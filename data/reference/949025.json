[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video",
        "document": "The above example shows how to use the element. Similar to the element, we include a path to the media we want to display inside the attribute; we can include other attributes to specify information such as video width and height, whether we want it to autoplay and loop, or to show the browser's default video controls, and so on. The content inside the opening and closing tags is shown as a fallback in browsers that don't support the element.\n\nLike all other HTML elements, this element supports the global attributes. A Boolean attribute; if specified, the video automatically begins to play back as soon as it can without stopping to finish loading the data. Note: Modern browsers block audio (or videos with an unmuted audio track) from autoplaying, as sites that automatically play audio can be an unpleasant experience for users. See our autoplay guide for additional information about how to properly use autoplay. To disable video autoplay, will not work; the video will autoplay if the attribute is there in the tag at all. To remove autoplay, the attribute needs to be removed altogether. If this attribute is present, the browser will offer controls to allow the user to control video playback, including volume, seeking, and pause/resume playback. The attribute, when specified, helps the browser select what controls to show for the element whenever the browser shows its own set of controls (that is, when the attribute is specified). The allowed values are , and . Use the attribute if you want to disable the Picture-In-Picture mode (and the control). This enumerated attribute indicates whether to use CORS to fetch the related video. CORS-enabled resources can be reused in the element without being tainted. The allowed values are: Sends a cross-origin request without a credential. In other words, it sends the HTTP header without a cookie, X.509 certificate, or performing HTTP Basic authentication. If the server does not give credentials to the origin site (by not setting the HTTP header), the resource will be tainted, and its usage restricted. Sends a cross-origin request with a credential. In other words, it sends the HTTP header with a cookie, a certificate, or performing HTTP Basic authentication. If the server does not give credentials to the origin site (through HTTP header), the resource will be tainted and its usage restricted. When not present, the resource is fetched without a CORS request (i.e. without sending the HTTP header), preventing its non-tainted use in elements. If invalid, it is handled as if the enumerated keyword was used. See CORS settings attributes for additional information. Prevents the browser from suggesting a Picture-in-Picture context menu or to request Picture-in-Picture automatically in some cases. A Boolean attribute used to disable the capability of remote playback in devices that are attached using wired (HDMI, DVI, etc.) and wireless technologies (Miracast, Chromecast, DLNA, AirPlay, etc.). In Safari, you can use as a fallback. The height of the video's display area, in CSS pixels (absolute values only; no percentages). A Boolean attribute; if specified, the browser will automatically seek back to the start upon reaching the end of the video. A Boolean attribute that indicates the default audio mute setting contained in the video. If set, the audio will be initially silenced. Its default value is , meaning the audio will be played when the video is played. A Boolean attribute indicating that the video is to be played \"inline\", that is, within the element's playback area. Note that the absence of this attribute does not imply that the video will always be played in fullscreen. A URL for an image to be shown while the video is downloading. If this attribute isn't specified, nothing is displayed until the first frame is available, then the first frame is shown as the poster frame. This enumerated attribute is intended to provide a hint to the browser about what the author thinks will lead to the best user experience regarding what content is loaded before the video is played. It may have one of the following values:\n• : Indicates that the video should not be preloaded.\n• : Indicates that only video metadata (e.g. length) is fetched.\n• : Indicates that the whole video file can be downloaded, even if the user is not expected to use it.\n• empty string: A synonym of the value. The default value is different for each browser. The spec advises it to be set to .\n• The attribute has precedence over . If is specified, the browser would obviously need to start downloading the video for playback.\n• The specification does not force the browser to follow the value of this attribute; it is a mere hint. The URL of the video to embed. This is optional; you may instead use the element within the video block to specify the video to embed. The width of the video's display area, in CSS pixels (absolute values only; no percentages).\n\nYou can detect when tracks are added to and removed from a element using the and events. However, these events aren't sent directly to the element itself. Instead, they're sent to the track list object within the element's that corresponds to the type of track that was added to the element: An containing all of the media element's audio tracks. Add a listener for to this object to be notified when new audio tracks are added to the element. A containing all of the media element's video tracks. Add an listener to this object to be notified when video tracks are added to the element. A containing all of the media element's text tracks (which are used for subtitles, closed captions, and so on). Add an listener to this object to be notified when text tracks are added to the element. For example, to detect when audio tracks are added to or removed from a element, you can use code like this: This code watches for audio tracks to be added to and removed from the element, and calls a hypothetical function on a track editor to register and remove the track from the editor's list of available tracks. You can also use to listen for the and events.\n\nIf the MIME type for the video is not set correctly on the server, the video may not show or show a gray box containing an X (if JavaScript is enabled). If you use Apache Web Server to serve WebM videos, you can fix this problem by adding the video file type extensions to the MIME type (the most common WebM file extension is ). To do this, edit the file in or use the configuration directive in : Your web host may provide an easy interface to MIME type configuration changes for new technologies until a global update naturally occurs.\n\nThis example builds on the last one, offering three different sources for the media; this allows the video to be watched regardless of which video codecs are supported by the browser. <!-- Using multiple sources as fallbacks for a video tag --> <!-- 'Elephants Dream' by Orange Open Movie Project Studio, licensed under CC-3.0, hosted by archive.org --> <!-- Poster hosted by Wikimedia --> <video width=\"620\" controls poster=\"https://upload.wikimedia.org/wikipedia/commons/e/e8/Elephants_Dream_s5_both.jpg\"> <source src=\"https://archive.org/download/ElephantsDream/ed_hd.avi\" type=\"video/avi\" /> <source src=\"https://archive.org/download/ElephantsDream/ed_1024_512kb.mp4\" type=\"video/mp4\" /> Sorry, your browser doesn't support embedded videos, but don't worry, you can <a href=\"https://archive.org/download/ElephantsDream/ed_1024_512kb.mp4\" download=\"ed_1024_512kb.mp4\"> download the MP4 </a> and watch it with your favorite video player! </video> First AVI is tried. If that can't be played, MP4 is tried. A fallback message is displayed if the video element isn't supported, but not if all sources fail. Some media file types let you provide more specific information using the parameter as part of the file's type string. For example, says that the file is a WebM video using VP8 for its video and Vorbis for audio."
    },
    {
        "link": "https://stackoverflow.com/questions/70719678/html5-video-autoplay-with-sound-unmuted",
        "document": "adding a \"hacky\" solution: Basically what the policy means is that a user must interact with the site before audio can play.\n\nwith this assumption, we can autoplay video with sound in two ways:\n\nthe first one, and the fairest one to the user, is to create a landing page when in it he has to interact with your site to begin using it or to click on something that says that he allows you to play sound.\n\nthe second one (and the a bit more 'hacky' one) is to add an invisible with a .mp3 file (that will be silent) and . this will trick the browser to autoplay any subsequent video even if it's unmuted.\n\nit will look like this:\n\nFor Electron - you need to bypass autoplay policy:\n\nUnfortunately, there is no real solution for this. it is aimed to protect the user and there is no workaround for that. There are some browsers where autoplaying with sound does work. but for most of them it won't work, and that is GOOD!.\n\nsince April 2018 you cannot autoplay with sound on chrome unless one of the following is happening (as seen on google's autoplay policy):\n• Autoplay with sound is allowed if:\n• User has interacted with the domain (click, tap, etc.).\n• On desktop, the user's Media Engagement Index threshold has been crossed, meaning the user has previously played a video with sound.\n• On mobile, the user has added the site to his or her home screen.\n• Top frames can delegate autoplay permission to their iframes to allow autoplay with sound.\n\nyou can read more about it here"
    },
    {
        "link": "http://w3schools.com/TAGs/att_video_autoplay.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/autoplay",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 .\n\nThe property reflects the HTML attribute, indicating whether playback should automatically begin as soon as enough media is available to do so without interruption.\n\nA media element whose source is a and whose property is will begin playback when it becomes active (that is, when becomes ).\n\nNote: Sites which automatically play audio (or videos with an audio track) can be an unpleasant experience for users, so it should be avoided when possible. If you must offer autoplay functionality, you should make it opt-in (requiring a user to specifically enable it). However, autoplay can be useful when creating media elements whose source will be set at a later time, under user control.\n\nFor a much more in-depth look at autoplay, autoplay blocking, and how to respond when autoplay is blocked by the user's browser, see our article Autoplay guide for media and Web Audio APIs."
    },
    {
        "link": "https://imagekit.io/blog/html-video-autoplay",
        "document": "Autoplay is a common feature associated with web video. It allows multimedia content to begin playing automatically on page load without user interaction. For scenarios where immediate playback is beneficial (think background videos, or product demonstrations), the autoplay attribute ensures a smooth and user-friendly experience – your users don’t need to interrupt their browsing of a product to click a \"play\" button somewhere off to the side.\n\nIn this blog post, we'll delve into the topic of autoplay, exploring how this feature has revolutionized online content delivery, the pitfalls to avoid, and pairing it with ImageKit to make autoplay an asset (and not an annoyance!) for your website.\n\nIn the past, to achieve such automatic video playback, developers had to use JavaScript to manipulate the video player. With HTML5, you can simply set the element’s autoplay attribute (a boolean value) to specify that the video should start playing on page load, without the user specifically requesting playback.\n\nThis is a streamlined API that eliminates the need for JavaScript, complex embedding techniques, or third-party plugins, making it easier than ever to add video content to your website.\n\nWe’ve covered the specifics of HTML5 video here, so read up on that as a refresher. This post is going to focus entirely on the technical aspects of autoplay.\n\nThe basic HTML5 structure for an auto-playing video looks like this:\n\nWhat happens when you set the property to true? Now, the following series of checks will take place:\n• “Is the page allowed to use ?” – This might be unintuitive, but simply including the attribute might not be enough, as most browsers have their own set of conditions to check if autoplay can be allowed. These include checking if the media has an audio track, if the user has interacted with the page yet, etc. We'll talk more about these checks in a later section.\n• “Was the element created during page load?” – As in, not inserted programmatically later. Again, this makes sense as a guardrail against malicious intent.\n• “Has a large enough chunk of the video been downloaded to begin and continue playback?” – This doesn’t mean the entire video must be downloaded before it can begin, just the minimum chunk needed to play something, and then download the rest as it plays through to the end. Notably, this check does not take into account network interruptions or unexpected bandwidth changes in the middle of playback.\n\nAs long as all three are true, the video will begin to autoplay.\n\nFleshing out our snippet with CSS and the attribute to add basic video player controls, here’s what it would look like in action, on a real webpage. You can check out the full code at this CodeSandBox here.\n\n\n\nWhat are the benefits of HTML video autoplay?\n\nHTML video autoplay offers several benefits when used thoughtfully. Some of these include:\n• Boosting Engagement with Content: Autoplay immediately draws the user's attention to a video when they land on a webpage, perfect for showcasing engaging, new, or featured content. For example, Netflix autoplays trailers for hot and happening movies and shows as soon as you arrive. Users get a taste of the content this way and continue watching, consider subscribing, or consider staying subscribed.\n• Reducing Bounce Rates with Seamless Navigation: Autoplay allows users to preview video content without having to manually click \"play.\" YouTube, for example, often auto-plays related videos right after you finish watching one. This keeps the user invested with a steady stream of multimedia content, and when users encounter more videos that match their interests, they are more likely to stay on the website for longer periods, reducing bounce rates.\n• Promotions and Storytelling: On Amazon, you’ll often see bite-sized autoplaying videos as banners to announce limited-time discounts or special offers. Conversely, a website for a non-profit or charity might autoplay a video on their landing page that showcases testimonials or the impact of their work, invoking emotions, establishing trust, and encouraging support.\n• Product Demos and Tutorials: E-commerce websites employ autoplay to showcase product demos or tutorials. As users navigate to a product page, an explainer video can begin showcasing the item in use, highlighting the product's features and benefits. This helps users make informed purchase decisions.\n• Design and Aesthetics: Autoplaying videos can run in silent background loops that add a dynamic and aesthetic element to your website. Consider a fashion brand's website with a subtle, looping animation of models walking down the runway, creating an aesthetic consistent with the brand. Or, autoplaying videos integrated into parallax scrolling, creating an immersive effect as users scroll down the page.\n\nWhile autoplaying videos offer several advantages, it is critical to tread carefully with their implementation. If overused, or not correctly implemented, autoplay can actively harm the user experience (and accessibility) instead of enhancing it, and become disruptive and annoying. On mobile devices, misuse of autoplaying videos is even more intrusive due to limited screen real estate.\n\nMoreover, there’s the issue of unoptimized, full-quality videos on autoplay that burn through data and battery, leading to slow loading times and lower PageSpeed Rankings.\n\nTo prevent this, consider using autoplay only in specific situations - where it adds value, such as for video previews, product showcases, or promotions. Judicial use is the secret sauce to autoplay.\n\nMost modern web browsers support the HTML video autoplay attribute. However, the behavior of autoplay may vary depending on the browser, and you need to meet certain conditions for it to work consistently.\n\nFirst of all, here’s the current state of popular browser compatibility for the HTML5 attribute.\n\n\n\nData: HTML element: video: autoplay | Can I use... Support tables for HTML5, CSS3, etc\n\nSecondly, it’s imperative to note that autoplay policies have evolved to enhance user experience and prevent intrusive or data-consuming behavior. Autoplay policies are different for each browser.\n• Google Chrome: Chrome has specific criteria for allowing autoplay with sound. These include:\n• User Interaction: Autoplay with sound is permitted on domains where the user has previously interacted.\n• Previous Media Playback: If the user has played a video with sound on an active tab before, autoplay with sound is allowed.\n• Mobile Engagement: For mobile users, if they have added the site to their home screen or installed the site’s Progressive Web App (PWA), autoplay with sound is permitted.\n• Media Engagement Index (MEI): Chrome uses a metric called the Media Engagement Index to determine if videos should autoplay with sound. The MEI calculates this based on various factors, including the history of the user's interactions with media on the site.\n• Mozilla Firefox: Firefox has a stricter autoplay policy. It generally blocks autoplay unless the audio is muted (or has its volume set to 0), the user has interacted with the site or the video element before, or the site has been explicitly whitelisted by the user.\n• Apple Safari/Webkit: Apple’s policy uses an Automatic Inference Engine to block media elements with sound from auto-playing by default on most websites, but it gives granular control to users regarding whitelisting websites that are allowed to autoplay media content. Notably, Safari’s power saving mode prevents silent videos from autoplaying when hidden, in a background tab, or offscreen.\n• Microsoft Edge: Starting with version 92, Edge follows a similar approach to Chrome, disabling autoplay with sound for all videos by default, while allowing some based on domains that users have interacted with previously.\n• Opera: Opera's autoplay policy is the same as Chrome and Edge, being based on the same engine. It uses user interaction as a metric to determine whether a video should play with sound.\n\nYou should test on different browsers, and verify that your autoplaying videos work across them by taking account of the differences in browser behavior.\n\nHow to use HTML5 video autoplay with ImageKit?\n\nImageKit is an all-in-one, cloud-based, digital asset management solution that can perform real-time video (and image) optimization and transformation via a unique URL-based API that makes it easier to adapt your autoplaying videos for various devices and platforms. Then, with ImageKit’s global CDN, you can be sure they’re served from as close as possible to your users, letting you create seamless and interactive video experiences without getting caught up in the details.\n\nOne of ImageKit's standout features is its developer-friendly URL-based API. The API allows you to adapt videos on the fly – resizing, cropping, trimming, adjusting their quality in real time (and more) to suit different devices, screen sizes, and bandwidths.\n\nUnoptimized, full-sized videos are the worst offenders when it comes to bad implementations of autoplay. To fix this, you’d normally need to create different variations of the same video, for different devices. With ImageKit, though, you avoid all of that work. Starting with a single source video, you can crop and resize them to pixel-perfect dimensions for different devices, or even different social media platforms – 16:9 for desktop viewers, square 1:1 for your mobile audiences or Instagram/Facebook feeds, or any arbitrary dimension based on your needs.\n\nSimply add on the transforms you want to your video’s public URL, as query or path params. For example, here’s how easy it is to resize a source 1080p video to a 300px square one.\n\nNeed a specific aspect ratio? Use the aspect ratio transform. This is for a 4:3 aspect ratio with a width of 480px.\n\nWhat if you have a longer video and you want a short, looping snippet (say, starting at the 5-second mark, and lasting 5 seconds) to be played in a banner? You could use the trim transform.\n\nWhere so is the start time and du the duration, in seconds.\n\nIn fact, you could chain however many transformations you want to apply, in order, just like this.\n\nNow, you can use this URL as the source wherever you want it to autoplay on your website or app.\n\nImageKit’s Transformation API proves invaluable for ensuring that your autoplay videos can be tailor-made for different user scenarios, devices, and platforms – all dynamically, and all from a single source video.\n\nImageKit automatically makes sure the most appropriate format for a given source video is served to your users – no matter which device or platform they’re consuming it from. All you need to do is turn on Automatic Format Conversion in the ImageKit dashboard and use the public URL to the video wherever you want, as usual. No need to manually create any variants yourself.\n\nImageKit can also automatically optimize video files to create a good enough balance between file size and image quality. This is a non-destructive process, and your source video is always intact. Again, this is another dashboard toggle – turn on Automatic Quality Optimization, tune the quality factor as desired, and you’re good to go.\n\nImageKit's video transformation capabilities extend beyond basic optimization. You can personalize your videos by applying image, text, and video overlays, subtitles, and watermarks in multiple layers. For example, you can add your company's logo as a watermark to your autoplay videos, enhancing branding and engagement. Additionally, you can apply transforms even to these overlays you apply, to further tune them however you need.\n\nHTML video autoplay is a powerful tool for enhancing user engagement and storytelling on your website, but you need to employ it judiciously, considering user preferences and ensuring the content aligns with your website's purpose. Consider some best practices like:\n• Mute by Default: Mute your Autoplay videos (via the muted property) by default to prevent audio from startling or annoying users. If you use the loop attribute, ensure the video content is short in addition to being muted by default.\n• Use ImageKit: Use ImageKit to dynamically optimize, transcode, and transform your video files to best fit your viewers’ devices, and your own needs. This ensures your viewers get the best quality at the best possible file sizes, reducing loading times and data usage.\n• Inform Users: Communicate the presence of autoplay video on your website via a clearly visible container and play button. Then, delay the autoplay feature slightly to give users time to orient themselves on the page.\n• Browser Compatibility: Test autoplay behavior across different browsers, as some may have specific policies or limitations on autoplaying videos. Also, test different autoplay strategies to see what works best for your specific audience.\n• Don’t Ignore Accessibility: Provide descriptive alt text for the autoplaying video and captions (using the <track> element). This benefits users with visual or hearing impairments who rely on screen readers/text-to-speech.\n\nCombining these autoplay strategies effectively with ImageKit, you can provide an enriched and dynamic web experience for your visitors, all while ensuring that your videos are optimized for performance and quality, and personalized to meet your unique requirements.\n\nRemember that the key to success with HTML5 video autoplay is judicious usage and a user-friendly and responsible implementation."
    },
    {
        "link": "https://css-tricks.com/snippets/css/a-guide-to-flexbox",
        "document": "The (Flexible Box) module (a W3C Candidate Recommendation as of October 2017) aims at providing a more efficient way to lay out, align and distribute space among items in a container, even when their size is unknown and/or dynamic (thus the word “flex”). The main idea behind the flex layout is to give the container the ability to alter its items’ width/height (and order) to best fill the available space (mostly to accommodate to all kind of display devices and screen sizes). A flex container expands items to fill available free space or shrinks them to prevent overflow. Most importantly, the flexbox layout is direction-agnostic as opposed to the regular layouts (block which is vertically-based and inline which is horizontally-based). While those work well for pages, they lack flexibility (no pun intended) to support large or complex applications (especially when it comes to orientation changing, resizing, stretching, shrinking, etc.). Note: Flexbox layout is most appropriate to the components of an application, and small-scale layouts, while the Grid layout is intended for larger scale layouts.\n\nSince flexbox is a whole module and not a single property, it involves a lot of things including its whole set of properties. Some of them are meant to be set on the container (parent element, known as “flex container”) whereas the others are meant to be set on the children (said “flex items”). If “regular” layout is based on both block and inline flow directions, the flex layout is based on “flex-flow directions”. Please have a look at this figure from the specification, explaining the main idea behind the flex layout. Items will be laid out following either the (from to ) or the cross axis (from to ).\n• main axis – The main axis of a flex container is the primary axis along which flex items are laid out. Beware, it is not necessarily horizontal; it depends on the property (see below).\n• main-start | main-end – The flex items are placed within the container starting from main-start and going to main-end.\n• main size – A flex item’s width or height, whichever is in the main dimension, is the item’s main size. The flex item’s main size property is either the ‘width’ or ‘height’ property, whichever is in the main dimension.\n• cross axis – The axis perpendicular to the main axis is called the cross axis. Its direction depends on the main axis direction.\n• cross-start | cross-end – Flex lines are filled with items and placed into the container starting on the cross-start side of the flex container and going toward the cross-end side.\n• cross size – The width or height of a flex item, whichever is in the cross dimension, is the item’s cross size. The cross size property is whichever of ‘width’ or ‘height’ that is in the cross dimension.\n\nThis defines a flex container; inline or block depending on the given value. It enables a flex context for all its direct children. Note that CSS columns have no effect on a flex container. \n\nThis establishes the main-axis, thus defining the direction flex items are placed in the flex container. Flexbox is (aside from optional wrapping) a single-direction layout concept. Think of flex items as primarily laying out either in horizontal rows or vertical columns.\n• (default): left to right in ; right to left in\n• : right to left in ; left to right in\n• : same as but top to bottom\n• : same as but bottom to top By default, flex items will all try to fit onto one line. You can change that and allow the items to wrap as needed with this property.\n• (default): all flex items will be on one line\n• : flex items will wrap onto multiple lines, from top to bottom.\n• : flex items will wrap onto multiple lines from bottom to top. There are some visual demos of here. This is a shorthand for the and properties, which together define the flex container’s main and cross axes. The default value is . \n\nThis defines the alignment along the main axis. It helps distribute extra free space leftover when either all the flex items on a line are inflexible, or are flexible but have reached their maximum size. It also exerts some control over the alignment of items when they overflow the line.\n• (default): items are packed toward the start of the flex-direction.\n• : items are packed toward the end of the flex-direction.\n• : items are packed toward the start of the direction.\n• : items are packed toward the end of the direction.\n• : items are packed toward left edge of the container, unless that doesn’t make sense with the , then it behaves like .\n• : items are packed toward right edge of the container, unless that doesn’t make sense with the , then it behaves like .\n• : items are centered along the line\n• : items are evenly distributed in the line; first item is on the start line, last item on the end line\n• : items are evenly distributed in the line with equal space around them. Note that visually the spaces aren’t equal, since all the items have equal space on both sides. The first item will have one unit of space against the container edge, but two units of space between the next item because that next item has its own spacing that applies.\n• : items are distributed so that the spacing between any two items (and the space to the edges) is equal. Note that that browser support for these values is nuanced. For example, never got support from some versions of Edge, and start/end/left/right aren’t in Chrome yet. MDN has detailed charts. The safest values are , , and . There are also two additional keywords you can pair with these values: and . Using ensures that however you do this type of positioning, you can’t push an element such that it renders off-screen (e.g. off the top) in such a way the content can’t be scrolled too (called “data loss”). \n\nThis defines the default behavior for how flex items are laid out along the cross axis on the current line. Think of it as the version for the cross-axis (perpendicular to the main-axis).\n• / / : items are placed at the start of the cross axis. The difference between these is subtle, and is about respecting the rules or the rules.\n• / / : items are placed at the end of the cross axis. The difference again is subtle and is about respecting rules vs. rules.\n• : items are centered in the cross-axis\n• : items are aligned such as their baselines align The and modifier keywords can be used in conjunction with all the rest of these keywords (although note browser support), and deal with helping you prevent aligning elements such that the content becomes inaccessible. \n\nThis aligns a flex container’s lines within when there is extra space in the cross-axis, similar to how aligns individual items within the main-axis. Note: This property only takes effect on multi-line flexible containers, where is set to either or ). A single-line flexible container (i.e. where is set to its default value, ) will not reflect .\n• (default): items are packed in their default position as if no value was set.\n• / : items packed to the start of the container. The (more supported) honors the while honors the direction.\n• / : items packed to the end of the container. The (more support) honors the while end honors the direction.\n• : items evenly distributed; the first line is at the start of the container while the last one is at the end\n• : items evenly distributed with equal space around each line\n• : items are evenly distributed with equal space around them\n• : lines stretch to take up the remaining space The and modifier keywords can be used in conjunction with all the rest of these keywords (although note browser support), and deal with helping you prevent aligning elements such that the content becomes inaccessible. The property explicitly controls the space between flex items. It applies that spacing only between items not on the outer edges. The behavior could be thought of as a minimum gutter, as if the gutter is bigger somehow (because of something like ) then the gap will only take effect if that space would end up smaller. It is not exclusively for flexbox, works in grid and multi-column layout as well. \n\nBy default, flex items are laid out in the source order. However, the property controls the order in which they appear in the flex container. Items with the same revert to source order. \n\nThis defines the ability for a flex item to grow if necessary. It accepts a unitless value that serves as a proportion. It dictates what amount of the available space inside the flex container the item should take up. If all items have set to , the remaining space in the container will be distributed equally to all children. If one of the children has a value of , that child would take up twice as much of the space as either one of the others (or it will try, at least). This defines the ability for a flex item to shrink if necessary. This defines the default size of an element before the remaining space is distributed. It can be a length (e.g. 20%, 5rem, etc.) or a keyword. The keyword means “look at my width or height property” (which was temporarily done by the keyword until deprecated). The keyword means “size it based on the item’s content” – this keyword isn’t well supported yet, so it’s hard to test and harder to know what its brethren , , and do. If set to , the extra space around content isn’t factored in. If set to , the extra space is distributed based on its value. See this graphic. This is the shorthand for and combined. The second and third parameters ( and ) are optional. The default is , but if you set it with a single number value, like , that changes the to 0%, so it’s like setting . It is recommended that you use this shorthand property rather than set the individual properties. The shorthand sets the other values intelligently. \n\nThis allows the default alignment (or the one specified by ) to be overridden for individual flex items. Please see the explanation to understand the available values. Note that , and have no effect on a flex item.\n\nFlexbox requires some vendor prefixing to support the most browsers possible. It doesn’t just include prepending properties with the vendor prefix, but there are actually entirely different property and value names. This is because the Flexbox spec has changed over time, creating an “old”, “tweener”, and “new” versions. Perhaps the best way to handle this is to write in the new (and final) syntax and run your CSS through Autoprefixer, which handles the fallbacks very well. Alternatively, here’s a Sass to help with some of the prefixing, which also gives you an idea of what kind of things need to be done:\n\nLet’s start with a very very simple example, solving an almost daily problem: perfect centering. It couldn’t be any simpler if you use flexbox. .parent { display: flex; height: 300px; /* Or whatever */ } .child { width: 100px; /* Or whatever */ height: 100px; /* Or whatever */ margin: auto; /* Magic! */ } This relies on the fact a margin set to in a flex container absorb extra space. So setting a margin of will make the item perfectly centered in both axes. Now let’s use some more properties. Consider a list of 6 items, all with fixed dimensions, but can be auto-sized. We want them to be evenly distributed on the horizontal axis so that when we resize the browser, everything scales nicely, and without media queries. .flex-container { /* We first create a flex layout context */ display: flex; /* Then we define the flow direction and if we allow the items to wrap * Remember this is the same as: * flex-direction: row; * flex-wrap: wrap; */ flex-flow: row wrap; /* Then we define how is distributed the remaining space */ justify-content: space-around; } Done. Everything else is just some styling concern. Below is a pen featuring this example. Be sure to go to CodePen and try resizing your windows to see what happens. Let’s try something else. Imagine we have a right-aligned navigation element on the very top of our website, but we want it to be centered on medium-sized screens and single-columned on small devices. Easy enough. /* Large */ .navigation { display: flex; flex-flow: row wrap; /* This aligns items to the end line on main-axis */ justify-content: flex-end; } /* Medium screens */ @media all and (max-width: 800px) { .navigation { /* When on medium sized screens, we center it by evenly distributing empty space around items */ justify-content: space-around; } } /* Small screens */ @media all and (max-width: 500px) { .navigation { /* On small screens, we are no longer using row direction but column */ flex-direction: column; } } Let’s try something even better by playing with flex items flexibility! What about a mobile-first 3-columns layout with full-width header and footer. And independent from source order. .wrapper { display: flex; flex-flow: row wrap; } /* We tell all items to be 100% width, via flex-basis */ .wrapper > * { flex: 1 100%; } /* We rely on source order for mobile-first approach * in this case: * 1. header * 2. article * 3. aside 1 * 4. aside 2 * 5. footer */ /* Medium screens */ @media all and (min-width: 600px) { /* We tell both sidebars to share a row */ .aside { flex: 1 auto; } } /* Large screens */ @media all and (min-width: 800px) { /* We invert order of first sidebar and main * And tell the main element to take twice as much width as the other two sidebars */ .main { flex: 3 0px; } .aside-1 { order: 1; } .main { order: 2; } .aside-2 { order: 3; } .footer { order: 4; } }"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_flexible_box_layout/Basic_concepts_of_flexbox",
        "document": "The flexible box layout module (usually referred to as flexbox) is a one-dimensional layout model for distributing space between items and includes numerous alignment capabilities. This article gives an outline of the main features of flexbox, which we will explore in more detail in the rest of these guides. When we describe flexbox as being one-dimensional we are describing the fact that flexbox deals with layout in one dimension at a time — either as a row or as a column. This can be contrasted with the two-dimensional model of CSS Grid Layout, which controls columns and rows together.\n\nAnother vital area of understanding is how flexbox makes no assumption about the writing mode of the document. Flexbox doesn't just assume that all lines of text start at the top left of a document and run towards the right-hand side, with new lines appearing one under the other. Rather, it supports all writing modes, like other logical properties and values. You can read more about the relationship between flexbox and writing modes in a later article; however, the following description should help explain why we do not talk about left and right and top and bottom when we describe the direction that our flex items flow in. If the is and I am working in English, then the start edge of the main axis will be on the left, the end edge on the right. If I were to work in Arabic, then the start edge of my main axis would be on the right and the end edge on the left. In both cases the start edge of the cross-axis is at the top of the flex container and the end edge at the bottom, as both languages have a horizontal writing mode. After a while, thinking about start and end rather than left and right becomes natural, and will be useful to you when dealing with other layout methods such as CSS Grid Layout which follow the same patterns.\n\nWhile flexbox is a one dimensional model, it is possible to make flex items wrap across multiple lines. If you do this, you should consider each line as a new flex container. Any space distribution will happen across each line, without reference to the previous or subsequent lines. To cause wrapping behavior add the property with a value of . Now, if your items are too large to all display in one line, they will wrap onto another line. The live sample below contains items that have been given a . The total width of the items is too wide for the flex container. As is set to , the items wrap across multiple lines. If you set it to , which is the initial value, they will shrink to fit the container. They shrink because they are using initial flexbox values, including , that allows items to shrink. Using would cause an overflow if the items were not able to shrink, or could not shrink small enough to fit. Find out more about wrapping flex items in the guide Mastering wrapping of flex items.\n\nTo control the inline-size of each flex item, we target them directly via three properties: We will take a brief look at these properties below, but if you want more comprehensive information, take a look at the Controlling ratios of flex items on the main axis guide. Before we can make sense of these properties we need to consider the concept of available space. What we are doing when we change the value of these flex properties is to change the way that available space is distributed amongst our items. This concept of available space is also important when we come to look at aligning items. If we have three 100 pixel-wide items in a container which is 500 pixels wide, then the space we need to lay out our items is 300 pixels. This leaves 200 pixels of available space. If we don't change the initial values then flexbox will put that space after the last item. If we instead would like the items to grow and fill the space, then we need to have a method of distributing the leftover space between the items. The properties that we apply to the items themselves, enable dictating how that available space should be distributed among the sibling flex items.\n\nWith the property set to a positive integer, if there is available space, the flex item can grow along the main axis from its . Whether the item stretches to take up all the available space on that axis, or just a portion of the available space depends on if the other items are allowed to grow too and the value of their properties. Each item with a positive value consumes a portion of any available space based on their value. If we gave all of our items in the example above a value of 1 then the available space in the flex container would be equally shared between our items and they would stretch to fill the container on the main axis. If we give our first item a value of 2, and the other items a value of 1 each, there are a total of 4 parts; 2 parts of the available space will be given to the first item (100px out of 200px in the case of the example above) and 1 part each the other two (50px each out of the 200px total).\n\nWhere the property deals with adding space in the main axis, the property controls how it is taken away. If we do not have enough space in the container to lay out our items, and is set to a positive integer, then the item can become smaller than the . As with , different values can be assigned in order to cause one item to shrink faster than others — an item with a higher value set for will shrink faster than its siblings that have lower values. An item can shrink down to its size. This minimum size is taken into account while working out the actual amount of shrinkage that will happen, which means that has the potential to appear less consistent than in behavior. We'll therefore take a more detailed look at how this algorithm works in the article Controlling ratios of items along the main axis. Note: These values for and are proportions. Typically if we had all of our items set to and then wanted one item to grow at twice the rate, we would set that item to . However you could also use and if you wanted.\n\nYou will very rarely see the , , and properties used individually; instead they are combined into the shorthand. The shorthand allows you to set the three values in this order — , , . The live sample below allows you to test out the different values of the flex shorthand; remember that the first value is . Giving this a positive value means the item can grow. The second is — with a positive value the items can shrink, but only if their total values overflow the main axis. The final value is ; this is the value the items are using as their base value to grow and shrink from. .box > * { border: 2px solid rgb(96 139 168); border-radius: 5px; background-color: rgb(96 139 168 / 0.2); } .box { border: 2px dotted rgb(96 139 168); display: flex; } .one { flex: 1 1 auto; } .two { flex: 1 1 auto; } .three { flex: 1 1 auto; } There are also some predefined shorthand values which cover most of the use cases. You will often see these used in tutorials, and in many cases these are all you will need to use. The predefined values are as follows: The value is a CSS-wide keyword that represents the initial value for a property. Setting resets the item to the initial values of the three longhand properties, which is the same as . The initial value of is , so items will not grow larger than their size. The initial value of is , so items can shrink if they need to rather than overflowing. The initial value of is . Items will either use any size set on the item in the main dimension, or they will get their size from the content size. Using is the same as using ; this is similar to , except that the items can grow and fill the container as well as shrink if needed. Using will create fully inflexible flex items. It is as if you wrote . The items cannot grow or shrink and will be laid out using flexbox with a of . The shorthand you often see in tutorials is or and so on. This is the same as writing or and so on, respectively. The items get minimum size due to and then proportionally grow to fill the available space. In this case, the value of is redundant because the items start with minimum size — they're not given any size that could cause them to overflow the flex container. Try these shorthand values in the live sample below. .box > * { border: 2px solid rgb(96 139 168); border-radius: 5px; background-color: rgb(96 139 168 / 0.2); } .box { border: 2px dotted rgb(96 139 168); display: flex; } .one { flex: 1; } .two { flex: 1; } .three { flex: 1; }"
    },
    {
        "link": "https://w3schools.com/css/css3_flexbox.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/CSS_layout/Flexbox",
        "document": "In this article, you'll work through a series of exercises to help you understand how flexbox works. To get started, you should make a local copy of the HTML and CSS. Load it in a modern browser (like Firefox or Chrome) and have a look at the code in your code editor. Alternatively open the example in open the playground. body { font-family: sans-serif; margin: 0; } header { background: purple; height: 100px; } h1 { text-align: center; color: white; line-height: 100px; margin: 0; } section { zoom: 0.8; } article { padding: 10px; margin: 10px; background: aqua; } /* Add your flexbox CSS below here */ You'll see that we have a element with a top level heading inside it and a element containing three s. We're going to use these to create a fairly standard three column layout.\n\nSpecifying what elements to lay out as flexible boxes To start with, we need to select which elements are to be laid out as flexible boxes. To do this, we set a special value of on the parent element of the elements you want to affect. In this case we want to lay out the elements, so we set this on the : body { font-family: sans-serif; margin: 0; } header { background: purple; height: 100px; } h1 { text-align: center; color: white; line-height: 100px; margin: 0; } section { zoom: 0.8; } article { padding: 10px; margin: 10px; background: aqua; } /* Add your flexbox CSS below here */ This causes the element to become a flex container and its children become flex items. This is what it looks like: This single declaration gives us everything we need. Incredible, right? We have a multiple column layout with equal-sized columns, and the columns are all the same height. This is because the default values given to flex items (the children of the flex container) are set up to solve common problems such as this. Let's recap what's happening here. Adding a value of to an element makes it a flex container. The container is displayed as Block-level content in terms of how it interacts with the rest of the page. When the element is converted to a flex container, its children are converted to (and laid out as) flex items. You can make the container inline using an outside value (e.g., ), which affects how the container itself is laid out in the page. The legacy display value displays the container as inline as well. We'll focus on how the contents of the container behave in this tutorial, but if you want to see the effect of inline versus block layout, you can have a look at the value comparison on the property page. The next sections explain in more detail what flex items are and what happens inside an element when you make it a flex container.\n\nOne issue that arises when you have a fixed width or height in your layout is that eventually your flexbox children will overflow their container, breaking the layout. In the following example we have 5 s, which don't fit, because they have a of , so there is a horizontal scroll. Here we see that the children are indeed breaking out of their container. By default, the browser tries to place all the flex items in a single row if the is set to or a single column if the is set to . One way in which you can fix this is to add the following declaration to your rule: You'll see that the layout looks much better with this included: We now have multiple rows. Each row has as many flexbox children fitted into it as is sensible. Any overflow is moved down to the next line. The declaration set on the articles means that each will be at least wide. We'll discuss this property in more detail later on. You might also notice that the last few children on the last row are each made wider so that the entire row is still filled. But there's more we can do here. First of all, try changing your property value to . Now you'll see that you still have your multiple row layout, but it starts from the opposite corner of the browser window and flows in reverse.\n\nLet's now return to our first example and look at how we can control what proportion of space flex items take up compared to the other flex items. In your local copy, add the following rule to the bottom of your CSS: This is a unitless proportion value that dictates how much available space along the main axis each flex item will take up compared to other flex items. In this case, we're giving each element the same value (a value of ), which means they'll all take up an equal amount of the spare space left after properties like padding and margin have been set. This value is proportionally shared among the flex items: giving each flex item a value of would have exactly the same effect. Now add the following rule below the previous one: Now when you refresh, you'll see that the third takes up twice as much of the available width as the other two. There are now four proportion units available in total (since 1 + 1 + 2 = 4). The first two flex items have one unit each, so they each take 1/4 of the available space. The third one has two units, so it takes up 2/4 of the available space (or one-half). You can also specify a minimum size value within the flex value. Try updating your existing article rules like so: This basically states, \"Each flex item will first be given of the available space. After that, the rest of the available space will be shared according to the proportion units.\" You'll see a difference in how the space is shared. All the flex items have a minimum width of 100 pixels—set using 'flex'. The value of flex for first two flex items is 1 and for the third item is 2. This splits the remaining space in the flex container into 4 proportion units. One unit is assigned to each of the first two flex items and 2 units are assigned to the third flex item, making the third flex item wider than the other two, which are of the same width. The real value of flexbox can be seen in its flexibility/responsiveness. If you resize the browser window or add another element, the layout continues to work just fine.\n\nYou can also use flexbox features to align flex items along the main or cross axis. Let's explore this by looking at a new example: body { font-family: sans-serif; width: 90%; max-width: 960px; margin: 10px auto; } div { height: 100px; border: 1px solid black; } button { font-size: 18px; line-height: 1.5; width: 15%; } /* Add your flexbox CSS below here */ We're going to turn this into a neat, flexible button/toolbar. At the moment you'll see a horizontal menu bar with some buttons jammed into the top left-hand corner. First, take a local copy of this example. Now, add the following to the bottom of the example's CSS: body { font-family: sans-serif; width: 90%; max-width: 960px; margin: 10px auto; } div { height: 100px; border: 1px solid black; } button { font-size: 18px; line-height: 1.5; width: 15%; } /* Add your flexbox CSS below here */ Refresh the page and you'll see that the buttons are now nicely centered horizontally and vertically. We've done this via two new properties. The flex items are positioned at the center of the cross-axis by setting the property to . The flex items are spaced evenly along the main-axis by setting the property to . The property controls where the flex items sit on the cross axis.\n• By default, the value which behaves as in flexbox. This stretches all flex items to fill the parent in the direction of the cross axis. If the parent doesn't have a fixed size in the cross axis direction, then all flex items will become as tall (or wide) as the tallest (or widest) flex item. This is how our first example had columns of equal height by default.\n• The value that we used in our above code causes the items to maintain their intrinsic dimensions, but be centered along the cross axis. This is why our current example's buttons are centered vertically.\n• You can also have values like , or and , or , which will align all items at the start and end of the cross axis respectively. The values will line up the flex items by their baseline; basically the bottom of each flex items first line of text will be lined up with the bottom of the first line of the element with the greatest distance between the cross start and that baseline. See for the full details. You can override the behavior for individual flex items by applying the property to them. For example, try adding the following to your CSS: body { font-family: sans-serif; width: 90%; max-width: 960px; margin: 10px auto; } div { height: 100px; border: 1px solid black; } button { font-size: 18px; line-height: 1.5; width: 15%; } div { display: flex; align-items: center; justify-content: space-around; } /* Add your flexbox CSS below here */ Have a look at what effect this has and remove it again when you've finished. controls where the flex items sit on the main axis.\n• The default value is , which behaves as , which makes all the items sit at the start of the main axis.\n• You can use or to make them sit at the end.\n• The and values behave as or depending on the writing mode direction.\n• is also a value for . It'll make the flex items sit in the center of the main axis.\n• The value we've used above, , is useful — it distributes all the items evenly along the main axis with a bit of space left at either end.\n• There is another value, , which is very similar to except that it doesn't leave any space at either end. The property is ignored in flexbox layouts. We'd like to encourage you to play with these values to see how they work before you continue.\n\nFlexbox also has a feature for changing the layout order of flex items without affecting the source order. This is another thing that is impossible to do with traditional layout methods. Try adding the following CSS to your button bar example code: Refresh and you'll see that the \"Smile\" button has moved to the end of the main axis. Let's talk about how this works in a bit more detail:\n• By default, all flex items have an value of .\n• Flex items with higher specified order values will appear later in the display order than items with lower order values.\n• Flex items with the same order value will appear in their source order. So if you have four items whose order values have been set as , , , and respectively, their display order would be 4th, 2nd, 3rd, then 1st.\n• The 3rd item appears after the 2nd because it has the same order value and is after it in the source order. You can set negative order values to make items appear earlier than items whose value is . For example, you could make the \"Blush\" button appear at the start of the main axis using the following rule: While you can change the order using , the tabbing order remains the same as the code order. Changing the order of focusable elements can negatively impact usability for your keyboard users!"
    },
    {
        "link": "https://w3schools.com/css/css3_flexbox_responsive.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    }
]