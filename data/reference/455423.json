[
    {
        "link": "https://docs.python.org/3/library/os.html",
        "document": "This module provides a portable way of using operating system dependent functionality. If you just want to read or write a file see , if you want to manipulate paths, see the module, and if you want to read all the lines in all the files on the command line see the module. For creating temporary files and directories see the module, and for high-level file and directory handling see the module.\n\nNotes on the availability of these functions:\n• None The design of all built-in operating system dependent modules of Python is such that as long as the same functionality is available, it uses the same interface; for example, the function returns stat information about path in the same format (which happens to have originated with the POSIX interface).\n• None Extensions peculiar to a particular operating system are also available through the module, but using them is of course a threat to portability.\n• None All functions accepting path or file names accept both bytes and string objects, and result in an object of the same type, if a path or file name is returned.\n• None On VxWorks, os.popen, os.fork, os.execv and os.spawn*p* are not supported.\n• None On WebAssembly platforms, Android and iOS, large parts of the module are not available or behave differently. APIs related to processes (e.g. , ) and resources (e.g. ) are not available. Others like and are emulated or stubs. WebAssembly platforms also lack support for signals (e.g. , )."
    },
    {
        "link": "https://geeksforgeeks.org/python-os-listdir-method",
        "document": "The os.listdir() method in Python is used to get the list of all files and directories in the specified directory. If we don’t specify any directory, then a list of files and directories in the current working directory will be returned.\n\nBelow are some examples of Python os.listdir() method of the OS module:\n\nIn this example, the code uses os.listdir() to obtain a list of files and directories in the root directory (“/”). It then prints the obtained list. The output includes the files and directories present in the specified root Directory.\n\nIn this example, the code utilizes os.listdir() method to obtain a list of files and directories in the current working directory os.getcwd() method. It then prints the obtained list, providing information about the files and directories present in the current working directory.\n\nList All Files and Directories When No Path is Specified\n\nIn this example, the code uses os.listdir() to obtain a list of files and directories in the current working directory. It then prints the obtained list, providing information about the files and directories present in the current working directory. If no path is specified, it defaults to the current working directory.\n\nWhat do you understand by os.listdir() Method?"
    },
    {
        "link": "https://docs.python.org/2/library/os.html?highlight=listdir",
        "document": "This module provides a portable way of using operating system dependent functionality. If you just want to read or write a file see , if you want to manipulate paths, see the module, and if you want to read all the lines in all the files on the command line see the module. For creating temporary files and directories see the module, and for high-level file and directory handling see the module.\n\nNotes on the availability of these functions:\n• None The design of all built-in operating system dependent modules of Python is such that as long as the same functionality is available, it uses the same interface; for example, the function returns stat information about path in the same format (which happens to have originated with the POSIX interface).\n• None Extensions peculiar to a particular operating system are also available through the module, but using them is of course a threat to portability.\n• None An “Availability: Unix” note means that this function is commonly found on Unix systems. It does not make any claims about its existence on a specific operating system.\n• None If not separately noted, all functions that claim “Availability: Unix” are supported on Mac OS X, which builds on a Unix core.\n\nThese functions and data items provide information and operate on the current process and user. A mapping object representing the string environment. For example, is the pathname of your home directory (on some platforms), and is equivalent to in C. This mapping is captured the first time the module is imported, typically during Python startup as part of processing . Changes to the environment made after this time are not reflected in , except for changes made by modifying directly. If the platform supports the function, this mapping may be used to modify the environment as well as query the environment. will be called automatically when the mapping is modified. Calling directly does not change , so it’s better to modify . On some platforms, including FreeBSD and Mac OS X, setting may cause memory leaks. Refer to the system documentation for . If is not provided, a modified copy of this mapping may be passed to the appropriate process-creation functions to cause child processes to use a modified environment. If the platform supports the function, you can delete items in this mapping to unset environment variables. will be called automatically when an item is deleted from , and when one of the or methods is called. Changed in version 2.6: Also unset environment variables when calling and . These functions are described in Files and Directories. Return the filename corresponding to the controlling terminal of the process. Return the effective group id of the current process. This corresponds to the “set id” bit on the file being executed in the current process. Return the real group id of the current process. Return list of supplemental group ids associated with the current process. On Mac OS X, behavior differs somewhat from other Unix platforms. If the Python interpreter was built with a deployment target of or earlier, returns the list of effective group ids associated with the current user process; this list is limited to a system-defined number of entries, typically 16, and may be modified by calls to if suitably privileged. If built with a deployment target greater than , returns the current group access list for the user associated with the effective user id of the process; the group access list may change over the lifetime of the process, it is not affected by calls to , and its length is not limited to 16. The deployment target value, , can be obtained with . Call the system initgroups() to initialize the group access list with all of the groups of which the specified username is a member, plus the specified group id. Return the name of the user logged in on the controlling terminal of the process. For most purposes, it is more useful to use the environment variable to find out who the user is, or to get the login name of the process’s real user id. Return the process group id of the process with process id pid. If pid is 0, the process group id of the current process is returned. Return the id of the current process group. Return the value of the environment variable varname if it exists, or value if it doesn’t. value defaults to . Set the environment variable named varname to the string value. Such changes to the environment affect subprocesses started with , or and . On some platforms, including FreeBSD and Mac OS X, setting may cause memory leaks. Refer to the system documentation for putenv. When is supported, assignments to items in are automatically translated into corresponding calls to ; however, calls to don’t update , so it is actually preferable to assign to items of . Set the list of supplemental group ids associated with the current process to groups. groups must be a sequence, and each element must be an integer identifying a group. This operation is typically available only to the superuser. On Mac OS X, the length of groups may not exceed the system-defined maximum number of effective group ids, typically 16. See the documentation for for cases where it may not return the same group list set by calling setgroups(). Call the system call or depending on which version is implemented (if any). See the Unix manual for the semantics. Call the system call to set the process group id of the process with id pid to the process group with id pgrp. See the Unix manual for the semantics. Call the system call . See the Unix manual for the semantics. Call the system call . See the Unix manual for the semantics. Return the error message corresponding to the error code in code. On platforms where returns when given an unknown error number, is raised. Set the current numeric umask and return the previous umask. Return a 5-tuple containing information identifying the current operating system. The tuple contains 5 strings: . Some systems truncate the nodename to 8 characters or to the leading component; a better way to get the hostname is or even . Unset (delete) the environment variable named varname. Such changes to the environment affect subprocesses started with , or and . When is supported, deletion of items in is automatically translated into a corresponding call to ; however, calls to don’t update , so it is actually preferable to delete items of .\n\nThese functions create new file objects. (See also .) Return an open file object connected to the file descriptor fd. The mode and bufsize arguments have the same meaning as the corresponding arguments to the built-in function. If raises an exception, it leaves fd untouched (unclosed). Changed in version 2.3: When specified, the mode argument must now start with one of the letters , , or , otherwise a is raised. Changed in version 2.5: On Unix, when the mode argument starts with , the O_APPEND flag is set on the file descriptor (which the implementation already does on most platforms). Open a pipe to or from command. The return value is an open file object connected to the pipe, which can be read or written depending on whether mode is (default) or . The bufsize argument has the same meaning as the corresponding argument to the built-in function. The exit status of the command (encoded in the format specified for ) is available as the return value of the method of the file object, except that when the exit status is zero (termination without errors), is returned. Deprecated since version 2.6: This function is obsolete. Use the module. Check especially the Replacing Older Functions with the subprocess Module section. Changed in version 2.0: This function worked unreliably under Windows in earlier versions of Python. This was due to the use of the function from the libraries provided with Windows. Newer versions of Python do not use the broken implementation from the Windows libraries. Return a new file object opened in update mode ( ). The file has no directory entries associated with it and will be automatically deleted once there are no file descriptors for the file. There are a number of different functions that provide slightly different ways to create subprocesses. Deprecated since version 2.6: All of the functions are obsolete. Use the module. For each of the variants, if bufsize is specified, it specifies the buffer size for the I/O pipes. mode, if provided, should be the string or ; on Windows this is needed to determine whether the file objects should be opened in binary or text mode. The default value for mode is . Also, for each of these variants, on Unix, cmd may be a sequence, in which case arguments will be passed directly to the program without shell intervention (as with ). If cmd is a string it will be passed to the shell (as with ). These methods do not make it possible to retrieve the exit status from the child processes. The only way to control the input and output streams and also retrieve the return codes is to use the module; these are only available on Unix. For a discussion of possible deadlock conditions related to the use of these functions, see Flow Control Issues. Execute cmd as a sub-process and return the file objects . Deprecated since version 2.6: This function is obsolete. Use the module. Check especially the Replacing Older Functions with the subprocess Module section. Execute cmd as a sub-process and return the file objects . Deprecated since version 2.6: This function is obsolete. Use the module. Check especially the Replacing Older Functions with the subprocess Module section. Execute cmd as a sub-process and return the file objects . Deprecated since version 2.6: This function is obsolete. Use the module. Check especially the Replacing Older Functions with the subprocess Module section. This functionality is also available in the module using functions of the same names, but the return values of those functions have a different order.\n\nThese functions operate on I/O streams referenced using file descriptors. File descriptors are small integers corresponding to a file that has been opened by the current process. For example, standard input is usually file descriptor 0, standard output is 1, and standard error is 2. Further files opened by a process will then be assigned 3, 4, 5, and so forth. The name “file descriptor” is slightly deceptive; on Unix platforms, sockets and pipes are also referenced by file descriptors. The method can be used to obtain the file descriptor associated with a file object when required. Note that using the file descriptor directly will bypass the file object methods, ignoring aspects such as internal buffering of data. This function is intended for low-level I/O and must be applied to a file descriptor as returned by or . To close a “file object” returned by the built-in function or by or , use its method. Close all file descriptors from fd_low (inclusive) to fd_high (exclusive), ignoring errors. Equivalent to: Duplicate file descriptor fd to fd2, closing the latter first if necessary. Change the mode of the file given by fd to the numeric mode. See the docs for for possible values of mode. Change the owner and group id of the file given by fd to the numeric uid and gid. To leave one of the ids unchanged, set it to -1. Force write of file with filedescriptor fd to disk. Does not force update of metadata. This function is not available on MacOS. Return system configuration information relevant to an open file. name specifies the configuration value to retrieve; it may be a string which is the name of a defined system value; these names are specified in a number of standards (POSIX.1, Unix 95, Unix 98, and others). Some platforms define additional names as well. The names known to the host operating system are given in the dictionary. For configuration variables not included in that mapping, passing an integer for name is also accepted. If name is a string and is not known, is raised. If a specific value for name is not supported by the host system, even if it is included in , an is raised with for the error number. Return information about the filesystem containing the file associated with file descriptor fd, like . Force write of file with filedescriptor fd to disk. On Unix, this calls the native function; on Windows, the MS function. If you’re starting with a Python file object f, first do , and then do , to ensure that all internal buffers associated with f are written to disk. Truncate the file corresponding to file descriptor fd, so that it is at most length bytes in size. Return if the file descriptor fd is open and connected to a tty(-like) device, else . Set the current position of file descriptor fd to position pos, modified by how: or to set the position relative to the beginning of the file; or to set it relative to the current position; or to set it relative to the end of the file. Return the new cursor position in bytes, starting from the beginning. Parameters to the function. Their values are 0, 1, and 2, respectively. Open the file file and set various flags according to flags and possibly its mode according to mode. The default mode is (octal), and the current umask value is first masked out. Return the file descriptor for the newly opened file. For a description of the flag and mode values, see the C run-time documentation; flag constants (like and ) are defined in this module too (see open() flag constants). In particular, on Windows adding is needed to open files in binary mode. This function is intended for low-level I/O. For normal usage, use the built-in function , which returns a “file object” with and methods (and many more). To wrap a file descriptor in a “file object”, use . Open a new pseudo-terminal pair. Return a pair of file descriptors for the pty and the tty, respectively. For a (slightly) more portable approach, use the module. Create a pipe. Return a pair of file descriptors usable for reading and writing, respectively. Read at most n bytes from file descriptor fd. Return a string containing the bytes read. If the end of the file referred to by fd has been reached, an empty string is returned. This function is intended for low-level I/O and must be applied to a file descriptor as returned by or . To read a “file object” returned by the built-in function or by or , or , use its or methods. Return the process group associated with the terminal given by fd (an open file descriptor as returned by ). Set the process group associated with the terminal given by fd (an open file descriptor as returned by ) to pg. Return a string which specifies the terminal device associated with file descriptor fd. If fd is not associated with a terminal device, an exception is raised. Write the string str to file descriptor fd. Return the number of bytes actually written. This function is intended for low-level I/O and must be applied to a file descriptor as returned by or . To write a “file object” returned by the built-in function or by or , or or , use its method. The following constants are options for the flags parameter to the function. They can be combined using the bitwise OR operator . Some of them are not available on all platforms. For descriptions of their availability and use, consult the open(2) manual page on Unix or the MSDN on Windows. The above constants are available on Unix and Windows. The above constants are only available on Unix. The above constants are only available on Windows. The above constants are extensions and not present if they are not defined by the C library.\n\nUse the real uid/gid to test for access to path. Note that most operations will use the effective uid/gid, therefore this routine can be used in a suid/sgid environment to test if the invoking user has the specified access to path. mode should be to test the existence of path, or it can be the inclusive OR of one or more of , , and to test permissions. Return if access is allowed, if not. See the Unix man page access(2) for more information. Using to check if a user is authorized to e.g. open a file before actually doing so using creates a security hole, because the user might exploit the short time interval between checking and opening the file to manipulate it. It’s preferable to use EAFP techniques. For example: I/O operations may fail even when indicates that they would succeed, particularly for operations on network filesystems which may have permissions semantics beyond the usual POSIX permission-bit model. Value to pass as the mode parameter of to test the existence of path. Value to include in the mode parameter of to test the readability of path. Value to include in the mode parameter of to test the writability of path. Value to include in the mode parameter of to determine if path can be executed. Change the current working directory to the directory represented by the file descriptor fd. The descriptor must refer to an opened directory, not an open file. Set the flags of path to the numeric flags. flags may take a combination (bitwise OR) of the following values (as defined in the module): Change the root directory of the current process to path. Availability: Unix. Change the mode of path to the numeric mode. mode may take one of the following values (as defined in the module) or bitwise ORed combinations of them: Although Windows supports , you can only set the file’s read-only flag with it (via the and constants or a corresponding integer value). All other bits are ignored. Change the owner and group id of path to the numeric uid and gid. To leave one of the ids unchanged, set it to -1. Set the flags of path to the numeric flags, like , but do not follow symbolic links. Change the mode of path to the numeric mode. If path is a symlink, this affects the symlink rather than the target. See the docs for for possible values of mode. Change the owner and group id of path to the numeric uid and gid. This function will not follow symbolic links. Return a list containing the names of the entries in the directory given by path. The list is in arbitrary order. It does not include the special entries and even if they are present in the directory. Changed in version 2.3: On Windows NT/2k/XP and Unix, if path is a Unicode object, the result will be a list of Unicode objects. Undecodable filenames will still be returned as string objects. Perform the equivalent of an system call on the given path. Similar to , but does not follow symbolic links. On platforms that do not support symbolic links, this is an alias for . Create a FIFO (a named pipe) named path with numeric mode mode. The default mode is (octal). The current umask value is first masked out from the mode. FIFOs are pipes that can be accessed like regular files. FIFOs exist until they are deleted (for example with ). Generally, FIFOs are used as rendezvous between “client” and “server” type processes: the server opens the FIFO for reading, and the client opens it for writing. Note that doesn’t open the FIFO — it just creates the rendezvous point. Create a filesystem node (file, device special file or named pipe) named filename. mode specifies both the permissions to use and the type of node to be created, being combined (bitwise OR) with one of , , , and (those constants are available in ). For and , device defines the newly created device special file (probably using ), otherwise it is ignored. Extract the device major number from a raw device number (usually the or field from ). Extract the device minor number from a raw device number (usually the or field from ). Compose a raw device number from the major and minor device numbers. Create a directory named path with numeric mode mode. The default mode is (octal). If the directory already exists, is raised. On some systems, mode is ignored. Where it is used, the current umask value is first masked out. If bits other than the last 9 (i.e. the last 3 digits of the octal representation of the mode) are set, their meaning is platform-dependent. On some platforms, they are ignored and you should call explicitly to set them. It is also possible to create temporary directories; see the module’s function. Recursive directory creation function. Like , but makes all intermediate-level directories needed to contain the leaf directory. Raises an exception if the leaf directory already exists or cannot be created. The default mode is (octal). The mode parameter is passed to ; see the mkdir() description for how it is interpreted. will become confused if the path elements to create include . Changed in version 2.3: This function now handles UNC paths correctly. Return system configuration information relevant to a named file. name specifies the configuration value to retrieve; it may be a string which is the name of a defined system value; these names are specified in a number of standards (POSIX.1, Unix 95, Unix 98, and others). Some platforms define additional names as well. The names known to the host operating system are given in the dictionary. For configuration variables not included in that mapping, passing an integer for name is also accepted. If name is a string and is not known, is raised. If a specific value for name is not supported by the host system, even if it is included in , an is raised with for the error number. Dictionary mapping names accepted by and to the integer values defined for those names by the host operating system. This can be used to determine the set of names known to the system. Availability: Unix. Return a string representing the path to which the symbolic link points. The result may be either an absolute or relative pathname; if it is relative, it may be converted to an absolute pathname using . Changed in version 2.6: If the path is a Unicode object the result will also be a Unicode object. Remove (delete) the file path. If path is a directory, is raised; see below to remove a directory. This is identical to the function documented below. On Windows, attempting to remove a file that is in use causes an exception to be raised; on Unix, the directory entry is removed but the storage allocated to the file is not made available until the original file is no longer in use. Remove directories recursively. Works like except that, if the leaf directory is successfully removed, tries to successively remove every parent directory mentioned in path until an error is raised (which is ignored, because it generally means that a parent directory is not empty). For example, will first remove the directory , and then remove and if they are empty. Raises if the leaf directory could not be successfully removed. Rename the file or directory src to dst. If dst is a directory, will be raised. On Unix, if dst exists and is a file, it will be replaced silently if the user has permission. The operation may fail on some Unix flavors if src and dst are on different filesystems. If successful, the renaming will be an atomic operation (this is a POSIX requirement). On Windows, if dst already exists, will be raised even if it is a file; there may be no way to implement an atomic rename when dst names an existing file. Recursive directory or file renaming function. Works like , except creation of any intermediate directories needed to make the new pathname good is attempted first. After the rename, directories corresponding to rightmost path segments of the old name will be pruned away using . This function can fail with the new directory structure made if you lack permissions needed to remove the leaf directory or file. Remove (delete) the directory path. Only works when the directory is empty, otherwise, is raised. In order to remove whole directory trees, can be used. Perform the equivalent of a system call on the given path. (This function follows symlinks; to stat a symlink use .) The return value is an object whose attributes correspond to the members of the structure, namely:\n• None - platform dependent; time of most recent metadata change on Unix, or the time of creation on Windows) Changed in version 2.3: If returns , the time values are floats, measuring seconds. Fractions of a second may be reported if the system supports that. See for further discussion. On some Unix systems (such as Linux), the following attributes may also be available:\n• None - type of device if an inode device On other Unix systems (such as FreeBSD), the following attributes may be available (but may be only filled out if root tries to use them): On RISCOS systems, the following attributes are also available: The exact meaning and resolution of the , , and attributes depend on the operating system and the file system. For example, on Windows systems using the FAT or FAT32 file systems, has 2-second resolution, and has only 1-day resolution. See your operating system documentation for details. For backward compatibility, the return value of is also accessible as a tuple of at least 10 integers giving the most important (and portable) members of the structure, in the order , , , , , , , , , . More items may be added at the end by some implementations. The standard module defines functions and constants that are useful for extracting information from a structure. (On Windows, some items are filled with dummy values.) Changed in version 2.2: Added access to values as attributes of the returned object. Determine whether represents time stamps as float objects. If newvalue is , future calls to return floats, if it is , future calls return ints. If newvalue is omitted, return the current setting. For compatibility with older Python versions, accessing as a tuple always returns integers. Changed in version 2.5: Python now returns float values by default. Applications which do not work correctly with floating point time stamps can use this function to restore the old behaviour. The resolution of the timestamps (that is the smallest possible fraction) depends on the system. Some systems only support second resolution; on these systems, the fraction will always be zero. It is recommended that this setting is only changed at program startup time in the __main__ module; libraries should never change this setting. If an application uses a library that works incorrectly if floating point time stamps are processed, this application should turn the feature off until the library has been corrected. Perform a system call on the given path. The return value is an object whose attributes describe the filesystem on the given path, and correspond to the members of the structure, namely: , , , , , , , , , . For backward compatibility, the return value is also accessible as a tuple whose values correspond to the attributes, in the order given above. The standard module defines constants that are useful for extracting information from a structure when accessing it as a sequence; this remains useful when writing code that needs to work with versions of Python that don’t support accessing the fields as attributes. Changed in version 2.2: Added access to values as attributes of the returned object. Return a unique path name that is reasonable for creating a temporary file. This will be an absolute path that names a potential directory entry in the directory dir or a common location for temporary files if dir is omitted or . If given and not , prefix is used to provide a short prefix to the filename. Applications are responsible for properly creating and managing files created using paths returned by ; no automatic cleanup is provided. On Unix, the environment variable overrides dir, while on Windows is used. The specific behavior of this function depends on the C library implementation; some aspects are underspecified in system documentation. Use of is vulnerable to symlink attacks; consider using (section File Object Creation) instead. Return a unique path name that is reasonable for creating a temporary file. This will be an absolute path that names a potential directory entry in a common location for temporary files. Applications are responsible for properly creating and managing files created using paths returned by ; no automatic cleanup is provided. Use of is vulnerable to symlink attacks; consider using (section File Object Creation) instead. Availability: Unix, Windows. This function probably shouldn’t be used on Windows, though: Microsoft’s implementation of always creates a name in the root directory of the current drive, and that’s generally a poor location for a temp file (depending on privileges, you may not even be able to open a file using this name). The maximum number of unique names that will generate before reusing names. Remove (delete) the file path. This is the same function as ; the name is its traditional Unix name. Set the access and modified times of the file specified by path. If times is , then the file’s access and modified times are set to the current time. (The effect is similar to running the Unix program touch on the path.) Otherwise, times must be a 2-tuple of numbers, of the form which is used to set the access and modified times, respectively. Whether a directory can be given for path depends on whether the operating system implements directories as files (for example, Windows does not). Note that the exact times you set here may not be returned by a subsequent call, depending on the resolution with which your operating system records access and modification times; see . Changed in version 2.0: Added support for for times. Generate the file names in a directory tree by walking the tree either top-down or bottom-up. For each directory in the tree rooted at directory top (including top itself), it yields a 3-tuple . dirpath is a string, the path to the directory. dirnames is a list of the names of the subdirectories in dirpath (excluding and ). filenames is a list of the names of the non-directory files in dirpath. Note that the names in the lists contain no path components. To get a full path (which begins with top) to a file or directory in dirpath, do . If optional argument topdown is or not specified, the triple for a directory is generated before the triples for any of its subdirectories (directories are generated top-down). If topdown is , the triple for a directory is generated after the triples for all of its subdirectories (directories are generated bottom-up). No matter the value of topdown, the list of subdirectories is retrieved before the tuples for the directory and its subdirectories are generated. When topdown is , the caller can modify the dirnames list in-place (perhaps using or slice assignment), and will only recurse into the subdirectories whose names remain in dirnames; this can be used to prune the search, impose a specific order of visiting, or even to inform about directories the caller creates or renames before it resumes again. Modifying dirnames when topdown is has no effect on the behavior of the walk, because in bottom-up mode the directories in dirnames are generated before dirpath itself is generated. By default, errors from the call are ignored. If optional argument onerror is specified, it should be a function; it will be called with one argument, an instance. It can report the error to continue with the walk, or raise the exception to abort the walk. Note that the filename is available as the attribute of the exception object. By default, will not walk down into symbolic links that resolve to directories. Set followlinks to to visit directories pointed to by symlinks, on systems that support them. New in version 2.6: The followlinks parameter. Be aware that setting followlinks to can lead to infinite recursion if a link points to a parent directory of itself. does not keep track of the directories it visited already. If you pass a relative pathname, don’t change the current working directory between resumptions of . never changes the current directory, and assumes that its caller doesn’t either. This example displays the number of bytes taken by non-directory files in each directory under the starting directory, except that it doesn’t look under any CVS subdirectory: In the next example, walking the tree bottom-up is essential: doesn’t allow deleting a directory before the directory is empty: # Delete everything reachable from the directory named in \"top\", # assuming there are no symbolic links. # CAUTION: This is dangerous! For example, if top == '/', it # could delete all your disk files.\n\nThese functions may be used to create and manage processes. The various functions take a list of arguments for the new program loaded into the process. In each case, the first of these arguments is passed to the new program as its own name rather than as an argument a user may have typed on a command line. For the C programmer, this is the passed to a program’s . For example, will only print on standard output; will seem to be ignored. Generate a signal to the current process. On Unix, the default behavior is to produce a core dump; on Windows, the process immediately returns an exit code of . Be aware that calling this function will not call the Python signal handler registered for with . These functions all execute a new program, replacing the current process; they do not return. On Unix, the new executable is loaded into the current process, and will have the same process id as the caller. Errors will be reported as exceptions. The current process is replaced immediately. Open file objects and descriptors are not flushed, so if there may be data buffered on these open files, you should flush them using or before calling an function. The “l” and “v” variants of the functions differ in how command-line arguments are passed. The “l” variants are perhaps the easiest to work with if the number of parameters is fixed when the code is written; the individual parameters simply become additional parameters to the functions. The “v” variants are good when the number of parameters is variable, with the arguments being passed in a list or tuple as the args parameter. In either case, the arguments to the child process should start with the name of the command being run, but this is not enforced. The variants which include a “p” near the end ( , , , and ) will use the environment variable to locate the program file. When the environment is being replaced (using one of the variants, discussed in the next paragraph), the new environment is used as the source of the variable. The other variants, , , , and , will not use the variable to locate the executable; path must contain an appropriate absolute or relative path. For , , , and (note that these all end in “e”), the env parameter must be a mapping which is used to define the environment variables for the new process (these are used instead of the current process’ environment); the functions , , , and all cause the new process to inherit the environment of the current process. Exit the process with status n, without calling cleanup handlers, flushing stdio buffers, etc. The standard way to exit is . should normally only be used in the child process after a . The following exit codes are defined and can be used with , although they are not required. These are typically used for system programs written in Python, such as a mail server’s external command delivery program. Some of these may not be available on all Unix platforms, since there is some variation. These constants are defined where they are defined by the underlying platform. Exit code that means the command was used incorrectly, such as when the wrong number of arguments are given. Exit code that means the input data was incorrect. Exit code that means an input file did not exist or was not readable. Exit code that means a specified user did not exist. Exit code that means a specified host did not exist. Exit code that means that a required service is unavailable. Exit code that means an internal software error was detected. Exit code that means an operating system error was detected, such as the inability to fork or create a pipe. Exit code that means some system file did not exist, could not be opened, or had some other kind of error. Exit code that means a user specified output file could not be created. Exit code that means that an error occurred while doing I/O on some file. Exit code that means a temporary failure occurred. This indicates something that may not really be an error, such as a network connection that couldn’t be made during a retryable operation. Exit code that means that a protocol exchange was illegal, invalid, or not understood. Exit code that means that there were insufficient permissions to perform the operation (but not intended for file system problems). Exit code that means that some kind of configuration error occurred. Exit code that means something like “an entry was not found”. Fork a child process. Return in the child and the child’s process id in the parent. If an error occurs is raised. Note that some platforms including FreeBSD <= 6.3, Cygwin and OS/2 EMX have known issues when using fork() from a thread. See for applications that use the SSL module with fork(). Fork a child process, using a new pseudo-terminal as the child’s controlling terminal. Return a pair of , where pid is in the child, the new child’s process id in the parent, and fd is the file descriptor of the master end of the pseudo-terminal. For a more portable approach, use the module. If an error occurs is raised. Send signal sig to the process pid. Constants for the specific signals available on the host platform are defined in the module. Windows: The and signals are special signals which can only be sent to console processes which share a common console window, e.g., some subprocesses. Any other value for sig will cause the process to be unconditionally killed by the TerminateProcess API, and the exit code will be set to sig. The Windows version of additionally takes process handles to be killed. Send the signal sig to the process group pgid. Add increment to the process’s “niceness”. Return the new niceness. Lock program segments into memory. The value of op (defined in ) determines which segments are locked. Run child processes, returning opened pipes for communications. These functions are described in section File Object Creation. Execute the program path in a new process. If mode is , this function returns the process id of the new process; if mode is , returns the process’s exit code if it exits normally, or , where signal is the signal that killed the process. On Windows, the process id will actually be the process handle, so can be used with the function. The “l” and “v” variants of the functions differ in how command-line arguments are passed. The “l” variants are perhaps the easiest to work with if the number of parameters is fixed when the code is written; the individual parameters simply become additional parameters to the functions. The “v” variants are good when the number of parameters is variable, with the arguments being passed in a list or tuple as the args parameter. In either case, the arguments to the child process must start with the name of the command being run. The variants which include a second “p” near the end ( , , , and ) will use the environment variable to locate the program file. When the environment is being replaced (using one of the variants, discussed in the next paragraph), the new environment is used as the source of the variable. The other variants, , , , and , will not use the variable to locate the executable; path must contain an appropriate absolute or relative path. For , , , and (note that these all end in “e”), the env parameter must be a mapping which is used to define the environment variables for the new process (they are used instead of the current process’ environment); the functions , , , and all cause the new process to inherit the environment of the current process. Note that keys and values in the env dictionary must be strings; invalid keys or values will cause the function to fail, with a return value of . As an example, the following calls to and are equivalent: Availability: Unix, Windows. , , and are not available on Windows. and are not thread-safe on Windows; we advise you to use the module instead. Possible values for the mode parameter to the family of functions. If either of these values is given, the functions will return as soon as the new process has been created, with the process id as the return value. Possible value for the mode parameter to the family of functions. If this is given as mode, the functions will not return until the new process has run to completion and will return the exit code of the process the run is successful, or if a signal kills the process. Possible values for the mode parameter to the family of functions. These are less portable than those listed above. is similar to , but the new process is detached from the console of the calling process. If is used, the current process will be replaced; the function will not return. Start a file with its associated application. When operation is not specified or , this acts like double-clicking the file in Windows Explorer, or giving the file name as an argument to the start command from the interactive command shell: the file is opened with whatever application (if any) its extension is associated. When another operation is given, it must be a “command verb” that specifies what should be done with the file. Common verbs documented by Microsoft are and (to be used on files) as well as and (to be used on directories). returns as soon as the associated application is launched. There is no option to wait for the application to close, and no way to retrieve the application’s exit status. The path parameter is relative to the current directory. If you want to use an absolute path, make sure the first character is not a slash ( ); the underlying Win32 function doesn’t work if it is. Use the function to ensure that the path is properly encoded for Win32. New in version 2.5: The operation parameter. Execute the command (a string) in a subshell. This is implemented by calling the Standard C function , and has the same limitations. Changes to , etc. are not reflected in the environment of the executed command. On Unix, the return value is the exit status of the process encoded in the format specified for . Note that POSIX does not specify the meaning of the return value of the C function, so the return value of the Python function is system-dependent. On Windows, the return value is that returned by the system shell after running command, given by the Windows environment variable : on command.com systems (Windows 95, 98 and ME) this is always ; on cmd.exe systems (Windows NT, 2000 and XP) this is the exit status of the command run; on systems using a non-native shell, consult your shell documentation. The module provides more powerful facilities for spawning new processes and retrieving their results; using that module is preferable to using this function. See the Replacing Older Functions with the subprocess Module section in the documentation for some helpful recipes. Return a 5-tuple of floating point numbers indicating accumulated (processor or other) times, in seconds. The items are: user time, system time, children’s user time, children’s system time, and elapsed real time since a fixed point in the past, in that order. See the Unix manual page times(2) or the corresponding Windows Platform API documentation. On Windows, only the first two items are filled, the others are zero. Wait for completion of a child process, and return a tuple containing its pid and exit status indication: a 16-bit number, whose low byte is the signal number that killed the process, and whose high byte is the exit status (if the signal number is zero); the high bit of the low byte is set if a core file was produced. The details of this function differ on Unix and Windows. On Unix: Wait for completion of a child process given by process id pid, and return a tuple containing its process id and exit status indication (encoded as for ). The semantics of the call are affected by the value of the integer options, which should be for normal operation. If pid is greater than , requests status information for that specific process. If pid is , the request is for the status of any child in the process group of the current process. If pid is , the request pertains to any child of the current process. If pid is less than , status is requested for any process in the process group (the absolute value of pid). An is raised with the value of errno when the syscall returns -1. On Windows: Wait for completion of a process given by process handle pid, and return a tuple containing pid, and its exit status shifted left by 8 bits (shifting makes cross-platform use of the function easier). A pid less than or equal to has no special meaning on Windows, and raises an exception. The value of integer options has no effect. pid can refer to any process whose id is known, not necessarily a child process. The functions called with return suitable process handles. Similar to , except no process id argument is given and a 3-element tuple containing the child’s process id, exit status indication, and resource usage information is returned. Refer to . for details on resource usage information. The option argument is the same as that provided to and . Similar to , except a 3-element tuple, containing the child’s process id, exit status indication, and resource usage information is returned. Refer to . for details on resource usage information. The arguments to are the same as those provided to . The option for to return immediately if no child process status is available immediately. The function returns in this case. This option causes child processes to be reported if they have been continued from a job control stop since their status was last reported. This option causes child processes to be reported if they have been stopped but their current state has not been reported since they were stopped. The following functions take a process status code as returned by , , or as a parameter. They may be used to determine the disposition of a process. Return if a core dump was generated for the process, otherwise return . Return if the process has been continued from a job control stop, otherwise return . Return if the process has been stopped, otherwise return . Return if the process exited due to a signal, otherwise return . Return if the process exited using the exit(2) system call, otherwise return . If is true, return the integer parameter to the exit(2) system call. Otherwise, the return value is meaningless. Return the signal which caused the process to stop. Return the signal which caused the process to exit.\n\nReturn string-valued system configuration values. name specifies the configuration value to retrieve; it may be a string which is the name of a defined system value; these names are specified in a number of standards (POSIX, Unix 95, Unix 98, and others). Some platforms define additional names as well. The names known to the host operating system are given as the keys of the dictionary. For configuration variables not included in that mapping, passing an integer for name is also accepted. If the configuration value specified by name isn’t defined, is returned. If name is a string and is not known, is raised. If a specific value for name is not supported by the host system, even if it is included in , an is raised with for the error number. Dictionary mapping names accepted by to the integer values defined for those names by the host operating system. This can be used to determine the set of names known to the system. Return the number of processes in the system run queue averaged over the last 1, 5, and 15 minutes or raises if the load average was unobtainable. Return integer-valued system configuration values. If the configuration value specified by name isn’t defined, is returned. The comments regarding the name parameter for apply here as well; the dictionary that provides information on the known names is given by . Dictionary mapping names accepted by to the integer values defined for those names by the host operating system. This can be used to determine the set of names known to the system. The following data values are used to support path manipulation operations. These are defined for all platforms. Higher-level operations on pathnames are defined in the module. The constant string used by the operating system to refer to the current directory. This is for Windows and POSIX. Also available via . The constant string used by the operating system to refer to the parent directory. This is for Windows and POSIX. Also available via . The character used by the operating system to separate pathname components. This is for POSIX and for Windows. Note that knowing this is not sufficient to be able to parse or concatenate pathnames — use and — but it is occasionally useful. Also available via . An alternative character used by the operating system to separate pathname components, or if only one separator character exists. This is set to on Windows systems where is a backslash. Also available via . The character which separates the base filename from the extension; for example, the in . Also available via . The character conventionally used by the operating system to separate search path components (as in ), such as for POSIX or for Windows. Also available via . The default search path used by and if the environment doesn’t have a key. Also available via . The string used to separate (or, rather, terminate) lines on the current platform. This may be a single character, such as for POSIX, or multiple characters, for example, for Windows. Do not use os.linesep as a line terminator when writing files opened in text mode (the default); use a single instead, on all platforms. The file path of the null device. For example: for POSIX, for Windows. Also available via ."
    },
    {
        "link": "https://tutorialspoint.com/python/os_listdir.htm",
        "document": "The Python os.listdir() method returns a list containing the names of the files within the given directory. The list will be in arbitrary order. It does not include the special entries '.' and '..' even if they are present in the directory.\n\nWhen listdir() is invoked without any arguments, it displays the current working directory.\n\nFollowing is the syntax for Python os.listdir() method −\n• None path − It is an optional parameter that specify the directory, which needs to be explored.\n\nThe Python os.listdir() method returns a list containing the names of the entries in the directory given by path.\n\nThe following example shows the usage of listdir() method. Here, we are displaying files and directories available in the path \"/home/TP\".\n\nWhen we run above program, it produces following result −\n\nIn the following example, we are using the listdir() without passing any arguments. It will show the directories of the current working directory.\n\nOn running, the above program will produce the following result −"
    },
    {
        "link": "https://docs.python.org/2/library/os.html",
        "document": "This module provides a portable way of using operating system dependent functionality. If you just want to read or write a file see , if you want to manipulate paths, see the module, and if you want to read all the lines in all the files on the command line see the module. For creating temporary files and directories see the module, and for high-level file and directory handling see the module.\n\nNotes on the availability of these functions:\n• None The design of all built-in operating system dependent modules of Python is such that as long as the same functionality is available, it uses the same interface; for example, the function returns stat information about path in the same format (which happens to have originated with the POSIX interface).\n• None Extensions peculiar to a particular operating system are also available through the module, but using them is of course a threat to portability.\n• None An “Availability: Unix” note means that this function is commonly found on Unix systems. It does not make any claims about its existence on a specific operating system.\n• None If not separately noted, all functions that claim “Availability: Unix” are supported on Mac OS X, which builds on a Unix core.\n\nThese functions and data items provide information and operate on the current process and user. A mapping object representing the string environment. For example, is the pathname of your home directory (on some platforms), and is equivalent to in C. This mapping is captured the first time the module is imported, typically during Python startup as part of processing . Changes to the environment made after this time are not reflected in , except for changes made by modifying directly. If the platform supports the function, this mapping may be used to modify the environment as well as query the environment. will be called automatically when the mapping is modified. Calling directly does not change , so it’s better to modify . On some platforms, including FreeBSD and Mac OS X, setting may cause memory leaks. Refer to the system documentation for . If is not provided, a modified copy of this mapping may be passed to the appropriate process-creation functions to cause child processes to use a modified environment. If the platform supports the function, you can delete items in this mapping to unset environment variables. will be called automatically when an item is deleted from , and when one of the or methods is called. Changed in version 2.6: Also unset environment variables when calling and . These functions are described in Files and Directories. Return the filename corresponding to the controlling terminal of the process. Return the effective group id of the current process. This corresponds to the “set id” bit on the file being executed in the current process. Return the real group id of the current process. Return list of supplemental group ids associated with the current process. On Mac OS X, behavior differs somewhat from other Unix platforms. If the Python interpreter was built with a deployment target of or earlier, returns the list of effective group ids associated with the current user process; this list is limited to a system-defined number of entries, typically 16, and may be modified by calls to if suitably privileged. If built with a deployment target greater than , returns the current group access list for the user associated with the effective user id of the process; the group access list may change over the lifetime of the process, it is not affected by calls to , and its length is not limited to 16. The deployment target value, , can be obtained with . Call the system initgroups() to initialize the group access list with all of the groups of which the specified username is a member, plus the specified group id. Return the name of the user logged in on the controlling terminal of the process. For most purposes, it is more useful to use the environment variable to find out who the user is, or to get the login name of the process’s real user id. Return the process group id of the process with process id pid. If pid is 0, the process group id of the current process is returned. Return the id of the current process group. Return the value of the environment variable varname if it exists, or value if it doesn’t. value defaults to . Set the environment variable named varname to the string value. Such changes to the environment affect subprocesses started with , or and . On some platforms, including FreeBSD and Mac OS X, setting may cause memory leaks. Refer to the system documentation for putenv. When is supported, assignments to items in are automatically translated into corresponding calls to ; however, calls to don’t update , so it is actually preferable to assign to items of . Set the list of supplemental group ids associated with the current process to groups. groups must be a sequence, and each element must be an integer identifying a group. This operation is typically available only to the superuser. On Mac OS X, the length of groups may not exceed the system-defined maximum number of effective group ids, typically 16. See the documentation for for cases where it may not return the same group list set by calling setgroups(). Call the system call or depending on which version is implemented (if any). See the Unix manual for the semantics. Call the system call to set the process group id of the process with id pid to the process group with id pgrp. See the Unix manual for the semantics. Call the system call . See the Unix manual for the semantics. Call the system call . See the Unix manual for the semantics. Return the error message corresponding to the error code in code. On platforms where returns when given an unknown error number, is raised. Set the current numeric umask and return the previous umask. Return a 5-tuple containing information identifying the current operating system. The tuple contains 5 strings: . Some systems truncate the nodename to 8 characters or to the leading component; a better way to get the hostname is or even . Unset (delete) the environment variable named varname. Such changes to the environment affect subprocesses started with , or and . When is supported, deletion of items in is automatically translated into a corresponding call to ; however, calls to don’t update , so it is actually preferable to delete items of .\n\nThese functions create new file objects. (See also .) Return an open file object connected to the file descriptor fd. The mode and bufsize arguments have the same meaning as the corresponding arguments to the built-in function. If raises an exception, it leaves fd untouched (unclosed). Changed in version 2.3: When specified, the mode argument must now start with one of the letters , , or , otherwise a is raised. Changed in version 2.5: On Unix, when the mode argument starts with , the O_APPEND flag is set on the file descriptor (which the implementation already does on most platforms). Open a pipe to or from command. The return value is an open file object connected to the pipe, which can be read or written depending on whether mode is (default) or . The bufsize argument has the same meaning as the corresponding argument to the built-in function. The exit status of the command (encoded in the format specified for ) is available as the return value of the method of the file object, except that when the exit status is zero (termination without errors), is returned. Deprecated since version 2.6: This function is obsolete. Use the module. Check especially the Replacing Older Functions with the subprocess Module section. Changed in version 2.0: This function worked unreliably under Windows in earlier versions of Python. This was due to the use of the function from the libraries provided with Windows. Newer versions of Python do not use the broken implementation from the Windows libraries. Return a new file object opened in update mode ( ). The file has no directory entries associated with it and will be automatically deleted once there are no file descriptors for the file. There are a number of different functions that provide slightly different ways to create subprocesses. Deprecated since version 2.6: All of the functions are obsolete. Use the module. For each of the variants, if bufsize is specified, it specifies the buffer size for the I/O pipes. mode, if provided, should be the string or ; on Windows this is needed to determine whether the file objects should be opened in binary or text mode. The default value for mode is . Also, for each of these variants, on Unix, cmd may be a sequence, in which case arguments will be passed directly to the program without shell intervention (as with ). If cmd is a string it will be passed to the shell (as with ). These methods do not make it possible to retrieve the exit status from the child processes. The only way to control the input and output streams and also retrieve the return codes is to use the module; these are only available on Unix. For a discussion of possible deadlock conditions related to the use of these functions, see Flow Control Issues. Execute cmd as a sub-process and return the file objects . Deprecated since version 2.6: This function is obsolete. Use the module. Check especially the Replacing Older Functions with the subprocess Module section. Execute cmd as a sub-process and return the file objects . Deprecated since version 2.6: This function is obsolete. Use the module. Check especially the Replacing Older Functions with the subprocess Module section. Execute cmd as a sub-process and return the file objects . Deprecated since version 2.6: This function is obsolete. Use the module. Check especially the Replacing Older Functions with the subprocess Module section. This functionality is also available in the module using functions of the same names, but the return values of those functions have a different order.\n\nThese functions operate on I/O streams referenced using file descriptors. File descriptors are small integers corresponding to a file that has been opened by the current process. For example, standard input is usually file descriptor 0, standard output is 1, and standard error is 2. Further files opened by a process will then be assigned 3, 4, 5, and so forth. The name “file descriptor” is slightly deceptive; on Unix platforms, sockets and pipes are also referenced by file descriptors. The method can be used to obtain the file descriptor associated with a file object when required. Note that using the file descriptor directly will bypass the file object methods, ignoring aspects such as internal buffering of data. This function is intended for low-level I/O and must be applied to a file descriptor as returned by or . To close a “file object” returned by the built-in function or by or , use its method. Close all file descriptors from fd_low (inclusive) to fd_high (exclusive), ignoring errors. Equivalent to: Duplicate file descriptor fd to fd2, closing the latter first if necessary. Change the mode of the file given by fd to the numeric mode. See the docs for for possible values of mode. Change the owner and group id of the file given by fd to the numeric uid and gid. To leave one of the ids unchanged, set it to -1. Force write of file with filedescriptor fd to disk. Does not force update of metadata. This function is not available on MacOS. Return system configuration information relevant to an open file. name specifies the configuration value to retrieve; it may be a string which is the name of a defined system value; these names are specified in a number of standards (POSIX.1, Unix 95, Unix 98, and others). Some platforms define additional names as well. The names known to the host operating system are given in the dictionary. For configuration variables not included in that mapping, passing an integer for name is also accepted. If name is a string and is not known, is raised. If a specific value for name is not supported by the host system, even if it is included in , an is raised with for the error number. Return information about the filesystem containing the file associated with file descriptor fd, like . Force write of file with filedescriptor fd to disk. On Unix, this calls the native function; on Windows, the MS function. If you’re starting with a Python file object f, first do , and then do , to ensure that all internal buffers associated with f are written to disk. Truncate the file corresponding to file descriptor fd, so that it is at most length bytes in size. Return if the file descriptor fd is open and connected to a tty(-like) device, else . Set the current position of file descriptor fd to position pos, modified by how: or to set the position relative to the beginning of the file; or to set it relative to the current position; or to set it relative to the end of the file. Return the new cursor position in bytes, starting from the beginning. Parameters to the function. Their values are 0, 1, and 2, respectively. Open the file file and set various flags according to flags and possibly its mode according to mode. The default mode is (octal), and the current umask value is first masked out. Return the file descriptor for the newly opened file. For a description of the flag and mode values, see the C run-time documentation; flag constants (like and ) are defined in this module too (see open() flag constants). In particular, on Windows adding is needed to open files in binary mode. This function is intended for low-level I/O. For normal usage, use the built-in function , which returns a “file object” with and methods (and many more). To wrap a file descriptor in a “file object”, use . Open a new pseudo-terminal pair. Return a pair of file descriptors for the pty and the tty, respectively. For a (slightly) more portable approach, use the module. Create a pipe. Return a pair of file descriptors usable for reading and writing, respectively. Read at most n bytes from file descriptor fd. Return a string containing the bytes read. If the end of the file referred to by fd has been reached, an empty string is returned. This function is intended for low-level I/O and must be applied to a file descriptor as returned by or . To read a “file object” returned by the built-in function or by or , or , use its or methods. Return the process group associated with the terminal given by fd (an open file descriptor as returned by ). Set the process group associated with the terminal given by fd (an open file descriptor as returned by ) to pg. Return a string which specifies the terminal device associated with file descriptor fd. If fd is not associated with a terminal device, an exception is raised. Write the string str to file descriptor fd. Return the number of bytes actually written. This function is intended for low-level I/O and must be applied to a file descriptor as returned by or . To write a “file object” returned by the built-in function or by or , or or , use its method. The following constants are options for the flags parameter to the function. They can be combined using the bitwise OR operator . Some of them are not available on all platforms. For descriptions of their availability and use, consult the open(2) manual page on Unix or the MSDN on Windows. The above constants are available on Unix and Windows. The above constants are only available on Unix. The above constants are only available on Windows. The above constants are extensions and not present if they are not defined by the C library.\n\nUse the real uid/gid to test for access to path. Note that most operations will use the effective uid/gid, therefore this routine can be used in a suid/sgid environment to test if the invoking user has the specified access to path. mode should be to test the existence of path, or it can be the inclusive OR of one or more of , , and to test permissions. Return if access is allowed, if not. See the Unix man page access(2) for more information. Using to check if a user is authorized to e.g. open a file before actually doing so using creates a security hole, because the user might exploit the short time interval between checking and opening the file to manipulate it. It’s preferable to use EAFP techniques. For example: I/O operations may fail even when indicates that they would succeed, particularly for operations on network filesystems which may have permissions semantics beyond the usual POSIX permission-bit model. Value to pass as the mode parameter of to test the existence of path. Value to include in the mode parameter of to test the readability of path. Value to include in the mode parameter of to test the writability of path. Value to include in the mode parameter of to determine if path can be executed. Change the current working directory to the directory represented by the file descriptor fd. The descriptor must refer to an opened directory, not an open file. Set the flags of path to the numeric flags. flags may take a combination (bitwise OR) of the following values (as defined in the module): Change the root directory of the current process to path. Availability: Unix. Change the mode of path to the numeric mode. mode may take one of the following values (as defined in the module) or bitwise ORed combinations of them: Although Windows supports , you can only set the file’s read-only flag with it (via the and constants or a corresponding integer value). All other bits are ignored. Change the owner and group id of path to the numeric uid and gid. To leave one of the ids unchanged, set it to -1. Set the flags of path to the numeric flags, like , but do not follow symbolic links. Change the mode of path to the numeric mode. If path is a symlink, this affects the symlink rather than the target. See the docs for for possible values of mode. Change the owner and group id of path to the numeric uid and gid. This function will not follow symbolic links. Return a list containing the names of the entries in the directory given by path. The list is in arbitrary order. It does not include the special entries and even if they are present in the directory. Changed in version 2.3: On Windows NT/2k/XP and Unix, if path is a Unicode object, the result will be a list of Unicode objects. Undecodable filenames will still be returned as string objects. Perform the equivalent of an system call on the given path. Similar to , but does not follow symbolic links. On platforms that do not support symbolic links, this is an alias for . Create a FIFO (a named pipe) named path with numeric mode mode. The default mode is (octal). The current umask value is first masked out from the mode. FIFOs are pipes that can be accessed like regular files. FIFOs exist until they are deleted (for example with ). Generally, FIFOs are used as rendezvous between “client” and “server” type processes: the server opens the FIFO for reading, and the client opens it for writing. Note that doesn’t open the FIFO — it just creates the rendezvous point. Create a filesystem node (file, device special file or named pipe) named filename. mode specifies both the permissions to use and the type of node to be created, being combined (bitwise OR) with one of , , , and (those constants are available in ). For and , device defines the newly created device special file (probably using ), otherwise it is ignored. Extract the device major number from a raw device number (usually the or field from ). Extract the device minor number from a raw device number (usually the or field from ). Compose a raw device number from the major and minor device numbers. Create a directory named path with numeric mode mode. The default mode is (octal). If the directory already exists, is raised. On some systems, mode is ignored. Where it is used, the current umask value is first masked out. If bits other than the last 9 (i.e. the last 3 digits of the octal representation of the mode) are set, their meaning is platform-dependent. On some platforms, they are ignored and you should call explicitly to set them. It is also possible to create temporary directories; see the module’s function. Recursive directory creation function. Like , but makes all intermediate-level directories needed to contain the leaf directory. Raises an exception if the leaf directory already exists or cannot be created. The default mode is (octal). The mode parameter is passed to ; see the mkdir() description for how it is interpreted. will become confused if the path elements to create include . Changed in version 2.3: This function now handles UNC paths correctly. Return system configuration information relevant to a named file. name specifies the configuration value to retrieve; it may be a string which is the name of a defined system value; these names are specified in a number of standards (POSIX.1, Unix 95, Unix 98, and others). Some platforms define additional names as well. The names known to the host operating system are given in the dictionary. For configuration variables not included in that mapping, passing an integer for name is also accepted. If name is a string and is not known, is raised. If a specific value for name is not supported by the host system, even if it is included in , an is raised with for the error number. Dictionary mapping names accepted by and to the integer values defined for those names by the host operating system. This can be used to determine the set of names known to the system. Availability: Unix. Return a string representing the path to which the symbolic link points. The result may be either an absolute or relative pathname; if it is relative, it may be converted to an absolute pathname using . Changed in version 2.6: If the path is a Unicode object the result will also be a Unicode object. Remove (delete) the file path. If path is a directory, is raised; see below to remove a directory. This is identical to the function documented below. On Windows, attempting to remove a file that is in use causes an exception to be raised; on Unix, the directory entry is removed but the storage allocated to the file is not made available until the original file is no longer in use. Remove directories recursively. Works like except that, if the leaf directory is successfully removed, tries to successively remove every parent directory mentioned in path until an error is raised (which is ignored, because it generally means that a parent directory is not empty). For example, will first remove the directory , and then remove and if they are empty. Raises if the leaf directory could not be successfully removed. Rename the file or directory src to dst. If dst is a directory, will be raised. On Unix, if dst exists and is a file, it will be replaced silently if the user has permission. The operation may fail on some Unix flavors if src and dst are on different filesystems. If successful, the renaming will be an atomic operation (this is a POSIX requirement). On Windows, if dst already exists, will be raised even if it is a file; there may be no way to implement an atomic rename when dst names an existing file. Recursive directory or file renaming function. Works like , except creation of any intermediate directories needed to make the new pathname good is attempted first. After the rename, directories corresponding to rightmost path segments of the old name will be pruned away using . This function can fail with the new directory structure made if you lack permissions needed to remove the leaf directory or file. Remove (delete) the directory path. Only works when the directory is empty, otherwise, is raised. In order to remove whole directory trees, can be used. Perform the equivalent of a system call on the given path. (This function follows symlinks; to stat a symlink use .) The return value is an object whose attributes correspond to the members of the structure, namely:\n• None - platform dependent; time of most recent metadata change on Unix, or the time of creation on Windows) Changed in version 2.3: If returns , the time values are floats, measuring seconds. Fractions of a second may be reported if the system supports that. See for further discussion. On some Unix systems (such as Linux), the following attributes may also be available:\n• None - type of device if an inode device On other Unix systems (such as FreeBSD), the following attributes may be available (but may be only filled out if root tries to use them): On RISCOS systems, the following attributes are also available: The exact meaning and resolution of the , , and attributes depend on the operating system and the file system. For example, on Windows systems using the FAT or FAT32 file systems, has 2-second resolution, and has only 1-day resolution. See your operating system documentation for details. For backward compatibility, the return value of is also accessible as a tuple of at least 10 integers giving the most important (and portable) members of the structure, in the order , , , , , , , , , . More items may be added at the end by some implementations. The standard module defines functions and constants that are useful for extracting information from a structure. (On Windows, some items are filled with dummy values.) Changed in version 2.2: Added access to values as attributes of the returned object. Determine whether represents time stamps as float objects. If newvalue is , future calls to return floats, if it is , future calls return ints. If newvalue is omitted, return the current setting. For compatibility with older Python versions, accessing as a tuple always returns integers. Changed in version 2.5: Python now returns float values by default. Applications which do not work correctly with floating point time stamps can use this function to restore the old behaviour. The resolution of the timestamps (that is the smallest possible fraction) depends on the system. Some systems only support second resolution; on these systems, the fraction will always be zero. It is recommended that this setting is only changed at program startup time in the __main__ module; libraries should never change this setting. If an application uses a library that works incorrectly if floating point time stamps are processed, this application should turn the feature off until the library has been corrected. Perform a system call on the given path. The return value is an object whose attributes describe the filesystem on the given path, and correspond to the members of the structure, namely: , , , , , , , , , . For backward compatibility, the return value is also accessible as a tuple whose values correspond to the attributes, in the order given above. The standard module defines constants that are useful for extracting information from a structure when accessing it as a sequence; this remains useful when writing code that needs to work with versions of Python that don’t support accessing the fields as attributes. Changed in version 2.2: Added access to values as attributes of the returned object. Return a unique path name that is reasonable for creating a temporary file. This will be an absolute path that names a potential directory entry in the directory dir or a common location for temporary files if dir is omitted or . If given and not , prefix is used to provide a short prefix to the filename. Applications are responsible for properly creating and managing files created using paths returned by ; no automatic cleanup is provided. On Unix, the environment variable overrides dir, while on Windows is used. The specific behavior of this function depends on the C library implementation; some aspects are underspecified in system documentation. Use of is vulnerable to symlink attacks; consider using (section File Object Creation) instead. Return a unique path name that is reasonable for creating a temporary file. This will be an absolute path that names a potential directory entry in a common location for temporary files. Applications are responsible for properly creating and managing files created using paths returned by ; no automatic cleanup is provided. Use of is vulnerable to symlink attacks; consider using (section File Object Creation) instead. Availability: Unix, Windows. This function probably shouldn’t be used on Windows, though: Microsoft’s implementation of always creates a name in the root directory of the current drive, and that’s generally a poor location for a temp file (depending on privileges, you may not even be able to open a file using this name). The maximum number of unique names that will generate before reusing names. Remove (delete) the file path. This is the same function as ; the name is its traditional Unix name. Set the access and modified times of the file specified by path. If times is , then the file’s access and modified times are set to the current time. (The effect is similar to running the Unix program touch on the path.) Otherwise, times must be a 2-tuple of numbers, of the form which is used to set the access and modified times, respectively. Whether a directory can be given for path depends on whether the operating system implements directories as files (for example, Windows does not). Note that the exact times you set here may not be returned by a subsequent call, depending on the resolution with which your operating system records access and modification times; see . Changed in version 2.0: Added support for for times. Generate the file names in a directory tree by walking the tree either top-down or bottom-up. For each directory in the tree rooted at directory top (including top itself), it yields a 3-tuple . dirpath is a string, the path to the directory. dirnames is a list of the names of the subdirectories in dirpath (excluding and ). filenames is a list of the names of the non-directory files in dirpath. Note that the names in the lists contain no path components. To get a full path (which begins with top) to a file or directory in dirpath, do . If optional argument topdown is or not specified, the triple for a directory is generated before the triples for any of its subdirectories (directories are generated top-down). If topdown is , the triple for a directory is generated after the triples for all of its subdirectories (directories are generated bottom-up). No matter the value of topdown, the list of subdirectories is retrieved before the tuples for the directory and its subdirectories are generated. When topdown is , the caller can modify the dirnames list in-place (perhaps using or slice assignment), and will only recurse into the subdirectories whose names remain in dirnames; this can be used to prune the search, impose a specific order of visiting, or even to inform about directories the caller creates or renames before it resumes again. Modifying dirnames when topdown is has no effect on the behavior of the walk, because in bottom-up mode the directories in dirnames are generated before dirpath itself is generated. By default, errors from the call are ignored. If optional argument onerror is specified, it should be a function; it will be called with one argument, an instance. It can report the error to continue with the walk, or raise the exception to abort the walk. Note that the filename is available as the attribute of the exception object. By default, will not walk down into symbolic links that resolve to directories. Set followlinks to to visit directories pointed to by symlinks, on systems that support them. New in version 2.6: The followlinks parameter. Be aware that setting followlinks to can lead to infinite recursion if a link points to a parent directory of itself. does not keep track of the directories it visited already. If you pass a relative pathname, don’t change the current working directory between resumptions of . never changes the current directory, and assumes that its caller doesn’t either. This example displays the number of bytes taken by non-directory files in each directory under the starting directory, except that it doesn’t look under any CVS subdirectory: In the next example, walking the tree bottom-up is essential: doesn’t allow deleting a directory before the directory is empty: # Delete everything reachable from the directory named in \"top\", # assuming there are no symbolic links. # CAUTION: This is dangerous! For example, if top == '/', it # could delete all your disk files.\n\nThese functions may be used to create and manage processes. The various functions take a list of arguments for the new program loaded into the process. In each case, the first of these arguments is passed to the new program as its own name rather than as an argument a user may have typed on a command line. For the C programmer, this is the passed to a program’s . For example, will only print on standard output; will seem to be ignored. Generate a signal to the current process. On Unix, the default behavior is to produce a core dump; on Windows, the process immediately returns an exit code of . Be aware that calling this function will not call the Python signal handler registered for with . These functions all execute a new program, replacing the current process; they do not return. On Unix, the new executable is loaded into the current process, and will have the same process id as the caller. Errors will be reported as exceptions. The current process is replaced immediately. Open file objects and descriptors are not flushed, so if there may be data buffered on these open files, you should flush them using or before calling an function. The “l” and “v” variants of the functions differ in how command-line arguments are passed. The “l” variants are perhaps the easiest to work with if the number of parameters is fixed when the code is written; the individual parameters simply become additional parameters to the functions. The “v” variants are good when the number of parameters is variable, with the arguments being passed in a list or tuple as the args parameter. In either case, the arguments to the child process should start with the name of the command being run, but this is not enforced. The variants which include a “p” near the end ( , , , and ) will use the environment variable to locate the program file. When the environment is being replaced (using one of the variants, discussed in the next paragraph), the new environment is used as the source of the variable. The other variants, , , , and , will not use the variable to locate the executable; path must contain an appropriate absolute or relative path. For , , , and (note that these all end in “e”), the env parameter must be a mapping which is used to define the environment variables for the new process (these are used instead of the current process’ environment); the functions , , , and all cause the new process to inherit the environment of the current process. Exit the process with status n, without calling cleanup handlers, flushing stdio buffers, etc. The standard way to exit is . should normally only be used in the child process after a . The following exit codes are defined and can be used with , although they are not required. These are typically used for system programs written in Python, such as a mail server’s external command delivery program. Some of these may not be available on all Unix platforms, since there is some variation. These constants are defined where they are defined by the underlying platform. Exit code that means the command was used incorrectly, such as when the wrong number of arguments are given. Exit code that means the input data was incorrect. Exit code that means an input file did not exist or was not readable. Exit code that means a specified user did not exist. Exit code that means a specified host did not exist. Exit code that means that a required service is unavailable. Exit code that means an internal software error was detected. Exit code that means an operating system error was detected, such as the inability to fork or create a pipe. Exit code that means some system file did not exist, could not be opened, or had some other kind of error. Exit code that means a user specified output file could not be created. Exit code that means that an error occurred while doing I/O on some file. Exit code that means a temporary failure occurred. This indicates something that may not really be an error, such as a network connection that couldn’t be made during a retryable operation. Exit code that means that a protocol exchange was illegal, invalid, or not understood. Exit code that means that there were insufficient permissions to perform the operation (but not intended for file system problems). Exit code that means that some kind of configuration error occurred. Exit code that means something like “an entry was not found”. Fork a child process. Return in the child and the child’s process id in the parent. If an error occurs is raised. Note that some platforms including FreeBSD <= 6.3, Cygwin and OS/2 EMX have known issues when using fork() from a thread. See for applications that use the SSL module with fork(). Fork a child process, using a new pseudo-terminal as the child’s controlling terminal. Return a pair of , where pid is in the child, the new child’s process id in the parent, and fd is the file descriptor of the master end of the pseudo-terminal. For a more portable approach, use the module. If an error occurs is raised. Send signal sig to the process pid. Constants for the specific signals available on the host platform are defined in the module. Windows: The and signals are special signals which can only be sent to console processes which share a common console window, e.g., some subprocesses. Any other value for sig will cause the process to be unconditionally killed by the TerminateProcess API, and the exit code will be set to sig. The Windows version of additionally takes process handles to be killed. Send the signal sig to the process group pgid. Add increment to the process’s “niceness”. Return the new niceness. Lock program segments into memory. The value of op (defined in ) determines which segments are locked. Run child processes, returning opened pipes for communications. These functions are described in section File Object Creation. Execute the program path in a new process. If mode is , this function returns the process id of the new process; if mode is , returns the process’s exit code if it exits normally, or , where signal is the signal that killed the process. On Windows, the process id will actually be the process handle, so can be used with the function. The “l” and “v” variants of the functions differ in how command-line arguments are passed. The “l” variants are perhaps the easiest to work with if the number of parameters is fixed when the code is written; the individual parameters simply become additional parameters to the functions. The “v” variants are good when the number of parameters is variable, with the arguments being passed in a list or tuple as the args parameter. In either case, the arguments to the child process must start with the name of the command being run. The variants which include a second “p” near the end ( , , , and ) will use the environment variable to locate the program file. When the environment is being replaced (using one of the variants, discussed in the next paragraph), the new environment is used as the source of the variable. The other variants, , , , and , will not use the variable to locate the executable; path must contain an appropriate absolute or relative path. For , , , and (note that these all end in “e”), the env parameter must be a mapping which is used to define the environment variables for the new process (they are used instead of the current process’ environment); the functions , , , and all cause the new process to inherit the environment of the current process. Note that keys and values in the env dictionary must be strings; invalid keys or values will cause the function to fail, with a return value of . As an example, the following calls to and are equivalent: Availability: Unix, Windows. , , and are not available on Windows. and are not thread-safe on Windows; we advise you to use the module instead. Possible values for the mode parameter to the family of functions. If either of these values is given, the functions will return as soon as the new process has been created, with the process id as the return value. Possible value for the mode parameter to the family of functions. If this is given as mode, the functions will not return until the new process has run to completion and will return the exit code of the process the run is successful, or if a signal kills the process. Possible values for the mode parameter to the family of functions. These are less portable than those listed above. is similar to , but the new process is detached from the console of the calling process. If is used, the current process will be replaced; the function will not return. Start a file with its associated application. When operation is not specified or , this acts like double-clicking the file in Windows Explorer, or giving the file name as an argument to the start command from the interactive command shell: the file is opened with whatever application (if any) its extension is associated. When another operation is given, it must be a “command verb” that specifies what should be done with the file. Common verbs documented by Microsoft are and (to be used on files) as well as and (to be used on directories). returns as soon as the associated application is launched. There is no option to wait for the application to close, and no way to retrieve the application’s exit status. The path parameter is relative to the current directory. If you want to use an absolute path, make sure the first character is not a slash ( ); the underlying Win32 function doesn’t work if it is. Use the function to ensure that the path is properly encoded for Win32. New in version 2.5: The operation parameter. Execute the command (a string) in a subshell. This is implemented by calling the Standard C function , and has the same limitations. Changes to , etc. are not reflected in the environment of the executed command. On Unix, the return value is the exit status of the process encoded in the format specified for . Note that POSIX does not specify the meaning of the return value of the C function, so the return value of the Python function is system-dependent. On Windows, the return value is that returned by the system shell after running command, given by the Windows environment variable : on command.com systems (Windows 95, 98 and ME) this is always ; on cmd.exe systems (Windows NT, 2000 and XP) this is the exit status of the command run; on systems using a non-native shell, consult your shell documentation. The module provides more powerful facilities for spawning new processes and retrieving their results; using that module is preferable to using this function. See the Replacing Older Functions with the subprocess Module section in the documentation for some helpful recipes. Return a 5-tuple of floating point numbers indicating accumulated (processor or other) times, in seconds. The items are: user time, system time, children’s user time, children’s system time, and elapsed real time since a fixed point in the past, in that order. See the Unix manual page times(2) or the corresponding Windows Platform API documentation. On Windows, only the first two items are filled, the others are zero. Wait for completion of a child process, and return a tuple containing its pid and exit status indication: a 16-bit number, whose low byte is the signal number that killed the process, and whose high byte is the exit status (if the signal number is zero); the high bit of the low byte is set if a core file was produced. The details of this function differ on Unix and Windows. On Unix: Wait for completion of a child process given by process id pid, and return a tuple containing its process id and exit status indication (encoded as for ). The semantics of the call are affected by the value of the integer options, which should be for normal operation. If pid is greater than , requests status information for that specific process. If pid is , the request is for the status of any child in the process group of the current process. If pid is , the request pertains to any child of the current process. If pid is less than , status is requested for any process in the process group (the absolute value of pid). An is raised with the value of errno when the syscall returns -1. On Windows: Wait for completion of a process given by process handle pid, and return a tuple containing pid, and its exit status shifted left by 8 bits (shifting makes cross-platform use of the function easier). A pid less than or equal to has no special meaning on Windows, and raises an exception. The value of integer options has no effect. pid can refer to any process whose id is known, not necessarily a child process. The functions called with return suitable process handles. Similar to , except no process id argument is given and a 3-element tuple containing the child’s process id, exit status indication, and resource usage information is returned. Refer to . for details on resource usage information. The option argument is the same as that provided to and . Similar to , except a 3-element tuple, containing the child’s process id, exit status indication, and resource usage information is returned. Refer to . for details on resource usage information. The arguments to are the same as those provided to . The option for to return immediately if no child process status is available immediately. The function returns in this case. This option causes child processes to be reported if they have been continued from a job control stop since their status was last reported. This option causes child processes to be reported if they have been stopped but their current state has not been reported since they were stopped. The following functions take a process status code as returned by , , or as a parameter. They may be used to determine the disposition of a process. Return if a core dump was generated for the process, otherwise return . Return if the process has been continued from a job control stop, otherwise return . Return if the process has been stopped, otherwise return . Return if the process exited due to a signal, otherwise return . Return if the process exited using the exit(2) system call, otherwise return . If is true, return the integer parameter to the exit(2) system call. Otherwise, the return value is meaningless. Return the signal which caused the process to stop. Return the signal which caused the process to exit.\n\nReturn string-valued system configuration values. name specifies the configuration value to retrieve; it may be a string which is the name of a defined system value; these names are specified in a number of standards (POSIX, Unix 95, Unix 98, and others). Some platforms define additional names as well. The names known to the host operating system are given as the keys of the dictionary. For configuration variables not included in that mapping, passing an integer for name is also accepted. If the configuration value specified by name isn’t defined, is returned. If name is a string and is not known, is raised. If a specific value for name is not supported by the host system, even if it is included in , an is raised with for the error number. Dictionary mapping names accepted by to the integer values defined for those names by the host operating system. This can be used to determine the set of names known to the system. Return the number of processes in the system run queue averaged over the last 1, 5, and 15 minutes or raises if the load average was unobtainable. Return integer-valued system configuration values. If the configuration value specified by name isn’t defined, is returned. The comments regarding the name parameter for apply here as well; the dictionary that provides information on the known names is given by . Dictionary mapping names accepted by to the integer values defined for those names by the host operating system. This can be used to determine the set of names known to the system. The following data values are used to support path manipulation operations. These are defined for all platforms. Higher-level operations on pathnames are defined in the module. The constant string used by the operating system to refer to the current directory. This is for Windows and POSIX. Also available via . The constant string used by the operating system to refer to the parent directory. This is for Windows and POSIX. Also available via . The character used by the operating system to separate pathname components. This is for POSIX and for Windows. Note that knowing this is not sufficient to be able to parse or concatenate pathnames — use and — but it is occasionally useful. Also available via . An alternative character used by the operating system to separate pathname components, or if only one separator character exists. This is set to on Windows systems where is a backslash. Also available via . The character which separates the base filename from the extension; for example, the in . Also available via . The character conventionally used by the operating system to separate search path components (as in ), such as for POSIX or for Windows. Also available via . The default search path used by and if the environment doesn’t have a key. Also available via . The string used to separate (or, rather, terminate) lines on the current platform. This may be a single character, such as for POSIX, or multiple characters, for example, for Windows. Do not use os.linesep as a line terminator when writing files opened in text mode (the default); use a single instead, on all platforms. The file path of the null device. For example: for POSIX, for Windows. Also available via ."
    },
    {
        "link": "https://geeksforgeeks.org/python-list-files-in-a-directory",
        "document": "Sometimes, while working with files in Python, a problem arises with how to get all files in a directory. In this article, we will cover different methods of how to list all file names in a directory in Python.\n\nWe will cover two modules and their respective functions for this tutorial on listing file names and details in a directory.\n\nWhat is a Directory in Python?\n\nA Directory, sometimes known as a folder, is a unit organizational structure in a computer’s file system for storing and locating files or more folders. Python now supports several APIs to list the directory contents. For instance, we can use the Path.iterdir, os.scandir, os.walk, Path.rglob, or os.listdir functions.\n\nHow to List Files in a Directory in Python\n\nThere are multiple ways of listing all the files in a directory. In this article, we will discuss the below modules and their functions to fetch the list of files in a directory. We will cover a total of 5 ways with examples to check the list of files in a directory.\n\nList Files in a Directory Using Os Module in Python\n\nWe can use these 3 methods of the OS module, to get a list of files in a directory.\n\nGet the list of files using os.listdir() method\n\nos.listdir() method gets the list of all files and directories in a specified directory. By default, it is the current directory. Beyond the first level of folders, os.listdir() does not return any files or folders.\n\nExample 1: Get a list of all files in a directory\n\nIn this example, the os module is imported to interact with the operating system. The listdir function is used to obtain a list of all files and directories in the specified path (“C://Users//Vanshi//Desktop//gfg”). The result is then printed, displaying the names of files and directories present in the specified location.\n\nExample 2: Get all the files and no folders\n\nIn this example, the Python program prompts the user for a folder path, and lists and prints the files in that directory, utilizing the os module for directory interaction and filtering files from the obtained list.\n\nExample 3: Get only ‘.txt’ files from the directory\n\nIn this example, the Python script utilizes the os module to iterate through files in the current directory. It selectively prints only the names of files ending with “.txt,” effectively listing text files present in the directory.\n\nOS.walk() generates file names in a directory tree. This function returns a list of files in a tree structure. The method loops through all of the directories in a tree.\n\nExample: Get only ‘.txt’ files in a directory\n\nIn this example, the Python script uses the os module to traverse through files in the specified directory (“C://Users//Vanshi//Desktop//gfg”) and its subdirectories. It identifies and prints the names of files with a “.txt” extension, populating the list variable with the desired text files.\n\nUsing os.scandir() method to list files in a Directory\n\nos.scandir() is an efficient version of os.listdir() function. It was later released by Python and is supported for Python 3.5 and greater.\n\nExample: List all files and directories in a directory.\n\nIn this example, the Python script utilizes the os module to list files and directories in the specified path (“C://Users//Vanshi//Desktop//gfg”). It employs os.scandir() to obtain an iterator of os.DirEntry objects representing entries in the directory.\n\nList Files in a Directory Using the Glob Module in Python\n\nThe glob module retrieves files/path names matching a specified pattern. Below are the ways by which we can list files in a directory using the glob module:\n\nUsing the glob() method to get all files in a directory\n\nWith glob.glob, we can use wild cards (“*, ?, [ranges]) to make path retrieval more simple and convenient.\n\nExample: Python file matching and printing using glob() method\n\nUsing iglob() method to list files in a directory\n\niglob() method can be used to print filenames recursively if the recursive parameter is set to True. This is used for big directories as it is more efficient than glob() method.\n\nExample: Print paths matching the specified pattern in a directory.\n\nIn this example, the Python script utilizes the glob module to find and print paths matching the specified pattern (“C:\\Users\\Vanshi\\Desktop\\gfg**\\*.txt”). It employs glob.iglob() to return an iterator, which is then used to print the paths of all text files present in the specified directory and its subdirectories.\n\nThese are the 5 ways you can use to get details of files and directories in a directory. Python has provided multiple built-in methods that you can use to know the files present in a directory. This tutorial showed easy methods with examples to understand how to get file listings with the os module and glob module.\n• None List all files of certain type in a directory using Python\n• None Listing out directories and files in Python\n• None Get list of files in directory with size\n\nHow do we get a list of files in a directory and subfolders in Python?\n\nHow to get a list of files in a directory sorted by name in Python?\n\nHow to get a list of all files in a folder and subfolders into notepad?\n\nHow to list files from a remote directory using Python?\n\nYou can list files from a remote directory using Python, but it typically requires using modules like (for SSH-based access) or libraries that support various protocols like FTP or HTTP. Here’s a simple example using for SSH-based access:\n\nThis example uses to connect to a remote host via SSH, lists files in a specified directory ( ), and returns a list of filenames. Adjust the , , , and variables according to your remote server setup."
    },
    {
        "link": "https://stackoverflow.com/questions/3207219/how-do-i-list-all-files-of-a-directory",
        "document": "\n• None Although there's a clear differentiation between file and directory terms in the question text, some may argue that directories are actually special files\n• None The statement: \"all files of a directory\" can be interpreted in two ways:\n• None All direct (or level 1) descendants only\n• None All descendants in the whole directory tree (including the ones in sub-directories)\n• None When the question was asked, I imagine that Python 2, was the LTS version, however the code samples will be run by Python 3(.5) (I'll keep them as Python 2 compliant as possible; also, any code belonging to Python that I'm going to post, is from v3.5.4 - unless otherwise specified).\n\n That has consequences related to another keyword in the question: \"add them into a list\":\n• None In pre Python 2.2 versions, sequences (iterables) were mostly represented by lists (tuples, sets, ...)\n• None In Python 2.2, the concept of generator ([Python.Wiki]: Generators) - courtesy of [Python.Docs]: Simple statements - The yield statement) - was introduced. As time passed, generator counterparts started to appear for functions that returned / worked with lists\n• None In Python 3, generator is the default behavior\n• None Not sure if returning a list is still mandatory (or a generator would do as well), but passing a generator to the list constructor, will create a list out of it (and also consume it). The example below illustrates the differences on [Python.Docs]: Built-in functions - map(function, iterable, *iterables) \n\n >>> import sys >>> >>> sys.version '3.5.4 (v3.5.4:3f56838, Aug 8 2017, 02:17:05) [MSC v.1900 64 bit (AMD64)]' >>> m = map(lambda x: x, [1, 2, 3]) >>> m, type(m) (<map object at 0x000001B4257342B0>, <class 'map'>) >>> len(m) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: object of type 'map' has no len() >>> lm0 = list(m) # Build a list from the generator >>> lm0, type(lm0) ([1, 2, 3], <class 'list'>) >>> >>> lm1 = list(m) # Build a list from the same generator >>> lm1, type(lm1) # Empty list now - generator already exhausted ([], <class 'list'>)\n• None The examples will be based on a directory called root_dir with the following structure (this example is for Win, but I'm using the same tree on Nix as well). Note that I'll be reusing the console: [cfati@CFATI-5510-0:e:\\Work\\Dev\\StackOverflow\\q003207219]> sopr.bat ### Set shorter prompt to better fit when pasted in StackOverflow (or other) pages ### [prompt]> [prompt]> tree /f \"root_dir\" Folder PATH listing for volume Work Volume serial number is 00000029 3655:6FED E:\\WORK\\DEV\\STACKOVERFLOW\\Q003207219\\ROOT_DIR ¦ file0 ¦ file1 ¦ +---dir0 ¦ +---dir00 ¦ ¦ ¦ file000 ¦ ¦ ¦ ¦ ¦ +---dir000 ¦ ¦ file0000 ¦ ¦ ¦ +---dir01 ¦ ¦ file010 ¦ ¦ file011 ¦ ¦ ¦ +---dir02 ¦ +---dir020 ¦ +---dir0200 +---dir1 ¦ file10 ¦ file11 ¦ file12 ¦ +---dir2 ¦ ¦ file20 ¦ ¦ ¦ +---dir20 ¦ file200 ¦ +---dir3\n• None There are two implementations:\n• None One that uses generators (of course here it seems useless, since I immediately convert the result to a list)\n• None The classic one (function names ending in _old)\n• None Recursion is used (to get into subdirectories)\n• None For each implementation there are two functions:\n• None One that starts with an underscore (_): \"private\" (should not be called directly) - that does all the work\n• None The public one (wrapper over previous): it just strips off the initial path (if required) from the returned entries. It's an ugly implementation, but it's the only idea that I could come with at this point\n• None In terms of performance, generators are generally a little bit faster (considering both creation and iteration times), but I didn't test them in recursive functions, and also I am iterating inside the function over inner generators - don't know how performance friendly is that\n• None Play with the arguments to get different results\n\nReturn an iterator of os.DirEntry objects corresponding to the entries in the directory given by path. The entries are yielded in arbitrary order, and the special entries and are not included. Using scandir() instead of listdir() can significantly increase the performance of code that also needs file type or file attribute information, because os.DirEntry objects expose this information if the operating system provides it when scanning a directory. All os.DirEntry methods may perform a system call, but is_dir() and is_file() usually only require a system call for symbolic links; os.DirEntry.stat() always requires a system call on Unix but only requires one for symbolic links on Windows.\n• None But it's also more flexible (and offers more functionality), more Pythonic (and in some cases, faster)\n• None Under the scenes, it uses os.scandir (os.listdir on older (Python) versions)\n• None It does the heavy lifting by recurring in subfolders\n• None For large trees (especially if recursive is on), iglob is preferred\n• None Allows advanced filtering based on name (due to the wildcard)\n• None This is one way of achieving our goal\n• None It's the OOP style of handling paths\n• None But, according to [GitHub]: python/cpython - (2.7) cpython/Lib/dircache.py, it's just a (thin) wrapper over os.listdir with caching\n\nAvailable via [Python.Docs]: ctypes - A foreign function library for Python:\n\nNot directly related, but check [SO]: C function called from Python via ctypes returns incorrect value (@CristiFati's answer) out before working with CTypes.\n• None It loads the three functions from LibC (libc.so - loaded in the current process) and calls them (for more details check [SO]: How do I check whether a file exists without exceptions? (@CristiFati's answer) - last notes from item #4.). That would place this approach very close to the Python / C edge\n• None NixDirent64 is the CTypes representation of struct dirent64 from [Man7]: dirent.h(0P) (so are the DT_ constants) from my Ubuntu OS. On other flavors / versions, the structure definition might differ, and if so, the CTypes alias should be updated, otherwise it will yield Undefined Behavior\n• None It returns data in the os.walk's format. I didn't bother to make it recursive, but starting from the existing code, that would be a fairly trivial task\n• None Everything is doable on Win as well, the data (libraries, functions, structs, constants, ...) differ\n• win32file.FindFilesW is part of [GitHub]: mhammond/pywin32 - Python for Windows (pywin32) Extensions, which is a Python wrapper over WinAPIs\n\n9. Use some (other) 3rd-party package that does the trick\n\nMost likely, will rely on one (or more) of the above (maybe with slight customizations).\n• None Code is meant to be portable (except places that target a specific area - which are marked) or cross:\n• None Multiple path styles (absolute, relatives) were used across the above variants, to illustrate the fact that the \"tools\" used are flexible in this direction\n• None os.listdir and os.scandir use opendir / readdir / closedir ([MS.Learn]: FindFirstFileW function (fileapi.h) / [MS.Learn]: FindNextFileW function (fileapi.h) / [MS.Learn]: FindClose function (fileapi.h)) (via [GitHub]: python/cpython - (main) cpython/Modules/posixmodule.c)\n• None win32file.FindFilesW uses those (Win specific) functions as well (via [GitHub]: mhammond/pywin32 - (main) pywin32/win32/src/win32file.i)\n• None _get_dir_content (from point #1.) can be implemented using any of these approaches (some will require more work and some less)\n• Some advanced filtering (instead of just file vs. dir) could be done: e.g. the include_folders argument could be replaced by another one (e.g. filter_func) which would be a function that takes a path as an argument: (this doesn't strip out anything) and inside _get_dir_content something like: (if the function fails for one entry, it will be skipped), but the more complex the code becomes, the longer it will take to execute\n• None Nota Bene! Since recursion is used, I must mention that I did some tests on my laptop (Win 10 pc064), totally unrelated to this problem, and when the recursion level was reaching values somewhere in the (990 .. 1000) range (recursionlimit - 1000 (default)), I got StackOverflow :). If the directory tree exceeds that limit (I am not an FS expert, so I don't know if that is even possible), that could be a problem.\n\n I must also mention that I didn't try to increase recursionlimit, but in theory there will always be the possibility for failure, if the dir depth is larger than the highest possible recursionlimit (on that machine).\n\n Check [SO]: _csv.Error: field larger than field limit (131072) (@CristiFati's answer) for more details on the topic\n• None Code samples are for demonstrative purposes only. That means that I didn't take into account error handling (I don't think there's any try / except / else / finally block), so the code is not robust (the reason is: to keep it as simple and short as possible). For production, error handling should be added as well\n\n1. Use Python only as a wrapper\n• None Everything is done using another technology\n• None That technology is invoked from Python\n• None The most famous flavor that I know is what I call the SysAdmin approach:\n• None Use Python (or any programming language for that matter) in order to execute Shell commands (and parse their outputs)\n• None Some consider this a neat hack\n• None I consider it more like a lame workaround (gainarie), as the action per se is performed from Shell (Cmd in this case), and thus doesn't have anything to do with Python\n• None Filtering (grep / findstr) or output formatting could be done on both sides, but I'm not going to insist on it. Also, I deliberately used os.system instead of [Python.Docs]: subprocess - Subprocess management routines (run, check_output, ...)\n\nIn general, this approach is to be avoided, since if some command output format slightly differs between OS versions / flavors, the parsing code should be adapted as well - not to mention differences between locales."
    },
    {
        "link": "https://builtin.com/data-science/python-list-files-in-directory",
        "document": "File and directory-related operations are basic skills for software engineers. This isn’t just copying one file into another folder on your Windows File Explorer, rather it’s understanding how to conduct automatic batch operations using software functions.\n\nThis is a big topic. Today we will dive into one specific problem: How to list all file names under a specific directory. In Python, a directory contains a group of files and subdirectories.\n\nI’ll introduce five ways to list and access files in a Python directory. Each of these methods are used in different scenarios.\n\nMore on PythonMerging Lists in Python\n\nHow to List Files in a Python Directory\n\n1. Use os.listdir() to Print All Files\n\nOne way to list files in a Python directory is to use the method, which is from Python’s OS module:\n\nThe above code will print the names of all files and directories under the current path. If you would like to print the results based on another path, just give the function an argument:\n\nIf you only want to print all files, the will give you a hand:\n\nFor directories, there is also a function named :\n\nIt’s simple and useful, but what if it returns a large list? Or what if you only need a specific type of file? Fortunately, Python provides you with plenty of options for more complex scenarios.\n\n2. Use os.walk() to Access Files Deeper in a Directory Tree\n\nYou can also list files in a Python directory using , another method from the OS module.\n\nAs its name implies, it can “walk” through a directory tree layer by layer. When you call the method, it will return a generator. Every time you call the method to generate its next value, it will go one layer deeper. The result will be a tuple that includes three items: .\n\nFor example, if you want to get the names of all folders in the second layer, your code will be as follows:\n\n3. Use Glob Module to Search by Regular Expressions\n\nInstead of retrieving the names of all files, sometimes you might want to get the names of a specific type of file. Since the module is able to add regular expressions in a search, it will be your friend for this type of operation:\n\nThe above code will list the file names ending with .\n\n4. Use the Pathlib Module to Generate All Path File Names\n\nSince Python 3.4, there is a module called , which is helpful as well. With the help of list comprehension tricks, we can use one line of code to generate all file names of the current path:\n\nSurprisingly, the comes with the function, as well. There’s no need to import the module explicitly on the top of your Python file.\n\n5. Use the os.scandir() Function to Return a Generator\n\nThe classic function is intuitive but not efficient for large directories that contain a huge amount of files. Therefore, Python 3.5 introduced a new similar function — .\n\nYes, you probably guessed it. This function will return a generator instead of a list of all names. And you can get names as you need. It’s more efficient in situations where you don’t need to get all of the names at once.\n\nMore on Python5 Pandas Groupby Tricks to Know in Python"
    },
    {
        "link": "https://geeksforgeeks.org/python-os-listdir-method",
        "document": "The os.listdir() method in Python is used to get the list of all files and directories in the specified directory. If we don’t specify any directory, then a list of files and directories in the current working directory will be returned.\n\nBelow are some examples of Python os.listdir() method of the OS module:\n\nIn this example, the code uses os.listdir() to obtain a list of files and directories in the root directory (“/”). It then prints the obtained list. The output includes the files and directories present in the specified root Directory.\n\nIn this example, the code utilizes os.listdir() method to obtain a list of files and directories in the current working directory os.getcwd() method. It then prints the obtained list, providing information about the files and directories present in the current working directory.\n\nList All Files and Directories When No Path is Specified\n\nIn this example, the code uses os.listdir() to obtain a list of files and directories in the current working directory. It then prints the obtained list, providing information about the files and directories present in the current working directory. If no path is specified, it defaults to the current working directory.\n\nWhat do you understand by os.listdir() Method?"
    },
    {
        "link": "https://betterstack.com/community/questions/python-how-to-list-all-files-in-dictionary",
        "document": ""
    }
]