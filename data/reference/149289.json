[
    {
        "link": "https://geeksforgeeks.org/pure-virtual-functions-and-abstract-classes",
        "document": "Sometimes implementation of all functions cannot be provided in a base class because we don‚Äôt know the implementation. Such a class is called an abstract class.For example, let Shape be a base class. We cannot provide the implementation of function draw() in Shape, but we know every derived class must have an implementation of draw(). Similarly, an Animal class doesn‚Äôt have the implementation of move() (assuming that all animals move), but all animals must know how to move. We cannot create objects of abstract classes.\n\nA pure virtual function (or abstract function) in C++ is a virtual function for which we can have an implementation, But we must override that function in the derived class, otherwise, the derived class will also become an abstract class. A pure virtual function is declared by assigning 0 in the declaration.\n\nA pure virtual function is implemented by classes that are derived from an Abstract class.\n\n1. A class is abstract if it has at least one pure virtual function.\n\nIn the below C++ code, Test is an abstract class because it has a pure virtual function show().\n\n2. We can have pointers and references of abstract class type.\n\nFor example, the following program works fine.\n\n3. If we do not override the pure virtual function in the derived class, then the derived class also becomes an abstract class.\n\nThe following example demonstrates the same.\n\n4. An abstract class can have constructors.\n\nFor example, the following program compiles and runs fine.\n\n5. An abstract class in C++ can also be defined using struct keyword.\n\nIn Java, a class can be made abstract by using an abstract keyword. Similarly, a function can be made pure virtual or abstract by using an abstract keyword. See Abstract Classes in Java for more details.\n\nAn interface does not have an implementation of any of its methods, it can be considered as a collection of method declarations. In C++, an interface can be simulated by making all methods pure virtual. In Java, there is a separate keyword for the interface.\n\nWe can think of Interface as header files in C++, like in header files we only provide the body of the class that is going to implement it. Similarly in Java in Interface we only provide the body of the class and we write the actual code in whatever class implements it."
    },
    {
        "link": "https://stackoverflow.com/questions/60780989/abstract-class-and-virtual-functions",
        "document": "Would this class be considered an abstract class because it has one virtual function? I was still able to create an Animal object and call getFoodCost();\n\nNo. In C++, \"Abstract Class\" usually refers to a class with a pure virtual function:\n\nYes, that is correct. This is because abstract classes have functions with no required implementation. It has no way to instantiate an instance directly. It uses inheritance and pointers/references to refer to an abstract class.\n\nYes. Again, abstract classes are classes that have pure virtual functions. This is different from a regular virtual function. As discussed above, pure virtual functions have no required implementation. Regular virtual functions, on the other hand, are required to have an implementation associated with them, so they can be instantiated."
    },
    {
        "link": "https://programiz.com/cpp-programming/pure-virtual-funtion",
        "document": "Before we learn about pure virtual functions, be sure to check these tutorials:\n‚Ä¢ if a function doesn't have any use in the base class\n‚Ä¢ but the function must be implemented by all its derived classes\n\nLet's take an example,\n\nSuppose, we have derived , and classes from the class, and we want to calculate the area of all these shapes.\n\nIn this case, we can create a pure virtual function named in the . Since it's a pure virtual function, all derived classes , and must include the function with implementation.\n\nA pure virtual function doesn't have the function body and it must end with . For example,\n\nNote: The syntax doesn't mean we are assigning 0 to the function. It's just the way we define pure virtual functions.\n\nA class that contains a pure virtual function is known as an abstract class. In the above example, the class is an abstract class.\n\nWe cannot create objects of an abstract class. However, we can derive classes from them, and use their data members and member functions (except pure virtual functions).\n\nExample: C++ Abstract Class and Pure Virtual Function\n\nIn this program, inside the class is a pure virtual function.\n\nThat's why we must provide the implementation of in both of our derived classes, or else we will get an error."
    },
    {
        "link": "https://ibm.com/docs/en/zos/2.4.0?topic=only-abstract-classes-c",
        "document": "An abstract class is a class that is designed to be specifically used as a base class. An abstract class contains at least one pure virtual function. You declare a pure virtual function by using a pure specifier ( ) in the declaration of a virtual member function in the class declaration.\n\nFunction is a pure virtual function. A function declaration cannot have both a pure specifier and a definition. For example, the compiler will not allow the following: You cannot use an abstract class as a parameter type, a function return type, or the type of an explicit conversion, nor can you declare an object of an abstract class. You can, however, declare pointers and references to an abstract class. The following example demonstrates this: struct A { virtual void f() = 0; }; struct B : A { virtual void f() { } }; // Error: // Class A is an abstract class // A g(); // Error: // Class A is an abstract class // void h(A); A& i(A&); int main() { // Error: // Class A is an abstract class // A a; A* pa; B b; // Error: // Class A is an abstract class // static_cast<A>(b); } Class is an abstract class. The compiler would not allow the function declarations or , declaration of object , nor the static cast of to type . The following is an example of an abstract class:Functionis a pure virtual function. A function declaration cannot have both a pure specifier and a definition. For example, the compiler will not allow the following:You cannot use an abstract class as a parameter type, a function return type, or the type of an explicit conversion, nor can you declare an object of an abstract class. You can, however, declare pointers and references to an abstract class. The following example demonstrates this:Classis an abstract class. The compiler would not allow the function declarationsor, declaration of object, nor the static cast ofto type\n\nVirtual member functions are inherited. A class derived from an abstract base class will also be abstract unless you override each pure virtual function in the derived class.\n\nThe compiler will not allow the declaration of object because is an abstract class; it inherited the pure virtual function from . The compiler will allow the declaration of object if you define function , as this overrides the inherited pure virtual function . Function needs to be overridden if you want to avoid the abstraction of .\n\nNote that you can derive an abstract class from a nonabstract class, and you can override a non-pure virtual function with a pure virtual function.\n\nThe default constructor of calls the pure virtual function both directly and indirectly (through ). You can call member functions from a constructor or destructor of an abstract class. However, the results of calling (directly or indirectly) a pure virtual function from its constructor are undefined. The following example demonstrates this:The default constructor ofcalls the pure virtual functionboth directly and indirectly (through)."
    },
    {
        "link": "https://medium.com/javarevisited/mastering-c-abstract-class-interface-and-pure-virtual-functions-in-few-steps-ddbeff770d1f",
        "document": "Hello Jawans üòé, today we will be learning about , , , and . Howzzzzz the Joshhhhhhhh ‚Ä¶???‚Ä¶ ‚≠êü§©üî•\n\nWhen we talk about Abstract Classes and Interfaces in C++, most people tend to get confused. The confusion is because in languages such as Java, and C# we have keyword and for creating Abstract Class and Interface Class. But in C++ we don‚Äôt have any language-supported keywords for creating such classes.\n\nBefore learning üìö about Abstract Class and Interface let‚Äôs first talk üé§ about Virtual and Pure Virtual Functions.\n\n1. What is a Virtual and Pure Virtual Functions\n\nA Virtual function (VF) is always defined in a Base or Parent class with the keyword at the beginning and is overridden in the derived/child class. We use the virtual function for dynamic binding or late binding, most famously known as Runtime Polymorphism. If a VF is not redefined in the derived/child class, it will not cause any compile error but then it doesn‚Äôt make sense to make the function virtual if it‚Äôs not overridden in the child class.\n\nA Pure Virtual Function (PVF) is a special type of Virtual Function. A Pure Virtual Function must be overridden in one of its derived/child classes. A PVF only has a function declaration and no definition. It is declared by assigning 0 to a virtual function without any function body or implementation.\n\nAn Abstract Class, in C++, is a class that has at least one Pure Virtual Function (PVF) however the class is allowed to have implemented methods and declared variables. Since the Abstract class has PVF, an abstract class cannot be instantiated , but we can create a Pointer variable of an Abstract Class pointing to its derived/child class objects.\n\nIn C++ when a class has all its functions (methods) as Pure Virtual Functions then that class is called an Interface Class. An Interface Class cannot have any variable declarations. Similar to Abstract Class we cannot create objects of an Interface Class."
    },
    {
        "link": "https://stackoverflow.com/questions/51686623/c-copy-constructor-in-inheritance",
        "document": "Your code makes a copy of an instance of , invoking its copy constructor.\n\nYour class 's copy constructor only invokes the copy constructors of its and 's superclasses. Because it does not invoke 's copy constructor, it gets default-constructed.\n\nVirtually-inherited classes can be thought of as direct superclasses of the most-derived class. That's what virtual inheritance means. As such, in your instance of , its virtually-inherited is a direct superclass of , and not of or ; as such, and 's invocations of copy-constructor is not invoked.\n\nWhen you have a virtually-inherited class, all your constructors really have two versions created \"behind the scenes\": one that's responsible for constructing any virtually-inherited classes, and one that's not. The one that's not does not call the virtually-inherited classes's constructors."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-implement-a-copy-constructor-in-a-derived-class-in-cpp",
        "document": "How to Implement a Copy Constructor in a Derived Class in C++\n\nIn object-oriented programming, a copy constructor is a special member function that initializes a new object as a copy of an existing object. In this article, we will learn how to implement a copy constructor in a derived class.\n\nImplementing Copy Constructor in a Derived Class in C++\n\nIn C++, when we implement a constructor in an inherited class, we need to explicitly call the corresponding constructor of the base class also so that we can avoid implement same constructor logic again and again. Some thing happens with copy constructor.\n\nTo implement a copy constructor in a derived class in C++, we have to call the copy constructor of the base class too in the definition as shown in the below syntax\n\nSyntax to Create a Copy Constructor in a Derived Class in C++\n\nC++ Program to Implement a Copy Constructor in a Derived Class\n\nThe following program illustrates how we can implement a copy constructor in a derived class."
    },
    {
        "link": "https://stackoverflow.com/questions/56398691/is-it-necessary-to-create-a-copy-constructor-for-derived-classes",
        "document": "If I have a base class with a complex data member, let's say , and at the end of my inheritance chain I have another class with the same kind of DM, do I have to implement the CCTORs (Copy Constructors) of all the other classes on the way?\n\nDo I need to implement a CCTOR in , even though it has only an as a data member?\n\nBasically my question is: When copying a complex object (built from several classes), does the compiler activate the CCTOR of each part separately?\n\nEdit: To be clear, I want to copy a object. If I write my code as above, will its name be deep copied as well?"
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/cpp/constructors-cpp?view=msvc-170",
        "document": "To customize how a class initializes its members, or to invoke functions when an object of your class is created, define a constructor. A constructor has the same name as the class and no return value. You can define as many overloaded constructors as needed to customize initialization in various ways. Typically, constructors have public accessibility so that code outside the class definition or inheritance hierarchy can create objects of the class. But you can also declare a constructor as or .\n\nConstructors can optionally take a member initializer list. It's a more efficient way to initialize class members than assigning values in the constructor body. The following example shows a class with three overloaded constructors. The last two use member init lists:\n\nWhen you declare an instance of a class, the compiler chooses which constructor to invoke based on the rules of overload resolution:\n‚Ä¢ Constructors may be declared as , , , or .\n‚Ä¢ A constructor can initialize an object that has been declared as , or . The object becomes after the constructor completes.\n‚Ä¢ To define a constructor in an implementation file, give it a qualified name like any other member function: .\n\nA constructor can optionally have a member initializer list, which initializes class members before the constructor body runs. (A member initializer list isn't the same thing as an initializer list of type .)\n\nPrefer member initializer lists over assigning values in the body of the constructor. A member initializer list directly initializes the members. The following example shows the member initializer list, which consists of all the expressions after the colon:\n\nThe identifier must refer to a class member; it's initialized with the value of the argument. The argument can be one of the constructor parameters, a function call or a .\n\nmembers and members of reference type must be initialized in the member initializer list.\n\nTo ensure base classes are fully initialized before the derived constructor runs, call any parameterized base class constructors in the initializer list.\n\nDefault constructors typically have no parameters, but they can have parameters with default values.\n\nDefault constructors are one of the special member functions. If no constructors are declared in a class, the compiler provides an implicit default constructor.\n\nIf you rely on an implicit default constructor, be sure to initialize members in the class definition, as shown in the previous example. Without those initializers, the members would be uninitialized and the Volume() call would produce a garbage value. In general, it's good practice to initialize members in this way even when not relying on an implicit default constructor.\n\nYou can prevent the compiler from generating an implicit default constructor by defining it as deleted:\n\nA compiler-generated default constructor will be defined as deleted if any class members aren't default-constructible. For example, all members of class type, and their class-type members, must have a default constructor and destructors that are accessible. All data members of reference type and all members must have a default member initializer.\n\nWhen you call a compiler-generated default constructor and try to use parentheses, a warning is issued:\n\nThis statement is an example of the \"Most Vexing Parse\" problem. You could interpret either as a function declaration or as the invocation of a default constructor. Because C++ parsers favor declarations over other things, the expression is treated as a function declaration. For more information, see Most Vexing Parse.\n\nIf any non-default constructors are declared, the compiler doesn't provide a default constructor:\n\nIf a class has no default constructor, an array of objects of that class can't be constructed by using square-bracket syntax alone. For example, given the previous code block, an array of Boxes can't be declared like this:\n\nHowever, you can use a set of initializer lists to initialize an array of Box objects:\n\nFor more information, see Initializers.\n\nA copy constructor initializes an object by copying the member values from an object of the same type. If your class members are all simple types such as scalar values, the compiler-generated copy constructor is sufficient and you don't need to define your own. If your class requires more complex initialization, then you need to implement a custom copy constructor. For example, if a class member is a pointer then you need to define a copy constructor to allocate new memory and copy the values from the other's pointed-to object. The compiler-generated copy constructor simply copies the pointer, so that the new pointer still points to the other's memory location.\n\nA copy constructor may have one of these signatures:\n\nWhen you define a copy constructor, you should also define a copy assignment operator (=). For more information, see Assignment and Copy constructors and copy assignment operators.\n\nYou can prevent your object from being copied by defining the copy constructor as deleted:\n\nAttempting to copy the object produces error C2280: attempting to reference a deleted function.\n\nA move constructor is a special member function that moves ownership of an existing object's data to a new variable without copying the original data. It takes an rvalue reference as its first parameter, and any later parameters must have default values. Move constructors can significantly increase your program's efficiency when passing around large objects.\n\nThe compiler chooses a move constructor when the object is initialized by another object of the same type, if the other object is about to be destroyed and no longer needs its resources. The following example shows one case when a move constructor is selected by overload resolution. In the constructor that calls , the returned value is an xvalue (eXpiring value). It's not assigned to any variable and is therefore about to go out of scope. To provide motivation for this example, let's give Box a large vector of strings that represent its contents. Rather than copying the vector and its strings, the move constructor \"steals\" it from the expiring value \"box\" so that the vector now belongs to the new object. The call to is all that's needed because both and classes implement their own move constructors.\n\nIf a class doesn't define a move constructor, the compiler generates an implicit one if there's no user-declared copy constructor, copy assignment operator, move assignment operator, or destructor. If no explicit or implicit move constructor is defined, operations that would otherwise use a move constructor use the copy constructor instead. If a class declares a move constructor or move assignment operator, the implicitly declared copy constructor is defined as deleted.\n\nAn implicitly declared move constructor is defined as deleted if any members that are class types lack a destructor or if the compiler can't determine which constructor to use for the move operation.\n\nFor more information about how to write a non-trivial move constructor, see Move Constructors and Move Assignment Operators (C++).\n\nYou can explicitly default copy constructors, default constructors, move constructors, copy assignment operators, move assignment operators, and destructors. You can explicitly delete all of the special member functions.\n\nFor more information, see Explicitly Defaulted and Deleted Functions.\n\nA constructor may be declared as constexpr if\n‚Ä¢ it's either declared as defaulted or else it satisfies all the conditions for constexpr functions in general;\n‚Ä¢ the class has no virtual base classes;\n‚Ä¢ each of the parameters is a literal type;\n‚Ä¢ all non-static data members and base class subobjects are initialized;\n‚Ä¢ if the class is (a) a union having variant members, or (b) has anonymous unions, only one of the union members is initialized;\n‚Ä¢ every non-static data member of class type, and all base-class subobjects have a constexpr constructor\n\nIf a constructor takes a as its parameter, and any other parameters have default arguments, that constructor is selected in overload resolution when the class is instantiated through direct initialization. You can use the initializer_list to initialize any member that can accept it. For example, assume the Box class (shown previously) has a member . You can provide a constructor like this:\n\nAnd then create Box objects like this:\n\nIf a class has a constructor with a single parameter, or if all parameters except one have a default value, the parameter type can be implicitly converted to the class type. For example, if the class has a constructor like this:\n\nIt's possible to initialize a Box like this:\n\nOr pass an int to a function that takes a Box:\n\nSuch conversions can be useful in some cases, but more often they can lead to subtle but serious errors in your code. As a general rule, you should use the keyword on a constructor (and user-defined operators) to prevent this kind of implicit type conversion:\n\nWhen the constructor is explicit, this line causes a compiler error: . For more information, see User-Defined Type Conversions.\n\nA constructor performs its work in this order:\n‚Ä¢ None It calls base class and member constructors in the order of declaration.\n‚Ä¢ None If the class is derived from virtual base classes, it initializes the object's virtual base pointers.\n‚Ä¢ None If the class has or inherits virtual functions, it initializes the object's virtual function pointers. Virtual function pointers point to the class's virtual function table to enable correct binding of virtual function calls to code.\n‚Ä¢ None It executes any code in its function body.\n\nThe following example shows the order in which base class and member constructors are called in the constructor for a derived class. First, the base constructor is called. Then, the base-class members are initialized in the order in which they appear in the class declaration. Finally, the derived constructor is called.\n\nA derived class constructor always calls a base class constructor, so that it can rely on completely constructed base classes before any extra work is done. The base class constructors are called in order of derivation‚Äîfor example, if is derived from , which is derived from , the constructor is called first, then the constructor, then the constructor.\n\nIf a base class doesn't have a default constructor, you must supply the base class constructor parameters in the derived class constructor:\n\nIf a constructor throws an exception, the order of destruction is the reverse of the order of construction:\n‚Ä¢ None The code in the body of the constructor function is unwound.\n‚Ä¢ None Base class and member objects are destroyed, in the reverse order of declaration.\n‚Ä¢ None If the constructor is non-delegating, all fully constructed base class objects and members are destroyed. However, because the object itself isn't fully constructed, the destructor isn't run.\n\nIf the constructor of a base class is non-public, but accessible to a derived class, then you can't use empty braces to initialize an object of the derived type under mode and later in Visual Studio 2017 and later.\n\nThe following example shows C++14 conformant behavior:\n\nIn C++17, is now considered an aggregate type. It means that the initialization of via the private default constructor happens directly, as part of the extended aggregate initialization rule. Previously, the private constructor was called via the constructor, and it succeeded because of the declaration.\n\nThe following example shows C++17 behavior in Visual Studio 2017 and later in mode:\n\nConstructors for classes that have multiple inheritance\n\nIf a class is derived from multiple base classes, the base class constructors are invoked in the order in which they're listed in the declaration of the derived class:\n\nYou should expect the following output:\n\nA delegating constructor calls a different constructor in the same class to do some of the work of initialization. This feature is useful when you have multiple constructors that all have to perform similar work. You can write the main logic in one constructor and invoke it from others. In the following trivial example, Box(int) delegates its work to Box(int,int,int):\n\nThe object created by the constructors is fully initialized as soon as any constructor is finished. For more information, see Delegating Constructors.\n\nA derived class can inherit the constructors from a direct base class by using a declaration as shown in the following example:\n\nA class template can inherit all the constructors from a type argument if that type specifies a base class:\n\nA deriving class can't inherit from multiple base classes if those base classes have constructors that have an identical signature.\n\nClasses that contain class-type members are known as composite classes. When a class-type member of a composite class is created, the constructor is called before the class's own constructor. When a contained class lacks a default constructor, you must use an initialization list in the constructor of the composite class. In the earlier example, if you change the type of the member variable to a new class, you must call both the base class constructor and initialize the variable in the constructor:"
    },
    {
        "link": "https://isocpp.org/wiki/faq/ctors",
        "document": "Constructors are like ‚Äúinit functions‚Äù. They turn a pile of arbitrary bits into a living object. Minimally they initialize internally used fields. They may also allocate resources (memory, files, semaphores, sockets, etc).\n\nIs there any difference between and ?\n\nSuppose that is the name of some class. Then function declares a local object called :\n\nCan one constructor of a class call another constructor of the same class to initialize the object?\n\nThe answer below applies to Classic (pre-11) C++. This question covers the C++11 feature of constructors that call same-type constructors.\n\nLet‚Äôs work an example. Suppose you want your constructor to call another constructor of the same class, say , in order that would help initialize the object. Unfortunately there‚Äôs no way to do this in Classic C++.\n\nSome people do it anyway. Unfortunately it doesn‚Äôt do what they want. For example, the line does not call on the object. Instead it calls to initialize a temporary, local object (not ), then it immediately destructs that temporary when control flows over the .\n\nYou can sometimes combine two constructors via a default parameter:\n\nIf that doesn‚Äôt work, e.g., if there isn‚Äôt an appropriate default parameter that combines the two constructors, sometimes you can share their common code in a private member function:\n\nBTW do NOT try to achieve this via placement new. Some people think they can say within the body of . However that is bad, bad, bad. Please don‚Äôt write me and tell me that it seems to work on your particular version of your particular compiler; it‚Äôs bad. Constructors do a bunch of little magical things behind the scenes, but that bad technique steps on those partially constructed bits. Just say no.\n\nIs the default constructor for always ?\n\nA ‚Äúdefault constructor‚Äù is a constructor that can be called with no arguments. One example of this is a constructor that takes no parameters:\n\nAnother example of a ‚Äúdefault constructor‚Äù is one that can take arguments, provided they are given default values:\n\nWhich constructor gets called when I create an array of objects?\n\n‚Äôs default constructor (except as discussed below).\n\nIf your class doesn‚Äôt have a default constructor, you‚Äôll get a compile-time error when you attempt to create an array using the above simple syntax:\n\nHowever, even if your class already has a default constructor, you should try to use rather than an array (arrays are evil). lets you decide to use any constructor, not just the default constructor:\n\nEven though you ought to use a rather than an array, there are times when an array might be the right thing to do, and for those, you might need the ‚Äúexplicit initialization of arrays‚Äù syntax. Here‚Äôs how:\n\nOf course you don‚Äôt have to do for every entry ‚Äî you can put in any numbers you want, even parameters or other variables.\n\nFinally, you can use placement-new to manually initialize the elements of the array. Warning: it‚Äôs ugly: the raw array can‚Äôt be of type , so you‚Äôll need a bunch of pointer-casts to do things like compute array index operations. Warning: it‚Äôs compiler- and hardware-dependent: you‚Äôll need to make sure the storage is aligned with an alignment that is at least as strict as is required for objects of class . Warning: it‚Äôs tedious to make it exception-safe: you‚Äôll need to manually destruct the elements, including in the case when an exception is thrown part-way through the loop that calls the constructors. But if you really want to do it anyway, read up on placement-new. (BTW placement-new is the magic that is used inside of . The complexity of getting everything right is yet another reason to use .)\n\nBy the way, did I ever mention that arrays are evil? Or did I mention that you ought to use a unless there is a compelling reason to use an array?\n\nShould my constructors use ‚Äúinitialization lists‚Äù or ‚Äúassignment‚Äù?\n\nInitialization lists. In fact, constructors should initialize as a rule all member objects in the initialization list. One exception is discussed further down.\n\nWatch this space for discussion of Non Static Data Member Initialization in C++11\n\nConsider the following constructor that initializes member object using an initialization list: whatever . The most common benefit of doing this is improved performance. For example, if the expression whatever is the same type as member variable , the result of the whatever expression is constructed directly inside ‚Äî the compiler does not make a separate copy of the object. Even if the types are not the same, the compiler is usually able to do a better job with initialization lists than with assignments.\n\nThe other (inefficient) way to build constructors is via assignment, such as: whatever . In this case the expression whatever causes a separate, temporary object to be created, and this temporary object is passed into the object‚Äôs assignment operator. Then that temporary object is destructed at the . That‚Äôs inefficient.\n\nAs if that wasn‚Äôt bad enough, there‚Äôs another source of inefficiency when using assignment in a constructor: the member object will get fully constructed by its default constructor, and this might, for example, allocate some default amount of memory or open some default file. All this work could be for naught if the whatever expression and/or assignment operator causes the object to close that file and/or release that memory (e.g., if the default constructor didn‚Äôt allocate a large enough pool of memory or if it opened the wrong file).\n\nConclusion: All other things being equal, your code will run faster if you use initialization lists rather than assignment.\n\nNote: There is no performance difference if the type of is some built-in/intrinsic type, such as or or . But even in these cases, my personal preference is to set those data members in the initialization list rather than via assignment for consistency. Another symmetry argument in favor of using initialization lists even for built-in/intrinsic types: non-static and non-static reference data members can‚Äôt be assigned a value in the constructor, so for symmetry it makes sense to initialize everything in the initialization list.\n\nNow for the exceptions. Every rule has exceptions (hmmm; does ‚Äúevery rule has exceptions‚Äù have exceptions? reminds me of G√∂del‚Äôs Incompleteness Theorems), and there are a couple of exceptions to the ‚Äúuse initialization lists‚Äù rule. Bottom line is to use common sense: if it‚Äôs cheaper, better, faster, etc. to not use them, then by all means, don‚Äôt use them. This might happen when your class has two constructors that need to initialize the object‚Äôs data members in different orders. Or it might happen when two data members are self-referential. Or when a data-member needs a reference to the object, and you want to avoid a compiler warning about using the keyword prior to the that begins the constructor‚Äôs body (when your particular compiler happens to issue that particular warning). Or when you need to do an ‚Ä¶ test on a variable (parameter, global, etc.) prior to using that variable to initialize one of your members. This list is not exhaustive; please don‚Äôt write me asking me to add another ‚ÄúOr when‚Ä¶‚Äù. The point is simply this: use common sense.\n\nHow should initializers be ordered in a constructor‚Äôs initialization list?\n\nImmediate base classes (left to right), then member objects (top to bottom).\n\nIn other words, the order of the initialization list should mimic the order in which initializations will take place. This guideline discourages a particularly subtle class of order dependency errors by giving an obvious, visual clue. For example, the following contains a hideous error.\n\nThe output of this program follows.\n\nNote that is used ( ) before it is initialized ( ). If instead the programmer had read and abided by the guideline in this FAQ, the error would be more obvious: the initialization list of would have read , visually indicating that was being used before being initialized.\n\nNot all compilers issue diagnostic messages for these cases. You have been warned.\n\nIs it moral for one member object to be initialized using another member object in the initializer expression?\n\nYes, but use care and do that only when it adds value.\n\nIn a constructor‚Äôs initialization list, it is easiest and safest to avoid using one member object from object in the initialization expression of a subsequent initializer for object. This guideline prevents subtle order-dependency errors if someone reorganizes the layout of member objects within the class.\n\nBecause of this guideline, the constructor that follows uses rather than , even though they are otherwise equivalent. The prefix avoids an unnecessary and avoidable order dependency.\n\nAn unnecessary order dependency on the class layout of and would have been introduced if the constructor‚Äôs initialization of had used rather than . However using within a constructor body ( ) is okay. No order dependency is introduced since the entire initialization list is guaranteed to finish before the constructor body begins executing.\n\nWhat if one member object has to be initialized using another member object?\n\nComment the declaration of the effected data members with .\n\nIf a constructor initializes a member object of object using another member object of object, rearranging the data members of the class could break the constructor. This important maintenance constraint should be documented in the class body.\n\nFor example, in the constructor below, the initializer for uses to avoid a redundant call to , which introduces an order dependency in the class body.\n\nNote that the comment is listed with the effected data members in the class body, not with the constructor initialization list where the order dependency was actually created. That is because the order of member objects in the class body is critical; the order of initializers in the constructor initialization list is irrelevant.\n\nShould you use the pointer in the constructor?\n\nSome people feel you should not use the pointer in a constructor because the object is not fully formed yet. However you can use in the constructor (in the body and even in the initialization list) if you are careful.\n\nHere is something that always works: the body of a constructor (or a function called from the constructor) can reliably access the data members declared in a base class and/or the data members declared in the constructor‚Äôs own class. This is because all those data members are guaranteed to have been fully constructed by the time the constructor‚Äôs body starts executing.\n\nHere is something that never works: the body of a constructor (or a function called from the constructor) cannot get down to a derived class by calling a member function that is overridden in the derived class. If your goal was to get to the overridden function in the derived class, you won‚Äôt get what you want. Note that you won‚Äôt get to the override in the derived class independent of how you call the member function: explicitly using the pointer (e.g., ), implicitly using the pointer (e.g., ), or even calling some other function that calls the member function on your object. The bottom line is this: even if the caller is constructing an object of a derived class, during the constructor of the base class, your object is not yet of that derived class. You have been warned.\n\nHere is something that sometimes works: if you pass any of the data members in object to another data member‚Äôs initializer, you must make sure that the other data member has already been initialized. The good news is that you can determine whether the other data member has (or has not) been initialized using some straightforward language rules that are independent of the particular compiler you‚Äôre using. The bad news is that you have to know those language rules (e.g., base class sub-objects are initialized first (look up the order if you have multiple and/or inheritance!), then data members defined in the class are initialized in the order in which they appear in the class declaration). If you don‚Äôt know these rules, then don‚Äôt pass any data member from the object (regardless of whether or not you explicitly use the keyword) to any other data member‚Äôs initializer! And if you do know the rules, please be careful.\n\nWhat is the ‚ÄúNamed Constructor Idiom‚Äù?\n\nA technique that provides more intuitive and/or safer construction operations for users of your class.\n\nThe problem is that constructors always have the same name as the class. Therefore the only way to differentiate between the various constructors of a class is by the parameter list. But if there are lots of constructors, the differences between them become somewhat subtle and error prone.\n\nWith the Named Constructor Idiom, you declare all the class‚Äôs constructors in the or sections, and you provide methods that return an object. These methods are the so-called ‚ÄúNamed Constructors.‚Äù In general there is one such method for each different way to construct an object.\n\nFor example, suppose we are building a class that represents a position on the X-Y plane. Turns out there are two common ways to specify a 2-space coordinate: rectangular coordinates (X+Y), polar coordinates (Radius+Angle). (Don‚Äôt worry if you can‚Äôt remember these; the point isn‚Äôt the particulars of coordinate systems; the point is that there are several ways to create a object.) Unfortunately the parameters for these two coordinate systems are the same: two s. This would create an ambiguity error in the overloaded constructors:\n\nOne way to solve this ambiguity is to use the Named Constructor Idiom:\n\nNow the users of have a clear and unambiguous syntax for creating s in either coordinate system:\n\nMake sure your constructors are in the section if you expect to have derived classes.\n\nThe Named Constructor Idiom can also be used to make sure your objects are always created via .\n\nNote that the Named Constructor Idiom, at least as implemented above, is just as fast as directly calling a constructor ‚Äî modern compilers will not make any extra copies of your object.\n\nDoes return-by-value mean extra copies and extra overhead?\n\nAll(?) commercial-grade compilers optimize away the extra copy, at least in cases as illustrated in the previous FAQ.\n\nTo keep the example clean, let‚Äôs strip things down to the bare essentials. Suppose function calls (‚Äúrbv‚Äù stands for ‚Äúreturn by value‚Äù) which returns a object by value:\n\nNow the question is, How many objects will there be? Will create a temporary object that gets copy-constructed into ? How many temporaries? Said another way, does return-by-value necessarily degrade performance?\n\nThe point of this FAQ is that the answer is No, commercial-grade C++ compilers implement return-by-value in a way that lets them eliminate the overhead, at least in simple cases like those shown in the previous FAQ. In particular, all(?) commercial-grade C++ compilers will optimize this case:\n\nCertainly the compiler is allowed to create a temporary, local object, then copy-construct that temporary into variable within , then destruct the temporary. But all(?) commercial-grade C++ compilers won‚Äôt do that: the statement will directly construct itself. Not a copy of , not a pointer to , not a reference to , but itself.\n\nYou can stop here if you don‚Äôt want to genuinely understand the previous paragraph, but if you want to know the secret sauce (so you can, for example, reliably predict when the compiler can and cannot provide that optimization for you), the key is to know that compilers usually implement return-by-value using pass-by-pointer. When calls , the compiler secretly passes a pointer to the location where is supposed to construct the ‚Äúreturned‚Äù object. It might look something like this (it‚Äôs shown as a rather than a since the object has not yet been constructed):\n\nSo the first ingredient in the secret sauce is that the compiler (usually) transforms return-by-value into pass-by-pointer. This means that commercial-grade compilers don‚Äôt bother creating a temporary: they directly construct the returned object in the location pointed to by .\n\nThe second ingredient in the secret sauce is that compilers typically implement constructors using a similar technique. This is compiler-dependent and somewhat idealized (I‚Äôm intentionally ignoring how to handle and overloading), but compilers typically implement using something like this:\n\nPutting these together, the compiler might implement the statement in by simply passing as the constructor‚Äôs pointer:\n\nSo passes to , and in turn passes to the constructor (as the pointer). That means constructor directly constructs .\n\nIn the early 90s I did a seminar for IBM‚Äôs compiler group in Toronto, and one of their engineers told me that they found this return-by-value optimization to be so fast that you get it even if you don‚Äôt compile with optimization turned on. Because the return-by-value optimization causes the compiler to generate less code, it actually improves compile-times in addition to making your generated code smaller and faster. The point is that the return-by-value optimization is almost universally implemented, at least in code cases like those shown above.\n\nFinal thought: this discussion was limited to whether there will be any extra copies of the returned object in a return-by-value call. Don‚Äôt confuse that with other things that could happen in . For example, if you changed from to (note the after the declaration), the compiler is required to use ‚Äôs assignment operator, and unless the compiler can prove that ‚Äôs default constructor followed by assignment operator is exactly the same as its copy constructor, the compiler is required by the language to put the returned object into an unnamed temporary within , use the assignment operator to copy the temporary into , then destruct the temporary. The return-by-value optimization still plays its part since there will be only one temporary, but by changing to , you have prevented the compiler from eliminating that last temporary.\n\nWhat about returning a local variable by value? Does the local exist as a separate object, or does it get optimized away?\n\nWhen your code returns a local variable by value, your compiler might optimize away the local variable completely - zero space-cost and zero time-cost - the local variable never actually exists as a distinct object from the caller‚Äôs target variable (see below for specifics about exactly what this means). Other compilers do not optimize it away.\n\nThese are some(!) of the compilers that optimize away the local variable completely:\n‚Ä¢ GNU C++ (g++) since at least version 3.3.3\n\nThese are some(!) of the compilers that do not optimize away the local variable:\n\nHere is an example showing what we mean in this FAQ:\n\nThe question addressed in this FAQ is this: How many objects actually get created in the runtime system? Conceptually there could be as many as three distinct objects: the temporary created by , variable (in ), and variable (in ). However as we saw earlier most compilers merge and variable into the same object, reducing the total number of objects from 3 to 2. But this FAQ pushes it one step further: does (in ) show up as a distinct, runtime object from (in )?\n\nSome compilers, including but not limited to those listed above, completely optimize away local variable . In those compilers, there is only one object in the above code: ‚Äôs variable is exactly identically the same object as ‚Äôs variable .\n\nThey do this the same way as described earlier: the return-by-value in function is implemented as pass-by-pointer, where the pointer points to the location where the returned object is to be initialized.\n\nSo instead of constructing as a local object, these compilers simply construct , and everytime they see variable used in the original source code, they substitute instead. Then the line becomes simply since the returned object has already been constructed in the location designated by the caller.\n\nHere is the resulting (pseudo)code:\n\nCaveat: this optimization can be applied only when all a function‚Äôs statements return the same local variable. If one statement in returned local variable but another returned something else, such as a global or a temporary, the compiler could not alias the local variable into the caller‚Äôs destination, . Verifying that all the function‚Äôs return statements return the same local variable requires extra work on the part of the compiler writers, which is usually why some compilers fail to implement that return-local-by-value optimization.\n\nFinal thought: this discussion was limited to whether there will be any extra copies of the returned object in a return-by-value call. Don‚Äôt confuse that with other things that could happen in . For example, if you changed from to (note the after the declaration), the compiler is required to use ‚Äôs assignment operator, and unless the compiler can prove that ‚Äôs default constructor followed by assignment operator is exactly the same as its copy constructor, the compiler is required by the language to put the returned object into an unnamed temporary within , use the assignment operator to copy the temporary into , then destruct the temporary. The return-by-value optimization still plays its part since there will be only one temporary, but by changing to , you have prevented the compiler from eliminating that last temporary.\n\nWhy can‚Äôt I initialize my member data in my constructor‚Äôs initialization list?\n\nBecause you must explicitly define your class‚Äôs data members.\n\n(or or whatever):\n\nNote: in some cases, the definition of might not contain the initializer part. For details, see here and here.\n\nWhy are classes with data members getting linker errors?\n\nBecause data members must be explicitly defined in exactly one compilation unit. If you didn‚Äôt do this, you‚Äôll probably get an linker error. For example:\n\nThe linker will holler at you ( ) unless you define (as opposed to merely declare) in (exactly) one of your source files:\n\nThe usual place to define data members of is file (or or whatever source file extension you use).\n\nNote: in some cases, you can add initializer to the declaration of class-scope declarations, however if you ever use the data member, you still need to explicitly define it in exactly one compilation unit. In this case you don‚Äôt include an initializer in the definition. A separate FAQ covers this topic.\n\nCan I add initializer to the declaration of a class-scope data member?\n\nYes, though with some important caveats.\n\nBefore going through the caveats, here is a simple example that is allowed:\n\nAnd, just like other data members, it must be defined in exactly one compilation unit, though this time without the initializer part:\n\nThe caveats are that you may do this only with integral or enumeration types, and that the initializer expression must be an expression that can be evaluated at compile-time: it must only contain other constants, possibly combined with built-in operators. For example, is a compile-time constant expression, as is provided and are compile-time constants. After the declaration above, is also a compile-time constant: it can be used in other compile-time constant expressions.\n\nIf you ever take the address of , such as passing it by reference or explicitly saying , the compiler will make sure it has a unique address. If not, won‚Äôt even take up space in your process‚Äôs static data area.\n\nA subtle way to crash your program.\n\nThe initialization order problem is a very subtle and commonly misunderstood aspect of C++. Unfortunately it‚Äôs very hard to detect ‚Äî the errors often occur before begins.\n\nIn short, suppose you have two objects and which exist in separate source files, say and . Suppose further that the initialization for the object (typically the object‚Äôs constructor) calls some method on the object.\n\nThe tough part is that you have a 50%-50% chance of corrupting the program. If the compilation unit for happens to get initialized first, all is well. But if the compilation unit for get initialized first, then ‚Äôs initialization will get run before ‚Äôs initialization, and you‚Äôre toast. E.g., ‚Äôs constructor could call a method on the object, yet the object hasn‚Äôt yet been constructed.\n\nFor how to address the problem, see the next FAQ.\n\nNote: The static initialization order problem can also, in some cases, apply to built-in/intrinsic types.\n\nHow do I prevent the ‚Äú initialization order problem‚Äù?\n\nTo prevent the static initialization order problem, use the Construct On First Use Idiom, described below.\n\nThe basic idea of the Construct On First Use Idiom is to wrap your object inside a function. For example, suppose you have two classes, and . There is a namespace-scope / global object called , and a namespace-scope / global object called . ‚Äôs constructor invokes the method on the object. The file defines the object:\n\nFor completeness the constructor might look something like this:\n\nYou would have a initialization disaster if got constructed before . As written above, this disaster would occur roughly 50% of the time, since the two objects are declared in different source files and those source files give no hints to the compiler or linker as to the order of static initialization.\n\nThere are many solutions to this problem, but a very simple and completely portable solution is the Construct On First Use Idiom: replace the namespace-scope / global object with a namespace-scope / global function that returns the object by reference.\n\nSince local objects are constructed the first time control flows over their declaration (only), the above statement will only happen once: the first time is called. Every subsequent call will return the same object (the one pointed to by ). Then all you do is change your usages of to :\n\nThis is called the Construct On First Use Idiom because it does just that: the (logically namespace-scope / global) object is constructed on its first use.\n\nThe downside of this approach is that the object is never destructed. If the object has a destructor with important side effects, there is another technique that answers this concern; but it needs to be used with care since it creates the possibility of another (equally nasty) problem.\n\nNote: The static initialization order problem can also, in some cases, apply to built-in/intrinsic types.\n\nWhy doesn‚Äôt the Construct On First Use Idiom use a object instead of a pointer?\n\nShort answer: it‚Äôs possible to use a static object rather than a static pointer, but doing so opens up another (equally subtle, equally nasty) problem.\n\nLong answer: sometimes people worry about the fact that the previous solution ‚Äúleaks.‚Äù In many cases, this is not a problem, but it is a problem in some cases. Note: even though the object pointed to by in the previous FAQ is never deleted, the memory doesn‚Äôt actually ‚Äúleak‚Äù when the program exits since the operating system automatically reclaims all the memory in a program‚Äôs heap when that program exits. In other words, the only time you‚Äôd need to worry about this is when the destructor for the object performs some important action (such as writing something to a file) that must occur sometime while the program is exiting.\n\nIn those cases where the construct-on-first-use object (the , in this case) needs to eventually get destructed, you might consider changing function as follows:\n\nHowever there is (or rather, may be) a rather subtle problem with this change. To understand this potential problem, let‚Äôs remember why we‚Äôre doing all this in the first place: we need to make 100% sure our static object (a) gets constructed prior to its first use and (b) doesn‚Äôt get destructed until after its last use. Obviously it would be a disaster if any static object got used either before construction or after destruction. The message here is that you need to worry about two situations (static initialization and static deinitialization), not just one.\n\nBy changing the declaration from to , we still correctly handle the initialization situation but we no longer handle the deinitialization situation. For example, if there are 3 static objects, say , and , that use during their destructors, the only way to avoid a static deinitialization disaster is if is destructed after all three.\n\nThe point is simple: if there are any other static objects whose destructors might use after is destructed, bang, you‚Äôre dead. If the constructors of , and use , you should normally be okay since the runtime system will, during static deinitialization, destruct after the last of those three objects is destructed. However if and/or and/or fail to use in their constructors and/or if any code anywhere gets the address of and hands it to some other static object, all bets are off and you have to be very, very careful.\n\nThere is a third approach that handles both the static initialization and static deinitialization situations, but it has other non-trivial costs.\n\nWhat is a technique to guarantee both initialization and deinitialization?\n\nShort answer: use the Nifty Counter Idiom (but make sure you understand the non-trivial tradeoffs!).\n‚Ä¢ The Construct On First Use Idiom uses a pointer and intentionally leaks the object. That is often innocuous, since the operating system will typically clean up a process‚Äôs memory when the process terminates. However if the object has a non-trivial destructor with important side effects, such as writing to a file or some other non-volatile action, then you need more.\n‚Ä¢ That‚Äôs where the second version of the Construct On First Use Idiom came in: it doesn‚Äôt leak the object, but it does not control the order of static deinitialization, so it is (very!) unsafe to use the object during static deinitialization, that is, from a destructor of another statically declared object.\n‚Ä¢ If you need to control the order of both static initialization and static deinitialization, meaning if you wish to access a statically allocated object from both constructors and destructors of other static objects, then keep reading.\n\nTODO: WRITE UP TRADEOFFS ‚Äî now that you know how to use the Nifty Counter Idiom, be sure you understand both when and (especially!) when not to use it! One size does not fit all.\n\nHow do I prevent the ‚Äú initialization order problem‚Äù for my data members?\n\nUse the Construct Members On First Use Idiom, which is basically the same as the regular Construct On First Use Idiom, or perhaps one of its variants, but it uses a member function instead of a namespace-scope / global function.\n\nSuppose you have a class that has a object:\n\nNaturally also the object will be used in one or more of ‚Äôs methods:\n\nBut now the ‚Äúdisaster scenario‚Äù is if someone somewhere somehow calls this method before the object gets constructed. For example, if someone else creates a static object and invokes its method during initialization, then you‚Äôre at the mercy of the compiler as to whether the compiler will construct before or after the is called. (Note that the ANSI/ISO C++ committee is working on this problem, but compilers aren‚Äôt yet generally available that handle these changes; watch this space for an update in the future.)\n\nIn any event, it‚Äôs always portable and safe to change the data member into a member function:\n\nThen you simply change any usages of to :\n\nIf you‚Äôre super performance sensitive and you‚Äôre concerned about the overhead of an extra function call on each invocation of you can set up a instead. As you recall, local are only initialized once (the first time control flows over their declaration), so this will call only once: the first time is called:\n\nNote: The static initialization order problem can also, in some cases, apply to built-in/intrinsic types.\n\nDo I need to worry about the ‚Äú initialization order problem‚Äù for variables of built-in/intrinsic types?\n\nIf you initialize your built-in/intrinsic type using a function call, the static initialization order problem is able to kill you just as bad as with user-defined/class types. For example, the following code shows the failure:\n\nThe output of this little program will show that it uses before initializing it. The solution, as before, is the Construct On First Use Idiom:\n\nOf course you might be able to simplify this by moving the initialization code for and into their respective functions:\n\nAnd, if you can get rid of the print statements you can further simplify these to something really simple:\n\nFurthermore, since is initialized using a constant expression, it no longer needs its wrapper function ‚Äî it can be a simple variable again.\n\nHow can I handle a constructor that fails?\n\nThrow an exception. For details, see here.\n\nWhat is the ‚ÄúNamed Parameter Idiom‚Äù?\n\nIt‚Äôs a fairly useful way to exploit method chaining.\n\nThe fundamental problem solved by the Named Parameter Idiom is that C++ only supports positional parameters. For example, a caller of a function isn‚Äôt allowed to say, ‚ÄúHere‚Äôs the value for formal parameter , and this other thing is the value for formal parameter .‚Äù All you can do in C++ (and C and Java) is say, ‚ÄúHere‚Äôs the first parameter, here‚Äôs the second parameter, etc.‚Äù The alternative, called named parameters and implemented in the language Ada, is especially useful if a function takes a large number of mostly default-able parameters.\n\nOver the years people have cooked up lots of workarounds for the lack of named parameters in C and C++. One of these involves burying the parameter values in a string parameter then parsing this string at run-time. This is what‚Äôs done in the second parameter of , for example. Another workaround is to combine all the boolean parameters in a bit-map, then the caller or‚Äôs a bunch of bit-shifted constants together to produce the actual parameter. This is what‚Äôs done in the second parameter of , for example. These approaches work, but the following technique produces caller-code that‚Äôs more obvious, easier to write, easier to read, and is generally more elegant.\n\nThe idea, called the Named Parameter Idiom, is to change the function‚Äôs parameters to methods of a newly created class, where all these methods return by reference. Then you simply rename the main function into a parameterless ‚Äúdo-it‚Äù method on that class.\n\nWe‚Äôll work an example to make the previous paragraph easier to understand.\n\nThe example will be for the ‚Äúopen a file‚Äù concept. Let‚Äôs say that concept logically requires a parameter for the file‚Äôs name, and optionally allows parameters for whether the file should be opened read-only vs. read-write vs. write-only, whether or not the file should be created if it doesn‚Äôt already exist, whether the writing location should be at the end (‚Äúappend‚Äù) or the beginning (‚Äúoverwrite‚Äù), the block-size if the file is to be created, whether the I/O is buffered or non-buffered, the buffer-size, whether it is to be shared vs. exclusive access, and probably a few others. If we implemented this concept using a normal function with positional parameters, the caller code would be very difficult to read: there‚Äôd be as many as 8 positional parameters, and the caller would probably make a lot of mistakes. So instead we use the Named Parameter Idiom.\n\nBefore we go through the implementation, here‚Äôs what the caller code might look like, assuming you are willing to accept all the function‚Äôs default parameters:\n\nThat‚Äôs the easy case. Now here‚Äôs what it might look like if you want to change a bunch of the parameters.\n\nNotice how the ‚Äúparameters‚Äù, if it‚Äôs fair to call them that, are in random order (they‚Äôre not positional) and they all have names. So the programmer doesn‚Äôt have to remember the order of the parameters, and the names are (hopefully) obvious.\n\nSo here‚Äôs how to implement it: first we create a class ( ) that houses all the parameter values as data members. The required parameters (in this case, the only required parameter is the file‚Äôs name) is implemented as a normal, positional parameter on ‚Äôs constructor, but that constructor doesn‚Äôt actually open the file. Then all the optional parameters (readonly vs. readwrite, etc.) become methods. These methods (e.g., , , etc.) return a reference to their object so the method calls can be chained.\n\nThe only other thing to do is make the constructor for class to take an object:\n\nThis constructor gets the actual parameters from the OpenFile object, then actually opens the file:\n\nNote that declares as its , that way doesn‚Äôt need a bunch of (otherwise useless) get methods.\n\nSince each member function in the chain returns a reference, there is no copying of objects and the chain is highly efficient. Furthermore, if the various member functions are , the generated object code will probably be on par with C-style code that sets various members of a . Of course if the member functions are not , there may be a slight increase in code size and a slight decrease in performance (but only if the construction occurs on the critical path of a CPU-bound program; this is a can of worms I‚Äôll try to avoid opening), so it may, in this case, be a tradeoff for making the code more reliable.\n\nWhy am I getting an error after declaring a object via ?\n\nBecause that doesn‚Äôt create a object - it declares a non-member function that returns a object. The term ‚ÄúMost Vexing Parse‚Äù was coined by Scott Myers to describe this situation.\n\nThis is really going to hurt; you might want to sit down.\n\nFirst, here‚Äôs a better explanation of the problem. Suppose there is a class called that has a default ctor. This might even be a library class such as , but for now we‚Äôll just call it :\n\nNow suppose there‚Äôs another class called that has a ctor that takes a . As before, this might be defined by someone other than you.\n\nNow you want to create a object using a temporary . In other words, you want to create an object via , and pass that to the ctor to create a local object called :\n\nIt‚Äôs a long story, but one solution (hope you‚Äôre sitting down!) is to add an extra pair of s around the part:\n\nAnother solution is to use in your declaration (see the fine print below):\n\nNote: The above solution requires to be able to access the copy constructor. In most situations that means the copy constructor needs to be , though it needn‚Äôt be in the less common case where is a friend of . If you‚Äôre not sure what any of that means, try it: if your code compiles, you passed the test.\n\nHere‚Äôs another solution (more fine print below):\n\nNote: The word ‚Äúusually‚Äù in the above means this: the above fails only when constructor is , or when ‚Äôs copy constructor is inaccessible (typically when it is or , and your code is not a ). If you‚Äôre not sure what any of that means, take 60 seconds and compile it. You are guaranteed to find out whether it works or fails at compile-time, so if it compiles cleanly, it will work at runtime.\n\nHowever, the best solution, the creation of which was at least partially motivated by the fact that this FAQ exists, is to use uniform initialization, which replaces the around the call with instead.\n\nThat‚Äôs the end of the solutions; the rest of this is about why this is needed (this is optional; you can skip this section if you don‚Äôt care enough about your career to actually understand what‚Äôs going on; ha ha): When the compiler sees , it thinks that the part is declaring a non-member function that returns a object, so it thinks you are declaring the existence of a function called that returns a and that takes as a single parameter of type ‚Äúnon-member function that takes nothing and returns a .‚Äù\n\nNow here‚Äôs the sad part. In fact it‚Äôs pathetic. Some mindless drone out there is going to skip that last paragraph, then they‚Äôre going to impose a bizarre, incorrect, irrelevant, and just plain stupid coding standard that says something like, ‚ÄúNever create temporaries using a default constructor‚Äù or ‚ÄúAlways use in all initializations‚Äù or something else equally inane. If that‚Äôs you, please fire yourself before you do any more damage. Those who don‚Äôt understand the problem shouldn‚Äôt tell others how to solve it. Harumph.\n\nWhat is the purpose of the keyword?\n\nThe keyword is an optional decoration for constructors and conversion operators to tell the compiler that a certain constructor or conversion operator may not be used to implicitly cast an expression to its class type.\n\nFor example, without the keyword the following code is valid:\n\nBut sometimes you want to prevent this sort of implicit promotion or implicit type conversion. For example, if is really an array-like container and 42 is the initial size, you might want to let your users say, or perhaps , but not just . If that‚Äôs the case, you should use the keyword:\n\nYou can mix and non- constructors and conversion operators in the same class. For example, this class has an constructor taking a but a non- constructor taking a , and can be implicitly converted to double, but only explicitly converted to bool:\n\nThe above code will print the following:\n\nVariable is initialized using the constructor because cannot be used in an implicit cast, but can be interpreted as a , that is, as , and implicitly cast to using . This may or may not be what you intended, but this is what happens.\n\nWhy doesn‚Äôt my constructor work right?\n\nThis is a question that comes in many forms. Such as:\n‚Ä¢ Why does the compiler copy my objects when I don‚Äôt want it to?\n‚Ä¢ How do I turn off copying?\n‚Ä¢ How did my int turn into a complex number?\n\nBy default a class is given a copy constructor and a copy assignment that copy all elements, and a move constructor and a move assignment that move all elements. For example:\n\nHere we get and . That‚Äôs often exactly what you want (and essential for C compatibility), but consider:\n\nHere, the default copy gives us and . This leads to disaster: when we exit the destructors for and are invoked and the object pointed to by and is deleted twice.\n\nHow do we avoid this? The simplest solution is to mark the operations that copy as deleted:\n\nIf we need to copy or move, we can of course define the proper initializers and assignments to provide the desired semantics.\n\nNow return to . For the default copy semantics is fine, the problem is the constructor:\n\nPeople provide default arguments to get the convenience used for and . Then, some are surprised by the conversion of to in the call of . This constructor defines a conversion. By default that‚Äôs an implicit conversion. To require such a conversion to be explicit, declare the constructor :"
    }
]