[
    {
        "link": "https://axios-http.com/docs/intro",
        "document": "Promise based HTTP client for the browser and node.js\n\nAxios is a promise-based HTTP Client for and the browser. It is isomorphic (= it can run in the browser and nodejs with the same codebase). On the server-side it uses the native node.js module, while on the client (browser) it uses XMLHttpRequests.\n• Progress capturing for browsers and node.js with extra info (speed rate, remaining time)\n\nPrebuilt CommonJS modules for direct importing with require (if your module bundler failed to resolve them automatically)"
    },
    {
        "link": "https://axios-http.com/docs/post_example",
        "document": "How to perform POST requests with Axios"
    },
    {
        "link": "https://circleci.com/blog/making-http-requests-with-axios",
        "document": "Axios is a promise-based HTTP library that lets developers make requests to either their own server or a third-party server to fetch data. It offers different ways of making requests such as , , , and .\n\nIn this tutorial, you will learn how Axios interacts with applications, how Axios structures requests and responses, and how to use Axios to make requests to an API. You’ll also learn how to write tests for your Axios requests and how to automate them with CircleCI for fast, seamless feedback on your changes.\n\nTo follow along with the tutorial, make sure that you have:\n\nAxios helps developers make HTTP requests from NodeJS or XMLHttpRequests from a browser. If the request is successful, you will receive a with the data requested. If the request fails, you will get an error. You can also the requests and responses and transform or modify them. I will go into more detail about that later in this tutorial.\n\nThis diagram represents how Axios interacts with an application.\n\nAxios is able to determine whether the request is made from the browser or from NodeJS. Once this is established, it then identifies the proper way to make the API requests and returns a transformed response back to the client that made the request.\n\nMaking a basic request in Axios is easy because the only option required is the . However, you can configure other options depending on the kind of request that you want to make.\n\nHere is an example request:\n\nThe first example uses for a simple GET request where you can add additional configurations. The second example uses the full method, allowing you to specify more options such as the request method, URL, and parameters.\n\nAxios provides great flexibility to configure your requests. You can decide to call Axios with the JavaScript dot notation format. Or you can use the object literal format to bundle all the Axios request properties into an object that can be used as properties of making the Axios request.\n\nThere are several methods that Axios supports for making requests. They include:\n\nHere’s another code snippet that shows how to make a simple request sent to a sample API using Axios.\n\nOnce you send a request with Axios, you expect to have a response returned. This snippet shows the data structure of an Axios response:\n\nIn this response, you get an object of the data that you are expecting, the status code sent back by the server, a , response headers, the config object set by Axios, and the request object that was used to generate the response. You can then consume the responses on your client-side application depending on the data that you need.\n\nNow that you’ve mastered some of the background, move on to the next section where I will show you exactly how to make HTTP requests with Axios.\n\nIn this section, you will make and requests and observe concurrent requests. You will be using a free “fake” API: JSONPlaceholder.\n\nYou will also use an application that will help you make your requests and get a better view of what is happening under the hood.\n\nBefore you get started though, you need to clone the GitHub repository for the tutorial. Run these commands:\n\nNow you should have the files you need for this tutorial. Your next step is to install both Axios and Jest as dependencies. Run this command:\n\nOpen the file on the browser to review your Axios demo webpage.\n\nThere are three buttons for each request. Clicking a button should display a response after the Axios request has been made and data returned to the browser.\n\nIn the file of your cloned repository, there is an event listener that displays the data returned by Axios. This file also has functions you will use to make your requests. Get started by making your first request.\n\nA basic request to our sample API looks like this:\n\nThis code snippet sends a request to the JSON API. Because the request returns a promise, we use the block to handle the responses. We also need to use the method to log any errors to the console.\n\nThis code snippet is already in the function in the file.\n\nNow that you understand what is happening behind the scenes, go to the browser and click the button. Below it, new content should appear, displaying details of the response.\n\nThis response from the API is broken into a few sections based on the data we have from Axios. The sections of the received Axios response are:\n• The section, which displays the status code of the response. In this case it is , which means that the request was successful.\n• The section, which contains all the HTTP headers that the server responds with.\n• The section, which contains the payload or the information that was requested from the server. In this case, it is all the information about .\n• The section, which contains all the configuration that was passed to Axios for the request.\n\nAs shown in the request, Axios behaves like the traditional library. Considering that this is a request, you do not need to pass a body with a request. Next I will show you how to do that in a request using Axios.\n\nA request is a little different because you often need to pass some data in the request to the server. In the sample application, we have a request that creates a user and passes in details for that user. The code snippet for the request looks like this:\n\nThe Axios request uses an object after the request URL to define the properties you want to create for your user. Once the operation has been completed, there will be a response from the server. To verify that your code is working, go back to the application browser window and click the POST button. This snippet is part of the function in the file.\n• The section has a status code of , which means a resource has been created. In this case, a new user has been created.\n• The section has a property for the length of the data we sent. It also specifies where the data will be stored: .\n• The section contains the information that was sent to the server.\n• The section contains the configuration that was sent along with the request. This involves the , , and being sent.\n\nYou can verify that the data defined in your request is the exact response received from the server as a created resource.\n\nIn this section, you learned how to make an Axios request, and you explored the basic structure of an Axios request and its the expected responses. In the next section, you will learn how to use request interception to verify data before it is sent to Axios as a request.\n\nIn Axios, requests or responses can be intercepted before they are handled by the or blocks. For example, say you want to check that all the requests going through to a client have a valid JWT token. To do that, you can set up a request interceptor to make sure that all the calls made to the server have that valid token. If a call does not have a valid token, the users of the system would have to go back to the login page and be reauthenticated.\n\nIn the interest of time, I will lead you through a less complicated use case, writing a logger for your current application.\n\nThe logger will log when a request was made, the URL for the request, and the time when the request was triggered. This code snippet is what the sample application uses:\n\nAxios will access the section of your requests to display the request method, URL, and time. This code snippet is part of the file in the function of the sample project.\n\nTo observe the behavior of the Axios interceptor, open the Chrome browser console. Click the method that fetches the first user in the API.\n\nFor the interceptors to work, they need to be called as concurrent requests to the API. The next code snippet shows Axios methods that implement the requests and responses:\n\nThe Chrome DevTools image shows that when you make any request, you can modify or inspect it before it is sent by Axios to the API server. Axios interceptors are not only powerful, but they also give developers the ability to control requests and the behavior of their responses.\n\nNow you have learned how to use interceptors to modify or inspect your Axios requests and responses. Great work! Your next task is writing tests for your Axios implementation.\n\nSoftware testing is an integral process in the development of virtually every application. Tests help make sure your application works as intended and that quality is consistent throughout the development process. In this section of the tutorial, you will use the version of Axios. Since you already installed Jest while installing dependencies, you can start writing tests right away.\n\nIn the root directory, there are two files named and . We use for requests and for tests.\n\nIn the file, we use to make requests in . This method uses the same request structure as the browser method does:\n\nThis snippet makes a request to the same URL used earlier and then saves the response to the variable. It then returns the response to make it accessible to other methods or functions that may need it — like our tests. The snippet exports the method to make it accessible outside the file.\n\nTo write a test for this, we import the method into the test file. Then we write the test as shown here:\n\nUsing this test and the sample response object, you can verify that the data called from the Axios endpoint was in fact returned and that your API call was successful.\n\nIn the same file, we have all three tests:\n\nNow that you understand how the tests work, run them:\n\nNow that you have written Axios requests and tested them, you can build a continuous integration(CI) pipeline for them. Using a CI/CD tool like CircleCI keeps everyone informed when changes break the pipeline and cause the tests to fail. This kind of feedback loop provides the insight and transparency needed in a successful software development process.\n\nThe sample project contains a folder and inside it, a file named . This is CircleCI’s configuration file. In the file, we have the configuration for our project:\n\nThis configuration defines your , then tells CircleCI to use a Node image to execute your tests. Once that is set up, it checks for any stored cache for the project. If there is one, it needs to be restored before doing a new dependencies install. The cache is saved after installing new dependencies, tests are executed, and any artifacts that were generated are saved.\n\nTo run the project in CircleCI, it needs to exist as a repository on your GItHub. First, create an empty repository on GitHub. Next, change the origin URL to your repo:\n\nOnce this is done, log into the CircleCI dashboard. In the Organization homepage, click Create Project. Select GitHub, then pick your project and give it a meaningful name. Finally, click Create Project.\n\nCircleCI will automatically detect your configuration file, but it won’t run the pipeline. To trigger a pipeline build, push a small, meaningless commit.\n\nYou have a successful pipeline build! Review details by clicking Jobs then build.\n\nClick the steps you want more detail about; for example the step.\n\nCircleCI detects changes every time you push to the GitHub repository in your branch. The CircleCI pipeline will execute again and make sure that your test suite runs, ensuring a successful continuous integration process.\n\nI enjoyed creating this tutorial for you, and I hope you found it valuable. Until next time, keep coding!"
    },
    {
        "link": "https://medium.com/@reggiecheston/a-beginners-guide-to-using-axios-in-node-js-simplifying-http-requests-441291fef064",
        "document": "In web development, it’s essential to understand how data is exchanged between clients (users interacting with the application) and servers (where data is stored for applications). Hypertext Transfer Protocol (HTTP) requests facilitate this exchange. In this article, we delve into the world of HTTP requests, specifically exploring Axios and how it simplifies how we structure code when defining these requests.\n\nDisclaimer: You should have a basic understanding of HTML, CSS, JavaScript, and APIs for this article.\n\nWhat is an HTTP Request?\n\nAn HTTP request refers to a communication protocol utilized by web servers and client-side applications for exchanging data over the Internet. Operating based on the Hypertext Transfer Protocol, this protocol enables users to initiate requests from their client-side applications to web servers. Upon receiving these requests, the server processes them and generates appropriate responses. This interaction facilitates various actions, including retrieving, modifying, sending, and deleting data stored on the server. These actions are defined in Axios as GET, POST, PUT, and DELETE requests respectively.\n\nThese HTTP requests can range from simple tasks such as signing into a user profile or adding an item to your favorites, to more complex actions like updating contact information or deleting a playlist from your library. In response, the server performs corresponding actions such as retrieving profile information, updating database records, or deleting relevant data tables.\n\nAxios is a popular JavaScript library used for making HTTP requests from the client-side. It offers a concise and intuitive way to send asynchronous HTTP requests to web servers, enabling developers to avoid having to write hundreds of lines of code to accomplish the same thing. The main advantages of Axios include ease of use, built-in features, and compatibility with both browser and Node.js environments.\n\nHow to Use Axios?\n\nStart by installing Axios using one of the following terminal commands, depending on whether you use npm or yarn.\n\nThen you need to import it into your working file using the traditional ‘require’ syntax or the ES6 ‘import’ syntax.\n\nOnce you’ve installed and imported Axios into your working file, you can use Axios’ simple syntax to make a request. For example, making a GET request to fetch data from an API endpoint.\n\nThis GET request starts by accessing the API via the “/data” endpoint. Once it reaches the endpoint it would ideally retrieve that raw data and log it to the console. However, if it is unable to reach the endpoint, it logs an error to the console. In the context of a real application, logging the raw data to the console could more practically be something like storing that data into a variable to later render a profile homepage with a user’s information that matches a set of login credentials.\n\nAs a comparison, this is what a GET request looks like without the use of Axios:\n\nAxios also supports other HTTP methods like POST, PUT, and DELETE, enabling you to perform a wide range of operations with ease. To follow the example from earlier of a user profile, you might use a POST request to change data like updating a user’s bio or editing a post they made. A PUT request adds data and may be used to add a new post or add something to favorites. Lastly, a DELETE request, as you might imagine, deletes data, which could be used for deleting a post or even deleting a user’s profile altogether.\n\nUnderstanding HTTP requests is essential for building robust and efficient web applications. By leveraging tools like Axios, developers can streamline the process of making requests and efficiently handle responses. Mastery of HTTP requests and utilizing Axios and libraries like it will equip you with the tools to create modern and dynamic web applications.\n\nYou can find the original Axios documentation here."
    },
    {
        "link": "https://github.com/axios/axios",
        "document": "Promise based HTTP client for the browser and node.js\n\nOnce the package is installed, you can import the library using or approach:\n\nYou can also use the default export, since the named export is just a re-export from the Axios factory:\n\nIf you use for importing, only default export is available:\n\nFor some bundlers and some ES6 linters you may need to do the following:\n\nFor cases where something went wrong when trying to import a module into a custom or legacy environment, you can try importing the module package directly:\n\nRequests can be made by passing the relevant config to .\n\nFor convenience, aliases have been provided for all common request methods.\n\nWhen using the alias methods , , and properties don't need to be specified in config.\n\nPlease use to replace the below functions.\n\nYou can create a new instance of axios with a custom config.\n\nThe available instance methods are listed below. The specified config will be merged with the instance config.\n\nThese are the available config options for making requests. Only the is required. Requests will default to if is not specified.\n\n// `url` is the server URL that will be used for the request : // `method` is the request method to be used when making the request : // `baseURL` will be prepended to `url` unless `url` is absolute and option `allowAbsoluteUrls` is set to true. // It can be convenient to set `baseURL` for an instance of axios to pass relative URLs // to methods of that instance. : // `allowAbsoluteUrls` determines whether or not absolute URLs will override a configured `baseUrl`. // When set to true (default), absolute values for `url` will override `baseUrl`. // When set to false, absolute values for `url` will always be prepended by `baseUrl`. : // `transformRequest` allows changes to the request data before it is sent to the server // This is only applicable for request methods 'PUT', 'POST', 'PATCH' and 'DELETE' // The last function in the array must return a string or an instance of Buffer, ArrayBuffer, // You may modify the headers object. : // Do whatever you want to transform the data // `transformResponse` allows changes to the response data to be made before // it is passed to then/catch : // Do whatever you want to transform the data // `headers` are custom headers to be sent : : // `params` are the URL parameters to be sent with the request // Must be a plain object or a URLSearchParams object : : // `paramsSerializer` is an optional config that allows you to customize serializing `params`. : // Custom encoder function which sends key/value pairs in an iterative fashion. ?: : : /* Do custom operations here and return transformed string */ // Custom serializer function for the entire parameter. Allows user to mimic pre 1.x behaviour. ?: : any ?: // Configuration for formatting array indexes in the params. : // Three available options: (1) indexes: null (leads to no brackets), (2) (default) indexes: false (leads to empty brackets), (3) indexes: true (leads to brackets with indexes). // `data` is the data to be sent as the request body // Only applicable for request methods 'PUT', 'POST', 'DELETE , and 'PATCH' // When no `transformRequest` is set, must be of one of the following types: : : // syntax alternative to send data into the body // only the value is sent, not the key : // `timeout` specifies the number of milliseconds before the request times out. // If the request takes longer than `timeout`, the request will be aborted. : // `withCredentials` indicates whether or not cross-site Access-Control requests // should be made using credentials : // `adapter` allows custom handling of requests which makes testing easier. : // Also, you can set the name of the built-in adapter, or provide an array with their names // to choose the first available in the environment : // `auth` indicates that HTTP Basic auth should be used, and supplies credentials. // This will set an `Authorization` header, overwriting any existing // `Authorization` custom headers you have set using `headers`. // Please note that only HTTP Basic auth is configurable through this parameter. // For Bearer tokens and such, use `Authorization` custom headers instead. : : : // `responseType` indicates the type of data that the server will respond with : // `responseEncoding` indicates encoding to use for decoding responses (Node.js only) // Note: Ignored for `responseType` of 'stream' or client-side requests : // `xsrfCookieName` is the name of the cookie to use as a value for xsrf token : // `xsrfHeaderName` is the name of the http header that carries the xsrf token value : // `undefined` (default) - set XSRF header only for the same origin requests : : // `onUploadProgress` allows handling of progress events for uploads : loaded total progress bytes estimated rate upload // Do whatever you want with the Axios progress event // `onDownloadProgress` allows handling of progress events for downloads : loaded total progress bytes estimated rate download // Do whatever you want with the Axios progress event // `maxContentLength` defines the max size of the http response content in bytes allowed in node.js : // `maxBodyLength` (Node only option) defines the max size of the http request content in bytes allowed : // `validateStatus` defines whether to resolve or reject the promise for a given // HTTP response status code. If `validateStatus` returns `true` (or is set to `null` // or `undefined`), the promise will be resolved; otherwise, the promise will be : // `maxRedirects` defines the maximum number of redirects to follow in node.js. // If set to 0, no redirects will be followed. : // `beforeRedirect` defines a function that will be called before redirect. // Use this to adjust the request options upon redirecting, // or to cancel the request by throwing an error // If maxRedirects is set to 0, `beforeRedirect` is not used. : headers // `socketPath` defines a UNIX Socket to be used in node.js. // e.g. '/var/run/docker.sock' to send requests to the docker daemon. // Only either `socketPath` or `proxy` can be specified. // If both are specified, `socketPath` is used. : // `transport` determines the transport method that will be used to make the request. // If defined, it will be used. Otherwise, if `maxRedirects` is 0, // the default `http` or `https` library will be used, depending on the protocol specified in `protocol`. // Otherwise, the `httpFollow` or `httpsFollow` library will be used, again depending on the protocol, : // `httpAgent` and `httpsAgent` define a custom agent to be used when performing http // and https requests, respectively, in node.js. This allows options to be added like // `keepAlive` that are not enabled by default. : : : : // `proxy` defines the hostname, port, and protocol of the proxy server. // You can also define your proxy using the conventional `http_proxy` and // `https_proxy` environment variables. If you are using environment variables // for your proxy configuration, you can also define a `no_proxy` environment // variable as a comma-separated list of domains that should not be proxied. // `auth` indicates that HTTP Basic auth should be used to connect to the proxy, and // This will set an `Proxy-Authorization` header, overwriting any existing // `Proxy-Authorization` custom headers you have set using `headers`. // If the proxy server uses HTTPS, then you must set the protocol to `https`. : : : // hostname: '127.0.0.1' // Takes precedence over 'host' if both are defined : : : : // `cancelToken` specifies a cancel token that can be used to cancel the request // (see Cancellation section below for details) : // an alternative way to cancel Axios requests using AbortController : // `decompress` indicates whether or not the response body should be decompressed // automatically. If set to `true` will also remove the 'content-encoding' header // from the responses objects of all decompressed responses // - Node only (XHR cannot turn off decompression) : // Indicates where to use an insecure HTTP parser that accepts invalid HTTP headers. // This may allow interoperability with non-conformant HTTP implementations. // Using the insecure parser should be avoided. : // transitional options for backward compatibility that may be removed in the newer versions : // `true` - ignore JSON parsing errors and set response.data to null if parsing failed (old behaviour) // `false` - throw SyntaxError if JSON parsing failed (Note: responseType must be set to 'json') : // default value for the current Axios version // try to parse the response string as JSON even if `responseType` is not 'json' : // throw ETIMEDOUT error instead of generic ECONNABORTED on request timeouts : : // The FormData class to be used to automatically serialize the payload into a FormData object : : : : // use dots instead of brackets format : // keep special endings like {} in parameter key : :\n\nThe response for a request contains the following information.\n\nWhen using , you will receive the response as follows:\n\nWhen using , or passing a rejection callback as second parameter of , the response will be available through the object as explained in the Handling Errors section.\n\nYou can specify config defaults that will be applied to every request.\n\nConfig will be merged with an order of precedence. The order is library defaults found in lib/defaults/index.js, then property of the instance, and finally argument for the request. The latter will take precedence over the former. Here's an example.\n\nYou can intercept requests or responses before they are handled by or .\n\nIf you need to remove an interceptor later you can.\n\nYou can also clear all interceptors for requests or responses.\n\nYou can add interceptors to a custom instance of axios.\n\nWhen you add request interceptors, they are presumed to be asynchronous by default. This can cause a delay in the execution of your axios request when the main thread is blocked (a promise is created under the hood for the interceptor and your request gets put on the bottom of the call stack). If your request interceptors are synchronous you can add a flag to the options object that will tell axios to run the code synchronously and avoid any delays in request execution.\n\nIf you want to execute a particular interceptor based on a runtime check, you can add a function to the options object. The request interceptor will not be executed if and only if the return of is . The function will be called with the config object (don't forget that you can bind your own arguments to it as well.) This can be handy when you have an asynchronous request interceptor that only needs to run at certain times.\n\nGiven you add multiple response interceptors and when the response was fulfilled\n• then each interceptor is executed\n• then they are executed in the order they were added\n• then only the last interceptor's result is returned\n• then every interceptor receives the result of its predecessor\n• and when the fulfillment-interceptor throws\n• then the following fulfillment-interceptor is not called\n• then the following rejection-interceptor is called\n• once caught, another following fulfill-interceptor is called again (just like in a promise chain).\n\nRead the interceptor tests for seeing all this in code.\n\nThere are many different axios error messages that can appear that can provide basic information about the specifics of the error and where opportunities may lie in debugging.\n\nThe general structure of axios errors is as follows:\n\nBelow is a list of potential axios identified error:\n\nthe default behavior is to reject every response that returns with a status code that falls out of the range of 2xx and treat it as an error.\n\nUsing the config option, you can override the default condition (status >= 200 && status < 300) and define HTTP code(s) that should throw an error.\n\nUsing you get an object with more information about the HTTP error.\n\nStarting from Axios supports AbortController to cancel requests in fetch API way:\n\nYou can also cancel a request using a CancelToken.\n\nYou can create a cancel token using the factory as shown below:\n\nYou can also create a cancel token by passing an executor function to the constructor:\n\nBy default, axios serializes JavaScript objects to . To send data in the format instead, you can use the API, which is supported in the vast majority of browsers,and Node starting with v10 (released in 2018).\n\nFor compatibility with very old browsers, there is a polyfill available (make sure to polyfill the global environment).\n\nAlternatively, you can encode data using the library:\n\nOr in another way (ES6),\n\nFor older Node.js engines, you can use the module as follows:\n\nYou can also use the library.\n\nAxios will automatically serialize the data object to urlencoded format if the content-type header is set to \"application/x-www-form-urlencoded\".\n\nThe server will handle it as:\n\nIf your backend body-parser (like of ) supports nested objects decoding, you will get the same object on the server-side automatically\n\nTo send the data as a you need to pass a formData instance as a payload. Setting the header is not required as Axios guesses it based on the payload type.\n\nIn node.js, you can use the library as follows:\n\nStarting from , Axios supports automatic object serialization to a FormData object if the request header is set to .\n\nThe following request will submit the data in a FormData format (Browser & Node.js):\n\nIn the build, the ( ) polyfill is used by default.\n\nYou can overload the FormData class by setting the config variable, but you probably won't need it in most cases:\n\nAxios FormData serializer supports some special endings to perform the following operations:\n• - serialize the value with JSON.stringify\n• - unwrap the array-like object as separate fields with the same key\n• - user-defined visitor function that will be called recursively to serialize the data object to a object by following custom rules.\n• - use dot notation instead of brackets to serialize arrays and objects;\n• - add the special ending (e.g ) in the FormData key. The back-end body-parser could potentially use this meta-information to automatically parse the value as JSON.\n• - controls how indexes will be added to unwrapped keys of array-like objects.\n\nLet's say we have an object like this one:\n\nThe following steps will be executed by the Axios serializer internally:\n\nAxios supports the following shortcut methods: , , which are just the corresponding http methods with the header preset to .\n\nAll files will be sent with the same field names: .\n\nPass HTML Form element as a payload to submit it as content.\n\nand objects can also be posted as by explicitly setting the header to :\n\nFor example, the Form\n\nwill be submitted as the following JSON object:\n\nSending / as JSON ( ) is not currently supported.\n\nAxios supports both browser and node environments to capture request upload/download progress. The frequency of progress events is forced to be limited to times per second.\n\nYou can also track stream upload/download progress in node.js:\n\nDownload and upload rate limits can only be set for the http adapter (node.js):\n\nAxios has its own class to manipulate headers using a Map-like API that guarantees caseless work. Although HTTP is case-insensitive in headers, Axios will retain the case of the original header for stylistic reasons and for a workaround when servers mistakenly consider the header's case. The old approach of directly manipulating headers object is still available, but deprecated and not recommended for future usage.\n\nAn AxiosHeaders object instance can contain different types of internal values. that control setting and merging logic. The final headers object with string values is obtained by Axios by calling the method.\n\nThe header value can be one of the following types:\n• - normal string value that will be sent to the server\n• - skip header when rendering to JSON, additionally indicates that method must be called with option set to to overwrite this value (Axios uses this internally to allow users to opt out of installing certain headers like or )\n• - value is not set\n\nThe headers object is always initialized inside interceptors and transformers:\n\nYou can iterate over an instance using a statement:\n\nIf the headers object is a string, it will be parsed as RAW HTTP headers.\n• - do not overwrite if header's value is set (is not )\n• (default) - overwrite the header unless its value is set to\n\nThe option can also accept a user-defined function that determines whether the value should be overwritten or not.\n\nReturns the internal value of the header. It can take an extra argument to parse the header's value with , matcher function or internal key-value parser.\n\nReturns the value of the header.\n\nReturns if the header is set (has no value).\n\nReturns if at least one header has been removed.\n\nRemoves all headers. Unlike the method matcher, this optional matcher will be used to match against the header name rather than the value.\n\nReturns if at least one header has been cleared.\n\nIf the headers object was changed directly, it can have duplicates with the same name but in different cases. This method normalizes the headers object by combining duplicate keys into one. Axios uses this method internally after calling each interceptor. Set to true for converting headers name to lowercase and capitalize the initial letters ( => )\n\nMerges the instance with targets into a new instance. If the target is a string, it will be parsed as RAW HTTP headers.\n\nResolve all internal headers values into a new null prototype object. Set to true to resolve arrays as a string containing all elements, separated by commas.\n\nReturns a new instance created from the raw headers passed in, or simply returns the given headers object if it's an instance.\n\nReturns a new instance created by merging the target objects.\n\nThe following shortcuts are available:\n\nFetch adapter was introduced in . By default, it will be used if and adapters are not available in the build, or not supported by the environment. To use it by default, it must be selected explicitly:\n\nYou can create a separate instance for this:\n\nThe adapter supports the same functionality as adapter, including upload and download progress capturing. Also, it supports additional response types such as and (if supported by the environment).\n\nUntil axios reaches a release, breaking changes will be released with a new minor version. For example , and will have the same API, but will have breaking changes.\n\naxios depends on a native ES6 Promise implementation to be supported. If your environment doesn't support ES6 Promises, you can polyfill.\n\nBecause axios dual publishes with an ESM default export and a CJS , there are some caveats. The recommended setting is to use (this is implied by ). Note that this requires TypeScript 4.7 or greater. If use ESM, your settings should be fine. If you compile TypeScript to CJS and you can’t use , you have to enable . If you use TypeScript to type check CJS JavaScript code, your only option is to use .\n\nYou can use Gitpod, an online IDE(which is free for Open Source) for contributing or running the examples online.\n\naxios is heavily inspired by the $http service provided in AngularJS. Ultimately axios is an effort to provide a standalone -like service for use outside of AngularJS."
    },
    {
        "link": "https://realpython.com/python-requests",
        "document": "The Requests library is the de facto standard for making HTTP requests in Python. It abstracts the complexities of making requests behind a beautiful, simple API so that you can focus on interacting with services and consuming data in your application.\n\nThroughout this tutorial, you’ll see some of the most useful features that Requests has to offer as well as ways to customize and optimize those features for different situations that you may come across. You’ll also learn how to use Requests in an efficient way as well as how to prevent requests to external services from slowing down your application.\n\nIn this tutorial, you’ll learn how to:\n• Make requests using the most common HTTP methods\n• Customize your requests’ headers and data using the query string and message body\n• Inspect data from your requests and responses\n• Configure your requests to help prevent your application from backing up or slowing down\n\nFor the best experience working through this tutorial, you should have basic general knowledge of HTTP. That said, you still may be able to follow along fine without it.\n\nIn the upcoming sections, you’ll see how you can install and use in your application. If you want to play with the code examples that you’ll see in this tutorial, as well as some additional ones, then you can download the code examples and work with them locally:\n\nEven though the Requests library is a common staple for many Python developers, it’s not included in Python’s standard library. There are good reasons for that decision, primarily that the library can continue to evolve more freely as a self-standing project. Note: Requests doesn’t support asynchronous HTTP requests directly. If you need async support in your program, you should try out AIOHTTP or HTTPX. The latter library is broadly compatible with Requests’ syntax. Because Requests is a third-party library, you need to install it before you can use it in your code. As a good practice, you should install external packages into a virtual environment, but you may choose to install into your global environment if you’re planning to use it across multiple projects. Whether you’re working in a virtual environment or not, you’ll need to install : Once has finished installing , you can use it in your application. Importing looks like this: Now that you’re all set up, it’s time to begin your journey through Requests. Your first goal will be learning how to make a request.\n\nA is a powerful object for inspecting the results of the request. Make that same request again, but this time store the return value in a variable so that you can get a closer look at its attributes and behaviors: In this example, you’ve captured the return value of , which is an instance of , and stored it in a variable called . You can now use to see a lot of information about the results of your request. The first bit of information that you can gather from is the status code. A status code informs you of the status of the request. For example, a status means that your request was successful, whereas a status means that the resource you were looking for wasn’t found. There are many other possible status codes as well to give you specific insights into what happened with your request. By accessing , you can see the status code that the server returned: returned , which means that your request was successful and the server responded with the data that you were requesting. Sometimes, you might want to use this information to make decisions in your code: With this logic, if the server returns a status code, then your program will print . If the result is a , then your program will print . Requests goes one step further in simplifying this process for you. If you use a instance in a conditional expression, then it’ll evaluate to if the status code was smaller than , and otherwise. Therefore, you can simplify the last example by rewriting the statement: In the code snippet above, you implicitly check whether the of is between and . If it’s not, then you raise an exception that includes the non-success status code in an f-string. Note: This truth value test is possible because is an overloaded method on . This means that the adapted default behavior of takes the status code into account when determining the truth value of the object. Keep in mind that this method is not verifying that the status code is equal to . The reason for this is that other status codes within the to range, such as and , are also considered successful in the sense that they provide some workable response. For example, the status code tells you that the response was successful, but there’s no content to return in the message body. So, make sure you use this convenient shorthand only if you want to know if the request was generally successful. Then, if necessary, you’ll need to handle the response appropriately based on the status code. Let’s say you don’t want to check the response’s status code in an statement. Instead, you want to use Request’s built-in capacities to raise an exception if the request was unsuccessful. You can do this using : If you invoke , then Requests will raise an for status codes between and . If the status code indicates a successful request, then the program will proceed without raising that exception. Now, you know a lot about how to deal with the status code of the response that you got back from the server. However, when you make a request, you rarely only care about the status code of the response. Usually, you want to see more. Next, you’ll see how to view the actual data that the server sent back in the body of the response. The response of a request often has some valuable information, known as a payload, in the message body. Using the attributes and methods of , you can view the payload in a variety of different formats. To see the response’s content in , you use : While gives you access to the raw bytes of the response payload, you’ll often want to convert them into a string using a character encoding such as UTF-8. will do that for you when you access : Because the decoding of to a requires an encoding scheme, Requests will try to guess the encoding based on the response’s headers if you don’t specify one. You can provide an explicit encoding by setting before accessing : If you take a look at the response, then you’ll see that it’s actually serialized JSON content. To get a dictionary, you could take the that you retrieved from and deserialize it using . However, a simpler way to accomplish this task is to use : The of the return value of is a dictionary, so you can access values in the object by key: You can do a lot with status codes and message bodies. But, if you need more information, like metadata about the response itself, then you’ll need to look at the response’s headers. The response headers can give you useful information, such as the content type of the response payload and a time limit on how long to cache the response. To view these headers, access : returns a dictionary-like object, allowing you to access header values by key. For example, to see the content type of the response payload, you can access : There’s something special about this dictionary-like headers object, though. The HTTP specification defines headers as case-insensitive, which means that you’re able to access these headers without worrying about their capitalization: Whether you use the key or , you’ll get the same value. Now that you’ve seen the most useful attributes and methods of in action, you already have a good overview of Requests’ basic usage. You can get content from the Internet and work with the response that you receive. But there’s more to the Internet than plain and straightforward URLs. In the next section, you’ll take a step back and see how your responses change when you customize your requests to account for query string parameters.\n\nAccording to the HTTP specification, , , and the less common requests pass their data through the message body rather than through parameters in the query string. Using Requests, you’ll pass the payload to the corresponding function’s parameter. takes a dictionary, a list of tuples, bytes, or a file-like object. You’ll want to adapt the data that send in the body of your request to the specific needs of the service that you’re interacting with. For example, if your request’s content type is , then you can send the form data as a dictionary: You can also send that same data as a list of tuples: If, however, you need to send JSON data, then you can use the parameter. When you pass JSON data via , Requests will serialize your data and add the correct header for you. Like you learned earlier, the httpbin service accepts test requests and responds with data about the requests. For instance, you can use it to inspect a basic request: You can see from the response that the server received your request data and headers as you sent them. Requests also provides this information to you in the form of a that you’ll inspect in more detail in the next section.\n\nAuthentication helps a service understand who you are. Typically, you provide your credentials to a server by passing data through the header or a custom header defined by the service. All the functions of Requests that you’ve seen to this point provide a parameter called , which allows you to pass your credentials: The request succeeds if the credentials that you pass in the tuple to are valid. When you pass your credentials in a tuple to the parameter, Requests applies the credentials using HTTP’s Basic access authentication scheme under the hood. You may wonder where the string that Requests set as the value for your header comes from. In short, it’s a Base64-encoded string of the username and password with the prefix :\n• First, Requests combines the username and password that you provided, putting a colon in between them. So for the username and password , this becomes .\n• Then, Requests encodes this string in Base64 using . The encoding converts the string to .\n• Finally, Requests adds in front of this Base64 string. This is how the final value for the header becomes in the example shown above. HTTP Basic authentication isn’t very secure, because you can decode the username and password from the Base64 string. That’s why it’s important to always send these requests over HTTPS, which provides an additional layer of security by encrypting the entire HTTP request. You could make the same request by passing explicit Basic authentication credentials using : Though you don’t need to be explicit for Basic authentication, you may want to authenticate using another method. Requests provides other methods of authentication out of the box, such as and . A real-world example of an API that requires authentication is GitHub’s authenticated user API. This endpoint provides information about the authenticated user’s profile. If you try to make a request without credentials, then you’ll see that the status code is : If you don’t provide authentication credentials when accessing a service that requires them, then you’ll get an HTTP error code as a response. To make a request to GitHub’s authenticated user API, you first need to generate a personal access token with the read:user scope. Then you can pass this token as the second element in a tuple to : Like you learned previously, this approach passes the credentials to , which expects a username and a password and sends the credentials as a Base64-encoded string with the prefix : This works, but it’s not the right way to authenticate with a Bearer token—and using an empty string input for the superfluous username is awkward. With Requests, you can supply your own authentication mechanism to fix that. To try this out, create a subclass of and implement : \"\"\"Attach an API token to the Authorization header.\"\"\" Here, your custom mechanism receives a token, then includes that token in the header of your request, also setting the recommended prefix to the string. You can now use this custom token authentication to make your call to GitHub’s authenticated user API: Your custom created a well-formatted string for the header. You can now use this more intuitive way of interacting with a token-based authentication scheme such as the one that parts of GitHub’s API require. Note: While you could construct the authentication string outside of a custom authentication class and pass it directly with , this appoach is discouraged because it can lead to unexpected behavior. When you attempt to set your authentication credentials directly using , then Requests may internally overwrite your input. This can happen, for example, if you have a file that provides authentication credentials. Requests will attempt to get the credentials from the file if you don’t provide an authentication method using . Bad authentication mechanisms can lead to security vulnerabilities. Unless a service requires a custom authentication mechanism for some reason, you’ll always want to use a tried-and-true auth scheme like the built-in Basic authentication or OAuth, for example through Requests-OAuthlib. While you’re thinking about security, consider dealing with SSL certificates using Requests.\n\nAnytime the data that you’re trying to send or receive is sensitive, security is important. The way that you communicate with secure sites over HTTP is by establishing an encrypted connection using SSL, which means that verifying the target server’s SSL certificate is critical. The good news is that Requests does this for you by default. However, there are some cases where you might want to change this behavior. If you want to disable SSL certificate verification, then you pass to the parameter of the request function: InsecureRequestWarning: Unverified HTTPS request is being made to host Requests even warns you when you’re making an insecure request to help you keep your data safe! Note: Requests uses a package called to provide certificate authorities. This lets Requests know which authorities it can trust. Therefore, you should update frequently to keep your connections as secure as possible. Now that you know how to make all sorts of HTTP requests using Requests, authenticated or not, you may wonder about how you can make sure that your program works as quickly as possible. In the next section, you’ll learn about a few ways that you can improve performance with the help of Requests.\n\nWhen using Requests, especially in a production application environment, it’s important to consider performance implications. Features like timeout control, sessions, and retry limits can help you keep your application running smoothly. When you make an inline request to an external service, your system will need to wait for the response before moving on. If your application waits too long for that response, requests to your service could back up, your user experience could suffer, or your background jobs could hang. By default, Requests will wait indefinitely on the response, so you should almost always specify a timeout duration to prevent these issues from happening. To set the request’s timeout, use the parameter. can be an integer or float representing the number of seconds to wait on a response before timing out: In the first request, the request will time out after 1 second. In the second request, the request will time out after 3.05 seconds. You can also pass a tuple to with the following two elements:\n• Connect timeout: The time it allows for the client to establish a connection to the server\n• Read timeout: The time it’ll wait on a response once your client has established a connection Both of these elements should be numbers, and can be of type or : If the request establishes a connection within 3.05 seconds and receives data within 5 seconds of the connection being established, then the response will be returned as it was before. If the request times out, then the function will raise a exception: \"The request did not time out\" Your program can catch the exception and respond accordingly. Until now, you’ve been dealing with high-level APIs such as and . These functions are abstractions of what’s going on when you make your requests. They hide implementation details, such as how connections are managed, so that you don’t have to worry about them. Underneath those abstractions is a class called . If you need to fine-tune your control over how requests are being made or improve the performance of your requests, you may need to use a instance directly. Sessions are used to persist parameters across requests. For example, if you want to use the same authentication across multiple requests, then you can use a session: In this code example, you use a context manager to ensure that the session releases the resources when it doesn’t need them anymore. In line 7, you log in using your custom . You only need to log in once per session, and then you can make multiple authenticated requests. Requests will persist the credentials while the session exists. You then make two requests to the authenticated user API in lines 9 and 10 using instead of . The primary performance optimization of sessions comes in the form of persistent connections. When your app makes a connection to a server using a , it keeps that connection around in a connection pool. When your app wants to connect to the same server again, it’ll reuse a connection from the pool rather than establishing a new one. When a request fails, you may want your application to retry the same request. However, Requests won’t do this for you by default. To apply this functionality, you need to implement a custom transport adapter. Transport adapters let you define a set of configurations for each service that you’re interacting with. For example, say you want all requests to to retry two times before finally raising a . You’d build a transport adapter, set its parameter, and mount it to an existing : In this example, you’ve set up your session so that it’ll retry a maximum of two times when your request to GitHub’s API doesn’t work as expected. When you mount the —in this case, —to , then will adhere to its configuration for each request to . Note: While the implementation shown above works, you won’t see any effect of the retry behavior unless there’s something wrong with your network connection or GitHub’s servers. If you want to play around with code that builds on top of this example, and you’d like to inspect when the retries happen, then you’re in luck. You can download the materials of this tutorial and take a look at : Get Your Code: Click here to download the free sample code that shows you how to use Python’s Requests library. The code in this file improves on the example shown above by using the underlying to further customize the retry functionality. It also adds logging to display debugging output, which gives you a chance to monitor when Python attempted the retries. Requests comes packaged with intuitive implementations for timeouts, transport adapters, and sessions that can help you keep your code efficient and your application resilient."
    },
    {
        "link": "https://requests.readthedocs.io",
        "document": "Requests is an elegant and simple HTTP library for Python, built for human beings.\n\nRequests allows you to send HTTP/1.1 requests extremely easily. There’s no need to manually add query strings to your URLs, or to form-encode your POST data. Keep-alive and HTTP connection pooling are 100% automatic, thanks to urllib3."
    },
    {
        "link": "https://requests.readthedocs.io/en/latest/user/advanced",
        "document": "This document covers some of Requests more advanced features.\n\nThe Session object allows you to persist certain parameters across requests. It also persists cookies across all requests made from the Session instance, and will use ’s connection pooling. So if you’re making several requests to the same host, the underlying TCP connection will be reused, which can result in a significant performance increase (see HTTP persistent connection). A Session object has all the methods of the main Requests API. Sessions can also be used to provide default data to the request methods. This is done by providing data to the properties on a Session object: # both 'x-test' and 'x-test2' are sent Any dictionaries that you pass to a request method will be merged with the session-level values that are set. The method-level parameters override session parameters. Note, however, that method-level parameters will not be persisted across requests, even if using a session. This example will only send the cookies with the first request, but not the second: If you want to manually add cookies to your session, use the Cookie utility functions to manipulate . Sessions can also be used as context managers: This will make sure the session is closed as soon as the block is exited, even if unhandled exceptions occurred. Sometimes you’ll want to omit session-level keys from a dict parameter. To do this, you simply set that key’s value to in the method-level parameter. It will automatically be omitted. All values that are contained within a session are directly available to you. See the Session API Docs to learn more.\n\nWhenever you receive a object from an API call or a Session call, the attribute is actually the that was used. In some cases you may wish to do some extra work to the body or headers (or anything else really) before sending a request. The simple recipe for this is the following: # do something with prepped.body 'No, I want exactly this as the body.' # do something with prepped.headers Since you are not doing anything special with the object, you prepare it immediately and modify the object. You then send that with the other parameters you would have sent to or . However, the above code will lose some of the advantages of having a Requests object. In particular, -level state such as cookies will not get applied to your request. To get a with that state applied, replace the call to with a call to , like this: # do something with prepped.body 'Seriously, send exactly these bytes.' # do something with prepped.headers When you are using the prepared request flow, keep in mind that it does not take into account the environment. This can cause problems if you are using environment variables to change the behaviour of requests. For example: Self-signed SSL certificates specified in will not be taken into account. As a result an is thrown. You can get around this behaviour by explicitly merging the environment settings into your session:\n\nIf you need to use a proxy, you can configure individual requests with the argument to any request method: Alternatively you can configure it once for an entire : Setting may behave differently than expected. Values provided will be overwritten by environmental proxies (those returned by urllib.request.getproxies). To ensure the use of proxies in the presence of environmental proxies, explicitly specify the argument on all individual requests as initially explained above. When the proxies configuration is not overridden per request as shown above, Requests relies on the proxy configuration defined by standard environment variables , , , and . Uppercase variants of these variables are also supported. You can therefore set them to configure Requests (only set the ones relevant to your needs): To use HTTP Basic Auth with your proxy, use the syntax in any of the above configuration entries: Storing sensitive username and password information in an environment variable or a version-controlled file is a security risk and is highly discouraged. To give a proxy for a specific scheme and host, use the form for the key. This will match for any request to the given scheme and exact hostname. Note that proxy URLs must include the scheme. Finally, note that using a proxy for https connections typically requires your local machine to trust the proxy’s root certificate. By default the list of certificates trusted by Requests can be found with: You override this default certificate bundle by setting the (or ) environment variable to another file path: In addition to basic HTTP proxies, Requests also supports proxies using the SOCKS protocol. This is an optional feature that requires that additional third-party libraries be installed before use. You can get the dependencies for this feature from : Once you’ve installed those dependencies, using a SOCKS proxy is just as easy as using a HTTP one: Using the scheme causes the DNS resolution to happen on the client, rather than on the proxy server. This is in line with curl, which uses the scheme to decide whether to do the DNS resolution on the client or proxy. If you want to resolve the domains on the proxy server, use as the scheme.\n\nRequests provides access to almost the full range of HTTP verbs: GET, OPTIONS, HEAD, POST, PUT, PATCH and DELETE. The following provides detailed examples of using these various verbs in Requests, using the GitHub API. We will begin with the verb most commonly used: GET. HTTP GET is an idempotent method that returns a resource from a given URL. As a result, it is the verb you ought to use when attempting to retrieve data from a web location. An example usage would be attempting to get information about a specific commit from GitHub. Suppose we wanted commit on Requests. We would get it like so: We should confirm that GitHub responded correctly. If it has, we want to work out what type of content it is. Do this like so: So, GitHub returns JSON. That’s great, we can use the method to parse it into Python objects. So far, so simple. Well, let’s investigate the GitHub API a little bit. Now, we could look at the documentation, but we might have a little more fun if we use Requests instead. We can take advantage of the Requests OPTIONS verb to see what kinds of HTTP methods are supported on the url we just used. Uh, what? That’s unhelpful! Turns out GitHub, like many API providers, don’t actually implement the OPTIONS method. This is an annoying oversight, but it’s OK, we can just use the boring documentation. If GitHub had correctly implemented OPTIONS, however, they should return the allowed methods in the headers, e.g. Turning to the documentation, we see that the only other method allowed for commits is POST, which creates a new commit. As we’re using the Requests repo, we should probably avoid making ham-handed POSTS to it. Instead, let’s play with the Issues feature of GitHub. This documentation was added in response to Issue #482. Given that this issue already exists, we will use it as an example. Let’s start by getting it. Cool, we have three comments. Let’s take a look at the last of them. Probably in the \"advanced\" section Well, that seems like a silly place. Let’s post a comment telling the poster that he’s silly. Who is the poster, anyway? OK, so let’s tell this Kenneth guy that we think this example should go in the quickstart guide instead. According to the GitHub API doc, the way to do this is to POST to the thread. Let’s do it. \"Sounds great! I'll get right on it!\" Huh, that’s weird. We probably need to authenticate. That’ll be a pain, right? Wrong. Requests makes it easy to use many forms of authentication, including the very common Basic Auth. Sounds great! I'll get right on it. Brilliant. Oh, wait, no! I meant to add that it would take me a while, because I had to go feed my cat. If only I could edit this comment! Happily, GitHub allows us to use another HTTP verb, PATCH, to edit this comment. Let’s do that. \"Sounds great! I'll get right on it once I feed my cat.\" Excellent. Now, just to torture this Kenneth guy, I’ve decided to let him sweat and not tell him that I’m working on this. That means I want to delete this comment. GitHub lets us delete comments using the incredibly aptly named DELETE method. Let’s get rid of it. Excellent. All gone. The last thing I want to know is how much of my ratelimit I’ve used. Let’s find out. GitHub sends that information in the headers, so rather than download the whole page I’ll send a HEAD request to get the headers. Excellent. Time to write a Python program that abuses the GitHub API in all kinds of exciting ways, 4995 more times.\n\nAs of v1.0.0, Requests has moved to a modular internal design. Part of the reason this was done was to implement Transport Adapters, originally described here. Transport Adapters provide a mechanism to define interaction methods for an HTTP service. In particular, they allow you to apply per-service configuration. Requests ships with a single Transport Adapter, the . This adapter provides the default Requests interaction with HTTP and HTTPS using the powerful urllib3 library. Whenever a Requests is initialized, one of these is attached to the object for HTTP, and one for HTTPS. Requests enables users to create and use their own Transport Adapters that provide specific functionality. Once created, a Transport Adapter can be mounted to a Session object, along with an indication of which web services it should apply to. The mount call registers a specific instance of a Transport Adapter to a prefix. Once mounted, any HTTP request made using that session whose URL starts with the given prefix will use the given Transport Adapter. The adapter will be chosen based on a longest prefix match. Be mindful prefixes such as will also match or . It’s recommended to terminate full hostnames with a . Many of the details of implementing a Transport Adapter are beyond the scope of this documentation, but take a look at the next example for a simple SSL use- case. For more than that, you might look at subclassing the . The Requests team has made a specific choice to use whatever SSL version is default in the underlying library (urllib3). Normally this is fine, but from time to time, you might find yourself needing to connect to a service-endpoint that uses a version that isn’t compatible with the default. You can use Transport Adapters for this by taking most of the existing implementation of HTTPAdapter, and adding a parameter ssl_version that gets passed-through to . We’ll make a Transport Adapter that instructs the library to use SSLv3: \"\"\"\"Transport adapter\" that allows us to use SSLv3.\"\"\" By default, Requests does not retry failed connections. However, it is possible to implement automatic retries with a powerful array of features, including backoff, within a Requests using the urllib3.util.Retry class:\n\nMost requests to external servers should have a timeout attached, in case the server is not responding in a timely manner. By default, requests do not time out unless a timeout value is set explicitly. Without a timeout, your code may hang for minutes or more. The connect timeout is the number of seconds Requests will wait for your client to establish a connection to a remote machine (corresponding to the connect()) call on the socket. It’s a good practice to set connect timeouts to slightly larger than a multiple of 3, which is the default TCP packet retransmission window. Once your client has connected to the server and sent the HTTP request, the read timeout is the number of seconds the client will wait for the server to send a response. (Specifically, it’s the number of seconds that the client will wait between bytes sent from the server. In 99.9% of cases, this is the time before the server sends the first byte). If you specify a single value for the timeout, like this: The timeout value will be applied to both the and the timeouts. Specify a tuple if you would like to set the values separately: If the remote server is very slow, you can tell Requests to wait forever for a response, by passing None as a timeout value and then retrieving a cup of coffee. The connect timeout applies to each connection attempt to an IP address. If multiple addresses exist for a domain name, the underlying will try each address sequentially until one successfully connects. This may lead to an effective total connection timeout multiple times longer than the specified time, e.g. an unresponsive server having both IPv4 and IPv6 addresses will have its perceived timeout doubled, so take that into account when setting the connection timeout. Neither the connect nor read timeouts are wall clock. This means that if you start a request, and look at the time, and then look at the time when the request finishes or times out, the real-world time may be greater than what you specified."
    },
    {
        "link": "https://stackoverflow.com/questions/37012486/python-3-x-how-to-get-http-version-using-requests-library",
        "document": "I think what you want is this. Calling version on raw will give you HTTP version. (I found the example of server running HTTP 1.0 using Shodan for testing purposes)\n\nThis is not mentioned in the docs directly, I found it by using PyCharm's autocomplete feature. But I have looked into it. The reason why is HTTP version returned as integer is historical.\n\nRequests for python3 uses urllib3. Urllib3's class urllib3.response.HTTPResponse is backwards compatible with httplib’s HTTPResponse see urllib3 docs\n\nNow if it's backwards compatible you have to check documentation for httplib and if you search you'll find\n\nHere is the exact link HTTPResponse.version"
    },
    {
        "link": "https://stackoverflow.com/questions/10588644/how-can-i-see-the-entire-http-request-thats-being-sent-by-my-python-application",
        "document": "You can use HTTP Toolkit to do exactly this.\n\nIt's especially useful if you need to do this quickly, with no code changes: you can open a terminal from HTTP Toolkit, run any Python code from there as normal, and you'll be able to see the full content of every HTTP/HTTPS request immediately.\n\nThere's a free version that can do everything you need, and it's 100% open source.\n\nI'm the creator of HTTP Toolkit; I actually built it myself to solve the exact same problem for me a while back! I too was trying to debug a payment integration, but their SDK didn't work, I couldn't tell why, and I needed to know what was actually going on to properly fix it. It's very frustrating, but being able to see the raw traffic really helps."
    },
    {
        "link": "https://php.net/manual/en/ref.curl.php",
        "document": "simon [at] vhostdirect [dot] co [dot] uk ¶ \n\n\n\nAfter reinstalling MS-VC7 and compiling OpenSSL to finally realise this was'nt nesscary.\n\n\n\nIf your like me and like *Nix systems more than Windows then you'll most probly have similar problems.\n\n\n\nI came across this, on a simple google with the right keywords.\n\n\n\nhttp://www.tonyspencer.com/journal/00000037.htm\n\n\n\nI read thru that and found my mistake.\n\n\n\nIts just a small list of notes, I found them to be the best I've found on the subject and the most simplist.\n\n\n\nDont forget to add a simple line like this into your scripts to get them working on Win32.\n\n\n\n \n\nLast note: ca-bundle.crt file is located in the Curl download. I stored mine in the windows directory and apache/php can access it fine.\n\n\n\nAll the best and I hope this helps.\n\n\n\nSimon Lightfoot\n\nvHost Direct Limited It took me quite some to to figure out how to get Curl (with SSL), OpenSSL and PHP to play nicely together.After reinstalling MS-VC7 and compiling OpenSSL to finally realise this was'nt nesscary.If your like me and like *Nix systems more than Windows then you'll most probly have similar problems.I came across this, on a simple google with the right keywords.I read thru that and found my mistake.Its just a small list of notes, I found them to be the best I've found on the subject and the most simplist.Dont forget to add a simple line like this into your scripts to get them working on Win32.Last note: ca-bundle.crt file is located in the Curl download. I stored mine in the windows directory and apache/php can access it fine.All the best and I hope this helps.Simon LightfootvHost Direct Limited\n\nmikeb[at]xamo[dot]com ¶ A note of warning for PHP 5 users: if you try to fetch the CURLINFO_CONTENT_TYPE using curl_getinfo when there is a connect error, you will core dump PHP. I have informed the Curl team about this, so it will hopefully be fixed soon. Just make sure you check for an error before you look for this data.\n\nkillermonk at REMOVE dot killermonk dot com ¶ For anyone trying to use cURL to submit to an ASP/ASPX page that uses an image as the submit button.\n\n\n\nMake sure that you have 'button_name.x' and 'button_name.y' in the post fields. PHP names these fields 'button_name_x' and 'button_name_y', while ASP uses a dot.\n\n\n\nAlso, as noted above, be sure to include the '__VIEWSTATE' input field in your post request.\n\nPeter X. ¶ \n\n\n\nFor example, the following code is likely to generate a memory limit error:\n\n\n\n \n\nWhile this, on the other hand, wouldn't\n\n\n\n Although it has been noted that cURL outperforms both file_get_contents and fopen when it comes to getting a file over a HTTP link, the disadvantage of cURL is that it has no way of only reading a part of a page at a time.For example, the following code is likely to generate a memory limit error:While this, on the other hand, wouldn't\n\nalidrus at langkah dot com ¶ In recent versions of php, CURLOPT_MUTE has (probably) been deprecated. Any attempt of using curl_setopt() to set CURLOPT_MUTE will give you a warning like this: \n\n \n\nPHP Notice: Use of undefined constant CURLOPT_MUTE - assumed 'CURLOPT_MUTE' in .... \n\n \n\nIf you wish tu silence the curl output, use the following instead: \n\n \n\n \n\nAnd then, \n\n \n\n \n\nThe output of the curl operation will be stored as a string in $curl_output while the operation remains totally silent.\n\nrichardkmiller AT gmail ¶ Beware of any extra spaces in the URL. A trailing space in the URL caused my script to fail with the message \"empty reply from server\"."
    },
    {
        "link": "https://php.net/manual/en/book.curl.php",
        "document": "frank at interactinet dot com ¶ I wrote the following to see if a submitted URL has a valid http response code and also if it responds quickly. \n\n \n\nUse the code like this: \n\n \n\n \n\nThe second argument is optional, and it allows you to check for a specific response code \n\n \n\n \n\nThe third allows you to specify how long you are willing to wait for a response. \n\n \n\n \n\n \n\nHope this example helps. It is not 100% tested, so any feedback [sent directly to me by email] is appreciated.\n\nartax_N_O_S_P_A_M_erxes2 at iname dot com ¶ \n\nOn a default install of Fedora, setting up the proper cURL parameters, I would get an error: \n\n \n\n$ php curl.php \n\n Peer certificate cannot be authenticated with known CA certificates \n\n \n\nThe data on \n\n \n\n# cd /etc/pki/nssdb \n\n# ln -s /usr/lib64/libnssckbi.so libnssckbi.so \n\n \n\nNow you can do client authentication, provided you have your certificate handy with: \n\n \n\n I needed to use cURL in a php script to download data using not only SSL for the server authentication but also for client authentication.On a default install of Fedora, setting up the proper cURL parameters, I would get an error:$ php curl.phpPeer certificate cannot be authenticated with known CA certificatesThe data on http://curl.haxx.se/docs/sslcerts.html was most useful. Indeed, toward to bottom it tells you to add a missing link inside /etc/pki/nssdb to use the ca-bundle.crt file. You do it so:# cd /etc/pki/nssdb# ln -s /usr/lib64/libnssckbi.so libnssckbi.soNow you can do client authentication, provided you have your certificate handy with:\n\nramez at dot dontspan dot zegenie dot com ¶ CURL failed with PHP5.3 and Apache2.2.X on my Windows 7 machine. \n\n\n\nIt turns out that it's not enough to copy the two dll's mentioned (libeay32 and sslea32) from the php folder into your system32 folder. You HAVE TO UNBLOCK THESE TWO FILES.\n\n\n\nRight click the file, select unblock, for each one. Then restart Apache.\n\n\n\nAnother very handy security feature added into Windows.\n\njcmargentina at gmail dot com ¶ Please note that new versions of curl is using http2 as default, so if you are having some strange errors, 0 http status codes, etc, please explicitly specify the http version in your code.\n\nfred dot knieper at gmail dot com ¶ After a lot of frustration with the fact that nobody has documented which curl commandline options go with which library functions, I discovered that the curl commandline will tell you (in the form of a C program) if you add `--libcurl foo.c`\n\n\n\nIf you've been struggling with trying to figure out how to get your fancy curl commandline to work in PHP, this makes it a breeze!"
    },
    {
        "link": "https://stackoverflow.com/questions/2138527/php-curl-and-http-post-example",
        "document": "I expect the cURL to return a response like result=OK . Are there any examples?\n\nI want to send data like this:\n\nCan anyone show me how to do a PHP cURL with an HTTP POST?\n\n// set post fields $post = [ 'username' => 'user1', 'password' => 'passuser1', 'gender' => 1, ]; $ch = curl_init('http://www.example.com'); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); curl_setopt($ch, CURLOPT_POSTFIELDS, $post); // execute! $response = curl_exec($ch); // close the connection, release resources used curl_close($ch); // do anything you want with your response var_dump($response); <?php // mutatis mutandis namespace MyApp\\Http; class CurlPost { private $url; private $options; /** * @param string $url Request URL * @param array $options cURL options */ public function __construct($url, array $options = []) { $this->url = $url; $this->options = $options; } /** * Get the response * @return string * @throws \\RuntimeException On cURL error */ public function __invoke(array $post) { $ch = \\curl_init($this->url); foreach ($this->options as $key => $val) { \\curl_setopt($ch, $key, $val); } \\curl_setopt($ch, \\CURLOPT_RETURNTRANSFER, true); \\curl_setopt($ch, \\CURLOPT_POSTFIELDS, $post); $response = \\curl_exec($ch); $error = \\curl_error($ch); $errno = \\curl_errno($ch); if (\\is_resource($ch)) { \\curl_close($ch); } if (0 !== $errno) { throw new \\RuntimeException($error, $errno); } return $response; } } // create curl object $curl = new \\MyApp\\Http\\CurlPost('http://www.example.com'); try { // execute the request echo $curl([ 'username' => 'user1', 'password' => 'passuser1', 'gender' => 1, ]); } catch (\\RuntimeException $ex) { // catch errors die(sprintf('Http error %s with code %d', $ex->getMessage(), $ex->getCode())); } Side note here: it would be best to create some kind of interface called for example with method and let the class above implement it. Then you can always swap this implementation with another adapter of your like, without any side effects to your application. Usually there's a problem with cURL in PHP under the Windows operating system. While trying to connect to a https protected endpoint, you will get an error telling you that . What most people do here is to tell the cURL library to simply ignore certificate errors and continue ( ). As this will make your code work, you introduce huge security hole and enable malicious users to perform various attacks on your app like Man In The Middle attack or such. Never, ever do that. Instead, you simply need to modify your and tell PHP where your file is to let it verify certificates correctly: ; modify the absolute path to the cacert.pem file curl.cainfo=c:\\php\\cacert.pem The latest can be downloaded from the Internet or extracted from your favorite browser. When changing any related settings remember to restart your webserver.\n• If your request has headers like bearer token or defining JSON contents you have to set options to cURL: $token = \"generated token code\"; curl_setopt( $ch, CURLOPT_HTTPHEADER, array( 'Content-Type: application/json', // for define content type that is json 'bearer: '.$token, // send token in header request 'Content-length: 100' // content length for example 100 characters (can add by strlen($fields)) ) );\n• If you want to include the header in the output set to :\n• Set option to to return the transfer as a string instead of outputting it directly:\n• To check the existence of a common name in the SSL peer certificate can be set to , , 2(default value and for production mode) :\n• For posting fields as an array by cURL:\n• Execute cURL and return the string. depending on your resource this returns output like :\n• The whole class that can be extended: class class_name_for_call_cURL { protected function getUrl() { return \"www.domain.com\"; } public function call_cURL() { $token = \"generated token code\"; $fields = array( \"username\" => \"user1\", \"password\" => \"passuser1\", \"gender\" => 1 ); $url = $this->getUrl(); $output = $this->_execute($fields, $url, $token); // if you want to get json data // $output = json_decode($output); if ($output == \"OK\") { return true; } else { return false; } } private function _execute($postData, $url, $token) { // for sending data as json type $fields = json_encode($postData); $ch = curl_init($url); curl_setopt( $ch, CURLOPT_HTTPHEADER, array( 'Content-Type: application/json', // if the content type is json 'bearer: '.$token // if you need token in header ) ); curl_setopt($ch, CURLOPT_HEADER, false); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2); curl_setopt($ch, CURLOPT_POSTFIELDS, $fields); $result = curl_exec($ch); curl_close($ch); return $result; } }\n• Using the class and call cURL:\n• A function for using anywhere that needed: function get_cURL() { $url = \"www.domain.com\"; $token = \"generated token code\"; $postData = array( \"username\" => \"user1\", \"password\" => \"passuser1\", \"gender\" => 1 ); // for sending data as json type $fields = json_encode($postData); $ch = curl_init($url); curl_setopt( $ch, CURLOPT_HTTPHEADER, array( 'Content-Type: application/json', // if the content type is json 'bearer: '.$token // if you need token in header ) ); curl_setopt($ch, CURLOPT_HEADER, false); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2); curl_setopt($ch, CURLOPT_POSTFIELDS, $fields); $result = curl_exec($ch); curl_close($ch); return $result; }\n• This function is usable just by:\n\nit's simple, it works; I use it in an environment where I control the code at both ends. even better, use json_decode (and set up your code to return JSON) this approach invokes curl behind the scenes, but you don't jump through as many hoops. Answer refined from this original answer elsewhere on Stack Overflow: PHP sending variables to file_get_contents()\n\nA simpler answer IF you are passing information to your own website is to use a SESSION variable. Begin php page with: If at some point there is information you want to generate in PHP and pass to the next page in the session, instead of using a POST variable, assign it to a SESSION variable. Example: $_SESSION['message']='www.'.$_GET['school'].'.edu was not found. Please try again.' Then on the next page you simply reference this SESSION variable. NOTE: after you use it, be sure you destroy it, so it doesn't persist after it is used:\n\nI think this might be helpful if you are using Postman, as it would make the process very easy here in the given below I attached picture you can refer also if you need to convert the response to any other type let me know i will help you <?php // code by Dasun 18/04/2022 // The data to be sent $data = array( 'username' => 'user1', 'password' => 'passuser1', 'gender' => '1' ); // The target URL $url = 'http://www.example.com'; // Initialize cURL $ch = curl_init($url); // Set the request method to POST curl_setopt($ch, CURLOPT_POST, true); // Set the POST data curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($data)); // Set the response format to plain text curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); // Execute the request and get the response $response = curl_exec($ch); // Close the cURL handle curl_close($ch); // Output the response echo $response; ?>\n\nIf you try to login on site with cookies. if ($server_output == \"OK\") { ... } else { ... } It May not works if you try to login, because many sites return status 200, but the post is not successful. The easy way to check if the login post is successful is to check if it setting cookies again. If in output have a Set-Cookies string, this means the posts are not successful and it starts a new session. Also, the post can be successful, but the status can redirect instead of 200. To be sure the post is successful try this: Follow location after the post, so it will go to the page where the post does redirect to: And than check if new cookies existing in the request: if (!preg_match('/^Set-Cookie:\\s*([^;]*)/mi', $server_output)) {echo 'post successful'; } else { echo 'not successful'; }"
    },
    {
        "link": "https://medium.com/@padamghimire/using-curl-in-php-making-http-requests-simplified-with-basiccurl-f4367b51b9d1",
        "document": "In the world of web development, interacting with remote servers and APIs is a common task. Whether you’re fetching data from a RESTful API, sending data to a third-party service, or integrating with external systems, making HTTP requests is fundamental. In PHP, the cURL library is a powerful tool that allows you to handle HTTP requests and responses effectively.\n\nIn this article, we’ll explore the use of cURL in PHP and introduce the class, which simplifies common HTTP request tasks. We'll cover the various methods in this class and provide examples of how to use them in real-world scenarios.\n\ncURL is a command-line tool and library for transferring data with URLs. It supports various protocols, including HTTP, HTTPS, FTP, and more. In PHP, the cURL library is accessible through functions that enable you to perform HTTP requests programmatically.\n\nThe class is designed to streamline the process of making HTTP requests using cURL in PHP. It encapsulates common cURL operations into reusable methods, making it easier to interact with external APIs and web services.\n\nLet’s dive into the methods provided by the class and understand their purposes:\n\nThis method is used for making a POST request with custom headers and an optional POST body. It takes three parameters:\n• : The URL to which the request is sent.\n• : An array of HTTP headers to be included in the request.\n• : An optional array of data to be sent in the POST request body.\n\nHere’s an example of how to use this method:\n\nSimilar to the previous method, this one also makes a POST request with custom headers and an optional POST body. However, it includes additional cURL options for advanced customization. Use this method when you need fine-grained control over your POST requests.\n\nThis method is specifically designed for making POST requests with JSON data in the request body. It sets the content type header to indicate JSON data. Use this method when working with APIs that expect JSON payloads.\n\nThis method is for making GET requests. It takes a single parameter, , and makes a GET request to the specified URL. It does not include custom headers.\n\nHere’s an example of how to use it:\n\nSimilar to , this method allows you to include custom headers in the GET request. It takes two parameters: and . Use it when you need to send specific headers with your GET request.\n\nLet’s take a closer look at each method, their parameters, and how to use them effectively.\n• Use this method for making POST requests with custom headers and an optional POST body.\n• should be an array of HTTP headers, such as authorization tokens or content type.\n• You can include POST data in the parameter as an associative array.\n• Similar to the previous method but offers advanced cURL options.\n• Useful when you need to control encoding, maximum redirections, timeout, and HTTP version for your POST requests.\n• Set the parameter to indicate that the content type is JSON.\n• The parameter should contain the JSON data to be sent.\n• Use this method for simple GET requests.\n• Provide the parameter to specify the URL you want to fetch.\n• It does not include custom headers.\n• Similar to but allows you to send custom headers.\n• Include both the and parameters.\n\nWhen using the class, it's essential to follow best practices to ensure secure and efficient HTTP requests:\n• Error Handling: Implement robust error handling to capture and handle exceptions or errors that may occur during HTTP requests.\n• Response Parsing: Depending on the API or service you’re interacting with, make sure to parse the response appropriately to extract the necessary data.\n• Secure Data Handling: If you’re working with sensitive data, such as API keys or tokens, ensure they are stored and transmitted securely.\n• Testing and Debugging: Test your HTTP requests thoroughly and use debugging tools like cURL verbose mode or error logging to troubleshoot any issues.\n\nThe class simplifies the process of making HTTP requests in PHP using the cURL library. By encapsulating common cURL operations into reusable methods, it provides a clean and organized way to interact with external APIs and web services. Whether you're sending data to a RESTful API, fetching information from a third-party service, or integrating with external systems, the class can save you time and effort in handling HTTP requests effectively.\n\nIn your PHP projects, consider utilizing this class to enhance the reliability and maintainability of your HTTP request logic."
    },
    {
        "link": "https://serpapi.com/blog/how-to-use-curl-in-php",
        "document": "If you're working with PHP and need to get or send data from a website, cURL is the tool you'll need. This post is going to show you the basics of cURL: what it is, and how you can use it in your PHP projects.\n\nWe'll go through easy examples to help you understand how to make cURL work for you. So, let's get started and learn how to use this handy tool in PHP!\n\nWhat is cURL in PHP?\n\ncURL in PHP is a tool that lets you make requests to other websites or servers from your PHP code. It's like using a web browser or phone app to access a website or online service, but your PHP script does it instead.\n\nYou can use cURL to get data from a website, send files, or interact with APIs (which are like special access points for different online services). It's handy for making your PHP code talk to other websites or online services.\n\nHow to use cURL in PHP?\n\nUnlike other programming languages, cURL is supported out of the box in PHP. This is a step-by-step on how to use cURL in PHP:\n\nStep 1: Install libcurl\n\nWe need to install the libcurl itself first (library for cURL). Please note that this is not a PHP package. It's the curl library itself.\n\nStep 2: Verify it's enabled\n\nCreate a simple PHP script that calls the function. This function outputs a lot of information about your PHP environment, including which extensions are enabled. Look for a section about cURL. If it's there, cURL is enabled.\n\nVisit the page and locate the \"cURL support\" section to see if it's already enabled.\n\nWhat if it isn't enabled yet?\n\nOpen your file, which is the configuration file for PHP. Look for a line that says . Uncomment this line, then save the file. Don't forget to restart the server as well.\n\nStep 3: Start writing cURL!\n\nHere is a simple cURL example in PHP\n\nCode explanation:\n\n- curl_init: initialize the curl\n\n- curl_setopt: any option or setting for this curl request\n\n- curl_exec: To execute the curl\n\n- curl_close: closing the connection\n\nThis will be the default template when running a cURL in PHP.\n\nHere are some cURL commands in PHP.\n\nSure, I'll list some common cURL settings in PHP for different types of requests. These are to be used with or functions between and .\n\nNo additional settings are required for a simple GET request beyond initializing cURL and setting the URL.\n\nTo save the output directly to a file:\n\nRemember to close the file with after .\n\nTo add a custom header to your request:\n\nRemember to replace with the actual proxy server address and port.\n\nSee a real-world example using SerpApi API with cURL:\n\nBenefits of using cURL in PHP\n\n\n\nHere are the top five benefits of using cURL in PHP instead of performing cURL commands directly on the command line:\n• Integration with Web Applications: Using cURL in PHP allows for direct integration with web applications. This is crucial for dynamically fetching data from external sources, interacting with APIs, and integrating these processes seamlessly into the overall workflow of the web application.\n• Automated Data Processing: PHP enables automatic processing and manipulation of the data retrieved through cURL. This is particularly useful for handling responses in various formats like JSON or XML, which are common in web services and APIs.\n• Error Handling: PHP offers more sophisticated error-handling capabilities when using cURL. This allows for more robust programming by programmatically responding to different error conditions, logging them, or triggering specific actions based on the type of error.\n• Dynamic Request Customization: PHP can dynamically create cURL requests based on various conditions such as user input, database contents, or other logic. This flexibility is essential for applications requiring customizable and dynamic web requests.\n• Session Management: cURL in PHP can be used in conjunction with session management to maintain stateful interactions with external services. This is important for scenarios like web scraping or dealing with APIs that require authenticated sessions.\n\nThese benefits make using cURL in PHP advantageous for developing complex, data-driven web applications, especially compared to the more manual and less dynamic nature of command-line cURL usage.\n\nWhat is the curl alternative in PHP?\n\nGuzzle can be considered a modern alternative to cURL in PHP. Guzzle is a PHP HTTP client that makes it easy to send HTTP requests and trivial to integrate with web services.\n\nLink: https://docs.guzzlephp.org/en/latest/"
    }
]