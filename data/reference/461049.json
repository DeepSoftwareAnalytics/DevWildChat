[
    {
        "link": "https://vuejs.org/guide/essentials/reactivity-fundamentals.html",
        "document": "With the Options API, we use the option to declare reactive state of a component. The option value should be a function that returns an object. Vue will call the function when creating a new component instance, and wrap the returned object in its reactivity system. Any top-level properties of this object are proxied on the component instance ( in methods and lifecycle hooks): // `mounted` is a lifecycle hook which we will explain later // `this` refers to the component instance. // data can be mutated as well These instance properties are only added when the instance is first created, so you need to ensure they are all present in the object returned by the function. Where necessary, use , or some other placeholder value for properties where the desired value isn't yet available. It is possible to add a new property directly to without including it in . However, properties added this way will not be able to trigger reactive updates. Vue uses a prefix when exposing its own built-in APIs via the component instance. It also reserves the prefix for internal properties. You should avoid using names for top-level properties that start with either of these characters. In Vue 3, data is made reactive by leveraging JavaScript Proxies. Users coming from Vue 2 should be aware of the following edge case: When you access after assigning it, the value is a reactive proxy of the original . Unlike in Vue 2, the original is left intact and will not be made reactive: make sure to always access reactive state as a property of .\n\nIn Composition API, the recommended way to declare reactive state is using the function: takes the argument and returns it wrapped within a ref object with a property: To access refs in a component's template, declare and return them from a component's function: // `setup` is a special hook dedicated for the Composition API. // expose the ref to the template Notice that we did not need to append when using the ref in the template. For convenience, refs are automatically unwrapped when used inside templates (with a few caveats). You can also mutate a ref directly in event handlers: For more complex logic, we can declare functions that mutate refs in the same scope and expose them as methods alongside the state: // .value is needed in JavaScript // don't forget to expose the function as well. Exposed methods can then be used as event handlers: Here's the example live on Codepen, without using any build tools. Manually exposing state and methods via can be verbose. Luckily, it can be avoided when using Single-File Components (SFCs). We can simplify the usage with : Top-level imports, variables and functions declared in are automatically usable in the template of the same component. Think of the template as a JavaScript function declared in the same scope - it naturally has access to everything declared alongside it. For the rest of the guide, we will be primarily using SFC + syntax for the Composition API code examples, as that is the most common usage for Vue developers. If you are not using SFC, you can still use Composition API with the option. You might be wondering why we need refs with the instead of plain variables. To explain that, we will need to briefly discuss how Vue's reactivity system works. When you use a ref in a template, and change the ref's value later, Vue automatically detects the change and updates the DOM accordingly. This is made possible with a dependency-tracking based reactivity system. When a component is rendered for the first time, Vue tracks every ref that was used during the render. Later on, when a ref is mutated, it will trigger a re-render for components that are tracking it. In standard JavaScript, there is no way to detect the access or mutation of plain variables. However, we can intercept the get and set operations of an object's properties using getter and setter methods. The property gives Vue the opportunity to detect when a ref has been accessed or mutated. Under the hood, Vue performs the tracking in its getter, and performs triggering in its setter. Conceptually, you can think of a ref as an object that looks like this: Another nice trait of refs is that unlike plain variables, you can pass refs into functions while retaining access to the latest value and the reactivity connection. This is particularly useful when refactoring complex logic into reusable code. The reactivity system is discussed in more details in the Reactivity in Depth section.\n\nTo add methods to a component instance we use the option. This should be an object containing the desired methods: // methods can be called in lifecycle hooks, or other methods! Vue automatically binds the value for so that it always refers to the component instance. This ensures that a method retains the correct value if it's used as an event listener or callback. You should avoid using arrow functions when defining , as that prevents Vue from binding the appropriate value: // BAD: no `this` access here! Just like all other properties of the component instance, the are accessible from within the component's template. Inside a template they are most commonly used as event listeners: In the example above, the method will be called when the is clicked.\n\nRefs can hold any value type, including deeply nested objects, arrays, or JavaScript built-in data structures like . A ref will make its value deeply reactive. This means you can expect changes to be detected even when you mutate nested objects or arrays: // these will work as expected. Non-primitive values are turned into reactive proxies via , which is discussed below. It is also possible to opt-out of deep reactivity with shallow refs. For shallow refs, only access is tracked for reactivity. Shallow refs can be used for optimizing performance by avoiding the observation cost of large objects, or in cases where the inner state is managed by an external library.\n\nWhen you mutate reactive state, the DOM is updated automatically. However, it should be noted that the DOM updates are not applied synchronously. Instead, Vue buffers them until the \"next tick\" in the update cycle to ensure that each component updates only once no matter how many state changes you have made.\n\nTo wait for the DOM update to complete after a state change, you can use the nextTick() global API:\n\nThere is another way to declare reactive state, with the API. Unlike a ref which wraps the inner value in a special object, makes an object itself reactive: Reactive objects are JavaScript Proxies and behave just like normal objects. The difference is that Vue is able to intercept the access and mutation of all properties of a reactive object for reactivity tracking and triggering. converts the object deeply: nested objects are also wrapped with when accessed. It is also called by internally when the ref value is an object. Similar to shallow refs, there is also the API for opting-out of deep reactivity. It is important to note that the returned value from is a Proxy of the original object, which is not equal to the original object: // proxy is NOT equal to the original. Only the proxy is reactive - mutating the original object will not trigger updates. Therefore, the best practice when working with Vue's reactivity system is to exclusively use the proxied versions of your state. To ensure consistent access to the proxy, calling on the same object always returns the same proxy, and calling on an existing proxy also returns that same proxy: // calling reactive() on the same object returns the same proxy This rule applies to nested objects as well. Due to deep reactivity, nested objects inside a reactive object are also proxies: The API has a few limitations:\n• None Limited value types: it only works for object types (objects, arrays, and collection types such as and ). It cannot hold primitive types such as , or .\n• None Cannot replace entire object: since Vue's reactivity tracking works over property access, we must always keep the same reference to the reactive object. This means we can't easily \"replace\" a reactive object because the reactivity connection to the first reference is lost: // the above reference ({ count: 0 }) is no longer being tracked\n• None Not destructure-friendly: when we destructure a reactive object's primitive type property into local variables, or when we pass that property into a function, we will lose the reactivity connection: // count is disconnected from state.count when destructured. // won't be able to track changes to state.count // we have to pass the entire object in to retain reactivity Due to these limitations, we recommend using as the primary API for declaring reactive state. A ref is automatically unwrapped when accessed or mutated as a property of a reactive object. In other words, it behaves like a normal property: If a new ref is assigned to a property linked to an existing ref, it will replace the old ref: // original ref is now disconnected from state.count Ref unwrapping only happens when nested inside a deep reactive object. It does not apply when it is accessed as a property of a shallow reactive object. Unlike reactive objects, there is no unwrapping performed when the ref is accessed as an element of a reactive array or a native collection type like : Ref unwrapping in templates only applies if the ref is a top-level property in the template render context. In the example below, and are top-level properties, but is not: Therefore, this expression works as expected: ...while this one does NOT: The rendered result will be because is not unwrapped when evaluating the expression and remains a ref object. To fix this, we can destructure into a top-level property: Now the render result will be . Another thing to note is that a ref does get unwrapped if it is the final evaluated value of a text interpolation (i.e. a tag), so the following will render : This is just a convenience feature of text interpolation and is equivalent to ."
    },
    {
        "link": "https://medium.com/@kaperskyguru/ultimate-guide-to-vue-3-reactivity-95a68e8704fd",
        "document": "Reactivity is one of the key features that make Vue.js a powerful framework for building interactive and dynamic web applications. It allows developers to declaratively define relationships between data and the UI, ensuring that changes in data are automatically reflected in the UI and vice versa.\n\nIn Vue 3, the reactivity system has been enhanced with the Composition API, providing more flexibility and control.\n\nIn this article, we will explore the concept of reactivity in Vue 3, discussing the reactivity model, reactive data, computed properties, and reactivity caveats.\n\nReactivity in Vue 3 revolves around the idea of tracking dependencies between data and UI elements. When data changes, the UI is automatically updated to reflect the changes, and when the UI triggers changes, the data is updated accordingly. This bidirectional synchronization is achieved through Vue’s reactivity system, which is based on the underlying JavaScript object.\n\nVue 3 uses a fine-grained reactivity model, where only properties accessed during the rendering process are tracked. This means that only the data that is actually used in the template or computed properties will trigger reactivity. This optimized approach ensures efficient reactivity and performance.\n\nIn Vue 3, you can create reactive data using the function from the Composition API. The function takes an object and returns a reactive proxy of that object.\n\nLet’s see an example:\n\nIn this example, the function is used to create a reactive object with a single property . Any changes to the property will be automatically reflected in the UI.\n\nComputed properties are an essential part of reactivity in Vue 3. They allow you to define derived values that automatically update when their dependencies change. Computed properties are created using the function from the Composition API.\n\nLet's take a look at an example:\n\nIn this example, a computed property is defined based on the and properties of the reactive object. Whenever either or changes, the computed property will be recalculated automatically.\n\nWhile Vue 3’s reactivity system provides a powerful and intuitive way to manage data and UI synchronization, there are a few caveats to keep in mind:\n\nBy default, Vue 3’s reactivity system cannot automatically detect changes in array elements when using index-based mutations (e.g., ). To ensure reactivity, you should use array methods like , , , etc., or use the function from the Composition API.\n\nSimilar to arrays, Vue 3’s reactivity system also faces limitations when it comes to detecting changes in object properties that are added or removed dynamically.\n\nTo ensure reactivity for dynamically added properties, you can use the function on the entire object or use the function to add properties.\n\nVue 3’s reactivity system may not immediately trigger updates for asynchronously modified data, such as data changes inside or AJAX callbacks.\n\nIn such cases, you can use the function from the Composition API to ensure the UI is updated after the next DOM update cycle.\n\nLearning and Using Reactivity in Vue 3\n\nTo learn more about reactivity in Vue 3 and deepen your understanding, here are some recommended resources:\n\nBy studying these resources, you will gain a comprehensive understanding of Vue 3’s reactivity system, its principles, and how to leverage it effectively in your Vue applications.\n\nReactivity is a fundamental concept in Vue 3 that enables seamless synchronization between data and the UI.\n\nBy understanding the reactivity model, working with reactive data, and utilizing computed properties, you can build powerful and dynamic Vue applications.\n\nHowever, it’s important to be aware of the reactivity caveats and follow best practices to ensure optimal reactivity and performance.\n\nIn this article, we explored the concept of reactivity in Vue 3, covering reactive data, computed properties, and important considerations. Armed with this knowledge, you can confidently leverage Vue 3’s reactivity system to create highly interactive and responsive applications.\n\nRemember to refer to the official Vue 3 documentation and additional learning resources for further exploration and mastery of reactivity in Vue 3."
    },
    {
        "link": "https://vuejs.org/guide/extras/reactivity-in-depth.html",
        "document": "One of Vue’s most distinctive features is the unobtrusive reactivity system. Component state consists of reactive JavaScript objects. When you modify them, the view updates. It makes state management simple and intuitive, but it’s also important to understand how it works to avoid some common gotchas. In this section, we are going to dig into some of the lower-level details of Vue’s reactivity system.\n\nThis term comes up in programming quite a bit these days, but what do people mean when they say it? Reactivity is a programming paradigm that allows us to adjust to changes in a declarative manner. The canonical example that people usually show, because it’s a great one, is an Excel spreadsheet:\n\nHere cell A2 is defined via a formula of (you can click on A2 to view or edit the formula), so the spreadsheet gives us 3. No surprises there. But if you update A0 or A1, you'll notice that A2 automagically updates too.\n\nJavaScript doesn’t usually work like this. If we were to write something comparable in JavaScript:\n\nWhen we mutate , does not change automatically.\n\nSo how would we do this in JavaScript? First, in order to re-run the code that updates , let's wrap it in a function:\n\nThen, we need to define a few terms:\n• None The function produces a side effect, or effect for short, because it modifies the state of the program.\n• None and are considered dependencies of the effect, as their values are used to perform the effect. The effect is said to be a subscriber to its dependencies.\n\nWhat we need is a magic function that can invoke (the effect) whenever or (the dependencies) change:\n\nThis function has the following tasks:\n• None Track when a variable is read. E.g. when evaluating the expression , both and are read.\n• None If a variable is read when there is a currently running effect, make that effect a subscriber to that variable. E.g. because and are read when is being executed, becomes a subscriber to both and after the first call.\n• None Detect when a variable is mutated. E.g. when is assigned a new value, notify all its subscriber effects to re-run.\n\nWe can't really track the reading and writing of local variables like in the example. There's just no mechanism for doing that in vanilla JavaScript. What we can do though, is intercept the reading and writing of object properties.\n\nThere are two ways of intercepting property access in JavaScript: getter / setters and Proxies. Vue 2 used getter / setters exclusively due to browser support limitations. In Vue 3, Proxies are used for reactive objects and getter / setters are used for refs. Here's some pseudo-code that illustrates how they work:\n\nThis explains a few limitations of reactive objects that we have discussed in the fundamentals section:\n• None When you assign or destructure a reactive object's property to a local variable, accessing or assigning to that variable is non-reactive because it no longer triggers the get / set proxy traps on the source object. Note this \"disconnect\" only affects the variable binding - if the variable points to a non-primitive value such as an object, mutating the object would still be reactive.\n• None The returned proxy from , although behaving just like the original, has a different identity if we compare it to the original using the operator.\n\nInside , we check whether there is a currently running effect. If there is one, we lookup the subscriber effects (stored in a Set) for the property being tracked, and add the effect to the Set:\n\nEffect subscriptions are stored in a global data structure. If no subscribing effects Set was found for a property (tracked for the first time), it will be created. This is what the function does, in short. For simplicity, we will skip its details.\n\nInside , we again lookup the subscriber effects for the property. But this time we invoke them instead:\n\nNow let's circle back to the function:\n\nIt wraps the raw function in an effect that sets itself as the current active effect before running the actual update. This enables calls during the update to locate the current active effect.\n\nAt this point, we have created an effect that automatically tracks its dependencies, and re-runs whenever a dependency changes. We call this a Reactive Effect.\n\nVue provides an API that allows you to create reactive effects: . In fact, you may have noticed that it works pretty similarly to the magical in the example. We can now rework the original example using actual Vue APIs:\n\nUsing a reactive effect to mutate a ref isn't the most interesting use case - in fact, using a computed property makes it more declarative:\n\nInternally, manages its invalidation and re-computation using a reactive effect.\n\nSo what's an example of a common and useful reactive effect? Well, updating the DOM! We can implement simple \"reactive rendering\" like this:\n\nIn fact, this is pretty close to how a Vue component keeps the state and the DOM in sync - each component instance creates a reactive effect to render and update the DOM. Of course, Vue components use much more efficient ways to update the DOM than . This is discussed in Rendering Mechanism.\n\nVue's reactivity system is primarily runtime-based: the tracking and triggering are all performed while the code is running directly in the browser. The pros of runtime reactivity are that it can work without a build step, and there are fewer edge cases. On the other hand, this makes it constrained by the syntax limitations of JavaScript, leading to the need of value containers like Vue refs.\n\nSome frameworks, such as Svelte, choose to overcome such limitations by implementing reactivity during compilation. It analyzes and transforms the code in order to simulate reactivity. The compilation step allows the framework to alter the semantics of JavaScript itself - for example, implicitly injecting code that performs dependency analysis and effect triggering around access to locally defined variables. The downside is that such transforms require a build step, and altering JavaScript semantics is essentially creating a language that looks like JavaScript but compiles into something else.\n\nThe Vue team did explore this direction via an experimental feature called Reactivity Transform, but in the end we have decided that it would not be a good fit for the project due to the reasoning here.\n\nIt's great that Vue's reactivity system automatically tracks dependencies, but in some cases we may want to figure out exactly what is being tracked, or what is causing a component to re-render.\n\nWe can debug what dependencies are used during a component's render and which dependency is triggering an update using the and lifecycle hooks. Both hooks will receive a debugger event which contains information on the dependency in question. It is recommended to place a statement in the callbacks to interactively inspect the dependency:\n\nThe debug event objects have the following type:\n\nWe can debug computed properties by passing a second options object with and callbacks:\n• will be called when a reactive property or ref is tracked as a dependency.\n• will be called when the watcher callback is triggered by the mutation of a dependency.\n\nBoth callbacks will receive debugger events in the same format as component debug hooks:\n\nSimilar to , watchers also support the and options:\n\nVue's reactivity system works by deeply converting plain JavaScript objects into reactive proxies. The deep conversion can be unnecessary or sometimes unwanted when integrating with external state management systems (e.g. if an external solution also uses Proxies).\n\nThe general idea of integrating Vue's reactivity system with an external state management solution is to hold the external state in a . A shallow ref is only reactive when its property is accessed - the inner value is left intact. When the external state changes, replace the ref value to trigger updates.\n\nIf you are implementing an undo / redo feature, you likely want to take a snapshot of the application's state on every user edit. However, Vue's mutable reactivity system isn't best suited for this if the state tree is large, because serializing the entire state object on every update can be expensive in terms of both CPU and memory costs.\n\nImmutable data structures solve this by never mutating the state objects - instead, it creates new objects that share the same, unchanged parts with old ones. There are different ways of using immutable data in JavaScript, but we recommend using Immer with Vue because it allows you to use immutable data while keeping the more ergonomic, mutable syntax.\n\nWe can integrate Immer with Vue via a simple composable:\n\nTry it in the Playground\n\nState Machine is a model for describing all the possible states an application can be in, and all the possible ways it can transition from one state to another. While it may be overkill for simple components, it can help make complex state flows more robust and manageable.\n\nOne of the most popular state machine implementations in JavaScript is XState. Here's a composable that integrates with it:\n\nTry it in the Playground\n\nRxJS is a library for working with asynchronous event streams. The VueUse library provides the add-on for connecting RxJS streams with Vue's reactivity system.\n\nQuite a few other frameworks have introduced reactivity primitives similar to refs from Vue's Composition API, under the term \"signals\":\n\nFundamentally, signals are the same kind of reactivity primitive as Vue refs. It's a value container that provides dependency tracking on access, and side-effect triggering on mutation. This reactivity-primitive-based paradigm isn't a particularly new concept in the frontend world: it dates back to implementations like Knockout observables and Meteor Tracker from more than a decade ago. Vue Options API and the React state management library MobX are also based on the same principles, but hide the primitives behind object properties.\n\nAlthough not a necessary trait for something to qualify as signals, today the concept is often discussed alongside the rendering model where updates are performed through fine-grained subscriptions. Due to the use of Virtual DOM, Vue currently relies on compilers to achieve similar optimizations. However, we are also exploring a new Solid-inspired compilation strategy, called Vapor Mode, that does not rely on Virtual DOM and takes more advantage of Vue's built-in reactivity system.\n\nThe design of Preact and Qwik's signals are very similar to Vue's shallowRef: all three provide a mutable interface via the property. We will focus the discussion on Solid and Angular signals.\n\nSolid's API design emphasizes read / write segregation. Signals are exposed as a read-only getter and a separate setter:\n\nNotice how the signal can be passed down without the setter. This ensures that the state can never be mutated unless the setter is also explicitly exposed. Whether this safety guarantee justifies the more verbose syntax could be subject to the requirement of the project and personal taste - but in case you prefer this API style, you can easily replicate it in Vue:\n\nTry it in the Playground\n\nAngular is undergoing some fundamental changes by foregoing dirty-checking and introducing its own implementation of a reactivity primitive. The Angular Signal API looks like this:\n\nAgain, we can easily replicate the API in Vue:\n\nTry it in the Playground\n\nCompared to Vue refs, Solid and Angular's getter-based API style provide some interesting trade-offs when used in Vue components:\n• is slightly less verbose than , but updating the value is more verbose.\n• There is no ref-unwrapping: accessing values always require . This makes value access consistent everywhere. This also means you can pass raw signals down as component props.\n\nWhether these API styles suit you is to some extent subjective. Our goal here is to demonstrate the underlying similarity and trade-offs between these different API designs. We also want to show that Vue is flexible: you are not really locked into the existing APIs. Should it be necessary, you can create your own reactivity primitive API to suit more specific needs."
    },
    {
        "link": "https://vueschool.io/articles/vuejs-tutorials/mastering-reactivity-and-data-updates-in-vue-js-3",
        "document": "Vue.js 3 goes beyond the standard reactive approach, offering a more granular and efficient system for managing your application's state. In this article, we'll unveil the secrets behind Vue.js 3's reactivity magic, empowering you to craft web applications that feel truly alive.\n\nAt its core, Vue leverages JavaScript's Proxies API to track changes in your data structures. These data structures, specifically objects and arrays, become \"reactive\" when wrapped using Vue's built-in APIs like and . Any modifications made to the properties within these reactive structures are automatically detected by Vue, triggering a re-render of the affected components.\n\nDeciding which to use between ref and reactive is completely up to you. Both APIs are achieving reactivity but each has its unique use-cases. But as a rule of thumb, ref is suitable for the majority of use-cases so it’s recommended to just always use ref.\n\nIn this code example, watch is used to execute a callback whenever the reactive property changes. The callback function logs the old and new values of whenever it changes.\n\nIn this example, watchEffect is used to reactively compute the sum based on changes to both firstNumber and secondNumber. The callback function inside accesses both and , demonstrating the ability to work with multiple reactive dependencies within the same callback function.\n\nComputed properties in Vue.js are functions that calculate values based on reactive data sources, such as or . Whenever these data sources change, computed properties automatically recalculate their values, ensuring that the template reflects the most up-to-date information. This feature eliminates the need for manual calculations, streamlining development and guaranteeing that the UI stays synchronized with the underlying data.\n\nOne key advantage of computed properties is their caching mechanism. They only recalculate when their dependencies change. While this feature helps in optimizing performance by avoiding unnecessary computations, it also leads to some limitations.\n\nThe property attempts to retrieve the current time using or . At the first glimpse, you would think that the computed property will update its value every time has changed. However, there's a catch: computed properties only re-evaluate when their reactive dependencies change.\n\nIn this case, both methods (Date.now() and new Date()) are not reactive, meaning Vue doesn't automatically detect changes within them. As a result, the computed property won't update with the current time at regular intervals, rendering the clock static.\n\nThis article delved into the heart of Vue.js 3: its reactivity system. We explored the fundamentals of and for managing reactive data, ensuring your UI seamlessly reflects data changes. We distinguished between properties, ideal for deriving values from reactive sources, and / , suited for side effects and complex scenarios."
    },
    {
        "link": "https://blog.logrocket.com/reactivity-vue-3-composition-api-ref-reactive",
        "document": "Editor’s note: This article was updated by Carlos Mucuho on 30 April 2024 to explore the use of Vue 3’s Hook as well as to offer a comparison between the Composition API and the Options API. For a deeper dive into that comparison, check out this guide. Before that, it was updated to include information about using the function to watch refs change and using template refs to create implicit references. For a more comprehensive overview of refs in Vue, see this guide.\n\nIn a single-page application (SPA), reactivity refers to the application’s ability to update its user interface in response to changes in the underlying data. Reactivity allows us to write cleaner code, preventing us from having to manually update the UI in response to data changes. Instead, the UI updates automatically.\n\nHowever, JavaScript doesn’t work like this on its own, so we can achieve reactivity using libraries and frameworks like React, Vue, and Angular. For example, in Vue, we can create a data set called ; Vue then uses a system of observers and watchers to keep track of the state and update our UI.\n\nWhen Vue detects changes in the state, it uses a virtual DOM to re-render the UI and ensure that it is always up to date, making the process as fast and efficient as possible through techniques like memoization and selective updates. There are a few different ways to define the application state that we want Vue to keep track of. For example, before the Composition API in Vue 3, we used a data function that returned the object we wanted to track.\n\nHowever, with the Composition API, we use two functions for defining state: and . In this article, we’ll explore these two functions, outlining what makes them unique and learning when we should use them. As a bonus, we’ll also look at how to unwrap refs, watch them change, and use them to create implicit references.\n\nWe can use to declare state for objects or arrays in Vue using the Composition API:\n\nIn the code snippet above, we declare to Vue that we want to track the object in the function. We can then create a UI that depends on this reactive object, and Vue will keep track of the object and use it to update the UI:\n\nIn the code above, we display the reactive data in our state. Now, Vue’s reactivity system can keep track of that data and update the UI when it changes.\n\nWe can test this by creating a function that changes the and when we click a button:\n\nWhen the button is clicked, the function changes the and , and Vue updates the UI content instantly.\n\nThe function is a powerful tool for creating reactive objects in Vue components, but because it works under the hood, it has one major limitation: it can only work with objects. Therefore, we can’t use it with primitives like strings or numbers. To handle this limitation, Vue provides a second function for declaring reactive state in applications: .\n\nThe function can hold any value type, including primitives and objects. Therefore, we use it in a similar way to the function:\n\nThe function returns a special reactive object. To access the value that is tracking, we access the property of the returned object:\n\nThe code below shows how we would make a UI that reacts to the changes of the :\n\nYou may notice that we didn’t need to specify the value when using the in the template. Vue automatically applies to the when we call it in a template, so we never need to use the value in the template.\n\nWe could rewrite the example from the first property with a ; the only difference is that we’d need to use the property to access the value in our JavaScript code.\n\nvs. : Which should you use?\n\nThe significant difference between and is that the function allows us to declare reactive state for primitives and objects, while only declares reactive state for objects.\n\nWe also have to access the value of by using the property on the returned object, but we don’t have to do that for objects.\n\nTherefore, in real-world scenarios, you’ll find more Vue code that uses than , but is perfect because it can easily accept state as it was defined before the Composition API. Both effectively track reactivity, so which one to use is a matter of preference and coding style.\n\nVue 3 didn’t completely eliminate the default way we defined reactive state in Vue 2; instead, Vue 3 ships with two APIs: the Composition API and the Options API. The Options API works primarily the way Vue 2 worked:\n\nIn the example above, we declare in the state and set it to . With , we can increase or decrease the , and then see the data change on the view with each button click. The code above uses the Options API and is valid for both Vue 2 and 3.\n\nThe property returned from Vue 2 works very similarly to the function in the Composition API we discussed earlier. It only works as an object; you can’t return a primitive value like a string from the function that the data property contains.\n\nMigrating a Vue 2 app to use and\n\nMigrating an application from the Vue 2 Options API to the Vue 3 Composition API is fairly straightforward. We can easily convert Vue 2 to either or . Take a look at the following Vue 2 component:\n\nWe can easily rewrite this component to show it using . Consider the code snippet below:\n\nWe can also rewrite this component to show it using :\n\nWe can make this code more fluent by using the Options API, which would look more like the following code:\n\nThe downsides of and\n\nThe downside of using is that it can be inconvenient to always have to use to access your state. If you have to use a value that could be a , you might not know if it has been initialized, and calling on null could throw a runtime error. To get around this issue, we could the , which we’ll discuss later in this article.\n\nOn the other hand, the downside of using is that it cannot be used on primitives. You can only use on objects and object-based types like and . You could circumvent this issue by using the same way that state is defined in the Options API.\n\nMixing and : Is it a good idea?\n\nThere’s no rule or convention against mixing and . Whether or not to do so is subjective and depends on the preferences and coding patterns of the developer(s) involved.\n\nThere are a few libraries, like Vuelidate, that use for setting up state for validations. In such cases, combining multiple functions for other states and functions for validation rules could make sense.\n\nIt’s essential that you agree on a convention with your team to avoid confusion as you write code. and are very efficient tools for declaring state, and they can be used together without any technical drawbacks.\n\nVue improves the ergonomics of using functions by automatically unwrapping it in certain circumstances. When using a in these cases, we don’t have to use because Vue automatically does that for us in unwrapping.\n\nOne place where Vue unwraps functions for us is in the template. When accessing a from the template, we can retrieve the value of the without using , as shown below and in the examples above:\n\nWhen a is set as a value of a object, Vue also automatically unwraps the for us when we access it, as shown below:\n\nWe can watch for changes to a reactive value by or using the function. The function enables us to define a callback that will be triggered whenever the value of the watched reactive changes. It provides the previous and current values as parameters to the callback function, thus allowing us to perform some actions based on the changed value.\n\nThis function is particularly useful when we need to react to changes in a ref and update other parts of our application accordingly, such as triggering side effects, updating UI elements, or making API calls:\n\nIn the code snippet above, the value is supplied as the first argument to the function and the callback function provides the new and old values to be acted upon.\n\nIt’s important to realize that the function may not work as intended if the value of that property is not . For instance, to watch the value of in the example defined above, the function can also take a callback as its first argument, as shown in the snippet below:\n\nIn Vue, refs can also be used to identify components or DOM. When a ref is used like this, it is called a template ref. Template refs are useful when we want to target the underlying DOM element of a Vue component:\n\nIn the code snippet above, the Vue component uses a ref to target a child component defined in its template. The ref then holds the instance of the component and can be used to carry out DOM operations.\n\nTemplate refs allow us to access child components or elements within a component template without assigning them a ref attribute. Template refs work by automatically creating an implicit reference to a child component or element based on its unique identifier within the template, thus simplifying the process of accessing a child component.\n\nThis is particularly useful when dealing with dynamic or nested structures. Vue assigns the reference as a property on the parent component’s instance, making it accessible within the component’s JavaScript code.\n\nIt is important to remember that implicit refs only work for direct child components or elements within a template.\n\nIn Vue 3, the lifecycle Hook can be used in conjunction with reactive states to enhance reactivity and manage complex component logic. is called after the component has been mounted to the DOM, making it a suitable place to initialize data, fetch data from APIs, or perform other setup tasks.\n\nHere’s an example demonstrating the use of with reactive states:\n\nIn this example, is a reactive state that holds the message to be displayed in the template. The Hook is used to fetch data (simulated by a function) and update the state once the component is mounted.\n\nLet’s consider a scenario where we not only fetch data from an API but also update the data periodically and handle cleanup when the component is unmounted:\n\nIn this example, we’ve added an Hook to log a message whenever the component is updated. We’ve also added an Hook to clean up the timer before the component is unmounted, ensuring that no updates occur after the component is removed from the DOM.\n\nThe Composition API and the Options API offer ways to manage reactivity but differ in how they structure and organize code. Here’s a comparison of the two APIs and when to use one vs. the other in terms of reactivity:\n• Structure: In the Options API, a Vue component is defined using an options object that contains properties such as , , , , etc.\n• Reactivity: Data properties defined in the and (using or ) options are made reactive by Vue. Computed properties and watchers are also reactive\n• When to use: The Options API is suitable for smaller, less complex components where reactivity is straightforward and does not require a lot of code organization\n• Structure: The Composition API allows you to organize your component’s logic into reusable functions. These functions can be used to define reactive data, computed properties, watchers, etc.\n• Reactivity: Similar to the Options API, data defined using or is reactive. Computed properties and watchers are also supported\n• When to use: The Composition API is beneficial for more complex components where reactivity logic needs to be more organized and reusable. It’s especially useful when dealing with components that have a lot of reactive logic or when you need to share logic between components\n\nApplying reactivity can help you write more concise code. In this article, we explored how to handle reactivity in Vue using the and functions. In addition, we investigated how these relate to the Vue 2 Options API as well as the Vue 3 Composition API, discussing when to use each.\n\nI hope you enjoyed this article, and be sure to leave a comment if you have any questions. Thanks!"
    },
    {
        "link": "https://blog.openreplay.com/best-practices-for-async-programming-in-javascript",
        "document": "JavaScript is one of the most popular programming languages for developing web apps since it is dynamic and versatile. One of its most notable features is its ability to execute asynchronous code, allowing it to do multiple tasks concurrently without blocking the main thread. This article will discuss asynchronous programming and show the best technique to perform asynchronous programming in Javascript, as well as how to manage and handle async code effectively.\n\nThis programming paradigm allows the execution of multiple tasks at one time without blocking the main thread. In other words, it lets your application continue operating while it waits for a task to finish, such as an API request. The significance of asynchronous programming in JavaScript cannot be overemphasized. Async code is vital for providing a seamless user experience in a world where people demand quick and responsive online apps. It lets developers build applications that can perform numerous activities at once, making them more efficient and scalable.\n\nHow does asynchronous programming differ from its counterpart, synchronous programming? Synchronous programming is a programming paradigm in which the execution of a task prevents the execution of succeeding tasks until it is done. This indicates that one task must be completed before the next may begin. In other words, the program waits for one job to finish before proceeding to the next. In a synchronous application, for example, if you make an API call, the software will wait for the response before moving on to the next task. In an asynchronous application, the application will continue to do other operations while it waits for the API response. As a result, the application runs more smoothly and efficiently.\n\nAsynchronous programming is essential for building fast and responsive web applications, while synchronous programming is better suited for basic, single-threaded applications.\n\nWhat exactly are asynchronous patterns? They are various approaches or tactics for managing and executing asynchronous programming. These patterns include callbacks, promises, and usage of async/await; we’ll consider them in the following sections.\n\nThe callback pattern refers to a programming technique in which a function is passed as an argument to another function and runs (“is called back”) when a certain event occurs or the outer function has completed some processing.\n\nAs seen, the function is defined and takes a callback as its argument. This function makes an asynchronous operation, such as an HTTP request, and then calls the callback with the result.\n\nPromises, however, provide a cleaner way to handle asynchronous code than callbacks, as they allow for chaining.\n\nThe code above is similar to callbacks, except instead of a callback, the function returns a Promise that resolves with the JSON data. The caller may then use the method to register a callback that accepts the JSON data as input.\n\nThe silver lining is the async/await pattern, which was introduced in ECMAScript 2017 and made it easier to handle code in a synchronous-like way. You can build code that looks like synchronous code and is easier to understand and maintain with .\n\nThe code is still similar to callbacks and promises, but instead of utilizing the method, the keyword is used. The function is declared async, which implies it may utilize the await keyword. The keyword is used to wait for the promise returned by to resolve before continuing execution. The keyword is then used again to wait for the promise returned by to resolve before resuming execution. Finally, the JSON data is logged to the console.\n\nEach pattern has its pros and cons, and the best choice depends on the specific requirements of your application.\n\nBest practices for Asynchronous Programming in JavaScript\n\nAsynchronous programming in JavaScript may be tricky and challenging, but by following best practices, you can make your code more efficient and manageable. Some of the practices I recommend are as follows:\n\nCallback Hell refers to a situation where you have multiple nested callbacks, making the code hard to read and maintain.\n\nHere is a simple example of callback hell:\n\nThe above scenario is a perfect example of callback hell. In the above example, we utilize the restcountries API to get the name of a country and one of its neighbors. The above code demonstrates callback hell. In this case, ‘fetchData()’ is called, followed by a sequence of nested callbacks that first extract the country name and then extract the neighboring country name using an asynchronous ‘fetchData2()’ method. Since the nested structure of callbacks may make the code difficult to comprehend, debug, and maintain, promise offers a solution.\n\nUsing promises, each operation returns a promise, and all operations are linked together using ‘.then()’. This method is much easier to read and manage than the previous one, which used nested callbacks. It’s also shorter since you only need one.catch() statement at the end of the chain to handle errors.\n\nIn the above code, we utilized promises to resolve the callback hell problem. We utilized ‘.then()’ to chain dependent activities so that once the country’s data is fetched, the code continues to get its neighbor, and if not, the promise is rejected.\n\nThe following are some recommended practices for dealing with promises in JavaScript:\n• Always use and methods to handle the resolved and rejected states of a Promise, respectively.\n• Once a Promise is resolved with a value, it should not be modified. Resolved values should be treated as immutable. Promises can be modified indirectly by creating a new Promise that wraps the original Promise and modifies the resolved value when the new Promise is resolved. For best practice, this process should be avoided.\n\nAs seen in the “Asynchronous patterns in JavaScript” section, the and pattern gives you many ways to deal with asynchronous code. It is also the most popular and effective pattern. Compared to other patterns, this one is the best because of the following reasons:\n\nSo, always try to use when possible.\n\nOne of the key best practices in asynchronous programming in JavaScript is proper error handling. When writing asynchronous code, it’s important to handle any errors that may occur to prevent unexpected behavior and ensure a stable application. What better way to handle errors than using the try-catch-finally block?\n\nThe block is a fundamental structure for error handling in JavaScript. An async function’s block contains code that may throw an error and need error handling. The block’s function is performed, and if an error is thrown, it is caught by the block, which has the error handling code. The block specifies a block of code that will be executed regardless of whether an error occurs. This block is also optional, but it must come after the block if included.\n\nIn this example, we’ve added a throw statement to the block that throws a new error with a custom error message (i.e., is false) if the API response is unsuccessful. If an error occurs during the function, a custom error message with further details about the error will be logged to the console. Lastly, we have a block called , which logs a message to the console that says our fetch operation is complete. You may offer additional precise information about the error that occurred by throwing a new error in the block, allowing you to identify and fix any problems with your code.\n\nRunning promises in parallel means executing multiple promises simultaneously and processing their results as soon as they are available. This can improve the performance of your asynchronous code and make it run faster. Here are the top Promise combinators when running promises in parallel and the best use case for each.\n• Promise.all(): This takes an array of promises as an argument and returns a single promise that either resolves when all of the promises in the array have resolved or rejects with the reason of the first rejected promise. The resolved values are returned in the order in which they were passed in the array.\n\nHere’s an example of how to use Promise.all():\n\nIn this example, we pass an array of three promises to . When all of the promises have been resolved, the then() method is called with an array of response objects. If any of the promises reject, the method is called with the reason for the first rejected promise.\n\nIf one of the promises in the array rejects, the entire call will immediately reject with the reason for the first rejected promise, and the remaining promises in the array will not be executed. Whether to cancel or continue with the remaining promises depends on the context of your application and the logic you want to implement.\n• Promise.race(): This takes an array of promises as an argument and returns a single promise that resolves or rejects with the value of the first promise that settles. Use when you need to return the result of the first promise that settles, regardless of whether it resolves or rejects. The method is mostly used for timeouts.\n\nHere’s an example of how to use Promise.race():\n\nIn this example, we pass an array of three promises into . The function will be resolved or rejected based on the promise that settles first, and the other promises will be ignored. The value of the first settled promise, which might be resolved or rejected, is sent to the function. If all of the promises fail, the function is called, passing the cause for the first failed promise.\n\nIn conclusion, asynchronous programming is an important component of modern web development, and JavaScript offers several techniques to handle asynchronous code. The and keywords are two of the most common and efficient methods of handling asynchronous programming. You can guarantee that your asynchronous code is well-structured, efficient, and simple to maintain by utilizing best practices such as blocks and proper promise consumption."
    },
    {
        "link": "https://dev.to/nziokidennis/javascript-asynchronous-programming-concepts-and-best-practices-38k7",
        "document": "We all have been to a restaurant. Now picture this scenario, a waiter comes to your table to take your order. This waiter adopts a unique approach, where they take your order, deliver it to the kitchen, wait until it is ready, and then serve it to you. But there's a catch, the waiter has to take your order, deliver it to the kitchen and wait until it is ready then serve you, meaning in between they don't do anything else.\n\nNow, let us consider a different scenario with a different waiter. In this case, the waiter takes your order and delivers it to the kitchen but instead of waiting for the chef to prepare the meal, they immediately move on to serve other tables and take additional orders. As they are doing this, back in the kitchen the chef prepares your order, and when ready informs the waiter who then promptly delivers the meal to your table, even if they are currently serving other customers.\n\nExamples one and two can be used to show how synchronous and asynchronous programming work. JavaScript in recent years has seen a surge in popularity. As of 2022, around 98% of websites used JavaScript as a client-side programming language, enabling developers to create highly performant and scalable applications. The effectiveness of the language's ability to handle asynchronous programming has contributed hugely to the language's success.\n\nJavaScript by default is synchronous and single-threaded. Synchronous programming means the execution of operations is done sequentially. an operation cannot be executed until the previous one has been executed. for complex computations, this presents a problem. On the other hand, asynchronous programming is a technique where a computer program handles multiple tasks at the same time than executing them sequentially, independent of the main program flow.\n\nThe call stack keeps track of multiple function calls in a program, itself being a data structure. Every time a function is called, a new frame is added to a call stack. The same happens when the function's execution is ended, with the frame removed from the stack. This is vital in the context of asynchronous programming, as this can help understand how function execution happens. To execute any asynchronous or synchronous code, callbacks have to interact with but are not limited to callback queues and event loops. The following code illustrates this with a simple example:\n• None hello() is called and added to the call stack\n• None Now once inside hello(), greet(\"Nzioki\") is called and added also\n• None greet(\"Nzioki\") completes, its frame is removed from the stack and control goes back to hello()\n\n hello() completes and its frame is removed from the stack\n\nSynchronous execution works well for simple and linear operations since tasks are processed sequentially. Each task must complete before another starts execution, which can be an issue for complex operations (e.g. file I/O or network requests. This lead to poor user experience.\n\nAsynchronous execution on the other hand allows execution of tasks independent of each other. In a case where an asynchronous operation is initiated, the main program flow does not wait for it to complete, it continues with other tasks. Once the asynchronous task completes, your program is presented with the result.\n\nConsider a simple synchronous function that performs three tasks sequentially: printing \"A,\" \"B,\" and \"C\" with a delay of one second between each task.\n\nIn this case, the tasks are executed sequentially, and each task must finish before moving on to the next.\n\nNow, let's implement an asynchronous version of the same functionality using setTimeout to introduce a delay. We'll print \"A,\" \"B,\" and \"C\" with a delay of one second between each task.\n\nIn the asynchronous execution, the main thread does not wait for the setTimeout functions to complete their tasks. Instead, it proceeds to the next statement immediately after invoking them. As a result, \"A\" is printed first, and then after one second, \"C\" is printed, and finally, another three seconds later, \"B\" is printed.\n\nTo illustrate the difference between synchronous and asynchronous execution visually, consider the following timeline diagrams:\n\nIn the synchronous execution, each task blocks the main thread until it completes, creating a sequential flow.\n\nIn the asynchronous execution, tasks are initiated and continue running in the background while the main thread progresses without waiting for them to complete.\n\nA callback is a function that is passed as an argument to another function and executed later when invoked. The primary purpose of a callback is to execute code in response to an event. In JavaScript, callbacks allow developers to specify what should happen once the task finishes executing.\n\nLet's consider a simple example where we have a function getUserData that simulates fetching user data from a server asynchronously using setTimeout. We provide a callback function onUserDataFetched to process the result once the data is ready.\n\nIn this example, the getUserData function takes a callback function callback as an argument. Inside getUserData, we use setTimeout to simulate an asynchronous operation that takes one second. Once the timeout is complete, we invoke the callback function, passing the user data as an argument.\n\nSometimes JavaScript operations grow and require multiple asynchronous operations, which lead to nested callbacks below each other which forms a \"pyramid of doom\". The reason we call this pyramid of doom is that every callback will have to depend/wait for the previous callback. This affects the maintainability and readability of the code. Here's an example demonstrating callback hell:\n\nHow do you avoid callback hell?\n• None Use Promises or Async/Await: Embrace Promises or Async/Await for better control over asynchronous operations.\n• None Use Error Handling: Implement error handling mechanisms to catch and handle errors gracefully.\n• None Avoid Nested Callbacks: Refrain from nesting multiple callbacks within each other.\n• None Named Functions: Use named functions for callbacks to enhance readability.\n• None Separation of Concerns: Keep different functionalities separate to reduce callback nesting.\n• None Libraries and Modules: Utilize libraries or modules designed for handling asynchronous operations.\n• None Use Control Flow Libraries: Consider using control flow libraries like async.js or functional programming concepts to manage asynchronous flow.\n• None Avoid Anonymous Functions: Use named functions instead of anonymous functions to improve code clarity.\n• None Refactor and Simplify: Regularly refactor code to simplify and reduce callback chains.\n\nPromises object represents the eventual completion/failure of an asynchronous operation and its resulting value and can be chained using .then() and .catch() methods, or with the async/await syntax for more structured handling. A promise exists at any time in one of these three states:\n• None Pending: When a promise is created it's usually pending.\n• None Fulfilled (Resolved): If the asynchronous operation represented by a promise is completed, the promise transitions to a fulfilled state.\n• None Rejected: A Promise transitions to a rejected state if the asynchronous operation fails.\n\nWe utilize the Promise constructor, which accepts a function as a parameter, to create a Promise. The parameters for this function, also known as an executor function, resolve and reject. Inside the executor function, we perform the asynchronous task, and when it completes successfully, we call resolve with the result. If an error occurs, we call reject with an error object.\n\nWith the aid of promise chaining, you can carry out several asynchronous operations in succession, with the outcome of one operation serving as the input for the next.\n\nPromise.all() produces a single promise after accepting a list of promises as input.\n\nAsync/await builds on top of Promises and eliminates the need for Promise chaining. The terms \"async\" and \"await\" in JavaScript are used together to create asynchronous code that appears more synchronous and readable. An asynchronous function is declared using the \"async\" keyword, and its execution can be paused using the \"await\" keyword until a Promise is resolved or rejected. Within an async function, the \"await\" keyword is used to call functions that return Promises, effectively synchronizing the flow of execution and making the asynchronous code easier to comprehend. The following example shows how Async/await works:\n\nIn the above code snippet, the asyncTask function demonstrates how async/await works. The await keyword pauses the execution of the function until the delay Promise resolves after a 2-second delay.\n\nAsync/await also provides a convenient way to handle errors in asynchronous code. Async/await makes error handling straightforward with the use of try-catch blocks. If an error occurs within the async function, it will be caught in the catch block, allowing for clean and centralized error handling.\n\nExample of Error Handling with Async/Await\n\nThe getUserData function throws an error. The fetchUserData function catches the error using a try-catch block, allowing us to handle it gracefully.\n\nA crucial component of JavaScript's asynchronous programming is error handling. It's crucial to appropriately handle problems when working with asynchronous processes to preserve application stability and give users useful feedback. In this section, we'll explore various error-handling strategies and techniques for dealing with errors in asynchronous code.\n\nPromises provide a straightforward way to handle errors using the .catch() method. When a Promise is rejected the control is passed to the nearest .catch() block, where you can handle the error.\n\nUsing the fetch() function, the fetchUserData function retrieves user data from an API. If the response status is not okay (e.g., HTTP status code 404 ), the Promise is rejected with an error using throw new Error(). The. catch() block then catches the error and logs a message to the console.\n\nTry-catch blocks make error handling even clearer and easier to understand when using async/await. Inside an async function, you can use try-catch to catch and handle errors that occur during await operations.\n\nThe fetchUserData function uses async/await to fetch user data. If during fetch or JSON parsing an error occurs, it's caught in the try-catch block and logged to the console.\n\nWhen running with multiple asynchronous operations, and all promises are completed, Promise.all() enables you to handle errors collectively by either resolving or rejecting the Promise it returns.\n\nThe fetchDataFromMultipleSources fetches data from multiple endpoints using fetch(), and then it waits for all the fetch Promises to resolve using Promise. all(). If any of the fetch operations fail, the Promise returned by Promise.all() will be rejected, and the error will be caught in the catch block if used.\n\nAs discussed earlier, JavaScript by default is a single-threaded language that has one execution thread responsible for handling all tasks. This is the opposite of multi-threaded languages, which concurrently execute independent tasks. Concurrency refers to a system's ability to handle multiple tasks simultaneously, with no need to execute them simultaneously.\n\nSo how does JavaScript which is a single-threaded language achieve concurrency? It does this through its non-blocking behavior. Asynchronous operations, such as network requests, file I/O, or timers, are executed in the background while the main thread continues executing the remaining code. A callback function or a resolved Promise alerts the event loop that it can run the related callback after an asynchronous operation is complete.\n\nA critical part of Javascript's concurrency, event loops work by continuously running as long as the program is executing, and maintaining the application's responsiveness. The event loop follows a specific sequence of phases during each iteration. they are 6 in total;\n• None Timers: The event loop in this phase checks for and handles any scheduled timer callbacks using functions like setTimeout() and setInterval().\n• None I/O Callbacks: Executes I/O-related callbacks, such as network requests, file system operations, or other asynchronous tasks that involve I/O that have been completed.\n• None Waiting / Preparation: In this phase, the event loop waits for new I/O events to be added to the queue. Simply put it, is a phase of internal maintenance\n• None I/O Polling: Checks for I/O events that have occurred since the previous iteration and executes their callbacks.\n• None setImmediate() Callbacks: Also called the check phase, this phase executes setImmediate() callbacks\n• None Close Events: The final phase handles cleanup tasks. It processes callbacks such as close event callbacks, such as closing database connections\n\nLet's consider a simplified illustration of how the event loop operates:\n\nJavaScript's asynchronous programming capabilities can significantly improve an application's performance and responsiveness. It also presents several performance-related variables, though, that developers should be aware of to ensure the best possible resource and code execution.\n\nWhile asynchronous operations can be beneficial, unnecessary use can impact performance. When performing tasks that are simple and can be executed synchronously try to avoid using asynchronous calls. Overusing asynchronous operations might add additional complexity and possibly make the codebase more complicated.\n\nExcessive usage of callbacks, commonly referred to as \"callback hell,\" can result in difficult-to-read and maintainable code. Asynchronous code must be written in a way that reduces nesting and increases readability. If you want to compress callback chains and improve code organization, think about utilizing Promises or async/await.\n\nConsider employing throttling or debouncing strategies in instances where many asynchronous operations are initiated (such as managing user input events). Debouncing delays the execution of a function until a certain period of inactivity, whereas throttling restricts the number of times a function can be called within a particular time frame. Debouncing is a programming technique that is used in a variety of situations, including front-end web development, to manage how frequently a specific operation or function is carried out in response to rapid or frequent events, such as user input.\n\n4. Efficient Error Handling\n\n For an application to remain stable, error handling must be done correctly. However, handling errors in callback chains with many levels of nesting might occasionally result in performance overhead. To prevent needless duplication of error handling code while utilizing Promises or async/await, think about centralizing error handling.\n\nWhen designing custom asynchronous APIs, aim for simplicity and ease of use. Well-designed APIs can improve code readability and reduce the potential for errors. Consider providing clear documentation and using intuitive function names to make the API more developer-friendly.\n\n7. Best Practices for Asynchronous Programming in JavaScript\n\nAsynchronous programming can be powerful and efficient when used correctly. However, it can also lead to code complexity and subtle bugs if not handled properly. Here are some best practices to follow when working with asynchronous code in JavaScript:\n\nInstead of utilizing conventional callbacks to handle asynchronous actions, use Promises or async/await. By eliminating callback hell and streamlining error handling, they offer a more organized and readable method to work with asynchronous tasks.\n\n2. Handle Errors Gracefully\n\n Always handle errors in asynchronous code. Use .catch() with Promises or try-catch blocks with async/await to catch and handle errors appropriately. By doing this, you can be sure that your application will remain reliable and will give users useful feedback when something goes wrong.\n\n3. Limit the Use of Global Variables\n\n Avoid using global variables to store data that might be modified asynchronously. Instead, use function parameters or closures to pass data between functions. Global variables can lead to race conditions and make code harder to maintain.\n\n4. Throttle and Debounce Asynchronous Calls:\n\n For frequently triggered asynchronous operations (e.g., handling user input), consider throttling or debouncing the function calls to control the rate of execution and prevent excessive resource usage.\n\n5. Use Web Workers for CPU-Intensive Tasks:\n\n For computationally intensive tasks, consider offloading the work to Web Workers. This approach prevents the main thread from becoming unresponsive and provides a better user experience.\n\n6. Avoid Blocking the Event Loop:\n\n Avoid long-running synchronous operations that block the event loop. Asynchronous code should not be used as a way to circumvent expensive synchronous tasks.\n\n7. Optimize Network Requests:\n\n Minimize the number of network requests and optimize their size whenever possible. Consider using techniques like HTTP compression and caching to reduce response times and bandwidth usage.\n\n8. Clean Up After Asynchronous Operations:\n\n Be diligent in cleaning up after asynchronous operations. Close files, release resources, and unsubscribe from event listeners to prevent memory leaks.\n\n9. Test Asynchronous Code:\n\n Write thorough unit tests for asynchronous functions to ensure they behave as expected under various scenarios, including successful execution and error handling.\n\n10. Document Asynchronous APIs:\n\n When designing custom asynchronous APIs, provide clear and concise documentation. Explain the purpose of the API, the expected input, and the structure of the returned data. Well-documented APIs ease integration and improve code readability.\n\nLet's consider a common scenario where a web application needs to fetch data from multiple APIs and display the combined results to the user. In this example, we'll use the GitHub API to fetch information about a user and their repositories.\n\nIn this example, we have three asynchronous functions: fetchUserData, fetchUserRepositories, and displayUserDetails. Each function uses await to fetch data from the GitHub API, making the code look synchronous and easy to read.\n\nThe displayUserDetails function uses Promise.all() to fetch both the user data and repositories concurrently. This approach ensures that both API calls happen simultaneously, improving the overall performance and reducing the waiting time for the user.\n\nConsider a real-time chat application where users can exchange messages instantly. Such an application requires efficient handling of asynchronous events to provide a seamless and responsive user experience.\n\nIn this example we use Node.js and the ws library to create a WebSocket server. WebSocket is a communication protocol that enables bidirectional data transfer between a client and a server over a single, long-lived connection.\n\nWhen a client establishes a WebSocket connection, the server adds it to the client set. Whenever a message is received from any client, the server broadcasts the message to all connected clients (except the sender). This approach ensures that messages are delivered to all participants in real time.\n\nThe event-driven nature of WebSocket makes it ideal for building real-time applications, as it allows the server to handle multiple asynchronous events concurrently without blocking the main thread. This results in a highly responsive chat application that delivers messages instantly to all users.\n\nAsynchronous programming is a fundamental aspect of JavaScript that allows developers to perform non-blocking operations, making applications more responsive and efficient. By leveraging techniques like Promises and async/await, developers can write clean and organized code that handles asynchronous tasks in a structured manner. Additionally, understanding the event loop and the concurrency model in JavaScript helps developers optimize code execution and resource utilization"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function",
        "document": "An declaration creates an object. Each time when an async function is called, it returns a new which will be resolved with the value returned by the async function, or rejected with an exception uncaught within the async function.\n\nAsync functions can contain zero or more expressions. Await expressions make promise-returning functions behave as though they're synchronous by suspending execution until the returned promise is fulfilled or rejected. The resolved value of the promise is treated as the return value of the await expression. Use of and enables the use of ordinary / blocks around asynchronous code.\n\nNote: The keyword is only valid inside async functions within regular JavaScript code. If you use it outside of an async function's body, you will get a . can be used on its own with JavaScript modules.\n\nAsync functions always return a promise. If the return value of an async function is not explicitly a promise, it will be implicitly wrapped in a promise.\n\nFor example, consider the following code:\n\nIt is similar to:\n\nNote that even though the return value of an async function behaves as if it's wrapped in a , they are not equivalent. An async function will return a different reference, whereas returns the same reference if the given value is a promise. It can be a problem when you want to check the equality of a promise and a return value of an async function.\n\nThe body of an async function can be thought of as being split by zero or more await expressions. Top-level code, up to and including the first await expression (if there is one), is run synchronously. In this way, an async function without an await expression will run synchronously. If there is an await expression inside the function body, however, the async function will always complete asynchronously.\n\nIt is also equivalent to:\n\nCode after each await expression can be thought of as existing in a callback. In this way a promise chain is progressively constructed with each reentrant step through the function. The return value forms the final link in the chain.\n\nIn the following example, we successively await two promises. Progress moves through function in three stages.\n• The first line of the body of function is executed synchronously, with the await expression configured with the pending promise. Progress through is then suspended and control is yielded back to the function that called .\n• Some time later, when the first promise has either been fulfilled or rejected, control moves back into . The result of the first promise fulfillment (if it was not rejected) is returned from the await expression. Here is assigned to . Progress continues, and the second await expression is evaluated. Again, progress through is suspended and control is yielded.\n• Some time later, when the second promise has either been fulfilled or rejected, control re-enters . The result of the second promise resolution is returned from the second await expression. Here is assigned to . Control moves to the return expression (if any). The default return value of is returned as the resolution value of the current promise.\n\nNote how the promise chain is not built-up in one go. Instead, the promise chain is constructed in stages as control is successively yielded from and returned to the async function. As a result, we must be mindful of error handling behavior when dealing with concurrent asynchronous operations.\n\nFor example, in the following code an unhandled promise rejection error will be thrown, even if a handler has been configured further along the promise chain. This is because will not be \"wired into\" the promise chain until control returns from .\n\ndeclarations behave similar to declarations — they are hoisted to the top of their scope and can be called anywhere in their scope, and they can be redeclared only in certain contexts."
    },
    {
        "link": "https://imaginarycloud.com/blog/async-javascript-patterns-guide",
        "document": "From web applications to servers and mobile apps, from small programs to big projects, JavaScript is everywhere. It's the main choice to embrace any project because, well, it's 2020 and JS is an even more mature language, with an enormous community supporting it. In JavaScript, all the code runs synchronously on the event loop, which executes sequentially small chunks of our program. On the event loop, each iteration is called a and runs until the queue is empty. Each chunk has a to process and after it's completed, the next one starts. For small applications, this is enough, but as we start doing heavier operations that require more time, like accessing a database or fetching data over the Internet, we need better mechanisms to handle them. Over the years, patterns and libraries emerged in the JS ecosystem to handle asynchronous programming, such as callbacks, events, promises, generators, async/await, web workers and packages on NPM registry like async, bluebird, co or RxJS. As for front-end developers, we may need to use different patterns to solve the challenging problems of every day depending on the framework we are working on. Knowing the available tools in the JavaScript world allows us to choose the best solution for each problem. You may ask if this guide is only for web development? No, most of these patterns are used in all JavaScript environments and platforms, so knowing how they work is always valuable for any developer. In JavaScript, functions are first-class objects and a callback is just a function that is passed as an argument to another function. Also known as high-order functions, the callback should be invoked whenever the asynchronous work is finished. Since callbacks are just functions, they are supported by all the environments that run JavaScript, from our browsers to servers that run Node.js. Simple, but yet powerful, this pattern is fundamental in asynchrony. However, it also has its drawbacks. When projects start to grow and we need to start doing more complex code, it becomes harder to implement generic solutions on our programs, making them harder to read and maintain. When this happens, we start having the pyramid shape of `})`similar to what we can see in the following example. This is usually known as \"Callback Hell\". However, the worst that we can have with callbacks is the inversion of control. If this happens, we are giving control of the program flow sequence to other parties, making it difficult (or even impossible!) to properly test it. An event-driven architecture can also be used to write asynchronous javascript code. This architecture consists of having one event emitter with a corresponding event listener, that sends events when the async code completes. Sending different types of events allows having different callbacks for each type of listeners. One basic example and really important part of the front-end development is requesting data over the internet. To achieve that we could use the XMLHttpRequest object that is heavily used on AJAX programming. \n\nThe XMLHttpRequest object already has some events listeners defined to handle the request flow, so we just need to take advantage of them. But this patter has lots of boilerplate code, as we could add and remove listeners depending on the different event types we need. This works perfectly on a small web page but as soon the complexity and functionalities grow it starts to be bloated and cumbersome to maintain, so better abstractions are needed! Promises are harder to master, but address the inversion of control issue. They are a little slower than callbacks, but in return we get a lot of trustability. We can always be sure that a Promise will resolve or reject since they are a “wrapper” around a value that may not exist yet. Promises are a trustable mechanism that also helps to express async code more sequentially. They can have, at most, one resolution value, meaning that a Promise always needs to be resolved or rejected. This is how they solve the inversion of control. Not by removing callbacks, but by creating a mechanism on the wrapper that handles this issue. We can chain multiple Promises on our code without forcing a new level of indentation after each one, using .then(). Promises provide more functionality, like, for example, the and vs the latest API aditions and . With more complex front-end web applications we need more and better mechanisms. This improves the readability of the code, and the maintainability of the program as well, but not everything is perfect. Since this feature is at the framework level, multiple implementations can vary on behavior, plus the overhead cost of time and memory. Generators were introduced on ECMAScript 2015 and are functions in which we can use and control the iterator, meaning that functions can be paused and resumed at any time. This is a powerful tool for when we want to get each value only when we need, instead of getting all of them at once. This is possible with the addition of the word to JavaScript. \n\nWe can see in this example that for each we receive an object with the value and a flag indicating if the generator functions ended. But generators can be used to control async flows in conjugations with other libraries as well, like in co or redux-saga, of which I will talk more about further ahead. How to use an Async/Await pattern Finally, ES2017 introduced asynchronous functions making it much more easy to write and read asynchronous code in JavaScript! They are much cleaner than the last patterns discussed, and the return of an async function is a Promise! This is very powerful because we have the goodness of both worlds. As we've discussed before, Promises are the safe pick when dealing with complex async operations, but they are not that easy to read and master as async/await code. One drawback is that it needs a tool, like Babel, because Async/Await is still syntactic sugar over the promises code. Since the result is a Promise and can be resolved/rejected, it's important to wrap our await code within a try/catch. This way we can properly handle errors on our async code. Using web-workers, it's possible to run scripts and functions on a different thread, running code in asynchronous background tasks. This will not affect the usability of the user interface and can send data between workers and the main thread. The service worker on our browsers is heavily used on progressive web applications. This consists of registering a web worker for our website and deciding which files can be cached or not, and it will make the app usage faster. Also, if the user is offline, some features will still be available. They can also be used to perform heavy operations without freezing the UI or main JS thread. Yarn vs NPM: Which package manager should you use? Several other libraries try to solve those issues, each using its techniques. You can find some examples ahead: Async: this library is good to work with callbacks trying to solve some problems that exist within them, as well as eliminating the callback hell problem! In the last implementations, it's possible to use Async/await code as well. Bluebird: a very performant implementation of Promises that also includes a lot of extra features like cancellation, iteration and Promisify! This last one is a wrapper around functions working with callbacks, returning a Promise for those functions. co: control async flows with generators. This library is a runtime around generators, combining the keyword yield with promises, executing the generator result and returning it as a promise object. Redux-saga: A front-end library for React/Redux stack. This is a Redux middleware aiming to make applications side-effects more efficient and easier to manage, as they can be started or canceled by Redux actions. This implementation makes heavy use of generators to fetch data over the internet and apply the needed side-effects on our website. RxJS: This is a pattern used on Angular apps and it's a reactive pattern. We create an observable that we can subscribe and wait for changes of which we will be notified. Using this pattern, it's possible to cancel subscriptions and chain observables, for instance. Which Async patterns should we use? For simple projects, callbacks are the simplest and easier way to handle async flows. On bigger projects with a proper setup, I would choose the async/await pattern, as the asynchronicity is easy to read, has a natural error handling and there's no pyramid of death. This is the kind of syntactic sugar we need on our work, allowing us to write a more readable and maintainable program. As seen in the above picture, JavaScript continues to be the most used language on GitHub, along with its vibrant community. This is our top pick to handle asynchronous flows, but there are more ways to achieve the same results besides the ones that this guide describes. All in all, it's up to you to choose which is the best for your needs. Found this article useful? You might like these ones too!\n• Angular vs React: a comparison of both frameworks Full-stack developer and JavaScript lover. Top notch front-end is my thing where I like to experiment new stuff. Kayak fisher, brewer and beer drinker! Read more posts by this author"
    },
    {
        "link": "https://stackoverflow.com/questions/56782792/nodejs-javascript-design-patterns-to-avoid-async-mess",
        "document": "For the very specific case of initialising an async resource there are several design patterns you can use. Note that these design patterns will not really help with other use cases of asynchronous code.\n\nAs you've demonstrated in your own code, this is one way to do it. Basically you have an asynchronous method to initialise your resource. This is similar to jQuery's function. There are several ways to write an init function. The most straightforward is probably to accept a callback allowing you to continue with your logic:\n\nThis design pattern is more common in the Java world and is seen less often in javascript. The builder pattern is used when your object needs complex initialisation. Needing an asynchronous resource is exactly the kind of complexity that lends itself well to the builder pattern:\n\nThis design pattern is useful if your initialisation is messy or complicated and you'd prefer a cleaner API. The idea is to cache the resource and only initialise it when not yet initialised:\n\nIf you look back at the init function example you will see that the callback looks kind of like a control structure - kind of like a or . This is one of the killer features of anonymous functions - the ability to create control structures. There are good examples of this in standard javascript such as and and even good-old .\n\nYou are free to create asynchronous control structures (the coalan/async and async-q libraries are good examples of this). Instead of:\n\nYou can write it as:\n\nasync/await is just one tool in asynchronous programming. And is itself a design pattern. Therefore limiting yourself to async/await limits your software design. Get comfortable with anonymous functions and you will see lots of opportunities for refactoring asynchronous code.\n\nIn the example for the on-demand init pattern the usage example saves two pieces of data sequentially by using await. This was because the code would initialise the db connection twice if we don't wait for it to complete.\n\nBut what if we want to speed up the code and perform both saves in parallel? What if we want to do this:\n\nWhat we can do is we can have the method check if there's a pending promise:\n\nIn fact, since there's no limit to how many times we can call on a Promise, we can actually simplify that and just cache the promise (don't know why I didn't think of it before):"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map",
        "document": "The method is an iterative method. It calls a provided function once for each element in an array and constructs a new array from the results. Read the iterative methods section for more information about how these methods work in general. is invoked only for array indexes which have assigned values. It is not invoked for empty slots in sparse arrays. The method is generic. It only expects the value to have a property and integer-keyed properties. Since builds a new array, calling it without using the returned array is an anti-pattern; use or instead.\n\nIt is common to use the callback with one argument (the element being traversed). Certain functions are also commonly used with one argument, even though they take additional optional arguments. These habits may lead to confusing behaviors. Consider: While one might expect , the actual result is . is often used with one argument, but takes two. The first is an expression and the second is the radix to the callback function, passes 3 arguments: the element, the index, and the array. The third argument is ignored by — but not the second one! This is the source of possible confusion. Here is a concise example of the iteration steps: /* first iteration (index is 0): */ parseInt(\"1\", 0); // 1 /* second iteration (index is 1): */ parseInt(\"2\", 1); // NaN /* third iteration (index is 2): */ parseInt(\"3\", 2); // NaN To solve this, define another function that only takes one argument: You can also use the function, which only takes one argument: [\"1\", \"2\", \"3\"].map(Number); // [1, 2, 3] // But unlike parseInt(), Number() will also return a float or (resolved) exponential notation: [\"1.1\", \"2.2e2\", \"3e300\"].map(Number); // [1.1, 220, 3e+300] // For comparison, if we use parseInt() on the array above: [\"1.1\", \"2.2e2\", \"3e300\"].map((str) => parseInt(str, 10)); // [1, 2, 3] See A JavaScript optional argument hazard by Allen Wirfs-Brock for more discussions.\n\nThe callback can have side effects. This is not recommended, because copying methods are best used with pure functions. In this case, we can choose to iterate the array twice. Sometimes this pattern goes to its extreme and the only useful thing that does is causing side effects. const products = [ { name: \"sports car\" }, { name: \"laptop\" }, { name: \"phone\" }, ]; products.map((product) => { product.price = 100; }); As mentioned previously, this is an anti-pattern. If you don't use the return value of , use or a loop instead. Or, if you want to create a new array instead:\n\nUsing the third argument of callbackFn The argument is useful if you want to access another element in the array, especially when you don't have an existing variable that refers to the array. The following example first uses to extract the positive values and then uses to create a new array where each element is the average of its neighbors and itself. const numbers = [3, -1, 1, 4, 1, 5, 9, 2, 6]; const averaged = numbers .filter((num) => num > 0) .map((num, idx, arr) => { // Without the arr argument, there's no way to easily access the // intermediate array without saving it to a variable. const prev = arr[idx - 1]; const next = arr[idx + 1]; let count = 1; let total = num; if (prev !== undefined) { count++; total += prev; } if (next !== undefined) { count++; total += next; } const average = total / count; // Keep two decimal places return Math.round(average * 100) / 100; }); console.log(averaged); // [2, 2.67, 2, 3.33, 5, 5.33, 5.67, 4] The argument is not the array that is being built — there is no way to access the array being built from the callback function.\n\nThe method reads the property of and then accesses each property whose key is a nonnegative integer less than . const arrayLike = { length: 3, 0: 2, 1: 3, 2: 4, 3: 5, // ignored by map() since length is 3 }; console.log(Array.prototype.map.call(arrayLike, (x) => x ** 2)); // [ 4, 9, 16 ] This example shows how to iterate through a collection of objects collected by . This is because returns a (which is a collection of objects). In this case, we return all the selected s' values on the screen: You can also use to transform to an array, and then access the method."
    },
    {
        "link": "https://dev.to/jules_k/array-map-parseint-in-javascript-3ig",
        "document": "I saw something today posted by someone on Twitter and I thought to write a short post about it in a simple manner as the newbie that I am myself.\n\nIf you're new to JavaScript, I am sure many things look like they make sense, only to realize that the output of your code is something totally unexpected.\n\nWhat I saw was this:\n\n\n\nWe know that:\n• map function creates a new array with the results of calling a function for every array element.\n\nNow, if you expected the above to output this:\n\n\n\nThis is where understanding how things behave in Javascript will come very handy.\n\nWe know that parseInt expects 2 arguments:\n• string: The value to parse.\n• radix: An integer between 2 and 36 that represents the radix (the base in mathematical numeral systems) of the string.\n\nWe also know that map method expects a callback as an argument. The callback itself can accept 3 arguments:\n• the value of the element\n• the index of the element\n• and the array object being mapped\n\nSo what happens in the example above?\n\nLong story short, because we didn't pass the radix number (base) to parseInt, and parseInt is the callback in map, the second argument of the callback in map being the index of each element in the array, the index is passed down to parseInt as its second argument and parseInt \"thinks\" it is the radix (base) number.\n\nSo parseInt being the callback in map, will do this for each element of the array:\n\n\n\nFor '1' in base 0, parseInt evaluates 0 as falsey and the effect is the same as not passing a radix argument and it defaults to 10 so it is like writing it parseInt('1', 10)\n\nFor '2' in base 1, it returns NaN, because radix must be an integer between 2 and 36.\n\nFor '10' in base 2, it evaluates to 2.\n\nIf you want to convert array string values to integer values you could do this:"
    },
    {
        "link": "https://w3schools.com/jsref/jsref_map.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://geeksforgeeks.org/javascript-array-map-method",
        "document": "The map() method is an ES5 feature that creates a new array by applying a function to each element of the original array. It skips empty elements and does not modify the original array.\n\nExample 1: Here, we are using the map() method to create a new array containing the square roots of each number in the original array.\n\nExample 2: This example uses the array map() method and returns the square of the array element.\n\nExample 3: This example uses the array map() method to concatenate the character ‘A’ with every character of the name.\n\nThe parseInt() function converts strings to integers. When used with map(), it converts each element of an array of strings to integers. This explains that the map function can take another function as a callback function that has one parameter and another optional parameter.\n\nNote: We are converting string to integer so that\n\nExample: Here, we are using parseint() with map() function.\n\nWhat is the JavaScript map() method and what is it used for?\n\nHow does the map() method handle empty elements in an array?\n\nWhat parameters does the map() method accept in its callback function?\n\nCan map() be used with asynchronous functions in JavaScript?\n\nCan map() change the length of the array in JavaScript?"
    },
    {
        "link": "https://raddevon.com/articles/cant-use-parseint-map-javascript",
        "document": "Why can't I use parseInt with map in Javascript?\n\nI recently had a case where I wanted to break an IP address into the numerical values of its octets. I started with a string like this:\n\nwith the goal of having an array with each of the values like this:\n\nMy first attempt was to split the string on the dots making an array. Then, I had an array of the octets as strings. To get an array of numbers, I decided to run the array’s method passing in the function. Here’s what that might look like:\n\nThe results were not what I expected.\n\nWhat makes this more puzzling is that each octet worked except for the second which yielded (not a number). Why does this happen? To understand this problem, we need a better understanding of both and .\n\nJavascript arrays have a handy method that generates a new array by running each value in the old array through a function (the callback passed into ). Here’s a quick example that doubles each value in an array of numbers:\n\nThe callback function takes a parameter and returns the value multiplied by 2. The method of the array passes each value in turn to our doubling callback function and returns a new array of the results returned from the callback.\n\nparses an integer from a string. This is good when you’re dealing with user input as you’ll usually get it as a string. You might want to use it as a number though. Here’s a quick example that doubles a user-entered number:\n\nWhat we expected to happen when we ran is for Javascript to iterate over the array passing each of the octet strings to resulting in the string values being converted to numeric values. Let’s review the documentation for both and to validate our assumptions about how these work.\n\nThe documentation gives us some information about how the callback is called that we might not know even if we frequently use it. (I frequently forget it myself even though I use routinely.)\n\nI generally use by passing in an anonymous function, and I typically don’t use the index or the array object. That makes it easy for me to forget they are being passed. Here, though, it could be the reason we’re getting odd results from . I believe takes a single argument: the string to be parsed into an integer, but I need to confirm that.\n\nOnce again, my understanding here is incomplete. From the documentation, we learn it actually takes two arguments. The second argument is the radix of the first argument:\n\nWith our new understanding, we can dissect the problem. takes the radix as the second argument. is passing three arguments, the second of which is the index of the current item. The index of the current octet in the array is being passed to although it expects the radix of the string being parsed instead.\n\nWant more information about the radix? It’s the same as the base of another number system. Still lost? I’ve got a post on other number systems that will help.\n\nHere are the calls is making for our example IP address array:\n\nThe next question to help us understand is this: why does it work for all the octets except the second one?\n\nThe first octet works because the radix argument is falsey. (Javascript evaluates as when it’s evaluated as a boolean.) The effect is the same as not passing a radix argument.\n\nThe second octet is the one that fails. We know from the documentation that Javascript expects a value between and for the radix. isn’t implemented to parse an integer with a radix value of , so it returns .\n\nThe third and fourth octets both work just because their values happen to be . is represented the same regardless of the radix. If these had been different numbers, you would have seen more values in the results.\n\nHow to Fix It\n\nNow that we understand the problem, we can write a solution. Rather than passing the function to the array’s method, we’ll pass an anonymous function that calls with exactly the arguments we want. Here’s our fixed array mapping:\n\nWe’re only using the first value passed to the ’s callback (because we don’t care about the index or the entire array). From the anonymous function, we’re returning the result of , with being the string of that octet of the IP. I specified the radix here because of something else I picked up from the documentation on MDN. If you read the entire description of the function’s parameter, you’ll find this:\n\nIf we don’t specify the radix of the integer we’re parsing, the results could be unpredictable. In practice, I haven’t found that to be the case, but better to be explicit than rely upon different implementations having the same default value for radix.\n\nWe learned map passes three arguments to the callback rather than just the current value. We learned parseInt takes a second argument. More importantly than both of those, though, we learned that, if the results of your code are not what you expect, make sure you reference the documentation for anything you didn’t write yourself (in our case, and ) to be sure that your assumptions about how it works are correct.\n\nMaking these kinds of assumptions generally makes writing code much faster, but it can lead to problems like the ones we experienced here. As long as you know how to pull back and rebuild your mental models, you’ll be able to fix your issues and move forward quickly."
    }
]