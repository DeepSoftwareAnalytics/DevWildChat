[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API",
        "document": "The Canvas API provides a means for drawing graphics via JavaScript and the HTML element. Among other things, it can be used for animation, game graphics, data visualization, photo manipulation, and real-time video processing. The Canvas API largely focuses on 2D graphics. The WebGL API, which also uses the element, draws hardware-accelerated 2D and 3D graphics.\n\nThe method gets a reference to the HTML element. Next, the method gets that element's context—the thing onto which the drawing will be rendered. The actual drawing is done using the interface. The property makes the rectangle green. The method places its top-left corner at (10, 10), and gives it a size of 150 units wide by 100 tall.\n\nThe Canvas API is extremely powerful, but not always simple to use. The libraries listed below can make the creation of canvas-based projects faster and easier.\n• EaselJS is an open-source canvas library that makes creating games, generative art, and other highly graphical experiences easy.\n• Fabric.js is an open-source canvas library with SVG parsing capabilities.\n• heatmap.js is an open-source library for creating canvas-based data heat maps.\n• Konva.js is a 2D canvas library for desktop and mobile applications.\n• p5.js has a full set of canvas drawing functionality for artists, designers, educators, and beginners.\n• Paper.js is an open-source vector graphics scripting framework that runs on top of the HTML Canvas.\n• Phaser is a fast, free and fun open source framework for Canvas and WebGL powered browser games.\n• Pts.js is a library for creative coding and visualization in canvas and SVG.\n• Rekapi is an animation key-framing API for Canvas.\n• Scrawl-canvas is an open-source JavaScript library for creating and manipulating 2D canvas elements.\n• The ZIM framework provides conveniences, components, and controls for coding creativity on the canvas — includes accessibility and hundreds of colorful tutorials.\n• Sprig is a beginner-friendly, open-source, tile-based game development library that uses Canvas. Note: See the WebGL API for 2D and 3D libraries that use WebGL."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas",
        "document": "Use the HTML element with either the canvas scripting API or the WebGL API to draw graphics and animations.\n\nThe height of the coordinate space in CSS pixels. Defaults to 150. Lets the canvas know whether translucency will be a factor. If the canvas knows there's no translucency, painting performance can be optimized. This is only supported by Mozilla-based browsers; use the standardized instead. The width of the coordinate space in CSS pixels. Defaults to 300.\n\nThe displayed size of the canvas can be changed using CSS, but if you do this the image is scaled during rendering to fit the styled size, which can make the final graphics rendering end up being distorted. It is better to specify your canvas dimensions by setting the and attributes directly on the elements, either directly in the HTML or by using JavaScript.\n\nThe exact maximum size of a element depends on the browser and environment. While in most cases the maximum dimensions exceed 10,000 x 10,000 pixels, notably iOS devices limit the canvas size to only 4,096 x 4,096 pixels. See canvas size limits in different browsers and devices. Note: Exceeding the maximum dimensions or area renders the canvas unusable — drawing commands will not work.\n\nA canvas can be rendered using the API where the document and canvas are decoupled. The benefit is that a worker thread can handle canvas rendering and the main thread of your web application is not blocked by canvas operations. By parallelizing work, other UI elements of your web application will remain responsive even if you are running complex graphics on an offscreen canvas. For more information, see the API documentation."
    },
    {
        "link": "https://w3schools.com/tags/ref_canvas.asp",
        "document": "You can add a canvas element anywhere in an HTML page with the tag:\n\nYou can access a element with the HTML DOM method .\n\nTo draw in the canvas you need to create a 2D context object:\n\nAfter you have created a 2D context, you can draw on the canvas.\n\nThe fillRect() method draws a black rectangle with a top-left corner at position 20,20. The rectangle is 150 pixel wide and 100 pixels high.\n\nThe fillStyle property sets the fill color of the drawing object:\n\nYou can also create a new element with the method, and add the element to an existing HTML page:\n\nThe common way to draw on the canvas is to:\n\nThere are only 3 methods to draw directly on the canvas:\n\nThe canvas object also supports the standard properties and events.\n\nThe element is an HTML5 standard (2014).\n\nis supported in all modern browsers:"
    },
    {
        "link": "https://webfx.com/blog/web-design/canvas-element",
        "document": "The HTML5 element has a unique history. Starting out as an Apple creation and dating back to 2004, was eventually added to the official W3C HTML5 spec, becoming one of the most interesting and exciting parts of HTML5. It is used by web designers all over the world. Unfortunately, this element takes a bit of work to understand and, unlike your usual run-of-the-mill HTML elements, requires more than just static markup and styling. This element is great for sites looking for a more responsive web design, like maybe a realtor.\n\nIn this guide, I hope to get you started on understanding the element and what kinds of things are required and expected in its associated code. This should help you get a firm fundamental understanding of in preparation for creating something interesting and powerful with this unique HTML5 element.\n\nI can’t possibly define the element better than the official W3C spec, so I’ll just quote part of that document here:\n\nI also like the way Wikipedia describes its usage:\n\nAs you can see already, this element has a bit of complexity to it. Let’s take it one step at a time, beginning with the markup. The markup for the element looks like this:\n\nSimilar to the element, has a width and height set in the markup to give it an actual size.\n\nAnd because requires scripting for its full capabilities, I’ve added an attribute that will allow us to target it using either JavaScript or a JavaScript web development library like jQuery or MooTools. Once you have this basic markup, you can use CSS to make the visible or, using CSS3 properties, move it around — the same as you would do with any other HTML element. You can add a border, padding, background color, margins, you can float the , and assign CSS properties to it just like any HTML5 element.\n\nSome Basic Scripting to Make It Work\n\nTo start drawing on a canvas, you need to first target it using the Document Object Model (DOM).\n\nSince you can include more than one element on any given page, this is where an ID attribute comes into play (in this case, our ID is ). Once the is targeted, the JavaScript method needs to be called. This method identifies the context of the targeted element, which means you will have access to the canvas drawing API.\n\nHere’s an example of code that draws an object on the canvas:\n\nAfter defining the element via the DOM (line 1), the context is defined (line 2), then a shape is drawn and colored (lines 3 and 4). The first two lines are more or less standard stuff, whereas the third and fourth lines consist of a few examples of custom code using the properties and methods available in the drawing API. The four values given above in the method represent the distance from the x axis, the distance from the y axis, the width, and the height (in that order).\n\nThe above code would generate a box like this: Having this rudimentary understanding of the element, here are some points of note:\n• Every element starts out blank, so it will not appear on the page until something is drawn on it or if it’s styled via CSS (e.g. giving it a border or giving it a background color).\n• Each element appears in the DOM\n• You can erase everything that is drawn on the by resetting the width and/or height of the element\n• The method “returns an object that exposes an API for drawing” (definition straight from the spec)\n• There are currently two kinds of contexts available: and ( is currently the more commonly used context)\n• The element is “resolution-dependent,” which means (unlike SVG) it will not always scale cleanly after rendering\n• The default color for any shape drawn is black\n• Canvas-drawn objects are given colors using RGBA or Hex values\n\nThe 2D context allows for the use of a number of different drawing methods and properties, each utilizing syntaxes familiar to experienced CSS and JavaScript developers. So don’t be intimidated, it’s pretty straightforward stuff. Here are some of the JavaScript methods associated with drawing rectangles:\n• : Draws a rectangle according to the given size and coordinate values and fills the object with whatever is defined in the fill style\n• : Clears the pixels inside the space defined by the given size and coordinate values\n• : Draws the rectangle using strokes or borders (apart from the fill) according to the given size and coordinate values; this is done using the determined stroke style\n\nSimilar to the concept behind drawing rectangles, you can draw straight lines using the and methods. These methods define, by means of x and y coordinates, the start and end points of the lines, or paths, that will be drawn. These methods, however, do not actually draw the visible lines; they prepare the for the actual stroking of the lines that will occur when you call the method.\n\nAssuming the markup remains the same (with the canvas sized at 400×400), the code above (lines 3-6) draws a diagonal line from the top left corner of the canvas (0, 0) to the bottom right corner (400, 400). The last line of code uses the aforementioned method to stroke the path that was prepared on lines 3 and 4. Line 5 has the optional method that can give the line a color, gradient, or pattern. If a stroke style is not declared, the line will be black by default. This is the line that is drawn by the code block above: Here are some further points to note about the drawing API:\n• Coordinates that define paths and shapes can have decimal values, and this is encouraged to ensure line widths in certain circumstances are represented accurately\n• To draw multiple paths in multiple stroke styles, you use the method for each line, then the method to end the path after it’s drawn\n• You can draw any Unicode character onto a element, utilizing the , , and attributes to style and align the characters\n• If you don’t use the typographic attributes on text, the text will display using CSS styles applied to the element\n\nIn step with what is now possible in CSS3 in most modern browsers, the drawing API allows you to fill your shapes and paths with two types of gradients. Here is an example showing a rectangle being filled with a linear gradient:\n\nOn line 3 above, the gradient is stored in memory and is given 4 arguments. The first two arguments are the x and y coordinates that determine the starting point of the gradient; the second two arguments are the x and y coordinates that determine the end point of the gradient.\n\nAfter the gradient is created (but not drawn yet), color stops are added (lines 4-5). Then the fill style is defined on the canvas context, and the gradient that is created on line 3 is added as the value of the fill (line 5). After line 5, everything is just stored in memory, waiting to be used on a shape or path.\n\nThe last line makes the gradient visible by creating a shape on which to place the gradient. This is what the gradient looks like: Here are some notes on gradients:\n• The position of the gradient is relative to the , not the shape (which seems a little odd at first)\n• To make a diagonal gradient across an entire shape, the coordinates of the gradient would be identical to the coordinates and size of the shape\n• The first and last color stops in a linear gradient are represented by 0 and 1, respectively; any additional color stops are represented by decimal values in between 0 and 1. Putting a color stop at 50% of the object, then, would be .5.\n• Radial gradients are created using the method, which takes 6 arguments; the first 3 arguments create a circle for the starting point, and the last 3 create a circle for the end point\n\nOther Methods and Properties Available\n\nWhat I’ve discussed so far are some of the methods and properties that are easier to deal with and understand. Canvas, however, has a much broader set of tools available in its drawing API. Here’s some of what’s available, with links to appropriate parts of the spec:\n\nIt’s strongly recommended that fallback content be used for non-supporting devices. Fallback content is included by putting them between the opening and closing tags. For example, you might have something like this:\n\nThis is a pretty simple example.\n\nIf, for whatever reason, is unavailable, the user will see the image instead. That image will not display if is supported.\n\nMozilla’s Developer Center has a great “skeleton” template for drawing elements. This is the template with some minor modifications.\n\nThe JavaScript of the template does a couple of things. First, it checks when the window has fully loaded, which means the DOM is ready to be worked on.\n\nThis isn’t very efficient because the DOM will be ready even before the entire window is loaded, so on heavier pages, our function will take longer than it should to execute. The better solution would be to use with the argument of , but this isn’t supported in Internet Explorer (which wouldn’t really matter until IE9). If you use a JavaScript web development library like jQuery, then they’ll usually have methods or functions to handle this for you (i.e.\n\n). Another way to make this more efficient is to use inline JavaScript on the element to call the function (as in ), but this uses obtrusive JavaScript and isn’t really a good practice. Secondly, we use feature detection instead of browser sniffing to see if is supported.\n\nWe do this with an if/else control structure. If is not null, then we can assume is supported and that it is ready to be worked on. Otherwise ( ) we can run some code in the event that is not supported (such as telling the user that the page requires a browser with support).\n\nFor CSS, we just draw a black border around the area of the elements to make it easier to see. Then, finally, the HTML just involves giving the element an ID, width, and height.\n\nIf you’re going to spend the time to create some sort of fallback content, then it would be good to know the extent of browser support for the element and its associated scripting. is supported in the following browsers and devices:\n\nUsing a third-party library called ExplorerCanvas, support is available in Internet Explorer 6 and up. All that’s required is to include a single JavaScript file on any page that uses the element. From my limited experience in running some example pages included with the ExploreCanvas library, IE’s rendering of elements is very slow and resource-heavy, so unfortunately this workaround is not very inviting.\n\nYou might think that it’s a little counterproductive and counterintuitive to create simple objects using such complex means.\n\nCanvas, however, should not be utilized for static object creation. Canvas is best used for drawing objects dynamically according to user input, or for updating the display of objects that are dependent on some kind of a dynamic feed of information (such as real-time stock market fluctuations visualized through a line graph).\n\nAlthough I’m not a huge fan of experimental techniques, it may be of value at this point to show what is possible with the element. Here are a few examples of apps and other experiments that do some interesting and downright cool stuff with HTML5 :\n\nA virtual fish tank in your browser using attractive fish built without any graphic files.\n\nIt has realistic fish movements and bubbles. Click on the tank to add as many fish as you want!\n\nAn experiment taking HTML5 to the next level. Each of the circle you see in the background is a Twitter user.\n\nClick on a circle and you’ll see more information about that user. HTML5 Canvas and Audio Experiment\n\nA little experiment that loads 100 tweets related to HTML5 and displays them using a JavaScript-based particle engine. Each particle represents a tweet — click on one of them and it will appear on the screen.\n\nThe international Billiards Tournament is being infiltrated by the terrorist organization CHALK.\n\nDo not let them win! Sink as many balls as possible before the timer runs out.\n\nThis demo is an implementation of a full 8-bit color cycling engine, rendered into a 32-bit HTML5 in real-time.\n\nThere are many color cycling scenes to choose from, with some ambient environmental soundtracks to match.\n\nA simple motorcycle game using and JavaScript. Use keyboard controls to do as many back flips and front flips as you can.\n\nFinally, here are some further articles, tutorials, and libraries that discuss or use the element:\n• Canvas Toolkit: A basic HTML5 drawing library for those familiar with the java.awt.Graphics class in Java.\n• The canvas element: discussed in Mark Pilgrim’s Dive Into HTML5\n• Processing.js: An open programming language for people who want to program images, animation, and interactions using the HTML5 canvas element\n• <canvas> text: A library that allows canvas’s text-drawing methods to work in non-supporting browsers\n• Canvas Demos: Home to applications, games, tools and tutorials that use the HTML5 element\n• An Introduction to the Canvas 2D API: Tutorial on HTML5 Doctor\n• Bouncing a Ball Around with HTML5 and JavaScript\n\nIf you know of any cool libraries, demos, or experiments that use the HTML5 canvas element, please let us know in the comments.\n• Bouncing a Ball Around with HTML5 and JavaScript\n• The Only HTML5 Resources You Need for Getting Up to Speed"
    },
    {
        "link": "https://w3schools.com/html/html5_canvas.asp",
        "document": "Your browser does not support the <canvas> element. The HTML element is used to draw graphics on a web page. The graphic to the left is created with . It shows four elements: a red rectangle, a gradient rectangle, a multicolor rectangle, and a multicolor text.\n\nThe HTML element is used to draw graphics, on the fly, via JavaScript.\n\nThe element is only a container for graphics. You must use JavaScript to actually draw the graphics.\n\nCanvas has several methods for drawing paths, boxes, circles, text, and adding images.\n\nCanvas is supported by all major browsers.\n\nA canvas is a rectangular area on an HTML page. By default, a canvas has no border and no content.\n\nThe markup looks like this:\n\nNote: Always specify an attribute (to be referred to in a script), and a and attribute to define the size of the canvas. To add a border, use the attribute.\n\nHere is an example of a basic, empty canvas:\n\nAfter creating the rectangular canvas area, you must add a JavaScript to do the drawing.\n\nHere are some examples:\n\nTo learn more about , please read our HTML Canvas Tutorial."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Scripting/Events",
        "document": "Events are things that happen in the system you are programming, which the system tells you about so your code can react to them. For example, if the user clicks a button on a webpage, you might want to react to that action by displaying an information box. In this article, we discuss some important concepts surrounding events, and look at the fundamentals of how they work in browsers. An understanding of HTML and the fundamentals of CSS, familiarity with JavaScript basics as covered in previous lessons.\n• What events are — a signal fired by the browser when something significant happens, which the developer can run some code in response to.\n• Setting up event handlers using (and ) and event handler properties.\n• Inline event handler attributes, and why you shouldn't use them.\n\nWhat is an event? Events are things that happen in the system you are programming — the system produces (or \"fires\") a signal of some kind when an event occurs, and provides a mechanism by which an action can be automatically taken (that is, some code running) when the event occurs. Events are fired inside the browser window, and tend to be attached to a specific item that resides in it. This might be a single element, a set of elements, the HTML document loaded in the current tab, or the entire browser window. There are many different types of events that can occur.\n• The user selects, clicks, or hovers the cursor over a certain element.\n• The user presses a key on the keyboard.\n• The user resizes or closes the browser window. You can gather from this (and from glancing at the MDN event reference) that there are a lot of events that can be fired. To react to an event, you attach an event handler to it. This is a block of code (usually a JavaScript function that you as a programmer create) that runs when the event fires. When such a block of code is defined to run in response to an event, we say we are registering an event handler. Note: Event handlers are sometimes called event listeners — they are pretty much interchangeable for our purposes, although strictly speaking, they work together. The listener listens out for the event happening, and the handler is the code that runs in response to it happening. Note: Web events are not part of the core JavaScript language — they are defined as part of the APIs built into the browser.\n\nIn the following example, we have a single in the page: Then we have some JavaScript. We'll look at this in more detail in the next section, but for now we can just say: it adds an event handler to the button's event, and the handler reacts to the event by setting the page background to a random color: The example output is as follows. Try clicking the button:\n\nIf you've added an event handler using , you can remove it again using the method. For example, this would remove the event handler: Event handlers can also be removed by passing an to and then later calling on the controller owning the . For example, to add an event handler that we can remove with an : const controller = new AbortController(); btn.addEventListener(\"click\", () => { const rndCol = `rgb(${random(255)} ${random(255)} ${random(255)})`; document.body.style.backgroundColor = rndCol; }, { signal: controller.signal } // pass an AbortSignal to this handler ); Then the event handler created by the code above can be removed like this: controller.abort(); // removes any/all event handlers associated with this controller For simple, small programs, cleaning up old, unused event handlers isn't necessary, but for larger, more complex programs, it can improve efficiency. Also, the ability to remove event handlers allows you to have the same button performing different actions in different circumstances: all you have to do is add or remove handlers.\n\nObjects (such as buttons) that can fire events also usually have properties whose name is followed by the name of the event. For example, elements have a property . This is called an event handler property. To listen for the event, you can assign the handler function to the property. For example, we could rewrite the random-color example like this: You can also set the handler property to a named function: With event handler properties, you can't add more than one handler for a single event. For example, you can call on an element multiple times, with different functions specified in the second argument: This is impossible with event handler properties because any subsequent attempts to set the property will overwrite earlier ones:\n\nYou might also see a pattern like this in your code: The earliest method of registering event handlers found on the Web involved event handler HTML attributes (or inline event handlers) like the one shown above — the attribute value is literally the JavaScript code you want to run when the event occurs. The above example invokes a function defined inside a element on the same page, but you could also insert JavaScript directly inside the attribute, for example: <button onclick=\"alert('Hello, this is my old-fashioned event handler!');\"> Press me </button> You can find HTML attribute equivalents for many of the event handler properties; however, you shouldn't use these — they are considered bad practice. It might seem easy to use an event handler attribute if you are doing something really quick, but they quickly become unmanageable and inefficient. For a start, it is not a good idea to mix up your HTML and your JavaScript, as it becomes hard to read. Keeping your JavaScript separate is a good practice, and if it is in a separate file you can apply it to multiple HTML documents. Even in a single file, inline event handlers are not a good idea. One button is OK, but what if you had 100 buttons? You'd have to add 100 attributes to the file; it would quickly turn into a maintenance nightmare. With JavaScript, you could easily add an event handler function to all the buttons on the page no matter how many there were, using something like this: Finally, many common server configurations will disallow inline JavaScript, as a security measure. You should never use the HTML event handler attributes — those are outdated, and using them is bad practice.\n\nSometimes, inside an event handler function, you'll see a parameter specified with a name such as , , or . This is called the event object, and it is automatically passed to event handlers to provide extra features and information. For example, let's rewrite our random color example again slightly: Note: You can find the full source code for this example on GitHub (also see it running live). Here you can see we are including an event object, e, in the function, and in the function setting a background color style on — which is the button itself. The property of the event object is always a reference to the element the event occurred upon. So, in this example, we are setting a random background color on the button, not the page. Note: You can use any name you like for the event object — you just need to choose a name that you can then use to reference it inside the event handler function. / / is most commonly used by developers because they are short and easy to remember. It's always good to be consistent — with yourself, and with others if possible.\n\nSometimes, you'll come across a situation where you want to prevent an event from doing what it does by default. The most common example is that of a web form, for example, a custom registration form. When you fill in the details and click the submit button, the natural behavior is for the data to be submitted to a specified page on the server for processing, and the browser to be redirected to a \"success message\" page of some kind (or the same page, if another is not specified). The trouble comes when the user has not submitted the data correctly — as a developer, you want to prevent the submission to the server and give an error message saying what's wrong and what needs to be done to put things right. Some browsers support automatic form data validation features, but since many don't, you are advised to not rely on those and implement your own validation checks. Let's look at an example. First, a simple HTML form that requires you to enter your first and last name: Now some JavaScript — here we implement a very simple check inside a handler for the event (the submit event is fired on a form when it is submitted) that tests whether the text fields are empty. If they are, we call the function on the event object — which stops the form submission — and then display an error message in the paragraph below our form to tell the user what's wrong: const form = document.querySelector(\"form\"); const fname = document.getElementById(\"fname\"); const lname = document.getElementById(\"lname\"); const para = document.querySelector(\"p\"); form.addEventListener(\"submit\", (e) => { if (fname.value === \"\" || lname.value === \"\") { e.preventDefault(); para.textContent = \"You need to fill in both names!\"; } }); Obviously, this is pretty weak form validation — it wouldn't stop the user from validating the form with spaces or numbers entered into the fields, for example — but it is OK for example purposes. The output is as follows: Note: For the full source code, see preventdefault-validation.html (also see it running live here)."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener",
        "document": "Note: This feature is available in Web Workers. The method of the interface sets up a function that will be called whenever the specified event is delivered to the target. Common targets are , or its children, , and , but the target may be any object that supports events (such as ). Note: The method is the recommended way to register an event listener. The benefits are as follows:\n• It allows adding more than one handler for an event. This is particularly useful for libraries, JavaScript modules, or any other kind of code that needs to work well with other libraries or extensions.\n• In contrast to using an property, it gives you finer-grained control of the phase when the listener is activated (capturing vs. bubbling).\n• It works on any event target, not just HTML or SVG elements. The method works by adding a function, or an object that implements a function, to the list of event listeners for the specified event type on the on which it's called. If the function or object is already in the list of event listeners for this target, the function or object is not added a second time. Note: If a particular anonymous function is in the list of event listeners registered for a certain target, and then later in the code, an identical anonymous function is given in an call, the second function will also be added to the list of event listeners for that target. Indeed, anonymous functions are not identical even if defined using the same unchanging source-code called repeatedly, even if in a loop. Repeatedly defining the same unnamed function in such cases can be problematic. (See Memory issues, below.) If an event listener is added to an from inside another listener — that is, during the processing of the event — that event will not trigger the new listener. However, the new listener may be triggered during a later stage of event flow, such as during the bubbling phase.\n\nThe value of \"this\" within the handler It is often desirable to reference the element on which the event handler was fired, such as when using a generic handler for a set of similar elements. When attaching a handler function to an element using , the value of inside the handler will be a reference to the element. It will be the same as the value of the property of the event argument that is passed to the handler. my_element.addEventListener(\"click\", function (e) { console.log(this.className); // logs the className of my_element console.log(e.currentTarget === this); // logs `true` }); As a reminder, arrow functions do not have their own context. my_element.addEventListener(\"click\", (e) => { console.log(this.className); // WARNING: `this` is not `my_element` console.log(e.currentTarget === this); // logs `false` }); If an event handler (for example, ) is specified on an element in the HTML source, the JavaScript code in the attribute value is effectively wrapped in a handler function that binds the value of in a manner consistent with the ; an occurrence of within the code represents a reference to the element. <table id=\"my_table\" onclick=\"console.log(this.id);\"> <!-- `this` refers to the table; logs 'my_table' --> … </table> Note that the value of inside a function, called by the code in the attribute value, behaves as per standard rules. This is shown in the following example: <script> function logID() { console.log(this.id); } </script> <table id=\"my_table\" onclick=\"logID();\"> <!-- when called, `this` will refer to the global object --> … </table> The value of within is a reference to the global object (or in the case of strict mode. Specifying \"this\" using bind() The method lets you establish a fixed context for all subsequent calls — bypassing problems where it's unclear what will be, depending on the context from which your function was called. Note, however, that you'll need to keep a reference to the listener around so you can remove it later. This is an example with and without : class Something { name = \"Something Good\"; constructor(element) { // bind causes a fixed `this` context to be assigned to `onclick2` this.onclick2 = this.onclick2.bind(this); element.addEventListener(\"click\", this.onclick1, false); element.addEventListener(\"click\", this.onclick2, false); // Trick } onclick1(event) { console.log(this.name); // undefined, as `this` is the element } onclick2(event) { console.log(this.name); // 'Something Good', as `this` is bound to the Something instance } } const s = new Something(document.body); Another solution is using a special function called to catch any events: class Something { name = \"Something Good\"; constructor(element) { // Note that the listeners in this case are `this`, not this.handleEvent element.addEventListener(\"click\", this, false); element.addEventListener(\"dblclick\", this, false); } handleEvent(event) { console.log(this.name); // 'Something Good', as this is bound to newly created object switch (event.type) { case \"click\": // some code here… break; case \"dblclick\": // some code here… break; } } } const s = new Something(document.body); Another way of handling the reference to is to use an arrow function, which doesn't create a separate context. class SomeClass { name = \"Something Good\"; register() { window.addEventListener(\"keydown\", (e) => { this.someMethod(e); }); } someMethod(e) { console.log(this.name); switch (e.code) { case \"ArrowUp\": // some code here… break; case \"ArrowDown\": // some code here… break; } } } const myObject = new SomeClass(); myObject.register();\n\nconst elts = document.getElementsByTagName(\"*\"); // Case 1 for (const elt of elts) { elt.addEventListener( \"click\", (e) => { // Do something }, false, ); } // Case 2 function processEvent(e) { // Do something } for (const elt of elts) { elt.addEventListener(\"click\", processEvent, false); } In the first case above, a new (anonymous) handler function is created with each iteration of the loop. In the second case, the same previously declared function is used as an event handler, which results in smaller memory consumption because there is only one handler function created. Moreover, in the first case, it is not possible to call because no reference to the anonymous function is kept (or here, not kept to any of the multiple anonymous functions the loop might create.) In the second case, it's possible to do because is the function reference. Actually, regarding memory consumption, the lack of keeping a function reference is not the real issue; rather it is the lack of keeping a static function reference.\n\nIf an event has a default action — for example, a event that scrolls the container by default — the browser is in general unable to start the default action until the event listener has finished, because it doesn't know in advance whether the event listener might cancel the default action by calling . If the event listener takes too long to execute, this can cause a noticeable delay, also known as jank, before the default action can be executed. By setting the option to , an event listener declares that it will not cancel the default action, so the browser can start the default action immediately, without waiting for the listener to finish. If the listener does then call , this will have no effect. The specification for defines the default value for the option as always being . However, to realize the scroll performance benefits of passive listeners in legacy code, modern browsers have changed the default value of the option to for the , , and events on the document-level nodes , , and . That prevents the event listener from canceling the event, so it can't block page rendering while the user is scrolling. Because of that, when you want to override that behavior and ensure the option is , you must explicitly set the option to (rather than relying on the default). You don't need to worry about the value of for the basic event. Since it can't be canceled, event listeners can't block page rendering anyway. See Improving scroll performance using passive listeners for an example showing the effect of passive listeners.\n\nThe following example shows the effect of setting . It includes a that contains some text, and a check box. <div id=\"container\"> <p> But down there it would be dark now, and not the lovely lighted aquarium she imagined it to be during the daylight hours, eddying with schools of tiny, delicate animals floating and dancing slowly to their own serene currents and creating the look of a living painting. That was wrong, in any case. The ocean was different from an aquarium, which was an artificial environment. The ocean was a world. And a world is not art. Dorothy thought about the living things that moved in that world: large, ruthless and hungry. Like us up here. </p> </div> <div> <input type=\"checkbox\" id=\"passive\" name=\"passive\" checked /> <label for=\"passive\">passive</label> </div> The code adds a listener to the container's event, which by default scrolls the container. The listener runs a long-running operation. Initially the listener is added with the option, and whenever the checkbox is toggled, the code toggles the option. const passive = document.querySelector(\"#passive\"); passive.addEventListener(\"change\", (event) => { container.removeEventListener(\"wheel\", wheelHandler); container.addEventListener(\"wheel\", wheelHandler, { passive: passive.checked, once: true, }); }); const container = document.querySelector(\"#container\"); container.addEventListener(\"wheel\", wheelHandler, { passive: true, once: true, }); function wheelHandler() { function isPrime(n) { for (let c = 2; c <= Math.sqrt(n); ++c) { if (n % c === 0) { return false; } } return true; } const quota = 1000000; const primes = []; const maximum = 1000000; while (primes.length < quota) { const candidate = Math.floor(Math.random() * (maximum + 1)); if (isPrime(candidate)) { primes.push(candidate); } } console.log(primes); }\n• Initially, the listener is passive, so trying to scroll the container with the wheel is immediate.\n• If you uncheck \"passive\" and try to scroll the container using the wheel, then there is a noticeable delay before the container scrolls, because the browser has to wait for the long-running listener to finish."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Element/input_event",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020 .\n\nThe event fires when the of an , , or element has been changed as a direct result of a user action (such as typing in a textbox or checking a checkbox).\n\nThe event also applies to elements with enabled, and to any element when is turned on. In the case of and , the event target is the editing host. If these properties apply to multiple elements, the editing host is the nearest ancestor element whose parent isn't editable.\n\nFor elements with or , the event should fire whenever a user toggles the control, per the HTML Living Standard specification. However, historically this has not always been the case. Check compatibility, or use the event instead for elements of these types.\n\nFor and elements that accept text input ( , , etc.), the interface is ; for others, the interface is .\n\nThe event is fired every time the of the element changes. This is unlike the event, which only fires when the value is committed, such as by pressing the enter key or selecting a value from a list of options. Note that the event is not fired when JavaScript changes an element's programmatically."
    },
    {
        "link": "https://w3schools.com/js/js_htmldom_eventlistener.asp",
        "document": "The method attaches an event handler to the specified element.\n\nThe method attaches an event handler to an element without overwriting existing event handlers.\n\nYou can add many event handlers to one element.\n\nYou can add many event handlers of the same type to one element, i.e two \"click\" events.\n\nYou can add event listeners to any DOM object not only HTML elements. i.e the window object.\n\nThe method makes it easier to control how the event reacts to bubbling.\n\nWhen using the method, the JavaScript is separated from the HTML markup, for better readability and allows you to add event listeners even when you do not control the HTML markup.\n\nYou can easily remove an event listener by using the method.\n\n\n\nThe first parameter is the type of the event (like \" \" or \" \" or any other HTML DOM Event.)\n\nThe second parameter is the function we want to call when the event occurs.\n\nThe third parameter is a boolean value specifying whether to use event bubbling or event capturing. This parameter is optional.\n\nAdd an Event Handler to an Element\n\nYou can also refer to an external \"named\" function:\n\nAdd Many Event Handlers to the Same Element\n\nThe method allows you to add many events to the same element, without overwriting existing events:\n\nYou can add events of different types to the same element:\n\nAdd an Event Handler to the window Object\n\nThe method allows you to add event listeners on any HTML DOM object such as HTML elements, the HTML document, the window object, or other objects that support events, like the object.\n\nWhen passing parameter values, use an \"anonymous function\" that calls the specified function with the parameters:\n\nThere are two ways of event propagation in the HTML DOM, bubbling and capturing.\n\nEvent propagation is a way of defining the element order when an event occurs. If you have a <p> element inside a <div> element, and the user clicks on the <p> element, which element's \"click\" event should be handled first?\n\nIn bubbling the inner most element's event is handled first and then the outer: the <p> element's click event is handled first, then the <div> element's click event.\n\nIn capturing the outer most element's event is handled first and then the inner: the <div> element's click event will be handled first, then the <p> element's click event.\n\nWith the addEventListener() method you can specify the propagation type by using the \"useCapture\" parameter:\n\nThe default value is false, which will use the bubbling propagation, when the value is set to true, the event uses the capturing propagation.\n\nThe method removes event handlers that have been attached with the addEventListener() method:\n\nFor a list of all HTML DOM events, look at our complete HTML DOM Event Object Reference."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Element/click_event",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 . * Some parts of this feature may have varying levels of support.\n\nAn element receives a event when any of the following occurs:\n• A pointing-device button (such as a mouse's primary button) is both pressed and released while the pointer is located inside the element.\n• A touch gesture is performed on the element.\n• Any user interaction that is equivalent to a click, such as pressing the key or key while the element is focused. Note that this only applies to elements with a default key event handler, and therefore, excludes other elements that have been made focusable by setting the attribute. If the button is pressed on one element and the pointer is moved outside the element before the button is released, the event is fired on the most specific ancestor element that contained both elements. fires after both the and events have fired, in that order. The event is a device-independent event — meaning it can be activated by touch, keyboard, mouse, and any other mechanism provided by assistive technology.\n\nThis interface inherits properties from and . Represents the angle between a transducer (a pointer or stylus) axis and the X-Y plane of a device screen. Represents the angle between the Y-Z plane and the plane containing both the transducer (a pointer or stylus) axis and the Y axis. A unique identifier for the pointer causing the event. The width (magnitude on the X axis), in CSS pixels, of the contact geometry of the pointer. The height (magnitude on the Y axis), in CSS pixels, of the contact geometry of the pointer. The normalized pressure of the pointer input in the range to , where and represent the minimum and maximum pressure the hardware is capable of detecting, respectively. The normalized tangential pressure of the pointer input (also known as barrel pressure or cylinder stress) in the range to , where is the neutral position of the control. The plane angle (in degrees, in the range of to ) between the Y–Z plane and the plane containing both the pointer (e.g. pen stylus) axis and the Y axis. The plane angle (in degrees, in the range of to ) between the X–Z plane and the plane containing both the pointer (e.g. pen stylus) axis and the X axis. The clockwise rotation of the pointer (e.g. pen stylus) around its major axis in degrees, with a value in the range to . Indicates the device type that caused the event (mouse, pen, touch, etc.). Indicates if the pointer represents the primary pointer of this pointer type.\n\nThe object passed into the event handler for has its property set to the number of times the was clicked. In other words, will be 2 for a double-click, 3 for triple-click, and so forth. This counter resets after a short interval without any clicks occurring; the specifics of how long that interval is may vary from browser to browser and across platforms. The interval is also likely to be affected by user preferences; for example, accessibility options may extend this interval to make it easier to perform multiple clicks with adaptive interfaces."
    },
    {
        "link": "https://cloudinary.com/guides/web-performance/javascript-image-optimization-techniques",
        "document": "Since the beginning of the rise of the web, images have become a common and integral part of modern websites and website applications. Images are used for various purposes, such as conveying concepts and information that can help improve comprehension by reinforcing information provided in text.\n\nImages can also represent a brand’s identity and improve the user experience by providing additional context or explanation for various website contents. They also play a vital role in a website’s SEO, which can help grab the attention of website visitors, improve user engagement, and ultimately drive conversions.\n\nWhile images can help improve the quality of a website’s content, they can also be disadvantageous when misused. For example, using an image with a large file size that takes too long to load on a webpage is one of the most common ways images hamper a website’s performance and usability.\n\nWhy is Image Optimization Necessary?\n\nImage optimization is a technique for delivering high-quality images in the right format, dimension, and resolution while keeping the file size as small as possible. Image optimization is particularly useful for websites presenting high-quality images to users without sacrificing performance metrics such as page load time.\n\nTwo major techniques are used in image compression: lossy and lossless. Lossy compression reduces image file size by permanently removing or ‘losing’ certain information in the image that is not useful.\n\nLossless compression, on the other hand, reduces an image file size by rebuilding and restoring its original data so it can take up less space. Because no data is lost in this compression method, the process is reversible, also known as reversible compression.\n\nDepending on the compression method you decide to use, there are advantages and disadvantages. Lossy compression gives you a smaller file size than the lossless method but with a trade-off of image quality and vice versa. Some common trade-offs associated with lossy compression are color degradation, the introduction of visual artifacts like blockiness and blurring, and the irreversibility of the compressed images.\n\nThere are several libraries and packages that can be used to compress images in JavaScript applications. Some of the most popular ones are discussed below.\n\nTinyPNG offers a versatile toolkit for various image manipulation tasks. It has a browser-based interface for uploading images directly for compression and an API supporting programming languages like JavaScript, Python, PHP, Java, and more. Apart from image compression, TinyPNG also allows you to convert images from one format to another, resize, crop, or perform simple image editing operations like background removal and addition.\n\nCompressing an image in Node.js using TinyPNG is straightforward:\n\nThe HTML element’s method is a handy tool for image compression using vanilla JavaScript and good old HTML. In this example, we’ll show you how to compress an image using the canvas element.\n\nThe main tool for the image compression is the method. It has the following syntax:\n\nTo get started, create a new folder and an file in it with the following code:\n\nTIP: You can use the Live Server extension in VS Code to quickly create a server to launch the code.\n\nOnce the code is launched, you should see a page like the following in the browser:\n\nImage optimization is one of the many features that Cloudinary has to offer. With Cloudinary, you can perform different kinds of optimizations such as image compression, resizing, format conversion, metadata removal, and many more.\n\nCloudinary provides an easy and convenient way of compressing images on the fly by letting you specify an image quality setting that defines the compression level to apply to an image. You can apply a value between 1 (lowest image quality) and 100 (highest image quality) or let Cloudinary handle the compression for you automatically.\n\nIn this section, we’ll show you how to use Cloudinary Node.js SDK to compress any image in your JavaScript application.\n\nCreate a new folder and run the following command to initialize a Node application:\n\nAnswer the prompts to configure the application accordingly and then run the following command to install the necessary packages to run the application:\n\nNext, open the file in the project root directory and modify the field to the following:\n\nCreate a file named in the root directory and add the following code to create an Express server:\n\nTo access Cloudinary programmatically using the Node.js SDK, we need to use our Cloudinary API credentials. To get your credentials, log into your Cloudinary account and navigate to your dashboard as shown below:\n\nCopy your Cloud name, API key, and API secret. Next, create a file in the project root directory and add the corresponding values as follows:\n\nNext, run on the command line to start up the server. When you navigate to , you should see The app is running! rendered.\n\nNOTE: Make sure the version of Node.js you’re using is not later than 18.11.0 to avoid unexpected errors when using the flag. You can check the version of Node.js installed on your computer by running in your terminal.\n\nIn this step, we’ll update with the main code to compress the quality of any image uploaded to the server.\n\nHere’s a breakdown of what’s going on above.\n• In the first few lines, we imported the packages for running the application and also configured the necessary Cloudinary credentials using environment variables.\n• Next, we defined a function to check if the uploaded file is an image file. If the file is an image, it calls the callback function with and to allow the file upload. Otherwise, it creates an error object and calls the callback with the error and to reject the file upload.\n• Next, we defined a route handler for the endpoint. This code block uploads the image file to Cloudinary using the function. If the upload is successful, the function is called to compress the image quality, and the compressed file URL is finally sent as a JSON response.\n\nStep 4 – Trying it out\n\nLet’s try out our code by uploading an image file for compression using the Postman VS Code extension. The image we’ll be uploading has an original file size of 2.94 MB, as shown below:\n\nNext, we’ll open the Postman extension and upload the image to the server:\n\nNext, we’ll upload the URL of the compressed image to Jimpl.com to see if the image has really been compressed by checking its file size.\n\nIndeed! The file size has been reduced from a whopping 2.94 MB to 358 KB—that’s about an 88.1% reduction! And the image still maintains its original quality. Isn’t that awesome!?\n\nNow, you can go on to compress the images on your website with Cloudinary for improved performance and user experience!\n\nOptimizing images is crucial for enhancing any website’s performance, user experience, and search engine optimization (SEO). In this article, we explored various JavaScript-based image optimization techniques, including lossy and lossless compression, using libraries like TinyPNG, UPNG.js, compressor.js, and browser-image-compression.js, as well as leveraging the HTML element.\n\nFinally, we explored how you can leverage Cloudinary, the cloud-based image management solution, to compress images in JavaScript. Hopefully, this article has given you a glimpse into what’s possible with Cloudinary. Feel free to sign up for a free account today to explore more about what Cloudinary has to offer."
    },
    {
        "link": "https://stackoverflow.com/questions/14672746/how-to-compress-an-image-via-javascript-in-the-browser",
        "document": "Is there a way to compress an image (mostly jpeg, png and gif) directly browser-side, before uploading it ? I'm pretty sure JavaScript can do this, but I can't find a way to achieve it.\n\n\n\n Here's the full scenario I would like to implement:\n• the user goes to my website, and choose an image via an element,\n• this image is retrieved via JavaScript, we do some verification such as correct file format, maximum file size etc,\n• if every thing is OK, a preview of the image is displayed on the page,\n• the user can do some basic operations such as rotate the image by 90°/-90°, crop it following a pre-defined ratio, etc, or the user can upload another image and return to step 1,\n• when the user is satisfied, the edited image is then compressed and \"saved\" locally (not saved to a file, but in the browser memory/page),-\n• the user fill a form with data like name, age etc,\n• the user click on the \"Finish\" button, then the form containing datas + compressed image is sent to the server (without AJAX),\n\nThe full process up to the last step should be done client side, and should be compatible on latest Chrome and Firefox, Safari 5+ and IE 8+. If possible, only JavaScript should be used (but I'm pretty sure this is not possible).\n\nI've not code anything right now, but I've thought about it already. File reading locally is possible via File API, image previewing and editing could be done using Canvas element, but I can't find a way to do the image compression part.\n\nAccording to html5please.com and caniuse.com, supporting those browser is quite hard (thanks to IE), but could be done using polyfill such as FlashCanvas and FileReader.\n\nActually, the goal is to reduce file size, so I see image compression as a solution. But, I know that uploaded images are going to be displayed on my website, every time at the same place, and I know the dimension of this display area (eg. 200x400). So, I could resize the image to fit those dimensions, thus reducing file size. I have no idea what would be the compression ratio for this technique.\n\nWhat do you think ? Do you have any advice to tell me ? Do you know any way to compress an image browser-side in JavaScript ? Thanks for your replies."
    },
    {
        "link": "https://medium.com/@jaredpotter1/optimizing-images-for-the-web-part-1-aa88c1c6d80e",
        "document": "The majority of software engineers I know love to focus on the latest and greatest framework, technology, or library. However, not enough of these engineers look at some basics that will immediately improve the load times of web apps, improve user experience while also reducing data usage and storage costs.\n\nThe basic we’ll look at today is simple: optimizing images for the web.\n\nTake a look at the following examples. They all heavily utilize image content. What’s worse is that these images haven’t been optimized for the web. This lack of proper image compression causes cascading impacts: ballooning storage buckets, increase data transfer cost for both you and your user’s data plan, and, most critical, the negative impacts the user experiences with poor load times — especially in places with only 3g connections (or less).\n\nI ran across a photographer’s portfolio website where they had a set of 4 different carousels showing off a total of 41 photos. The nasty truth became apparent when I opened up my Chrome network tab and found the site was loading over 300 MBs of data. With mobile providers charging about $10 a gig puts this person’s site at load cost of $3.\n\nThis is a bit of an extreme example but not impossible.\n\nLet’s take a look at a more common example. Through hiring I’ve seen many developer portfolio sites with full screen background photos for a cool design effect. On some sites I also found very large, uncompressed PNG screenshots demoing apps.\n\n50 MB isn’t the same as 308 MB but still considered an unnecessarily large landing page on their site.\n\nOn this page the background image was 11.1 MB alone. ~10 PNG screenshots ranging in size of 2–3 MB.\n\nIn this part 1 article we’ll explore a few native solutions for quick and easy image optimization. Part 2 will look at more advanced methods with professional tools (JPEGmini) and command line interfaces. Finally part 3 takes on organizational/enterprise solutions — APIs, Mobile SDKs, and Javascript web uploaders, and an affordable custom JPEGmini server.\n\nToo few Mac users know the power of many of the operating system’s basic apps. Today we’ll explore Mac OSX’s Preview app and its ability to batch compress images into a web optimized JPEG and PNG formats.\n• Select the images you’d like to compress, secondary-click, then and open with Preview\n\n2. Select all images in the left sidebar (command + a)\n\n4. For PNG you can remove the alpha layer (which reduces the file size if not required). For JPEG/JPG you can adjust the quality with a slider.\n\nWeird Bug: I found that if I left the quality slider at its recommend spot of 7.7 MB that it exports the same 11.1 MB original file. However, if I bumped it down from 7.7 MB to 7.6 MB then it exported correctly to 7.6 MB.\n\nNatively Windows 10 has 2 primary ways to compress an image. Unfortunately both methods are limited to 1 at a time; no batch support.\n\nFirst, open the photo in the Windows 10 Photo app.\n• Once the photo is open in the Photos app, in the top right corner select the hotdog menu (the …), and then “resize”.\n\n2. Pick from the 3 strict options. Or the 4th “Custom” option that allows retaining the original height and width, and a JPEG quality slider that defaults to 80%.\n\n2. Once photo is open in MS Paint, simple select File -> Save as -> JPEG / PNG / ETC.\n\nI know I said only “native” solutions wanted to provide any Windows users with a batch option.\n\nThe site https://bulkresizephotos.com has a simple drag-n-drop option for batch photo optimization. It outputs a zip file with the compressed files.\n\nOverall when comparing the original image to the optimized images the perceived image quality drop is virtually non-existent.\n\nNote: The comparisons in this article aren’t entirely accurate as they are ultimately compressed by Medium. In a later article I’ll be showing the actual comparisons with original file sizes."
    },
    {
        "link": "https://imagekit.io/blog/image-compression-techniques-in-javascript",
        "document": "High-quality images go a long way in impressing your website visitors. However, they can slow down your website and hamper your user experience. So, it helps compress these images in file size to remain appealing to the users without hindering UX.\n\nImage compression can be done in two ways — lossy or lossless.\n\nLossy compression is where the original image file is removed and replaced with the compressed image file. Since the original image cannot be restored, it is also referred to as irreversible compression. However, if done correctly, the data loss is not usually noticeable.\n\nWhat is lossless image compression?\n\n\n\nOn the other hand, lossless compression does not lose data in the process. Instead, it “packs” the data into smaller sizes. Imagine writing a logo para in shorthand that a system can read and understand. Lossless compression is akin to that.\n\nLossless compression is favored for archiving purposes because it can retain the original asset without resulting in data loss. It is often used in medical imaging, technical drawings, clip art, comics, etc.\n\nIn addition to these techniques, you can compress images using JavaScript and dedicated tools.\n\nThis tutorial will look at compressing images using canvas, browser-image-compression JavaScript library, and ImageKit.‌‌\n\nWhy do you need image compression?\n\n\n\nThe most fundamental benefit of image compression is that it reduces file size. You can keep compressing the image until it's the size you want, depending on the sort of file you're squeezing.\n\nGoogle search engines use the loading speeds of online pages to rank web pages. As a result, the lower the image weight, the higher the web's score and the chances of scoring higher SERPs.\n\nUsing images that are less in weight will help the web load faster on mobile phones. Google does more weightage to websites that perform well on mobile devices.\n\nAlso, some web hosting firms also require compressed images to develop websites that load faster than their competitors.\n\nNow that we know the need for image compression let’s get cut to the chase on how to do it using Canvas.\n\n‌‌To get started, we'll need to set up our project.\n\nWe will run the command to start Visual Studio Code from the terminal.‌‌\n\nNote: If you don't have Visual Studio Code installed, you won't be able to use code command.\n\nUsing the command below, we'll create the script.js and index.html files.\n\nWe'll put the following snippet inside to make a simple HTML structure referencing the file we created earlier.‌‌\n\nWe'll add the code snippet below into to declare and , which we'll use to compute the image size uploaded later in the tutorial.\n\nWe can now read the file, utilize the callback to process and also create a helper image object using the blob URL as the image source, as shown below:\n\nWe need to create a function to handle image size calculation and read image bytes before calculating image size and creating a canvas for image compression.\n\nLet us add the snippet below to create the function.\n\nWe will also create a function with the snippet below:\n\nWe can now update the callback similar to the snippet shown below:\n\nNow, let’s head over to our browser to test the application. If everything is done right, we should have something similar to the screen below:\n\nAs shown above, we have the original image size on the left-hand side while the compressed image size is on the right-hand side. We have successfully compressed the image using the Canvas approach. You can test the same direction using this codepen link.\n\nBrowser-image-compression is a JS module used for image compression in web browsers. They aid in compressing jpeg and png images by reducing their resolution or file size before uploading them, which results in lesser bandwidth consumption.\n\nTo create a new project, we use the command to scaffold a new project in a directory of our choice.\n\nTo install the dependencies, we will be using the command below:\n\nWe'll get a message with instructions for browsing our site and running it locally once the app has been created and the dependencies have been installed. This is done using the command.\n\nReact.js will start a hot-reloading development environment accessible by default at http://localhost:3000.\n\nTo get started, we will update with the snippet below:\n\nWe should have something similar to what is shown below:\n\nLet us now implement the image compression process using the .\n\nUsing the snippet below, we will create different state variables and functions to handle image compression and file upload.\n\nIn the snippet above, we utilize the library to handle the compression and update our variable with the result. At the same time, we also set using the method.\n\nLet us update the component with the snippet below:\n\nWe called the method in the attribute of the input tag and the method in the attribute of the Compress button in the snippet above.\n\nWith all these settings in place, we can now test our application, and we should have something similar to what we have below.\n\nWe can also try out the demo via this code sandbox link.\n\nWe compressed the image using the Canvas method and the JavaScript library in the previous steps; however, using this strategy, the image was compressed at the expense of image quality, effect, and other criteria.\n\nTo compress our image flawlessly, we'll use ImageKit compression with its URL-based image transformations.\n\nImageKit is a cloud-based image compression and optimization tool. It can perform 50+ real-time image transformations that will help deliver a superior user experience to end users on the web and mobile apps.\n\nAlso, ImageKit’s image compression is not browser or canvas based but instead based on a no-code cloud-hosted solution far superior in performance and capabilities than browser-based image compression tools. \n\n\n\nIn other words, non-technical users like designers and marketers can transform images easily without writing a single line of code.\n\nFurther, ImageKit can perform lossy compression compared to Canvas API without image resizing and automatic file format conversions. In other words, ImageKit is a powerful image transformation tool that does not require prior technical knowledge or new learning.\n\nLet’s understand how image transformations in ImageKit work with the help of an image. In the following sections, you will see how the original image can be transformed in several ways.\n\nThe expression below shows how the transformation works using the ImageKit URL.\n\nIn the following sections, we will demonstrate how ImageKit's image transformation capabilities can be used for specific business use cases using the below sample image.\n\nOne of the common transformations that developers require while using images on their website is the manipulation of the height and width of an image.\n\nHowever, exchanging images between designers and end-users (like marketers) is extremely difficult. Most often, files get replaced resulting in the wrong file being worked upon. This probability for confusion and errors can be avoided with the help of URL-based resizing.\n\nURL-based resizing allows you to change the size of the image by simply altering the height/width of the URL.\n\nAs shown below, we can scale the image width to any desired size by changing the URL's input. We will adjust the image's width to 200px from the URL in this example.\n\nSome of the CMS platforms or social media media channels require the image to have a specific width. If your raw image is not of the stipulated width, you can resize it easily using ImageKit's URL-based resizing. No designer required. No coding required.\n\nSimilarly, in addition to the width, the height of the image can also be altered. It i spossible to alter only the width or height alone depending on the requirement.\n• Resizing the image using the Aspect ratio\n\nIn addition to height and width, you can also change the image's aspect ratio. Aspect ratio of an image can be defined as the ratio of its width to its height, and is denoted like a mathematical ratio, two numberals separated by a coloon. For example: 4:3 is a popular aspect ratio for images.\n\nThis is typically useful when the image has to be resized across several social media platforms with varying image size requirements.\n\nAs illustrated in the steps above, we could adequately resize the image to our desired size. Check out ImageKit docs to know more aboutImageKit’s image transformation features.\n\nDynamic resizing refers to performing basix the image resizing as well as some additional transformations like cropping & preserving the aspect ration, adding a text overlay or watermark, adding a padding using a specific color, etc.\n\nLet's see how to use URL parameters to resize and modify images to fit the website layout dynamically.\n\nFor adding a padding to our image with the color FF0000 without cropping the image, we add a simple URl parameter to insert a padding with a width of 400px and a height of 300px.\n\nThere could be times when you want to convey textual information on top of the image to educate the user or to provide context. Alternatively, you may want to add a watermark text to protect the asset from unauthorized usage. This could be a logo, your business name, or even generic text like 'copyright protected' or 'confidential'.\n\nYou can dynamically put text overlay on images to display any text on the image to achieve the above-mentioned purposes.\n\n\n\nThe perceived visual quality of an image is referred to as image quality. ImageKit rates image quality on a scale of one to ten, with ten being the highest and one being the worst. This section will show how we can easily control image quality.\n\nThere are two methods for controlling image quality: utilizing the URL parameter and using Image Quality from the dashboard.\n\nThere are some default quality settings in ImageKit which you mightant to change change to better suit your needs.\n\nUsing the parameter to override the default quality setting specified within the ImageKit dashboard.\n\nThese are some use cases of image compression/optimization in ImageKit. There are still more variants that you may try to suit your purpose.\n\n\n\nImageKit is a one-stop facility for all your image processing requirements. As we've seen so far in this tutorial, there are several ways to compress an image, including utilizing the canvas method and the JavaScript library, both of which are inefficient and inconvenient compared to the ImageKit transformation approach. This section will go through some of the other cool features we get out of the box when using the ImageKIt transformation approach.\n\nBringing it all together\n\n\n\nWhile JavaScript is fast, flexible, and simple, it requires some technical expertise to perform the transformation. If your business deals with many images regularly, you will have to deal with image compression from time to time. However, most free online image compression tools do not meet your requirements. When compressing images without losing quality, an image CDN like ImageKit.io is necessary.\n\nWant to see how ImageKit works?\n\nSign up for a free trial. It is free until you are ready to upgrade."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Performance/Multimedia",
        "document": "One of the biggest improvements to most websites is lazy-loading images beneath the fold, rather than downloading them all on initial page load regardless of whether a visitor scrolls to see them or not. Browsers provide this natively via the attribute on the element, and there are also many client-side JavaScript libraries that can do this.\n\nBeyond loading a subset of images, you should look into the format of the images themselves:\n• Are you loading the most optimal file formats?\n• Have you compressed the images well?\n• Are you loading the correct sizes?\n\nThe optimal file format typically depends on the character of the image.\n\nThe SVG format is more appropriate for images that have few colors and that are not photo-realistic. This requires the source to be available as in a vector graphic format. Should such an image only exist as a bitmap, then PNG would be the fallback format to choose. Examples of these types of motifs are logos, illustrations, charts, or icons (note: SVGs are far better than icon fonts!). Both formats support transparency.\n\nPNGs can be saved with three different output combinations:\n• 24-bit color + 8-bit transparency — offer full-color accuracy and smooth transparency at the expense of size. You probably want to avoid this combination in favor of WebP (see below).\n• 8-bit color + 8-bit transparency — offer no more than 255 colors but maintain smooth transparencies. The size is not too big. Those are the PNGs you would probably want.\n• 8-bit color + 1-bit transparency — offer no more than 255 colors and just offer no or full transparency per pixel which makes the transparency borders appear hard and jagged. The size is small but the price is visual fidelity.\n\nA good online tool for optimizing SVGs is SVGOMG. For PNGs there is ImageOptim online or Squoosh.\n\nWith photographic motifs that do not feature transparency, there is a much wider range of formats to choose from. If you want to play it safe, then you would go for well-compressed Progressive JPEGs. Progressive JPEGs, in contrast to normal JPEGs, render progressively (hence the name), meaning the user sees a low-resolution version that gains clarity as the image downloads, rather than the image loading at full resolution top-to-bottom or even only rendering once completely downloaded. A good compressor for these would be MozJPEG, e.g. available to use in the online image optimization tool Squoosh. A quality setting of 75% should yield decent results.\n\nOther formats improve on JPEG's capabilities regarding compression, but are not available on every browser:\n• WebP — Excellent choice for both images and animated images. WebP offers much better compression than PNG or JPEG with support for higher color depths, animated frames, transparency, etc. (but not progressive display.). Supported by all major browsers except Safari 14 on macOS desktop Big Sur or earlier. Note: Despite Apple announcing support for WebP in Safari 14, Safari versions earlier than 16.0 don't display images successfully on macOS desktop versions earlier than 11/Big Sur. Safari for iOS 14 does display images successfully.\n• AVIF — Good choice for both images and animated images due to high performance and royalty-free image format (even more efficient than WebP, but not as widely supported). It is now supported on Chrome, Edge, Opera, and Firefox. Squoosh is a good online tool for converting previous image formats to AVIF.\n• JPEG2000 — once to be the successor to JPEG but only supported in Safari. Doesn't support progressive display either.\n\nGiven the narrow support for JPEG-XR and JPEG2000, and also taking decode costs into the equation, the only serious contender for JPEG is WebP. Which is why you could offer your images in that flavor too. This can be done via the element with the help of a element equipped with a type attribute.\n\nIf all of this sounds a bit complicated or feels like too much work for your team then there are also online services that you can use as image CDNs that will automate the serving of the correct image format on the fly, according to the type of device or browser requesting the image. Popular choices include Cloudinary, Image Engine, ImageKit, and imgix.\n\nFinally, should you want to include animated images on your page, then know that Safari allows the use of video files within and elements. These also allow you to add in an Animated WebP for all other modern browsers.\n\nIn image delivery the \"one size fits all\" approach will not yield the best results, meaning that for smaller screens you would want to serve images with smaller resolution and vice versa for larger screens. On top of that, you'd also want to serve higher resolution images to those devices that boast a high DPI screen (e.g. \"Retina\"). So apart from creating plenty of intermediate image variants you also need a way to serve the right file to the right browser. That's where you would need to upgrade your and elements with media and/or sizes attributes. A detailed article on how to combine all of these attributes can be found here.\n\nTwo interesting effects to keep in mind regarding high dpi screens is that:\n• with a high DPI screen, humans will spot compression artifacts a lot later, meaning that for images meant for these screens you can crank up compression beyond usual.\n• Only a very few people can spot an increase in resolution beyond 2× DPI, which means you don't need to serve images resolving higher than 2×.\n\nControlling the priority (and ordering) of downloading images\n\nGetting the most important images in front of visitors sooner than the less important can deliver improved perceived performance.\n\nThe first thing to check is that your content images use or elements and your background images are defined in CSS with — images referenced in elements are assigned a higher loading priority than background images.\n\nSecondly, with the adoption of Priority Hints, you can control the priority further by adding a attribute to your image tags. An example use case for priority hints on images are carousels where the first image is a higher priority than the subsequent images."
    }
]