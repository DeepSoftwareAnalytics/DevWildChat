[
    {
        "link": "https://en.esotericsoftware.com/forum/d/5288-how-to-change-order-in-layer-in-code",
        "document": "Hi, I'm new to spine & unity. And I'm actually working on my first unity project.\n\nI've searched the forum, but can not find any answer.\n\nSkeleton Animation has properties of \"Sorting Layer\" & \"Order in Layer\" in the Inspector. But I'd like to change \"Order in Layer\" in code, depending on its y position. I just want to know how to reference to \"Order in Layer\" property, thanks!"
    },
    {
        "link": "http://en.esotericsoftware.com/spine-unity-main-components",
        "document": "The spine-unity runtime provides you with a set of components that allow to display, animate, follow and modify skeletons exported from Spine. These components reference skeleton data and texture atlas assets you import as described in the Assets section.\n\nTo quickly display a Spine skeleton in your Unity project:\n• Import the skeleton data and texture atlas as described in the Assets section.\n• Drag the _SkeletonData asset into the Scene view or the Hierarchy panel and choose . A new GameObject will be instantiated, with the required Spine components already set up.\n\nYou can now use the components' C# API to animate the skeleton, react to events triggered by animations, etc. Refer to the component documentation below for more details.\n\nInstantiating a skeleton as SkeletonAnimation is the recommended way to use a Spine skeleton in Unity, as it provides the most complete feature set of the three alternatives.\n\nThe three alternatives to instantiate a skeleton are:\n• SkeletonAnimation - Uses Spine's custom animation and event system, providing highest customizability. Renders using a , interacting with masks such as like a Unity sprite. The recommended way of using a Spine skeleton in Unity.\n• SkeletonGraphic (UI) - For use as UI element together with a Unity . Renders and interacts with UI masks such as like the built-in Unity UI elements. Animation and event behavior is identical to SkeletonAnimation.\n• SkeletonMecanim - Uses Unity's Mecanim animation and event system for starting, mixing and transitioning between animations. Provides fewer animation mixing and transition options than SkeletonAnimation. When using it will not be guaranteed that transitions will look as previewed in the Spine Editor.\n\nWhile it's not the recommended workflow, the spine-unity API allows you to instantiate and GameObjects at runtime from a , or even directly from the three exported assets. Instantiation directly from the exported assets is only recommended if you can't use the normal Unity import pipeline to automatically create and assets beforehand.\n\nYou can examine the example scene and the used example scripts , and for additional information.\n\nThe component is one of three ways to use a Spine skeleton in Unity. These alternatives are: SkeletonAnimation, SkeletonMecanim and SkeletonGraphic (UI).\n\nThe SkeletonAnimation component is the heart of the spine-unity runtime. It allows you to add a Spine skeleton to a GameObject, animate it, react to animation events, and so on.\n\nA SkeletonAnimation component requires a reference to a skeleton data asset from which it can get the information about a skeleton's bone hierarchy, slots etc.\n\nIf you have added a skeleton to a scene via drag and drop, the skeleton data asset is automatically assigned. In case you have an already set up GameObject and suddenly want to change the skeleton to a different asset, you can manually change it via the provided Inspector property.\n\nTo set or change the skeleton data\n• Assign a _SkeletonData asset at the property in the Inspector.\n\nThe SkeletonAnimation Inspector exposes the following parameters\n• Initial Skin. This skin will be assigned upon start. Note: In case you only see bones of a skeleton without any images attached, you might want to switch to a skin other than to show your skin.\n• Animation Name. This animation will be played upon start.\n• Loop. Defines whether the initial animation shall be looped or played only once.\n• Time Scale. You can set the time scale to slow down or speed up playback of animations.\n• Unscaled Time. When set to , updates will be performed according to Time.unscaledDeltaTime instead of Time.deltaTime. This is useful to animate UI elements independently of slow-motion effects.\n\nRoot motion for and SkeletonGraphic (UI) components is provided via a separate SkeletonRootMotion component. The Inspector provides a button to quickly add the suitable component to your skeleton GameObject.\n\nUnfold the section in the SkeletonAnimation Inspector to show advanced configuration parameters.\n\nThe SkeletonAnimation Inspector exposes the following advanced parameters\n• Initial Flip X, Initial Flip Y. These parameters allow you to flip the skeleton horizontally and vertically upon start. This will set ScaleX and ScaleY to -1 where flipped.\n• Animation Update. Whether to update the animation in normal (the default), physics step , or manually via a user call. When using a SkeletonRootMotion component with a or assigned, it is recommended to set the update mode to . Otherwise is recommended.\n• Update When Invisible. Update mode used when the MeshRenderer becomes invisible. Update mode is automatically reset to when the mesh becomes visible again.\n• Use single submesh. Can be enabled to simplify submesh generation by assuming you are only using one Material and need only one submesh. This is will disable multiple materials, render separation, and custom slot materials.\n• Fix Draw Order. Applies only when 3+ submeshes are used (2+ materials with alternating order, e.g. \"A B A\"). If true, MaterialPropertyBlocks are assigned at each material to prevent aggressive batching of submeshes by e.g. the LWRP renderer, leading to incorrect draw order (e.g. \"A1 B A2\" changed to \"A1A2 B\"). You can leave this parameter disabled when everything is drawn correctly to save the additional performance cost.\n• Immutable triangles. Can be enabled to optimize rendering for skeletons that never change attachment visbility. If true, triangles will not be updated. Enable this as an optimization if the skeleton does not make use of attachment swapping or hiding, or draw order keys. Otherwise, setting this to false may cause errors in rendering.\n• Clear State on Disable. Clears the state of the render and skeleton when this component or its GameObject is disabled. This prevents previous state from being retained when it is enabled again. When pooling your skeleton, setting this to true can be helpful.\n• Fix Prefab Override MeshFilter. Fixes the prefab always being marked as changed (sets the hide flags to ), but at the cost of references to the by other components being lost. When set to , the setting in Spine Preferences is used.\n• Separator Slot Names. Slots that determine where the render is split. This is used by components such as so that the skeleton can be rendered by two separate renderers on different GameObjects.\n• Z-Spacing. Attachments are rendered back to front in the x/y plane by the skeleton renderer component. Each attachment is offset by a customizable z-spacing value on the z-axis to avoid z-fighting.\n• PMA Vertex Colors. Multiply vertex color RGB with vertex color alpha. Enable this parameter if the shader used for rendering is a Spine shader (even with ) or a thirdparty shader which uses PMA additive blend mode . Disable this parameter for normal shaders with regular blend mode . When enabled, additive slots can be rendered in a single draw call together with normal slots. When disabled, additive slots require Blend Mode Materials - Apply Additive Material enabled, leading to a separate draw call, which may adversely affect performance.\n• Tint Black (!). Adds black tint vertex data to the mesh. Enable if the skeleton has any slots with tint black color set.\n\n Black tinting requires that the shader interprets UV2 and UV3 as black tint colors for this effect to work. You may use the included shader. If you only need to tint the whole skeleton and not individual parts, the shader is recommended for better efficiency and changing/animating the material property via MaterialPropertyBlock. See section Shaders for additional information. To retain batching while tinting multiple skeletons differently, tinting via Skeleton.R .G .B .A is recommended.\n• Add Normals. When enabled, the mesh generator adds normals to the output mesh. Enable if your shader requires vertex normals. For better performance and reduced memory usage, you can instead use a shader such as the shader that assumes the desired normal. Note that the shaders can be configured to assume a as well.\n• Solve Tangents. Some lit shaders require vertex tangents, usually for applying normal maps. When enabled, tangents are calculated every frame and added to the output mesh.\n• Physics Inheritance. Controls how Transform movement is applied to PhysicsConstraints of the skeleton.\n• Position. When set to non-zero, Transform position movement in X and Y direction is applied to skeleton PhysicsConstraints, multiplied by these X and Y scale factors. Typical (X,Y) values are:\n\n (1,1) to apply XY movement normally,\n\n (2,2) to apply movement with double intensity,\n\n (1,0) to apply only horizontal movement, or\n\n (0,0) to not apply any Transform position movement at all.\n• Rotation. When set to non-zero, Transform rotation movement is applied to skeleton PhysicsConstraints, multiplied by this scale factor. Typical values are:\n\n 1 to apply movement normally,\n\n 2 to apply movement with double intensity, or\n\n 0 to not apply any Transform rotation movement at all.\n• Movement relative to. To apply Transform movement relative to e.g. a parent Transform, set this to the reference Transform relative to which movement shall be calculated. Set this to None to use the absolute world location (the default).\n• Add Skeleton Utility. This button can be used to quickly add a component to the GameObject for tracking or overriding bone positions. See SkeletonUtility for further info.\n• Debug. Sometimes you may want to know the current color of a slot or scale of a bone while the game is running. Pressing the Debug button opens the Skeleton Debug window which was created for this purpose. It allows you to inspect the current state of bones, slots, constraints, draw order, events and statistical information about your skeleton.\n\n\n\n In the SkeletonAnimation component, AnimationState holds the state of all currently playing and queued animations. Every , the AnimationState is updated so that the animations progress forward in time. Then the new frame is applied to the Skeleton as a new pose.\n\nInteracting with a skeleton via code requires accessing the SkeletonAnimation component. As applies to Unity components in general, it is recommended to query the reference once and store it for further use.\n\nYour scripts may run before or after SkeletonAnimation's . If your code takes Skeleton or bone values before SkeletonAnimation's Update, your code will read values from the previous frame instead of the current one.\n\nThe component exposes the event callback delegates as properties that allow you to intercept this life-cycle before and after the world transforms of all bones are calculated. You can bind to these delegates to modify bone positions and other aspects of the skeleton without having to care for the update order of your actors and components.\n• is raised before the animations for the frame are applied. Use this callback when you want to change the skeleton state before animations are applied on top.\n• is raised after the animations for the frame are updated and applied to the skeleton's local values. Use this if you need to read or modify bone local values.\n• is raised after world values are calculated for all bones in the Skeleton. SkeletonAnimation makes no further operations in Update after this. Use this if you only need to read bone world values. Those values may still change if any of your scripts modify them after SkeletonAnimation's Update.\n• is raised after the world values are calculated for all the bones in the Skeleton. If you subscribe to this event, it will call a second time. Depending on the complexity of your skeleton or what you are doing, this may be unnecessary, or wasteful. Use this event if you need to modify bone local values based on bone world values. This is useful for implementing custom constraints in Unity code.\n• is raised after the Skeleton is successfully initialized.\n• is raised at the end of after the Mesh and all materials have been updated.\n\nAs an alternative, you can change Script Execution Order to run after SkeletonAnimation's Update method.\n\nIn Unity, each component's and calls are ordered according to script execution order (see ExecutionOrder and for details). When issuing calls from your own component's or methods that modify skeleton or animation state, it is important to execute at the right time relative to the SkeletonAnimation component.\n\nThe update sequence of SkeletonAnimation is as follows:\n• To run before animations are applied, issue the call from and set execution order to before SkeletonAnimation.\n• To run after animations are applied and before the skeleton mesh is generated, issue the call from and set execution order to after SkeletonAnimation. Alternatively issue the call from and set execution order to before SkeletonAnimation.\n\nIf you can't change the update order of your script executing too late, you can perform manual updates as described in Manual Updates to still update the skeleton or skeleton mesh within the same frame.\n\nAfter certain modifications it may be desired to immediately re-apply animations to your skeleton, or re-generate the skeleton mesh based on the modified skeleton. Compared to the generic runtime, the SkeletonAnimation component provides additional methods allowing consistent updates with a single method call. For example, is called as part of and listed below.\n• for a full skeleton update. The skeleton mesh remains unchanged.\n\n updates the underlying , forwards this frame's Transform movement to physics constraints and applies the animations to the skeleton, followed by updating all bone's world transforms. This may be necessary when you need to perform a full skeleton update without advancing time, or if you want to advance by a custom delta-time.\n• to re-apply animations to the skeleton.\n\n similarly re-applies the animations to the skeleton, but without updating the underlying or forwarding Transform movement to physics constraints.\n• to update the skeleton mesh to the skeleton state.\n\n (similar to but ignores ) updates the skeleton mesh based on the skeleton. This may be necessary when modifying skeleton properties in and script execution order executes your script too late, after has already updated the skeleton mesh for this frame.\n\nThe SkeletonAnimation component provides access to the underlying skeleton via the property. A Skeleton stores a reference to a skeleton data asset, which in turn references one or more atlas assets.\n\nThe Skeleton allows you to set skins, attachments, reset bones to setup pose and scale and flip the whole skeleton.\n\nTo set an attachment, provide the slot and attachment name.\n\nNote that and in the above code are String Property Attributes described in this section.\n\nFor procedural animation it is sometimes necessary to reset bones and/or slots to their setup pose. After setting skins you likely want to call as described in section Setting Skins below.\n\nA Spine skeleton may have multiple skins that define which attachment goes on which slot. The skeleton component provides a simple way to switch between skins.\n\nYou likely want to call after changing skins if you don't want previously set attachments to affect the visibility of your current attachments. See the documentation here for details.\n\nSpine skins can be combined to e.g. form a complete character skin from single cloth item skins. See the new Skin API documentation for more details.\n\nWhile combining skins, multiple materials may be accumulated. This leads to additional draw calls. The method can be used to combine used texture regions of a collected skin to a single texture at runtime.\n\nYou can examine the example scenes and and the used example script for further insights.\n\nYou can also repack normal maps and other additional texture layers alongside the main texture. Pass as parameter to to repack both the main texture and the normal map layer.\n\nFlipping a skeleton vertically or horizontally allows you to reuse animations, e.g. a walk animation facing left can be played back to face right.\n\nThe Skeleton lets you set and get bone transform values so you can implement IK terrain following or let other actors and components such as particle systems follow the bones in your skeleton.\n\nThe SkeletonAnimation component implements the method in which it updates the underlying AnimationState based on the delta time, forwards transform movement to skeleton physics, applies the to the skeleton, and updates the world transforms of all bones of the skeleton.\n\nThe skeleton animation component exposes the AnimationState API via the property. This section assumes a familiarity with concepts like tracks, track entries, mix times, or animation queuing as described in the section Applying Animations in the generic Spine Runtime Guide.\n\nYou can set the time scale of the skeleton animation component to slow down or speed up the playback of animations. The delta time used to advance animations is simply multiplied with the time scale, e.g. a time scale of 0.5 slows the animation down to half the normal speed, a time scale of 2 speeds it up to twice the normal speed.\n\nTo set an animation, provide the track index, animation name and whether to loop the animation.\n\nAs an alternative, you can use an AnimationReferenceAsset instead of a string as parameter.\n\nTo queue an animation, provide the track index, animation name, whether to loop the animation, and the delay after which this animation should start playing on the track in seconds.\n\nThe skeleton animation component also provides methods to set an empty animation, queue an empty animation, or clear one or all tracks. All of these work analogous to the methods and nodes shown above.\n\nYou'll receive a TrackEntry from all the methods that allows you to further customize the playback of this specific animation, as well as bind to delegates of track entry specific events. See the section Processing AnimationState Events below.\n\nWhile animations are played back by the underlying , various events will be emitted that notify listeners that\n• An animation was interrupted, e.g. by clearing a track or setting a new animation.\n• An animation was completed without interruption, which may occur multiple times if looped.\n• An animation and its corresponding have been disposed.\n\nThe skeleton animation component provides delegates to which C# code can bind in order to react to these events for all queued animations on all tracks. Listeners can also be bound to the corresponding delegates of a specific only. So you can register to e.g. to handle event callbacks for any future animation event, or instead register to a single event to handle events issued by a single specific enqueued animation.\n\nIn the class that should react to events, add delegates for the events you want to listen to:\n\nSee the Spine API Reference for detailled information.\n\nWhile you can modify by e.g. calling from within an event callback, there are some potential timing issues to consider. This also applies when changing your game state from an event callback.\n• event callbacks are issued when animations are applied in , before the mesh is updated in .\n• If you call from the callback, it will trigger an event in the same frame. Because of mix transitions from one animation to another, the event of your second animation is issued before the event of your first animation. This is a common pitfall to consider when modifying game state.\n\nIf you need to delay calls from within an event callback to the next cycle, you could use as follows:\n\nThe spine-unity runtime provides a set of yield instructions for use with Unity's Coroutines. If you are new to Unity Coroutines, the Coroutine tutorials and Coroutine documentation are a good place to start.\n\nThe following yield instructions are provided:\n• WaitForSpineAnimation. Waits until a raises one of the specified events.\n• yield return new WaitForSpineEvent(skeletonAnimation.state, \"spawn bullet\");\n\n // You can also pass a Spine.Event's Spine.EventData reference.\n\n Spine.EventData spawnBulletEvent; // cached in e.g. Start()\n\n ..\n\n yield return new WaitForSpineEvent(skeletonAnimation.state, spawnBulletEvent);\n\nYou can find a tutorial page on spine-unity events here.\n\nIt is not convenient to type e.g. animation names manually in the Inspector. Thus spine-unity provides popup fields for string parameters instead. You can precede a property with one of the following property attributes to automatically receive a popup selection field, populated with e.g. all available animations at a skeleton. If you can see such popup fields in one of the provided Spine components, you can also use the same popup via property attributes in your custom components. The following list shows available property attributes.\n\nPlease take a look at the example scenes that come with the spine-unity package to see the string property attributes in use.\n\nThe component is one of three ways to use a Spine skeleton in Unity. These alternatives are: SkeletonAnimation, SkeletonMecanim and SkeletonGraphic (UI).\n\nThe component is an alternative to the SkeletonAnimation component, using Unity's Mecanim animation system for high-level control in combination with the Spine animation system for posing and setup of the skeleton. The Mecanim system is used to determine which Spine animations shall be played back and determines track time and alpha of each animation. The respective Spine animations are then applied to the Spine skeleton by the component.\n\nLike the SkeletonAnimation component, allows you to add a Spine skeleton to a GameObject, animate it, react to animation events, and so on. After the animations are applied, before the skeleton is drawn, you can make changes to the skeleton just like you can when using SkeletonAnimation instead of SkeletonMecanim. In comparison to SkeletonAnimation it comes with some limitations and additional requirements:\n\nThe component provides similar parameters as the SkeletonAnimation component, please consult the SkeletonAnimation section for additional information.\n\nTo smoothly mix out a timeline state (e.g. bone rotation) from one animation to the next, the second animation requires an additional key at the first frame when in setup pose. Otherwise the previous animation would leave a leftover timeline state. This is one of the drawbacks of compared to SkeletonAnimation.\n\nThe parameter resets the state, but will mix out sharply at the end of an animation transition, not creating a smooth transition.\n\nAlso be sure to disable upon exporting your skeleton as or , otherwise keys identical to setup pose will not be exported!\n\nThe Inspector exposes the following additional parameters:\n• \n• Auto Reset. When set to , the skeleton state is mixed out to setup pose when an animation finishes, according to the animation's keyed items. This may be especially important when an animation has changed attachment visibility state: when mixed out, attachment visibility will change back to setup pose state, otherwise current attachment state is held until another animation has a key set at the respective attachment timeline.\n• Custom MixMode. When disabled, the recommended is used according to the layer blend mode. When enabled, a section is shown below allowing you to specify a for each Mecanim layer.\n• Mix Modes. Shown when parameter above is enabled. This parameter determines the animation mix mode between successive animations, and also across layers.\n• Mix Next (recommended for and layers)\n\n Applies the previous track and then mixes in the next track on top using Mecanim transition weights.\n• Always Mix (recommended for layers)\n\n Fades out the previous track (potentially to setup pose when is enabled), and mixes in the next track on top using Mecanim transition weights. Note that this may cause an unintended animation dipping effect when used on the base layer.\n• Match (new in 4.2, recommended on any layer using blend tree nodes)\n\n Calculates Spine animation weights to best match the provided Mecanim clip weights.\n\nWhen a transition is active, there are four poses - , the , and - which will be combined as follows:\n• Starts with (or other modifications this frame prior to SkeletonMecanim's update).\n• Apply :\n• When is enabled, the replaces the .\n• When is disabled, is not part of the mix.\n• Apply :\n• When mode is set to , the is mixed with the current state (so mixed with when is enabled).\n• When set to or , the is applied with full weight, overriding the current state (thus overriding ).\n• Apply :\n• When mode is set to or , the is mixed with the current state. So at with enabled it is a mix of , and .\n• When mode is set to , the is applied with full weight, overriding all previously applied poses.\n\nThe table below shows the case when both previous clip and new clip modify the same timeline value, e.g. the same bone rotation. represents the setup pose when is enabled, and the current state (e.g. of the previous frame) if disabled. Transition weight (0 at transition start, 1 at transition end) is represented by the variable . The default (recommended) mix mode at each layer blend mode is highlighted in bold.\n\nThe component uses the Controller asset assigned at the component as usual with Unity Mecanim. The Controller asset is automatically generated and assigned when instantiating a skeleton as via drag and drop.\n\nYou can add animations to the Controller's animation state machine via drag and drop of Spine animations to the Animator panel as usual. The animations can be found below the Controller asset.\n\nMix duration values set at the SkeletonDataAsset will be ignored by . Instead, Mecanim transition times are used as setup via the Animator panel.\n\nWhen using , events are stored in each and are raised like other Unity animation events. For example, if you named your event in Spine, you need to provide a script on your GameObject with a method named to handle it. When using folders in Spine, the method name will be a concatenation of the folder name and the animation name. For example when the previous event is placed in a folder named it will be .\n\nFor more information on Unity Mecanim events, see Unity's Documentation on Animation Events.\n\nThe component is one of three ways to use a Spine skeleton in Unity. These alternatives are: SkeletonAnimation, SkeletonMecanim and SkeletonGraphic (UI).\n\nThe component is an alternative to the SkeletonAnimation component, using Unity's UI system for layout, rendering and mask interaction. As the SkeletonAnimation component, it allows you to add a Spine skeleton to a GameObject, animate it, react to animation events, and so on.\n\nThe Unity UI (UnityEngine.UI) uses a system of and to sort and manage its renderable objects. Built-in renderable UI components such as , , and , rely on to function correctly. Putting objects like (e.g. a default Cube object), or (e.g. a Sprite) under a UI will not render in a . uses a and thus behaves in the same way. The spine-unity runtime therefore provides the variant , a subclass of using components for rendering.\n\nOnly use Materials with special compatible shaders at components, such as the shaders which are assigned by default. Do not use URP, LWRP or normal shaders like with a component. Seeing no visual error does not mean that the shader works with . We have seen cases where it renders incorrectly on target mobile devices while rendering without any issues in the Unity Editor. As other UI components, uses a instead of a , which uses a separate rendering pipeline.\n\nNormal Materials assigned at a are ignored when instantiating a as , only the Textures are used. You can use a SkeletonGraphicCustomMaterials component to override Materials at a component.\n\nUsing special shaders like or using below a CanvasGroup requires vertex data to be generated accordingly. You can find the relevant parameters in the Inspector section. The settings are , and . We have provided buttons next to each property which automatically derives the correct settings. There is also a button which detects settings for all three properties.\n\nAfter modifying settings, the used materials need to be updated to fit the active settings. At , materials are independent of textures, and can thus be shared across different skeletons which use the same material properties. For this reason, special shared SkeletonGraphic materials are provided for the main parameter and shader combinations. The suitable material can be assigned automatically according to the chosen settings via the available button next to the property.\n\nWhen the skeleton uses multiple blend modes and has enabled, you can use the button next to to automatically assign the suitable blend mode materials in a similar way.\n\nIf you receive incorrect results, likely your atlas texture's import settings are incorrect (see the documentation here).\n\nWhen using shaders with a , you will notice the skeleton becoming brighter when reducing the value, as can be seen in the image below.\n\nThis is due to Unity modifying the vertex color alpha value behind the scenes, which unfortunately does not play well with the premultiplied-alpha vertex color shaders of the spine-unity runtime.\n\nThe following applies When using a material with the shaders except for . If you use such a material below a with alpha fadeout, the material must have the parameter enabled and the SkeletonGraphic component disabled:\n• a) With version 4.2 and newer of the spine-unity runtime, you can find a variant of each material in the folders and respectively.\n\n b) On older versions, best create a copy of the shared material and rename it to e.g. instead of modifying the original material. Note that this shared SkeletonGraphic material needs to be created only once, it can be used with different skeletons as it is independent of the used texture.\n• Assign this material at any components below a instead of the original material.\n• Any component using this compatible material needs to also have disabled to avoid a double-darkening effect of semi-transparent parts. This unfortunately prevents rendering of additive slots in a single batch together with normal slots and may thus increase the number of draw calls.\n\nWhen using a material with the shader below a with alpha fadeout, the following setup is required:\n• a) As above, with spine-unity version 4.2 and newer, use the provided materials within the folder, or\n\n b) on older versions create a copy of the shared material and rename it to e.g. instead of modifying the original material. Note that this shared SkeletonGraphic material needs to be created only once, it can be used with different skeletons as it is independent of the used texture.\n• Assign this material at the component instead of the original material.\n• Enable at the component\n\n ( on version 4.1 or older).\n• a) When using spine-unity 4.2 or newer, both enabled and disabled settings are supported. It is recommended to keep enabled to benefit from rendering additive slots in a single draw call.\n\n b) On older versions, disable to avoid a double-darkening effect of semi-transparent additive slots.\n\nVisibility of a is determined via its RectTransform bounds. When a Skeleton is instantiated via drag-and-drop as a child of a GameObject, the RectTransform bounds are automatically matched to the initial pose. You can also manually fit the RectTransform to its current pose's dimensions by clicking the button. It is important that the RectTransform bounds are not smaller than the mesh, otherwise e.g. a will omit drawing the skeleton as soon as the RectTransform is completely outside, even when part of the mesh is still inside and should be rendered. The current RectTransform bounds are shown in Scene view when the RectTransform Tool of the five Transform modes is active.\n\nprovides similar parameters as the SkeletonAnimation component, please consult the SkeletonAnimation section for additional information.\n\nThe Inspector exposes the following additional parameters:\n• Material - Detect button. Assigns the suitable material, according to settings. Same as Detect Material parameter in the section below.\n• Freeze. When set to , the will no longer be updated.\n• Layout Scale Mode. supports automatic uniform scaling based on its bounds. Defaults to to keep previous behaviour. Automatic scaling can be enabled by setting this parameter to , , or (details can be found here). To modify the reference layout bounds, hit the toggle button to enter edit-mode, allowing you to adjust the bounds to your skeleton. The skeleton will be scaled accordingly to fit the reference layout bounds to the object's .\n• Edit Layout Bounds. To modify the reference layout bounds used by above, hit this toggle button to enter edit-mode. You can then adjust the bounds manually or hit to fit the current pose. When done adjusting, hit the toggle button again to exit edit-mode.\n• Match RectTransform with Mesh You can make a 's RectTransform fit its current pose's dimensions by clicking the button. It is important that the RectTransform bounds are not smaller than the mesh, otherwise e.g. a will omit drawing the skeleton as soon as the is outside, even when part of the mesh is still inside and should be rendered. This option is grayed-out unless is set to or the toggle button is set to edit-mode.\n• \n• Use Clipping. When set to , any Spine clipping attachments will be ignored.\n• Tint Black (!). Adds black tint vertex data to the mesh. Enable if the skeleton has any slots with tint black color set.\n\n Black tinting requires that the shader interprets UV2 and UV3 as black tint colors, such as the provided shaders.\n\n To allow UV2 and UV3 data at the parent Canvas, you need to select the Canvas and under enable and . A button is provided which enables this parameter if the SkeletonData contains any slot with tint black color set, and disables it otherwise.\n• CanvasGroup Compatible. Enable when SkeletonGraphic is used below a GameObject. The material also needs enabled, so assign the suitable material after changing this setting via or manually.\n\n When using a shader and both and are enabled, the alpha value will be stored at instead of at the primary vertex color , and stores constant to capture modifying . A button is provided which enables this parameter if the SkeletonGraphic component is located below a component in the hierarchy, and disables it otherwise.\n• [4.1 and older] Canvas Group Tint Black. Only enable when using a shader. Has no effect when is disabled or is disabled. Enable when using blend mode at a slot of under a . When enabled, the alpha value is stored at instead of primary vertex color , and stores constant to capture modifying .\n• PMA Vertex Colors (additional rules for CanvasGroup alpha apply). Multiply vertex color RGB with vertex color alpha. This parameter is enabled by default, which is the correct setting unless you are using thirdparty shaders or require enabled on a shader which is not . A button is provided, which requires and above to be setup correctly. disables this parameter if a thirdparty (non-Spine) shader is used, or if is enabled and disabled. It enables the parameter otherwise. The following detailed rules for PMA Vertex Color apply (only needed when fails): When using spine-unity 4.2 or newer:\n\n Enable this parameter (the default):\n• if is disabled at the used shader (even with enabled), or\n• if using a shader (even with enabled), or\n• if using a thirdparty (non-Spine) shader which requires vertex color as PMA (likely if the shader uses PMA additive output blend mode ).\n• if not using a shader but a normal shader which has enabled, or\n• if using a thirdparty (non-Spine) shader which requires regular vertex color (likely if the shader uses regular output blend mode ). When using spine-unity 4.1 or older:\n\n Enable this parameter (the default):\n• if is disabled at the used shader (even with enabled), or\n• if using a thirdparty (non-Spine) shader which requires vertex color as PMA (likely if the shader uses PMA additive output blend mode ).\n• if you're using a shader which has enabled, or\n• if using a thirdparty (non-Spine) shader which requires regular vertex color (likely if the shader uses regular output blend mode ). When enabled, additive slots can be rendered in a single draw call together with normal slots. When disabled, additive slots require Blend Mode Materials - Apply Additive Material enabled, leading to a separate draw call, which may adversely affect performance.\n• Detect Settings. Applies detection of , and parameters at once.\n• Detect Material. Assigns the suitable material based on the above and parameters and the atlas texture's import settings (PMA vs straight alpha settings). If you receive incorrect results, likely your texture settings are incorrect (see the documentation here).\n• Multiple CanvasRenderers. When set to , no longer uses a single but automatically creates the required number of child GameObjects for each required draw call (submesh). This can be used to raise the single texture limitation, but comes at an additional performance overhead.\n• Blend Mode Materials. Allows using different materials for each Slot blend mode. Use only or other compatible materials here.\n• Select to assign the default blend mode materials , and . Note: Be sure to have a proper setup of at the , as the blend mode material assignment relies on the materials. is ignored when is enabled.\n• Animation Update. Whether to update the animation in normal (the default), physics step , or manually via a user call. When using a SkeletonRootMotion component with a or assigned, it is recommended to set the update mode to . Otherwise is recommended.\n• Update When Invisible. Update mode used when the graphic is outside the bounds of a parent and thus invisible. Update mode is automatically reset to when it becomes visible again. Note: or normal components alone don't perform the required visibility tests, so please add a component where needed to update the required culling state.\n• Separator Slot Names. Slots that determine where the render is split when Enable Separation is set to . For general information on render separation, see section SkeletonRenderSeparator, but note that no additional components are required with .\n• Enable Separation. Render separation can be enabled directly in this Inspector section, it does not require any additional components (like or for components). When enabled, additional separation part GameObjects will be created automatically, and GameObjects re-parented to them accordingly. The separation part GameObjects can be moved around and re-parented in the hierarchy according to your requirements to achieve the desired draw order within your .\n• Update Part Location. When enabled, separator part GameObject location will be updated to match the position of the . This can be helpful when re-parenting parts to a different GameObject.\n• Physics Inheritance. Controls how Transform movement is applied to PhysicsConstraints of the skeleton.\n• Position. When set to non-zero, Transform position movement in X and Y direction is applied to skeleton PhysicsConstraints, multiplied by these X and Y scale factors. Typical (X,Y) values are:\n\n (1,1) to apply XY movement normally,\n\n (2,2) to apply movement with double intensity,\n\n (1,0) to apply only horizontal movement, or\n\n (0,0) to not apply any Transform position movement at all.\n• Rotation. When set to non-zero, Transform rotation movement is applied to skeleton PhysicsConstraints, multiplied by this scale factor. Typical values are:\n\n 1 to apply movement normally,\n\n 2 to apply movement with double intensity, or\n\n 0 to not apply any Transform rotation movement at all.\n• Movement relative to. To apply Transform movement relative to e.g. a parent Transform, set this to the reference Transform relative to which movement shall be calculated. Set this to None to use the absolute world location (the default).\n\nYou can examine the example scene Spine Examples/Getting Started/6 Skeleton Graphic for basic usage.\n\n An advanced example scene showing how to set up separator slots and modify draw order can be found at .\n\nThe component is responsible for drawing the current state of a skeleton. It is the base class for SkeletonAnimation and SkeletonMecanim.\n\nRendering is performed via a procedural mesh which is updated at a component. The component uses the texture atlas asset referenced by the SkeletonDataAsset to find the textures and materials needed to draw the attachments of the skeleton. Please consult the documentation section of SkeletonAnimation for additional information.\n\nYou can examine the example scene on how to use a component directly."
    },
    {
        "link": "https://github.com/EsotericSoftware/spine-runtimes/blob/4.2/spine-unity/Assets/Spine/Runtime/spine-unity/Components/SkeletonRenderSeparator/SkeletonRenderSeparator.cs",
        "document": "* Otherwise, it is permitted to integrate the Spine Runtimes into software or\n\n* \"Products\"), provided that each user of the Products must obtain their own\n\n* THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n\n* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n\n/// <summary>OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and\n\n/// <param name=\"addMinimumPartsRenderers\">If set to <c>true</c>, a minimum number of SkeletonPartsRenderer GameObjects (determined by separatorSlots.Count + 1) will be added.</param>\n\n\"Tried to add SkeletonRenderSeparator to a null SkeletonRenderer reference.\"\n\n// Not enough renderers. Skip the rest of the instructions."
    },
    {
        "link": "https://discussions.unity.com/t/working-with-spine-files-and-ui-toolkit/950186",
        "document": ""
    },
    {
        "link": "https://discussions.unity.com/t/spine-unity-change-animations/648740",
        "document": ""
    },
    {
        "link": "https://en.esotericsoftware.com/forum/d/7106-how-to-access-order-in-layer-in-spines-skeleton-animation",
        "document": "Hey all I just wanted to know how to access the 'Sorting Layer' and the 'Order in Layer' variables within a C# script.\n\nThanks to any who can lend a helping hand!\n\n -Spineman"
    },
    {
        "link": "https://en.esotericsoftware.com/forum/d/5288-how-to-change-order-in-layer-in-code",
        "document": "Hi, I'm new to spine & unity. And I'm actually working on my first unity project.\n\nI've searched the forum, but can not find any answer.\n\nSkeleton Animation has properties of \"Sorting Layer\" & \"Order in Layer\" in the Inspector. But I'd like to change \"Order in Layer\" in code, depending on its y position. I just want to know how to reference to \"Order in Layer\" property, thanks!"
    },
    {
        "link": "https://discussions.unity.com/t/accessing-order-in-layer/523160",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/Unity2D/comments/16cn1fr/can_you_dynamically_change_a_sprites_order_in",
        "document": "I have a 2D player prefab with several sprites, each with a pre-set order in layer. I wish to change this order for some of the sprites when the player turns around for example, but nothing seems to work. You can access the order in layer with , but trying to change it doesn't seem to have an effect. Even when trying to change it manually through the editor, it resets to it's original order in layer instantly. Is there a way to do it? These sorting layers seem much more elegant than using the z axis."
    },
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Renderer-sortingOrder.html",
        "document": "Suggest a change Thank you for helping us improve the quality of Unity Documentation. Although we cannot accept all submissions, we do read each suggested change from our users and will make updates where applicable. Close For some reason your suggested change could not be submitted. Please <a>try again</a> in a few minutes. And thank you for taking the time to help us improve the quality of Unity Documentation. Close\n\nYou can group GameObjects into layers in their SpriteRenderer component. This is called the SortingLayer. The sorting order decides what priority each GameObject has to the Renderer within each Sorting Layer. The lower the number you give it, the further back the GameObject appears. The higher the number, the closer the GameObject looks to the Camera. This is very effective when creating 2D scroller games, as you may want certain GameObjects on the same layer but certain parts to appear in front of others, for example, layering clouds and making them appear in front of the sky.\n\n\n\nNote: The value must be between -32768 and 32767."
    }
]