[
    {
        "link": "https://geeksforgeeks.org/python-3-input-function",
        "document": "In Python, we use the input() function to take input from the user. Whatever you enter as input, the input function converts it into a string. If you enter an integer value still input() function converts it into a string.\n\nIn this example, we are using input() function to input user data as a string in Python.\n\nIn this example, we are using the Python input() function to input user data as a string in Python, which takes input from the user and prints it.\n\nIn this example, we are taking input from the user and input user data as a string in Python with a prompt and printing it.\n\nIn this example, we are using the Python input() function which takes input from the user in string format converting it into an integer adding 1 to the integer, and printing it.\n\nIn this example, we are using the Python input() function which takes input from the user in string format converts it into float adds 1 to the float, and prints it.\n\nIn this example, we are taking input from the user in string format converting it into a list, and printing it.\n\nTake User Input for Tuples and Sets\n\nIn this example, we are taking input from the user in string format converting it into a tuple, and printing it.\n\nIn this example, we are taking the words separated by space to input user data as a string in Python, and we make a dictionary of the word as the key with their length as the value."
    },
    {
        "link": "https://docs.python.org/3/tutorial/inputoutput.html",
        "document": "There are several ways to present the output of a program; data can be printed in a human-readable form, or written to a file for future use. This chapter will discuss some of the possibilities.\n\nSo far we’ve encountered two ways of writing values: expression statements and the function. (A third way is using the method of file objects; the standard output file can be referenced as . See the Library Reference for more information on this.) Often you’ll want more control over the formatting of your output than simply printing space-separated values. There are several ways to format output.\n• None To use formatted string literals, begin a string with or before the opening quotation mark or triple quotation mark. Inside this string, you can write a Python expression between and characters that can refer to variables or literal values.\n• None The method of strings requires more manual effort. You’ll still use and to mark where a variable will be substituted and can provide detailed formatting directives, but you’ll also need to provide the information to be formatted. In the following code block there are two examples of how to format variables: Notice how the are padded with spaces and a negative sign only for negative numbers. The example also prints multiplied by 100, with 2 decimal places and followed by a percent sign (see Format Specification Mini-Language for details).\n• None Finally, you can do all the string handling yourself by using string slicing and concatenation operations to create any layout you can imagine. The string type has some methods that perform useful operations for padding strings to a given column width. When you don’t need fancy output but just want a quick display of some variables for debugging purposes, you can convert any value to a string with the or functions. The function is meant to return representations of values which are fairly human-readable, while is meant to generate representations which can be read by the interpreter (or will force a if there is no equivalent syntax). For objects which don’t have a particular representation for human consumption, will return the same value as . Many values, such as numbers or structures like lists and dictionaries, have the same representation using either function. Strings, in particular, have two distinct representations. The value of x is 32.5, and y is 40000... # The repr() of a string adds string quotes and backslashes: # The argument to repr() may be any Python object: The module contains a class that offers yet another way to substitute values into strings, using placeholders like and replacing them with values from a dictionary, but offers much less control of the formatting. Formatted string literals (also called f-strings for short) let you include the value of Python expressions inside a string by prefixing the string with or and writing expressions as . An optional format specifier can follow the expression. This allows greater control over how the value is formatted. The following example rounds pi to three places after the decimal: 'The value of pi is approximately The value of pi is approximately 3.142. Passing an integer after the will cause that field to be a minimum number of characters wide. This is useful for making columns line up. Other modifiers can be used to convert the value before it is formatted. applies , applies , and applies : 'My hovercraft is full of My hovercraft is full of eels. 'My hovercraft is full of My hovercraft is full of 'eels'. The specifier can be used to expand an expression to the text of the expression, an equal sign, then the representation of the evaluated expression: See self-documenting expressions for more information on the specifier. For a reference on these format specifications, see the reference guide for the Format Specification Mini-Language. Basic usage of the method looks like this: We are the knights who say \"Ni!\" The brackets and characters within them (called format fields) are replaced with the objects passed into the method. A number in the brackets can be used to refer to the position of the object passed into the method. If keyword arguments are used in the method, their values are referred to by using the name of the argument. Positional and keyword arguments can be arbitrarily combined: The story of Bill, Manfred, and Georg. If you have a really long format string that you don’t want to split up, it would be nice if you could reference the variables to be formatted by name instead of by position. This can be done by simply passing the dict and using square brackets to access the keys. This could also be done by passing the dictionary as keyword arguments with the notation. This is particularly useful in combination with the built-in function , which returns a dictionary containing all local variables: __name__: __main__; __doc__: None; __package__: None; __loader__: ... As an example, the following lines produce a tidily aligned set of columns giving integers and their squares and cubes: For a complete overview of string formatting with , see Format String Syntax. Here’s the same table of squares and cubes, formatted manually: # Note use of 'end' on previous line The method of string objects right-justifies a string in a field of a given width by padding it with spaces on the left. There are similar methods and . These methods do not write anything, they just return a new string. If the input string is too long, they don’t truncate it, but return it unchanged; this will mess up your column lay-out but that’s usually better than the alternative, which would be lying about a value. (If you really want truncation you can always add a slice operation, as in .) There is another method, , which pads a numeric string on the left with zeros. It understands about plus and minus signs: The % operator (modulo) can also be used for string formatting. Given (where format is a string), conversion specifications in format are replaced with zero or more elements of values. This operation is commonly known as string interpolation. For example: 'The value of pi is approximately The value of pi is approximately 3.142. More information can be found in the printf-style String Formatting section.\n\nreturns a file object, and is most commonly used with two positional arguments and one keyword argument: The first argument is a string containing the filename. The second argument is another string containing a few characters describing the way in which the file will be used. mode can be when the file will only be read, for only writing (an existing file with the same name will be erased), and opens the file for appending; any data written to the file is automatically added to the end. opens the file for both reading and writing. The mode argument is optional; will be assumed if it’s omitted. Normally, files are opened in text mode, that means, you read and write strings from and to the file, which are encoded in a specific encoding. If encoding is not specified, the default is platform dependent (see ). Because UTF-8 is the modern de-facto standard, is recommended unless you know that you need to use a different encoding. Appending a to the mode opens the file in binary mode. Binary mode data is read and written as objects. You can not specify encoding when opening file in binary mode. In text mode, the default when reading is to convert platform-specific line endings ( on Unix, on Windows) to just . When writing in text mode, the default is to convert occurrences of back to platform-specific line endings. This behind-the-scenes modification to file data is fine for text files, but will corrupt binary data like that in or files. Be very careful to use binary mode when reading and writing such files. It is good practice to use the keyword when dealing with file objects. The advantage is that the file is properly closed after its suite finishes, even if an exception is raised at some point. Using is also much shorter than writing equivalent - blocks: # We can check that the file has been automatically closed. If you’re not using the keyword, then you should call to close the file and immediately free up any system resources used by it. Calling without using the keyword or calling might result in the arguments of not being completely written to the disk, even if the program exits successfully. After a file object is closed, either by a statement or by calling , attempts to use the file object will automatically fail. The rest of the examples in this section will assume that a file object called has already been created. To read a file’s contents, call , which reads some quantity of data and returns it as a string (in text mode) or bytes object (in binary mode). size is an optional numeric argument. When size is omitted or negative, the entire contents of the file will be read and returned; it’s your problem if the file is twice as large as your machine’s memory. Otherwise, at most size characters (in text mode) or size bytes (in binary mode) are read and returned. If the end of the file has been reached, will return an empty string ( ). 'This is the entire file.\n\n' reads a single line from the file; a newline character ( ) is left at the end of the string, and is only omitted on the last line of the file if the file doesn’t end in a newline. This makes the return value unambiguous; if returns an empty string, the end of the file has been reached, while a blank line is represented by , a string containing only a single newline. 'This is the first line of the file.\n\n' 'Second line of the file\n\n' For reading lines from a file, you can loop over the file object. This is memory efficient, fast, and leads to simple code: This is the first line of the file. If you want to read all the lines of a file in a list you can also use or . writes the contents of string to the file, returning the number of characters written. Other types of objects need to be converted – either to a string (in text mode) or a bytes object (in binary mode) – before writing them: returns an integer giving the file object’s current position in the file represented as number of bytes from the beginning of the file when in binary mode and an opaque number when in text mode. To change the file object’s position, use . The position is computed from adding offset to a reference point; the reference point is selected by the whence argument. A whence value of 0 measures from the beginning of the file, 1 uses the current file position, and 2 uses the end of the file as the reference point. whence can be omitted and defaults to 0, using the beginning of the file as the reference point. # Go to the 6th byte in the file # Go to the 3rd byte before the end In text files (those opened without a in the mode string), only seeks relative to the beginning of the file are allowed (the exception being seeking to the very file end with ) and the only valid offset values are those returned from the , or zero. Any other offset value produces undefined behaviour. File objects have some additional methods, such as and which are less frequently used; consult the Library Reference for a complete guide to file objects. Strings can easily be written to and read from a file. Numbers take a bit more effort, since the method only returns strings, which will have to be passed to a function like , which takes a string like and returns its numeric value 123. When you want to save more complex data types like nested lists and dictionaries, parsing and serializing by hand becomes complicated. Rather than having users constantly writing and debugging code to save complicated data types to files, Python allows you to use the popular data interchange format called JSON (JavaScript Object Notation). The standard module called can take Python data hierarchies, and convert them to string representations; this process is called serializing. Reconstructing the data from the string representation is called deserializing. Between serializing and deserializing, the string representing the object may have been stored in a file or data, or sent over a network connection to some distant machine. The JSON format is commonly used by modern applications to allow for data exchange. Many programmers are already familiar with it, which makes it a good choice for interoperability. If you have an object , you can view its JSON string representation with a simple line of code: Another variant of the function, called , simply serializes the object to a text file. So if is a text file object opened for writing, we can do this: To decode the object again, if is a binary file or text file object which has been opened for reading: JSON files must be encoded in UTF-8. Use when opening JSON file as a text file for both of reading and writing. This simple serialization technique can handle lists and dictionaries, but serializing arbitrary class instances in JSON requires a bit of extra effort. The reference for the module contains an explanation of this. Contrary to JSON, pickle is a protocol which allows the serialization of arbitrarily complex Python objects. As such, it is specific to Python and cannot be used to communicate with applications written in other languages. It is also insecure by default: deserializing pickle data coming from an untrusted source can execute arbitrary code, if the data was crafted by a skilled attacker."
    },
    {
        "link": "https://docs.python.org/3/library/functions.html",
        "document": "The Python interpreter has a number of functions and types built into it that are always available. They are listed here in alphabetical order.\n\nOpen file and return a corresponding file object. If the file cannot be opened, an is raised. See Reading and Writing Files for more examples of how to use this function. file is a path-like object giving the pathname (absolute or relative to the current working directory) of the file to be opened or an integer file descriptor of the file to be wrapped. (If a file descriptor is given, it is closed when the returned I/O object is closed unless closefd is set to .) mode is an optional string that specifies the mode in which the file is opened. It defaults to which means open for reading in text mode. Other common values are for writing (truncating the file if it already exists), for exclusive creation, and for appending (which on some Unix systems, means that all writes append to the end of the file regardless of the current seek position). In text mode, if encoding is not specified the encoding used is platform-dependent: is called to get the current locale encoding. (For reading and writing raw bytes use binary mode and leave encoding unspecified.) The available modes are: open for writing, truncating the file first open for exclusive creation, failing if the file already exists open for writing, appending to the end of file if it exists The default mode is (open for reading text, a synonym of ). Modes and open and truncate the file. Modes and open the file with no truncation. As mentioned in the Overview, Python distinguishes between binary and text I/O. Files opened in binary mode (including in the mode argument) return contents as objects without any decoding. In text mode (the default, or when is included in the mode argument), the contents of the file are returned as , the bytes having been first decoded using a platform-dependent encoding or using the specified encoding if given. Python doesn’t depend on the underlying operating system’s notion of text files; all the processing is done by Python itself, and is therefore platform-independent. buffering is an optional integer used to set the buffering policy. Pass 0 to switch buffering off (only allowed in binary mode), 1 to select line buffering (only usable when writing in text mode), and an integer > 1 to indicate the size in bytes of a fixed-size chunk buffer. Note that specifying a buffer size this way applies for binary buffered I/O, but (i.e., files opened with ) would have another buffering. To disable buffering in , consider using the flag for . When no buffering argument is given, the default buffering policy works as follows:\n• None Binary files are buffered in fixed-size chunks; the size of the buffer is chosen using a heuristic trying to determine the underlying device’s “block size” and falling back on . On many systems, the buffer will typically be 4096 or 8192 bytes long.\n• None “Interactive” text files (files for which returns ) use line buffering. Other text files use the policy described above for binary files. encoding is the name of the encoding used to decode or encode the file. This should only be used in text mode. The default encoding is platform dependent (whatever returns), but any text encoding supported by Python can be used. See the module for the list of supported encodings. errors is an optional string that specifies how encoding and decoding errors are to be handled—this cannot be used in binary mode. A variety of standard error handlers are available (listed under Error Handlers), though any error handling name that has been registered with is also valid. The standard names include:\n• None to raise a exception if there is an encoding error. The default value of has the same effect.\n• None ignores errors. Note that ignoring encoding errors can lead to data loss.\n• None causes a replacement marker (such as ) to be inserted where there is malformed data.\n• None will represent any incorrect bytes as low surrogate code units ranging from U+DC80 to U+DCFF. These surrogate code units will then be turned back into the same bytes when the error handler is used when writing data. This is useful for processing files in an unknown encoding.\n• None is only supported when writing to a file. Characters not supported by the encoding are replaced with the appropriate XML character reference .\n• None (also only supported when writing) replaces unsupported characters with escape sequences. newline determines how to parse newline characters from the stream. It can be , , , , and . It works as follows:\n• None When reading input from the stream, if newline is , universal newlines mode is enabled. Lines in the input can end in , , or , and these are translated into before being returned to the caller. If it is , universal newlines mode is enabled, but line endings are returned to the caller untranslated. If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated.\n• None When writing output to the stream, if newline is , any characters written are translated to the system default line separator, . If newline is or , no translation takes place. If newline is any of the other legal values, any characters written are translated to the given string. If closefd is and a file descriptor rather than a filename was given, the underlying file descriptor will be kept open when the file is closed. If a filename is given closefd must be (the default); otherwise, an error will be raised. A custom opener can be used by passing a callable as opener. The underlying file descriptor for the file object is then obtained by calling opener with (file, flags). opener must return an open file descriptor (passing as opener results in functionality similar to passing ). The following example uses the dir_fd parameter of the function to open a file relative to a given directory: 'This will be written to somedir/spamspam.txt' The type of file object returned by the function depends on the mode. When is used to open a file in a text mode ( , , , , etc.), it returns a subclass of (specifically ). When used to open a file in a binary mode with buffering, the returned class is a subclass of . The exact class varies: in read binary mode, it returns an ; in write binary and append binary modes, it returns an , and in read/write mode, it returns an . When buffering is disabled, the raw stream, a subclass of , , is returned. See also the file handling modules, such as , (where is declared), , , , and . The and arguments may have been modified or inferred from the original call.\n• None used to be raised, it is now an alias of .\n• None is now raised if the file opened in exclusive creation mode ( ) already exists.\n• None The file is now non-inheritable.\n• None If the system call is interrupted and the signal handler does not raise an exception, the function now retries the system call instead of raising an exception (see PEP 475 for the rationale).\n• None On Windows, opening a console buffer may return a subclass of other than . Changed in version 3.11: The mode has been removed.\n\nReturn a proxy object that delegates method calls to a parent or sibling class of type. This is useful for accessing inherited methods that have been overridden in a class. The object_or_type determines the method resolution order to be searched. The search starts from the class right after the type. For example, if of object_or_type is and the value of type is , then searches . The attribute of the class corresponding to object_or_type lists the method resolution search order used by both and . The attribute is dynamic and can change whenever the inheritance hierarchy is updated. If the second argument is omitted, the super object returned is unbound. If the second argument is an object, must be true. If the second argument is a type, must be true (this is useful for classmethods). When called directly within an ordinary method of a class, both arguments may be omitted (“zero-argument ”). In this case, type will be the enclosing class, and obj will be the first argument of the immediately enclosing function (typically ). (This means that zero-argument will not work as expected within nested functions, including generator expressions, which implicitly create nested functions.) There are two typical use cases for super. In a class hierarchy with single inheritance, super can be used to refer to parent classes without naming them explicitly, thus making the code more maintainable. This use closely parallels the use of super in other programming languages. The second use case is to support cooperative multiple inheritance in a dynamic execution environment. This use case is unique to Python and is not found in statically compiled languages or languages that only support single inheritance. This makes it possible to implement “diamond diagrams” where multiple base classes implement the same method. Good design dictates that such implementations have the same calling signature in every case (because the order of calls is determined at runtime, because that order adapts to changes in the class hierarchy, and because that order can include sibling classes that are unknown prior to runtime). For both use cases, a typical superclass call looks like this: # This does the same thing as: In addition to method lookups, also works for attribute lookups. One possible use case for this is calling descriptors in a parent or sibling class. Note that is implemented as part of the binding process for explicit dotted attribute lookups such as . It does so by implementing its own method for searching classes in a predictable order that supports cooperative multiple inheritance. Accordingly, is undefined for implicit lookups using statements or operators such as . Also note that, aside from the zero argument form, is not limited to use inside methods. The two argument form specifies the arguments exactly and makes the appropriate references. The zero argument form only works inside a class definition, as the compiler fills in the necessary details to correctly retrieve the class being defined, as well as accessing the current instance for ordinary methods. For practical suggestions on how to design cooperative classes using , see guide to using super()."
    },
    {
        "link": "https://geeksforgeeks.org/taking-input-in-python",
        "document": "Developers often have a need to interact with users, either to get data or to provide some sort of result. Most programs today use a dialog box as a way of asking the user to provide some type of input. While Python provides us with two inbuilt functions to read the input from the keyboard.\n\n\n\ninput () function first takes the input from the user and converts it into a string. The type of the returned object always will be <class ‘str’>. It does not evaluate the expression it just returns the complete statement as String.\n\nFor example, Python provides a built-in function called input which takes the input from the user. When the input function is called it stops the program and waits for the user’s input. When the user presses enter, the program resumes and returns what the user typed.\n\nHow the input function works in Python :\n• None When input() function executes program flow will be stopped until the user has given input.\n• None The text or message displayed on the output screen to ask a user to enter an input value is optional i.e. the prompt, which will be printed on the screen is optional.\n• None Whatever you enter as input, the input function converts it into a string. if you enter an integer value still input() function converts it into a string. You need to explicitly convert it into an integer in your code using\n\nNote: input() function takes all the input as a string only\n\nThere are various function that are used to take as desired input few of them are : –\n\nHow to input a number in Python?\n\nHow to take character input in Python?\n\nHow to check input type in Python?\n\nHow to print input value in Python?\n\nHow to input time in Python?"
    },
    {
        "link": "https://stackoverflow.com/questions/70797/user-input-and-command-line-arguments",
        "document": "To read user input you can try the module for easily creating a mini-command line interpreter (with help texts and autocompletion) and ( for Python 3+) for reading a line of text from the user.\n\nCommand line inputs are in . Try this in your script:\n\nThere are two modules for parsing command line options: (deprecated since Python 2.7, use instead) and . If you just want to input files to your script, behold the power of .\n\nThe Python library reference is your friend."
    },
    {
        "link": "https://stackoverflow.com/questions/43173168/avoiding-nested-for-loops-python",
        "document": "Nested loops are not a bad thing per se. They are only bad, if there are used for problems, for which better algorithm have been found (better and bad in terms of efficiency regarding the input size). Sorting of a list of integers for example is such a problem.\n\nIn your case above you have three lists, all of size 4. This makes 4 * 4 * 4 = 64 possible combinations of them, if a comes always before b and b before c. So you need at least 64 iterations!\n\nIn your approach we have 4 iterations for each possible value of a, 4 iterations for each possible value of b and the same for c. So we have 4 * 4 * 4 = 64 iterations in total. So in fact your solution is quite good! As there is no faster way of listening all combinations, your way is also the best one.\n\nRegarding the style one can say that you can improve your code by better variable names and combining some of the for loops. E.g. like that:\n\nNotice however that the amount of iterations remain the same!\n\nAs Kevin noticed, you could also use to generate the cartesian product. Internally it will do the same as what you did with the combined for loops:"
    },
    {
        "link": "https://blog.heycoach.in/nested-loops-in-python",
        "document": "Welcome, fellow Pythonistas! Today, we’re diving into the wonderful world of nested loops in Python. If you’ve ever felt like your code was a bit too simple, like a plain bagel without cream cheese, then nested loops are here to spice things up! So grab your favorite caffeinated beverage, and let’s get looping!\n\nNested loops are like those Russian dolls that fit inside one another—one loop inside another loop. In Python, this means you can have a loop (like a or loop) inside another loop. This is particularly useful when you need to iterate over multi-dimensional data structures, like lists of lists, or when you want to perform complex calculations that require multiple iterations.\n• Outer Loop: The loop that contains another loop.\n• Inner Loop: The loop that is contained within the outer loop.\n• Complexity: Nested loops can increase the time complexity of your code, so use them wisely!\n• Real-life Example: Think of nested loops like a restaurant menu: the outer loop is the main course, and the inner loop is the side dishes you can choose for each main course.\n\nNow, you might be wondering, “Why would I want to complicate my life with nested loops?” Well, my friend, here are some compelling reasons:\n• Multi-dimensional Data: Perfect for working with matrices or grids.\n• Complex Calculations: Great for algorithms that require multiple passes over data.\n• Data Processing: Useful for processing data in a structured format.\n• Pattern Generation: Ideal for generating patterns, like stars or shapes.\n• Combinatorial Problems: Essential for problems that require combinations or permutations.\n• Game Development: Useful for traversing game boards or grids.\n• Nested Structures: Works well with nested data structures like dictionaries of lists.\n• Efficiency: Sometimes, they can make your code cleaner and more efficient.\n\nLet’s get our hands dirty with some code! Here’s the basic syntax for nested loops in Python:\n\nIn this structure, the loop will run first, and for each iteration of the loop, the loop will run completely. It’s like a dance party where the outer loop is the DJ, and the inner loop is the crowd dancing to every beat!\n\nLet’s look at a practical example. Suppose we want to print a multiplication table. Here’s how we can do it using nested loops:\n\nWhen you run this code, you’ll get a lovely multiplication table:\n\nSee? It’s like magic, but with numbers!\n\nAs with all great things, nested loops come with their own set of challenges. Here are some common pitfalls to watch out for:\n• Performance Issues: Nested loops can lead to performance bottlenecks, especially with large datasets.\n• Readability: Too many nested loops can make your code hard to read and maintain.\n• Infinite Loops: Be careful with your loop conditions; you don’t want to get stuck in an infinite loop!\n• Variable Scope: Be mindful of variable scope; inner loop variables can affect outer loops.\n• Off-by-One Errors: Watch out for those pesky off-by-one errors in your range definitions.\n• Debugging Difficulty: Debugging nested loops can be tricky; use print statements wisely!\n• Logic Errors: Ensure your logic is sound; nested loops can complicate things quickly.\n• Memory Usage: Be aware of memory usage, especially with large data structures.\n• Overcomplication: Sometimes, a simple solution is better than a complex nested loop.\n• Testing: Test your loops thoroughly to ensure they behave as expected.\n\nReady to take your nested loop skills to the next level? Here are some advanced techniques to consider:\n• List Comprehensions: Use list comprehensions for cleaner, more Pythonic nested loops.\n• Generator Expressions: Use generators to save memory when dealing with large datasets.\n• Using Functions: Encapsulate nested loops in functions for better organization.\n• Recursive Functions: Sometimes recursion can replace nested loops for certain problems.\n• Using Libraries: Leverage libraries like NumPy for efficient multi-dimensional array operations.\n• Matrix Operations: Use nested loops for matrix operations, but consider optimized libraries.\n• Debugging Tools: Use debugging tools to visualize nested loops in action.\n• Profiling: Profile your code to identify performance bottlenecks in nested loops.\n\nAnd there you have it, folks! Nested loops in Python are like the Swiss Army knife of programming—versatile, powerful, and sometimes a little confusing. Remember to use them wisely, and don’t let them spiral out of control like a toddler on a sugar rush!\n\nNow that you’re armed with the knowledge of nested loops, go forth and conquer your coding challenges! And if you find yourself in a loop (pun intended), don’t hesitate to revisit this guide. Happy coding!\n\nFor more Python fun, check out our other posts on advanced topics, and remember: the only limit is your imagination (and maybe your computer’s processing power). Until next time, keep looping!"
    },
    {
        "link": "https://reddit.com/r/learnpython/comments/11d6o3e/how_to_make_nested_for_loops_run_faster",
        "document": "Hi, i'm currently in situation where my function needs run with multiple variations and at this point it takes a two days to calculate what I need. Multiprocessing not helping. So I want to ask how to improve nested for loops that currently structure looks something like this?"
    },
    {
        "link": "https://stackoverflow.com/questions/68340065/any-tip-to-improve-performance-when-using-nested-loops-with-python",
        "document": "Here's a simple solution that should be extremely fast (it runs in O(n) time). It makes use of the following observation: We only care about each value mod 60. E.g. 23 and 143 are effectively the same.\n\nSo rather than making an O(n**2) nested pass over the list, we instead count how many of each value we have, mod 60, so each value we count is in the range 0 - 59.\n\nOnce we have the counts, we can consider the pairs that sum to 0 or 60. The pairs that work are:\n\nAfter this, the order is reversed, but we only want to count each pair once.\n\nThere are two cases where the values are the same: 0 + 0 and 30 + 30. For each of these, the number of pairs is . Note that this works when count is 0 or 1, since in both cases we're multiplying by zero.\n\nIf the two values are different, then the number of cases is simply the product of their counts.\n\nThis runs in O(n) time, due to the initial one-time pass we make over the list of input values. The loop at the end is just iterating from 1 through 29 and isn't nested, so it should run almost instantly."
    },
    {
        "link": "https://geeksforgeeks.org/python-nested-loops",
        "document": "In Python programming language there are two types of loops which are for loop and while loop. Using these loops we can create nested loops in Python. Nested loops mean loops inside a loop. For example, while loop inside the for loop, for loop inside the for loop, etc.\n\nExample 1: Basic Example of Python Nested Loops\n\nExample 2: Printing multiplication table using Python nested for loops\n\nIn the above example what we do is take an outer for loop running from 2 to 3 for multiplication table of 2 and 3 and then inside that loop we are taking an inner for loop that will run from 1 to 10 inside that we are printing multiplication table by multiplying each iteration value of inner loop with the iteration value of outer loop as we see in the below output.\n\nExample 3: Printing using different inner and outer nested loops\n\nIn this example, we are initializing two lists with some strings. Store the size of list2 in ‘list2_Size’ using len() function and using it in the while loop as a counter. After that run an outer for loop to iterate over list1 and inside that loop run an inner while loop to iterate over list2 using list indexing inside that we are printing each value of list2 for every value of list1.\n\nIt is a type of loop control statement. In a loop, we can use the break statement to exit from the loop. When we use a break statement in a loop it skips the rest of the iteration and terminates the loop. let’s understand it using an example.\n\nThe above code is the same as in Example 2 In this code we are using a break statement inside the inner loop by using the if statement. Inside the inner loop if ‘i’ becomes equals to ‘j’ then the inner loop will be terminated and not executed the rest of the iteration as we can see in the output table of 3 is printed up to two iterations because in the next iteration ‘i’ becomes equal to ‘j’ and the loop breaks.\n\nA continue statement is also a type of loop control statement. It is just the opposite of the break statement. The continue statement forces the loop to jump to the next iteration of the loop whereas the break statement terminates the loop. Let’s understand it by using code.\n\nIn the above code instead of using a break statement, we are using a continue statement. Here when ‘i’ becomes equal to ‘j’ in the inner loop it skips the rest of the code in the inner loop and jumps on the next iteration as we see in the output “2 * 2 = 4” and “3 * 3 = 9” is not printed because at that point ‘i’ becomes equal to ‘j’.\n\nTo convert the multiline nested loops into a single line, we are going to use list comprehension in Python. List comprehension includes brackets consisting of expression, which is executed for each element, and the for loop to iterate over each element in the list.\n\nIn the above code, we are storing a list inside the list using list comprehension in the inner loop of list comprehension [j for j in range(3)] to make a list [0, 1, 2] for every iteration of the outer loop “for i in range(5)”.\n\nTime Complexity: O(n2) It is faster than nested loops\n\nWhat is a Nested Loop in Python?\n\nA nested loop in Python refers to a loop within another loop. The “inner loop” will be executed one time for each iteration of the “outer loop”. This structure is commonly used when you need to perform operations on multi-dimensional data structures like lists of lists, or when processing tasks that require multiple levels of looping. \n\n for j in range(1, 4): # Inner loop \n\n This will print pairs of and values, where is from the outer loop and from the inner.\n\nWhat are the 2 Main Types of Loops in Python?\n\nWhat are the 3 Types of Loops?\n\nHow Many Nested Loops are There?\n\nWhat is Nested Class in Python?"
    },
    {
        "link": "https://docs.python.org/3/tutorial/inputoutput.html",
        "document": "There are several ways to present the output of a program; data can be printed in a human-readable form, or written to a file for future use. This chapter will discuss some of the possibilities.\n\nSo far we’ve encountered two ways of writing values: expression statements and the function. (A third way is using the method of file objects; the standard output file can be referenced as . See the Library Reference for more information on this.) Often you’ll want more control over the formatting of your output than simply printing space-separated values. There are several ways to format output.\n• None To use formatted string literals, begin a string with or before the opening quotation mark or triple quotation mark. Inside this string, you can write a Python expression between and characters that can refer to variables or literal values.\n• None The method of strings requires more manual effort. You’ll still use and to mark where a variable will be substituted and can provide detailed formatting directives, but you’ll also need to provide the information to be formatted. In the following code block there are two examples of how to format variables: Notice how the are padded with spaces and a negative sign only for negative numbers. The example also prints multiplied by 100, with 2 decimal places and followed by a percent sign (see Format Specification Mini-Language for details).\n• None Finally, you can do all the string handling yourself by using string slicing and concatenation operations to create any layout you can imagine. The string type has some methods that perform useful operations for padding strings to a given column width. When you don’t need fancy output but just want a quick display of some variables for debugging purposes, you can convert any value to a string with the or functions. The function is meant to return representations of values which are fairly human-readable, while is meant to generate representations which can be read by the interpreter (or will force a if there is no equivalent syntax). For objects which don’t have a particular representation for human consumption, will return the same value as . Many values, such as numbers or structures like lists and dictionaries, have the same representation using either function. Strings, in particular, have two distinct representations. The value of x is 32.5, and y is 40000... # The repr() of a string adds string quotes and backslashes: # The argument to repr() may be any Python object: The module contains a class that offers yet another way to substitute values into strings, using placeholders like and replacing them with values from a dictionary, but offers much less control of the formatting. Formatted string literals (also called f-strings for short) let you include the value of Python expressions inside a string by prefixing the string with or and writing expressions as . An optional format specifier can follow the expression. This allows greater control over how the value is formatted. The following example rounds pi to three places after the decimal: 'The value of pi is approximately The value of pi is approximately 3.142. Passing an integer after the will cause that field to be a minimum number of characters wide. This is useful for making columns line up. Other modifiers can be used to convert the value before it is formatted. applies , applies , and applies : 'My hovercraft is full of My hovercraft is full of eels. 'My hovercraft is full of My hovercraft is full of 'eels'. The specifier can be used to expand an expression to the text of the expression, an equal sign, then the representation of the evaluated expression: See self-documenting expressions for more information on the specifier. For a reference on these format specifications, see the reference guide for the Format Specification Mini-Language. Basic usage of the method looks like this: We are the knights who say \"Ni!\" The brackets and characters within them (called format fields) are replaced with the objects passed into the method. A number in the brackets can be used to refer to the position of the object passed into the method. If keyword arguments are used in the method, their values are referred to by using the name of the argument. Positional and keyword arguments can be arbitrarily combined: The story of Bill, Manfred, and Georg. If you have a really long format string that you don’t want to split up, it would be nice if you could reference the variables to be formatted by name instead of by position. This can be done by simply passing the dict and using square brackets to access the keys. This could also be done by passing the dictionary as keyword arguments with the notation. This is particularly useful in combination with the built-in function , which returns a dictionary containing all local variables: __name__: __main__; __doc__: None; __package__: None; __loader__: ... As an example, the following lines produce a tidily aligned set of columns giving integers and their squares and cubes: For a complete overview of string formatting with , see Format String Syntax. Here’s the same table of squares and cubes, formatted manually: # Note use of 'end' on previous line The method of string objects right-justifies a string in a field of a given width by padding it with spaces on the left. There are similar methods and . These methods do not write anything, they just return a new string. If the input string is too long, they don’t truncate it, but return it unchanged; this will mess up your column lay-out but that’s usually better than the alternative, which would be lying about a value. (If you really want truncation you can always add a slice operation, as in .) There is another method, , which pads a numeric string on the left with zeros. It understands about plus and minus signs: The % operator (modulo) can also be used for string formatting. Given (where format is a string), conversion specifications in format are replaced with zero or more elements of values. This operation is commonly known as string interpolation. For example: 'The value of pi is approximately The value of pi is approximately 3.142. More information can be found in the printf-style String Formatting section.\n\nreturns a file object, and is most commonly used with two positional arguments and one keyword argument: The first argument is a string containing the filename. The second argument is another string containing a few characters describing the way in which the file will be used. mode can be when the file will only be read, for only writing (an existing file with the same name will be erased), and opens the file for appending; any data written to the file is automatically added to the end. opens the file for both reading and writing. The mode argument is optional; will be assumed if it’s omitted. Normally, files are opened in text mode, that means, you read and write strings from and to the file, which are encoded in a specific encoding. If encoding is not specified, the default is platform dependent (see ). Because UTF-8 is the modern de-facto standard, is recommended unless you know that you need to use a different encoding. Appending a to the mode opens the file in binary mode. Binary mode data is read and written as objects. You can not specify encoding when opening file in binary mode. In text mode, the default when reading is to convert platform-specific line endings ( on Unix, on Windows) to just . When writing in text mode, the default is to convert occurrences of back to platform-specific line endings. This behind-the-scenes modification to file data is fine for text files, but will corrupt binary data like that in or files. Be very careful to use binary mode when reading and writing such files. It is good practice to use the keyword when dealing with file objects. The advantage is that the file is properly closed after its suite finishes, even if an exception is raised at some point. Using is also much shorter than writing equivalent - blocks: # We can check that the file has been automatically closed. If you’re not using the keyword, then you should call to close the file and immediately free up any system resources used by it. Calling without using the keyword or calling might result in the arguments of not being completely written to the disk, even if the program exits successfully. After a file object is closed, either by a statement or by calling , attempts to use the file object will automatically fail. The rest of the examples in this section will assume that a file object called has already been created. To read a file’s contents, call , which reads some quantity of data and returns it as a string (in text mode) or bytes object (in binary mode). size is an optional numeric argument. When size is omitted or negative, the entire contents of the file will be read and returned; it’s your problem if the file is twice as large as your machine’s memory. Otherwise, at most size characters (in text mode) or size bytes (in binary mode) are read and returned. If the end of the file has been reached, will return an empty string ( ). 'This is the entire file.\n\n' reads a single line from the file; a newline character ( ) is left at the end of the string, and is only omitted on the last line of the file if the file doesn’t end in a newline. This makes the return value unambiguous; if returns an empty string, the end of the file has been reached, while a blank line is represented by , a string containing only a single newline. 'This is the first line of the file.\n\n' 'Second line of the file\n\n' For reading lines from a file, you can loop over the file object. This is memory efficient, fast, and leads to simple code: This is the first line of the file. If you want to read all the lines of a file in a list you can also use or . writes the contents of string to the file, returning the number of characters written. Other types of objects need to be converted – either to a string (in text mode) or a bytes object (in binary mode) – before writing them: returns an integer giving the file object’s current position in the file represented as number of bytes from the beginning of the file when in binary mode and an opaque number when in text mode. To change the file object’s position, use . The position is computed from adding offset to a reference point; the reference point is selected by the whence argument. A whence value of 0 measures from the beginning of the file, 1 uses the current file position, and 2 uses the end of the file as the reference point. whence can be omitted and defaults to 0, using the beginning of the file as the reference point. # Go to the 6th byte in the file # Go to the 3rd byte before the end In text files (those opened without a in the mode string), only seeks relative to the beginning of the file are allowed (the exception being seeking to the very file end with ) and the only valid offset values are those returned from the , or zero. Any other offset value produces undefined behaviour. File objects have some additional methods, such as and which are less frequently used; consult the Library Reference for a complete guide to file objects. Strings can easily be written to and read from a file. Numbers take a bit more effort, since the method only returns strings, which will have to be passed to a function like , which takes a string like and returns its numeric value 123. When you want to save more complex data types like nested lists and dictionaries, parsing and serializing by hand becomes complicated. Rather than having users constantly writing and debugging code to save complicated data types to files, Python allows you to use the popular data interchange format called JSON (JavaScript Object Notation). The standard module called can take Python data hierarchies, and convert them to string representations; this process is called serializing. Reconstructing the data from the string representation is called deserializing. Between serializing and deserializing, the string representing the object may have been stored in a file or data, or sent over a network connection to some distant machine. The JSON format is commonly used by modern applications to allow for data exchange. Many programmers are already familiar with it, which makes it a good choice for interoperability. If you have an object , you can view its JSON string representation with a simple line of code: Another variant of the function, called , simply serializes the object to a text file. So if is a text file object opened for writing, we can do this: To decode the object again, if is a binary file or text file object which has been opened for reading: JSON files must be encoded in UTF-8. Use when opening JSON file as a text file for both of reading and writing. This simple serialization technique can handle lists and dictionaries, but serializing arbitrary class instances in JSON requires a bit of extra effort. The reference for the module contains an explanation of this. Contrary to JSON, pickle is a protocol which allows the serialization of arbitrarily complex Python objects. As such, it is specific to Python and cannot be used to communicate with applications written in other languages. It is also insecure by default: deserializing pickle data coming from an untrusted source can execute arbitrary code, if the data was crafted by a skilled attacker."
    },
    {
        "link": "https://geeksforgeeks.org/python-output-formatting",
        "document": "In Python, output formatting refers to the way data is presented when printed or logged. Proper formatting makes information more understandable and actionable. Python provides several ways to format strings effectively, ranging from old-style formatting to the newer f-string approach.\n\nThe string modulo operator (%) is one of the oldest ways to format strings in Python. It allows you to embed values within a string by placing format specifiers in the string. Each specifier starts with a % and ends with a character that represents the type of value being formatted.\n\nThere are several ways to format output using String Method in Python.\n\nThe format() method was introduced in Python 2.6 to enhance string formatting capabilities. This method allows for a more flexible way to handle string interpolation by using curly braces {} as placeholders for substituting values into a string. It supports both positional and named arguments, making it versatile for various formatting needs. For Example –\n\nExample 1: Basic positional formatting demonstrates how values are substituted based on their order:\n\nIn this example, {0} and {1} refer to the first and second argument provided to format(), respectively.\n\nThe following diagram with an example usage depicts how the format method works for positional parameters:\n\nThe format() method also supports detailed formatting options such as setting widths, alignment, number formatting and more, which can be extremely useful for creating tabulated data or reports.\n\nExample 2: Here’s how positional parameters along with a named argument are used to format numbers and text precisely:\n\nIn this example:\n• None {0:2d} and {1:8.2f} demonstrate number formatting where 2d specifies a two-digit integer and 8.2f specifies a floating-point number with two decimal places padded to a total width of eight characters.\n• None Named arguments a and p are used for additional clarity and are referenced directly in the format string.\n\nPython’s string methods such as str.center(), str.ljust() and str.rjust() provide straightforward ways to format strings by aligning them within a specified width. These methods are ideal for organizing textual data neatly in output without using more complex formatting tools.\n\nThis table lists the standard format conversion guidelines used by Python’s format() function.\n\nHow to do formatting in Python?\n\nIn Python, there are multiple ways to format data:\n• Old-style String Formatting ( operator): This method is less preferred in newer Python code but still works:\n\nWhat is the formatting tool for Python?\n\nWhat is data formatting in Python?"
    },
    {
        "link": "https://stackoverflow.com/questions/28204936/python-format-best-practices",
        "document": "I'm just coming up to speed with Python and had a question about best practices (or at least common practices) around using .format on a string.\n\nMy question is mostly around when you would use blank curly brackets vs. an index number vs. a name.\n\nFor example if you had a single variable that you wanted to include in a string which one would you do?\n\nDoes this change if you have multiple variables you want to include? Maybe it's OK to include {} for a single var, but never for multiple vars?\n\nAny thoughts or insights here would be greatly appreciated."
    },
    {
        "link": "https://realpython.com/python-formatted-output",
        "document": "In modern Python, you have f-strings and the method to approach the tasks of interpolating and formatting strings. These tools help you embed variables and expressions directly into strings, control text alignment, and use custom format specifiers to modify how values appear. You can apply these techniques to create well-structured and readable Python code.\n\nBy the end of this tutorial, you’ll understand that:\n• String interpolation in Python involves embedding variables and expressions into strings.\n• You create an f-string in Python by prepending a string literal with an or and using curly braces to include variables or expressions.\n• You can use variables in Python’s method by placing them inside curly braces and passing them as arguments.\n• Format specifiers in Python control how values appear when formatted, using components like fill, align, sign, width, and type.\n• You align text in Python string formatting using the align component, which can justify text to the left, right, or center within a specified width.\n\nWhen working with strings in Python, you can leverage these formatting techniques to create dynamic and readable output. To get the most out of this tutorial, you should know the basics of Python programming and the string data type.\n\nPython has a string formatting tool called f-strings, which stands for formatted string literals. F-strings are string literals that you can create by prepending an or to the literal. They allow you to do string interpolation and formatting by inserting variables or expressions directly into the literal. Here you’ll take a look at how you can create an f-string by prepending the string literal with an or : Using either or has the same effect. However, it’s a more common practice to use a lowercase to create f-strings. Just like with regular string literals, you can use single, double, or triple quotes to define an f-string: Up to this point, your f-strings look pretty much the same as regular strings. However, if you create f-strings like those in the examples above, you’ll get complaints from your code linter if you have one. The remarkable feature of f-strings is that you can embed Python variables or expressions directly inside them. To insert the variable or expression, you must use a replacement field, which you create using a pair of curly braces. The variable that you insert in a replacement field is evaluated and converted to its string representation. The result is interpolated into the original string at the replacement field’s location: In this example, you’ve interpolated the variable into your string. Note that Python treats anything outside the curly braces as a regular string. Also, keep in mind that Python retrieves the value of when it runs the string literal, so if isn’t defined at that time, then you get a exception. Therefore, f-strings are appropriate for eager string interpolation. Note: You’ll typically find two different types of string interpolation:\n• Eager interpolation, where Python inserts the values into the string at execution time in the same place where you define the string.\n• Lazy interpolation, where Python delays the value insertion until the string is needed. In lazy interpolation, you typically create string templates at one point in your code and fill the template with values at another point. To do this type of interpolation, you can use the method, as you’ll see in a moment. Now that you’ve learned how to embed a variable into an f-string, you can look into embedding Python expressions into your f-string literals. You can embed almost any Python expression in an f-string, including arithmetic, Boolean, and conditional expressions. You can also include function calls, attribute access, common sequence operations like indexing and slicing, and more. Note: To learn more about using f-strings in Python, check out the Python’s F-String for String Interpolation and Formatting tutorial. Here’s an example that uses an arithmetic operation: The expressions that you embed in an f-string can be almost arbitrarily complex. The examples below show some of the possibilities. You can also do indexing and slicing on sequences and look up keys in dictionaries: \"First fruit in the list is ' \"First fruit in the list is 'apple'\" \"Last two fruits in the list are \"Last two fruits in the list are ['mango', 'grape']\" \"Dict value for key 'one' is \"Dict value for key 'one' is 1\" In this example, the first two embedded expressions run indexing and slicing operations in a list. The last expression runs a dictionary key lookup. Note: Before Python 3.12, f-strings had a few limitations that restricted the expressions that you could embed. These limitations were overcome with the arrival of Python 3.12. To explore the details, check out the Python 3.12 Preview: More Intuitive and Consistent F-Strings tutorial. To include curly braces in an f-string, you need to escape it by doubling it: In this example, the outer pair of curly braces tells Python to treat the inner braces as literal characters rather than part of the expression so they can appear in the resulting string.\n\nUsing the Method for String Interpolation In many ways, the Python string method is similar to the older string modulo operator, but goes well beyond it in terms of versatility. The general form of a call is shown below: You typically call the method on a string template, which is a string containing replacement fields. The and arguments allow you to specify the values to insert into the template. The resulting string is returned from the method. In the template string, replacement fields are enclosed in curly braces ( ). Anything outside of the curly braces is literal text that’s copied directly from the template to the output. To interpolate values into a string template using , you can use positional arguments in the method call. You can then use integer indices to determine which replacement field to insert each value into: In this example, is the string , which includes three replacement fields. The replacement fields , , and contain numbers that correspond to the zero-based positional arguments , , and . Each positional argument is inserted into the template according to its index. The following diagram shows the complete process: Using the String .format() Method With Positional Arguments and Indices The arguments to are inserted into the string template in the corresponding position. The first argument goes into the replacement field with index , the second argument goes into the replacement field with index , and so on. It’s important to note that the indices don’t have to follow a strict consecutive order or be unique in the template. This allows you to customize the position of each argument in the final string. When you specify a replacement field number that’s out of range, you’ll get an error. In the following example, the positional arguments are numbered , , and , but you specify in the template: : Replacement index 3 out of range for positional args tuple This call to raises an exception because index is out of range. You can also omit the indices in the replacement fields, in which case Python will assume a sequential order. This is referred to as automatic field numbering: In this example, you’ve removed the indices from your template. In this situation, Python inserts every argument into the replacement field following the same order you used in the call to . When you specify automatic field numbering, you must provide at least as many arguments as there are replacement fields. Here’s a toy example with four replacement fields and only three arguments: : Replacement index 3 out of range for positional args tuple In this example, you have four replacement fields in the template but only three arguments in the call to . So, you get an exception. Finally, it’s fine if the arguments outnumber the replacement fields. The excess arguments aren’t used: Here, Python ignores the argument and builds the final string using only and . Note that you can’t mix these two techniques: When you use Python to format strings with positional arguments, you must choose between either automatic or explicit replacement field numbering. You can also use keyword arguments instead of positional argument to produce the same result: In this case, the replacement fields are , , and . These fields specify keywords corresponding to the keyword arguments , , and . Each keyword value is inserted into the template in place of its corresponding replacement field by name. Keyword arguments are inserted into the template string in place of keyword replacement fields with the same name: In this example, the values of the keyword arguments , , and take the place of the replacement fields , , and , respectively. If you refer to a keyword argument that’s missing, then you’ll get an error: In this example, you specify the replacement field, but no corresponding keyword argument is named in the call to , so Python raises a exception. You can specify keyword arguments in any arbitrary order: In the first example, the replacement fields are in alphabetical order and the arguments aren’t. In the second example, it’s the other way around. You can specify positional and keyword arguments in one call. In this case, all of the positional arguments must appear before any of the keyword arguments: The requirement that all positional arguments appear before any keyword arguments doesn’t only apply to the method. This is generally true for any function or method call in Python. In all the examples so far, the values you passed to have been literal values, but you can specify variables as well: In this example, you pass the variables and as positional arguments and as a keyword argument.\n\nNow that you know the basics of how to interpolate values into your strings using f-strings or , you’re ready to learn about formatting. When you call Python’s method, the template string contains replacement fields. A replacement field consists of three components. Here’s the BNF notation for the replacement fields syntax: The three components are interpreted as shown in the table below: Specifies the source of the value to be formatted Indicates which standard Python function to use to perform the type conversion Specifies the format specifier to use when formatting the input value Each component is optional and may be omitted. The component can be a name or an index as you’ve already learned. F-strings also have replacement fields. Their syntax is similar: As shown here, f-strings have up to four components. The interpretation is mostly the same as with the method. However, in an f-string, the component can hold a variable or expression. The equal sign ( ) is optional and allows you to create self-documenting strings. Up to this point, you’ve coded examples that show how to use the component in f-strings and the component in . In the following sections, you’ll learn about the other two components, which work similarly in f-strings and . The component defines the function to use when converting the input value into a string. Python can do this conversion using built-in functions like the following: By default, both f-strings and the method use . However, in some situations, you may want to use . You can do this with the component of a replacement field. The possible values for are shown in the table below: To illustrate the difference between these two values, consider the following class: This class implements the special methods and , which internally support the built-in and functions. Now consider how this class works in the context of f-strings and the method: When you use the value for the component, you get the user-friendly string representation of the interpolated object. Similarly, when you use the value, you get the developer-friendly string representation. The component is the last portion of a replacement field. This component represents the guts of Python’s string formatting functionality. It contains information that exerts fine control over how to format the input values before inserting them into the template string. The BNF notation that describes the syntax of this component is shown below: The components of are listed in order in the following table: Specifies the character to use for padding values that don’t occupy the entire field width Specifies how to justify values that don’t occupy the entire field width Controls whether a leading sign is included for numeric values Selects an alternate output form for certain presentation types, such as integers Causes values to be padded on the left with zeros instead of ASCII space characters Specifies the minimum width of the output Specifies the number of digits after the decimal point for floating-point presentation types, and the maximum output width for string presentations types Specifies the presentation type, which is the type of conversion performed on the corresponding argument In the following section, you’ll learn how these components work in practice and how you can use them to format your strings either with f-string literals or with the method.\n\nIn practice, when you’re creating format specifiers to format the values that you interpolate into your strings, you can use different components according to your specific needs. In the following sections, you’ll learn about the format specifier components and how to use them. To kick things off, you’ll start with the component, which is the final portion of a . The component specifies the presentation type, which is the type of conversion that’s performed on the corresponding value to produce the output. The possible values for are described below: The first presentation type you have is , which designates binary integer conversion: In these examples, you use the conversion type to represent the decimal number as a binary number. The presentation type allows you to convert an input integer into its associated Unicode character: As shown above, you can convert a given integer value into its associated Unicode character with the presentation type. Note that you can use the built-in function to confirm the conversion. The conversion type chooses either floating-point or exponential output, depending on the magnitude of the exponent: The exact rules governing the choice might seem slightly complicated. Generally, you can trust that the choice will make sense. The conversion type is identical to except for when the output is exponential, in which case the will be displayed in uppercase: The result is the same as in the previous example, but this time with an uppercase . You’ll find a couple of other situations where you’ll see a difference between the and presentation types. For example, under some circumstances, a floating-point operation can result in a value that’s essentially infinite. The string representation of such a number in Python is . A floating-point operation may also produce a value that can’t be represented as a number. Python represents this value with the string , which stands for Not a Number. When you pass these values to an f-string or the method, the presentation type produces lowercase output, and produces uppercase output: You’ll see similar behavior with the and presentation types. For more information on floating-point representation, , and , check out the Wikipedia page on IEEE 754. To learn more about other representation types, take a look at the Converting Between Type Representations section of Python’s Format Mini-Language for Tidy Strings. The component specifies the minimum width of the output field: Note that this is a minimum field width. Suppose you specify a value that’s longer than the minimum: In this example, is effectively ignored and the final string displays the input value as is. The and components allow you to control how the formatted output is padded and positioned within the specified field width. These components only make a difference when the input value doesn’t occupy the entire field width, which can only happen if a minimum field width is specified. If isn’t specified, then and are effectively ignored. Here are the possible values for the subcomponent: Aligns the value to the left Aligns the value to the right A format specifier that uses the less than sign ( ) indicates that the output will be left-justified: Aligning the value to the left is the default behavior with strings like . A format specifier that uses the greater than sign ( ) indicates that the output will be right-justified: Aligning to the right is the default behavior for numeric values like . A format specifier that uses a caret ( ) indicates that the output will be centered in the output field: With the caret character, you can center the input value in the output field. Finally, you can specify a value for the component using the equal sign ( ) . This sign only has meaning for numeric values with signs included. When numeric output includes a sign, it’s normally placed directly to the left of the first digit in the number: In these examples, you’ve used the component, which you’ll learn about in detail in the next section. If you set to the equal sign ( ), then the sign appears at the left of the output field: As you can see, the sign now appears on the left and the padding is added in between the sign and the number. The component allows you to replace the extra space when the input value doesn’t completely fill the output width. It can be any character except for curly braces ( ). Some examples of using are shown below: Keep in mind that if you specify a value for , then you should also include a value for . You can control whether a sign appears in numeric output with the component of your format specifiers. In the following example, the plus sign ( ) indicates that the value should always display a leading sign: In these examples, you use the plus sign to always include a leading sign for both positive and negative values. If you use the minus sign ( ), then only negative numeric values will include a leading sign: The sign lets you display the sign when the input value is negative. If the input value is positive, then no sign is displayed. Finally, you can also use a space ( ) for the component. A space means that a sign is included for negative values and a space character for positive values. To make this behavior evident in the example below, you use an asterisk as the fill character: As you can see in these examples, positive values include a space rather than a plus sign. On the other hand, negative values include the actual minus sign. When you include a hash character ( ) in the component, Python will select an alternate output form for certain presentation types. For binary ( ), octal ( ), and hexadecimal ( ) presentation types, the hash character causes the inclusion of an explicit base indicator to the left of the value: The base indicators are , , and for binary, octal, and hexadecimal representations, respectively. For floating-point ( or ) and exponential ( or ) presentation types, the hash character forces the output to contain a decimal point, even if the input consists of a whole number: For any presentation type other than those covered above, the hash character ( ) has no effect. If the output is smaller than the indicated field width and you start the component with a zero ( ), then the input value will be padded on the left with zeros instead of space characters: You’ll typically use the component for numeric values, as shown above. However, it works for string values as well: If you specify both and , then overrides the component: The and components essentially control the same thing, so there isn’t any need to specify both at the same time. In practice, is superfluous and was probably included as a convenience for developers who are familiar with the string modulo operator’s similar conversion flag. The component allows you to include a grouping separator character in numeric outputs. For decimal and floating-point presentation types, may be either a comma ( ) or an underscore ( ). That character then separates each group of three digits in the output: In these examples, you’ve used a comma and an underscore as thousand separators for integer and floating-point values. Setting the component to an underscore ( ) may also be useful with the binary, octal, and hexadecimal presentation types. In those cases, each group of four digits is separated by an underscore character in the output: If you try to specify with any presentation type other than those listed above, then your code will raise an exception. The component specifies the number of digits after the decimal point for floating-point presentation types: In these examples, you use different precision values to display the output number. The is separated from the by a literal dot ( ). For string representation types, specifies the maximum width of the output: If the input value is longer than the specified value, then the output will be truncated."
    },
    {
        "link": "https://realpython.com/python-string-formatting",
        "document": "String formatting is essential in Python for creating dynamic and well-structured text by inserting values into strings. This tutorial covers various methods, including f-strings, the method, and the modulo operator ( ). Each method has unique features and benefits for different use cases. The string formatting mini-language provides additional control over the output format, allowing for aligned text, numeric formatting, and more.\n\nBy the end of this tutorial, you’ll understand that:\n• String formatting in Python involves inserting and formatting values within strings using interpolation.\n• Python supports different types of string formatting, including f-strings, the method, and the modulo operator ( ).\n• F-strings are generally the most readable and efficient option for eager interpolation in Python.\n• While f-strings are more readable and efficient compared to and the operator, the method supports lazy evaluation.\n\nTo get the most out of this tutorial, you should be familiar with Python’s string data type and the available string interpolation tools. Having a basic knowledge of the string formatting mini-language is also a plus.\n\nString interpolation involves generating strings by inserting other strings or objects into specific places in a base string or template. For example, here’s how you can do some string interpolation using an f-string: In this quick example, you first have a Python variable containing a string object, . Then, you create a new string using an f-string. In this string, you insert the content of your variable using a replacement field. When you run this last line of code, Python builds a final string, . The insertion of into the f-string is an interpolation. Note: To dive deeper into string interpolation, check out the String Interpolation in Python: Exploring Available Tools tutorial. When you do string interpolation, you may need to format the interpolated values to produce a well-formatted final string. To do this, you can use different string interpolation tools that support string formatting. In Python, you have these three tools: The first two tools support the string formatting mini-language, a feature that allows you to fine-tune your strings. The third tool is a bit old and has fewer formatting options. However, you can use it to do some minimal formatting. Note: The built-in function is yet another tool that supports the format specification mini-language. This function is typically used for date and number formatting, but you won’t cover it in this tutorial. In the following sections, you’ll start by learning a bit about the string formatting mini-language. Then, you’ll dive into using this language, f-strings, and the method to format your strings. Finally, you’ll learn about the formatting capabilities of the modulo operator.\n\nPython 3.6 added a string interpolation and formatting tool called formatted string literals, or f-strings for short. As you’ve already learned, f-strings let you embed Python objects and expressions inside your strings. To create an f-string, you must prefix the string with an or and insert replacement fields in the string literal. Each replacement field must contain a variable, object, or expression: In the first example, you define an f-string that embeds the number directly into the resulting string. In the second example, you insert two variables and an expression into the string. Formatted string literals are a Python parser feature that converts f-strings into a series of string constants and expressions. These are then joined up to build the final string. Using the Formatting Mini-Language With F-Strings When you use f-strings to create strings through interpolation, you need to use replacement fields. In f-strings, you can define a replacement field using curly brackets ( ) as in the examples below: Inside the brackets, you can insert Python objects and expressions. In this example, you’d like the resulting string to display the currency values using a proper format. However, you get a string that shows the currency values with at most one digit on its decimal part. To format the values and always display two digits on its decimal part, you can use a format specifier: In this example, note that each replacement field contains a string that starts with a colon. That’s a format specifier. The part tells Python that you want to format the value as a floating-point number ( ) with two decimal places ( ). Note: To learn more about the formatting mini-language and its syntax, check out the Python’s Format Mini-Language for Tidy Strings tutorial. If you’re interested in formatting floating-point numbers specifically, then you can also read How to Format Floats Within F-Strings in Python. The string formatting mini-language is a powerful tool with several cool features, including the following: In the following sections, you’ll explore how to use f-strings, the method, and the string formatting mini-language to format the values that you insert into your strings through interpolation. You can use f-strings and the string formatting mini-language to format the values that you interpolate into your strings in multiple ways. To illustrate, say that you want to write a Python function to build a grades report for your students. The student data is in a dictionary that looks like the following: \"Needs to participate more.\" The dictionary has the key to store the student’s name. Then, it has the key to hold a list of dictionaries containing the student’s performance in each subject. Your function may look like the following: Thank you for reviewing the progress report. In this function, you’re doing several things. Here’s a line-by-line breakdown:\n• Line 5 computes the average of the grades.\n• Line 6 defines the average grade subreport. In this part of the report, you use the format specifier to express the average grade as a floating-point number with two decimal places.\n• Line 8 defines the first line of the subject subreport.\n• Line 10 adds more information to the subject subreport.\n• Line 11 formats the subject’s name. To do this, you use the format specifier, which tells Python to align the name to the left within characters.\n• Line 12 formats the grade. In this case, the format specifier tells Python to display the grade using up to three characters. A leading space is used if the grade doesn’t have three digits.\n• Lines 16 to 21 build the final report and return it to the caller. Now that you’ve gone through the complete code, it’s time to try out your function. Go ahead and run the following code: History Grade: 78 Comment: Needs to participate more. Thank you for reviewing the progress report. Your report looks pretty nice! It provides general information about the student at the top and grade details for every subject.\n\nYou can also use the method to format values during string interpolation. In most cases, you’d use the method for lazy interpolation. In this type of interpolation, you define a template string in some part of your code and then interpolate values in another part: In both examples, you create a string template and then use the method to interpolate the required values. Using the Formatting Mini-Language With The method also supports the string formatting mini-language. This feature allows you to nicely format the interpolated values when you create strings through interpolation. To illustrate, consider the example you wrote in the section about using the formatting mini-language with f-strings. Here’s how to do it with the method: Again, the resulting string displays the currency values using a proper format that shows two decimal places. Now it’s time for a couple of practical examples of using the method and the string formatting mini-language to format your strings. For the first example, say that you need to create a sales report for your company. You’d like to create a report template and fill it with the appropriate data when someone requires it. In this situation, you can create the following report template: In this report template, you have a few format specifiers. Here’s a summary of their specific meanings:\n• displays the interpolated value aligned to the right within a space of characters. The dot after the colon works as the fill character. The other format specifiers, and , have a similar effect. Note that the field widths were chosen by trial and error to make the report line up nicely.\n• displays the preceding number using a comma as the thousands separator.\n• shows a value as a floating-point number using two decimal places and a comma as the thousands separator. Now, you can code a function to generate the actual report: This function takes the sales data and the report template as arguments. Then, it computes the required values and calls on the template. Go ahead and give this function a try by running the following code: Cool! You have a nicely formatted sales report. You can experiment on your own and tweak the format specifiers further as an exercise. For example, you can improve the date format. However, note that dates have their own formatting, which you can learn about in the Formatting Dates section of the tutorial about Python’s string formatting mini-language. You can also take advantage of the method when your data is stored in dictionaries. For example, here’s how you can update the function using the method: Thank you for reviewing the progress report. In the first lines of code, you create string templates to display the information about each subject and also the final report. In , you create a dictionary with the required data to build the student report. Next, you interpolate the data into the report template using with the dictionary as an argument. Note that to fill the string templates, you use the operator to unpack the data from the input dictionary.\n\nStrings in Python have a built-in operation that you can access with the modulo operator ( ). This operator lets you do positional and named string interpolation. If you’ve ever worked with the function in C, then the syntax will be familiar. Here’s a toy example: The substring is a conversion specifier that works as a replacement field. It tells Python where to substitute the value of , represented as a string. To build a conversion specifier, you need two or more characters. Here’s a quick summary of the accepted characters and their corresponding order in the specifier:\n• The character marks the start of the specifier.\n• An optional mapping key in parentheses allows you to use named replacement fields like .\n• An optional conversion flag affects how some conversion types display.\n• An optional minimum field width allows you to define the number of characters to display.\n• An optional precision consists of a dot character ( ) followed by the desired precision.\n• An optional length modifier is an or for long and short integers.\n• A conversion type specifies how the output string will be formatted, mimicking different data types. Several conversion types are available for the modulo operator in Python. They allow you to control the output’s format in some way. For example, you can convert numbers to hexadecimal notation or add whitespace padding to generate nicely formatted tables and reports. Here’s a summary of the conversion types currently available in Python: A percentage character ( ) in the result if no argument is converted With all these conversion types, you can process your interpolated values to display them using different representation types. Note: It’s important to note that f-strings and the method also support the conversion types listed above. For details on this topic, check out the Converting Between Type Representations section in the Python’s Format Mini-Language for Tidy Strings tutorial. Here are a few examples of how to use some of the above specifiers in your strings: In these examples, you’ve used different conversion types to display values using different type representations. Now, check out the examples below to see other formatting options in action: In the first example, you use named replacement fields in parentheses and a dictionary to provide the values you want to interpolate. In the second example, you provide a minimum width for your string in characters. The third example is a dynamic variation of the second. Note how the symbol allows you to insert the desired width dynamically. Finally, you use the precision option to display a floating-point number using different precisions. You use two, four, and eight digits after the decimal separator, respectively. Unfortunately, the modulo operator doesn’t support the string formatting mini-language, so if you use this tool to interpolate and format your strings, then your formatting options are more limited than when you use f-strings or . The modulo operator also supports what’s known as conversion flags. Here’s a quick summary of the currently available flags: Left-justifies the value (overrides the conversion if both are given) Adds a sign character ( or ) before the value These flags help you apply some additional formatting options to your strings. Consider the following quick examples: In these examples, you demonstrate the effect of the flag, which prepends the appropriate prefix to the input number depending on the base you use. This flag is mostly used with integer values. Here are some more examples of using different flags: In the first example, you add zero padding to the input value. Next, you have an example of how to use the minus sign to align a value to the left in a width of ten characters. The space flag allows you to add a space before positive numbers. This space disappears when the value is negative. Finally, you use the plus sign so the string always displays whether the input value is positive or negative.\n\nDeciding Which String Formatting Tool to Use You’ve learned about three different tools for string formatting up to this point. Having several choices for one task can be confusing. In the end, what tool should you use? If you want readable syntax, good performance, and you’re doing eager interpolation, then f-strings are for you. On the other hand, if you need a tool for doing lazy string interpolation, then the method is the way to go. In contrast, the modulo operator ( ) is an old-fashioned tool not commonly used in modern Python. You could say that this tool is almost dead. However, you may find it in legacy Python code, so it’s good to know how it works. The following table compares the three tools using several comparison criteria: F-strings are the clear winner in terms of readability. However, they don’t allow you to do lazy interpolation. There’s no way to use an f-string to create a reusable string template that you can interpolate later in your code. If you want a universal tool with all the features, then the method is the way to go.\n\nNow that you have some experience with string formatting tools in Python, you can use the questions and answers below to check your understanding and recap what you’ve learned. These FAQs are related to the most important concepts you’ve covered in this tutorial. Click the Show/Hide toggle beside each question to reveal the answer: What is string formatting in Python?Show/Hide String formatting in Python is the process of applying a specific format to a given value when creating a new string through interpolation. This allows you to embed variables and expressions into strings and control the appearance of the resulting output. How do you format a string in Python?Show/Hide You can format a string in Python using several methods: f-strings, the method, and the modulo operator ( ). What are the different types of string formatting in Python?Show/Hide The different types of string formatting in Python include f-strings for embedding expressions inside string literals, the method for creating string templates and filling them with values, and the modulo operator ( ), an older method used in legacy code similar to C’s function. Which string formatting method is best in Python?Show/Hide The string formatting method you choose will depend on the use case. While f-strings are best for readability and performance in modern Python and ideal for eager interpolation, the method is useful for lazy interpolation and when you need reusable templates. The modulo operator ( ), on the other hand, is mostly for maintaining legacy code and isn’t recommended for new projects. Python’s string formatting mini-language offers several features, including string alignment, type conversion, numeric formatting, and dynamic formatting. These features provide enhanced control over how interpolated values are presented in the final string. Get Your Code: Click here to download the free sample code you’ll use to learn about Python’s string formatting tools. Test your knowledge with our interactive “Python String Formatting: Available Tools and Their Features” quiz. You’ll receive a score upon completion to help you track your learning progress: Python String Formatting: Available Tools and Their Features You can take this quiz to test your understanding of the available tools for string formatting in Python, as well as their strengths and weaknesses. These tools include f-strings, the .format() method, and the modulo operator."
    }
]