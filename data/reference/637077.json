[
    {
        "link": "https://en.wikipedia.org/wiki/ASCII_art",
        "document": "ASCII art is a graphic design technique that uses computers for presentation and consists of pictures pieced together from the 95 printable (from a total of 128) characters defined by the ASCII Standard from 1963 and ASCII compliant character sets with proprietary extended characters (beyond the 128 characters of standard 7-bit ASCII). The term is also loosely used to refer to text-based visual art in general. ASCII art can be created with any text editor, and is often used with free-form languages. Most examples of ASCII art require a fixed-width font (non-proportional fonts, as on a traditional typewriter) such as Courier or Consolas for presentation.\n\nAmong the oldest known examples of ASCII art are the creations by computer-art pioneer Kenneth Knowlton from around 1966, who was working for Bell Labs at the time.[1] \"Studies in Perception I\" by Knowlton and Leon Harmon from 1966 shows some examples of their early ASCII art.[2]\n\nASCII art was invented, in large part, because early printers often lacked graphics ability and thus, characters were used in place of graphic marks. Also, to mark divisions between different print jobs from different users, bulk printers often used ASCII art to print large banner pages, making the division easier to spot so that the results could be more easily separated by a computer operator or clerk.[3] ASCII art was also used in early e-mail when images could not be embedded.\n\nSince 1867, typewriters have been used for creating visual art.[better source needed][4][5] Typists could find guides in books or magazines with instructions on how to type portraits or other depictions.[6]\n\nTTY stands for \"TeleTYpe\" or \"TeleTYpewriter\", and is also known as Teleprinter or Teletype. RTTY stands for Radioteletype; character sets such as Baudot code, which predated ASCII, were used. According to a chapter in the \"RTTY Handbook\", text images have been sent via teletypewriter as early as 1923.[7] However, none of the \"old\" RTTY art has been discovered yet. What is known is that text images appeared frequently on radioteletype in the 1960s and the 1970s.[4][8]\n\nIn the 1960s, Andries van Dam published a representation of an electronic circuit produced on an IBM 1403 line printer.[9] At the same time, Kenneth Knowlton was producing realistic images, also on line printers, by overprinting several characters on top of one another.[2] Note that it was not ASCII art in a sense that the 1403 was driven by an EBCDIC-coded platform and the character sets and trains available on the 1403 were derived from EBCDIC rather than ASCII, despite some glyphs commonalities.\n\nThe widespread usage of ASCII art can be traced to the computer bulletin board systems of the late 1970s and early 1980s. The limitations of computers of that time period necessitated the use of text characters to represent images. Along with ASCII's use in communication, however, it also began to appear in the underground online art groups of the period.\n\nAn ASCII comic is a form of webcomic which uses ASCII text to create images. In place of images in a regular comic, ASCII art is used, with the text or dialog usually placed underneath.[10]\n\nDuring the 1990s, graphical browsing and variable-width fonts became increasingly popular, leading to a decline in ASCII art. Despite this, ASCII art continued to survive through online MUDs, an acronym for \"Multi-User Dungeon\", (which are textual multiplayer role-playing video games), Internet Relay Chat, Email, message boards, and other forms of online communication which commonly employ the needed fixed-width.\n\nASCII art is seen to this day on the CLI app Neofetch, which displays the logo of the OS on which it is invoked.[11][12]\n\nASCII and more importantly, ANSI were staples of the early technological era; terminal systems relied on coherent presentation using color and control signals standard in the terminal protocols.\n\nOver the years, warez groups began to enter the ASCII art scene.[13] Warez groups usually release .nfo files with their software, cracks or other general software reverse-engineering releases.[14] The ASCII art will usually include the warez group's name and maybe some ASCII borders on the outsides of the release notes, etc.[15]\n\nBBS systems were based on ASCII and ANSI art, as were most DOS and similar console applications, and the precursor to AOL.\n\nASCII art is used wherever text can be more readily printed or transmitted than graphics, or in some cases, where the transmission of pictures is not possible. This includes typewriters, teleprinters, non-graphic computer terminals, printer separators, in early computer networking (e.g., BBSes), email, and Usenet news messages. ASCII art is also used within the source code of computer programs for representation of company or product logos, and flow control or other diagrams. In some cases, the entire source code of a program is a piece of ASCII art – for instance, an entry to one of the earlier International Obfuscated C Code Contest is a program that adds numbers, but visually looks like a binary adder drawn in logic ports.[16]\n\nSome electronic schematic archives represent the circuits using ASCII art.[17][18][19][20][21][22][23][24][25][26][27][excessive citations]\n\nExamples of ASCII-style art predating the modern computer era can be found in the June 1939, July 1948 and October 1948 editions of Popular Mechanics.[28]\n\nEarly computer games played on terminals frequently used ASCII art to simulate graphics, most notably the roguelike genre using ASCII art to visually represent dungeons and monsters within them.[29] \"0verkill\" is a 2D platform multiplayer shooter game designed entirely in color ASCII art.[30] MPlayer and VLC media player can display videos as ASCII art through the AAlib library. ASCII art is used in the making of DOS-based ZZT games.\n\nMany game walkthrough guides come as part of a basic .txt file; this file often contains the name of the game in ASCII art. Such as below, word art is created using backslashes and other ASCII values in order to create the illusion of 3D.\n\nDifferent techniques could be used in ASCII art to obtain different artistic effects.\n\nShading, using symbols with various intensities for creating gradients or contrasts:\n\nCombinations of the above, often used as signatures, for example, at the end of an email:\n\nAs-pixel characters use combinations of ░ , █ , ▄, ▀ (Block Elements), and/or ⣿, ⣴, ⢁, etc (Braille ASCII) to make pictures:\n\nThe simplest forms of ASCII art are combinations of two or three characters for expressing emotion in text. They are commonly referred to as 'emoticon', 'smilie', or 'smiley'. There is another type of one-line ASCII art that does not require the mental rotation of pictures, which is widely known in Japan as kaomoji (literally \"face characters\".)\n\nMore complex examples use several lines of text to draw large symbols or more complex figures. Hundreds of different text smileys have developed over time,[32] but only a few are generally accepted, used and understood.\n\nAn ASCII comic is a form of webcomic.[citation needed]\n\n'The Adventures of Nerd Boy', or just 'Nerd Boy', was an ASCII comic, published by Joaquim Gândara between 5 August 2001 and 17 July 2007, and consisting of 600 strips. They were posted to ASCII art newsgroup alt.ascii-art and on the website.[33] Some strips have been translated to Polish[34][35] and French.\n\nThe Atari 400/800, which were released in 1979, did not follow the ASCII standard and had their own character set, called ATASCII.[36][37][failed verification] The emergence of ATASCII art coincided with the growing popularity of BBS Systems caused by availability of the acoustic couplers that were compatible with the 8-bit home computers. ATASCII text animations are also referred to as \"break animations\" by the Atari sceners.\n\nThe Commodore 64, which was released in 1982, also did not follow the ASCII standard. The C-64 character set is called PETSCII, an extended form of ASCII-1963. As with the Atari's ATASCII art, C-64 fans developed a similar scene that used PETSCII for their creations.\n\nSo-called \"block ASCII\" or \"high ASCII\" uses the extended characters of the 8-bit code page 437, which is a proprietary standard introduced by IBM in 1979 (ANSI Standard x3.16) for the IBM PC DOS and MS-DOS operating systems. \"Block ASCIIs\" were widely used on the PC during the 1990s until the Internet replaced BBSes as the main communication platform. Until then, \"block ASCIIs\" dominated the PC Text Art Scene.[38][39]\n\nThe first art scene group that focused on the extended character set of the PC in their artwork was called \"Aces of ANSI Art\", or <A.A.A>. Some members left in 1990 and formed a group called \"ANSI Creators in Demand\", or ACiD. In that same year the second major underground art scene group \"Insane Creators Enterprise\", or ICE, was founded.[40]\n\nThere is some debate between ASCII and block ASCII artists, with \"Hardcore\" ASCII artists maintaining that block ASCII art is in fact not ASCII art, because it does not use the 128 characters of the original ASCII standard. On the other hand, block ASCII artists argue that if their art uses only characters of the computer's character set, then it is to be called ASCII, regardless if the character set is proprietary or not.\n\nMicrosoft Windows does not support the ANSI Standard x3.16. One can view block ASCIIs with a text editor using the font \"Terminal\", but it will not look exactly as it was intended by the artist. With a special ASCII/ANSI viewer, such as ACiDView for Windows (see: § ASCII and ANSI art), one can see block ASCII and ANSI files properly. An example that illustrates the difference in appearance is part of this article. Alternatively, one could look at the file using the TYPE command in the command prompt.\n\nIn the art scene one popular ASCII style that used the 7-bit standard ASCII character set was the so-called \"Oldskool\" style. It is also called \"Amiga style\", due to its origin and widespread use on Commodore Amiga computers. The style uses primarily the characters and looks more like the outlined drawings of shapes than real pictures. The accompanying image is an example of \"Amiga style\" (also referred to as \"old school\" or \"oldskool\" style) scene ASCII art.[38]\n\nThe Amiga ASCII scene surfaced in 1992, seven years after the introduction of the Commodore Amiga 1000. The Commodore 64 PETSCII scene did not make the transition to the Commodore Amiga as the C64 demo and warez scenes did. Among the first Amiga ASCII art groups were ART, Epsilon Design, Upper Class, Unreal (later known as \"DeZign\"). This means that the text art scene on the Amiga was actually younger than the text art scene on the PC. The Amiga artists also did not call their ASCII art style \"Oldskool\". That term was introduced on the PC; when and by whom is unknown and lost to history.\n\nThe Amiga style ASCII artwork was most often released in the form of a single text file, which included all the artwork (usually requested), with some design parts in between, as opposed to the PC art scene where the art work was released as a ZIP archive with separate text files for each piece. Furthermore, the releases were usually called \"ASCII collections\" and not \"art packs\" like on the IBM PC.\n\nThis kind of ASCII art is handmade in a text editor. Popular editors used to make this kind of ASCII art include Microsoft Notepad, CygnusEditor also known as CED (Amiga), and EditPlus2 (PC).\n\nThe accompanying image shows an Oldskool font example done with the ASCII editor FIGlet on a PC.\n\n\"Newskool\" is a popular form of ASCII art which capitalizes on character strings like \"$#Xxo\". In spite of its name, the style is not \"new\"; on the contrary, it was very old but fell out of favor and was replaced by \"Oldskool\" and \"Block\" style ASCII art. It was dubbed \"Newskool\" upon its comeback and renewed popularity at the end of the 1990s.[38]\n\nNewskool changed significantly as the result of the introduction of extended proprietary characters. The classic 7-bit standard ASCII characters remain predominant, but the extended characters are often used for \"fine tuning\" and \"tweaking\". The style developed further after the introduction and adaptation of Unicode.\n\nWhile some prefer to use a simple text editor to produce ASCII art, specialized programs, such as JavE have been developed that often simulate the features and tools in bitmap image editors. For Block ASCII art and ANSI art the artist almost always uses a special text editor, because to generate the required characters on a standard keyboard, one needs to know the Alt code for each character. For example, + will produce ▓, + will produce ▒, and + will produce ◘.\n\nThe special text editors have sets of special characters assigned to existing keys on the keyboard. Popular DOS-based editors, such as TheDraw and ACiDDraw had multiple sets of different special characters mapped to the function keys to make the use of those characters easier for the artist who can switch between individual sets of characters via basic keyboard shortcuts. PabloDraw is one of the very few special ASCII/ANSI art editors that was developed for Windows.\n\nOther programs allow one to automatically convert an image to text characters, which is a special case of vector quantization. A method is to sample the image down to grayscale with less than 8-bit precision, and then assign a character for each value. Such ASCII art generators often allow users to choose the intensity and contrast of the generated image.[41]\n\nThree factors limit the fidelity of the conversion, especially of photographs:\n• ratio (solutions with compatibility issues: font with a square grid; stylized without extra line spacing).\n\nExamples of converted images are given below.\n\nThis is one of the earliest forms of ASCII art, dating back to the early days of the 1960s minicomputers and teletypes. During the 1970s, it was popular in US malls to get a t-shirt with a photograph printed in ASCII art on it from an automated kiosk containing a computer, and London's Science Museum had a similar service to produce printed portraits. With the advent of the web, HTML and CSS, many ASCII conversion programs will now quantize to a full RGB colorspace, enabling colorized ASCII images.\n\nStill images or movies can also be converted to ASCII on various UNIX and UNIX-like systems using the AAlib (black and white) or libcaca (colour) graphics device driver, or the VLC media player or mpv under Windows, Linux or macOS; all of which render the screen using ASCII symbols instead of pixels.[42]\n\nThere are also a number of smartphone applications, such as ASCII cam for Android, that generate ASCII art in real-time using input from the phone's camera. These applications typically allow the ASCII art to be saved as either a text file or as an image made up of ASCII text.\n\nMost ASCII art is created using a monospaced font, such as Courier, where all characters are identical in width. Early computers in use when ASCII art came into vogue had monospaced fonts for screen and printer displays. Today, most of the more commonly used fonts in word processors, web browsers and other programs are proportional fonts, such as Helvetica or Times Roman, where different widths are used for different characters. ASCII art drawn for a fixed width font will usually appear distorted, or even unrecognizable when displayed in a proportional font.\n\nSome ASCII artists have produced art for display in proportional fonts. These ASCIIs, rather than using a purely shade-based correspondence, use characters for slopes and borders and use block shading. These ASCIIs generally offer greater precision and attention to detail than fixed-width ASCIIs for a lower character count, although they are not as universally accessible since they are usually relatively font-specific.\n\nAnimated ASCII art started in 1970 from so-called VT100 animations produced on VT100 terminals. These animations were simply text with cursor movement instructions, deleting and erasing the characters necessary to appear animated. Usually, they represented a long hand-crafted process undertaken by a single person to tell a story.\n\nContemporary web browser revitalized animated ASCII art again. It became possible to display animated ASCII art via JavaScript or Java applets. Static ASCII art pictures are loaded and displayed one after another, creating the animation, very similar to how movie projectors unreel film reel and project the individual pictures on the big screen at movie theaters. A new term was born: \"ASCIImation\" – another name of animated ASCII art. A seminal work in this arena is the Star Wars ASCIImation.[43] More complicated routines in JavaScript generate more elaborate ASCIImations showing effects like Morphing effects, star field emulations, fading effects and calculated images, such as mandelbrot fractal animations.[44][45]\n\nThere are now many tools and programs that can transform raster images into text symbols; some of these tools can operate on streaming video. For example, the music video for American singer Beck's song \"Black Tambourine\"[46] is made up entirely of ASCII characters that approximate the original footage. VLC, a media player software, can render any video in colored ASCII through the libcaca module.\n\nThere are a variety of other types of art using text symbols from character sets other than ASCII and/or some form of color coding. Despite not being pure ASCII, these are still often referred to as \"ASCII art\". The character set portion designed specifically for drawing is known as the line drawing characters or pseudo-graphics.\n\nThe IBM PC graphics hardware in text mode uses 16 bits per character. It supports a variety of configurations, but in its default mode under DOS they are used to give 256 glyphs from one of the IBM PC code pages (Code page 437 by default), 16 foreground colors, eight background colors, and a flash option. Such art can be loaded into screen memory directly. ANSI.SYS, if loaded, also allows such art to be placed on screen by outputting escape sequences that indicate movements of the screen cursor and color/flash changes. If this method is used then the art becomes known as ANSI art. The IBM PC code pages also include characters intended for simple drawing which often made this art appear much cleaner than that made with more traditional character sets. Plain text files are also seen with these characters, though they have become far less common since Windows GUI text editors (using the Windows ANSI code page) have largely replaced DOS-based ones.\n\nIn Japan, ASCII art (AA) is mainly known as Shift_JIS art. Shift JIS offers a larger selection of characters than plain ASCII (including characters from Japanese scripts and fullwidth forms of ASCII characters), and may be used for text-based art on Japanese websites.\n\nOften, such artwork is designed to be viewed with the default Japanese font on a platform, such as the proportional MS P Gothic.[47]\n\nUsers on ASCII-NET, in which the word ASCII refers to the ASCII Corporation rather than the American Standard Code for Information Interchange, popularised a style of emoticon (顔文字, kaomoji, emoticon) in which the face appears upright rather than rotated.\n\nUnicode would seem to offer the ultimate flexibility in producing text based art with its huge variety of characters. However, finding a suitable fixed-width font is likely to be difficult if a significant subset of Unicode is desired. (Modern UNIX-style operating systems do provide complete fixed-width Unicode fonts, e.g. for xterm. Windows has the Courier New font, which includes characters like ┌ ╥ ─ ╨ ┐♥ ☺ Ƹ̵̡ Ӝ̵̨̄ Ʒ). Also, the common practice of rendering Unicode with a mixture of variable width fonts is likely to make predictable display hard, if more than a tiny subset of Unicode is used. ≽ʌⱷ҅ ⱷʌ≼ is an adequate representation of a cat's face in a font with varying character widths.\n\nThe combining characters mechanism of Unicode provides considerable ways of customizing the style, even obfuscating the text (e.g. via an online generator like Obfuscator,[48] which focuses on the filters[49]). 'Glitcher' is one example of Unicode art, initiated in 2012: \"These symbols, intruding up and down, are made by combining lots of diacritical marks. It’s a kind of art. There’s quite a lot of artists who use the Internet or specific social networks as their canvas.\"[50] The corresponding creations are favored in web browsers (thanks to their always better support[51]), as geekily stylized usernames for social networks. With a fair compatibility, and among different online tools, Facebook symbols[52] showcases various types of Unicode art, mainly for aesthetic purpose (Ɯıḳĭƥḙȡḯả Wîkipêȡıẚ Ẉǐḳîṗȅḍȉā Ẃįḵįṗẻḑìẵ Ẉĭḵɪṕḗdïą Ẇïƙỉpểɗĭà Ẅȉḱïṕȩđĩẵ etc.). Besides, the creations can be hand-crafted (by programming), or pasted from mobile applications (e.g. the category of 'fancy text'[53] tools on Android). The underlying technique dates back to the old systems that incorporated control characters, though. E.g. the German composite would be imitated on ZX Spectrum by overwriting[54] after backspace and .\n\nIn the 1970s and early 1980s it was popular to produce a kind of text art that relied on overprinting. This could be produced either on a screen or on a printer by typing a character, backing up, and then typing another character, just as on a typewriter. This developed into sophisticated graphics in some cases, such as the PLATO system (circa 1973), where superscript and subscript allowed a wide variety of graphic effects. A common use was for emoticons, with WOBTAX and VICTORY both producing convincing smiley faces.[55] Overprinting had previously been used on typewriters, but the low-resolution pixelation of characters on video terminals meant that overprinting here produced seamless pixel graphics, rather than visibly overstruck combinations of letters on paper.\n\nBeyond pixel graphics, this was also used for printing photographs, as the overall darkness of a particular character space dependent on how many characters, as well as the choice of character, were printed in a particular place. Thanks to the increased granularity of tone, photographs were often converted to this type of printout. Even manual typewriters or daisy wheel printers could be used. The technique has fallen from popularity since all cheap printers can easily print photographs, and a normal text file (or an e-mail message or Usenet posting) cannot represent overprinted text. However, something similar has emerged to replace it: shaded or colored ASCII art, using ANSI video terminal markup or color codes (such as those found in HTML, IRC, and many internet message boards) to add a bit more tone variation. In this way, it is possible to create ASCII art where the characters only differ in color.\n• media4u.ch - ASCII Art Archived 2019-08-21 at the Wayback Machine (ASCII Art Movie. The Matrix in ASCII Art)"
    },
    {
        "link": "https://ttwong12.github.io/papers/asciiart/asciiart.pdf",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/30097953/ascii-art-sorting-an-array-of-ascii-characters-by-brightness-levels-c-c",
        "document": "ASCII characters have no intrinsic grayness, because this only depends on how they are drawn on your screen - in what font, size, and horizontal and vertical spacing, and in what colors.\n\nStill: it's possible to make an educated guess. A space is 'all white' for most fonts, a full stop will be a small dot in most fonts, a comma is slightly larger, et cetera. All you need is the ratio of black-to-white pixels, for each displayable character.\n• None Find (or create) a bitmapped version of the font you are going to use, or one close to it. Since most ASCII fonts are actually very close in their design, you can even use a simple 8x8 bitmap font (not many fonts will have a that is \"heavier\" than a - if you find one that does, find another). As you are going to use it for ASCII art, you probably want monospaced fonts only. Drawing ASCII art with proportional fonts is possible but much harder.\n• None Loop over each character and count the black pixels. Typically, a space will have , a full stop , and something like a will have 16 or so. (Hey look! This is where you can use a loop!)\n• None The exact grayness of each character can be represented by where is the entire size of the bitmap. But you are not interested in the absolute value! A normal ASCII range does not contain a character that should be \"all black\". To find out the relative grayness, divide the value for each character by the maximum value you found for the entire font. That way, the space will be , the \"maximum value\" character will be , and all other characters will have a value in between. (Actually, if your Space character contains black pixels, subtract these from the initial values as well. Just to outline the general idea; you'd better not use such a weird font.)\n• None You will end up with 95 values - one for each from Space (#32) to Tilde (#126). If you want to use all characters in your output, you are ready to go. Sort the characters on their gray level. For each gray input pixel (a level from 0 to 255), divide it by 255 to get it into the same range as your character map value. Then print the character with a level closest to it. (This is the most straightforward method but can be optimized in various ways.)\n• None If you want to restrict the grayscale to a smaller range of values/characters, build a smaller array with values closest to the levels you want. For example, if you want 16 levels of gray, find the characters closest to 0, 1/15, 2/15 ... 15/15.\n\nSee also Step 5 and 6 of my answer to a related question."
    },
    {
        "link": "https://medium.com/@gehnaahuja011/image-to-ascii-art-e7eb671e1d69",
        "document": "Just like the Image shown below!!! 🤩\n\nASCII art is a way of creating pictures using characters from the ASCII (American Standard Code for Information Interchange) character set. Because these characters are easy to display in text-based systems, ASCII art became popular in environments where graphics were limited, like early computers and command-line interfaces.\n\nEven in today’s world, where digital images are everywhere, converting an image into ASCII art is still a fun and interesting challenge. The process works by taking an image, resizing it to fit a text-based format, converting it to grayscale, and then mapping the brightness of each pixel to a character like @, #, etc.. The result is a picture made entirely out of text, with different characters representing different shades of brightness.\n\nThis technique has practical uses, especially in places where displaying actual images isn’t possible, like in old systems or text-based environments. But it’s also a cool form of digital art that appeals to people who enjoy retro or minimalist designs. Whether for creative projects, coding experiments, or just for fun, ASCII art offers a simple yet unique way to represent images using only text.\n\nThere are several ways to create ASCII art in Python, ranging from basic manual designs to complex image-to-ASCII conversions.\n• The simplest method involves manually creating ASCII art by typing it out using statements.\n• You can use loops to generate repeating patterns, which are often seen in geometric ASCII art.\n• Several libraries can help generate ASCII art from images or strings.\n• Art is a Python library that allows for text-based ASCII art creation, using pre-defined styles or custom text.\n• pyfiglet library is used to generate large ASCII text in various fonts.\n\nNow that we have a grasp of creating ASCII art from text, let’s transition to the main purpose of this article: converting images to ASCII format. This process involves taking an image, converting it into grayscale, and then mapping pixel brightness to ASCII characters.\n\nCreating ASCII art from images generally involves a series of common steps, regardless of the specific method or library used. Here are the typical steps involved:\n• Read the image file using an appropriate library (e.g., OpenCV, PIL, etc.).\n• Resize the image to fit within a text-based canvas. This often involves adjusting the width while maintaining the aspect ratio, since ASCII characters are taller than they are wide.\n• Convert the image to grayscale. This simplifies the data by removing color information, focusing solely on brightness levels.\n• Define a set of ASCII characters that represent different brightness levels. Darker pixels might be represented by characters like or , while lighter pixels could be represented by characters like or spaces.\n• Map each pixel’s intensity to the corresponding ASCII character based on its brightness.\n• Create a text-based representation of the image using the mapped ASCII characters, maintaining the original structure of the image as much as possible.\n• Print the ASCII art to the terminal, save it to a file, or display it in a graphical interface, depending on the application’s requirements.\n\nThe provided code utilizes the Pillow library to convert images into ASCII art by mapping pixel brightness to ASCII characters. It begins by defining a set of ASCII characters sorted by increasing brightness, from dark characters like @ to light characters such as a space. The code includes a background_char, which is set to a space, used to represent lighter areas of the image. The resize_image function adjusts the image size to a specified width (defaulting to 50 pixels) while maintaining the aspect ratio by calculating a new height based on the original dimensions. This resizing is crucial for ensuring that the ASCII art maintains the correct proportions and fits within the terminal or display area.\n\nThe core of the conversion process is handled by the convert_image_to_ascii function, which takes an image path and processes the image through several steps. First, it opens the image file using Image.open(), then it calls resize_image to adjust the dimensions. After resizing, the image is converted to grayscale using the image_to_grayscale function, which simplifies the pixel data by representing it in shades of gray. This grayscale representation allows for more straightforward mapping of brightness levels to ASCII characters. The pixel_to_ascii function iterates through the pixel values, where each pixel is evaluated against a threshold (defaulted to 210) that determines whether it should be treated as background noise or as part of the actual image.\n\nIn the pixel_to_ascii function, pixel values above the threshold are mapped to the background_char, effectively filtering out lighter areas, while darker pixels are converted into corresponding ASCII characters based on their intensity levels. The pixel values are divided by 32 to fit them within the range of available ASCII characters, as there are 256 possible grayscale values. The final step formats the resulting ASCII string into a list of strings that match the new width, creating a neat and organized output. By tweaking the width and threshold values, users can customize the ASCII art to suit their preferences, allowing for a personalized and visually appealing representation of any image.\n\nIn this approach, we use the K-means clustering algorithm from the scikit-learn library to reduce the color palette of an image before converting it to ASCII art. This method begins by reading the image using OpenCV, which is a powerful library for image processing. The first step is resizing the image to a manageable width while maintaining its aspect ratio. This is important because a smaller image can be processed faster and will yield a clearer ASCII representation when displayed in a terminal or text editor. By reducing the width to 50 pixels, we ensure that the final ASCII output fits well on the screen without distorting the image’s proportions.\n\nAfter resizing, we apply the K-means algorithm to simplify the image’s color palette. K-means works by clustering the pixel colors into a specified number of groups, which we can adjust with the n_colors parameter. For example, if we set n_colors to 32, K-means will reduce the image to 32 dominant colors. This is achieved by reshaping the image into a 2D array where each row corresponds to a pixel’s RGB color values. The K-means algorithm then identifies clusters of similar colors and replaces each pixel’s color with the average color of its respective cluster. This color reduction not only helps in simplifying the image but also enhances the overall visual representation when converting to ASCII art.\n\nOnce the image has been simplified, we convert it to grayscale using OpenCV’s cvtColor function, which allows us to focus on pixel intensity rather than color. The grayscale image is then processed pixel by pixel; each pixel’s brightness is compared against a predefined threshold (set at 210 by default). Pixels brighter than this threshold are mapped to a background character (a space, in this case), while darker pixels are translated into ASCII characters based on their intensity. The mapping is done using an array of ASCII characters, where each character corresponds to a specific brightness level. This allows for a nuanced representation of the image, capturing details in dark and light areas effectively. Finally, the ASCII characters are formatted into lines that match the new width, producing a visual representation that resembles the original image, albeit in a text-based format.\n\nCreating ASCII art comes with its own set of challenges that can affect how well the final piece represents the original image.\n\n1. Loss of Detail: One of the biggest hurdles with ASCII art is that it can’t capture intricate details very well. ASCII characters are generally larger than the individual pixels in an image, which means that finer details can get lost during the conversion process. When dealing with complex images that have intricate patterns or subtle gradients, the transformation into ASCII may lead to a simplified version that can sometimes be unrecognizable. Striking the right balance between retaining detail and keeping the overall dimensions of the ASCII representation in check requires careful thought about both the character set and the size of the image.\n\n2. Character Selection and Density: Choosing the right ASCII characters is vital for accurately conveying an image. Different characters have varying levels of visual density; for example, the character ‘@’ appears much darker than ‘.’. Because of this, it can be a challenge to pick a character set that effectively reflects the brightness levels of the original image. Additionally, since ASCII characters are of fixed width and height, this can lead to distortion when the output is viewed in environments that don’t use a monospaced font. Therefore, users often need to experiment with different characters and sizes to get the best visual result.\n\n3. Handling Color and Brightness Variations: Images usually feature a broad range of colors and brightness levels, and mapping these variations to a limited selection of ASCII characters is no easy task. The thresholding process, which determines how pixel brightness is translated into ASCII, can vary significantly from one image to another. A single threshold might work perfectly for one image but fall flat for another with different lighting. To improve the output quality, we might need to use adaptive techniques that take varying light conditions and contrast levels into account, but this can complicate the conversion process.\n\nAfter exploring both approaches for generating ASCII art from input images, it’s evident that both methods yield similar results in terms of visual representation. While K-means clustering enhances color reduction, the overall ASCII output remains largely consistent between the two methods. This consistency highlights the potential for either approach to effectively convert images into text-based art. However, for real-world applications, there are still areas that could benefit from optimization. For instance, implementing adaptive thresholding could better accommodate images with varying lighting conditions, allowing for a more nuanced conversion to ASCII. Additionally, experimenting with different character sets or even incorporating machine learning techniques to determine optimal mapping of pixel intensities could enhance visual fidelity. Further refining these methods would not only improve accuracy but also broaden the utility of ASCII art in various applications, such as text-based graphics for websites, terminal-based art displays, or even enhancing accessibility in digital media.\n\nIn conclusion, ASCII art offers a unique and creative way to represent images using text, blending art and technology in an intriguing manner. From simple text-based designs to converting images into intricate character representations, we’ve explored the process step by step. Although both approaches, we discussed produced similar results, they provide a strong foundation for experimenting further with image detail, brightness, and character density. While there are challenges like loss of detail and handling brightness variations, these can be addressed with further optimization and experimentation. Ultimately, ASCII art remains a fascinating form of expression, with plenty of potential for artistic and practical applications as we continue to refine the techniques.\n\nIf you are a fan of converting Image to beautiful ASCII Art, there a library in python called ASCII-Magic that converts images into ASCII art for terminals and HTML."
    },
    {
        "link": "https://quora.com/How-do-you-do-ASCII-art-using-math-or-pure-coding-like-no-tools-used-or-not-made-by-hand-only-using-coding",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://stackoverflow.com/questions/52843790/built-in-for-creating-permutations-of-a-character-set-of-n-length",
        "document": "I'm aware of itertools.permutations(), but what I'm asking about is slightly different.\n\nIs there a built in that will create lists of the given characters of all permutations of N length? So for example, if I wanted length 7:\n\nAs it stands, I wrote my own recursive procedure to generate them, but I'm sure there's some magic one line call I'm missing."
    },
    {
        "link": "https://stackoverflow.com/questions/6551282/python-all-possible-words-permutations-of-fixed-length-in-mini-alphabet",
        "document": "You are either looking for a permutation or a combination.\n\nand are different permutations, but they are the same combination .\n\nUse (since the functions there really should be in the default namespace), or if you'd like.\n\nIf you care about permutations:\n\nIf you care about combinations :\n\nIn other languages, there are simple recursive or iterative algorithms to generate these. See wikipedia or stackoverflow. e.g. http://en.wikipedia.org/wiki/Permutation#Systematic_generation_of_all_permutations\n\nDo note that the number of permutations is , so for example your string would have\n• combinations of length 8, and therefore...\n\nYou'll run out of memory if you are storing every permutation. Even if you don't (because you're reducing them), it'll take a long time to run, maybe somewhere between 1-10 days on a modern computer."
    },
    {
        "link": "https://geeksforgeeks.org/generate-all-permutations-of-a-string-that-follow-given-constraints",
        "document": "Generate all permutations of a string that follow given constraints\n\nGiven a string, generate all permutations of it that do not contain ‘B’ after ‘A’, i.e., the string should not contain “AB” as a substring.\n\nA simple solution is to generate all permutations. For every permutation, check if it follows the given constraint.\n\nTime Complexity: O(n! X n) where n! is the number of permutations generated and O(n) times to print a permutation.\n\nThe above solution first generates all permutations, then for every permutation, it checks if it follows given constraint or not. \n\n\n\nAn efficient solution is to use Backtracking. We cut down the recursion tree whenever we see that substring “AB” is formed. How do we do this? we add a isSafe() function. Before doing a swap, we check if previous character is ‘A’ and current character is ‘B’.\n\nBelow is the implementation of the above code:"
    },
    {
        "link": "https://medium.com/@makmalsh/exploring-permutations-under-constraints-in-python-beee13e79a8a",
        "document": "In this section, we will extract data from Excel files and perform unique permutations using Python and pandas. Let’s break down the process step by step.\n\nTo start, let’s import the data from the Excel file into pandas DataFrames. The Excel file is named “full_info.xlsx” and includes two tabs named “Sheet1” and “Sheet2.” The content of these two sheets is as follows:\n\nThis code will import the data:\n\nInterested readers can find more information about the data structure DataFrame in pandas.\n\nNow let’s find unique permutations of pairs of names from both DataFrames. We’ll define a function that takes and as input and returns a list of valid permutations. We’ll also define the conditions for a valid pairing:\n• The ‘Number’ value in Sheet1 must be at least 5 greater than the corresponding ‘Number’ in Sheet2.\n• The ‘Place’ values cannot be the same.\n• The ‘Char’ value from Sheet2 should be in the ‘List’ from Sheet1.\n\ndef unique_permutations_df(df1, df2):\n\n # Sort lists by length\n\n df1, df2 = sort_by_length(df1, df2) # Implement sort_by_length function\n\n\n\n # Initialize a list of valid permutations\n\n valid_perms = []\n\n\n\n # Generate all permutations of the longer list taken len(df2) at a time\n\n df1_all_permutations = generate_permutations_of_length(df1.iterrows(), len(df2)) # Implement generate_permutations_of_length function\n\n\n\n for perm in df1_all_permutations:\n\n # Zip the permutations with the rows from df2\n\n list_zipped = zip_2_lists(perm, df2.iterrows()) # Implement list_zipped function\n\n\n\n # Initialize a local list of valid permutations\n\n local_list_of_perms = []\n\n\n\n for (index1, row1), (index2, row2) in list_zipped:\n\n # Check the conditions for a valid pairing\n\n if check_conditions_df(row1, row2): # Implement check_conditions_df function\n\n # If the conditions are met, add the pair to the current permutation\n\n local_list_of_perms.append((row1['Names'], row2['Names']))\n\n\n\n if len(local_list_of_perms) != 0 and local_list_of_perms not in valid_perms:\n\n # Append if local-list is not empty and not already in valid_perms\n\n valid_perms.append(local_list_of_perms)\n\n\n\n # Return the list of valid permutations\n\n return valid_perms\n\nLet’s define the function, that verifies the conditions for a valid pairing:\n\nBy applying these modifications, you’ll be able to find valid permutations of names from both DataFrames. The full code’s output will be:"
    },
    {
        "link": "https://geeksforgeeks.org/python-permutation-given-string-using-inbuilt-function",
        "document": "The task is to generate all the possible permutations of a given string. A permutation of a string is a rearrangement of its characters. For example, the permutations of “ABC” are “ABC”, “ACB”, “BAC”, “BCA”, “CAB”, and “CBA”. The number of permutations of a string with n unique characters is n! (factorial of n).\n\nWe can generate permutations of a string in Python using methods like inbuilt functions and recursion.\n\nitertools module in Python provides a simple function called permutations that can generate all possible permutations of a string. This method is the easiest and most efficient, especially when working with built-in Python libraries.\n• itertools.permutations(s) generates all possible permutations of the string s, returning each permutation as a tuple.\n• ”.join(p) p into a string by concatenating its elements.\n• None collects all the joined strings (permutations) into a list.\n\nRecursion is a method where a function calls itself to solve smaller parts of a problem. In the case of generating permutations, we can break down the problem by selecting one character at a time and recursively permuting the rest of the string. This approach is a bit more complex than using itertools.permutations, but it can be useful if we want more control over the process.\n• None If the string s is empty, print the accumulated answer.\n• None For each character in s, remove the character and recursively permute the remaining characters while adding the character to answer.\n• None Call permute(s, answer) with the initial string and an empty answer to start generating permutations."
    }
]