[
    {
        "link": "https://forums.raspberrypi.com/viewtopic.php?t=299754",
        "document": "Re: Interfacing with SSD1306 OLED displays via the C SDK \n\n \n\n The code that works on the STM32 doesn't work on an STM8. There could be any number of reasons of why the disparity. OLEDs seem to require a lot of \"gloop\" to set up, so I guess there could be any number of problems. I've been trying to port code without worrying too much about the nitty-gritty of the protocol itself. Maybe I need to dig a little deeper.\n\n \n\n The good news is that I've managed to get an OLED working on the Pico using MicroPython. So it's at least a start. If you want to see something working\n\n 1. go to my github directory: \n\n 2. install micropython on your machine\n\n 3. upload ssd1306.py onto the Pico. This is the main drive.\n\n 4. upload the demo program pico1306.py to the Pico.\n\n \n\n It should work (TM).\n\n \n\n Let me know how you folks get on. I don't know if everyone's questions are addressed. My STM32 code does work, but not when I translated it to the Pico. Hmmm. There's a lot of OLED code floating around on the net, and it's difficult to know offhand how much they diverge.The code that works on the STM32 doesn't work on an STM8. There could be any number of reasons of why the disparity. OLEDs seem to require a lot of \"gloop\" to set up, so I guess there could be any number of problems. I've been trying to port code without worrying too much about the nitty-gritty of the protocol itself. Maybe I need to dig a little deeper.The good news is that I've managed to get an OLED working on the Pico using MicroPython. So it's at least a start. If you want to see something working1. go to my github directory: https://github.com/blippy/rpi/tree/master/1306 2. install micropython on your machine3. upload ssd1306.py onto the Pico. This is the main drive.4. upload the demo program pico1306.py to the Pico.It should work (TM).Let me know how you folks get on.\n\nRe: Interfacing with SSD1306 OLED displays via the C SDK congrats on getting anything on the screen of a display though, they are finicky things at the best of times to initialise congrats on getting anything on the screen of a display though, they are finicky things at the best of times to initialise Thanks. I've been completely boneheaded in trying to get it working. I'm sure a smarter person would have had this working in no time.\n\n \n\n However, a recent commit by me has greatly helped, and I've managed to get pixel positioning and a couple of letters working which seem to be in the right place. The code is a mess, as I've been trying to get the wretched thing working!\n\n \n\n However, the whole problem of positioning seems to be resolved. So I'm getting there! \n\n \n\n It doesn't work on a 128.32 display yet, but hey, one thing at a time.\n\n \n\n Taking a look at my STM32 code, I think it's flawed. it's one of those bizarre situations where you think \"how on earth did this work in the first place?\"\n\n \n\n Alas, the way I've written it means that the code is somewhat cumbersome to port back to severely constrained mcus like the STM8 or ATTiny85. But meh, one battle at a time.\n\n \n\n What I need to figure out is how to do fonts. I've got a couple of letters working, but the next step is trying to figure out how to get a complete character set working.\n\n \n\n The real trouble with these things is getting them working in the first place, and figuring out how the protocols work. Things like character sets should be just a question of logic. I reckon to have broken the back of it.\n\n \n\n Stay tuned. Thanks. I've been completely boneheaded in trying to get it working. I'm sure a smarter person would have had this working in no time.However, a recent commit by me has greatly helped, and I've managed to get pixel positioning and a couple of letters working which seem to be in the right place. The code is a mess, as I've been trying to get the wretched thing working!However, the whole problem of positioning seems to be resolved. So I'm getting there!It doesn't work on a 128.32 display yet, but hey, one thing at a time.Taking a look at my STM32 code, I think it's flawed. it's one of those bizarre situations where you think \"how on earth did this work in the first place?\"Alas, the way I've written it means that the code is somewhat cumbersome to port back to severely constrained mcus like the STM8 or ATTiny85. But meh, one battle at a time.What I need to figure out is how to do fonts. I've got a couple of letters working, but the next step is trying to figure out how to get a complete character set working.The real trouble with these things is getting them working in the first place, and figuring out how the protocols work. Things like character sets should be just a question of logic. I reckon to have broken the back of it.Stay tuned.\n\nRe: Interfacing with SSD1306 OLED displays via the C SDK When I last wrote a driver for one of these it was for the Arduino pro-mini, 8MHz and 2K SRAM, the standard drivers all took too much space - what I needed was basic text and some basic graphics that could be done as custom glyphs - I needed small text (8 pixels high was fine) and larger (36 pixels high) - this was for a small handset controller that wanted small details and a central easy to read bit.\n\n \n\n the font bit was simple, the displays write in bytes, each byte is a column 1 pixel wide and 8 pixels wide, as long as you ware happy to keep your font a multiple of 8 pixels its not hard to have a defined array of bytes to write to a set column and 'page' (screen spilt into 8 8 pixel high pages), then just go to the desired location, write your byte, IIRC it moves across one pixel on its own and write the next. \n\n \n\n larger fonts meant writing several 'pages'\n\n \n\n doing it this way meant adding bar charts under was easy, before you write a column, invert it or not. \n\n \n\n the font is then just a byte array - critically you can make it only have the characters you need, e.g. you need fractions? go for it, I had a few custom icons for tyres, fuel and so on.\n\n \n\n if you have a \"drawCharacter()\" routine that knows how to map an ASCII character to your font, and what to do with characters not present its not too hard.\n\n \n\n currently redoing this for a Max7219 dot matrix, the speed of the processor and the ran in the PICO I'd be tempted to have a buffer, in the same format (128 columns, each of 8 pixels high, then 8 rows of them) and draw to that, can then set your own drawing mode in a way you can't when talking to the device in SPI or I2C mode\n\nRe: Interfacing with SSD1306 OLED displays via the C SDK Is it fine if I use (and modify) your library in a project? There is no license included. I'll make sure to specify the source and author. Is it fine if I use (and modify) your library in a project? There is no license included. I'll make sure to specify the source and author. I'm not sure if the question was directed at me, but if so: feel free to do whatever you like with the code.\n\n \n\n The exclusion of a license was deliberate on my part. The code has been adapted from elsewhere, so whether my code should be considered a derivative work or new code in its own right is a question for the lawyers.\n\n \n\n One problem, of course, is that all code that does the same thing is going to look fairly similar. It leads us back to the question: \"Can you copyright mathematics?\"\n\n \n\n I did notice, for example, that there was a link to a font given in a previous post. In that code, the author asserted copyright. He was being a little bit cheeky there, because it seemed to be a straight-out copy of the font available elsewhere. \n\n \n\n It's difficult to trace the provenance of a piece of code.\n\n \n\n I'm happy enough to release stuff into the Public Domain and let people do what they want with it.\n\n \n\n I'm all in favour of a small code base. Makes it easier to understand, and easier to port. I'm not sure if the question was directed at me, but if so: feel free to do whatever you like with the code.The exclusion of a license was deliberate on my part. The code has been adapted from elsewhere, so whether my code should be considered a derivative work or new code in its own right is a question for the lawyers.One problem, of course, is that all code that does the same thing is going to look fairly similar. It leads us back to the question: \"Can you copyright mathematics?\"I did notice, for example, that there was a link to a font given in a previous post. In that code, the author asserted copyright. He was being a little bit cheeky there, because it seemed to be a straight-out copy of the font available elsewhere.It's difficult to trace the provenance of a piece of code.I'm happy enough to release stuff into the Public Domain and let people do what they want with it.I'm all in favour of a small code base. Makes it easier to understand, and easier to port."
    },
    {
        "link": "https://randomnerdtutorials.com/raspberry-pi-pico-ssd1306-oled-arduino",
        "document": "This guide shows how to use the SSD1306 OLED display with Raspberry Pi Pico using Arduino IDE. We’ll show you how to write text, set different fonts, draw shapes and display bitmaps images.\n\nWe have a similar tutorial using Raspberry Pi Pico with MicroPython: Raspberry Pi Pico: SSD1306 OLED Display (MicroPython).\n\nYou need to install the Raspberry Pi Pico boards on Arduino IDE and you must know how to upload code to the board. Check out the following tutorial first if you haven’t already:\n\nThe OLED display that we’ll use in this tutorial is the SSD1306 model: a monocolor, 0.96 inch display with 128×64 pixels as shown in the following figure.\n\nThe OLED display doesn’t require backlight, which results in a very nice contrast in dark environments. Additionally, its pixels consume energy only when they are on, so the OLED display consumes less power when compared to other displays.\n\nThe model we’re using has four pins and communicates with any microcontroller using I2C communication protocol. There are models that come with an extra RESET pin or that communicate using SPI communication protocol.\n\nHere’s a list of parts you need for this project:\n\nYou can use the preceding links or go directly to MakerAdvisor.com/tools to find all the parts for your projects at the best price!\n\nThe OLED display uses I2C communication protocol, so wiring is pretty straightforward. You can use the following table as a reference. The default I2C pins used by the Raspberry Pi Pico when using Arduino IDE are GPIO 4 (SDA) and GPIO 5 (SCL).\n\nYou can also use the following schematic diagram as a reference.\n\nThere are several libraries to control the OLED display compatible with the Raspberry Pi Pico. In this tutorial, we’ll use two Adafruit libraries: Adafruit_SSD1306 library and Adafruit_GFX library.\n\nFollow the next steps to install those libraries.\n\n1. Open your Arduino IDE and go to Sketch > Include Library > Manage Libraries. The Library Manager should open.\n\n2. Type “SSD1306” in the search box and install the SSD1306 library from Adafruit.\n\nIt will prompt a message to also install the GFX library. Install that library.\n\n3. If it doesn’t prompt that message, install the GFX library manually. Search for “GFX” in the search box and install the library.\n\n4. After installing the libraries, you’re ready to start controlling the OLED display.\n\nThe Adafruit library for the OLED display comes with several functions to write text. In this section, you’ll learn how to write text using the library functions.\n\nThe following sketch displays the Hello, world! message in the OLED display.\n\nLet’s take a quick look at how the code works.\n\nFirst, you need to import the necessary libraries. The Wire library to use I2C and the Adafruit libraries to write to the display: Adafruit_GFX and Adafruit_SSD1306.\n\nThen, you define your OLED width and height. In this example, we’re using a 128×64 OLED display. If you’re using other sizes, you can change that in the SCREEN_WIDTH, and SCREEN_HEIGHT variables.\n\nThen, initialize a display object with the width and height defined earlier with I2C communication protocol (&Wire).\n\nThe (-1) parameter means that your OLED display doesn’t have a RESET pin. If your OLED display does have a RESET pin, it should be connected to a GPIO. In that case, you should pass the GPIO number as a parameter.\n\nIn the setup(), initialize the Serial Monitor at a baud rate of 115200 for debugging purposes.\n\nInitialize the OLED display with the begin() method as follows:\n\nThis snippet also prints a message on the Serial Monitor, in case we’re not able to connect to the display.\n\nIn case you’re using a different OLED display, you may need to change the OLED address. In our case, the address is 0x3C.\n\nIf this address doesn’t work, you can run an I2C scanner sketch to find your OLED address. You can find the I2C scanner sketch here.\n\nAfter initializing the display, add a two-second delay, so that the OLED has enough time to initialize before writing text:\n\nAfter initializing the display, clear the display buffer with the clearDisplay() method:\n\nBefore writing text, you need to set the text size, color, and where the text will be displayed in the OLED.\n\nSet the font size using the setTextSize() method:\n\nSet the font color with the setTextColor() method:\n\nDefine the position where the text starts, using the setCursor(x,y) method. In this case, we’re setting the text to start at the (0,0) coordinates – at the top left corner.\n\nFinally, you can send the text to the display using the println() method, as follows:\n\nThen, you need to call the display() method to actually display the text on the screen.\n\nUploading the Code to the Raspberry Pi Pico\n\nFor you to be able to upload code to the Raspberry Pi Pico, it needs to be in bootloader mode.\n\nIf the Raspberry Pi is currently running MicroPython firmware, you need to manually put it into bootloader mode. For that, connect the Raspberry Pi Pico to your computer while holding the BOOTSEL button at the same time.\n\nFor future uploads using Arduino IDE, the board should go automatically into bootloader mode without the need to press the BOOTSEL button.\n\nNow, select your COM port in Tools > Port. It may be the case that the COM port is grayed out. If that’s the case, don’t worry it will automatically find the port once you hit the upload button.\n\nYou should get a success message.\n\nAfter uploading the code, the OLED will display the “Hello, world!!!” message.\n\nThe Adafruit GFX library allows us to use some other fonts besides the built-in fonts. It allows you to choose between Serif, Sans, and Mono. Each font is available in bold, italic, and in different sizes.\n\nThe sizes are set by the actual font. So, the setTextSize() method doesn’t work with these fonts. The fonts are available in 9, 12, 18 and 24 point sizes and also contain 7-bit characters (ASCII codes) (described as 7b in the font name).\n\nYou can choose from the next selection of fonts:\n\nThe fonts that work better with the OLED display are the 9 and 12 points size.\n\nTo use one of those fonts, first, you need to include it in your sketch, for example:\n\nNext, you just need to use the setFont() method and pass as an argument, the specified font:\n\nAfter specifying the font, all methods to write text will use that font. To get back to using the original font, you just need to call the setFont() method with no arguments:\n\nUpload the next sketch to your board:\n\nNow, your display prints the “Hello, world!” message in FreeSerif font in bold and italic.\n\nThe Adafruit OLED library provides useful methods to draw pixels, lines, and shapes. Let’s take a quick look at those methods.\n\nTo draw a pixel in the OLED display, you can use the drawPixel(x, y, color) method that accepts as arguments the x and y coordinates where the pixel appears, and color. For example:\n\nUse the drawLine(x1, y1, x2, y2, color) method to create a line. The (x1, y1) coordinates indicate the start of the line, and the (x2, y2) coordinates indicate where the line ends. For example:\n\nThe drawRect(x, y, width, height, color) provides an easy way to draw a rectangle. The (x, y) coordinates indicate the top left corner of the rectangle. Then, you need to specify the width, height, and color:\n\nYou can use the fillRect(x, y, width, height, color) to draw a filled rectangle. This method accepts the same arguments as drawRect().\n\nThe library also provides methods to display rectangles with round corners: drawRoundRect() and fillRoundRect(). These methods accept the same arguments as previous methods plus the radius of the corner. For example:\n\nTo draw a circle use the drawCircle(x, y, radius, color) method. The (x,y) coordinates indicate the center of the circle. You should also pass the radius as an argument. For example:\n\nIn the same way, to build a filled circle, use the fillCircle() method with the same arguments:\n\nUse the the drawTriangle(x1, y1, x2, y2, x3, y3, color) method to build a triangle. This method accepts as arguments the coordinates of each corner and the color.\n\nUse the fillTriangle() method to draw a filled triangle.\n\nThe library provides an additional method that you can use with shapes or text: the invertDisplay() method. Pass true as an argument to invert the colors of the screen or false to get back to the original colors.\n\nIf you call the following command after defining the triangle:\n\nYou’ll get an inverted triangle as follows:\n\nUpload the following sketch that implements each snippet of code we’ve covered previously and displays all those the shapes.\n\nYou can display 128×64 bitmap monocolor images on the OLED display.\n\nFirst, use an imaging program to resize a photo or picture and save it as monochrome bitmap. If you’re on a Windows PC, you can use Paint. The picture must be 128×64 pixels.\n\nDon’t forget to save your image in Monochrome Bitmap format.\n\nThen, use an Image to C Array converter to convert the image into an array. I’ve used LCD Image Converter.\n\nRun the program and start with a new image. Go to Image > Import and select the bitmap image you created earlier.\n\nGo to Options > Conversion and in the Prepare tab, select the Monochrome preset:\n\nThen, click OK. Finally, in the main menu, go to File > Convert. A new file with .c extension should be saved. That file contains the C array for the image. Open that file with a text editor, and copy the array.\n\nIn our case, this is the array that we get:\n\nCopy your array to the sketch. Then, to display the array, use the drawBitmap() method that accepts the following arguments (x, y, image array, image width, image height, rotation). The (x, y) coordinates define where the image starts to be displayed.\n\nCopy the code below to display your bitmap image in the OLED.\n\nAfter uploading the code, this is what we get on the display, a nice picture of Rui.\n\nIf you get the “SSD1306 allocation failed” error or if the OLED is not displaying anything on the screen, it can be one of the following issues:\n\nThe I2C address for the OLED display we are using is 0x3C. However, yours may be different. So, make sure you check your display I2C address using an I2C scanner sketch.\n\nSDA and SCL are not connected properly\n\nPlease make sure that you have the SDA and SCL pins of the OLED display wired correctly. In the case of the Raspberry Pi Pico, the default I2C pins on the Arduino IDE are GPIO 4 (SDA) and GPIO 5 (SCL).\n\nIn this guide, we’ve shown you how to display text, draw shapes and display bitmap images on the OLED display using the Raspberry Pi Pico programmed with Arduino IDE.\n\nIf you like the Raspberry Pi Pico, make sure you take a look at some of the other tutorials on our blog:"
    },
    {
        "link": "https://instructables.com/Air-Monitor-With-RP2040-Zero-SSD1306-Oled-Screen-a",
        "document": "About: I am mechanical engineer and I work on robotic mechanical design. I am running my startup and sometime working on my design hobby. In this project, I used microcontroller to monitor the humidity and temperature of 2 different locations. The measured data is shown on SSD1306 oled screen There are 2 main things I need to test with the RP2040-Zero\n\nThis is a mini version of RP Pico. It fits small project better because you don't need to use all the GPIO anyway. You will have a compact design using this. More important is the price, this one is cheaper that the original Pico. This Humidity and Temperature sensor is popular thanks to the accuracy and repeatablity. It is much better than DHT11 or DHT22 which are usually come with beginner kit. You can also get a cheaper version of SHT31 here. I used 2 of the sensors in this project for 2 different locations. Get 1 if you just need to learn how to use it. I used the all white color screen. If you by chance has the 2-colors yellow and blue, you should update the address of the screen in the ssd1306.py (line 105) to 0x3D instead of 0x3C (I will have a more details instructables later)\n\nLet's talk about the micro controller. There are many kinds of them for you to choose from Arduino to ESP32...I chose this RP2040 because it is the first of it kind from Raspberry Pi manufacture. It is coded in Python which is very intuitive for beginner. The RP2040-Zero format is very compact. It fits the small project like this one (and it's cheap :) It's very simple circuit. I have two SHT31 sensors from adafruit that connected to the RP2040-Zero. To display the measured humidity and temperature, I added the oled screen SSD1306. They all work with the I2C communication. I will not go into details. It is just a communication standard that electronics can talk to each other. As you can see in the pinout photo, the RP2040-Zero has 2 I2C buses: I2C0 and I2C1. I used I2C0 (Pin GP0 and GP1) for the 2 sensors and the I2C1 (Pin GP14 and GP15) for the screens. The wiring depends on the selection of the I2C buses so make sure that you connect them correctly. You will need to supply power using the usb port or directly connect to the 5V or 3.3V power pins. That's will be all the circuit.\n\nYou can download all the code from my Github There are some libraries that we need to import The main code for RP2040-zero is oled2SensorBigText.py. The most important part is the setting for the I2C buses. I2C0 is shared between 2 SHT31 sensors (line 14). One of them has the ADR pin connected to Vcc to set the I2C address to 0x45 (line 16). The other one will have 0x44 (line 15) instead (default). I2C1 is used for oled screen SSD1306 (line 19).\n\nRun the oled2SensorBigText.py with the RP2040-Zero and you will get the measurement of the 2 sensors. This project is good for when you need to compare the air at different locations. I am working on packing the whole unit with battery as well as adding more sensors. You can follow my Youtube channel to get update about it."
    },
    {
        "link": "https://randomnerdtutorials.com/guide-for-oled-display-with-arduino",
        "document": "This article shows how to use the SSD1306 0.96 inch I2C OLED display with the Arduino. We’ll show you some features of the OLED display, how to connect it to the Arduino board, and how to write text, draw shapes and display bitmap images. Lastly, we’ll build a project example that displays temperature and humidity readings.\n\nThe organic light-emitting diode (OLED) display that we’ll use in this tutorial is the SSD1306 model: a monocolor, 0.96-inch display with 128×64 pixels as shown in the following figure.\n\nThe OLED display doesn’t require backlight, which results in a very nice contrast in dark environments. Additionally, its pixels consume energy only when they are on, so the OLED display consumes less power when compared with other displays.\n\nThe model we’re using here has only four pins and communicates with the Arduino using I2C communication protocol. There are models that come with an extra RESET pin. There are also other OLED displays that communicate using SPI communication.\n\nBecause the OLED display uses I2C communication protocol, wiring is very simple. You just need to connect to the Arduino Uno I2C pins as shown in the table below.\n\nIf you’re using a different Arduino board, make sure you check the correct I2C pins:\n\nTo control the OLED display you need the adafruit_SSD1306.h and the adafruit_GFX.h libraries. Follow the next instructions to install those libraries.\n\n1. Open your Arduino IDE and go to Sketch > Include Library > Manage Libraries. The Library Manager should open.\n\n2. Type “SSD1306” in the search box and install the SSD1306 library from Adafruit.\n\n3. After installing the SSD1306 library from Adafruit, type “GFX” in the search box and install the library.\n\n4. After installing the libraries, restart your Arduino IDE.\n\nTips for writing text using these libraries\n\nHere’s some functions that will help you handle the OLED display library to write text or draw simple graphics.\n• – all pixels are off\n• – set the font size, supports sizes from 1 to 8\n• – call this method for the changes to make effect\n\nAfter wiring the OLED display to the Arduino and installing all required libraries, you can use one example from the library to see if everything is working properly.\n\nIn your Arduino IDE, go to File > Examples > Adafruit SSD1306 and select the example for the display you’re using.\n\nThe following code should load:\n\nIf your OLED doesn’t have a RESET pin, you should set the OLED_RESET variable to -1 as shown below:\n\nUpload the code to your Arduino board. Don’t forget to select the right board and COM port in the Tools menu.\n\nYou should get a series of different animations in the OLED as shown in the following short video.\n\nIf your OLED display is not showing anything:\n• Check that the OLED display is properly wired to the Arduino\n• Double-check the OLED display I2C address: with the OLED connected to the Arduino, upload this code and check the I2C address in the Serial Monitor\n\nYou should change the OLED address in the following line, if necessary. In our case, the address is 0x3C.\n\nThe Adafruit library for the OLED display comes with several functions to write text. In this section, you’ll learn how to write and scroll text using the library functions.\n\nThe following sketch displays Hello, world! message in the OLED display.\n\nAfter uploading the code, this is what you’ll get in your OLED:\n\nLet’s take a quick look on how the code works.\n\nFirst, you need to import the necessary libraries. The Wire library to use I2C and the Adafruit libraries to write to the display: Adafruit_GFX and Adafruit_SSD1306.\n\nThen, you define your OLED width and height. In this example, we’re using a 128×64 OLED display. If you’re using other sizes, you can change that in the SCREEN_WIDTH, and SCREEN_HEIGHT variables.\n\nThen, initialize a display object with the width and height defined earlier with I2C communication protocol (&Wire).\n\nThe (-1) parameter means that your OLED display doesn’t have a RESET pin. If your OLED display does have a RESET pin, it should be connected to a GPIO. In that case, you should pass the GPIO number as a parameter.\n\nIn the setup(), initialize the Serial Monitor at a baud raute of 115200 for debugging purposes.\n\nInitialize the OLED display with the begin() method as follows:\n\nThis snippet also prints a message on the Serial Monitor, in case we’re not able to connect to the display.\n\nIn case you’re using a different OLED display, you may need to change the OLED address. In our case, the address is 0x3C.\n\nIf this address doesn’t work, you can run an I2C scanner sketch to find your OLED address. You can find the I2C scanner sketch here.\n\nAfter initializing the display, add a two second delay, so that the OLED has enough time to initialize before writing text:\n\nAfter initializing the display, clear the display buffer with the clearDisplay() method:\n\nBefore writing text, you need to set the text size, color and where the text will be displayed in the OLED.\n\nSet the font size using the setTextSize() method:\n\nSet the font color with the setTextColor() method:\n\nDefine the position where the text starts using the setCursor(x,y) method. In this case, we’re setting the text to start at the (0,10) coordinates.\n\nFinally, you can send the text to the display using the println() method, as follows:\n\nThen, you need to call the display() method to actually display the text on the screen.\n\nThe Adafruit OLED library provides useful methods to easily scroll text.\n• : scroll text from left to right\n• : scroll text from right to left\n• : scroll text from left bottom corner to right upper corner\n• : scroll text from right bottom corner to left upper corner\n\nThe following sketch implements those methods.\n\nThe text scrolls as shown in the following short video.\n\nThe Adafruit GFX library allows us to use some alternate fonts besides the built-in fonts. It allows you to chose between Serif, Sans, and Mono. Each font is available in bold, italic and in different sizes.\n\nThe sizes are set by the actual font. So, the setTextSize() method doesn’t work with these fonts. The fonts are available in 9, 12, 18 and 24 point sizes and also contain 7-bit characters (ASCII codes) (described as 7b in the font name).\n\nYou can chose from the next selection of fonts:\n\nThe fonts that work better with the OLED display are the 9 and 12 points size.\n\nTo use one of those fonts, first you need to include it in your sketch, for example:\n\nNext, you just need to use the setFont() method and pass as argument, the specified font:\n\nAfter specifying the font, all methods to write text will use that font. To get back to use the original font, you just need to call the setFont() method with no arguments:\n\nUpload the next sketch to your board:\n\nNow, your display prints the “Hello, world!” message in FreeSerif font.\n\nThe Adafruit OLED library provides useful methods to draw pixels, lines and shapes. Let’s take a quick look at those methods.\n\nTo draw a pixel in the OLED display, you can use the drawPixel(x, y, color) method that accepts as arguments the x and y coordinates where the pixel appears, and color. For example:\n\nUse the drawLine(x1, y1, x2, y2, color) method to create a line. The (x1, y1) coordinates indicate the start of the line, and the (x2, y2) coordinates indicates where the line ends. For example:\n\nThe drawRect(x, y, width, height, color) provides an easy way to draw a rectangle. The (x, y) coordinates indicate the top left corner of the rectangle. Then, you need to specify the width, height and color:\n\nYou can use the fillRect(x, y, width, height, color) to draw a filled rectangle. This method accepts the same arguments as drawRect().\n\nThe library also provides methods to displays rectangles with round corners: drawRoundRect() and fillRoundRect(). These methods accepts the same arguments as previous methods plus the radius of the corner. For example:\n\nTo draw a circle use the drawCircle(x, y, radius, color) method. The (x,y) coordinates indicate the center of the circle. You should also pass the radius as an argument. For example:\n\nIn the same way, to build a filled circle, use the fillCircle() method with the same arguments:\n\nUse the the drawTriangle(x1, y1, x2, y2, x3, y3, color) method to build a triangle. This method accepts as arguments the coordinates of each corner and the color.\n\nUse the fillTriangle() method to draw a filled triangle.\n\nThe library provides an additional method that you can use with shapes or text: the invertDisplay() method. Pass true as argument to invert the colors of the screen or false to get back to the original colors.\n\nIf you call the following command after defining the triangle:\n\nYou’ll get an inverted triangle as follows:\n\nUpload the following sketch that implements each snippet of code we’ve covered previously and goes through all the shapes.\n\nYou can display 128×64 bitmap monocolor images on the OLED display.\n\nFirst, use an imaging program to resize a photo or picture and save it as monochrome bitmap. If you’re on a Windows PC, you can use Paint.\n\nThen, use a Image to C Array converter to convert the image into an array. I’ve used LCD Image Converter.\n\nRun the program and start with a new image. Go to Image > Import and select the bitmap image you’ve created earlier.\n\nGo to Options > Conversion and in the Prepare tab, select the following options:\n\nGo to the Image tab and select the following options:\n\nThen, click OK. Finally, in the main menu, go to File > Convert. A new file with .c extension should be saved. That file contains the C array for the image. Open that file with a text editor, and copy the array.\n\nIn our case, this is the array that we get:\n\nCopy your array to the sketch. Then, to display the array, use the drawBitmap() method that accepts the following arguments (x, y, image array, image width, image height, rotation). The (x, y) coordinates define where the image starts to be displayed.\n\nCopy the code below to display your bitmap image in the OLED.\n\nAfter uploading the code, this is what we get on the display.\n\nDisplay Temperature and Humidity in the OLED Display with Arduino\n\nIn this section we’ll build a project that displays temperature and humidity readings on the OLED display. We’ll get temperature and humidity using the DHT11 temperature and humidity sensor. If you’re not familiar with the DHT11 sensor, read the following article:\n• Complete Guide for DHT11/DHT22 Humidity and Temperature Sensor With Arduino\n\nTo complete this project you need the following components:\n\nYou can use the preceding links or go directly to MakerAdvisor.com/tools to find all the parts for your projects at the best price!\n\nAssemble the circuit by following the next schematic diagram.\n\nNote: if you’re using a module with a DHT sensor, it normally comes with only three pins. The pins should be labeled so that you know how to wire them. Additionally, many of these modules already come with an internal pull up resistor, so you don’t need to add one to the circuit.\n\nBefore proceeding, make sure you have installed the“adafruit_GFX.h” and the “adafruit_SSD1306.h” libraries to control the OLED display.\n\nFor this project you also need two aditional libraries to read from the DHT sensor: the DHT library and the Adafruit_Sensor library. Follow the next steps to install those libraries\n\n1. Open your Arduino IDE and go to Sketch > Include Library > Manage Libraries. The Library Manager should open.\n\n2. Search for “DHT” on the Search box and install the DHT library from Adafruit.\n\n3. After installing the DHT library from Adafruit, type “Adafruit Unified Sensor” in the search box. Scroll all the way down to find the library and install it.\n\nAfter installing all the necessary libraries, you can upload the following code.\n\nRead this section if you want to learn how the code works. Otherwise, you can skip to the “Demonstration” section.\n\nThe code starts by including the necessary libraries. The Wire, Adafruit_GFX and Adafruit_SSD1306 are used to interface with the OLED display. The Adafruit_Sensor and the DHT libraries are used to interface with the DHT22 or DHT11 sensors.\n\nThen, define your OLED display dimensions. In this case, we’re using a 128×64 pixel display.\n\nThen, initialize a display object with the width and height defined earlier with I2C communication protocol (&Wire).\n\nThe (-1) parameter means that your OLED display doesn’t have a RESET pin. If your OLED display does have a RESET pin, it should be connected to a GPIO. In that case, you should pass the GPIO number as a parameter.\n\nThen, define the DHT sensor type you’re using. If you’re using a DHT11 you don’t need to change anything on the code. If you’re using another sensor, just uncomment the sensor you’re using and comment the others.\n\nInitialize a DHT sensor object with the pin and type defined earlier.\n\nIn the setup(), initialize the serial monitor for debugging purposes.\n\nIn this case, the address of the OLED display we’re using is 0x3C. If this address doesn’t work, you can run an I2C scanner sketch to find your OLED address. You can find the I2C scanner sketch here.\n\nAdd a delay to give time for the display to initialize, clear the display and set the text color to white:\n\nIn the loop() is where we read the sensor and display the temperature and humidity on the display.\n\nGet temperature and humidity readings from DHT\n\nThe temperature and humidity are saved on the t and h variables, respectively. Reading temperature and humidity is as simple as using the readTemperature() and readHumidity() methods on the dht object.\n\nIn case we are not able to get the readings, display an error message:\n\nIf you get that error message, read our troubleshooting guide: how to fix “Failed to read from DHT sensor”.\n\nThe following lines display the temperature on the OLED display.\n\nWe use the setTextSize() method to define the font size, the setCursor() sets where the text should start being displayed and the print() method is used to write something on the display.\n\nTo print the temperature and humidity you just need to pass their variables to the print() method as follows:\n\nThe “Temperature” label is displayed in size 1, and the actual reading is displayed in size 2.\n\nTo display the º symbol, we use the Code Page 437 font. For that, you need to set the cp437 to true as follows:\n\nThen, use the write() method to display your chosen character. The º symbol corresponds to character 167.\n\nA similar approach is used to display the humidity:\n\nDon’t forget that you need to call display.display() at the end, so that you can actually display something on the OLED.\n\nAfter wiring the circuit and uploading the code, the OLED display shows the temperature and humidity readings. The sensor readings are updated every five seconds.\n\nIf your DHT sensor fails to get the readings or you get the message “Failed to read from DHT sensor”, read our DHT Troubleshooting Guide to help you solve that problem.\n\nIf you get the “SSD1306 allocation failed” error or if the OLED is not displaying anything in the screen, it can be one of the following issues:\n\nThe I2C address for the OLED display we are using is 0x3C. However, yours may be different. So, make sure you check your display I2C address using an I2C scanner sketch.\n\nPlease make sure that you have the SDA and SCL pins of the OLED display wired correctly.\n\nThe OLED display provides an easy and inexpensive way to display text or graphics using an Arduino. We hope you’ve found this guide and the project example useful.\n\nIf you like Arduino, make sure you check all our Arduino resources:\n\nDon’t miss our next tutorials and projects! Make sure you subscribe the RNT blog."
    },
    {
        "link": "https://instructables.com/How-to-Use-an-OLED-Display-With-Raspberry-Pi-Pico",
        "document": "Introduction: How to Use an OLED Display With Raspberry Pi Pico More by the author: In this tutorial we will learn about the Interfacing of SSD1306 OLED Display with Raspberry Pi Pico. SSD1306 Oled display with Raspberry pi pico - In a majority of the projects, we need display units for printing text and sensor values. Nowadays, one of the most commonly used displays is the Oled display. The one you can see on the screen is the SSD1306 I2C-supported Oled display Module which I am going to use with Raspberry Pi Pico.\n\nRaspberry Pi Pico is a little, fast, and versatile board built using RP2040, a brand-new microcontroller chip devised by Raspberry Pi in the UK. A Raspberry Pi Pico is a low-cost, high-performance microcontroller board with flexible digital interfaces.. Microcontrollers are tiny computers, but they tend to lack large-volume storage\n• RP2040 microcontroller chip designed by Raspberry Pi in the United Kingdom\n• 264kB of SRAM, and 2MB of on-board Flash memory\n\nThe 0.96\" 128x64 OLED display module is a compact, low-cost module that is perfect for any project requiring a small display screen. The module is very easy to use, with only four pins required to interface with a microcontroller. The display is clear and bright, and the module is extremely thin, making it ideal for use in portable applications. OLED (organic light-emitting diode) displays are low-power consumption output devices able to show text and images by controlling every single pixel. The most common size is 128×64 pixels (0.96 inches), but also the 128×32 pixels (0.91 inches) is available from e-shops. Their screens are usually mono-colour or bi-colour. The mono-colour ones are made of blue or white pixels, while the bi-colour models usually have an upper part yellow and the lower one blue. In this tutorial, I’m going to use the bi-colour model, but this uses also the mono-colour ones\n\nTo use the Pico board with the library, you'll have to use the thonny IDE with Raspberry Pi Pico board support. If you haven't already done that yet, you can easily install Raspberry pi pico Board support to your Thonny IDE by following this tutorial Before uploading the code install the following libraries :\n\nI prefer Thonny IDE for programming. The programming here is divided into two main parts:1. SSD1306.py2. Main.py This is because the OLED Display requires an SSD1306 Driver Code first. We have to write the code for the SSD1306 Driver first. After uploading the SSD1306 Code, we can then run the main.py code. # MicroPython SSD1306 OLED driver, I2C and SPI interfaces\n\n\n\nfrom micropython import const\n\nimport framebuf\n\n\n\n# register definitions\n\nSET_CONTRAST = const(0x81)\n\nSET_ENTIRE_ON = const(0xA4)\n\nSET_NORM_INV = const(0xA6)\n\nSET_DISP = const(0xAE)\n\nSET_MEM_ADDR = const(0x20)\n\nSET_COL_ADDR = const(0x21)\n\nSET_PAGE_ADDR = const(0x22)\n\nSET_DISP_START_LINE = const(0x40)\n\nSET_SEG_REMAP = const(0xA0)\n\nSET_MUX_RATIO = const(0xA8)\n\nSET_COM_OUT_DIR = const(0xC0)\n\nSET_DISP_OFFSET = const(0xD3)\n\nSET_COM_PIN_CFG = const(0xDA)\n\nSET_DISP_CLK_DIV = const(0xD5)\n\nSET_PRECHARGE = const(0xD9)\n\nSET_VCOM_DESEL = const(0xDB)\n\nSET_CHARGE_PUMP = const(0x8D)\n\n\n\n# Subclassing FrameBuffer provides support for graphics primitives\n\n# http://docs.micropython.org/en/latest/pyboard/library/framebuf.html\n\nclass SSD1306(framebuf.FrameBuffer):\n\n def __init__(self, width, height, external_vcc):\n\n self.width = width\n\n self.height = height\n\n self.external_vcc = external_vcc\n\n self.pages = self.height // 8\n\n self.buffer = bytearray(self.pages * self.width)\n\n super().__init__(self.buffer, self.width, self.height, framebuf.MONO_VLSB)\n\n self.init_display()\n\n\n\n def init_display(self):\n\n for cmd in (\n\n SET_DISP | 0x00, # off\n\n # address setting\n\n SET_MEM_ADDR,\n\n 0x00, # horizontal\n\n # resolution and layout\n\n SET_DISP_START_LINE | 0x00,\n\n SET_SEG_REMAP | 0x01, # column addr 127 mapped to SEG0\n\n SET_MUX_RATIO,\n\n self.height - 1,\n\n SET_COM_OUT_DIR | 0x08, # scan from COM[N] to COM0\n\n SET_DISP_OFFSET,\n\n 0x00,\n\n SET_COM_PIN_CFG,\n\n 0x02 if self.width > 2 * self.height else 0x12,\n\n # timing and driving scheme\n\n SET_DISP_CLK_DIV,\n\n 0x80,\n\n SET_PRECHARGE,\n\n 0x22 if self.external_vcc else 0xF1,\n\n SET_VCOM_DESEL,\n\n 0x30, # 0.83*Vcc\n\n # display\n\n SET_CONTRAST,\n\n 0xFF, # maximum\n\n SET_ENTIRE_ON, # output follows RAM contents\n\n SET_NORM_INV, # not inverted\n\n # charge pump\n\n SET_CHARGE_PUMP,\n\n 0x10 if self.external_vcc else 0x14,\n\n SET_DISP | 0x01,\n\n ): # on\n\n self.write_cmd(cmd)\n\n self.fill(0)\n\n self.show()\n\n\n\n def poweroff(self):\n\n self.write_cmd(SET_DISP | 0x00)\n\n\n\n def poweron(self):\n\n self.write_cmd(SET_DISP | 0x01)\n\n\n\n def contrast(self, contrast):\n\n self.write_cmd(SET_CONTRAST)\n\n self.write_cmd(contrast)\n\n\n\n def invert(self, invert):\n\n self.write_cmd(SET_NORM_INV | (invert & 1))\n\n\n\n def show(self):\n\n x0 = 0\n\n x1 = self.width - 1\n\n if self.width == 64:\n\n # displays with width of 64 pixels are shifted by 32\n\n x0 += 32\n\n x1 += 32\n\n self.write_cmd(SET_COL_ADDR)\n\n self.write_cmd(x0)\n\n self.write_cmd(x1)\n\n self.write_cmd(SET_PAGE_ADDR)\n\n self.write_cmd(0)\n\n self.write_cmd(self.pages - 1)\n\n self.write_data(self.buffer)\n\n\n\n\n\nclass SSD1306_I2C(SSD1306):\n\n def __init__(self, width, height, i2c, addr=0x3C, external_vcc=False):\n\n self.i2c = i2c\n\n self.addr = addr\n\n self.temp = bytearray(2)\n\n self.write_list = [b\"\\x40\", None] # Co=0, D/C#=1\n\n super().__init__(width, height, external_vcc)\n\n\n\n def write_cmd(self, cmd):\n\n self.temp[0] = 0x80 # Co=1, D/C#=0\n\n self.temp[1] = cmd\n\n self.i2c.writeto(self.addr, self.temp)\n\n\n\n def write_data(self, buf):\n\n self.write_list[1] = buf\n\n self.i2c.writevto(self.addr, self.write_list)\n\n\n\n\n\nclass SSD1306_SPI(SSD1306):\n\n def __init__(self, width, height, spi, dc, res, cs, external_vcc=False):\n\n self.rate = 10 * 1024 * 1024\n\n dc.init(dc.OUT, value=0)\n\n res.init(res.OUT, value=0)\n\n cs.init(cs.OUT, value=1)\n\n self.spi = spi\n\n self.dc = dc\n\n self.res = res\n\n self.cs = cs\n\n import time\n\n\n\n self.res(1)\n\n time.sleep_ms(1)\n\n self.res(0)\n\n time.sleep_ms(10)\n\n self.res(1)\n\n super().__init__(width, height, external_vcc)\n\n\n\n def write_cmd(self, cmd):\n\n self.spi.init(baudrate=self.rate, polarity=0, phase=0)\n\n self.cs(1)\n\n self.dc(0)\n\n self.cs(0)\n\n self.spi.write(bytearray([cmd]))\n\n self.cs(1)\n\n\n\n def write_data(self, buf):\n\n self.spi.init(baudrate=self.rate, polarity=0, phase=0)\n\n self.cs(1)\n\n self.dc(1)\n\n self.cs(0)\n\n self.spi.write(buf)\n\n self.cs(1)\n\n Now hit the download & run button. So you will be able to see the SSD1306 driver saved in the Raspberry Pi Pico."
    },
    {
        "link": "https://randomnerdtutorials.com/esp-now-esp32-arduino-ide",
        "document": "Learn how to use ESP-NOW to exchange data between ESP32 boards programmed with Arduino IDE. ESP-NOW is a connectionless communication protocol developed by Espressif that features short packet transmission. This protocol enables multiple devices to talk to each other in an easy way.\n\nWe have other tutorials for ESP-NOW with the ESP32:\n\nWe’ll program the ESP32 board using Arduino IDE, so before proceeding with this tutorial you should have the ESP32 add-on installed in your Arduino IDE. Follow the next guide:\n• Installing the ESP32 Board in Arduino IDE (Windows, Mac OS X, and Linux instructions)\n\nNote: we have a similar guide for the ESP8266 NodeMCU Board: Getting Started with ESP-NOW (ESP8266 NodeMCU with Arduino IDE)\n\nFor a video introduction to ESP-NOW protocol, watch the following (try the project featured in this video):\n\nStating the Espressif website, ESP-NOW is a “protocol developed by Espressif, which enables multiple devices to communicate with one another without using Wi-Fi. The protocol is similar to the low-power 2.4GHz wireless connectivity (…) . The pairing between devices is needed prior to their communication. After the pairing is done, the connection is safe and peer-to-peer, with no handshake being required.”\n\nThis means that after pairing a device with each other, the connection is persistent. In other words, if suddenly one of your boards loses power or resets, when it restarts, it will automatically connect to its peer to continue the communication.\n• Up to 250-byte payload can be carried;\n• Sending callback function that can be set to inform the application layer of transmission success or failure.\n\nESP-NOW technology also has the following limitations:\n• None Limited encrypted peers. 10 encrypted peers at the most are supported in Station mode; 6 at the most in SoftAP or SoftAP + Station mode;\n• Multiple unencrypted peers are supported, however, their total number should be less than 20, including encrypted peers;\n\nIn simple words, ESP-NOW is a fast communication protocol that can be used to exchange small messages (up to 250 bytes) between ESP32 boards.\n\nESP-NOW is very versatile and you can have one-way or two-way communication in different setups.\n\nFor example, in one-way communication, you can have scenarios like this:\n• One ESP32 board sending data to another ESP32 board\n\nThis configuration is very easy to implement and it is great to send data from one board to the other like sensor readings or ON and OFF commands to control GPIOs.\n\nOne ESP32 board sending the same or different commands to different ESP32 boards. This configuration is ideal to build something like a remote control. You can have several ESP32 boards around the house that are controlled by one main ESP32 board.\n\nThis configuration is ideal if you want to collect data from several sensors nodes into one ESP32 board. This can be configured as a web server to display data from all the other boards, for example.\n\nNote: in the ESP-NOW documentation there isn’t such thing as “sender/master” and “receiver/slave”. Every board can be a sender or receiver. However, to keep things clear we’ll use the terms “sender” and “receiver” or “master” and “slave”.\n\nWith ESP-NOW, each board can be a sender and a receiver at the same time. So, you can establish two-way communication between boards.\n\nFor example, you can have two boards communicating with each other.\n\nLearn how to: Exchange Sensor Readings with ESP-NOW Two-Way Communication.\n\nYou can add more boards to this configuration and have something that looks like a network (all ESP32 boards communicate with each other).\n\nIn summary, ESP-NOW is ideal to build a network in which you can have several ESP32 boards exchanging data with each other.\n\nTo communicate via ESP-NOW, you need to know the MAC Address of the ESP32 receiver. That’s how you know to which device you’ll send the data to.\n\nEach ESP32 has a unique MAC Address and that’s how we identify each board to send data to it using ESP-NOW (learn how to Get and Change the ESP32 MAC Address).\n\nTo get your board’s MAC Address, upload the following code.\n\nAfter uploading the code, open the Serial Monitor at a baud rate of 115200 and press the ESP32 RST/EN button. The MAC address should be printed as follows:\n\nSave your board MAC address because you’ll need it to send data to the right board via ESP-NOW.\n\nTo get you started with ESP-NOW wireless communication, we’ll build a simple project that shows how to send a message from one ESP32 to another. One ESP32 will be the “sender” and the other ESP32 will be the “receiver”.\n\nWe’ll send a structure that contains a variable of type char, int, float, and boolean. Then, you can modify the structure to send whichever variable types are suitable for your project (like sensor readings, or boolean variables to turn something on or off).\n\nFor better understanding, we’ll call “sender” to ESP32 #1 and “receiver” to ESP32 #2.\n\nHere’s what we should include in the sender sketch:\n• Register a callback function upon sending data – the function will be executed when a message is sent. This can tell us if the message was successfully delivered or not;\n• Add a peer device (the receiver). For this, you need to know the receiver MAC address;\n\nOn the receiver side, the sketch should include:\n• Register for a receive callback function ( ). This is a function that will be executed when a message is received.\n• Inside that callback function, save the message into a variable to execute any task with that information.\n\nESP-NOW works with callback functions that are called when a device receives a message or when a message is sent (you get if the message was successfully delivered or if it failed).\n\nHere’s a summary of the most essential ESP-NOW functions:\n\nFor more information about these functions read the ESP-NOW documentation at Read the Docs.\n\nHere’s the code for the ESP32 Sender board. Copy the code to your Arduino IDE, but don’t upload it yet. You need to make a few modifications to make it work for you.\n\nFirst, include the esp_now.h and WiFi.h libraries.\n\nIn the next line, you should insert the ESP32 receiver MAC address.\n\nIn our case, the receiver MAC address is: 30:AE:A4:07:0D:64, but you need to replace that variable with your own MAC address.\n\nThen, create a structure that contains the type of data we want to send. We called this structure struct_message and it contains 4 different variable types. You can change this to send other variable types.\n\nThen, create a new variable of type struct_message that is called myData that will store the variables’ values.\n\nCreate a variable of type esp_now_peer_info_t to store information about the peer.\n\nNext, define the OnDataSent() function. This is a callback function that will be executed when a message is sent. In this case, this function simply prints if the message was successfully delivered or not.\n\nIn the setup(), initialize the serial monitor for debugging purposes:\n\nAfter successfully initializing ESP-NOW, register the callback function that will be called when a message is sent. In this case, we register for the OnDataSent() function created previously.\n\nAfter that, we need to pair with another ESP-NOW device to send data. That’s what we do in the next lines:\n\nIn the loop(), we’ll send a message via ESP-NOW every 2 seconds (you can change this delay time).\n\nFirst, we set the variables values as follows:\n\nRemember that myData is a structure. Here we assign the values we want to send inside the structure. For example, the first line assigns a char, the second line assigns a random Int number, a Float, and a Boolean variable.\n\nWe create this kind of structure to show you how to send the most common variable types. You can change the structure to send other data types.\n\nFinally, send the message as follows:\n\nCheck if the message was successfully sent:\n\nThe loop() is executed every 2000 milliseconds (2 seconds).\n\nUpload the following code to your ESP32 receiver board.\n\nSimilarly to the sender, start by including the libraries:\n\nCreate a structure to receive the data. This structure should be the same defined in the sender sketch.\n\nCreate a callback function that will be called when the ESP32 receives the data via ESP-NOW. The function is called onDataRecv() and should accept several parameters as follows:\n\nWe copy the content of the incomingData data variable into the myData variable.\n\nNow, the myData structure contains several variables inside with the values sent by the ESP32 sender. To access variable a, for example, we just need to call myData.a.\n\nIn this example, we simply print the received data, but in a practical application you can print the data on a display, for example.\n\nIn the setup(), intialize the Serial Monitor.\n\nRegister for a callback function that will be called when data is received. In this case, we register for the OnDataRecv() function that was created previously.\n\nUpload the sender sketch to the sender ESP32 board and the receiver sketch to the receiver ESP32 board.\n\nNow, open two Arduino IDE windows. One for the receiver, and another for the sender. Open the Serial Monitor for each board. It should be a different COM port for each board.\n\nThis is what you should get on the sender side.\n\nAnd this is what you should get on the receiver side. Note that the Int variable changes between each reading received (because we set it to a random number on the sender side).\n\nWe tested the communication range between the two boards, and we are able to get a stable communication up to 220 meters (approximately 722 feet) in open field. In this experiment both ESP32 on-board antennas were pointing to each other.\n\nWe tried to keep our examples as simple as possible so that you better understand how everything works. There are more ESP-NOW-related functions that can be useful in your projects, like: managing peers, deleting peers, scanning for slave devices, etc… For a complete example, in your Arduino IDE, you can go to File > Examples > ESP32 > ESPNow and choose one of the example sketches.\n\nWe hope you’ve found this introduction to ESP-NOW useful. As a simple getting started example, we’ve shown you how to send data as a structure from one ESP32 to another. The idea is to replace the structure values with sensor readings or GPIO states, for example.\n\nAdditionally, with ESP-NOW, each board can simultaneously be a sender and receiver. One board can send data to multiple boards and also receive data from multiple boards.\n\nWe also have a tutorial about ESP-NOW with the ESP8266: Getting Started with ESP-NOW (ESP8266 NodeMCU with Arduino IDE).\n\nTo learn more about the ESP32 board, make sure you take a look at our resources:"
    },
    {
        "link": "https://randomnerdtutorials.com/esp-now-two-way-communication-esp32",
        "document": "In this guide, we’ll show you how to establish a two-way communication between two ESP32 boards using ESP-NOW communication protocol. As an example, two ESP32 boards will exchange sensor readings (with a range in open field up to 220 meters ~ 722 feet).\n\nFor an introduction to ESP-NOW protocol, you can watch the following video:\n\nIf you want to learn more about ESP-NOW, you can read this guide: Getting Started with ESP-NOW (ESP32 with Arduino IDE).\n\nESP-NOW is a connectionless communication protocol developed by Espressif that features short packet transmission. This protocol enables multiple devices to talk to each other without using Wi-Fi.\n\nThis is a fast communication protocol that can be used to exchange small messages (up to 250 bytes) between ESP32 boards. ESP-NOW is very versatile and you can have one-way or two-way communication in different arrangements.\n\nIn this tutorial, we’ll show you how to establish a two-way communication between two ESP32 boards.\n\nNote: read our ESP-NOW Getting Started Guide for a complete introduction to ESP-NOW protocol with ESP32.\n\nThe following diagram shows a high-level overview of the project we’ll build.\n• In this project we’ll have two ESP32 boards. Each board is connected to an OLED display and a BME280 sensor;\n• Each board gets temperature, humidity and pressure readings from their corresponding sensors;\n• Each board sends its readings to the other board via ESP-NOW;\n• When a board receives the readings, it displays them on the OLED display;\n• After sending the readings, the board displays on the OLED if the message was successfully delivered;\n• Each board needs to know the other board MAC address in order to send the message.\n\nIn this example, we’re using a two-way communication between two boards, but you can add more boards to this setup, and having all boards communicating with each other.\n\nBefore proceeding with this project, make sure you check the following prerequisites.\n\nWe’ll program the ESP32 using Arduino IDE, so before proceeding with this tutorial you should have the ESP32 add-on installed in your Arduino IDE. Follow the next guide:\n• Installing the ESP32 Board in Arduino IDE (Windows, Mac OS X, and Linux)\n\nInstall the following libraries in your Arduino IDE. These libraries can be installed through the Arduino Library Manager. Go to Sketch > Include Library> Manage Libraries and search for the library name.\n\nFor this tutorial you need the following parts:\n\nYou can use the preceding links or go directly to MakerAdvisor.com/tools to find all the parts for your projects at the best price!\n\nTo send messages between each board, we need to know their MAC address. Each board has a unique MAC address (learn how to Get and Change the ESP32 MAC Address).\n\nUpload the following code to each of your boards to get their MAC address.\n\nAfter uploading the code, press the RST/EN button, and the MAC address should be displayed on the Serial Monitor.\n\nWrite down the MAC address of each board to clearly identify them.\n\nWire an OLED display and a BME280 sensor to each ESP32 board. Follow the next schematic diagram.\n\nYou can use the following table as a reference when wiring the BME280 sensor.\n\nYou can also follow the next table to wire the OLED display to the ESP32.\n\nLearn more about interfacing multiple I2C peripherals with the ESP32.\n\nUpload the following code to each of your boards. Before uploading the code, you need to enter the MAC address of the other board (the board you’re sending data to).\n\nWe’ve covered in great detail how to interact with the OLED display and with the BME280 sensor in previous tutorials. Here, we’ll just take a look at the relevant parts when it comes to ESP-NOW.\n\nThe code is well commented so that you understand what each line of code does.\n\nTo use ESP-NOW, you need to include the next libraries.\n\nIn the next line, insert the MAC address of the receiver board:\n\nCreate variables to store temperature, humidity and pressure readings from the BME280 sensor. These readings will be sent to the other board:\n\nCreate variables to store the sensor readings coming from the other board:\n\nThe following variable will store a success message if the readings are delivered successfully to the other board.\n\nThen, you need to create two instances of that structure. One to receive the readings and another to store the readings to be sent.\n\nThe BME280Readings will store the readings to be sent.\n\nThe incomingReadings will store the data coming from the other board.\n\nCreate a variable of type esp_now_peer_info_t to store information about the peer.\n\nThen, we need to create two callback functions. One will be called when data is sent, and another will be called when data is received.\n\nThe OnDataSent() function will be called when new data is sent. This function simply prints if the message was successfully delivered or not. If the message is delivered successfully, the status variable returns 0, so we can set our success message to “Delivery Success”:\n\nIf the success message returns 1, it means the delivery failed:\n\nThe OnDataRecv() function will be called when a new packet arrives.\n\nWe save the new packet in the incomingReadings structure we’ve created previously:\n\nWe print the message length on the serial monitor. You can only send 250 bytes in each packet.\n\nThen, store the incoming readings in their corresponding variables. To access the temperature variable inside incomingReadings structure, you just need to do call incomingReadings.temp as follows:\n\nThe same process is done for the other variables:\n\nThen, register for the OnDataSent callback function.\n\nIn order to send data to another board, you need to pair it as a peer. The following lines register and add a new peer.\n\nIn the loop(), we call the getReadings() function that is responsible for getting new temperature readings from the sensor. That function is created after the loop().\n\nAfter getting new temperature, humidity and pressure readings, we update our BME280Reading structure with those new values:\n\nThen, we can send the BME280Readings structure via ESP-NOW:\n\nFinally, call the updateDisplay() function that will update the OLED display with the readings coming from the other ESP32 board.\n\nThe loop() is executed every 10 seconds.\n\nThat’s pretty much how the code works. You should upload the code to both of your boards. You just need to modify the code with the MAC address of the board you’re sending data to.\n\nRecommended reading: Guide for OLED Display with ESP32 and Guide for BME280 Sensor with ESP32.\n\nAfter uploading the code to both boards, you should see the OLED displaying the sensor readings from the other board, as well as a success delivery message.\n\nAs you can see, it’s working as expected:\n\nWe tested the communication range between the two boards, and we are able to get a stable communication up to 220 meters (approximately 722 feet) in open field. In this experiment both ESP32 on-board antennas were pointing to each other.\n\nIn this tutorial we’ve shown you how to establish a two-way communication with two ESP32 boards using ESP-NOW. This is a very versatile communication protocol that can be used to send packets with up to 250 bytes. ESP-NOW communication protocol can also be used with ESP8266 boards: Getting Started with ESP-NOW (ESP8266 NodeMCU with Arduino IDE).\n\nAs an example, we’ve shown you the interaction between two boards, but you can add many boards to your setup. You just need to know the MAC address of the board you’re sending data to.\n\nWe’ll be publishing more tutorials about ESP-NOW, so stay tuned. Additionally, write a comment below saying which tutorial you would like to see with ESP-NOW.\n\nTo learn more about the ESP32 board, take a look at our resources:"
    },
    {
        "link": "https://docs.arduino.cc/tutorials/nano-esp32/esp-now",
        "document": ""
    },
    {
        "link": "https://dronebotworkshop.com/esp-now",
        "document": "Today we will be working with ESP-NOW, a connectionless protocol developed by Espressif for the ESP32 and ESP08266 microcontrollers. With ESP-NOW we can build a private network without WiFi or a Router!\n\nThe ESP32 and its cousin, the ESP8266, are undoubtedly remarkable microcontrollers. Aside from a high-speed 32-bit architecture, they also have built-in Bluetooth and WiFi.\n\nThe Bluetooth and WiFi capabilities on these devices are made possible by an integrated 2.4GHz radio transceiver module. And this module can also be used for other communications applications that use the unlicensed 2.4GHz band.\n\nEspressif, the makers of the ESP8266 and ESP32, have developed a protocol that allows all these devices to create a private, wireless network using the 2.5GHz transceivers. This is a separate network from the WiFi network and can only be used by ESP-type microcontrollers.\n\nESP-NOW allows simple packet communications between ESP devices, using the 2.4 GHz band. These transmissions operate a lot like those used by wireless mice and keypads and are limited to packets of 250 bytes or fewer.\n\nYes, I said 250 bytes! Not quite enough for voice and video perhaps, although there are ways of packetizing both of those, but quite sufficient to deliver remote control commands or data from sensors.\n\nThe data can be unidirectional or bidirectional, i.e. single-duplex or full-duplex. Most data types are supported.\n\nData can be encrypted or unencrypted, and no external source of WiFi or a router is required. Depending upon your configuration, you can have anywhere from 2 to 20 devices communicating between themselves.\n\nThe range can vary dramatically due to the environment, but under the right conditions (and with proper antennas) you can achieve over 400 meters. Just using the built-in antennas on the modules should still allow you to communicate through a medium-sized home without a problem.\n\nYou can place your ESP-NOW network in many configurations. You can mix and match ESP32 and ESP8266 devices within the same network.\n\nA device participating in an ESP-NOW network can be operated in one of two modes.\n• Initiator – This device initiates the transmission. It will require the MAC address of the receiving device.\n\nIn unidirectional (half-duplex) mode, the transmitting device is the Initiator and the receiving device is the Responder.\n\nIn a 2-way (full-duplex) communications mode, each device is both an Initiator and Responder.\n\nIn this arrangement, the Initiator ESP32 transmits data to the Responder ESP32. The Initiator can tell if the Responder received the message successfully.\n\nThis is a simple arrangement, but it has many uses in remote control applications.\n\nThis setup consists of one Initiator that is communicating with multiple responders.\n\nThe configuration can be used in two fashions:\n• None The Initiator communicates with each Responder individually.\n• None The Initiator initiates a broadcast message to communicate with all the Responders.\n\nAn alarm system might use this sort of configuration to activate remote sounders or communicate with remote monitors when an alarm has been triggered\n\nThis is the reverse of the previous ESP-NOW network configuration. In this arrangement, we have one Responder and multiple Initiators.\n\nThis arrangement is very common as it is used for remote sensor applications, with the Responder gathering data sent by the Initiator.\n\nThe ESP-NOW protocol can also handle bidirectional, or full-duplex, communications.\n\nThis illustrates the simplest arrangement, with two devices communicating with one another.\n\nIn this, and all bidirectional communications configurations, the ESP-32 acts as both Initiator and Resolver.\n\nExpanding upon the previous configuration even further, we come up with this arrangement, four boards that have bidirectional communications established with one another.\n\nNote that the boards can be a mix of different models of both ESP32 and ESP8266 devices.\n\nWhen Initiators communicate with Responders, they need to know the Responder’s MAC Address.\n\nA MAC, or Media Access Control, Address is a unique 6-digit hexadecimal number assigned to every device on a network. It is generally burned into the device by the manufacturer, although it is possible to manually set it.\n\nEvery ESP32 and ESP8266 has its own unique MAC address, and you’ll need to know that address to use it as a Responder in the experiments we will be doing today.\n\nHere is a very simple sketch that you can run on an ESP32 to determine its unique MAC Address:\n\nAll we are doing is including the WiFi Library, initializing the serial monitor, placing the ESP32 into Station mode, and then asking it for its MAC address. The result is printed on the serial monitor.\n\nThe entire sketch runs in the Setup section, so after loading it to the ESP32, it will likely run before you get a chance to view it on the Serial monitor.\n\nYou can press the Reset key on your module to force it to run again.\n\nThe MAC Address will be at the bottom of the screen. Copy it to a safe location, so that you can use it later.\n\nThe ESP-NOW Library is included in your ESP device boards manager installation. It has a number of functions and methods to assist with coding for ESP-NOW.\n\nIn order to see how it works, you need to examine the sending and receiving of an ESP-NOW message packet.\n\nA callback is a bit like an interrupt, it is generated every time a specific event has occurred.\n\nIn the ESP-NOW protocol, there are two callbacks of interest:\n• None callback is called whenever data is sent.\n• None callback is called when data is received.\n\nIn your code, you will create a callback function that you will bind to either the sending or receiving callback using the functions listed above. Your function will run every time the event occurs.\n\nThe callback functions also return some useful data:\n• None The Sending callback returns the status of the sent data.\n\nIf you are writing code to use the ESP32 or ESP8266 as the Initiator, then this is what you need to accomplish:\n• None You need to initialize the ESP-NOW library.\n• None You need to add a peer device, which is the responder device. You add the peer by specifying its MAC address.\n• None Finally, you can packetize and send the message.\n\nTo write code for the ESP-NOW responder, you’ll need to do the following:\n• None You need to initialize the ESP-NOW library.\n• None In the receive callback, you’ll capture the incoming message data and pass it to a variable.\n\nLet’s dig out some ESP boards and start experimenting with ESP-NOW.\n\nI’ll be playing with the ESP32 today, but you should be able to run everything on an ESP8266 as well. If you do, you’ll need to change the WiFi library, as the ESP8266 uses a different one.\n\nGather a few modules, a mix of different manufacturers boards is fine, and run the MAC Address sketch on each of them and save the address to a text file or spreadsheet.\n\nOur first test is very simple and is a great way to learn the fundamentals of sending and receiving data using ESP-NOW.\n\nWe will need two ESP32 boards for this test. One board will be the Initiator (sender), and the other will be our Responder (receiver). We don’t require any additional hardware on the modules, as we’ll be monitoring the results with the serial monitor in the Arduino IDE.\n\nAs one board is Initiator and the other Responder, they will be running different sketches, which are shown below. You’ll need the MAC address of the Responder, as it goes into the Initiators code.\n\nThe first sketch we will be running is the One-Way Initiator Sketch. This is run on the board that is transmitting the data.\n\nThis is the simplest mode of communication with ESP-NOW, and it will show you the fundamentals of sending data using the ESP-NOW protocol.\n\nWe start by including both the WiFi and ESP-NOW libraries. Both were installed on your Arduino IDE when you set up the ESP32 Boards Manager, so there is no need to install them from the Library Manager.\n\nWe then set up a few variables we are going to transmit to the receiver. There is an integer, a float, and a boolean. We will also be sending some text in a character variable, which you’ll see shortly.\n\nNow we need to enter the MAC address of the Responder board, which is the other ESP32 board. You will need to change the value in the sketch to match your board’s reading.\n\nNow we define a data structure. This is the structure of the data message we want to send, and it should match the types of variables we are using. You’ll see that we start with a character array variable, followed by an integer, float, and boolean. Those data types match the types we just defined.\n\nWe then create a structured data object called myData to hold the data we will be transmitting.\n\nNow we define our callback function, which we are calling OnDataSent. This will be called when data has been transmitted. In the function, we just print the status of the t transmission to the serial monitor.\n\nNow we go to the Setup.\n\nIn Setup, we initialize our serial monitor and set the ESP32 temporarily as a WiFi Station.\n\nAssuming that it initializes, we register our callback function and then add information about the peer, which is our Responder.\n\nNow to the Loop.\n\nIn the Loop we create some test data for the integer, float, and boolean. Then we add it to the myData object, along with the string “Welcome to the Workshop”.\n\nThen we send the message. We print the result and then delay two seconds before starting at the top of the Loop.\n\nReceiving has several similarities to transmitting.\n\nWe start by loading the same two libraries, and we then define a matching data structure and c a structured data object.\n\nWe then define our callback function, which in this case is called whenever data is received.\n\nRemember, the receive callback returns the data in the message, so that is where all the “action” takes place! We grab the data and print it to the serial monitor.\n\nWe then go to the Setup, where we initialize the serial monitor and set up the ESP32 up as a WiFi Station.\n\nNext, we attempt to initialize ESP-NOW. If we succeed, then we register our callback function.\n\nAnd we are done. Nothing happens in the Loop, as everything is handled in the callback function.\n\nLoad the sketches to their respective ESP32 boards.\n\nIdeally, you’ll want to observe both of the boards’ output on a serial monitor. Instead of using two computers, you can just open two instances of the Arduino IDE on your computer and run them with different COM ports selected. That way, you can open up two serial monitors.\n\nYou should see the Initiator display the status of its sent messages. The Responders serial monitor will display the data that is received, and note how the variables change on each transmission.\n\nOur next demonstration will put the ESP32 in a 2-way Broadcast mode. You’ll need at least two ESP32 boards to do this experiment, but it is more fun if you have three or more!\n\nWe will have an LED and pushbutton attached to each of our ESP 32 boards.\n\nAll the LEDs will remain in the same state on every board. So if one is on, they are all on. The pushbuttons can toggle the LED states, any pushbutton will affect all the LEDs.\n\nHere is how we will hook up each of the ESP32 boards.\n\nYou can use any color of LED you like, and they don’t have to be the same color on each board. The resistor I used had a value of 150-ohms, but any value from 100 to 220 ohms will work fine.\n\nHere is the sketch that you will run on every board. As we are using broadcast mode, we don’t need to know the other boards’ MAC addresses, so every board can run identical code.\n\nWe start with the two libraries, after that we define boolean variables to represent the state of the LED and pushbutton. We also define the pins these devices connect to.\n\nThere is also a function to correctly format the MAC addresses that are returned to us when we scan for recipients.\n\nAs we are both an Initiator and a Responder, we have two callbacks, one for send and one for receive.\n\nThe receive callback grabs the data and looks for the word “on”. If it gets it, then it turns on the LED, otherwise, it turns the LED off.\n\nThe send callback just prints up information about the sent packets on the serial monitor.\n\nThe broadcast function creates the broadcast message, by sending out the special MAC address of FF:FF:FF:FF:FF:FF. Each peer responds with its MAC address, which is used to send out the data.\n\nIn Setup, we do the usual – start the serial monitor, start the ESP32 in station mode before starting ESP-NOW.\n\nWe then register both callbacks.\n\nFinally, we define the LED and pushbutton pins and an OUTPUT and INPUT, respectively. We use the internal pull-up for the pushbutton, which saves us the trouble of wiring up a resistor of our own.\n\nIn the Loop we examine the pushbutton status, if it is down then we toggle the state of the ledOn variable and send a broadcast message with a value of “on” or “off”, dependent upon its final value.\n\nLoad up the sketch onto each ESP32 module that you have wired up and power them all up. You should observe that the LED status on each board is identical and that you can change the status by pressing the pushbutton on any of the boards.\n\nLet’s put our ESP-NOW knowledge to work and build something practical – a remote temperature and humidity sensor.\n\nWe will have our old friend the DHT22 temperature and humidity sensor attached to the Initiator ESP32, broadcasting its values every two seconds. Our Responder will display the readings on the serial monitor.\n\nThis could be the basis for a practical project, with a display instated of a serial monitor.\n\nHere is how we will wire up our Initiator board.\n\nNote that we are also using a 10K pull-up resistor on the data input line. This is actually optional, but you may find it more reliable with it.\n\nThe Responder (receiver) does not need any additional components wired to it. You will need to know its MAC address for all of this to work.\n\nHere is the sketch that we will run on the Initiator board:\n\nWe include the two ESP libraries, plus the DHT library from Adafruit. If you don’t already have this library installed, you can find it in your Library Manager by searching for “DHT”. You want the library from Adafruit.\n\nAfter setting up the DHT sensor parameters (which you can change if you want to use a DHT11 instead) we define a couple of floats for temperature and humidity.\n\nWe then have the MAC address of the responder. You will need to change this to the MAC address of your Responder ESP32 board.\n\nWe next define our data structure. As we are sending a couple of floating variables, we define exactly that – two floats. We then use this definition to create a structured data object.\n\nNext is the sent callback function, which just prints some diagnostic data on the serial monitor.\n\nIn the Setup, we start the serial monitor and the DHT22. We do the usual and start the hESP32 in station mode before starting ESP-NOW.\n\nWe then register our callback and add our peer, as we saw in earlier sketches.\n\nIn the Loop, we query the DHT 22 and get the temperature and humidity values, which we assign to their respective variables. We also print those to the Serial Monitor.\n\nWe then add those values to the myData structured data object.\n\nThen we send the data to the Responder.\n\nAfter that we delay for a couple of seconds, this is for the benefit of the DHT22. Then we go back and start the Loop again.\n\nAs you have probably started to notice, the Responder sketches are much shorter than the Initiator ones. This is because we have been doing all of our work in our callback function, with no code in the Loop. There is also less to set up for a Responder, as it doesn’t need the Initiator’s MAC address.\n\nHere is the sketch for our Responder, which receives and displays the temperature and humidity values sent by the Initiator:\n\nWe start with the usual two libraries, followed by a definition of a data structure with two floats, to match the transmitted one.\n\nWe then define our callback, which, like in other Responder sketches, does most of the work.\n\nIn this callback function, we grab the data and display it on the serial monitor.\n\nThe Setup is pretty straightforward, start everything and register the callback function. And there is nothing in the Loop, as the callback is what drives the serial monitor.\n\nOnce again, you can use two serial monitors on the same machine if you wish, just open two instances of the Arduino IDE. Or you can choose to only monitor the Responder serial monitor, which will display the temperature and humidity values from the Initiator.\n\nYou should be able to move the initiator a fair distance from the Responder, so this can make a good remote sensor.\n\nWe can modify our Remote Temperature and Humidity Sensor project to use multiple Initiators. That way, we can monitor the temperature in more than one location.\n\nWe will just add one more board for this test, but you could expand it to several more. If you did expand it you’ll want to improve the Responder side to keep track of the data better, in this demonstration we are still using the serial monitor but an OLED would probably be more practical for a multi-sensor unit.\n\nOf course, you will need an additional ESP32, along with a DHT22 and pull-up resistor for this experiment. It is wired identically to the first one.\n\nWe will also need to modify both of our sketches to make our multiple-sensor configuration more reliable. All we really need to add is a unique identifier for each Initiator so that it can be identified at the Responder end.\n\nWhile we could have used the MAC address of the Initiator, it is a lot easier to define our own identity tag. In our case, we will just use an integer with a unique value for each Initiator.\n\nHere is the Initiator sketch, which will need to be modified with a unique identity value and then loaded onto both Temperature & Humidity sensor ESP32 boards.\n\nIt’s the same initiator sketch, with a slight modification for the unique identity value. This value is sent along with the temperature and humidity information. This way, the sender can be identified on the Responder end.\n\nThere are only three modifications to make to our sketch.\n\nFirst, we add an ident variable, an integer. This is the unique value, it needs to be set to a different value for each board.\n\nThe second modification is to the data structure, where we add a third data variable, an integer. This will be what holds our new identity integer value.\n\nAnd finally, when we add the temperature and humidity to the structured data object, we also add the identity. So it gets transmitted along with the other information.\n\nOn the Responder side, we also make a few modifications to accommodate the new third variable, the integer with the Initiator identity.\n\nThe modification to the data structure is the same as it was for the transmitter, with the addition of an integer variable.\n\nAs most of our “action” in the Responder sketch is in the callback, this is where we use our new variable. We just incorporate it into the temperature and humidity reading, to identify the sender.\n\nLoad the modified sketches onto their respective boards, making sure to have changed the integer identity value for each Initiator.\n\nThen turn it all on and observe the serial monitor on the Responder. You should see the temperature and humidity readings from both sensors.\n\nIf they are too fast, try increasing the delay on each board above the current 2 seconds.\n\nThis is more effective if the two transmitters are in separate environments, perhaps indoors and outdoors.\n\nESP-NOW is a very useful protocol that allows you to build even more advanced ESP32 projects.\n\nFor remote control and remote sensing applications, this has a lot of potential, and you’ll be seeing more ESP-NOW projects here in the workshop soon."
    },
    {
        "link": "https://github.com/espressif/esp-now/blob/master/User_Guide.md",
        "document": "This project provides examples to simplify the use of ESP-NOW.\n\nESP-NOW is a kind of connectionless Wi-Fi communication protocol that is defined by Espressif. Different from traditional Wi-Fi protocols, the first five upper layers in OSI are simplified to one layer in ESP-NOW, so the data doesn't need to be transmitted through the network layer, the transport layer, the session layer, the presentation layer, and the application layer, which reduces the delay caused by packet loss under congested network, and leads to quickly response time.\n\nThe ESP-NOW provided by ESP-IDF is the ESP-NOW protocol, this component provides some high-level functionalities to simplify the use of ESP-NOW protocol, you can understand this component as an application-level ESP-NOW, which provides some enhanced features, including pairing, control, provisioning, debug, OTA, security, etc.\n\nESP-NOW occupies less CPU and flash resource. It can work with Wi-Fi and Bluetooth LE, and supports the series of ESP8266、ESP32、ESP32-S and ESP32-C. The data transmission mode of ESP-NOW is flexible including unicast and broadcast, and supports one-to-many and many-to-many device connection and control.\n\nThere are two roles defined in ESP-NOW according to the data flow, initiator and responder. The same device can have two roles at the same time. Generally, switches, sensors, LCD screens, etc. play the role of initiator in an IoT system, when lights, sockets and other smart applications play the role of responder.\n\nThe following table shows the ESP-IDF versions supported by ESP-NOW at the current time. The lable means supported, and the lable means not supported.\n\nThe ESP-IDF master branch is marked as not supported because the major feature changes it has introduced may cause conflicts with ESP-NOW. Yet, the ESP-NOW examples not affected by those feature changes can still run correctly on the IDF master branch.\n\nEnd of Life IDF branches are marked as not supported, such as ESP-IDF Release/v4.0. See IDF Supported Periods for details.\n\nNote 1: The built-in IDF branch of ESP-NOW v1.0 is IDF Release/v4.4 at the current time.\n\nNote 2: The built-in IDF branch of ESP-NOW v2.x.x is from IDF Release/v4.4 at the current time.\n\nNew feature development and bugfix usually take place on the master branch and will be published into ESP Component Registry. The publish time of the next version is usually a few months. When a new version of the ESP-NOW is published, please plan to upgrade to that version.\n\nSetting the environment and getting ESP-IDF (release/v4.4 or tag v4.4) follow the Step .\n\nDownload ESP-NOW using the following:\n\nIt is recommended to first erase the flash if you are using this for the first time and then flash the firmware. Here are the steps:\n\nThere are some obvious advantages in ESP-NOW:\n• Quick Response: After power-on, the devices can transmit data and control other paired devices directly without any wireless connection, and the response speed is in milliseconds.\n• Good Compatibility: When the device connects to a router or works as a hotpot, it can also realize a fast and stable communication by ESP-NOW. And the device can keep stable connection through ESP-NOW even if the router is faulty or the network is unstable.\n• Long-distance Communication: ESP-NOW supports long-distance communication. It can be applied to outdoor scenes and can keep stable connection even the devices are separated by walls even floors.\n• Multi-hop Control: The multi-hop control of devices can be realized by ESP-NOW. Hundreds of devices can be controlled through unicast, broadcast and group control.\n\nESP-NOW provides a new provisioning method besides the Wi-Fi provisioning and Bluetooth provisioning. First, configuring the network for the first device via bluetooth, and other devices don't need to be configured the information of SSID/password, because the first device connected to the network can send these information to others directly. Users can choose whether to allow remaining devices to access the network on the APP side.\n\nESP-NOW can be used for the mass data transmission like firmware upgrade.\n• Resume Upgrade from Break-point: When use ESP-NOW to upgrade the firmware, the firmware will be subpackaged in a fixed size and be written to the flash one by one, and the device will record upgraded packages. If the upgrade process is interrupted, the device will only request the remaining firmware packages to resume upgrade from break point.\n• Multiple Devices Upgrade: ESP-NOW can support multiple devices upgrade at same time. 50 devices can be upgraded in 3 minutes.\n• Rollback: The firmware can rollback to previous version if an upgrade error occurs.\n\nESP-NOW can be used to receive the running log for debugging. It can be used in scene where the devices can't be contact directly because of the high-voltage electricity, high temperature. With the supporting of many-to-many connections, the initiator can receive logs from multiple responders to diagnose device faults quickly.\n• Device Log\n• Log Analysis: analysis the running time and restart times from log.\n• Log Storage: store the acquired data in the SD cards or export to the web.\n• Log Level Modification: the log level of each function model can be freely adjusted.\n• Debug Commands\n• Peripheral Debugging: Control commands can be sent to test the peripherals like GPIO, UART, LED, etc.\n• Wi-Fi Debugging: The country code, Wi-Fi mode, Wi-Fi power, etc., can be adjusted, and the performance of Wi-Fi can be debugged.\n• Production Test\n• Interference Test: distribute a large number of Wi-Fi data packets to interfere with the network.\n• Version Verification: verify whether the factory version of the device is the specified version.\n\nESP-NOW can protect the data security with ECDH and AES128-CCM.\n• Quick Configuration: 16 devices can be configurated in 5 seconds.\n• Multiple Devices Handshake: ESP-NOW initiator can support multiple devices handshake at same time.\n• Safety:\n• ECDH and Proof of Possession (PoP) string used to authorize session and derive shared key\n• The esp32.com forum is a place to ask questions and find community resources.\n• Check the Issues section on github if you find a bug or have a feature request. Please check existing Issues before opening a new one.\n• ESP-FAQ which include some common FAQs. Please click it if something is not working when you enable ESP-NOW in your project."
    }
]