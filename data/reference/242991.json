[
    {
        "link": "https://doc.qt.io/qt-6/plugins-howto.html",
        "document": "Qt provides two APIs for creating plugins:\n• A high-level API for writing extensions to Qt itself, such as custom database drivers, image formats, text codecs, and custom styles.\n\nFor example, if you want to write a custom QStyle subclass and have Qt applications load it dynamically, you would use the higher-level API.\n\nSince the higher-level API is built on top of the lower-level API, some issues are common to both.\n\nIf you want to provide plugins for use with Qt Widgets Designer, see Creating Custom Widget Plugins.\n\nWriting a plugin that extends Qt itself is achieved by subclassing the appropriate plugin base class, implementing a few functions, and adding a macro.\n\nThere are several plugin base classes. Derived plugins are stored by default in sub-directories of the standard plugin directory. Qt will not find plugins if they are not stored in the appropriate directory.\n\nThe following table summarizes the plugin base classes. Some of the classes are private, and are therefore not documented. You can use them, but there is no compatibility promise with later Qt versions.\n\nIf you have a new document viewer class called that you want to make available as a plugin, the class needs to be defined as follows ( ):\n\nEnsure that the class implementation is located in a file:\n\nIn addition, a json file ( ) containing meta data describing the plugin is required for most plugins. For document viewer plugins it simply contains the name of the viewer plugin.\n\nThe type of information that needs to be provided in the json file is plugin dependent. See the class documentation for details on the information that needs to be contained in the file.\n\nFor database drivers, image formats, text codecs, and most other plugin types, no explicit object creation is required. Qt will find and create them as required.\n\nPlugin classes may require additional functions to be implemented. See the class documentation for details of the virtual functions that must be reimplemented for each type of plugin.\n\nThe Document Viewer Demo shows how to implement a plugin that displayes structured contents of a file. Each plugin therefore reimplements virtual functions, which\n• inform whether there is content to display and\n\nIn addition to Qt itself, Qt applications can be extended through plugins. This requires the application to detect and load plugins using QPluginLoader. In that context, plugins may provide arbitrary functionality and are not limited to database drivers, image formats, text codecs, styles, and other types of plugins that extend Qt's functionality.\n\nMaking an application extensible through plugins involves the following steps:\n• Define a set of interfaces (classes with only pure virtual functions) used to talk to the plugins.\n• Use the Q_DECLARE_INTERFACE() macro to tell Qt's meta-object system about the interface.\n• Use QPluginLoader in the application to load the plugins.\n• Use qobject_cast() to test whether a plugin implements a given interface.\n• Declare a plugin class that inherits from QObject and from the interfaces that the plugin wants to provide.\n• Use the Q_INTERFACES() macro to tell Qt's meta-object system about the interfaces.\n• Export the plugin using the Q_PLUGIN_METADATA() macro.\n\nFor example, here's the definition of an interface class:\n\nSee also Creating Custom Widgets for Qt Widgets Designer for information about issues that are specific to Qt Widgets Designer.\n\nQt applications automatically know which plugins are available, because plugins are stored in the standard plugin subdirectories. Because of this, applications don't require any code to find and load plugins, since Qt handles them automatically.\n\nDuring development, the directory for plugins is (where is the directory where Qt is installed), with each type of plugin in a subdirectory for that type, for example, . If you want your applications to use plugins and you don't want to use the standard plugins path, have your installation process determine the path you want to use for the plugins, and save the path, for example, by using QSettings, for the application to read when it runs. The application can then call QCoreApplication::addLibraryPath() with this path and your plugins will be available to the application. Note that the final part of the path (for example, ) cannot be changed.\n\nIf you want the plugin to be loadable, one approach is to create a subdirectory under the application, and place the plugin in that directory. If you distribute any of the plugins that come with Qt (the ones located in the directory), you must copy the subdirectory under where the plugin is located to your applications root folder (i.e., do not include the directory).\n\nFor more information about deployment, see the Deploying Qt Applications and Deploying Plugins documentation.\n\nThe normal and most flexible way to include a plugin with an application is to compile it into a dynamic library that is shipped separately, and detected and loaded at runtime.\n\nPlugins can be linked statically into your application. If you build the static version of Qt, this is the only option for including Qt's predefined plugins. Using static plugins makes the deployment less error-prone, but has the disadvantage that no functionality from plugins can be added without a complete rebuild and redistribution of the application.\n\nCMake and qmake automatically add the plugins that are typically needed by the Qt modules that are used, while more specialized plugins need to be added manually. The default list of automatically added plugins can be overridden per type.\n\nThe defaults are tuned towards an optimal out-of-the-box experience, but may unnecessarily bloat the application. It is recommended to inspect the linker command line and eliminate unnecessary plugins.\n\nTo cause static plugins actually being linked and instantiated, Q_IMPORT_PLUGIN() macros are also needed in application code, but those are automatically generated by the build system and added to your application project.\n\nTo statically link plugins in a CMake project, you need to call the qt_import_plugins command.\n\nFor example, the Linux plugin is not imported by default. The following command imports it:\n\nTo link the minimal platform integration plugin instead of the default Qt platform adaptation plugin, use:\n\nAnother typical use case is to link only a certain set of plugins:\n\nIf you want to prevent the linking of any plugin, use:\n\nIf you want to turn off the addition of any default plugin, use the option of qt_import_plugins.\n\nIn a qmake project, you need to add the required plugins to your build using :\n\nFor example, to link the minimal plugin instead of the default Qt platform adaptation plugin, use:\n\nIf you want neither the default, nor the minimal QPA plugin to be linked automatically, use:\n\nIf you do not want all plugins added to QTPLUGIN to be automatically linked, remove from the variable:\n\nIt is also possible to create your own static plugins by following these steps:\n• Pass the option to the qt_add_plugin command in your . For a qmake project, add to your plugin's file.\n• Use the Q_IMPORT_PLUGIN() macro in your application.\n• Use the Q_INIT_RESOURCE() macro in your application if the plugin ships qrc files.\n• Link your application with your plugin library using target_link_libraries in your or in your file.\n\nSee the Plug & Paint example and the associated Basic Tools plugin for details on how to do this.\n\nPlugin types (static or shared) and operating systems require specific approaches to locate and load plugins. It's useful to implement an abstraction for loading plugins.\n\nQPluginLoader::staticInstances() returns a QObjectList with a pointer to each statically linked plugin\n\nShared plugins reside in their deployment directories, which may require OS-specific handling.\n\nThe Deploying Plugins document covers the process of deploying plugins with applications and debugging them when problems arise."
    },
    {
        "link": "https://doc.qt.io/qt-6/whatsnew63.html",
        "document": "New and Restored Modules in Qt 6.3\n• Qt Language Server: implements the Language Server Protocol Specification and the JsonRpc 2.0 protocol. The module does not contain a public API.\n\nQt 6.3 reintroduces the following modules that were not present in Qt 6.2. All listed modules were ported to Qt 6 and the CMake build system.\n\nA more detailed list of changes to each module can be found in Changes to Qt Modules in Qt 6.\n• QMetaType can now convert any QFuture<T> to QFuture<void>.\n• Added QDirIterator::nextFileInfo(), to advance and get full file information.\n• QLocale's mappings of language codes to and from Language values now have overloads specifying which ISO 639 code types to consider.\n• QRegularExpressionMatch now has hasCaptured() methods to test whether a given group was captured at all.\n• QProcessEnvironment gained a new enum and constructor that allows you to choose whether the process environment shall be inherited from the parent process when a respective QProcess is launched. Warning: In older Qt versions, the default behavior was to inherit, although the documentation said it won't. Qt 6.3 changes the behavior of the default constructor to actually match the documentation. That is, launching a QProcess with a QProcessEnvironment created by QProcessEnvironment() will be launched in an empty environment. Use QProcessEnvironment(QProcessEnvironment::InheritFromParent) to revert to the old behavior. Also, added method inheritsFromParent() to test for an instance constructed the new way.\n• QVarLengthArray now has emplace() and emplace_back() methods.\n• Time formats used by QLocale, QTime and QDateTime's parsing and serialization now recognize 'aP' and 'Ap' format specifiers to obtain an AM/PM indicator, using the locale-appropriate case for the indicator, where previously the author of a time format had to pick a case that might conflict with the user's locale. For QTime and QDateTime the locale is always C, whose indicators are uppercase. For QLocale, the case will now match that of amText() or pmText(). Previously, 'aP' would have been read as a lower-case indicator followed by a 'P' and 'Ap' as an upper-case indicator followed by a 'p'. The 'P' or 'p' will now be treated as part of the format specifier: if the prior behavior is desired, either use 'APp' or 'apP' as format specifier or quote the 'p' or 'P' in the format. The prior 'a', 'ap', 'A' and 'AP' specifiers are otherwise unaffected.\n• QObject::findChildren() now has an overload taking no name.\n• Added overloads and method names to QSemaphore for greater compatibility with std::counting_semaphore and std::chrono.\n• QJsonValue now has rvalue constructors taking QJsonArray and QJsonObject.\n• QCborMap::fromJsonObject() and QCborArray::fromJsonArray() now have rvalue overloads.\n• QUuid can now be constructed from QAnyStringView.\n• QByteArrayList::join() now has an overload taking QByteArrayView.\n• QCryptographicHash::addData() now has an overload taking QByteArrayView.\n• Added new public CMake API:\n• for generating a qt.conf file at installation time: qt_deploy_qt_conf() (in Technical Preview)\n• for deploying runtime dependencies at installation time: qt_deploy_runtime_dependencies() (in Technical Preview)\n• for performing platform-specific tasks associated with a Qt project: qt_finalize_project() (in Technical Preview)\n• Calling QGuiApplication::setLayoutDirection() with a non-auto value now disables the auto-detection based on installed translators.\n• URL handlers passed to QDesktopServices::setUrlHandler() must now be removed by calling unsetUrlHandler() before they are destroyed. Relying on the handler's destructor to implicitly unset them is deprecated.\n• QVulkanWindow now enables all Vulkan 1.0 features that are reported as supported by the physical device.\n• HoverHandler and WheelHandler have a property to control whether the hover and wheel events respectively propagate to items and handlers behind the handler's .\n• TapHandler now has one more gesturePolicy value: ; it is similar to , except that even if the user drags while holding the point pressed, timeHeld is not reset during dragging, and the longPressed signal is emitted regardless of the drag threshold, if the user holds it that long. This is useful for implementing press-drag-release components such as menus (like the pie menu in the pointer handlers example) while using to directly drive an \"opening\" animation.\n• QQuickItem::clipRect() now provides the region visible in the viewport (the parent Flickable or Window), and can be used to limit scene graph node vertices as an optimization in custom items, at the cost of having updatePaintNode() called more often. See docs about the new QQuickItem::ItemObservesViewport and QQuickItem::ItemIsViewport flags.\n• To save memory and startup time, Text and TextEdit now avoid generating scene graph nodes for large portions of text that are invisible because of falling outside the viewport (Flickable or Window).\n• Text now renders horizontal rules from HTML or Markdown.\n• In Text, horizontal rules and underline/overline/strikethrough lines can be colored by CSS rules included in HTML source.\n• QQuickItem::dumpItemTree() has been added; it can be called from C++ (similar to QObject::dumpObjectTree()) or from QML, to show the qDebug-operator output for an item and all its children, indented to show the tree structure.\n• TapHandler tapped, singleTapped and doubleTapped signals now have two arguments: the QEventPoint instance, and the being tapped. If you need a signal handler, you should write an explicit function to receive those arguments:\n• DragHandler activeTranslation now holds the amount of movement since the drag gesture began. persistentTranslation holds the accumulated sum of movement that has occurred during subsequent drag gestures, and can be reset to arbitrary values between gestures.\n• Added FolderDialog and MessageDialog. These are native dialogs on platforms that support it, and non-native Qt Quick dialogs on other platforms. The non-native dialogs support all of the non-native styles: Basic, Fusion, Imagine, Material and Universal.\n• QToolBar now supports scrolling with a kinetic wheel or track pad.\n\nSeveral new QStyle enum values are available to allow styles to customize additional look and feel aspects of a widget-based UI:\n• PM_LineEditIconMargin to customize the margin around an icon in a QLineEdit.\n• SH_Table_AlwaysDrawLeftTopGridLines to control whether the left and top grid lines are always painted, also when the headers are hidden.\n• SH_SpinBox_SelectOnStep to control whether changing the value using the up/down buttons should select the text.\n• SP_TabCloseButton to specify an icon for the close button in the tab of a QTabBar\n• QNetworkInformation learned transportMedium. A property that returns the transport medium of the primary network interface.\n• QNetworkInformation also learned isMetered. A property that returns whether the network is metered.\n• Added tech preview QML type compiler ( ) that compiles QML type structure to C++.\n• Added several new warnings to qmllint which now uses compiler infrastructure.\n• The header only qmlintegration module allows to mark types for registration in a QML module, without adding a dependency to qtdeclarative. Those can then be added to a QML module via the new qt_generate_foreign_qml_types() CMake API.\n• qmlcachegen compiles suitable functions and expressions to C++ now, for improved performance.\n• Added new public CMake API:\n• for registering a target's foreign types in a QML module: qt_generate_foreign_qml_types() (in Technical Preview)\n• for compiling QML code into C++: qt_target_compile_qml_to_cpp() (in Technical Preview)\n• for deploying the runtime components of QML modules at installation time: qt_deploy_qml_imports() (in Technical Preview)\n• for querying information about a QML module: qt_query_qml_module() (in Technical Preview)\n• Added ReflectionProbe, making it possible for models to show reflections.\n• Particles3D: New element which loads emitting shapes from custom CBOR binary files.\n• Particles3D: Sprite particles now have support for the 3D environment lights.\n• Particles3D: New element for declarative dynamic emitting and for emitting at trail start/end times.\n• Added ResourceLoader component for explicit setting of resource lifetimes (in Technical Preview)\n• glTF2: Importers now support the following additional extensions: KHR_materials_clearcoat, KHR_materials_ior, KHR_materials_transmission, KHR_materials_volume\n• Now builds with Python 3 instead of Python 2\n• Added new public CMake API:\n• for converting Hunspell dictionaries to the Qt WebEngine binary format: qt_add_webengine_dictionary()\n• Added a new wireframeColor property to set the wireframe color for a QSurface3DSeries in Q3DSurface.\n• Added a new rowColors property to set different colors for rows of bars in Q3DBars.\n• Added a new barSeriesMargin property to set the margin for individual bars in Q3DBars.\n• Added a hasSeries function to check whether a series is already added in QAbstract3DGraph.\n• New DirectionAccuracy attribute is added for Android and iOS platforms. It represents the accuracy of the provided bearing.\n• Extended the Windows implementation of QBluetoothLocalDevice. It reports the adapter state correctly, and allows to toggle its state. Support for connected/disconnected devices tracking is still missing.\n• Extended QBluetoothDeviceInfo API to expose Bluetooth Low Energy service data as published during the advertisement.\n• Added an API to create custom shell extensions. For instructions on usage, see the example.\n• Added a Qt Shell which supports all windowing system features available in Qt.\n• Added support for multiple input method protocols in the same server, in order to support clients from different sources.\n\nSeveral improvements have been made for Qt for WebAssembly. See the platform documentation at Qt for WebAssembly for details.\n• Added support for copy/paste of images and html text to the system clipboard.\n• Added support for calling QEventLoop::exec() and QThread::exec() on secondary threads.\n• Added support for calling QEventLoop::exec() and QDialog::exec() on the main thread using Emscripten Asyncify. Note that enabling asyncify requires building Qt from source.\n• Added support for tunneling TCP and UDP sockets over WebSockets, using Emscriptens Emulated POSIX TCP Sockets over WebSockets. This support is limited to async sockets on the main thread.\n\nWindows on ARM64 remains in Technology Preview as problems with optimized builds of Qt could not be resolved yet.\n• The In-App purchasing demo and Qt 3D: Planets QML Example had android specific improvements.\n• Updated Gradle to 7.2.0 and the Android Gradle Plugin (AGP) to 7.0.2 (requires JDK 11 or above).\n• QML modules are now staged to a common directory named \"android-qml\" under the user's build folder. This acts as a common import path for The androiddeployqt Tool.\n• The QML Test Bench now works for Android builds.\n• Boot to Qt stack was updated to use Yocto 3.4 (honister).\n• Qt PDF and Qt Language Server were included in Boot to Qt stack.\n• Added support for selecting input method protocol, if the server supports multiple interfaces. This can be done by setting QT_WAYLAND_TEXT_INPUT_PROTOCOL to the name of the protocol.\n\nThese pages contain an overview of API changes in Qt 6.3:\n• New Classes and Functions in Qt 6.3"
    },
    {
        "link": "https://qt.io/resources/qt",
        "document": ""
    },
    {
        "link": "https://github.com/conan-io/conan-center-index/issues/13144",
        "document": "I have a small QML test project that I am able to build and run succesfully on MacOS.\n\nWhen I am building however the same project on Windows, qt/6.3.1 fails to build and to be honest I am having a hard time understanding what's the reason (CMakeError and CMakeOutput do not really tell me much).\n\nThe profile I am using is as follows:\n\nand I am configuring qt like this:\n\nDid anyone successfully build qt/6.3.1 on Windows 11 with Visual Studio 2019?"
    },
    {
        "link": "https://formulae.brew.sh/formula",
        "document": "This is a listing of all packages available from the core tap via the Homebrew package manager for macOS and Linux."
    },
    {
        "link": "https://stackoverflow.com/questions/22423280/is-it-possible-to-use-qsqldatabase-along-sqlcipher",
        "document": "I want to use an encrypted SQLite database in Qt. Is it possible to connect to database by and use SQLCipher to encrypt or decrypt the database? for instance regularly i connect to SQLite database file like this:\n\nI want to know is it possible to use the SQLCipher API to decrypt the database and use the Qt database module to connect and manipulate the database?"
    },
    {
        "link": "https://forum.qt.io/topic/37817/using-sqlcipher-in-place-of-sqlite",
        "document": "I would like to use encrypted SQLite databases with Qt.\n\n The company I work for, has been using SQLCipher with C++ Builder XE3 for almost two years (they bought a license). In this context it's pretty easy cause there's only a sqlite3.dll file to load.\n\nWe're switching from C++ Builder to Qt.\n\n With Qt I can access SQLite database with the sqlite3 driver compiled with Qt. I tried it, it works and it's pretty easy to use.\n\nAccording to the documentation it is possible to link with my own sqlite library (\"How to Build the QSQLITE Plugin\":http://qt-project.org/doc/qt-5.0/qtsql/sql-driver.html#qsqlite).\n\nWhen we bought a SQLCipher licence we got a zip file which contains the following file:\n\nI tried to recompile the SQLite driver for Qt but it failed.\n\n Here the step I followed:\n\nBut it failed with the error : \"ld.exe: cannot find -lsqlite3\"\n\nDo you think it's due to the sqlite3.lib file which might be sqlite3.a ?\n\n In this case I will have to recompile sqlcipher with mingw-32.\n\nI've seen those articles but I wanted to only link a specifc lib without recompiling SQLCipher.\n\n \"Building QSQLITE driver with AES-256 encryption support\":http://www.qtcentre.org/wiki/index.php?title=Building_QSQLITE_driver_with_AES-256_encryption_support\n\nDoes anyone have an idea ?"
    },
    {
        "link": "https://stackoverflow.com/questions/29196087/how-to-build-the-qt-sql-driver-plugin-qsqlcipher-for-sqlite-db-with-sqlcipher",
        "document": "When delivering a Qt-program do not forget the Qt-libraries, the platforms-libraries, SQL-driver-plugin 'qsqlcipher.dll' and the OpenSSL-library 'libeay32.dll'. Example for the test program above:\n\nCaution: The test program contains the key:\n\nThis key string in the binary file of the test program can easiliy be read using a hex-editor, which is, to my opinion, a lack in security:\n\nFor approaches how to solve this problem, ask the search engine of your own choice. ;-)\n\n E.g. search for: hide string in executable"
    },
    {
        "link": "https://zetetic.net/sqlcipher/sqlcipher-api",
        "document": ""
    },
    {
        "link": "https://github.com/devbean/QtCipherSqlitePlugin/issues/16",
        "document": "I have manually created a SQLite database (named \"localDB.db\") and protected it with a password, by using DB browser. If I am not mistaken, DB browser uses SQLCipher (with a default page size of 1024), for encrypting a database.\n\n However, if I try to open the database with this plugin (see following code), I always get the error that \"the password is invalid or cipher does not match\", although I clearly use the correct password and have set the cipher as \"sqlcipher\".\n\nThe same happens for the inverse process: if I encrypt a database by using this plugin, then I am unable to manually open the database with DB Browser or other similar programs, because it does not accept the password.\n\nHow can I solve this problem? I need to access an encrypted sqlite database through both my software and a third-party application like DB browser."
    },
    {
        "link": "https://doc.qt.io/qt-6/qsqldatabase.html",
        "document": "The QSqlDatabase class handles a connection to a database. More...\n\nNote: When using transactions, you must start the transaction before you create your query.\n\nIf you create multiple database connections, specify a unique connection name for each one, when you call addDatabase (). Use database () with a connection name to get that connection. Use removeDatabase () with a connection name to remove a connection. QSqlDatabase outputs a warning if you try to remove a connection referenced by other QSqlDatabase objects. Use contains () to see if a given connection name is in the list of connections.\n\nWarning: It is highly recommended that you do not keep a copy of the QSqlDatabase around as a member of a class, as this will prevent the instance from being correctly cleaned up on shutdown. If you need to access an existing QSqlDatabase, it should be accessed with database (). If you chose to have a QSqlDatabase member variable, this needs to be deleted before the QCoreApplication instance is deleted, otherwise it may lead to undefined behavior.\n\nQSqlDatabase is a value class. Changes made to a database connection via one instance of QSqlDatabase will affect other instances of QSqlDatabase that represent the same connection. Use cloneDatabase () to create an independent database connection based on an existing one.\n\nThe connection defined above will be the default connection, because we didn't give a connection name to addDatabase (). Subsequently, you can get the default connection by calling database () without the connection name argument:\n\nOnce the QSqlDatabase object has been created, set the connection parameters with setDatabaseName (), setUserName (), setPassword (), setHostName (), setPort (), and setConnectOptions (). Then call open () to activate the physical connection to the database. The connection is not usable until you open it.\n\nCreate a connection (i.e., an instance of QSqlDatabase) by calling one of the static addDatabase () functions, where you specify the driver or type of driver to use (depending on the type of database) and a connection name. A connection is known by its own name, not by the name of the database it connects to. You can have multiple connections to one database. QSqlDatabase also supports the concept of a default connection, which is the unnamed connection. To create the default connection, don't pass the connection name argument when you call addDatabase (). Subsequently, the default connection will be assumed if you call any static member function without specifying the connection name. The following snippet shows how to create and open a default connection to a PostgreSQL database:\n\nThe QSqlDatabase class provides an interface for accessing a database through a connection. An instance of QSqlDatabase represents the connection. The connection provides access to the database via one of the supported database drivers , which are derived from QSqlDriver . Alternatively, you can subclass your own database driver from QSqlDriver . See How to Write Your Own Database Driver for more information. A QSqlDatabase instance must only be accessed by the thread it was created in. Therefore you have to make sure to create them in the correct context. Alternatively you can change the context with QSqlDatabase::moveToThread ().\n\nSee also QSqlDriver, QSqlQuery, Qt SQL, and Threads and the SQL Module.\n\nSee also QSql::NumericalPrecisionPolicy , QSqlQuery::numericalPrecisionPolicy , and QSqlDriver::numericalPrecisionPolicy .\n\nThis property was introduced in Qt 6.8.\n\nNote: Setting the default precision policy to precisionPolicy doesn't affect any currently active queries.\n\nNote: Drivers that don't support fetching numerical values with low precision will ignore the precision policy. You can use QSqlDriver::hasFeature () to find out whether a driver supports this feature.\n\nThis property holds the default numerical precision policy used by queries created on this database connection.\n\nCreates an empty, invalid QSqlDatabase object. Use addDatabase(), removeDatabase(), and database() to get valid QSqlDatabase objects.\n\nThis is an overloaded function.\n\nCreates a database connection using the given driver.\n\nThis is an overloaded function.\n\nCreates a QSqlDatabase connection that uses the driver referred to by type. If the type is not recognized, the database connection will have no functionality.\n\nThe currently available driver types are:\n\nAdditional third party drivers, including your own custom drivers, can be loaded dynamically.\n\nSee also SQL Database Drivers, registerSqlDriver(), and drivers().\n\nDestroys the object and frees any allocated resources.\n\nAdds a database to the list of database connections using the driver type and the connection name connectionName. If there already exists a database connection called connectionName, that connection is removed.\n\nThe database connection is referred to by connectionName. The newly added database connection is returned.\n\nIf type is not available or could not be loaded, isValid() returns .\n\nIf connectionName is not specified, the new connection becomes the default connection for the application, and subsequent calls to database() without the connection name argument will return the default connection. If a connectionName is provided here, use database(connectionName) to retrieve the connection.\n\nBefore using the connection, it must be initialized. e.g., call some or all of setDatabaseName(), setUserName(), setPassword(), setHostName(), setPort(), and setConnectOptions(), and, finally, open().\n\nSee also database(), removeDatabase(), and Threads and the SQL Module.\n\nThis is an overloaded function.\n\nThis overload is useful when you want to create a database connection with a driver you instantiated yourself. It might be your own database driver, or you might just need to instantiate one of the Qt drivers yourself. If you do this, it is recommended that you include the driver code in your application. For example, you can create a PostgreSQL connection with your own QPSQL driver like this:\n\nThe above code sets up a PostgreSQL connection and instantiates a QPSQLDriver object. Next, addDatabase() is called to add the connection to the known connections so that it can be used by the Qt SQL classes. When a driver is instantiated with a connection handle (or set of handles), Qt assumes that you have already opened the database connection.\n\nRemember that you must link your application against the database client library. Make sure the client library is in your linker's search path, and add lines like these to your file:\n\nThe method described works for all the supplied drivers. The only difference will be in the driver constructor arguments. Here is a table of the drivers included with Qt, their source code files, and their constructor arguments:\n\nClones the database connection other and stores it as connectionName. All the settings from the original database, e.g. databaseName(), hostName(), etc., are copied across. Does nothing if other is an invalid database. Returns the newly created database connection.\n\nThis is an overloaded function.\n\nClones the database connection other and stores it as connectionName. All the settings from the original database, e.g. databaseName(), hostName(), etc., are copied across. Does nothing if other is an invalid database. Returns the newly created database connection.\n\nThis overload is useful when cloning the database in another thread to the one that is used by the database represented by other.\n\nCloses the database connection, freeing any resources acquired, and invalidating any existing QSqlQuery objects that are used with the database.\n\nThis will also affect copies of this QSqlDatabase object.\n\nCommits a transaction to the database if the driver supports transactions and a transaction() has been started. Returns if the operation succeeded. Otherwise it returns .\n\nCall lastError() to get information about errors.\n\nSee also QSqlQuery::isActive(), QSqlDriver::hasFeature(), and rollback().\n\nReturns the connection options string used for this connection. The string may be empty.\n\nReturns the connection name, which may be empty.\n\nReturns a list containing the names of all connections.\n\nSee also contains(), database(), and Threads and the SQL Module.\n\nReturns if the list of database connections contains connectionName; otherwise returns .\n\nSee also connectionNames(), database(), and Threads and the SQL Module.\n\nReturns the database connection called connectionName. The database connection must have been previously added with addDatabase(). If open is true (the default) and the database connection is not already open it is opened now. If no connectionName is specified the default connection is used. If connectionName does not exist in the list of databases, an invalid connection is returned.\n\nSee also isOpen() and Threads and the SQL Module.\n\nReturns the connection's database name, which may be empty.\n\nReturns the database driver used to access the database connection.\n\nSee also addDatabase() and drivers().\n\nSee also addDatabase() and driver().\n\nReturns a list of all the available database drivers.\n\nReturns the connection's host name; it may be empty.\n\nReturns if a driver called name is available; otherwise returns .\n\nReturns if the database connection is currently open; otherwise returns .\n\nReturns if there was an error opening the database connection; otherwise returns . Error information can be retrieved using the lastError() function.\n\nReturns if the QSqlDatabase has a valid driver.\n\nReturns information about the last error that occurred on the database.\n\nFailures that occur in conjunction with an individual query are reported by QSqlQuery::lastError().\n\nSee also QSqlError and QSqlQuery::lastError().\n\nChanges the thread affinity for QSqlDatabase and its associated driver. This function returns when the function succeeds. Event processing will continue in the targetThread.\n\nDuring this operation you have to make sure that there is no QSqlQuery bound to this instance otherwise the QSqlDatabase will not be moved to the given thread and the function returns .\n\nSince the associated driver is derived from QObject, all constraints for moving a QObject to another thread also apply to this function.\n\nThis function was introduced in Qt 6.8.\n\nSee also QObject::moveToThread() and Threads and the SQL Module.\n\nOpens the database connection using the current connection values. Returns on success; otherwise returns . Error information can be retrieved using lastError().\n\nSee also lastError(), setDatabaseName(), setUserName(), setPassword(), setHostName(), setPort(), and setConnectOptions().\n\nThis is an overloaded function.\n\nOpens the database connection using the given user name and password. Returns on success; otherwise returns . Error information can be retrieved using the lastError() function.\n\nThis function does not store the password it is given. Instead, the password is passed directly to the driver for opening the connection and it is then discarded.\n\nReturns the connection's password. An empty string will be returned if the password was not set with setPassword(), and if the password was given in the open() call, or if no password was used.\n\nReturns the connection's port number. The value is undefined if the port number has not been set.\n\nReturns the primary index for table tablename. If no primary index exists, an empty QSqlIndex is returned.\n\nSee also tables() and record().\n\nReturns a QSqlRecord populated with the names of all the fields in the table (or view) called tablename. The order in which the fields appear in the record is undefined. If no such table (or view) exists, an empty record is returned.\n\nThis function registers a new SQL driver called name, within the SQL framework. This is useful if you have a custom SQL driver and don't want to compile it as a plugin.\n\nQSqlDatabase takes ownership of the creator pointer, so you mustn't delete it yourself.\n\nRemoves the database connection connectionName from the list of database connections.\n\nThe correct way to do it:\n\nTo remove the default connection, which may have been created with a call to addDatabase() not specifying a connection name, you can retrieve the default connection name by calling connectionName() on the database returned by database(). Note that if a default database hasn't been created an invalid database will be returned.\n\nSee also database(), connectionName(), and Threads and the SQL Module.\n\nRolls back a transaction on the database, if the driver supports transactions and a transaction() has been started. Returns if the operation succeeded. Otherwise it returns .\n\nCall lastError() to get information about errors.\n\nSee also QSqlQuery::isActive(), QSqlDriver::hasFeature(), and commit().\n\nSets database-specific options. This must be done before the connection is opened, otherwise it has no effect. Another possibility is to close the connection, call QSqlDatabase::setConnectOptions(), and open() the connection again.\n\nThe format of the options string is a semicolon separated list of option names or option=value pairs. The options depend on the database client used and are described for each plugin in the SQL Database Drivers page.\n\nRefer to the client library documentation for more information about the different options.\n\nSets the connection's database name to name. To have effect, the database name must be set before the connection is opened. Alternatively, you can close() the connection, set the database name, and call open() again.\n\nFor the QSQLITE driver, if the database name specified does not exist, then it will create the file for you unless the QSQLITE_OPEN_READONLY option is set.\n\nAdditionally, name can be set to which will create a temporary database which is only available for the lifetime of the application.\n\nFor the QOCI (Oracle) driver, the database name is the TNS Service Name.\n\nFor the QODBC driver, the name can either be a DSN, a DSN filename (in which case the file must have a extension), or a connection string.\n\nFor example, Microsoft Access users can use the following connection string to open an file directly, instead of having to create a DSN entry in the ODBC manager:\n\nThere is no default value.\n\nSee also databaseName(), setUserName(), setPassword(), setHostName(), setPort(), setConnectOptions(), and open().\n\nSets the connection's host name to host. To have effect, the host name must be set before the connection is opened. Alternatively, you can close() the connection, set the host name, and call open() again.\n\nThere is no default value.\n\nSee also hostName(), setUserName(), setPassword(), setDatabaseName(), setPort(), setConnectOptions(), and open().\n\nSets the connection's password to password. To have effect, the password must be set before the connection is opened. Alternatively, you can close() the connection, set the password, and call open() again.\n\nThere is no default value.\n\nSee also password(), setUserName(), setDatabaseName(), setHostName(), setPort(), setConnectOptions(), and open().\n\nSets the connection's port number to port. To have effect, the port number must be set before the connection is opened. Alternatively, you can close() the connection, set the port number, and call open() again..\n\nThere is no default value.\n\nSee also port(), setUserName(), setPassword(), setHostName(), setDatabaseName(), setConnectOptions(), and open().\n\nSets the connection's user name to name. To have effect, the user name must be set before the connection is opened. Alternatively, you can close() the connection, set the user name, and call open() again.\n\nThere is no default value.\n\nSee also userName(), setDatabaseName(), setPassword(), setHostName(), setPort(), setConnectOptions(), and open().\n\nReturns a list of the database's tables, system tables and views, as specified by the parameter type.\n\nSee also primaryIndex() and record().\n\nReturns a pointer to the associated QThread instance.\n\nThis function was introduced in Qt 6.8.\n\nBegins a transaction on the database if the driver supports transactions. Returns if the operation succeeded. Otherwise it returns .\n\nSee also QSqlDriver::hasFeature(), commit(), and rollback().\n\nReturns the connection's user name; it may be empty.\n\nAssigns other to this object."
    },
    {
        "link": "https://stackoverflow.com/questions/31524893/create-a-class-for-database-connection-in-qt",
        "document": "I can give you my source code of my class for connecting to my database. I saved my specific database data in a txt file, so if i install it on another computer I can just make the txt file fit. Here the header:\n\nAnd here the cpp file. should be exaxtly what you are looking for"
    },
    {
        "link": "http://osr600doc.xinuos.com/en/SDK_qt3/qsqldatabase.html",
        "document": "The QSqlDatabase class is used to create SQL database connections and to provide transaction handling. More...\n\nNote that transaction handling is not supported by every SQL database. You can find out whether transactions are supported using QSqlDriver::hasFeature().\n\nThe QSqlDatabase class provides an abstract interface for accessing many types of database backends. Database-specific drivers are used internally to actually access and manipulate data, (see QSqlDriver). Result set objects provide the interface for executing and manipulating SQL queries (see QSqlQuery).\n\nThe currently available drivers are:\n\nAdditional third party drivers, including your own custom drivers, can be loaded dynamically.\n\nCreates a database connection using the driver driver, with the parent parent and the object name objname.\n\nWarning: The framework takes ownership of the driver pointer, so it should not be deleted.\n\nThe database connection is referred to by connectionName. The newly added database connection is returned. This pointer is owned by QSqlDatabase and will be deleted on program exit or when removeDatabase() is called.\n\nIf connectionName is not specified, the newly added database connection becomes the default database connection for the application, and subsequent calls to database() (without a database name parameter) will return a pointer to it. If connectionName is given, use database(connectionName) to retrieve a pointer to the database connection.\n\nWarning: If you add a database with the same name as an existing database, the new database will replace the old one. This will happen automatically if you call this function more than once without specifying connectionName.\n\nSee also database() and removeDatabase().\n\nThis function is useful if you need to set up the database connection and instantiate the driver yourself. If you do this, it is recommended that you include the driver code in your own application. For example, setting up a custom PostgreSQL connection and instantiating the QPSQL7 driver can be done the following way:\n\nThe above code sets up a PostgreSQL connection and instantiates a QPSQLDriver object. Next, addDatabase() is called to add the connection to the known connections so that it can be used by the Qt SQL classes. When a driver is instantiated with a connection handle (or set of handles), Qt assumes that you have already opened the database connection.\n\nRemember that you must link your application against the database client library as well. The simplest way to do this is to add lines like those below to your file:\n\nYou will need to have the client library in your linker's search path.\n\nThe method described above will work for all the drivers, the only difference is the arguments the driver constructors take. Below is an overview of the drivers and their constructor arguments.\n\nNote: The host name (or service name) is needed when constructing the QTDSDriver for creating new connections for internal queries. This is to prevent the simultaneous usage of several QSqlQuery/QSqlCursor objects from blocking each other.\n\nWarning: The SQL framework takes ownership of the driver pointer, and it should not be deleted. The returned QSqlDatabase object is owned by the framework and must not be deleted. If you want to explicitly remove the connection, use removeDatabase()\n\nSee also QSqlDriver::hasFeature() and rollback().\n\nReturns the database connect options. See the \"connectOptions\" property for details.\n\nWarning: There are restrictions on the use of database connections in threaded applications. Please see the Thread Support in Qt document for more information about threading and SQL databases.\n\nReturns the name of the database. See the \"databaseName\" property for details.\n\nNote that if you want to iterate over the list, you should iterate over a copy, e.g.\n\nSee also QSqlQuery and lastError().\n\nReturns the host name where the database resides. See the \"hostName\" property for details.\n\nOpens the database connection using the given user name and password. Returns TRUE on success; otherwise returns FALSE. Error information can be retrieved using the lastError() function.\n\nThis function does not store the password it is given. Instead, the password is passed directly to the driver for opening a connection and is then discarded.\n\nReturns the password used to connect to the database. See the \"password\" property for details.\n\nReturns the port used to connect to the database. See the \"port\" property for details.\n\nReturns a QSqlRecord populated with the names of all the fields used in the SQL query. If the query is a \"SELECT *\" the order in which fields appear in the record is undefined.\n\nSee also QSqlRecordInfo, QSqlFieldInfo, and record().\n\nReturns a QSqlRecordInfo object with meta data for the QSqlQuery query. Note that this overloaded function may return less information than the recordInfo() function which takes the name of a table as parameter.\n\nSee also QSqlRecordInfo, QSqlFieldInfo, and record().\n\nWarning: The framework takes ownership of the creator pointer, so it should not be deleted.\n\nWarning: There should be no open queries on the database connection when this function is called, otherwise a resource leak will occur.\n\nRemoves the database connection db from the list of database connections. The QSqlDatabase object is destroyed when it is removed from the list.\n\nWarning: The db pointer is not valid after this function has been called. There should be no open queries on the database connection when this function is called, otherwise a resource leak will occur.\n\nSee also QSqlDriver::hasFeature(), commit(), and transaction().\n\nSets the database connect options to options. See the \"connectOptions\" property for details.\n\nSets the name of the database to name. See the \"databaseName\" property for details.\n\nSets the host name where the database resides to host. See the \"hostName\" property for details.\n\nSets the password used to connect to the database to password. See the \"password\" property for details.\n\nSets the port used to connect to the database to p. See the \"port\" property for details.\n\nSets the user name connected to the database to name. See the \"userName\" property for details.\n\nNote that if you want to iterate over the list, you should iterate over a copy, e.g.\n\nReturns a list of the database's tables that are visible to the user. To include views or system tables, use the version of this function that takes a table parameter.\n\nNote that if you want to iterate over the list, you should iterate over a copy, e.g.\n\nSee also QSqlDriver::hasFeature(), commit(), and rollback().\n\nReturns the user name connected to the database. See the \"userName\" property for details.\n\nThe format of the options string is a semi-colon separated list of option names or option = value pairs. The options depend on the database client used:\n\nPlease refer to the client library documentation for more information about the different options. The options will be set prior to opening the database connection. Setting new options without re-opening the connection does nothing.\n\nSet this property's value with setConnectOptions() and get this property's value with connectOptions().\n\nThis property holds the name of the database.\n\nNote that the database name is the TNS Service Name for the QOCI8 (Oracle) driver.\n\nFor the QODBC3 driver it can either be a DSN, a DSN filename (the file must have a extension), or a connection string. MS Access users can for example use the following connection string to open a file directly, instead of having to create a DSN entry in the ODBC manager:\n\nThere is no default value.\n\nSet this property's value with setDatabaseName() and get this property's value with databaseName().\n\nThis property holds the host name where the database resides.\n\nThere is no default value.\n\nSet this property's value with setHostName() and get this property's value with hostName().\n\nThis property holds the password used to connect to the database.\n\nThere is no default value.\n\nWarning: This function stores the password in plain text within Qt. Use the open() call that takes a password as parameter to avoid this behaviour.\n\nSet this property's value with setPassword() and get this property's value with password().\n\nThis property holds the port used to connect to the database.\n\nThere is no default value.\n\nSet this property's value with setPort() and get this property's value with port().\n\nThis property holds the user name connected to the database.\n\nThere is no default value.\n\nSet this property's value with setUserName() and get this property's value with userName().\n\nThis file is part of the Qt toolkit. Copyright © 1995-2007 Trolltech. All Rights Reserved."
    },
    {
        "link": "https://doc.qt.io/qt-6/sql-driver.html",
        "document": "The Qt SQL module uses driver plugins to communicate with the different database APIs. Since Qt's SQL Module API is database-independent, all database-specific code is contained within these drivers. Several drivers are supplied with Qt, and other drivers can be added. The driver source code is supplied and can be used as a model for writing your own drivers.\n\nThe table below lists the drivers included with Qt:\n\nSQLite is the in-process database system with the best test coverage and support on all platforms. Oracle via OCI, PostgreSQL, and MySQL through either ODBC or a native driver are well-tested on Windows and Linux. The completeness of the support for other systems depends on the availability and quality of client libraries.\n\nThe Qt script tries to automatically detect the available client libraries on your machine. Run to see what drivers can be built. You should get an output similar to this:\n\nThe script cannot detect the necessary libraries and include files if they are not in the standard paths, so it may be necessary to specify these paths using either driver-specific include and library path variables or and . For example, if your MySQL files are installed in on Windows, then pass the following parameter to double-dash part of configure line:\n\nWhen you configure drivers in the manner described above, CMake skips any dependency checks and uses the provided paths as is. This is especially useful if the package provides its own set of system libraries that should not be recognized by the build routine.\n\nThe particulars for each driver are explained below.\n\nIt's possible to only compile a specific SQL driver when Qt is already built or installed as binary version. But you have to make sure to install the exact same version of the Qt sources (for example through the Qt Maintenance Tool) - otherwise you might get compile errors due to changed apis. Also make sure to properly set up the build environment by executing the appropriate Qt command prompt in the Windows Start menu.\n\nA typical run (in this case to configure for MySQL) looks like this:\n\nDue to the practicalities of dealing with external dependencies, only the SQLite plugin is shipped with binary builds of Qt. Binary builds of Qt for Windows also include the ODBC and PostgreSQL plugin. To be able to add additional drivers to the Qt installation without re-building all of Qt, it is possible to configure and build the directory outside of a full Qt build directory. Note that it is not possible to configure each driver separately, only all of them at once. Drivers can be built separately, though.\n\nQMYSQL for MySQL or MariaDB 5.6 and higher\n\nMariaDB is a fork of MySQL intended to remain free and open-source software under the GNU General Public License. MariaDB intended to maintain high compatibility with MySQL, ensuring a drop-in replacement capability with library binary parity and exact matching with MySQL APIs and commands. Therefore the plugin for MySQL and MariaDB are combined into one Qt plugin.\n\nSince Qt 6.8, QDateTime values are converted to UTC before insertion and back from UTC during retrieval. To make this work, the driver sets the connection time zone to UTC during open() (SET time_zone = '+00:00'). Since MySQL does not store any timezone information, this information is lost and all retrieved QDateTime values are UTC.\n\nMySQL has stored procedure support at the SQL level, but no API to control IN, OUT, and INOUT parameters. Therefore, parameters have to be set and read using SQL commands instead of QSqlQuery::bindValue().\n\nSource code to access the OUT values:\n\nThe MySQL embedded server is a drop-in replacement for the normal client library. With the embedded MySQL server, a MySQL server is not required to use MySQL functionality.\n\nTo use the embedded MySQL server, simply link the Qt plugin to instead of . This can be done by adding to the configure command line.\n\nPlease refer to the MySQL documentation, chapter \"libmysqld, the Embedded MySQL Server Library\" for more information about the MySQL embedded server.\n\nThe Qt MySQL/MariaDB plugin honors the following connection options:\n\nFor more detailed information about the connect options please refer to the mysql_options() MySQL documentation.\n\nHow to Build the QMYSQL Plugin on Unix and macOS\n\nYou need the MySQL / MariaDB header files, as well as the shared library / . Depending on your Linux distribution, you may need to install a package which is usually called \"mysql-devel\" or \"mariadb-devel\".\n\nTell where to find the MySQL / MariaDB header files and shared libraries (here it is assumed that MySQL / MariaDB is installed in ) and build:\n\nHow to Build the QMYSQL Plugin on Windows\n\nYou need to get the MySQL installation files (e.g. MySQL web installer or MariaDB C Connector). Run the installer, select custom installation and install the MySQL C Connector which matches your Qt installation (x86 or x64). After installation check that the needed files are there:\n\nBuild the plugin as follows (here it is assumed that is ):\n\nWhen you distribute your application, remember to include libmysql.dll / libmariadb.dll in your installation package. It must be placed in the same folder as the application executable. libmysql.dll additionally needs the MSVC runtime libraries which can be installed with vcredist.exe\n\nThe Qt OCI plugin supports connecting to Oracle database as determined by the version of the instant client used. This is dependent on what Oracle indicates it supports. The plugin will auto-detect the database version and enable features accordingly.\n\nIt's possible to connect to a Oracle database without a tnsnames.ora file. This requires that the database SID is passed to the driver as the database name, and that a hostname is given.\n\nThe Qt OCI plugin supports authentication using external credentials (OCI_CRED_EXT). Usually, this means that the database server will use the user authentication provided by the operating system instead of its own authentication mechanism.\n\nLeave the username and password empty when opening a connection with QSqlDatabase to use the external credentials authentication.\n\nBinary Large Objects (BLOBs) can be read and written, but be aware that this process may require a lot of memory. You should use a forward only query to select LOB fields (see QSqlQuery::setForwardOnly()).\n\nInserting BLOBs should be done using either a prepared query where the BLOBs are bound to placeholders or QSqlTableModel, which uses a prepared query to do this internally.\n\nThe Qt OCI plugin honors the following connection options:\n\nHow to Build the OCI Plugin on Unix and macOS\n\nAll you need is the \" - Basic\" and \"Instant Client Package - SDK\".\n\nTell where to find the Oracle header files and shared libraries and build.\n\nWe assume that you installed the RPM packages of the Instant Client Package SDK (you need to adjust the version number accordingly):\n\nHow to Build the OCI Plugin on Windows\n\nChoosing the option \"Programmer\" in the Oracle Client Installer from the Oracle Client Installation CD is generally sufficient to build the plugin. For some versions of Oracle Client, you may also need to select the \"Call Interface (OCI)\" option if it is available.\n\nBuild the plugin as follows (here it is assumed that Oracle Client is installed in and SDK is installed in ):\n\nWhen you run your application, you will also need to add the path to your environment variable:\n\nODBC is a general interface that allows you to connect to multiple DBMSs using a common interface. The QODBC driver allows you to connect to an ODBC driver manager and access the available data sources. Note that you also need to install and configure ODBC drivers for the ODBC driver manager that is installed on your system. The QODBC plugin then allows you to use these data sources in your Qt applications.\n\nOn Windows, an ODBC driver manager is installed by default. For Unix systems, there are some implementations which must be installed first. Note that every end user of your application is required to have an ODBC driver manager installed, otherwise the QODBC plugin will not work.\n\nWhen connecting to an ODBC datasource, you should pass the name of the ODBC datasource (DSN) to the QSqlDatabase::setDatabaseName() function, rather than the actual database name. It's also possible to pass a FILEDSN (*.dsn) filename or a complete ODBC driver string. When passing a driver string you must make sure, that all parameters (username, password, ...) are properly escaped. Passing the username or password through the QSqlDatabase functions, the escaping is done by the QODBC plugin.\n\nThe QODBC Plugin needs an ODBC compliant driver manager version 2.0 or later. Some ODBC drivers claim to be version-2.0-compliant, but do not offer all the necessary functionality. The QODBC plugin therefore checks whether the data source can be used after a connection has been established, and refuses to work if the check fails. If you do not like this behavior, you can remove the line from the file . Do this at your own risk!\n\nBy default, Qt instructs the ODBC driver to behave as an ODBC 2.x driver. However, for some driver-manager/ODBC 3.x-driver combinations (e.g., unixODBC/MaxDB ODBC), telling the ODBC driver to behave as a 2.x driver can cause the driver plugin to have unexpected behavior. To avoid this problem, instruct the ODBC driver to behave as a 3.x driver by setting the connect option before you open your database connection. Note that this will affect multiple aspects of ODBC driver behavior, e.g., the SQLSTATEs. Before setting this connect option, consult your ODBC documentation about behavior differences you can expect.\n\nIf you experience very slow access of the ODBC datasource, make sure that ODBC call tracing is turned off in the ODBC datasource manager.\n\nSome drivers do not support scrollable cursors. In that case, only queries in QSqlQuery::setForwardOnly() mode can be used successfully.\n\nODBC is using TIMESTAMP_STRUCT which has no information about any timezone or similar. Due to this, the QDateTime is used without honoring the timezone at all.\n\nWith Microsoft SQL Server the result set returned by a stored procedure that uses the return statement, or returns multiple result sets, will be accessible only if you set the query's forward only mode to forward using QSqlQuery::setForwardOnly().\n\nThe QODBC Plugin will use the Unicode API if UNICODE is defined. On Windows based systems, this is the default. Note that the ODBC driver and the DBMS must also support Unicode.\n\nFor the Oracle 9 ODBC driver (Windows), it is necessary to check \"SQL_WCHAR support\" in the ODBC driver manager otherwise Oracle will convert all Unicode strings to local 8-bit representation.\n\nThe Qt ODBC plugin honors the following connection options:\n\nFor more detailed information about the connect options please refer to the SQLSetConnectAttr() ODBC documentation.\n\nHow to Build the ODBC Plugin on Unix and macOS\n\nIt is recommended that you use unixODBC. You can find the latest version and ODBC drivers at http://www.unixodbc.org. You need the unixODBC header files and shared libraries.\n\nTell where to find the unixODBC header files and shared libraries (here it is assumed that unixODBC is installed in ) and build:\n\nHow to Build the ODBC Plugin on Windows\n\nThe ODBC header and include files should already be installed in the right directories. You just have to build the plugin as follows:\n\nQPSQL for PostgreSQL (Version 7.3 and above)\n\nThe QPSQL driver supports version 7.3 and higher of the PostgreSQL server.\n\nFor more information about PostgreSQL visit http://www.postgresql.org.\n\nSince Qt 6.8, QDateTime values are converted to UTC before insertion and back from UTC during retrieval. To make this work, the driver sets the connection time zone to UTC during open() (SET TIME ZONE 'UTC'). Although PostgreSQL has the `timestamptz` column type, the timezone used during insertion is not preserved and therefore all retrieved QDateTime values are UTC.\n\nThe QPSQL driver automatically detects whether the PostgreSQL database you are connecting to supports Unicode or not. Unicode is automatically used if the server supports it. Note that the driver only supports the UTF-8 encoding. If your database uses any other encoding, the server must be compiled with Unicode conversion support.\n\nUnicode support was introduced in PostgreSQL version 7.1 and it will only work if both the server and the client library have been compiled with multibyte support. More information about how to set up a multibyte enabled PostgreSQL server can be found in the PostgreSQL Administrator Guide, Chapter 5.\n\nPostgreSQL databases will only respect case sensitivity if the table or field name is quoted when the table is created. So for example, a SQL query such as:\n\nwill ensure that it can be accessed with the same case that was used. If the table or field name is not quoted when created, the actual table name or field name will be lower-case. When QSqlDatabase::record() or QSqlDatabase::primaryIndex() access a table or field that was unquoted when created, the name passed to the function must be lower-case to ensure it is found. For example:\n\nTo use forward-only queries, you must build the QPSQL plugin with PostreSQL client library version 9.2 or later. If the plugin is built with an older version, then forward-only mode will not be available - calling QSqlQuery::setForwardOnly() with will have no effect.\n\nWhile navigating the results in forward-only mode, the handle of QSqlResult may change. Applications that use the low-level handle of SQL result must get a new handle after each call to any of QSqlResult fetch functions. Example:\n\nWhile reading the results of a forward-only query with PostgreSQL, the database connection cannot be used to execute other queries. This is a limitation of libpq library. Example:\n\nThis problem will not occur if query1 and query2 use different database connections, or if we execute query2 after the while loop.\n\nThe Qt PostgreSQL plugin honors all connection options specified in the connect() PostgreSQL documentation.\n\nHow to Build the QPSQL Plugin on Unix and macOS\n\nYou need the PostgreSQL client library and headers installed.\n\nTo make find the PostgreSQL header files and shared libraries, build the plugin the following way (assuming that the PostgreSQL client is installed in ):\n\nHow to Build the QPSQL Plugin on Windows\n\nInstall the appropriate PostgreSQL developer libraries for your compiler. Assuming that PostgreSQL was installed in , build the plugin as follows:\n\nUsers of MinGW may wish to consult the following online document: PostgreSQL MinGW/Native Windows.\n\nWhen you distribute your application, remember to include libpq.dll in your installation package. It must be placed in the same folder as the application executable.\n\nQDB2 for IBM DB2 (Version 7.1 and above)\n\nThe Qt DB2 plugin makes it possible to access IBM DB2 databases. It has been tested with IBM DB2 v7.1 and 7.2. You must install the IBM DB2 development client library, which contains the header and library files necessary for compiling the QDB2 plugin.\n\nThe QDB2 driver supports prepared queries, reading/writing of Unicode strings and reading/writing of BLOBs.\n\nWe suggest using a forward-only query when calling stored procedures in DB2 (see QSqlQuery::setForwardOnly()).\n\nThe Qt IBM DB2 plugin honors the following connection options:\n\nHow to Build the QDB2 Plugin on Unix and macOS\n\nHow to Build the QDB2 Plugin on Windows\n\nThe DB2 header and include files should already be installed in the right directories. You just have to build the plugin as follows:\n\nQSQLITE for SQLite (Version 3 and above)\n\nThe Qt SQLite plugin makes it possible to access SQLite databases. SQLite is an in-process database, which means that it is not necessary to have a database server. SQLite operates on a single file, which must be set as the database name when opening a connection. If the file does not exist, SQLite will try to create it. SQLite also supports in-memory and temporary databases. Simply pass respectively \":memory:\" or an empty string as the database name.\n\nSQLite has some restrictions regarding multiple users and multiple transactions. If you try to read/write on a resource from different transactions, your application might freeze until one transaction commits or rolls back. The Qt SQLite driver will retry to write to a locked resource until it runs into a timeout (see at QSqlDatabase::setConnectOptions()).\n\nIn SQLite any column, with the exception of an INTEGER PRIMARY KEY column, may be used to store any type of value. For instance, a column declared as INTEGER may contain an integer value in one row and a text value in the next. This is due to SQLite associating the type of a value with the value itself rather than with the column it is stored in. A consequence of this is that the type returned by QSqlField::type() only indicates the field's recommended type. No assumption of the actual type should be made from this and the type of the individual values should be checked.\n\nThe driver is locked for updates while a select is executed. This may cause problems when using QSqlTableModel because Qt's item views fetch data as needed (with QSqlQuery::fetchMore() in the case of QSqlTableModel).\n\nYou can find information about SQLite on http://www.sqlite.org.\n\nSQLite does not have a special timestamp column type. A QDateTime is stored as string, formatted in Qt::ISODateWithMs and therefore the QDateTime timezone information is preserved during insertion and select.\n\nThe Qt SQLite plugin honors the following connection options:\n\nHow to Build the QSQLITE Plugin\n\nSQLite version 3 is included as a third-party library within Qt. It can be built by passing the parameter to the command line.\n\nIf you do not want to use the SQLite library included with Qt, you can pass to the command line to use the SQLite libraries of the operating system. This is recommended whenever possible, as it reduces the installation size and removes one component for which you need to track security advisories.\n\nOn Unix and macOS (replace with the directory where SQLite resides):\n\nOn Windows (assuming that SQLite is installed in ):\n\nSQLite comes with a REGEXP operation. However the needed implementation must be provided by the user. For convenience a default implementation can be enabled by setting the connect option before the database connection is opened. Then a SQL statement like \"column REGEXP 'pattern'\" basically expands to the Qt code\n\nFor better performance the regular expressions are cached internally. By default the cache size is 25, but it can be changed through the option's value. For example passing \" \" reduces the cache size to 10.\n\nSQLite minor releases sometimes break file format forward compatibility. For example, SQLite 3.3 can read database files created with SQLite 3.2, but databases created with SQLite 3.3 cannot be read by SQLite 3.2. Please refer to the SQLite documentation and change logs for information about file format compatibility between versions.\n\nQt minor releases usually follow the SQLite minor releases, while Qt patch releases follow SQLite patch releases. Patch releases are therefore both backward and forward compatible.\n\nTo force SQLite to use a specific file format, it is necessary to build and ship your own database plugin with your own SQLite library as illustrated above. Some versions of SQLite can be forced to write a specific file format by setting the define when building SQLite.\n\nThe Qt Mimer SQL plugin makes it possible to work with the Mimer SQL RDBMS. Mimer SQL provides small footprint, scalable and robust relational database solutions that conform to international ISO SQL standards. Mimer SQL is available on Windows, Linux, macOS, and OpenVMS as well as several embedded platforms like QNX, Android, and embedded Linux.\n\nMimer SQL fully support Unicode. To work with Unicode data the column types National Character (NCHAR), National Character Varying (NVARCHAR), or National Character Large Object (NCLOB) must be used. For more information about Mimer SQL and unicode, see https://developer.mimer.com/features/multilingual-support\n\nMimerSQL does not know anything about timezones and QDateTime is used without honoring the timezone at all.\n\nMimer SQL have stored procedures according to the SQL standard (PSM) and the plugin fully support IN, OUT, INOUT parameters as well as resultset procedures.\n\nExample stored procedure with INOUT and OUT parameters:\n\nSource code to access the INOUT and OUT values:\n\nHow to Build the QMIMER Plugin on Unix and macOS\n\nYou need the Mimer SQL header files and shared libraries. Get them by installing any of the Mimer SQL variants found at https://developer.mimer.com.\n\nHow to Build the QMIMER Plugin on Windows\n\nYou need the Mimer SQL header files and shared libraries. Get them by installing any of the Mimer SQL variants found at https://developer.mimer.com.\n\nThe Qt InterBase plugin makes it possible to access the InterBase and Firebird databases. InterBase can either be used as a client/server or without a server in which case it operates on local files. The database file must exist before a connection can be established. Firebird must be used with a server configuration.\n\nNote that InterBase requires you to specify the full path to the database file, no matter whether it is stored locally or on another server.\n\nInterbase stores timestamps in UTC without any timezone information. Due to this, the QDateTime is used without honoring the timezone at all.\n\nSince Firebird 4.0, the database supports timestamps with timezones. The timezone information is stored separately to the timestamp so it can be properly retrieved later on. See the Firebird documentation for more information about timestamp handling.\n\nThe Qt Borland InterBase plugin honors the following connection options:\n\nHow to Build the QIBASE Plugin\n\nYou need the InterBase/Firebird development headers and libraries to build this plugin.\n\nDue to license incompatibilities with the GPL, users of the Qt Open Source Edition are not allowed to link this plugin to the commercial editions of InterBase. Please use Firebird or the free edition of InterBase.\n\nInterBase/Firebird return OUT values as result set, so when calling stored procedure, only IN values need to be bound via QSqlQuery::bindValue(). The RETURN/OUT values can be retrieved via QSqlQuery::value(). Example:\n\nHow to Build the QIBASE Plugin on Unix and macOS\n\nThe following assumes InterBase or Firebird is installed in :\n\nIf you are using InterBase:\n\nOptionally, use the CMake variables and to specify the include path and library directly.\n\nHow to Build the QIBASE Plugin on Windows\n\nThe following assumes InterBase or Firebird is installed in :\n\nIf you are using InterBase:\n\nOptionally, use the CMake variables and to specify the include path and library directly.\n\nNote that must be in the .\n\nYou should always use client libraries that have been compiled with the same compiler as you are using for your project. If you cannot get a source distribution to compile the client libraries yourself, you must make sure that the pre-compiled library is compatible with your compiler, otherwise you will get a lot of \"undefined symbols\" errors.\n\nIf the compilation of a plugin succeeds but it cannot be loaded afterwards, check out the following steps to find out the culprit:\n• Ensure that the plugin is in the correct directory. You can use QApplication::libraryPaths() to determine where Qt looks for plugins.\n• Ensure that the client libraries of the DBMS are available on the system. On Unix, run the command and pass the name of the plugin as parameter, for example . You will get a warning if any of the client libraries could not be found. On Windows, you can use Visual Studio's dependency walker or Dependencies GUI to find out the dependent libraries. With Qt Creator, you can update the environment variable in the Run section of the Project panel to include the path to the folder containing the client libraries.\n• When using MSVC, also make sure the plugin is built with the correct build type. Due to different MSVC runtimes for debug and release, a Qt debug build can't load a Qt release plugin and vice versa.\n• Run the compiled Qt executable with the environment variable QT_DEBUG_PLUGINS set to get very verbose debug output when loading plugins.\n• To retrieve possible debug messages from the SQL subsystem, enable the output by setting the environment variable to . Don't forget to enable the console when working on windows. See Logging Rules for a more detailed explanation on how to set logging rules.\n\nMake sure you have followed the guide to Deploying Plugins.\n\nHow to Write Your Own Database Driver\n\nQSqlDatabase is responsible for loading and managing database driver plugins. When a database is added (see QSqlDatabase::addDatabase()), the appropriate driver plugin is loaded (using QSqlDriverPlugin). QSqlDatabase relies on the driver plugin to provide interfaces for QSqlDriver and QSqlResult.\n\nQSqlDriver is an abstract base class which defines the functionality of a SQL database driver. This includes functions such as QSqlDriver::open() and QSqlDriver::close(). QSqlDriver is responsible for connecting to a database, establish the proper environment, etc. In addition, QSqlDriver can create QSqlQuery objects appropriate for the particular database API. QSqlDatabase forwards many of its function calls directly to QSqlDriver which provides the concrete implementation.\n\nQSqlResult is an abstract base class which defines the functionality of a SQL database query. This includes statements such as , , and . QSqlResult contains functions such as QSqlResult::next() and QSqlResult::value(). QSqlResult is responsible for sending queries to the database, returning result data, etc. QSqlQuery forwards many of its function calls directly to QSqlResult which provides the concrete implementation.\n\nQSqlDriver and QSqlResult are closely connected. When implementing a Qt SQL driver, both of these classes must to be subclassed and the abstract virtual methods in each class must be implemented.\n\nTo implement a Qt SQL driver as a plugin (so that it is recognized and loaded by the Qt library at runtime), the driver must use the Q_PLUGIN_METADATA() macro. Read How to Create Qt Plugins for more information on this. You can also check out how this is done in the SQL plugins that are provided with Qt in .\n\nThe following code can be used as a skeleton for a SQL driver:"
    },
    {
        "link": "https://linux.die.net/man/3/qsqldatabase",
        "document": ""
    }
]