[
    {
        "link": "https://en.cppreference.com/w/cpp/types/enable_if",
        "document": "If is true, has a public member typedef , equal to ; otherwise, there is no member typedef.\n\nThis metafunction is a convenient way to leverage SFINAE prior to C++20's concepts, in particular for conditionally removing functions from the candidate set based on type traits, allowing separate function overloads or specializations based on those different type traits.\n\ncan be used in many forms, including:\n• as an additional function argument (not applicable to most operator overloads),\n• as a return type (not applicable to constructors and destructors),\n\nIf the program adds specializations for , the behavior is undefined.\n\nA common mistake is to declare two function templates that differ only in their default template arguments. This does not work because the declarations are treated as redeclarations of the same function template (default template arguments are not accounted for in function template equivalence).\n\nCare should be taken when using in the type of a template non-type parameter of a namespace-scope function template. Some ABI specifications like the Itanium ABI do not include the instantiation-dependent portions of non-type template parameters in the mangling, meaning that specializations of two distinct function templates might end up with the same mangled name and be erroneously linked together. For example:\n\nThe function templates #1 and #3 have different signatures and are distinct templates. Nonetheless, #2 and #4, despite being instantiations of different function templates, have the same mangled name in the Itanium C++ ABI ( ), meaning that the linker will erroneously consider them to be the same entity."
    },
    {
        "link": "https://stackoverflow.com/questions/54749968/template-struct-tag-partial-specialisation-with-enable-if-or-something-similar",
        "document": "To make sure I understand the question correctly, are you looking for something equivalent to the code you've posted, but using only C++14 (without concepts)?\n\nI think the first limitation you mentioned (\"struct A cannot be modified to accept two template parameters\") is the biggest problem. I'm not aware of any way to specialize an existing, single-argument template for a whole \"class\" of types at once (e.g. floating-point types) without using concepts.\n\nSo I think the strict answer to your question is, \"No, it's not possible.\"\n\nIf you could modify the first declaration of A, then it would be a lot easier. And personally, I feel that sometimes the best answer to questions that start with \"I can't modify this external library\" is, \"Go and find out how to modify it, then come back and ask your question again.\"\n\nI provide one idea for an alternative solution below, but there's too much information missing from your question to say whether it will work for you.\n\nI assume that this external library pulls in some header that you provide in order to see your specialization, and that you'll be recompiling the library whenever you change that header. (If that's not the case, please edit your question to explain the situation a bit better.)\n\nIn that same header where you want to put your specialization, you might consider using some old-school preprocessor trickery as a workaround. It's ugly, and you have to be careful about the order of your statements, but it might get the job done for you:"
    },
    {
        "link": "https://stackoverflow.com/questions/6627651/enable-if-method-specialization",
        "document": "How can I use enable_if to make the following specialization happen for any floating point type (is_floating_point)?\n\nEDIT: Here's an answer I came up which is different from the ones posted below...\n\nLike the below posters say, using enable_if may not be ideal for this problem (it's very difficult to read)"
    },
    {
        "link": "https://medium.com/@sidbhasin82/c-templates-what-is-std-enable-if-and-how-to-use-it-fd76d3abbabe",
        "document": "Templates in C++ are amazing. They enable us to write compile-time polymorphic code, which not only helps us catch bugs while we are building the code, but also makes the code run faster than using polymorphism with virtual functions. But this “Swiss army knife”, provides creative engineers ways to express code that for us mere mortals is almost gibberish. And one such example is std::enable_if. If you have dealt with any sort of C++ production code, you must have come across it.\n\nNow there are two types of C++ engineers in the industry right now, 1) who see the code using std::enable_if and are like I better stay away from it, or 2) who understand the concept and try to use it as much as possible. Now the problem is generally these two types of people are working in a single team and the people in group 1 are not able to understand what is going on. I myself was in the former group and thus I can understand the pain. Therefore, after having dealt with this sort of code in multiple repos, I thought I would write a post about it so that future C++ engineers, or someone who was like me (working with C++ code but not aware of this) can understand this concept and debug or even code it like a pro.\n\nBefore going through the article I expect you are aware of basic C++ programming constructs like struct, class, loops, conditionals, etc. Also I expect you are aware of basics of templates(class and function) and can write a simple max function for different built-in types using templates. It would be great if you have heard of template specialisation but it’s not a must. Also some familiarity with STL containers such as vector, set and maps will be awesome.\n\nSuppose you are working on a logging library and you need provide a method which takes in any kind of object and returns it in the form of string. For example:\n• If you are given an int 102 you return it as string “102”.\n• If you are given a Person object which is a user-defined type, you need to return a string representation of the object, as defined by the author of the class\n• If you are given a vector of int say [1, 2, 3, 4], you return a list where each element is converted to its string representation [“1”, “2”, “3”, “4”].\n\nTo make it more clear, below is how our ToString method will be used:\n\nNow T here is the template parameter, and it can be anything. So how should we go about implementing the ToString method?\n\nUse function overloading, which means define ToString for every possible type you need to serve. Here you might say, “well there can be so many types, do we need to define it for all?” and your apprehension is right. You would need to do something like:\n\nAnd the list goes on and on. And one thing to note is that built-in types can be casted implicitly in C++, so you need to take care of that as well. It doesn’t require much analysis to know this is not exactly a good solution for our problem here. But the reason why I mention this is because 80–85% times these solutions work, since most of the time, requirements don’t want you to come up with something complex, but we over-engineer our solution which has no upside, rather, it causes us difficulty to understand our own code when we look back at it sometime later. So check if this simple solution works before moving on to the complex stuff.\n\nNow with templates we know built-in types need to be handled differently from user-defined types. For built-in types C++ provides a standard library function called (no surprises) std::to_string method. So our ToString method just forwards the call to the standard library method:\n\nFor user-defined types we don’t have any such method since the author of these types need to define one. Let’s say objects of class have a member function, so we can specialise our ToString template function as follows:\n\nWe can do similar specialisations for other user-defined types. If you are not aware of template specialisations this is pretty much what it is, defined special cases of templates based on specific types.\n\nNow moving on to vectors, we can do a similar specialisation but the interesting thing is our implementation of ToString for vectors is based on the ToString implementations for other types we have already defined.\n\nSo now for vectors also we have an implementation. This however is partial specialisation(C++ is awesome, isn’t it!!), which means we are only partially specifying the type(T inside the vector). But the main problem is, we need to do something similar for sets, maps, unordered_sets, multimaps, etc. Also for user-defined type we would need to define functions along the same lines again and again. That is just too much code duplication, which is not nice. Thus we bring in the big guns!!\n\nNow, let’s change gears for a bit. So you know you can have non-type template parameters such as you do in std::array , now “int” here is a type parameter and “3” is a non-type parameter which has to be evaluated at compile time. You can read here for more reference. The thing we should take from this is that compile time constants can be used as template parameters.\n\nLet’s define a templated struct which takes in a boolean non-type parameter and T a type parameter:\n\nSo from our previous discussions, it shouldn’t be hard to understand that the redefinition of enable_if is a specialisation(partial one) which defines a typedef of the type that was passed. Now you might be thinking well how does this helps us? And for a novice programmer, yes it should not make sense.\n\nBut C++ has something called as SFINAE, which is short for “Substitution Failure Is Not An Error”. In short, if you write some template code that cannot be substituted correctly, compiler will flag it but not throw an error and not stop the compilation. It’s like the compiler is saying, “Hey we are friends, you write bad code that you don’t call, yeah I don’t care!!”\n\nNow let’s complete our ToString method, let’s say we have 3 versions for ToString method now, 1) for built-in types, 2) for user-defined types, and 3) for collections. Now our function call needs to bind with any one of these. For it to bind with only 1, we need to make the other two victims of SFINAE.\n\nOne thing to know here is that C++ allows unnamed function parameters and there is a good reason for it which you can read here. So don’t get scared if you see something like , instead we exploit this to our benefit. Now let’s check how to handle containers first. Now using the above logic of how we defined enable_if, we could define something like as follows:\n\nSo by default if we pass any type that is not a set or vector the is false, but if we pass a set or vector, the is true.\n\nNow for our ToString method for collections, we only need to add another parameter that enables the container function when it is valid otherwise keeps it disabled. And we do that this way:\n\nNow I hope you can figure out, what is going on, but let’s recap. If the type T is either a vector or set, the is true, which makes a valid entity in the program since defines a typedef for it and hence the function exists. If is false, the is not defined and we give away this function to SFINAE. It’s as if the function doesn’t exist. (Has your mind exploded?) Now why this technique is so powerful is because it provides great encapsulation while not compromising on reusability of code. In case we need to support a new container we just define a new specialisation for , don’t even touch the ToString method and we are good. It’s a great example of Open-Closed Principle.\n\nFor the user defined types with to string member function we can have something like this:\n\nYou see we don’t even need to have any relation between user defined types (no inheritance or composition), and still can re-use the code. It’s such a fantastic technique for code re-use that once you learn it, you just feel like using it in all the places.\n\nFor built-in types, it’s just simply checking that is defined or not, and you have a method for built-in types as well, and yeah for any other type that is false for both, but you know how to handle this now, don’t you!!.\n\nBelieve it or not, that’s the core logic behind implementation of std::enable_if and now you know it too!!\n\nI tried to keep it as short as possible, and glossed over some details for brevity, which you will realise when you use this technique in your own code, but I think this article could act as a starting point for your journey into this complex, but amazing concept. For more in depth knowledge, I would suggest watching this CppCon video. Also starting C++20, the standard introduces concepts which alleviates the complexity of std::enable_if, but since it was released not long ago and we already have more than 3 decades of C++ code in production, I know this knowledge wouldn’t be wasted :).\n\nIn case you want to experiment a bit yourself you can check out the code here."
    },
    {
        "link": "https://akrzemi1.wordpress.com/2017/12/02/your-own-type-predicate",
        "document": "In this post we will see how to define a type trait or a type predicate or a meta-function that would allow us to check at compile time whether a type exposes an interface that we need. That is, we want to check if a given type has:\n• static member function that takes one argument of type ,\n• member function that returns type and that is declared not to throw exceptions,\n\nIn other words, the following expressions and constructs need to be valid for any variable of type :\n\nBy “checking” I mean being able to test it at compile time, for instance like this:\n\nWe will do it in C++11. This is also going to be an introduction to “metafunctions” in C++.\n\nI will not try to answer in detail the important question: why do we need such predicate. The short answer is: if we are writing a template library, we can use it to generate better (and shorter) error messages when a user is using our library incorrectly. For more on this, have a look at the advice from Boost Library Incubator, or this excellent talk by Vinnie Falco (which was in fact an inspiration for this post).\n\nTerm “metafunction” is perhaps too impressive for the simple thing it describes. “Function” here means a function in the mathematical sense: that something is mapped onto something else; “meta” means that we do not mean invoking functions in the C language sense (initializing objects representing arguments to functions and performing a function call). Instead, a metafunction is a language construct, where you put one or more types and perhaps some compile-time constans, and the construct “produces” a different type (which can later be converted to a constant value).\n\nSo, going back to the initial code example:\n\nis a metafunction. It is a function in the mathematical sense. It takes a (one element) set of arguments — which in our case is type — and maps it on a different type: . Next, we “convert” this type into a Boolean value, by accessing its static data member . Its type is .\n\nAccessing static data member is a traditional way in C++ of obtaining integral or Boolean values from types returned by metafunctions and we will follow it. In total, we can say that we have mapped from a type onto a Boolean value.\n\nThe most trivial metafunction we could define is this:\n\nAnd we can “invoke” it like this:\n\nThis function is really trivial. It takes zero arguments and “returns” a type that always converts to Boolean value . We can say that is value but encoded as a type rather than value.\n\nIt is not useful on its own, but is very useful as a building block for more practical meta-functions.\n\nUsing a corresponding, second building block:\n\nwe can try to build some more meaningful functions. First task: a metafunction that detects if given types and are identical.\n\nSince our metafunction needs to take parameters, we will have to use a class template. Most of the time our metafunction will return , so let’s start with this case:\n\nNow, is a class template, so in order to use it, you have to provide two types. Also, it derives from , so accessing data member works, and the result is always :\n\nBut as it is now, it will give wrong result even for two s. So let’s fix it. We will specialize the template for the case where and are identical.\n\nThis is called a partial template specialization. It has only one parameter in line 1 (the previous template had two), but it does not mean that we can use with one parameter. It only means that we have defined a pattern in the sense of pattern matching. Class template is always instantiated with two parameters, but once the two parameters are provided, the primary template and the specialization are inspected in order to determine which is a better match. The former is always a good match for any two types; the latter is a better match for two identical types. The definitions of two templates are significantly different: the former derives from , the latter from . This achieves the desired result:\n\nNow, the last exercise before we solve the real problem: we want to check if the size of a given type (as measured with operator ) is 1. It is easy to do with expressions directly:\n\nBut we want it wrapped into a C++-style metafunction. We will also specialize class templates but in a more clever way. First, the primary template:\n\nThis time we have a second parameter . It is not a type, it is a value, and more importantly it has a default value, so users will not know that there is a second parameter. They will just call it with a single type:\n\nValue keeps internally the answer to the question. But the template without specialization always represents value “false” (it is derived from ). While value is invisible outside, we can use it internally in providing the partial specialization:\n\nThis specialization is a better match for types where the value of condition (evaluated in the primary template) is ; and this specialization represents value “true”. Let’s test it:\n\nBut we can implement metafunction in a different way. It is a bit more complicated, but it illustrates some mechanics of template instantiations. We will first define a meta-metafunction, . This also requires a primary template and a specialization:\n\nAgain, we have a class template which is parametrized by a Boolean constant. If the value is true, the class has a member typedef ; otherwise no typedef is present. This gives us a very strange mapping. In the previous case of metafunction , and pair was mapped onto either type or type . In the current case, in construct , Boolean value is either mapped onto a valid type, or onto a type-system error, depending on whether is true or false. The actual type is not important, it is this error versus non-error that is the crux here.\n\nThe usage of keyword is characteristic of C++ metaprogramming. Without it compiler would have to assume that name refers to a static data member. Since C++11, we can instruct the compiler in a different way, which additionally makes the notation more concise, by using an alias template:\n\nNow, we again had to use the , but only once. Henceforth, anyone can just refer to the nested type as .\n\nAnd we can similarly say that construct maps onto a valid type when is and onto a type-system error when is . This is the most extraordinary application of a notion of mapping I have seen in programming; and as we shall see in a moment, it is still useful in practice.\n\nWe can use to implement metafunction , again the master template and a specialization:\n\nThe primary template has two parameters. The second one has a default “value”, so the users will not know it is there. I also do not need to know it, so I do not even give it a name. The only reason I need 2nd parameter is for the specialization with one parameter to be more specialized than the primary template, and in the specialization to have a placeholder where to put a type-or-error generated from .\n\nThe specialization takes any and is always more specialized, and it always gets chosen… as long as it is correct. But we know that when the condition we check, , is false, will be a type-system error. But this is one of these special places where creating a type-system error while instantiating a template is not a compiler error. Or, to put it in other words, template argument substitution failure is not an error (which is abbreviated to SFINAE).\n\nThis means that when I instantiate template with type , the specialization is considered, but because substituting for fails ( would be a type-system error), compiler simply concludes that this specialization will not work, and just goes with the primary template (which, unlike the specialization, derives from ).\n\nNote that I used type as the default for the second template parameter. I also used for inside . In either case I never rely on the fact that it is actually : I just need any type. Because type is special in C++, I just re-used it to indicate other special use cases. Any other type would do as well.\n\nThe entities we have defined, , , and are useful tools for meta-programming tricks and type traits, and they are in fact already defined in the C++11 Standard Library. They are a bit more complicated and more developed, but the idea stays the same. Additionally, in C++14 we have alias template .\n\nThere is one more metaprograming tool that we need to define before we solve our problem.\n\nAnd in fact in newer compilers, which fix C++14 issue 1558, it can be implemented even more cleanly:\n\nThis meta-metafunction is perhaps even more bizarre than . Rather than mapping values on values, or types on types, it maps validity on validity. We have a construct that is parametrized by an arbitrary number of parameters — other constructs that potentially represent valid types — and this construct in turn also potentially represents a valid type, provided that all parameters represent valid types.\n\nFor instance, consider the following construct:\n\nEach of the two arguments is a construct representing a valid type, thus the entire construct is also a valid construct representing a type. The type is but again, this is irrelevant: it is only relevant that it is a valid type.\n\nNext, in the following case:\n\nThis construct is valid for { } but is invalid for { }.\n\nWe can say that is a Boolean AND function, where value True is represented by construct representing a valid type, and value False is represented by a construct that does not represent a valid type.\n\nWhat it buys us, is that we have arbitrary number of slots (template arguments) where we can put constructs potentially referring to types — some of them may be in fact invalid types — and we change it to a single construct that we have to test for correctness. The only thing we now need to make use of this facility is a SFINAE context, where a potential type-system error is “converted” into a decision, which overload or template specialization to select.\n\nhas turned out to be so useful that we are goting to get it with the Standard Library in C++17.\n\nNow, back to our task. We want our meta-predicate to detect the following (for any type , and any value of type :\n\nWe will apply the same technique as with : the primary template will always “return” , the specialization will “return” but will be disabled unless all the requirements are met.\n\nFor the specialization we will start with only checking for the nested typedef :\n\nFor now we are only using one slot of . If does not represent a valid type, the specialization is skipped and we are going with the primary template.\n\nNow, second thing we should check is if we can call a static member function with argument of type . There is a slight problem here: works well with valid/invalid types, but now we need to check a valid/invalid expression. Luckily, there is an easy way to convert a valid/invalid expression into a valid/invalid type: . Let’s try it:\n\nNow we are using two slots of . inside means that we are testing the validity of an expression.\n\nNow, we need to check if the call to a nullary member function is valid for some variable of type . And we have another difficulty here: it is not possible to just insert a name of the variable in the middle of template parameter list.\n\nWe could try to do it like this:\n\nAnd it would “work” to some extent, but with this we also introduce a yet another inadvertent constraint that is default-constructible. We do not want this. We want to accept types without a default constructor! But we can still reuse the trick with a temporary. We will need to create a yet another auxiliary general-purpose helper function:\n\nThe condition inside can never be true for any so the program will fail when you try to instantiate its body. But because the condition is dependent on , the compiler cannot test it until the body is actually instantiated. Thus the definition alone is fine. And also calling this function inside the “unevaluated context” is fine:\n\nbecause in such contexts function template bodies are not instantiated. We only need this function for its declaration; and its declaration has this useful property: the return type of this function is exactly the type we pass as the template argument. Thus, when we type it actually means, “for some temporary object of type . If you need a temporary reference rather than an object, no problem, just type: . (This tool has been found to be so useful that it is also part of C++11 Standard Library.)\n\nNow the solution is simple:\n\nNext, how to check that the last expression is declared not to throw exception? We have operator for just this purpose:\n\nHowever, the operator returns or , but what the interface of requires is valid or invalid type. we will have to map from to a valid type and from false to a type-system error. We already know a tool for exactly this purpose: :\n\nAs we can see, inside means we are testing a Boolean condition. Finally, we need to check that the retun type of is .\n\nOne way to do it is to check the type of an expression with than test if it is identical with the desired type using a type trait we already know: (or use one from the Standard Library: ). Then, because the latter returns / use to adapt the result to the interface of . The last check will be longer, but no more difficult than the others:\n\nAnd because what we typically do with values returned from functions is to use them to copy-initialize a new object:\n\nWe are only interested if is convertible to : they do not necessarily have to be the same type. We can relax our constraint from to . In fact, this is what Concepts Lite typically do.\n\nIf we used Concepts Lite (which are shipped with GCC 6), our meta-function could be rewritten as:\n\nThe first two constraints look quite obvious, the third requires some explanation. Expression in braces must be well-formed. The following means that the entire expression must be detected as not throwing exceptions: either we are only using built-in operations, or functions declared . The type following the arrow is a requirement that the type of the tested expression must be convertible to the type. There is no direct way to say that a given expression must have exactly a given type. So, people when they want to specify an exact return type use a hack:\n\nThe semantics of the hacky constraint is, expression returns some type and of this type we require that constraint is satisfied.\n\nThe version of our predicate using Concepts Lite is much shorter and cleaner. One reason for this is that we can declare variables and and we can use them to build valid expressions. No need for using . In fact, there is a way to write a concept-like constraint in C++11, where we can also operate on variable names and do away with .\n\nFirst, we will define an auxiliary class which contains our constraint encoded in a member function template. It is a function, so it can have and it make use of function parameters:\n\nI use name instead of because I am thinking in terms of future C++, where is to be a reserved keyword. Now, we will make use of the fact that when function return type is declared with an arrow, we can access the names (and the types) of function’s input parameters. Thus, our constraints from above can be rewritten as:\n\nNote that in line 7 I am referring to variable .\n\nNow, this function has a declaration but no body. All the relevant parts are embedded in function declaration. It is correct to have it, as long it is not instantiated. For a given type we would like to instantiate its declaration but not its body. You can do it by taking the address of this function template instantiation in an unevaluated context (such as ):\n\nNow, implementing our type trait is not much different than the initial attempts:\n\nThis gives one additional benefit over previous solutions: the definition of a constraint is separated from the machinery of class template specializations. We could define one reusable template like below, which abstracts away the definition of class templates and specializations.\n\nWe will be using it like this:\n\nThat is, you give us the definition of concept constraints ( ) and a set of concept parameters (in our case only ), and you get a predicate in return. The implementation follows; it consists of a primary class template, a specialization, and an alias:\n\nThe master template takes the concept constraints class ( ) and a list of types to test the concept against (remember that some concepts define a constraint on a number of types). The first argument is artificial. We only need it to fix it in the specialization. Because this time we are dealing with a parameter pack, we cannot put additional argument with default value at the end, therefore we put it in the front with no default.\n\nThe specialization, in the slot for the artificial parameter, instantiates the function declaration as before. Note the peculiar use of keyword in line 5. The history is similar with that for . Without the additional keyword compiler would have to assume that refers to a static data member of and the following character is a less-than operator.\n\nFinally, because we do not want the users to be aware of the additional first parameter we provide type alias which hides the parameter.\n\nAnd we could keep on improving the solution, but there is no reason for doing it ourselves, as we already have a good library exactly for this purpose.\n\nTick is a c++11 library for defining and making use of concept-like meta-predicates on types. With Tick, our predicate could be defined as follows:\n\nWe can see that Tick applies a similar trick with member function template and hides other machinery behind a clever macro .\n\nUnfortunately, in Tick’s we are not allowed to add random function parameters. so rather than testing “for any of type ” I am testing “for value ”. But this can be worked around by by providing additional parameter with default value.\n\nSimilarly, having to type time and again is a bit tedious, and it makes the last constraint particularly long. We can introduce an alias in the template parameter list.\n\nWith these hacks applied, the definition of our type trait reads:\n\nLast, because Tick based its ideas on range-v3 library, I was curious how my type trait could be implemented in the latter library. Range-v3 is actually for working with STL containers, generators and algorithms through ranges (rather than iterators), but it uses its own implementation of concepts internally, so why not try it.\n\nThe scheme for defining constraints is similar: we specify them in return type of a member function template:\n\nHere, however, rather than providing a list of valid types, we provide a list of valid expressions. And while before we were converting expression constraints to types, here we will be sometimes converting type constraints to expressions. The full implementation of my type predicate is not as short as with previous techniques, and before I provide it, I need to define a yet another meta-programming tool:\n\nThis maps a Boolean type encoded as either or value of type , onto a Boolean value encoded as either or . Concept mechanism from ranges-v3 likes this C++ meta-programming way of encoding Boolean values. In C++17 we get this mapping function with the Standard Library: it is called .\n\nHere is the implementation of my trait:\n\nSome explanation. Line 9 says that expression is valid and that its return type is exactly .\n\nLine 10 says that expression is valid. But I couldn’t just type , because its return type is , and it cannot be passed as argument to function . So, I apply the trick with comma operator and type and the return value of this expression is . Unless for some function returns a strange type with overloaded comma operator, and then we have no clue what the return type is (and if it is not again). So, in order to avoid this problem, we cast the left-hand side operand to .\n\nIn line 11, a helper function from the library checks if a given expression is valid and evaluates to “true”, but by “true” it understands the object of type (or at least something with static constant member data of type ). So, I need to map the result from operator using my meta-function .\n\nFinally, in line 16 I turn a class with constraints into a type predicate. This is a bit different from how rane-v3 defines concepts; but my goal is to define a C++-like type predicate, which can be used like this:\n\nIt is my impression that the choice to list valid expressions (as in range-v3) rather than to list valid types (as in Tick) makes the definitions longer and more clumsy on average.\n\nIn fact, ranes-v3 library is installed in Wandbox, so we can test our example online.\n\nAnd that’s it for today.\n\nI am grateful to Paul Fultz II for helping me understand the details of Tick library.\n\nFor writing the range-v3 example, I used this post from Eric Niebler’s great blog."
    },
    {
        "link": "https://stackoverflow.com/questions/63524675/constraining-a-specialised-class-template-parameter-to-integer-and-floating-poin",
        "document": "I would like to create class specialisations where one specialisation is for all integer types, another for all floating point types, another for bool, and all others for my own types, and to fail to compile with anything else.\n\nI would like integer to be for {signed or unsigned} * {short, int, long or long long}. It is not desirable to include char but I can live with it. Floating point is for float, double, and long double.\n\nI've tried playing around with variations of:-\n\nbut the compiler is telling me I keep getting it wrong. What is the correct syntax please?"
    },
    {
        "link": "https://stackoverflow.com/questions/16976720/how-do-i-restrict-a-template-class-to-certain-built-in-types",
        "document": "In your first example, should take a second parameter which would be a string literal, otherwise it's deemed to fail (edit: dropping the the second parameter is legal since C++17). And this second argument cannot be defaulted.\n\nYour second example is incorrect for several reasons:\n• is meant to be used on an expression, not on a type.\n• You simply cannot compare types with , the correct way to do this is what you try in your first attempt with .\n\nSo, the right way to do what you are trying to achieve is:\n\nMoreover, I bet you are trying to constrict your template to floating points values. In order to do this, you can use the trait :\n\nAnd as a bonus, take this online example."
    },
    {
        "link": "https://geeksforgeeks.org/std-is_floating_point-template-in-c",
        "document": "The std::is_floating_point template of C++ STL is used to check whether the given type is a floating point value or not. It returns a boolean value showing the same.\n\nParameter: This template accepts a single parameter T (Trait class) to check whether T is a floating point type.\n\nReturn Value: This template returns a boolean value as shown below:\n• True: if the type is a float.\n• False: if the type is a not float value.\n\nBelow programs illustrate the std::is_floating_point template in C++ STL:"
    },
    {
        "link": "https://en.cppreference.com/w/cpp/types/is_floating_point",
        "document": "Checks whether is a floating-point type. Provides the member constant value which is equal to true, if is the type float, double, long double, or any extended floating-point types (std::float16_t, std::float32_t, std::float64_t, std::float128_t, or std::bfloat16_t)(since C++23), including any cv-qualified variants. Otherwise, value is equal to false.\n\nIf the program adds specializations for or , the behavior is undefined."
    },
    {
        "link": "https://app.studyraid.com/en/read/12332/398076/static-assertions-for-constraint-checking",
        "document": "Static assertions provide compile-time constraint validation for template parameters, enforcing requirements before code execution. Unlike runtime assertions ( ), evaluates conditions during compilation, making it essential for template metaprogramming where type requirements must be validated early.\n\nThis code demonstrates a size constraint check using . The assertion:\n• Triggers during compilation when instantiated with oversized types\n\nEffective constraint checking requires combining with type traits. This approach enables precise control over template instantiation conditions.\n• Checks for both integral and floating-point types\n\nComplex constraints require combining multiple checks using logical operators. The standard library's header provides essential tools for creating sophisticated requirements.\n\nEffective error messages are crucial for debugging template constraints. Advanced techniques enhance message clarity and diagnostic value.\n\nFollowing established patterns ensures maintainable and effective static assertions in template code.\n• Use standard type traits when possible\n\nThrough proper application of static assertions, developers can create robust template code that fails fast with clear diagnostic messages, reducing debugging time and improving code safety. The techniques demonstrated provide a foundation for building type-safe generic components while maintaining flexibility in template-based designs."
    }
]