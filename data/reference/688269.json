[
    {
        "link": "https://medium.com/towards-data-science/pymysql-connecting-python-and-sql-for-data-science-91e7582d21d7",
        "document": "SQL and Python are indispensable tools for data practitioners to work effectively with data.\n\nA common use case would be the initial retrieval of data from relational databases using SQL queries, followed by subsequent manipulation and analysis of the data in Python with libraries such as pandas.\n\nBut did you know that these two seemingly isolated tasks can be combined into a single Python script to easily deliver the same outcome?\n\nIn this article, we discover the concepts and implementation of PyMySQL for connecting to and interacting with MySQL databases from Python.\n\n(1) What is PyMySQL, and Why Use It?"
    },
    {
        "link": "https://medium.com/data-science/pymysql-connecting-python-and-sql-for-data-science-91e7582d21d7",
        "document": "SQL and Python are indispensable tools for data practitioners to work effectively with data.\n\nA common use case would be the initial retrieval of data from relational databases using SQL queries, followed by subsequent manipulation and analysis of the data in Python with libraries such as pandas.\n\nBut did you know that these two seemingly isolated tasks can be combined into a single Python script to easily deliver the same outcome?\n\nIn this article, we discover the concepts and implementation of PyMySQL for connecting to and interacting with MySQL databases from Python.\n\n(1) What is PyMySQL, and Why Use It?"
    },
    {
        "link": "https://pypi.org/project/PyMySQL",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    },
    {
        "link": "https://github.com/PyMySQL/PyMySQL/blob/main/README.md",
        "document": "This package contains a pure-Python MySQL and MariaDB client library, based on PEP 249.\n• Python -- one of the following:\n• MySQL Server -- one of the following:\n\nYou can install it with pip:\n\nTo use \"sha256_password\" or \"caching_sha2_password\" for authenticate, you need to install additional dependency:\n\nTo use MariaDB's \"ed25519\" authentication method, you need to install additional dependency:\n\nFor support, please refer to the StackOverflow.\n\nThe following examples make use of a simple table\n\n. . ( , , , , . . ) : . () : . ( , ( , )) # connection is not autocommit by default. So you must commit to save . () . () : . ( , ( ,)) . () ( )\n\nThis example will print:\n• Getting Help With MariaDB https://mariadb.com/kb/en/getting-help-with-mariadb/\n\nPyMySQL is released under the MIT License. See LICENSE for more information."
    },
    {
        "link": "https://cs.wellesley.edu/~cs304flask/readings/pymysql",
        "document": "This discussion of the PyMySQL Python module assumes some background knowledge of Python that you may not have gotten in CS 111. So, I strongly urge you to read my Python 102 description of some intermediate Python concepts and techniques.\n\nIf you're feeling quite shaky on your knowledge of Python (maybe it's been a long time since you took CS 111 or you skipped CS 111 because of a high-school course in Python), I strongly recommend you start with my Python 101 crash course in Python.\n\nWe'll have a brief digression about modules and APIs and then get into PyMySQL.\n\nAll the code examples come from files in the folder.\n\nThis is a very simple script, but it's useful in its own right, and it illustrates some important ideas. The following code is in a file called\n\nHere's how we could use it from a Unix shell:\n\nVery cool, particularly if you're not familiar with the Unix command.\n\nIf we import that file, it provides the function, but doesn't print anything. That is, the part after the statement doesn't run.\n\nAn API is an Application Programming Interface, which means how one part of a multi-part program talks to another part.\n\nThe module is a ludicrously small example of that. When we the servertime module into another Python file, we can then use a function called\n\nIn general, a Python module might create a large set of functions, objects, classes and methods that the importing code can use to get something useful done.\n\nThe script imports the module, which is part of the standard set of Python packages, so you can assume it's installed on your system. However, if you need other packages installed, you'll either need to be an administrator or use a virtual environment. Here is more on virtual environments.\n\nWe will use virtual environments in CS 304 and install and (as well as some other packages that we will get to later).\n\nNow that we know a little Python and we can import the PyMySQL module, we will turn to that module, which lets us talk to a database back end.\n\nPyMySQL is a Python module that provides functions, objects and methods (an API) to interact with a MySQL DBMS. You should certainly spend a little time with one of the following:\n• PyMySQL tutorial at TutorialsPoint. This is readable and almost complete. Note that it sometimes refers to PyMySQL and sometimes to MySQLdb, which is a version of the module that works with Python 2. Treat the two terms as interchangeable.\n• PyMySQL Official Documentation This is comprehensive, but a reference, not a tutorial. However, there is a User Guide with some nice examples.\n\nTo understand how we will will work with databases from Python, we need to learn the following:\n• How to connect to the DBMS, either with username/password or with a credentials file\n• How to use a particular database, either our own personal database or WMDB, and eventually the project database. This is just like the statement we employed in our batch files\n• How to do prepared queries, which is a parameterized query, allowing parameters from untrusted sources.\n\nWe may also learn some topics that are useful, but not essential for CS 304, such as command line arguments and others\n\nWhen anyone connects to MySQL, they have to have a username and password. That has been invisible to you in CS 304 because (1) I created your MySQL accounts for you, and (2) the MySQL client (the command) doesn't ask you for a username and password. Instead, it reads them from a credentials file called . Recall that means that the file is in your home directory and that the leading dot in the filename means that it doesn't show up in a normal command. Instead, you have to say\n\nEach of you has your own unique version of that file, with your own username and (randomly generated) password in it.\n\nWhen we connect to the DBMS from a Python script, we also have to supply a username and password. We'll learn how to do that using the PyMySQL package, and an alternative way using a home-grown package called .\n\nThe PyMySQL function to connect to the DBMS is called and it can either take a username/password or the name of a credentials file. The function returns an object called a that has methods that we will use. For now, we'll just get the connection object, and we will typically put it in a variable called .\n\nConnecting to the DBSM using the PyMySQL Module\n\nThere are a few reasons not to like the code above:\n• If the code will be public (which it will in CS 304, since we will use GitHub), it's a security risk to have our username and password posted publicly\n• We have to copy/paste the username and password to everyplace we connect, and we will connect from each of the many routes in our Flask app.\n• It's tedious to modify the username/password since it gets copied to many places.\n\nAn improvement is to use the credentials file:\n\nThis is much better! The only downside of this is that, since our Flask app will run for an extended duration and will connect many times during its run, it'll re-read the file many times, even though the file will not change. So, an improvement is to factor the reading of the credential file (and caching the values) from connecting to the database. Furthermore, we can select the database and store that in the cached credentials and have a function that (by default) uses the cached information. Here's how it would work:\n\nThat looks like a step backwards, since it's two lines instead of one, but the function to read the CNF file and cache the results and use the database (the function) only needs to happen once, so we can do that when the app starts and never have to do it again. Then, we can connect with just one simple line:\n\nThe examples above all created a connection object, which I consistently stored in a variable called . (You can, of course, store it in any variable name you want, but I'll use .)\n\nWhat is this thing? Consider placing a phone call to someone, say your grandmother. Once grandma picks up, your phone is connected to her. You can ask her questions and she can respond. You can hand the phone to your mother, father, brother or sister and they can also talk to grandma. The telephone handset is an object that allow anyone to talk grandma and you can pass that around. It represents the connection. (Sometimes, there's a lot of static. You have a bad connection. You can hang up and call again, to get a new connection.)\n\nThe connection object represents our connection to the MySQL server. Other people can connect to the server as well (just like your cousins can also all grandma). They get their own connection objects.\n\nWe use the connection object for just a few operations:\n• selecting what database we are using, and\n\nOnce we connect, we may want to switch databases, either because our code is working with multiple databases, or because the database that is set in our file is not the one we want. (Of course, if we always want the other database, we could just edit the credentials file. It's just an ASCII file, and we can edit it with VS Code.)\n\nIn raw PyMySQL, you can use a method on the connection object:\n\nIf you're using with cached credentials and you want the next connection to use a different database, just modify the cached credentials before connecting. We saw that above:\n\nThis is very convenient, and since the first steps (reading and caching the CNF and modifying it to use a different database) are conceptually distinct from making the connection, we will often modularize these in our Flask apps. We'll cover that when we get to it.\n\nOnce we have a connection object, we need to be able to do queries and read the results. Both are done with special objects called cursors. (Indeed, every database API that I'm familiar with has cursors, so this is a very general notion, because of the issues we'll discuss now.) We get a cursor by requesting one from a connection object. Cursors are cheap, so feel free to get one for every query.\n\nDoing a simple query is fairly easy. There is an method on a cursor that will send the given query string to the DBMS and read the results.\n\nConceptually, reading the results seems easy but it comes in two styles. One way is just to get all the results as a (possibly large) list/array. To do that, there's a method on a cursor. But because the results could be large and we might not want all of them, or because we want to do something with each one before going on to the next, or similar reasons, we can get the results one row at a time. There's a method on a cursor to do that. If there are no more rows, the method returns . (This API might remind you of Java's iterators, and that's the correct intuition.)\n\nFinally, we need to discuss how each row is represented in Python. Cursors can either represent a row as a tuple or a dictionary. You specify this when you request a cursor from the connection.\n\nHere's an example ( ) that shows an example of a tuple cursor and the method:\n\nIn that case, we know that (because the query is using which is a key) there can be only 0 or 1 result, so is a reasonable choice.\n\nThe file shows an alternative that gets multiple results, represented as dictionaries:\n\nThat script works, but it's not great coding style. is a Python file that can also be used as a module in a larger system, providing a function that returns a list of all the people in the database:\n\nYou can use this script from the Unix command line very easily. Just activate your virtual environment and run python with the script, like this:\n\nThe script above is okay, but it always returns everyone. What if we wanted just the people born in September? What if we wanted the user to be able to choose the month that they cared about. For that, we need a way to parameterize a query.\n\nIt turns out that simple-minded ways of combining a user's input with other SQL code and executing the resulting query can result in security vulnerabilities. Specifically, a perennial top-ten vulnerability called SQL injection, which is when the attacker can trick your code into executing some SQL code that comes from the attacker.\n\nOne important way to foil a SQL injection attack is to use prepared queries, which is a safe way to parameterize a query with untrustworthy data.\n\nSuppose you have a query like this:\n\nfurthermore, you have a value that came from the user, an untrustworthy source. Suppose it's in a variable called\n\nThe wrong way to combine the two is to combine them as strings and then execute the result:\n\nThe right way to do a parameterized query is to keep the trustworthy SQL code separate from the untrustworthy parameters.\n\nPyMySQL does prepared queries as follows. The method can take an optional second argument which is a list of parameter values. Each parameter value is matched up with a placeholder in the SQL string that is the first argument. In PyMySQL, the placeholder is :\n\nIf you need to have more than one parameter, just use multiple placeholders. The placeholders are matched up with parameters from left to right, just like function calls:\n\nDifferent APIs use different placeholder characters. Some use a question mark. Some allow named parameters. In some, like PyMySQL, the placeholder is . This is an unfortunate choice, since is also used for a kind of string formatting, which we are not doing. I'm sure that %s was chosen because programmers were already familiar with %s as a kind of placeholder in string formatting, but we want to avoid string formatting.\n\nThe punch line talks about but even better is using prepared queries, because they absolutely keep the nefarious user's inputs from being treated as SQL code, which is the crux of a SQL injection attack.\n\nHere's the complete example for\n\nThe example above allows the user to run the script with a command line argument that is the sought month. If you don't know about command-line arguments in Python, you can read more about it below, but it's not essential for this topic.\n\nNote also the use of triple-quoted strings and the ability to spread strings over multiple lines makes it much easier to embed another language (SQL code) within Python, in a readable way. I strongly suggest using that anytime your embedded SQL code is anything but trivial.\n\nWe could use these same ideas to create a script that would easily let us insert data into the database.\n\nThere's an important difference between the default behavior of the PyMySQL client and the client. The client automatically commits any changes (makes them permanent). The default behavior requires you to commit the changes by using the on the connection object.\n\nThe script is an example. Note that the connection is done with just one line, since we want to use the default credentials file and not a different database. So all we need is\n\nHere's the relevant function in the file:\n\nNotice that because the method is on the connection object, not the cursor, it's convenient to pass connection objects as arguments to functions that need to update with the database, because then they can commit their changes. It's easy enough for them to create a cursor.\n\nWe know that SQL has a special value that is used to represent unknown or missing values. Note that is different from the string . We can store a in a numeric column (like, say, ) to say that it's unknown, but we can't store the string in a numeric column. (It would get converted to zero.)\n\nWe know that Python has a special value that is different (has a different datatype) than any other value. See None In short, it plays a similar role in the Python language that plays in SQL.\n\nThe PyMySQL API translates between and . So if you look up the director of a movie where the database doesn't have one, you get :\n\nSimilarly, to set the value to you would use :\n\nHere are the essential steps to using a database from Python:\n• connect to the database using appropriate credentials\n• create a cursor of the kind (tuple or dictionary) you want\n• execute the SQL statement you want, using the cursor. If it needs parameters from an untrustworthy source, use a prepared query. * for queries with no parameters, or * for queries with N dynamic values\n• fetch the results with either or on the cursor\n\nShould you use tuple cursors or dictionary cursors? Some considerations I use:\n\nIf I'm getting more than one or two columns of data, using results as tuples means I have to do some tedious and error-prone counting to get the indexes right:\n\nBut using dictionaries, the code is practically self-documenting:\n\nBy the way, I use for the columns all the time in the MySQL shell (client) but never in production code. I prefer to specify exactly what data I am returning. Also, since the order of the columns specifies the numbering of the elements of a tuple, is particularly hard to use.\n\nAlternatively, you can use destructuring assignment to take apart the tuple:\n\nThat also works well, but if we have to pass the data to another function, we have to pass 6 values instead of a single dictionary, so on balance I prefer dictionaries.\n\nDictionaries are not quite as compact as tuples, and sometimes that extra data matters. When I process all 300K rows of data in the diabetes database, Python runs out of memory if I use dictionary cursors, but it works fine if I use tuples."
    },
    {
        "link": "https://simeononsecurity.com/articles/python-security-best-practices-protecting-code-data",
        "document": "Python Security Best Practices: Protecting Your Code and Data\n\nPython is a powerful and versatile programming language that is widely used for various purposes, including web development, data analysis, and machine learning. However, like any other software, Python applications are susceptible to security vulnerabilities. In this article, we will discuss best practices for Python security to help you protect your code and data from potential threats.\n\nEnsuring the security of your Python applications is crucial for several reasons:\n• None Data Protection: Python applications often handle sensitive data, such as user information, financial records, or intellectual property. A security breach can lead to data theft or unauthorized access, resulting in severe consequences.\n• None System Integrity: Vulnerabilities in Python code can be exploited to gain unauthorized access to systems, manipulate data, or disrupt services. By implementing security best practices, you can safeguard the integrity of your systems and prevent unauthorized activities.\n• None Reputation and Trust: Security breaches not only harm your organization but also erode the trust of your customers and users. By prioritizing security, you demonstrate a commitment to protecting their interests and data, enhancing your reputation as a reliable and trustworthy provider.\n\nImplementing robust security measures in your Python applications helps mitigate risks and ensures the confidentiality, integrity, and availability of your data. It is essential to establish a strong security foundation to protect against cyber threats and maintain the trust of your users and stakeholders.\n\nTo enhance the security of your Python applications, it is essential to follow these best practices:\n\nRegularly updating your Python interpreter to the latest stable version ensures that you have the latest security patches and bug fixes. The Python community actively addresses vulnerabilities and releases updates to improve the security and stability of the language. Visit the Python website to download the latest version.\n\nBy keeping your Python interpreter up to date, you benefit from the latest security enhancements that address known vulnerabilities. These updates are designed to mitigate risks and protect your applications from potential attacks. Additionally, staying updated allows you to leverage new features and improvements introduced in newer versions of Python.\n\nFor example, if you are using Python 3.7 and a critical security vulnerability is discovered, the Python community will release a patch specifically addressing that vulnerability. By updating your Python interpreter to the latest version, such as Python 3.9, you ensure that your code is protected against known security issues.\n\nUpdating your Python interpreter is a straightforward process. Simply visit the Python downloads page and choose the appropriate installer for your operating system. Follow the installation instructions provided to upgrade your Python interpreter to the latest version.\n\nRemember to periodically check for updates and make it a best practice to update your Python interpreter regularly to stay ahead of potential security risks.\n\nAdopting secure coding practices minimizes the likelihood of introducing security vulnerabilities into your Python code. By following these practices, you can strengthen the security posture of your applications and protect against common attack vectors. Let’s explore some key practices:\n• None Input Validation: Validate all user inputs to prevent injection attacks and other input-related security issues. Implement techniques such as whitelisting, input sanitization, and parameterized queries to ensure that user-supplied data is validated and safe to use. For example, when accepting user input through a web form, validate and sanitize the input before processing or storing it in a database. This helps prevent malicious code or unintended input from compromising the application.\n• None Avoid Code Injection: Never execute user-supplied code without proper validation and sanitization. Code injection attacks occur when an attacker is able to inject and execute arbitrary code within your application’s context. To prevent this, carefully evaluate and validate any code provided by users before executing it. Use secure coding practices and libraries that provide protection against code injection vulnerabilities.\n• None Secure Password Handling: When working with passwords, it is crucial to handle them securely. Hash and salt passwords using appropriate hashing algorithms and key stretching techniques. Storing plain-text passwords is highly discouraged as it exposes users to significant risks. Instead, store only the password hashes and ensure their secure storage. Use strong hashing algorithms such as bcrypt or Argon2 and consider applying techniques like salt and pepper to further enhance password security. By implementing secure password handling practices, you can protect user credentials even if the underlying database is compromised.\n\nIt is important to note that secure coding practices go beyond these examples. Always be vigilant and keep up with the latest security guidelines and recommendations to ensure that your Python code remains secure.\n\nRole-Based Access Control (RBAC) is a powerful security model that restricts access to resources based on the roles assigned to users. By implementing RBAC in your Python applications, you can ensure that users only have the necessary privileges to perform their assigned tasks, minimizing the risk of unauthorized access and reducing the attack surface.\n\nIn RBAC, each user is assigned one or more roles, and each role is associated with specific permissions and access rights. For example, in a web application, you may have roles like admin, user, and guest. The admin role may have full access to all features and functionalities, while the user role may have limited access, and the guest role may have minimal or read-only access.\n• None Identifying Roles: Analyze your application’s functionality and determine the different roles that users can have. Consider the specific permissions and privileges associated with each role.\n• None Assigning Roles: Assign roles to users based on their responsibilities and the level of access they require. This can be done through user management systems or databases.\n• None Defining Permissions: Define the permissions associated with each role. For example, an admin role might have permissions to create, read, update, and delete records, while a user role might only have read and update permissions.\n• None Enforcing RBAC: Implement RBAC mechanisms within your Python application to enforce role-based access control. This can involve using decorators, middleware, or access control libraries to check the role of the user and verify their permissions before allowing access to specific resources.\n\nBy implementing RBAC, you establish a granular access control system that ensures users have the appropriate level of access based on their roles. This helps prevent unauthorized actions and restricts potential damage in the event of a security breach.\n\nTo learn more about implementing RBAC in Python, you can refer to the official Python Security documentation or explore relevant Python libraries and frameworks that provide RBAC functionalities, such as Flask-Security, Django Guardian, or Pyramid Authorization.\n\nWhen handling sensitive data in your Python applications, it is crucial to employ strong encryption techniques to protect the confidentiality and integrity of the data. By using well-established encryption algorithms and protocols, such as AES (Advanced Encryption Standard) and TLS (Transport Layer Security), you can ensure that data is encrypted both at rest and in transit.\n\nEncryption is the process of transforming data into an unreadable format, known as ciphertext, using encryption algorithms and cryptographic keys. Only authorized parties with the corresponding decryption keys can decipher the ciphertext and access the original data.\n\nHere are some examples of how you can protect sensitive data in Python:\n• None Data Encryption: Use encryption algorithms like AES to encrypt sensitive data before storing it in databases or other storage systems. This helps ensure that even if the data is accessed without authorization, it remains unreadable and unusable.\n• None TLS Encryption: When transmitting sensitive data over networks, such as during API calls or user authentication, use TLS encryption to establish secure and encrypted connections. TLS ensures that data exchanged between a client and a server is encrypted, preventing eavesdropping and data tampering.\n\nBy applying encryption techniques to protect sensitive data, you add an extra layer of security to your Python applications. This significantly reduces the risk of data breaches and unauthorized access to sensitive information.\n\nTo learn more about encryption in Python and how to implement it effectively, you can refer to relevant libraries and documentation, such as the Python Cryptography library and the official TLS RFC for understanding the TLS protocol.\n\nRemember that encryption is just one aspect of protecting sensitive data. It is equally important to implement secure storage, access controls, and secure key management practices to ensure comprehensive data protection.\n\nIf your Python application interacts with databases, it is essential to follow security practices to protect against potential vulnerabilities. Consider the following best practices:\n• None Use Prepared Statements: When executing database queries, utilize prepared statements or parameterized queries to prevent SQL injection attacks. Prepared statements separate SQL code from user-provided data, reducing the risk of unauthorized database access. For example, in Python, you can use libraries like SQLAlchemy or psycopg2 to implement prepared statements and protect against SQL injection vulnerabilities.\n• None Implement Least Privilege: Ensure that the database user associated with your Python application has the minimum necessary privileges required for its functionality. By following the principle of least privilege, you restrict the capabilities of the database user to only what is necessary, minimizing the potential impact of a compromised database connection. For example, if your application only requires read-only access to certain tables, grant the database user read-only privileges for those specific tables rather than full access to the entire database.\n\nBy using prepared statements and implementing least privilege, you strengthen the security of your database access and mitigate the risks associated with common attack vectors. It is also important to stay updated with the latest security guidelines and best practices provided by database vendors and relevant documentation.\n\nTo learn more about secure database access in Python, you can refer to the documentation and resources of popular database libraries such as SQLAlchemy for working with relational databases, psycopg2 for PostgreSQL, or specific documentation provided by your chosen database management system.\n\nRemember, securing database access is a critical aspect of protecting your data and maintaining the integrity of your Python applications.\n\nPython projects often rely on third-party libraries and frameworks to enhance functionality and streamline development. However, it is crucial to regularly update these dependencies to ensure the security and stability of your project.\n\nStaying vigilant about updating dependencies allows you to benefit from security patches and bug fixes released by the library maintainers. By keeping your dependencies up to date, you mitigate the risk of potential vulnerabilities and ensure that your project is running on the latest stable versions.\n\nTo effectively manage dependencies, consider the following practices:\n• None Track Vulnerabilities: Stay informed about reported vulnerabilities in your project dependencies. Websites like Snyk provide vulnerability databases and tools that can help you identify and address vulnerabilities in your dependencies. By regularly monitoring these vulnerabilities, you can take timely actions to update or replace affected dependencies.\n• None Update Dependencies Promptly: When security patches or updates are released for your project dependencies, update them promptly. Delaying updates increases the risk of exploitation, as attackers may target known vulnerabilities in outdated versions.\n• None Automate Dependency Management: Consider using dependency management tools such as Pipenv or Conda to automate dependency installation, version control, and updates. These tools can simplify the process of managing dependencies, ensuring that updates are applied consistently across different environments.\n\nRemember, maintaining up-to-date dependencies is an ongoing process. Set up a regular schedule to review and update your project dependencies, keeping security as a top priority. By staying proactive and vigilant, you can significantly reduce the risk of potential security vulnerabilities in your Python projects.\n\nTo enhance the security of your Python applications, it is essential to implement comprehensive logging and monitoring mechanisms. Logging allows you to track events and activities within your application, while monitoring provides real-time visibility into the system’s behavior, enabling the detection and investigation of security incidents.\n\nBy enabling logging, you can capture relevant information about the execution of your application, including errors, warnings, and user activities. Properly configured logging helps you identify issues, debug problems, and trace security-related events. For example, you can log authentication attempts, access to sensitive resources, or suspicious activities that may indicate a security breach.\n\nAdditionally, monitoring enables you to observe your application’s runtime behavior and detect any anomalies or security-related patterns. This can be done using tools and services that provide real-time monitoring, log aggregation, and alerting capabilities. For instance, services like AWS CloudWatch, Datadog, or Prometheus offer monitoring solutions that can be integrated with your Python applications.\n\nBy enabling logging and monitoring, you can:\n• None Detect Security Incidents: Log entries and monitoring data can help you identify security incidents or suspicious activities, allowing you to respond quickly and effectively.\n• None Investigate Breaches: When a security incident occurs, logs and monitoring data provide valuable information for post-incident investigations and forensic analysis.\n• None Improve Security Posture: By analyzing logs and monitoring data, you can gain insights into the effectiveness of your security measures, identify potential vulnerabilities, and take proactive steps to enhance your application’s security posture.\n\nRemember to configure logging and monitoring appropriately, balancing the level of detail captured with the potential impact on performance and storage. It is also essential to regularly review and analyze the collected logs and monitoring data to stay proactive in identifying and addressing security concerns.\n\nImplementing log management solutions and utilizing monitoring tools empowers you to stay ahead of potential security threats and protect your Python applications effectively.\n\nTo reinforce Python security best practices, it is crucial to invest in educating and training your Python developers. By providing them with the necessary knowledge and skills, you empower your development team to write secure code and detect potential security issues early in the development lifecycle.\n\nHere are some steps you can take to promote developer education and training:\n• None Security Awareness Programs: Conduct regular security awareness programs to educate developers about common security vulnerabilities and secure coding practices. These programs can include workshops, webinars, or online training sessions tailored to Python application development.\n• None Secure Coding Guidelines: Establish secure coding guidelines specific to Python development, outlining recommended practices and code patterns that mitigate common vulnerabilities. These guidelines can cover topics such as input validation, secure authentication, data encryption, and secure handling of sensitive information.\n• None Code Reviews and Pair Programming: Encourage a culture of collaboration and learning through code reviews and pair programming. By reviewing code together, developers can share knowledge, identify security weaknesses, and suggest improvements. This helps in maintaining code quality and adherence to secure coding practices.\n• None Security-focused Tools: Integrate security-focused tools, such as static code analysis tools, into your development workflow. These tools can automatically identify potential security issues, insecure coding patterns, and vulnerabilities in the codebase. For Python, you can explore tools like Bandit or Pylint to analyze your code for security vulnerabilities.\n• None Continuous Learning: Encourage developers to stay updated with the latest security trends, best practices, and emerging threats in the Python ecosystem. This can be achieved through participation in security conferences, webinars, or by following reputable security resources like the OWASP (Open Web Application Security Project) community.\n\nBy investing in developer education and training, you create a strong foundation for building secure Python applications. Promoting a security-focused mindset among developers helps in preventing security incidents, reducing vulnerabilities, and ensuring the overall security of your software.\n\nRemember, security is a continuous process, and ongoing education and training are necessary to stay ahead of evolving threats and maintain the highest standards of security in your Python development projects.\n\nHere is a concise cheat sheet summarizing the Python security best practices discussed in this article:\n• None Keep your Python interpreter updated to the latest stable version to benefit from security patches and bug fixes. Visit the Python website - Downloads to download the latest version.\n• None Follow secure coding practices, including input validation to prevent injection attacks, avoiding code injection by validating and sanitizing user-supplied code, and secure password handling by using appropriate hashing algorithms and password storage techniques.\n• None Implement Role-Based Access Control (RBAC) to restrict unauthorized access. RBAC assigns roles to users based on their responsibilities and grants access privileges accordingly. Refer to the NIST - Role-Based Access Control documentation for more details.\n• None Protect sensitive data using strong encryption techniques. Utilize well-established encryption algorithms like AES (Advanced Encryption Standard) and ensure secure storage and transmission of sensitive information. You can refer to the AES Wikipedia page for more information.\n• None Secure database access by using prepared statements to prevent SQL injection attacks and implementing least privilege to restrict database user permissions. These practices minimize the risk of unauthorized access to sensitive data. Learn more about prepared statements in the SQLAlchemy documentation and least privilege in the OWASP RBAC Cheat Sheet .\n• None Regularly update dependencies to address security vulnerabilities and benefit from bug fixes. Tools like Snyk - Open Source Security Platform can help you identify vulnerabilities in your project dependencies.\n• None Enable logging and monitoring to detect and investigate security incidents. Logging captures relevant information about application events, while monitoring provides real-time visibility into system behavior. Consider using services like AWS CloudWatch, Datadog, or Prometheus for comprehensive monitoring.\n• None Educate and train developers on secure coding practices and common security vulnerabilities. Promote security awareness programs, establish secure coding guidelines, and encourage code reviews and pair programming. Explore security tools like Bandit or Pylint for static code analysis.\n\nFor a more comprehensive guide on Python security, refer to the official Python Security documentation .\n\nProtecting your Python code and data from security vulnerabilities should be a top priority for any developer or organization. By following the best practices outlined in this article, you can minimize the risk of security breaches and ensure the integrity and confidentiality of your applications. Stay informed about the latest security threats, adopt secure coding practices, and prioritize security throughout the development lifecycle.\n\nRemember, securing your Python applications is an ongoing process. Regularly update your code, stay informed about emerging threats, and continuously enhance your security practices to stay one step ahead of potential attackers."
    },
    {
        "link": "https://qwiet.ai/appsec-resources/securing-your-python-codebase-best-practices-for-developers",
        "document": "Are you confident that your Python application can stand up to the latest cybersecurity threats? As Python’s popularity surges across various fields, the security of its codebases has become critical. This article delves into essential security practices for Python developers, aiming to fortify applications against cyber threats. You’ll walk away with a clear understanding of common vulnerabilities, strategies to address them, and a wealth of Python-specific security measures to apply to your projects.\n\nPython is a powerhouse in the programming world, but it’s not immune to security risks. When we talk about coding in Python, the threat list is long: we’ve got everything from injection attacks to authentication issues. These aren’t just small bugs; they can lead to serious breaches, leak sensitive data, and give cyber intruders the keys to the kingdom. Python developers need to stay sharp and secure their code from these vulnerabilities.\n\nSome of the common vulnerabilities include:\n• SQL Injection: In Python, this risk emerges when executing SQL commands with user input not correctly sanitized, potentially corrupting or leaking database data.\n• Cross-Site Scripting (XSS): Python web apps face this when user-generated content isn’t escaped properly, leading to the execution of malicious scripts.\n• Insecure Deserialization: Python applications can be compromised if they deserialize data from untrusted sources with modules like pickle.\n• Buffer Overflows: A less common issue in Python due to its high-level nature, but it can occur in extensions written in C or when interfacing with lower-level libraries.\n• Cross-Site Request Forgery (CSRF): Python frameworks often include CSRF protection. Still, developers need to ensure this is enabled and properly configured to prevent unauthorized actions on behalf of logged-in users.\n• Broken Authentication: Weak implementation of session management and user authentication in Python can allow attackers to assume users’ identities.\n\nSecure coding in Python development is all about writing code that’s not just functional but also safe. As developers, we must think like an attacker and defend against potential threats. This means rigorously validating all inputs to prevent SQL injection and XSS attacks, carefully handling errors so they don’t give away system information, and ensuring that authentication methods are airtight to keep out unauthorized users.\n\nInput validation is the first line of defense in Python programming. It ensures that the data your program receives is what it expects and can safely process. This step is important because invalid or malicious data can lead to security vulnerabilities, such as SQL injection or buffer overflows. In essence, input validation is about preemptively catching errors and potential exploits by checking the data before it’s used in your application.\n\nHere’s a rundown of the best practices for input validation in Python:\n• Define the Input: Clearly define what kind of data is acceptable. If it’s a string, should it be alphanumeric? If it’s a number, what range is okay?\n• Validate Against Criteria: Always check that the incoming data matches your requirements. This isn’t just about type checking; it’s about confirming the data fits the expected format and length and adheres to the expected pattern.\n• Handle Invalid Input: When data doesn’t pass validation, have a plan. You might log the issue, throw an exception, or ask the user to re-enter the data, but don’t just let it slide.\n• Secure Default Values: Use safe default values to handle unexpected inputs. If something slips through the cracks, your application won’t suddenly behave unpredictably.\n• Regular Updates: Keep your validation logic up-to-date. As new threats emerge, you must adjust your rules to stay one step ahead of attackers.\n\nSo, how would we implement the above practices let take a look:\n\nAs you can see from the above snippet, the validate_input function is designed to be versatile, handling various types of data and constraints. It begins by confirming that the data matches the expected type, preventing type-related errors. It then applies specific constraints, like minimum and maximum values for integers, which is crucial for numerical validations. If the input doesn’t meet the criteria, it raises an appropriate exception, clearly communicating the nature of the issue.\n\nWe attempt to validate an age integer, ensuring it falls within a legal range. We catch the exception if the input is invalid and print an error message. As a fallback, we set a secure default age value, maintaining the application’s integrity in case of invalid input. This demonstrates handling unexpected or unsafe inputs in a controlled manner, ensuring the application remains stable and secure.\n• None Best practices for logging errors without exposing sensitive information.\n\nError handling in Python is more than just preventing crashes; it’s about ensuring that they do so without compromising security when things go wrong. Secure error handling means anticipating the unexpected and having a strategy to deal with it.\n\nUsing try-except blocks is the first step, allowing you to catch and respond to exceptions in a way that keeps your application running smoothly and securely. It’s essential to anticipate and handle specific exceptions to prevent a generic catch-all that might swallow important debugging information or security-relevant signals.\n\nThe goal of logging errors is to record enough information for debugging while not leaking any sensitive details. This balance is critical:\n• Validate Error Outputs: Always sanitize error messages displayed to the user or written to logs to prevent revealing stack traces, system information, or confidential data.\n• Implement Logging: Use Python’s logging module to record errors. Configure it to exclude sensitive information and ensure that logs are stored securely and with proper access control.\n• Regular Log Reviews: Review log files for anomalies that could indicate security incidents or operational issues. This practice is not just for post-mortem analysis but is a proactive security measure.\n\nThis snippet uses a try-except block to handle any ZeroDivisionError specifically, which could occur during division operations. We log the error occurrence without exposing any sensitive details. For other unexpected exceptions, we catch them generally, log an error message, and set a secure default result value of None. This way, we’re recording the necessary debugging information without risking sensitive information. Regular review of the app.log file would help identify and rectify recurring issues while keeping an eye out for potential security threats.\n\nAuthentication and authorization form the cornerstone of web security in Python applications. Authentication is about verifying who a user is, typically through credentials like usernames and passwords, while authorization determines what an authenticated user is allowed to do. Getting these processes right is essential to protect against unauthorized access and to ensure that users can only interact with the parts of your application they’re permitted to.\n\nFor secure user authentication in Python, follow these techniques:\n• Strong Credential Storage: Use hashing algorithms, like bcrypt, to store user passwords. Never store passwords in plain text.\n• Multi-Factor Authentication (MFA): Implement MFA to add an extra layer of security, ensuring that even if a password is compromised, unauthorized access is still prevented.\n• Session Management: Utilize secure, unique session tokens and ensure they are invalidated upon logout or after a period of inactivity.\n\nBelow is a Python code snippet that demonstrates secure authentication and role-based access control, typically in the context of a web application using Flask:\n\nThis snippet provides a basic structure for handling secure user authentication and role-based access control within a Flask application. It includes user model definitions with roles, password hashing for secure credential storage, session management with secure token generation, and role verification for access control.\n\nIn the /login route, it handles user authentication by verifying usernames and passwords and storing a secure session token if successful. The /admin route demonstrates role-based access control, where only users with the ‘admin’ role can view the page, and the /logout route properly clears the session. Note that this is a simplified example for demonstration purposes, and a real-world application should include additional security measures such as HTTPS enforcement, proper error handling, and more sophisticated user session management.\n\nSecuring your Python development process is an ongoing task involving multiple security layers. Here’s a checklist with specific practices that you can take to bolster the security of your Python application:\n• Integrate a Python Security Linter: Incorporate a security-focused linter-like bandit into your CI/CD pipeline to catch security flaws.\n• Automate Dependency Checks: Use safety to automatically check your installed dependencies for known security vulnerabilities.\n• Implement Pre-Commit Hooks: Set up pre-commit hooks using pre-commit that run checks like flake8, black for code formatting, and sort for import sorting, which indirectly improves code quality and security.\n• Use HTTPS for All Web Traffic: Ensure your Python web applications enforce HTTPS by default. When using Flask, you can redirect all incoming requests to HTTPS.\n• Employ ORM for Database Interactions: Utilize Object-Relational Mapping (ORM) libraries like SQLAlchemy or Django ORM to interact with databases, which helps prevent SQL injection attacks.\n• Store Secrets Securely: Use python-dotenv to load sensitive data from an .env file that is not tracked in version control systems.\n• Enable ORM Debug Logging With Caution: In development, you might enable ORM debug logging to troubleshoot issues, but ensure it’s turned off in production to avoid leaking sensitive information.\n• Regularly Rotate Encryption Keys: Make it a habit to rotate your encryption keys periodically. Implement key rotation in your application logic if you manage your encryption.\n• Enforce Type Checking: Use mypy or similar tools to enforce type checking, which can prevent certain types of bugs that might lead to security vulnerabilities.\n• Setup Structured Logging: Use structured logging with proper log levels, which helps diagnose issues without exposing too much information.\n• Leverage Automated Security Scanning Tool: Use an automated security tool like to regularly scan your codebase for known vulnerabilities in both your code and dependencies. Set it up to run at regular intervals, such as with each commit or at least once a week.\n\nWe’ve journeyed through the crucial aspects of securing Python code, tackling input validation, error handling, authentication, and more, concluding with a targeted checklist to keep your codebase secure. Remember, security is an ongoing pursuit, and staying updated with best practices is key to defense.\n\nReady to enhance the security of your Python codebase? Book a demo with Qwiet today."
    },
    {
        "link": "https://linkedin.com/advice/3/what-best-practices-handling-user-input-python-bwznf",
        "document": ""
    },
    {
        "link": "https://blackduck.com/blog/python-security-best-practices.html",
        "document": "One key to interactive software is user inputs and the reaction of the software to it. But however useful, those inputs can be highly dangerous, as they can lead to possible injection attacks. One of the most common and simple injection attacks is SQL injection.\n\nSQL injection is a vulnerability in which an attacker influences the queries that software makes to the database. By inserting a relatively simple command, one can, for example, turn an authorization check into administrative access to a web portal. Some web platforms limit the special characters that can be included in usernames and passwords to prevent the use of those characters in a SQL injection attack. Unfortunately, this makes the creation of strong passwords more difficult. Therefore, it’s best to sanitize the inputs—that is, check every input and create rules defining valid inputs, acceptable character sequences, and which combinations to allow. This helps prevent injection attacks while still allowing strong passwords.\n\nTo further improve security, make sure your database supports prepared statements. Databases like MySQL, MS SQL Server, and PostgreSQL support this functionality because it can protect against vulnerabilities like SQL injection—and in some cases, it even results in performance improvements in your application, especially if you run SQL statements repeatedly. And in Python, you can use prepared statements even if your database doesn’t support them. Python supports this functionality in its standard libraries and will emulate it on the client side if needed. The biggest security benefit of using prepared statements is the separation of SQL statements and user-provided data. This ensures that user-provided data cannot be abused to modify SQL statements, and will be used literally in the precompiled statement that logic will not change.\n\nMalicious actors often create misspelled domains to catch people who have misspelled their URL. The same can happen when fetching libraries from PyPI. A malicious package with a name similar to a legitimate one could be placed in a repository to trick someone into fetching it by mistake.\n\nIn absolute imports, you specify the full path to the package you want to use. In relative imports, you import a package relative to the location of the project where you made the import statement. There are two types of relative imports.\n• The explicit relative import requires you to specify the exact path of the module relative to the current module\n• The implicit relative import doesn’t specify the resource path at all\n\nThe danger of implicit relative imports is that a poisoned package could find its way into another part of your project (via an import of another library) and then could mistakenly be used instead of the library you intended. Due to the unspecified path and the potential for confusion, the implicit relative import was removed from Python 3.x. However, if you are still using older versions of Python, remove the implicit relative imports and use either the absolute or explicit relative import types."
    },
    {
        "link": "https://medium.com/@StarkesWeb/secure-input-handling-in-python-applications-4fb7f511d8cc",
        "document": "The first step in secure input handling is validation. The idea is to check if the input data is what you expect. For instance, if you’re asking for a date, it shouldn’t be “42”. 🗓️\n\nRegular expressions (regex) are powerful tools to match patterns in text. If you’re validating an email, you want to ensure it has a `@` and a domain. Of course, be cautious — regex can get messy quickly! 🌀\n\nGotcha Alert! ⚠️ Not all emails adhere perfectly to simple regex patterns. While `re` is nifty, don’t rely on it alone for complex validation.\n\nSpeaking of performance issues (or the lack thereof when code goes wrong), encoding and escaping are crucial to avoiding certain types of attacks. Never trust user inputs directly: always escape them before using in database queries or HTML.\n\nSay you’re displaying user comments. Without proper escaping, one nasty script tag and — whoosh — your site is compromised. Use built-in functions to encode HTML entities. Here’s a flavored taste:\n\nNow, libraries…Python is blessed with a plethora of them. Here are a few that come handy for secure input handling:\n• Bleach: A library for sanitizing and stripping HTML, CSS, and Javascript. Yes, it helps avoid XSS attacks.\n\n2. SQLAlchemy: While technically a database toolkit, it automatically escapes inputs, reducing risk of SQL injection.\n\nSpeaking of libraries, sometimes they also surprise us with edge cases. For instance, remember versions might differ on what they automatically handle. 🤷‍♂️\n\nEscaping transforms special characters into a safe format that won’t be executed. It’s an added layer, much like washing your hands even after wearing gloves. 🧼\n\nFor SQL, while libraries like SQLAlchemy handle much of this, if you’re writing custom queries, use parameterized ones:\n\nNotice how is used instead of concatenating strings? That’s our safety net.\n\nReal-World Example: Putting It All Together\n\nLet’s mock a mini-scene to bind these concepts. Imagine a web form collecting user feedback. We need to validate email, clean text input, and store it safely in a database.\n\nWithout diving into the entire code…here’s an open-ended question: could these steps always guarantee safety? 👀"
    }
]