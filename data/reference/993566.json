[
    {
        "link": "https://docs.aiogram.dev",
        "document": "# Bot token can be obtained via https://t.me/BotFather # All handlers should be attached to the Router (or Dispatcher) # Most event objects have aliases for API methods that can be called in events' context # For example if you want to answer to incoming message you can use `message.answer(...)` alias # and the target chat will be passed to :ref:`aiogram.methods.send_message.SendMessage` Handler will forward receive a message back to the sender By default, message handler will handle all message types (like a text, photo, sticker etc.) # But not all the types is supported to be copied so need to handle it # Initialize Bot instance with default bot properties which will be passed to all API calls"
    },
    {
        "link": "https://docs.aiogram.dev/en/stable/api/bot.html",
        "document": "# Bot token can be obtained via https://t.me/BotFather # All handlers should be attached to the Router (or Dispatcher) # Most event objects have aliases for API methods that can be called in events' context # For example if you want to answer to incoming message you can use `message.answer(...)` alias # and the target chat will be passed to :ref:`aiogram.methods.send_message.SendMessage` Handler will forward receive a message back to the sender By default, message handler will handle all message types (like a text, photo, sticker etc.) # But not all the types is supported to be copied so need to handle it # Initialize Bot instance with default bot properties which will be passed to all API calls"
    },
    {
        "link": "https://docs.aiogram.dev/en/v3.19.0/api/bot.html",
        "document": "Bot instance can be created from ( ) and you can’t use methods without instance of bot with configured token.\n\nThis class has aliases for all methods and named in .\n\nFor example named and has the same specification with all class-based methods.\n• None session – HTTP Client session (For example AiohttpSession). If not specified it will be automatically created.\n• None default – Default bot properties. If specified it will be propagated into the API methods at runtime. TokenValidationError – When token has invalid format this exception will be raised If you want to automatically create destination ( ) use default value of destination and handle result of this method.\n• None file_path – File path on Telegram server (You can get it from )\n• None destination – Filename, file path or instance of . For e.g. , defaults to None\n• None seek – Go to start of file when downloading is finished. Used only for destination with type, defaults to True Download file by file_id or Downloadable object to destination. If you want to automatically create destination ( ) use default value of destination and handle result of this method.\n• None destination – Filename, file path or instance of . For e.g. , defaults to None\n• None seek – Go to start of file when downloading is finished. Used only for destination with type, defaults to True"
    },
    {
        "link": "https://stackoverflow.com/questions/77295612/how-to-configure-proxy-in-aiogram-3-1-1-python",
        "document": "Aiogram 3.1.1 didnot natively support proxy configuration, to use proxy for, you typically needed to use external Python libraries like aiosocksy or aiohttp. These libraries can be used to route your bot requests through a proxy server."
    },
    {
        "link": "https://docs.aiogram.dev/en/v3.13.1/api/bot.html",
        "document": "Bot instance can be created from ( ) and you can’t use methods without instance of bot with configured token.\n\nThis class has aliases for all methods and named in .\n\nFor example named and has the same specification with all class-based methods.\n• None session – HTTP Client session (For example AiohttpSession). If not specified it will be automatically created.\n• None default – Default bot properties. If specified it will be propagated into the API methods at runtime. TokenValidationError – When token has invalid format this exception will be raised If you want to automatically create destination ( ) use default value of destination and handle result of this method.\n• None file_path – File path on Telegram server (You can get it from )\n• None destination – Filename, file path or instance of . For e.g. , defaults to None\n• None seek – Go to start of file when downloading is finished. Used only for destination with type, defaults to True Download file by file_id or Downloadable object to destination. If you want to automatically create destination ( ) use default value of destination and handle result of this method.\n• None destination – Filename, file path or instance of . For e.g. , defaults to None\n• None seek – Go to start of file when downloading is finished. Used only for destination with type, defaults to True"
    },
    {
        "link": "https://docs.aiogram.dev/en/stable/utils/i18n.html",
        "document": "# Bot token can be obtained via https://t.me/BotFather # All handlers should be attached to the Router (or Dispatcher) # Most event objects have aliases for API methods that can be called in events' context # For example if you want to answer to incoming message you can use `message.answer(...)` alias # and the target chat will be passed to :ref:`aiogram.methods.send_message.SendMessage` Handler will forward receive a message back to the sender By default, message handler will handle all message types (like a text, photo, sticker etc.) # But not all the types is supported to be copied so need to handle it # Initialize Bot instance with default bot properties which will be passed to all API calls"
    },
    {
        "link": "https://aiogram-i18n.readthedocs.io",
        "document": "aiogram_i18n, an unrivalled middleware for Telegram bot internationalization, breathes life into bots, enabling diverse interactions in multiple languages, while adeptly managing user context, paving the way for a truly engaging and immersive user experience irrespective of language preference, and providing robust support for both Fluent and GNU gettext localization systems, thereby offering flexibility in translation file format selection, streamlining the translation process, and making the creation of multilingual bots an achievable goal for developers.\n\nTo install aiogram-i18n without any backends: If you need help with what backend to choose, read Backends. To use fluent-compiler backend ( ) install it: To use Fluent.runtime backend ( ) install it: To use gettext backend ( ) install it:\n\n# you should import mutable objects from here if you want to use LazyProxy in them"
    },
    {
        "link": "https://docs.aiogram.dev/en/v2.25.1",
        "document": "aiogram is a pretty simple and fully asynchronous framework for Telegram Bot API written in Python 3.7 with asyncio and aiohttp. It helps you to make your bots faster and simpler.\n• None Can reply into webhook. (In other words make requests in response to updates)"
    },
    {
        "link": "https://github.com/aiogram/i18n",
        "document": ", , , . . . . . , , , . . . ( , # you should import mutable objects from here if you want to use LazyProxy in them ) ( ) ( [ [ ( ( ))] ], ) ( : , : ) : . . () . ( . ( , ), ) ( : ) : . ( . ) () : ( ) ( , ( . )) ( ( ) ) () . ( ) . ( ) . ( ) : ( ): . ( ())"
    },
    {
        "link": "https://docs.aiogram.dev",
        "document": "# Bot token can be obtained via https://t.me/BotFather # All handlers should be attached to the Router (or Dispatcher) # Most event objects have aliases for API methods that can be called in events' context # For example if you want to answer to incoming message you can use `message.answer(...)` alias # and the target chat will be passed to :ref:`aiogram.methods.send_message.SendMessage` Handler will forward receive a message back to the sender By default, message handler will handle all message types (like a text, photo, sticker etc.) # But not all the types is supported to be copied so need to handle it # Initialize Bot instance with default bot properties which will be passed to all API calls"
    },
    {
        "link": "https://docs.aiogram.dev/en/latest/dispatcher/finite_state_machine/index.html",
        "document": "An FSM is defined by a list of its states, its initial state, and the inputs that trigger each transition.\n\nIt is an abstract machine that can be in exactly one of a finite number of states at any given time. The FSM can change from one state to another in response to some inputs; the change from one state to another is called a transition.\n\nA finite-state machine (FSM) or finite-state automaton (FSA, plural: automata), finite automaton, or simply a state machine, is a mathematical model of computation.\n\nNot all functionality of the bot can be implemented as single handler, for example you will need to collect some data from user in separated steps you will need to use FSM.\n\nLet’s see how to do that step-by-step\n\nBefore handle any states you will need to specify what kind of states you want to handle And then write handler for each state separately from the start of dialog Here is dialog can be started only via command , so lets handle it and make transition user to state \"Hi there! What's your name?\" After that you will need to save some data to the storage and make transition to next step. Did you like to write bots?\" At the next steps user can make different answers, it can be , or any other Handle and soon we need to handle state What programming language did you use for it?\" And handle any other answers All possible cases of step was covered, let’s implement finally step \"Python, you say? That's the language that makes my circuits light up! 😉\" \"you like to write bots with \"you don't like to write bots, so sad...\" And now you have covered all steps from the image, but you can make possibility to cancel conversation, lets do that via command or text Allow user to cancel any action\n\n\"Hi there! What's your name?\" Allow user to cancel any action Did you like to write bots?\" What programming language did you use for it?\" \"Python, you say? That's the language that makes my circuits light up! 😉\" \"you like to write bots with \"you don't like to write bots, so sad...\" # Initialize Bot instance with default bot properties which will be passed to all API calls"
    },
    {
        "link": "https://medium.com/sp-lutsk/exploring-finite-state-machine-in-aiogram-3-a-powerful-tool-for-telegram-bot-development-9cd2d19cfae9",
        "document": "In the realm of Telegram bot development, the quest for efficiency and robustness is an ongoing endeavor. With each iteration, developers seek tools and frameworks that streamline the development process while ensuring the scalability and maintainability of their bots. In this pursuit, the integration of Finite State Machines (FSMs) has emerged as a powerful technique, providing a structured approach to managing bot behavior. In this article, we delve into the integration of Finite State Machines within the Aiogram 3 framework, a powerful option for Telegram bot development in Python. Aiogram, renowned for its simplicity and flexibility, empowers developers to build feature-rich bots effortlessly. By using FSM, it can become even more seamless, offering developers a structured approach to handling complex bot behavior.\n\nA Finite State Machine (FSM) is a computational model used to describe the behavior of a system by dividing it into a finite number of states, along with transitions between these states based on certain conditions or events. At its core, an FSM consists of the following components:\n• States: These represent the distinct conditions or modes that the system can be in at any given time. Each state encapsulates a specific set of behaviors or actions that the system can perform while in that state.\n• Transitions: These define the conditions or events that trigger a change in state. When a transition occurs, the system moves from one state to another, potentially altering its behavior or internal configuration.\n• Inputs/Events: These are the stimuli or signals that drive the transitions between states. Inputs can come from various sources, such as user interactions, sensor readings, or external events. In Aiogram 3, the integration of Finite State Machines offers developers a remarkable opportunity to manage the intricate flow of user inputs with ease. By guiding users through a sequence of defined states and handling each state separately, FSMs empower developers to create Telegram bots that gracefully navigate through complex interaction scenarios. This capability allows for the systematic handling of user inputs, ensuring a seamless conversational experience for bot users.\n\nTo better comprehend the theoretical aspects of Finite State Machines (FSM) in Aiogram, let’s embark on a practical journey. Imagine we’re creating a form within our Telegram bot where we sequentially ask users a series of questions, concluding with a confirmation of the collected answers. In Aiogram, FSMs are represented as StatesGroups, serving as the foundation for organizing bot behavior into distinct states and managing transitions between them. The schema below illustrates the sequential flow of our form within the FSM framework: Starting with the creation of a StatesGroup, we establish a structured environment for managing the flow of user interactions. Each state within the StatesGroup corresponds to a specific stage in our form, guiding users through a sequence of questions and responses. As users progress through the form, transitions between states occur based on their inputs, ensuring a smooth and intuitive user experience. Now, let’s delve into the implementation details. Below, you’ll find the code snippet illustrating the creation of the StatesGroup with Aiogram: After defining the StatesGroup for our form, the next step is to establish handlers to manage user interactions. Typically, a conversation with the bot initiates with the /start command. Therefore, our first task is to handle this command and transition the user to the initial state of our form, Form.About.first_name. Below is a snippet showcasing the implementation of the handler for the /start command and the transition operation to the first state: We have added two buttons for this question — “Skip” and “Cancel”, we will cover them later. After the user answers the first question, we need to store the answer in the storage and move on to the next step. Code snippet to handler first state and transition to second state: In this handler, we’ve successfully stored the user’s input for the first question and will now progress to the next question. Additionally, we’ll incorporate an “Go back” button later, enabling users to make transition to the previous question. Following a consistent sequence, each subsequent handler will entail the same actions: saving the user’s response, transitioning to the subsequent step, and posing the subsequent question. Upon reaching the final state, Form.confirm, users will be presented with all collected information for review. With the implementation of the described logic, our bot is now equipped to traverse through all defined states, guiding users through each step of the form.\n\nIncorporating various options to enhance user flexibility during Finite State Machine (FSM) integration in Aiogram is crucial for providing a smoother user experience. Among these options is the ability to terminate the flow, facilitated by the addition of a “Cancel” button. This button should be accessible from any state within the FSM, necessitating a single handler to manage its functionality. This handler will be responsible for clearing the current state and sending an appropriate message to the user, indicating the cancellation of the flow. @form_router.message(Command(\"cancel\"))\n\n@form_router.message(F.text.casefold() == \"cancel\")\n\nasync def cancel_handler(message: Message, state: FSMContext) -> None:\n\n \"\"\"\n\n Allow user to cancel any action\n\n \"\"\"\n\n current_state = await state.get_state()\n\n if current_state is None:\n\n return To introduce the “Go back” button functionality, enabling users to transition to the previous state, we need to implement an additional tool — a list containing information about the states. For this, let’s outline a data structure representing the state information. Code snippet for this: Each element of the list will be represented as dataclass with state name, question for this state, in memory representative value, corresponding button (we will need it for future step) and keyboard buttons that need to be sent to user with state question. Code snippet for first state implementation in dataclass format: State(\n\n \"Form.About:first_name\",\n\n \"What's your first name?\",\n\n \"first_name\",\n\n \"First name\",\n\n [\n\n [KeyboardButton(text=\"Skip\")],\n\n [KeyboardButton(text=\"Cancel\")],\n\n ],\n\n), All following states will have similar structure, but with additional “Go back” button. Code snippet example for following states: State(\n\n \"Form.About:last_name\",\n\n \"What's your last name?\",\n\n \"last_name\",\n\n \"Last name\",\n\n [\n\n [KeyboardButton(text=\"Skip\"), KeyboardButton(text=\"Go back\")],\n\n [KeyboardButton(text=\"Cancel\")],\n\n ],\n\n), This list of states will allow us to track the state by name and manage all of its attributes to better understand it lets review code snippet for the “Go back” button handler: @form_router.message(Command(\"go back\"))\n\n@form_router.message(F.text.casefold() == \"go back\")\n\nasync def go_back_handler(message: Message, state: FSMContext) -> None:\n\n current_state = await state.get_state()\n\n logging.info(\"Going back from %r\", current_state)\n\n (\n\n previous_state,\n\n state_message,\n\n keyboard_buttons\n\n ) = get_previous_state(current_state)\n\n if previous_state is None:\n\n await message.answer(\n\n \"You are already at the first step.\",\n\n )\n\n else:\n\n await state.set_state(previous_state)\n\n await message.answer(\n\n state_message,\n\n reply_markup=ReplyKeyboardMarkup(\n\n keyboard=keyboard_buttons,\n\n resize_keyboard=True,\n\n ),\n\n ) In this handler we get the current_state and based on that we get the previous state information using the get_previous_state method. def get_previous_state(current_state: str) -> str:\n\n current_state_index = next(\n\n (i for i, obj in enumerate(STATES_LIST) if obj.state_name == current_state),\n\n None,\n\n )\n\n previous_state_index = current_state_index - 1\n\n if previous_state_index < 0:\n\n return None, None\n\n return (\n\n STATES_LIST[previous_state_index].state_name,\n\n STATES_LIST[previous_state_index].state_question,\n\n STATES_LIST[previous_state_index].keyboard_buttons,\n\n ) This method uses created STATES_LIST to receive current state (the state from which the user wants to go back) index and based on this returns information about previous state name, questions and keyboard buttons. After this we only need to set this state and send proper message to user. Implementation of this flow shown bellow.\n\nTransition to any state in flow Now when we can cancel flow and use transition to previous state we can try to implement even more complicated operations. For this lets implement confirmation for our form. Previously we have added “Approve” and “Disapprove” buttons for final step. Handler for “Approve” button is very simple. @form_router.message(Form.confirm, F.text.casefold() == \"approve\")\n\nasync def process_confirm(message: Message, state: FSMContext) -> None:\n\n await state.clear()\n\n await message.answer(\n\n \"Thank you for your Form!\",\n\n reply_markup=ReplyKeyboardRemove(),\n\n ) We will not save any customers data in this example, so all we need — close state and send appropriate message. To implement “Disapprove” function lets add another state — “confirm_reject”, after it our StatesGroup looks like this: Handler for “Disapprove” button will set this state and send message with proposition to change any of inputed data. @form_router.message(Form.confirm_reject, F.text.casefold() != \"cancel\")\n\nasync def process_reject(message: Message, state: FSMContext) -> None:\n\n required_state_index = next(\n\n (\n\n i\n\n for i, obj in enumerate(STATES_LIST)\n\n if obj.state_corresponding_button == message.text\n\n ),\n\n None,\n\n )\n\n if required_state_index is None:\n\n await message.answer(\n\n \"I don't understand you. Please, choose one of the options.\",\n\n )\n\n else:\n\n required_state = STATES_LIST[required_state_index]\n\n await state.update_data(reject=True)\n\n await state.set_state(required_state.state_name)\n\n await message.answer(\n\n required_state.state_question,\n\n reply_markup=ReplyKeyboardMarkup(\n\n keyboard=required_state.keyboard_buttons,\n\n resize_keyboard=True,\n\n ),\n\n ) In this handler firstly we validate if user selected one of available buttons, for this we are trying to find state by state_corresponding_button value in STATES_LIST. After this we need to receive required_state information, make transition to this step and send proper message. But logically — after user will answer to this question we should send him to confirmation step again, for this we need to add “reject” value to states data and also update our states handlers to handle this value. Updated “first_name” state handler @form_router.message(Form.about.first_name)\n\nasync def process_first_name(message: Message, state: FSMContext) -> None:\n\n await state.update_data(first_name=message.text)\n\n data = await state.get_data()\n\n reject = data.get(\"reject\", False)\n\n if reject:\n\n await update_on_reject(message, state)\n\n else:\n\n await state.set_state(Form.about.last_name)\n\n await message.answer(\n\n \"What's your last name?\",\n\n reply_markup=ReplyKeyboardMarkup(\n\n keyboard=[\n\n [\n\n KeyboardButton(text=\"Skip\"),\n\n KeyboardButton(text=\"Go back\")\n\n ],\n\n [KeyboardButton(text=\"Cancel\")],\n\n ],\n\n resize_keyboard=True,\n\n ),\n\n ) As you can see we added only if else statement to handler reject, in case if reject is equal to True we are calling update_on_reject method: This method will make transition to confirmation state and send confirmation message again. On our state schema this operation is illustrated in two lines, firstly we perform transition from “Confirmation” to “First name” (with red arrow) and then back to “Confirmation” (with purple arrow). In Telegram flow it will looks like this:"
    },
    {
        "link": "https://github.com/aiogram/aiogram/blob/dev-3.x/examples/finite_state_machine.py",
        "document": "\"Hi there! What's your name?\" ,\n\nAllow user to cancel any action\n\nf\"Nice to meet you, ! Did you like to write bots?\" ,\n\n\"Not bad not terrible. See you soon.\" ,\n\n\"Cool! I'm too! What programming language did you use for it?\" ,\n\n\"Python, you say? That's the language that makes my circuits light up! 😉\"\n\nf\"I'll keep in mind that, , \"\n\nf\"you like to write bots with .\""
    },
    {
        "link": "https://aiogram-birdi7.readthedocs.io/en/latest/examples/finite_state_machine_example.html",
        "document": "# For example use simple MemoryStorage for Dispatcher. # Will be represented in storage as 'Form:name' # Will be represented in storage as 'Form:age' # Will be represented in storage as 'Form:gender' \"Hi there! What's your name?\" # You can use state '*' if you need to handle all states Allow user to cancel any action # Cancel state and inform user about it # And remove keyboard (just in case) How old are you? (digits only)\" In this example gender has to be one of: Male, Female, Other. \"Bad gender name. Choose you gender from keyboard.\""
    },
    {
        "link": "https://restack.io/p/state-machines-answer-aiogram-cat-ai",
        "document": "Explore the integration of state machines with Aiogram for efficient bot development and management.\n\nState management is crucial in AI applications, particularly when dealing with large language models (LLMs). Each request to the model requires context, which is encapsulated in the application's state. In traditional chatbots, this state is represented as an array of , where each message contains a unique identifier, the role of the sender, and the content of the message. For instance, a typical message structure looks like this: { \"id\": \"12345\", \"role\": \"user\", \"content\": \"Hello, how can I help you?\" } This state can be easily rendered in the UI and sent to the model without any modifications. However, with the advent of Generative UI, the model can return React components instead of plain text messages. While the client can render these components seamlessly, the challenge arises because React components are not serializable, making it impossible to send them back to the model directly. To address this issue, the state can be divided into two distinct parts: AI State and UI State. This separation allows for a more manageable and efficient way to handle state synchronization. Using a Lego analogy, consider a complex Lego model that is difficult to transport when fully assembled. By disassembling the model, it becomes easier to move, and the instructions serve as a guide for reassembly. In this scenario, AI State acts as a serializable representation (like the instructions) that can be easily passed to the model, while UI State represents the actual rendered components. AI State is the serializable format of your application's state, which is utilized on the server and can be shared with the language model. In a chat application, AI State encompasses the conversation history, including all messages exchanged between the user and the assistant. This state is crucial as it serves as the source of truth for the current application state. For example, AI State can be structured as follows: { \"messages\": [ {\"id\": \"1\", \"role\": \"user\", \"content\": \"What is AI?\"}, {\"id\": \"2\", \"role\": \"assistant\", \"content\": \"AI stands for Artificial Intelligence.\"} ], \"createdAt\": \"2023-10-01T12:00:00Z\", \"chatId\": \"chat_001\" } On the other hand, UI State represents the state of the application that is rendered on the client side. This state is fully client-side and can store various types of data, from JavaScript values to React elements. UI State essentially consists of the actual UI components that are displayed to the user. For instance, UI State might look like this: The RSC API provides a streamlined approach to manage and synchronize AI State and UI State. By ensuring that both states are kept in sync between the database, server, and client, developers can create a seamless user experience. This synchronization is vital for maintaining the integrity of the application, especially when dealing with dynamic content generated by the model. In summary, understanding the distinction between AI State and UI State is essential for effective state management in AI applications. By leveraging the RSC API, developers can ensure that their applications remain responsive and contextually aware, ultimately enhancing the user experience.\n• None Explore the fundamentals of finite state machines in AI, their applications, and how they enhance decision-making processes.\n• None Explore the implementation of state machine AI in Unity, enhancing game logic and character behavior through structured states.\n• None Explore the intricacies of state machine AI, its applications, and how it enhances decision-making processes in various systems. Build reliable and accurate AI agents in code, capable of running and persisting month-lasting processes in the background."
    }
]