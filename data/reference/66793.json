[
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/awt/image/BufferedImage.html",
        "document": ". Returns a of objects that are the immediate sources, not the sources of these immediate sources, of image data for this\n\nSets a rectangular region of the image to the contents of the specified , which is assumed to be in the same coordinate space as the ."
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/index.html?java/awt/image/BufferedImage.html",
        "document": "JavaScript is disabled on your browser.\n\nThis document is designed to be viewed using the frames feature. If you see this message, you are using a non-frame-capable web client. Link to Non-frame version."
    },
    {
        "link": "https://tutorialspoint.com/java_dip/java_buffered_image.htm",
        "document": "Java class is a subclass of Image class. It is used to handle and manipulate the image data. A is made of ColorModel of image data. All objects have an upper left corner coordinate of (0, 0).\n\nThis class supports three types of constructors.\n\nThe first constructor constructs a new with a specified ColorModel and Raster.\n\nThe second constructor constructs a of one of the predefined image types.\n\nThe third constructor constructs a of one of the predefined image types: TYPE_BYTE_BINARY or TYPE_BYTE_INDEXED.\n\nThe following example demonstrates the use of java class that draw some text on the screen using Graphics Object −\n\nWhen you execute the given code, the following output is seen −"
    },
    {
        "link": "https://stackoverflow.com/questions/30875461/read-in-bufferedimage-pixel-values-then-manipulate-each-one-and-write-to-file",
        "document": "I am currently trying to read in an image pixel by pixel and change each colored pixel to the rgb value of (100,100,100). For whatever reason when I check the values of each pixel one the image is saved it has all the colored pixels as (46,46,46) instead.\n\nHere is the original image\n\nAfter running my program this is the image it gives to me\n\nHere is the code\n\nI have no clue why it doesn't set the pixels to the expected rgb value. I eventually want to be able to basically increment the rgb color as I move down rows and columns in the x and y so what the final image will look like is it will start off dark in the top left corner and then have a fade out effect as you get from that side to the bottom right corner."
    },
    {
        "link": "https://stackoverflow.com/questions/24529600/how-to-go-about-creating-a-new-class-of-bufferedimage-with-a-file-as-argument",
        "document": "I want to create a new class ,because I want to make some new methods, which extends BufferedImage and takes a file ,a bmp picture, as an argument. Like what happens here:\n\nLooking through the documentation I found that the class BufferedImage has two constructors:\n\nGoing through the documentation of all the arguments I failed to notice which argument refers to a file ,if any. So how would I need to go about in creating a new BufferedImage class but with a file as one of the arguments?"
    },
    {
        "link": "https://stackoverflow.com/questions/596216/formula-to-determine-perceived-brightness-of-rgb-color",
        "document": "I'm looking for some kind of formula or algorithm to determine the brightness of a color given the RGB values. I know it can't be as simple as adding the RGB values together and having higher sums be brighter, but I'm kind of at a loss as to where to start.\n\nConsider this an addendum to Myndex's excellent answer. As he (and others) explain, the algorithms for calculating the relative luminance (and the perceptual lightness) of an RGB colour are designed to work with linear RGB values. You can't just apply them to raw sRGB values and hope to get the same results. Well that all sounds great in theory, but I really needed to see the evidence for myself, so, inspired by Petr Hurtak's colour gradients, I went ahead and made my own. They illustrate the two most common algorithms (ITU-R Recommendation BT.601 and BT.709), and clearly demonstrate why you should do your calculations with linear values (not gamma-corrected ones). Firstly, here are the results from the older ITU BT.601 algorithm. The one on the left uses raw sRGB values. The one on the right uses linear values. At this resolution, you can see that many neighbouring pixels on the left aren't even close to the same brightness—in the top half, there are bright red pixels next to very dark ones. At a higher resolution, unwanted patterns start to appear: The linear one doesn't suffer from these, but there's quite a lot of noise there. Let's compare it to ITU-R Recommendation BT.709… Oh boy. Clearly not intended to be used with raw sRGB values! And yet, that's exactly what most people do! At high-res, you can really see how effective this algorithm is when using linear values. It doesn't have nearly as much noise as the earlier one. While none of these algorithms are perfect, this one is about as good as it gets.\n\nI did a comparison of methods recommended here, and these are the results: 1- First of all, none of them do magic. However, if you've recently found how useless those averaging or (min + max) / 2 implementations are, you're in the right place. 2- For serious work, the best options are either Rec. 709 or sRGB. They are essentially the same but with different factors and thresholds optimized for TVs or office monitors. 3- If you need a metric to simply determine the brightness of a color, use my formula: It's fast, simple, and provides results very close to sRGB and Rec. 709. Comparison:\n\n I generated random RGB colors and calculated the luminance using different metrics. I plotted each color as a pixel in an image, with the horizontal position corresponding to its luminance value and the vertical position displaying multiple colors for the same luminance value. This also shows how each method distributes luminance for random samples. When colors are sorted by their saturation before plotting the diagrams: Note that all the diagrams above are plotted using the exact same colors. The only difference lies in how the colors are sorted before plotting. Rec. 601 wights (^2):\n\n \n\n This is called HSP. To use it, R, G, and B must first be scaled to the 0-1 range, and the result must then be rescaled back to the desired range. sRGB and Rec. 709:\n\n I used Jive Dadson's sRGB implementation, and for Rec. 709 only replaced values. If you see any problems, please let me know. My Formula:\n\n \n\n Well, I don't have lab equipments and didn't dive too deep into the math behind sRGB and Rec. 709 to see what happens when the gamma encoding/decoding is bypassed. All I got is a probably uncalibrated monitor and a pair of eyes suffering from mild red-green blindness! However, what I see back here is that all those float calculations in sRGB and Rec. 709 just shifts highly saturated colors in darker areas, from incorrect places to slightly better incorrect places. If that much error is acceptable for you, you might consider making it even simpler.\n\n My formula uses sRGB/Rec. 709 weights rounded to integers (0.2126/0.0722=2.9446 and 0.7152/0.0722=9.9058). This adds some more error but eliminates floating point operations and can be done in s. I actually wonder why nobody has mentioned it yet and allowed this to be mine! :D Here is the code to produce those diagrams: import matplotlib.pyplot as plt from PIL import Image import random import numpy as np from matplotlib.colors import rgb_to_hsv import math highresfactor = 1 ## I used 10, but it becomes very slow width = 120 * highresfactor height = 60 * highresfactor np.random.seed(43) colors = np.random.randint(0, 256, [round(width * height * 0.6), 3]) # colors = colors[ # np.argsort(rgb_to_hsv(colors / 255.0)[:, 1]) # ] # uncomment to order colors by saturation # colors = colors[ # np.argsort(1 - rgb_to_hsv(colors / 255.0)[:, 0]) # ] # uncomment to order colors by hue def generate_image(luminance_function): img = Image.new(\"RGB\", (width, height)) counts = [0] * width for i in range(colors.shape[0]): (r, g, b) = colors[i, :] lum = int(round(luminance_function(r, g, b) * (width - 1) / 255)) if counts[lum] > height - 1: continue y = counts[lum] img.putpixel((lum, height - y - 1), (int(r), int(g), int(b))) counts[lum] += 1 return img def average_luminance(r, g, b): return (r + g + b) / 3 def minmax_luminance(r, g, b): return (max([r, g, b]) + min([r, g, b])) / 2 def div6__luminance(r, g, b): return (r + r + g + g + g + b) / 6 def rightshift_luminance(r, g, b): if highresfactor > 2: return (r + r + r + g + g + g + g + b) / 8 return (r + r + r + g + g + g + g + b) >> 3 def rec601_luminance_no_lin(r, g, b): return 0.299 * r + 0.587 * g + 0.114 * b def rec601_luminance_2(r, g, b): return ( math.sqrt( 0.299 * (r / 255) ** 2 + 0.587 * (g / 255) ** 2 + 0.114 * (b / 255) ** 2 ) * 255 ) def rec709_luminance_no_lin(r, g, b): return 0.2126 * r + 0.7152 * g + 0.0722 * b def rec709_luminance_int(r, g, b): if highresfactor > 2: return (3 * r + 10 * g + b) / 14 return (3 * r + 10 * g + b) // 14 # Function to calculate sRGB luminance def sRGB_luminance(r, g, b): # Inverse of sRGB \"gamma\" function def inv_gam_sRGB(c): c = c / 255.0 return c / 12.92 if c <= 0.04045 else ((c + 0.055) / 1.055) ** 2.4 # sRGB \"gamma\" function def gam_sRGB(v): return ( v * 12.92 if v <= 0.0031308 else 1.055 * v ** (1.0 / 2.4) - 0.055 ) * 255 + 0.5 # GRAY VALUE (\"brightness\") def gray(r, g, b): return gam_sRGB( 0.212655 * inv_gam_sRGB(r) + 0.715158 * inv_gam_sRGB(g) + 0.072187 * inv_gam_sRGB(b) ) return gray(r, g, b) # Function to calculate Rec. 709 luminance def rec709_luminance(r, g, b): # Inverse of Rec. 709 \"gamma\" function def inv_gam_rec709(c): c = c / 255.0 return c / 4.5 if c < 0.018 else ((c + 0.099) / 1.099) ** 2.2 # Rec. 709 \"gamma\" function def gam_rec709(v): return (v * 4.5 if v < 0.018 else 1.099 * v ** (1.0 / 2.2) - 0.099) * 255 + 0.5 # GRAY VALUE (\"brightness\") def gray_rec709(r, g, b): return gam_rec709( 0.212655 * inv_gam_rec709(r) + 0.715158 * inv_gam_rec709(g) + 0.072187 * inv_gam_rec709(b) ) return gray_rec709(r, g, b) methods = [ (average_luminance, \"(R+G+B) / 3\"), # (minmax_luminance, \"(Min+Max) / 2\"), # comment another to see this (rightshift_luminance, \"(3R+4G+B) / 8 (or >> 3)\"), (div6__luminance, \"(2R+3G+B) / 6\"), (rec601_luminance_no_lin, \"Rec.601 weights\"), (rec601_luminance_2, \"Rec.601 weights (^2)\"), (sRGB_luminance, \"sRGB\"), (rec709_luminance_int, \"(3R+10G+B) // 14\"), (rec709_luminance_no_lin, \"sRGB / Rec. 709 weights\"), (rec709_luminance, \"Rec. 709\"), ] fig, axes = plt.subplots(3, 3, sharex=True, sharey=True) axes = axes.flatten() for i in range(len(methods)): im = generate_image(methods[i][0]) axes[i].imshow(im) axes[i].text( 0.975 * width, 0.033 * height, str(methods[i][1]), color=\"white\", va=\"top\", ha=\"right\", size=7, weight=\"bold\", bbox=dict(facecolor=\"black\", alpha=0.35), ) axes[i].set_xticks([0, width / 2, width - 1]) axes[i].set_xticklabels([0, 127, 255]) axes[i].set_yticks([]) plt.tight_layout() plt.show(block=True)"
    },
    {
        "link": "https://stackoverflow.com/questions/42177751/how-to-calculate-rgb-values-with-identical-perceived-brightness",
        "document": "THESE AREN'T THE MATHS YOU'RE LOOKING FOR\n\nNo this is incorrect, or at least incomplete. Yes, R*0.2126+ G*0.7152+ B*0.0722 are the spectral coefficients, but that is not the complete story.\n\nFirst, Don't use the term brightness in this context. Brightness is not a measure of light, it is a perception, not a measurable quantity. When we are talking about light and colorimetry, use the term \"luminance\" (L or Y). Luminance is a linear measure of light, not perception.\n\nPerceptual lightness, or L* (Lstar) from CIELAB, is based on human perception of changes in luminance. It is close to a power curve of about 0.43.\n\nsRGB, the colorspace typically used for computer monitors and the web, is not linear like light, and it is also not exactly like the perceptual L* curve. sRGB's transfer curve is close to a 1/2.2 power curve. That is, the sRGB data/signal is raised to the power of 0.455, and then the monitor applies a power of 2.2.\n\nYour math isn't working because you are not taking the transfer curves into account. You must linearize the sRGB values before applying the coefficients. Then the sum of these will equal a luminance of 1.\n\n#FFFF00 in sRGB equals 0.9278 in luminance, but this is an sRGB value of 96.76% or an L* value of 97.14%\n\n#0000FF in sRGB equals 0.0722 in luminance, but this is an sRGB value of 29.79% or an L* value of 32.3%\n\nHere's a chart of some values, expanding on your example:\n\nSo to answer the rest of your question, to get a blue that matches a higher luminance than the monitor is capable of requires desaturating it, adding R and G to increase the lightness.\n\nIn this chart, we have the fully saturated but darker red and green to match the 7% blue luminance, then we have 18% luminance (as in an 18% grey card), and here we have to desaturate the blue to bring the luminance value up.\n\nFirst, you need to linearize the sRGB components, and THEN apply the coefficients, if you need to determine luminance. If you come up with some values doing math on linearized components, then you need to re-gamma encode to get back to sRGB.\n\nI've discussed this is several other answers, such as this here."
    },
    {
        "link": "https://forums.oracle.com/ords/apexds/post/setting-the-saturation-and-brightness-of-an-rgb-color-0141",
        "document": "For appeals, questions and feedback about Oracle Forums, please email oracle-forums-moderators_us@oracle.com. Technical questions should be asked in the appropriate category. Thank you!\n\nInterested in getting your voice heard by members of the Developer Marketing team at Oracle? Check out this post for AppDev or this post for AI focus group information."
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/awt/Color.html",
        "document": "\n• Returns the red component in the range 0-255 in the default sRGB space.\n• Returns the green component in the range 0-255 in the default sRGB space.\n• Returns the blue component in the range 0-255 in the default sRGB space.\n• Returns the alpha component in the range 0-255.\n• Returns the RGB value representing the color in the default sRGB . (Bits 24-31 are alpha, 16-23 are red, 8-15 are green, 0-7 are blue). the RGB value of the color in the default sRGB .\n• that is a brighter version of this . Creates a newthat is a brighter version of this This method applies an arbitrary scale factor to each of the three RGB components of this to create a brighter version of this . The value is preserved. Although and are inverse operations, the results of a series of invocations of these two methods might be inconsistent because of rounding errors. a new object that is a brighter version of this with the same value.\n• that is a darker version of this . Creates a newthat is a darker version of this This method applies an arbitrary scale factor to each of the three RGB components of this to create a darker version of this . The value is preserved. Although and are inverse operations, the results of a series of invocations of these two methods might be inconsistent because of rounding errors. a new object that is a darker version of this with the same value.\n• Computes the hash code for this . a hash code value for this object.\n• . Determines whether another object is equal to this The result is if and only if the argument is not and is a object that has the same red, green, blue, and alpha values as this object. - the object to test for equality with this if the objects are the same; otherwise.\n• Returns a string representation of this . This method is intended to be used only for debugging purposes. The content and format of the returned string might vary between implementations. The returned string might be empty but cannot be .\n• Converts a to an integer and returns the specified opaque . This method handles string formats that are used to represent octal and hexadecimal numbers. - a that represents an opaque color as a 24-bit integer - if the specified string cannot be interpreted as a decimal, octal, or hexadecimal integer.\n• The argument is treated as the name of a system property to be obtained. The string value of this property is then interpreted as an integer which is then converted to a object. If the specified property is not found or could not be parsed as an integer then is returned. - the name of the color property the converted from the system property.\n• The first argument is treated as the name of a system property to be obtained. The string value of this property is then interpreted as an integer which is then converted to a object. If the specified property is not found or cannot be parsed as an integer then the specified by the second argument is returned instead. - the name of the color property the converted from the system property, or the specified .\n• The first argument is treated as the name of a system property to be obtained. The string value of this property is then interpreted as an integer which is then converted to a object. If the specified property is not found or could not be parsed as an integer then the integer value is used instead, and is converted to a object. - the name of the color property - the default color value, as an integer the converted from the system property or the converted from the specified integer.\n• Converts the components of a color, as specified by the HSB model, to an equivalent set of values for the default RGB model. The and components should be floating-point values between zero and one (numbers in the range 0.0-1.0). The component can be any floating-point number. The floor of this number is subtracted from it to create a fraction between 0 and 1. This fractional number is then multiplied by 360 to produce the hue angle in the HSB color model. The integer that is returned by encodes the value of a color in bits 0-23 of an integer value that is the same format used by the method . This integer can be supplied as an argument to the constructor that takes a single integer argument. - the hue component of the color - the saturation of the color - the brightness of the color the RGB value of the color with the indicated hue, saturation, and brightness.\n• Converts the components of a color, as specified by the default RGB model, to an equivalent set of values for hue, saturation, and brightness that are the three components of the HSB model. If the argument is , then a new array is allocated to return the result. Otherwise, the method returns the array , with the values put into that array. - the red component of the color - the green component of the color - the blue component of the color - the array used to return the three HSB values, or an array of three elements containing the hue, saturation, and brightness (in that order), of the color with the indicated red, green, and blue components.\n• object based on the specified values for the HSB color model. Creates aobject based on the specified values for the HSB color model. The and components should be floating-point values between zero and one (numbers in the range 0.0-1.0). The component can be any floating-point number. The floor of this number is subtracted from it to create a fraction between 0 and 1. This fractional number is then multiplied by 360 to produce the hue angle in the HSB color model. - the saturation of the color - the brightness of the color a object with the specified hue, saturation, and brightness.\n• Returns a array containing the color and alpha components of the , as represented in the default sRGB color space. If is , an array of length 4 is created for the return value. Otherwise, must have length 4 or greater, and it is filled in with the components and returned. - an array that this method fills with color and alpha components and returns\n• Returns a array containing only the color components of the , in the default sRGB color space. If is , an array of length 3 is created for the return value. Otherwise, must have length 3 or greater, and it is filled in with the components and returned. - an array that this method fills with color components and returns\n• Returns a array containing the color and alpha components of the , in the of the . If is , an array with length equal to the number of components in the associated plus one is created for the return value. Otherwise, must have at least this length and it is filled in with the components and returned. - an array that this method fills with the color and alpha components of this in its and returns the color and alpha components in a array.\n• Returns a array containing only the color components of the , in the of the . If is , an array with length equal to the number of components in the associated is created for the return value. Otherwise, must have at least this length and it is filled in with the components and returned. - an array that this method fills with the color components of this in its and returns\n• Returns a array containing the color and alpha components of the , in the specified by the parameter. If is , an array with length equal to the number of components in plus one is created for the return value. Otherwise, must have at least this length, and it is filled in with the components and returned. - an array that this method fills with the color and alpha components of this in the specified and returns the color and alpha components in a array.\n• Returns a array containing only the color components of the in the specified by the parameter. If is , an array with length equal to the number of components in is created for the return value. Otherwise, must have at least this length, and it is filled in with the components and returned. - an array that this method fills with the color components of this in the specified\n• Returns the of this .\n• Creates and returns a used to generate a solid color field pattern. See the of the method in the interface for information on null parameter handling. - the preferred which represents the most convenient format for the caller to receive the pixel data, or if there is no preference. - the device space bounding box of the graphics primitive being rendered. - the user space bounding box of the graphics primitive being rendered. - the from user space into device space. - the set of hints that the context object can use to choose between rendering alternatives.\n• Returns the transparency mode for this . This is required to implement the interface."
    },
    {
        "link": "https://computergraphics.stackexchange.com/questions/5085/light-intensity-of-an-rgb-value",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    }
]