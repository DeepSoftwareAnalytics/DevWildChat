[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Memory_management",
        "document": "Regardless of the programming language, the memory life cycle is pretty much always the same:\n• Allocate the memory you need\n• Release the allocated memory when it is not needed anymore The second part is explicit in all languages. The first and last parts are explicit in low-level languages but are mostly implicit in high-level languages like JavaScript.\n\nRelease when the memory is not needed anymore The majority of memory management issues occur at this phase. The most difficult aspect of this stage is determining when the allocated memory is no longer needed. Low-level languages require the developer to manually determine at which point in the program the allocated memory is no longer needed and to release it. Some high-level languages, such as JavaScript, utilize a form of automatic memory management known as garbage collection (GC). The purpose of a garbage collector is to monitor memory allocation and determine when a block of allocated memory is no longer needed and reclaim it. This automatic process is an approximation since the general problem of determining whether or not a specific piece of memory is still needed is undecidable.\n\nNote: No modern JavaScript engine uses reference-counting for garbage collection anymore. This is the most naïve garbage collection algorithm. This algorithm reduces the problem from determining whether or not an object is still needed to determining if an object still has any other objects referencing it. An object is said to be \"garbage\", or collectible if there are zero references pointing to it. let x = { a: { b: 2, }, }; // 2 objects are created. One is referenced by the other as one of its properties. // The other is referenced by virtue of being assigned to the 'x' variable. // Obviously, none can be garbage-collected. let y = x; // The 'y' variable is the second thing that has a reference to the object. x = 1; // Now, the object that was originally in 'x' has a unique reference // embodied by the 'y' variable. let z = y.a; // Reference to 'a' property of the object. // This object now has 2 references: one as a property, // the other as the 'z' variable. y = \"mozilla\"; // The object that was originally in 'x' has now zero // references to it. It can be garbage-collected. // However its 'a' property is still referenced by // the 'z' variable, so it cannot be freed. z = null; // The 'a' property of the object originally in x // has zero references to it. It can be garbage collected. There is a limitation when it comes to circular references. In the following example, two objects are created with properties that reference one another, thus creating a cycle. They will go out of scope after the function call has completed. At that point they become unneeded and their allocated memory should be reclaimed. However, the reference-counting algorithm will not consider them reclaimable since each of the two objects has at least one reference pointing to them, resulting in neither of them being marked for garbage collection. Circular references are a common cause of memory leaks.\n\nThis algorithm reduces the definition of \"an object is no longer needed\" to \"an object is unreachable\". This algorithm assumes the knowledge of a set of objects called roots. In JavaScript, the root is the global object. Periodically, the garbage collector will start from these roots, find all objects that are referenced from these roots, then all objects referenced from these, etc. Starting from the roots, the garbage collector will thus find all reachable objects and collect all non-reachable objects. This algorithm is an improvement over the previous one since an object having zero references is effectively unreachable. The opposite does not hold true as we have seen with circular references. Currently, all modern engines ship a mark-and-sweep garbage collector. All improvements made in the field of JavaScript garbage collection (generational/incremental/concurrent/parallel garbage collection) over the last few years are implementation improvements of this algorithm, but not improvements over the garbage collection algorithm itself nor its reduction of the definition of when \"an object is no longer needed\". The immediate benefit of this approach is that cycles are no longer a problem. In the first example above, after the function call returns, the two objects are no longer referenced by any resource that is reachable from the global object. Consequently, they will be found unreachable by the garbage collector and have their allocated memory reclaimed. However, the inability to manually control garbage collection remains. There are times when it would be convenient to manually decide when and what memory is released. In order to release the memory of an object, it needs to be made explicitly unreachable. It is also not possible to programmatically trigger garbage collection in JavaScript — and will likely never be within the core language, although engines may expose APIs behind opt-in flags.\n\nand are data structures whose APIs closely mirror their non-weak counterparts: and . allows you to maintain a collection of key-value pairs, while allows you to maintain a collection of unique values, both with performant addition, deletion, and querying. and got the name from the concept of weakly held values. If is weakly held by , it means that although you can access the value of via , the mark-and-sweep algorithm won't consider as reachable if nothing else strongly holds to it. Most data structures, except the ones discussed here, strongly holds to the objects passed in so that you can retrieve them at any time. The keys of and can be garbage-collected (for objects, the values would then be eligible for garbage collection as well) as long as nothing else in the program is referencing the key. This is ensured by two characteristics:\n• and can only store objects or symbols. This is because only objects are garbage collected — primitive values can always be forged (that is, but ), making them stay in the collection forever. Registered symbols (like ) can also be forged and thus not garbage collectable, but symbols created with are garbage collectable. Well-known symbols like come in a fixed set and are unique throughout the lifetime of the program, similar to intrinsic objects such as , so they are also allowed as keys.\n• and are not iterable. This prevents you from using to observe the liveliness of objects, or get hold of an arbitrary key which should otherwise be eligible for garbage collection. (Garbage collection should be as invisible as possible.) In typical explanations of and (such as the one above), it's often implied that the key is garbage-collected first, freeing the value for garbage collection as well. However, consider the case of the value referencing the key: const wm = new WeakMap(); const key = {}; wm.set(key, { key }); // Now `key` cannot be garbage collected, // because the value holds a reference to the key, // and the value is strongly held in the map! If is stored as an actual reference, it would create a cyclic reference and make both the key and value ineligible for garbage collection, even when nothing else references — because if is garbage collected, it means that at some particular instant, would point to a non-existent address, which is not legal. To fix this, the entries of and aren't actual references, but ephemerons, an enhancement to the mark-and-sweep mechanism. Barros et al. offers a good summary of the algorithm (page 4). To quote a paragraph: Ephemerons are a refinement of weak pairs where neither the key nor the value can be classified as weak or strong. The connectivity of the key determines the connectivity of the value, but the connectivity of the value does not affect the connectivity of the key. […] when the garbage collection offers support to ephemerons, it occurs in three phases instead of two (mark and sweep). As a rough mental model, think of a as the following implementation: Warning: This is not a polyfill nor is anywhere close to how it's implemented in the engine (which hooks into the garbage collection mechanism). class MyWeakMap { #marker = Symbol(\"MyWeakMapData\"); get(key) { return key[this.#marker]; } set(key, value) { key[this.#marker] = value; } has(key) { return this.#marker in key; } delete(key) { delete key[this.#marker]; } } As you can see, the never actually holds a collection of keys. It simply adds metadata to each object being passed in. The object is then garbage-collectable via mark-and-sweep. Therefore, it's not possible to iterate over the keys in a , nor clear the (as that also relies on the knowledge of the entire key collection). For more information on their APIs, see the keyed collections guide.\n\nNote: and offer direct introspection into the garbage collection machinery. Avoid using them where possible because the runtime semantics are almost completely unguaranteed. All variables with an object as value are references to that object. However, such references are strong — their existence would prevent the garbage collector from marking the object as eligible for collection. A is a weak reference to an object that allows the object to be garbage collected, while still retaining the ability to read the object's content during its lifetime. One use case for is a cache system which maps string URLs to large objects. We cannot use a for this purpose, because objects have their keys weakly held, but not their values — if you access a key, you would always deterministically get the value (since having access to the key means it's still alive). Here, we are okay to get for a key (if the corresponding value is no longer alive) since we can just re-compute it, but we don't want unreachable objects to stay in the cache. In this case, we can use a normal , but with each value being a of the object instead of the actual object value. function cached(getter) { // A Map from string URLs to WeakRefs of results const cache = new Map(); return async (key) => { if (cache.has(key)) { const dereferencedValue = cache.get(key).deref(); if (dereferencedValue !== undefined) { return dereferencedValue; } } const value = await getter(key); cache.set(key, new WeakRef(value)); return value; }; } const getImage = cached((url) => fetch(url).then((res) => res.blob())); provides an even stronger mechanism to observe garbage collection. It allows you to register objects and be notified when they are garbage collected. For example, for the cache system exemplified above, even when the blobs themselves are free for collection, the objects that hold them are not — and over time, the may accumulate a lot of useless entries. Using a allows one to perform cleanup in this case. function cached(getter) { // A Map from string URLs to WeakRefs of results const cache = new Map(); // Every time after a value is garbage collected, the callback is // called with the key in the cache as argument, allowing us to remove // the cache entry const registry = new FinalizationRegistry((key) => { // Note: it's important to test that the WeakRef is indeed empty. // Otherwise, the callback may be called after a new object has been // added with this key, and that new, alive object gets deleted if (!cache.get(key)?.deref()) { cache.delete(key); } }); return async (key) => { if (cache.has(key)) { return cache.get(key).deref(); } const value = await getter(key); cache.set(key, new WeakRef(value)); registry.register(value, key); return value; }; } const getImage = cached((url) => fetch(url).then((res) => res.blob())); Due to performance and security concerns, there is no guarantee of when the callback will be called, or if it will be called at all. It should only be used for cleanup — and non-critical cleanup. There are other ways for more deterministic resource management, such as , which will always execute the block. and exist solely for optimization of memory usage in long-running programs. For more information on the API of and , see their reference pages."
    },
    {
        "link": "https://medium.com/@stheodorejohn/circular-references-in-javascript-1a798940e7eb",
        "document": "Discover the impact of circular dependencies and how to break free\n\nIn this comprehensive guide, we will delve into the concept of circular references in JavaScript, why they matter, where they arise, and provide a thorough understanding of how to avoid and manage them. We’ll accompany our explanations with practical code examples and insightful discussions, ensuring that you gain a strong grasp of this essential topic.\n\nA circular reference, also known as a circular dependency, occurs when two or more objects reference each other in a way that creates an endless loop. This can happen when one object’s property refers back to the original object or to another object that ultimately references the original object. Circular references can lead to memory leaks, unexpected behavior, and can be challenging to identify and resolve."
    },
    {
        "link": "https://stackoverflow.com/questions/7347203/circular-references-in-javascript-garbage-collector",
        "document": "Cycles are only a problem if you do naive reference counting.\n\nMost garbage collectors don't do ref-counting (both because it can't handle cycles, and because it's inefficient). Instead, they simply follow every reference they can find, starting from \"roots\" (typically globals and stack-based variables), and mark everything they can find as \"reachable\".\n\nThen they simply reclaim all other memory.\n\nCycles are no problem because they just mean that the same node will be reached multiple times. After the first time, the node will be marked as \"reachable\" already, and so the GC will know that it's been there already, and skip the node.\n\nEven more primitive GC's based on reference-counting typically implement algorithms to detect and break cycles.\n\nIn short, it's not something you have to worry about. I seem to recall that IE6's Javascript GC actually failed to handle cycles (I could be wrong, it's been a while since I read it, and it's been much, much longer since I touched IE6), but in any modern implementation, it is no problem.\n\nThe entire point in a garbage collector is to abstract away memory management. If you have to do this work yourself, your GC is broken.\n\nSee MDN for more information on modern garbage collection and the mark-and-sweep algorithms that are used."
    },
    {
        "link": "https://dzone.com/articles/resolving-circular-reference-related-memory-leaks",
        "document": "JavaScript is a dynamic, garbage collection programming language. It allocates memory for objects when they are first created and releases that memory after any references to them are destroyed. This is one of the biggest factors that differentiates JavaScript from C++ and other C-based programming languages. It is also one of the main reasons JavaScript is widely used for recurring web-based applications, such as online stores and e-commerce platforms like Shopify.\n\nUnfortunately, memory isn't always properly reallocated. If object references are improperly terminated, memory leaks can develop. Over time, they can consume too much memory for the application to continue to run seamlessly.\n\nJavaScript developers must understand the root cause of memory leaks and take reasonable measures to deal with them. Circular references are one of the main causes of memory leaks, especially in older browsers.\n\nBe wary with circular references for Internet Explorer and Firefox users.\n\nIn JavaScript, browsers record references to every object. If all references to an object are broken, the object is destroyed and memory is reallocated back to the heap.\n\nUnfortunately, the memory isn’t always returned to the heap if references with other objects are formed. Microsoft provides a brief overview of the issues that arise if references to DOM aren’t broken.\n\nIn other words, a circular reference occurs if two separate objects pass references to each other. Google Chrome does not count circular references, so objects are usually destroyed when the object is no longer needed. However, Internet Explorer and Firefox use circular references as part of their reference count.\n\nAs a result, objects may continue to exist and consume memory long after they are needed. Newer versions of these browsers are better at discounting circular references, but issues still occur. Developers need to take additional steps to prevent memory leaks.\n\nBefore JavaScript developers can resolve memory leaks, they must obviously identify them. They must monitor their code carefully for references between unrelated objects. IBM provides an example in one of their tutorials on the topic:\n\n\n\nFortunately, there are some solutions to circular reference related memory leaks. The most straightforward approach is to assign the null value to the elem property. This breaks the circular link and keeps the handler from referencing the DOM any longer. Without a reference to DOM, the browser is instructed to stop reserving memory for the object.\n\nIlya Kantor of JavaScript Tutorial states that the following application can be resolved by creating and calling the following function:\n\nYou can add bigString = null to your code when you want to terminate the object.\n\nWhile new browsers are more adept at resolving memory leaks caused by circular references, problems often arise with older browsers. These types of memory leaks can still occur with newer versions of Internet Explorer and Firefox as well, so it’s important to monitor code carefully to identify circular references."
    },
    {
        "link": "https://researchgate.net/publication/283051807_On_Memory_Management_in_JavaScript_Applications",
        "document": "referenced by a field in some other (directly or indirectly)\n\naccessible object. Any accessible obj ect is considered to be\n\nlive. Any other objects are garbage.\n\nThe mark-and-sweep algorithm consists of two phases. In\n\nthe first phase (mark), it finds and marks all ac cessible\n\nobjects. During the second phase (sweep), the algorithm\n\nwalks through the list o f obj ects a nd recla ims all the dead\n\nproceed cycled references. Also, we do not need to introduce\n\nadditional fields (like reference counter) for our data. T he\n\nmain disadvantage of the mark-and-sw eep approach is the\n\nfact that that normal program execution is suspended while\n\nthe g arbage collection algorithm runs. It is so-called stop-\n\nThe copying garbage collector (sometimes is called stop-\n\nand-copy and semi-space collector) starts from a set of roots\n\nand traverse all of the reachable m emory-allocated objects,\n\ncopying them from one-half of memory into the other half.\n\nThe area of memory that we copy from is called old space\n\nand the area of memory that we copy to is called new space.\n\nWhen we copy the reachable data, we compact it so that it is\n\nin a c ontiguous chunk. This procedure lets us avoid memory\n\nThe mark- compact GC is some combination of copying\n\nand mark-and-sweep [17]. In the first phase (mark), it finds\n\nand marks all live objects. In the second phase (com pact),\n\nthe garbage collection algorithm compresses the heap by\n\nmoving all the live objects into contiguous memory\n\nThe generational garbage collector is b ased on the idea of\n\npartitioning of live obj ects. This partitioning pro cedure is\n\nbased on tim e of m emory allocation. We assume that most\n\nobjects are discarded shortly after being used. So, w e can\n\ndeploy different GC policies to different p artitions. T he\n\nnot co mprehensive - they don't successfu lly remove all the\n\ngarbage (long-lived garbage, in particular, may never g et\n\nAll the garbage collector s in JavaScrip t engines we know\n\nJavaScriptCore uses Generational Collecto r. As per their\n\nmanual: “The garbage collector in JavaScriptCore has been\n\nimproved quite a bit from the earliest versions. But much\n\nthat uses a generational algorithm, so we don't have to mark\n\nall the objects every time we garbage collect. T his should\n\nSo, all the above mentioned JS engines use generational\n\ncollectors. The differences are lying in two areas:\n\n- How to present the objects\n\nInteresting, that all the above-mentioned implementations\n\nare stop-the-world. A sub-collector (an algorithm for\n\ngarbage c ollecting within the generation) is still mark-and-\n\nsweep. Of course, there are many improvements for the\n\nclassical mark-and-sweep. W e can m ention, for example, a\n\nby dividing the heap in several regions and compacts ob jects\n\nto one end of the r egions, and can thus reduce memory\n\nmanner, marks objects and then evacuates them from current\n\nregions to new ones so that current regions can be r eclaimed\n\nas a whole [24]. It is a garbage collector in Oracle JDK\n\nand thus achieves a time c omplexity proportional to the size\n\nof the live data set. How ever, this co mes with an overhead\n\ncost of maintaining a set of free memory intervals. The\n\nnumber of free intervals is much smaller than the number of\n\nlive objects because some live objects reside adjacent to\n\neach other. It seems beneficial, in certain situations, to avoid\n\nthe sweep phase at the cost of this overhead, which depends\n\non the distribution of live obj ects and also highly on the data\n\nstructure selected to store the free intervals. The data\n\nstructure should preferably provide search for an interval at\n\nBy our opinion, th ere are at least two most interesting\n\nquestions. At the first hand, it is not clear at this moment,\n\nwhy JavaScript engines do not use non-stop-the-world\n\ngarbage collectors. There are concurrent a nd para llel\n\nimplementations for mark-and-sweep, for example. They\n\nhave been tested w ith Java, for exam ple [27]. But we have\n\nnot seen yet such implementations in co nnection with\n\nJavaScript. As seems to us, such a movement would be in\n\nline with the common trend to add co ncurrency into\n\nThe seco nd interesting moment is the policy for runnin g\n\nthe garbage collector. Actually, it should be more complex\n\nthan a simply timer-based event or percentage of free\n\nmemory. It is e specially true for the mobile web with\n\nrelatively limited resources on mobile phones. Just think\n\nabout the stop-the-world action in the middle of filling some\n\nform on the screen. In th e sam e tim e, a quick stop action\n\ncould be almost “invisible” during the AJAX request, when\n\na user is waiting for the response any way. In other words,\n\nthe p olicy for running garbage collector should be based on\n\nthe behavior and depends on the application.\n\nAs per GC benchmarks, they are really light. The code"
    },
    {
        "link": "https://mdjamilkashemporosh.medium.com/best-practices-for-avoiding-memory-leaks-in-javascript-1fb24827914b",
        "document": "Memory leaks in JavaScript can be a common problem that can cause your application to slow down or even crash. In this blog post, I will discuss some of the best practices for avoiding memory leaks in JavaScript. I will cover topics such as how to identify memory leaks, how to prevent them from happening in the first place, and how to fix them when they do occur.\n\nAs much as possible, don’t use the global scope. Make the best use of the local scope inside the functions, as that will be garbage collected and will keep memory free.\n\nTry to define only constants, cache, and reusable variables in global. Do not use global space as a medium to pass values from one function to other, use function parameters instead.\n\nTo free up memory, you should use the built-in garbage collector.\n\nTo avoid circular references, You can use a technique called “manual memory management” by using JavaScript’s delete keyword to remove the properties that are creating the circular reference.\n\n04. Use the and keywords\n\nUse and keywords instead of to declare variables. and are block-scoped, which means they are only available within the block they are defined in.\n\nWhen you add an event listener to an element, it creates a reference to that element in memory. If you don’t remove the event listener when you’re done with it, it can cause a memory leak.\n\nand can cause memory leaks if you're not careful. Make sure to clear the timeout or interval when you're done with it.\n\nCircular references occur when two or more objects reference each other. To avoid circular references, make sure to remove references to objects when you’re done with them.\n\nUse the keyword to remove properties from objects when you're done with them.\n\n09. Use the and objects\n\nUse the and objects to store weak references to objects. Weak references are not counted by the garbage collector, so they won't prevent an object from being garbage collected.\n\nYou can use heap snapshots and profilers to identify memory leaks in your JavaScript code. Navigate to Chrome DevTools → Memory → Heap Snapshot → Take Snapshot. You can find detached DOM nodes by filtering Detached in the summary section.\n\nRemove unused code from your application to reduce the memory footprint.\n\nHello, I am interested in connecting with you as I believe we share similar interests in software engineering. Let’s connect on LinkedIn."
    },
    {
        "link": "https://stackoverflow.com/questions/7347203/circular-references-in-javascript-garbage-collector",
        "document": "Cycles are only a problem if you do naive reference counting.\n\nMost garbage collectors don't do ref-counting (both because it can't handle cycles, and because it's inefficient). Instead, they simply follow every reference they can find, starting from \"roots\" (typically globals and stack-based variables), and mark everything they can find as \"reachable\".\n\nThen they simply reclaim all other memory.\n\nCycles are no problem because they just mean that the same node will be reached multiple times. After the first time, the node will be marked as \"reachable\" already, and so the GC will know that it's been there already, and skip the node.\n\nEven more primitive GC's based on reference-counting typically implement algorithms to detect and break cycles.\n\nIn short, it's not something you have to worry about. I seem to recall that IE6's Javascript GC actually failed to handle cycles (I could be wrong, it's been a while since I read it, and it's been much, much longer since I touched IE6), but in any modern implementation, it is no problem.\n\nThe entire point in a garbage collector is to abstract away memory management. If you have to do this work yourself, your GC is broken.\n\nSee MDN for more information on modern garbage collection and the mark-and-sweep algorithms that are used."
    },
    {
        "link": "https://stackoverflow.com/questions/1999840/javascript-circular-references-and-memory-leaks",
        "document": "To add to bobince answer, I did some tests with IE8.\n\nI tried almost all examples provided at http://www.javascriptkit.com/javatutors/closuresleak/index.shtml\n\nNo one of them is leaking memory anymore (at least not in a perceivable way), except the example that removes child nodes with events still attached to them.\n\nThis type of example I think it's better explained by Douglas Crockford in his queuetest2.\n\nThis one still leaks memory on IE8 and it's pretty easy to test by simply running the test script and looking at Windows Task Manager - Performance - PF Usage. You will see PF Usage increases by almost 1MB per loop (very fast).\n\nBut in IE8 the memory is released on page unload (like navigating to a new page or reloading the same page) and obviously also when totally closing the browser.\n\nSo in order for a final user to perceive this memory leaks on IE8 (as reduced systerm performances), he needs to stay on the same page for a long time, which in now days it can frequently happen with AJAX, but this page need also to do hundreds of childnodes removal of elements with event attached to them.\n\nDouglas Crockford test is stressing the browser with 10000 nodes added and then removed, that's excellent for showing you the issue, but in real life I never had a page that removed more than 10 elements. INMHO usually it's faster to use rather than removing an entire set of nodes, that's why I don't use that much.\n\nFor whoever might be more interested in the IE8 memory leak explained above, I did another test and it seems mem leaks do not show up at all in IE8 when using in place of to add/remove child elements with attached events. So apparently Douglas Crockford purge function (suggested by him to prevent memory leaks in IE) is not necessary anymore in IE8 at least when using ...\n\n(EDITED thanks to 4esn0k comment below) ...moreover Douglas Crockford purge function does NOT work at all on IE8, in his code returns NO attributes (or any other attributes) that were added at runtime on IE8 (they do are returned on IE7).\n\nI provide here the code for the test:"
    },
    {
        "link": "https://dzone.com/articles/resolving-circular-reference-related-memory-leaks",
        "document": "JavaScript is a dynamic, garbage collection programming language. It allocates memory for objects when they are first created and releases that memory after any references to them are destroyed. This is one of the biggest factors that differentiates JavaScript from C++ and other C-based programming languages. It is also one of the main reasons JavaScript is widely used for recurring web-based applications, such as online stores and e-commerce platforms like Shopify.\n\nUnfortunately, memory isn't always properly reallocated. If object references are improperly terminated, memory leaks can develop. Over time, they can consume too much memory for the application to continue to run seamlessly.\n\nJavaScript developers must understand the root cause of memory leaks and take reasonable measures to deal with them. Circular references are one of the main causes of memory leaks, especially in older browsers.\n\nBe wary with circular references for Internet Explorer and Firefox users.\n\nIn JavaScript, browsers record references to every object. If all references to an object are broken, the object is destroyed and memory is reallocated back to the heap.\n\nUnfortunately, the memory isn’t always returned to the heap if references with other objects are formed. Microsoft provides a brief overview of the issues that arise if references to DOM aren’t broken.\n\nIn other words, a circular reference occurs if two separate objects pass references to each other. Google Chrome does not count circular references, so objects are usually destroyed when the object is no longer needed. However, Internet Explorer and Firefox use circular references as part of their reference count.\n\nAs a result, objects may continue to exist and consume memory long after they are needed. Newer versions of these browsers are better at discounting circular references, but issues still occur. Developers need to take additional steps to prevent memory leaks.\n\nBefore JavaScript developers can resolve memory leaks, they must obviously identify them. They must monitor their code carefully for references between unrelated objects. IBM provides an example in one of their tutorials on the topic:\n\n\n\nFortunately, there are some solutions to circular reference related memory leaks. The most straightforward approach is to assign the null value to the elem property. This breaks the circular link and keeps the handler from referencing the DOM any longer. Without a reference to DOM, the browser is instructed to stop reserving memory for the object.\n\nIlya Kantor of JavaScript Tutorial states that the following application can be resolved by creating and calling the following function:\n\nYou can add bigString = null to your code when you want to terminate the object.\n\nWhile new browsers are more adept at resolving memory leaks caused by circular references, problems often arise with older browsers. These types of memory leaks can still occur with newer versions of Internet Explorer and Firefox as well, so it’s important to monitor code carefully to identify circular references."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Memory_management",
        "document": "Regardless of the programming language, the memory life cycle is pretty much always the same:\n• Allocate the memory you need\n• Release the allocated memory when it is not needed anymore The second part is explicit in all languages. The first and last parts are explicit in low-level languages but are mostly implicit in high-level languages like JavaScript.\n\nRelease when the memory is not needed anymore The majority of memory management issues occur at this phase. The most difficult aspect of this stage is determining when the allocated memory is no longer needed. Low-level languages require the developer to manually determine at which point in the program the allocated memory is no longer needed and to release it. Some high-level languages, such as JavaScript, utilize a form of automatic memory management known as garbage collection (GC). The purpose of a garbage collector is to monitor memory allocation and determine when a block of allocated memory is no longer needed and reclaim it. This automatic process is an approximation since the general problem of determining whether or not a specific piece of memory is still needed is undecidable.\n\nNote: No modern JavaScript engine uses reference-counting for garbage collection anymore. This is the most naïve garbage collection algorithm. This algorithm reduces the problem from determining whether or not an object is still needed to determining if an object still has any other objects referencing it. An object is said to be \"garbage\", or collectible if there are zero references pointing to it. let x = { a: { b: 2, }, }; // 2 objects are created. One is referenced by the other as one of its properties. // The other is referenced by virtue of being assigned to the 'x' variable. // Obviously, none can be garbage-collected. let y = x; // The 'y' variable is the second thing that has a reference to the object. x = 1; // Now, the object that was originally in 'x' has a unique reference // embodied by the 'y' variable. let z = y.a; // Reference to 'a' property of the object. // This object now has 2 references: one as a property, // the other as the 'z' variable. y = \"mozilla\"; // The object that was originally in 'x' has now zero // references to it. It can be garbage-collected. // However its 'a' property is still referenced by // the 'z' variable, so it cannot be freed. z = null; // The 'a' property of the object originally in x // has zero references to it. It can be garbage collected. There is a limitation when it comes to circular references. In the following example, two objects are created with properties that reference one another, thus creating a cycle. They will go out of scope after the function call has completed. At that point they become unneeded and their allocated memory should be reclaimed. However, the reference-counting algorithm will not consider them reclaimable since each of the two objects has at least one reference pointing to them, resulting in neither of them being marked for garbage collection. Circular references are a common cause of memory leaks.\n\nThis algorithm reduces the definition of \"an object is no longer needed\" to \"an object is unreachable\". This algorithm assumes the knowledge of a set of objects called roots. In JavaScript, the root is the global object. Periodically, the garbage collector will start from these roots, find all objects that are referenced from these roots, then all objects referenced from these, etc. Starting from the roots, the garbage collector will thus find all reachable objects and collect all non-reachable objects. This algorithm is an improvement over the previous one since an object having zero references is effectively unreachable. The opposite does not hold true as we have seen with circular references. Currently, all modern engines ship a mark-and-sweep garbage collector. All improvements made in the field of JavaScript garbage collection (generational/incremental/concurrent/parallel garbage collection) over the last few years are implementation improvements of this algorithm, but not improvements over the garbage collection algorithm itself nor its reduction of the definition of when \"an object is no longer needed\". The immediate benefit of this approach is that cycles are no longer a problem. In the first example above, after the function call returns, the two objects are no longer referenced by any resource that is reachable from the global object. Consequently, they will be found unreachable by the garbage collector and have their allocated memory reclaimed. However, the inability to manually control garbage collection remains. There are times when it would be convenient to manually decide when and what memory is released. In order to release the memory of an object, it needs to be made explicitly unreachable. It is also not possible to programmatically trigger garbage collection in JavaScript — and will likely never be within the core language, although engines may expose APIs behind opt-in flags.\n\nand are data structures whose APIs closely mirror their non-weak counterparts: and . allows you to maintain a collection of key-value pairs, while allows you to maintain a collection of unique values, both with performant addition, deletion, and querying. and got the name from the concept of weakly held values. If is weakly held by , it means that although you can access the value of via , the mark-and-sweep algorithm won't consider as reachable if nothing else strongly holds to it. Most data structures, except the ones discussed here, strongly holds to the objects passed in so that you can retrieve them at any time. The keys of and can be garbage-collected (for objects, the values would then be eligible for garbage collection as well) as long as nothing else in the program is referencing the key. This is ensured by two characteristics:\n• and can only store objects or symbols. This is because only objects are garbage collected — primitive values can always be forged (that is, but ), making them stay in the collection forever. Registered symbols (like ) can also be forged and thus not garbage collectable, but symbols created with are garbage collectable. Well-known symbols like come in a fixed set and are unique throughout the lifetime of the program, similar to intrinsic objects such as , so they are also allowed as keys.\n• and are not iterable. This prevents you from using to observe the liveliness of objects, or get hold of an arbitrary key which should otherwise be eligible for garbage collection. (Garbage collection should be as invisible as possible.) In typical explanations of and (such as the one above), it's often implied that the key is garbage-collected first, freeing the value for garbage collection as well. However, consider the case of the value referencing the key: const wm = new WeakMap(); const key = {}; wm.set(key, { key }); // Now `key` cannot be garbage collected, // because the value holds a reference to the key, // and the value is strongly held in the map! If is stored as an actual reference, it would create a cyclic reference and make both the key and value ineligible for garbage collection, even when nothing else references — because if is garbage collected, it means that at some particular instant, would point to a non-existent address, which is not legal. To fix this, the entries of and aren't actual references, but ephemerons, an enhancement to the mark-and-sweep mechanism. Barros et al. offers a good summary of the algorithm (page 4). To quote a paragraph: Ephemerons are a refinement of weak pairs where neither the key nor the value can be classified as weak or strong. The connectivity of the key determines the connectivity of the value, but the connectivity of the value does not affect the connectivity of the key. […] when the garbage collection offers support to ephemerons, it occurs in three phases instead of two (mark and sweep). As a rough mental model, think of a as the following implementation: Warning: This is not a polyfill nor is anywhere close to how it's implemented in the engine (which hooks into the garbage collection mechanism). class MyWeakMap { #marker = Symbol(\"MyWeakMapData\"); get(key) { return key[this.#marker]; } set(key, value) { key[this.#marker] = value; } has(key) { return this.#marker in key; } delete(key) { delete key[this.#marker]; } } As you can see, the never actually holds a collection of keys. It simply adds metadata to each object being passed in. The object is then garbage-collectable via mark-and-sweep. Therefore, it's not possible to iterate over the keys in a , nor clear the (as that also relies on the knowledge of the entire key collection). For more information on their APIs, see the keyed collections guide.\n\nNote: and offer direct introspection into the garbage collection machinery. Avoid using them where possible because the runtime semantics are almost completely unguaranteed. All variables with an object as value are references to that object. However, such references are strong — their existence would prevent the garbage collector from marking the object as eligible for collection. A is a weak reference to an object that allows the object to be garbage collected, while still retaining the ability to read the object's content during its lifetime. One use case for is a cache system which maps string URLs to large objects. We cannot use a for this purpose, because objects have their keys weakly held, but not their values — if you access a key, you would always deterministically get the value (since having access to the key means it's still alive). Here, we are okay to get for a key (if the corresponding value is no longer alive) since we can just re-compute it, but we don't want unreachable objects to stay in the cache. In this case, we can use a normal , but with each value being a of the object instead of the actual object value. function cached(getter) { // A Map from string URLs to WeakRefs of results const cache = new Map(); return async (key) => { if (cache.has(key)) { const dereferencedValue = cache.get(key).deref(); if (dereferencedValue !== undefined) { return dereferencedValue; } } const value = await getter(key); cache.set(key, new WeakRef(value)); return value; }; } const getImage = cached((url) => fetch(url).then((res) => res.blob())); provides an even stronger mechanism to observe garbage collection. It allows you to register objects and be notified when they are garbage collected. For example, for the cache system exemplified above, even when the blobs themselves are free for collection, the objects that hold them are not — and over time, the may accumulate a lot of useless entries. Using a allows one to perform cleanup in this case. function cached(getter) { // A Map from string URLs to WeakRefs of results const cache = new Map(); // Every time after a value is garbage collected, the callback is // called with the key in the cache as argument, allowing us to remove // the cache entry const registry = new FinalizationRegistry((key) => { // Note: it's important to test that the WeakRef is indeed empty. // Otherwise, the callback may be called after a new object has been // added with this key, and that new, alive object gets deleted if (!cache.get(key)?.deref()) { cache.delete(key); } }); return async (key) => { if (cache.has(key)) { return cache.get(key).deref(); } const value = await getter(key); cache.set(key, new WeakRef(value)); registry.register(value, key); return value; }; } const getImage = cached((url) => fetch(url).then((res) => res.blob())); Due to performance and security concerns, there is no guarantee of when the callback will be called, or if it will be called at all. It should only be used for cleanup — and non-critical cleanup. There are other ways for more deterministic resource management, such as , which will always execute the block. and exist solely for optimization of memory usage in long-running programs. For more information on the API of and , see their reference pages."
    }
]