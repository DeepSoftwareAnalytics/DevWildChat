[
    {
        "link": "https://stackoverflow.com/questions/24132665/return-rgb-values-from-range-interior-color-or-any-other-color-property",
        "document": "Should note, for the hex values, if you're exporting out to HTML you're going to get quirks too.\n\nIdeally you'd create the hex string from the individual colours, rather than returning a hex from the ColorVal number.\n\nThe reason being you can get some invalid hex numbers if the cell is a 'pure' colour like green/blue\n\nIf you used these to create HTML/CSS colour output, you'd get RED for any blue cells.\n\nI modified the script to assemble each two character hex 'chunk' based on the RGB values, with a UDF that just pads with a leading 0 where output of one character is returned ( hopefully if you're reading this, you can make something similar )\n\n--Edit : forgot to include the code for the UDF...\n\n\n\nBTW - If you want the hex codes as displayed in the form editor ( which inexplicably has it's own standard , apart from the normal HTML Hex Colours )"
    },
    {
        "link": "https://stackoverflow.com/questions/1426369/set-background-colour-of-cell-to-rgb-value-of-data-in-cell",
        "document": "Setting the Color property alone will guarantee an exact match. Excel 2003 can only handle 56 colors at once. The good news is that you can assign any rgb value at all to those 56 slots (which are called ColorIndexs). When you set a cell's color using the Color property this causes Excel to use the nearest \"ColorIndex\". Example: Setting a cell to RGB 10,20,50 (or 3281930) will actually cause it to be set to color index 56 which is 51,51,51 (or 3355443).\n\nIf you want to be assured you got an exact match, you need to change a ColorIndex to the RGB value you want and then change the Cell's ColorIndex to said value. However you should be aware that by changing the value of a color index you change the color of all cells already using that color within the workbook. To give an example, Red is ColorIndex 3. So any cell you made Red you actually made ColorIndex 3. And if you redefine ColorIndex 3 to be say, purple, then your cell will indeed be made purple, but all other red cells in the workbook will also be changed to purple.\n\nThere are several strategies to deal with this. One way is to choose an index not yet in use, or just one that you think will not be likely to be used. Another way is to change the RGB value of the nearest ColorIndex so your change will be subtle. The code I have posted below takes this approach. Taking advantage of the knowledge that the nearest ColorIndex is assigned, it assigns the RGB value directly to the cell (thereby yielding the nearest color) and then assigns the RGB value to that index."
    },
    {
        "link": "https://morsagmon.com/blog/working-with-colors-in-excel-vba",
        "document": "Every color is identified by a unique number. For example, 255 represents Red. 16774980 represent a specific cyan.\n\nYou can also convert any decimal number to its Hexadecimal representation (or Hex for short). For example, that cyan color number equals FFF744 in Hex representation (use any decimal to hex converter you find on the web to see how it works).\n\nYou can assign the color codes to any Color property of any object in either their decimal or hex representation. Precede the Hex value with the &H prefix (our cyan code will be set to: &HFFF744). For example, the background color of cell A1 can be set to be cyan in one of the following two options:\n\nTip: to clear the background (Fill) color of a range, assign it the value -4142. Luckily, we have an Excel enumeration for that, so you do not need to remember the specific code, just assign xlNone like that:\n\nAnother way to represent a color is by its unique combination of the Red, Green and Blue components, or RGB in short. Each component takes a value between 1 and 255.\n\nOur cyan color above has a mix of 68 red, 247 green and 255 blue.\n\nVBA offers an RGB function to convert a mix of RGB values to the decimal code of a color, making it useful to assign an RGB mix to any Color property. Let’s set the font color of cell A1:\n\nYou can use Excel to choose a color you like from the color selection dialog box to see its RGB values.\n\nIn recent Excel versions the Hex code of the color is also presented. If not, you can use any RGB to Hex converter (such as this one) to find the Hex code of a color.\n\nThe twist of Hex color codes in Excel\n\nAs you noticed, a hex color code contains 6 characters. That is a construction of two characters for the R (Red) code in the mix, two characters for the G (Green) and two characters for the B (Blue), resulting in the RGB mix that also uniquely identifies a color.\n\nYou may also know that colors in Webpages are also usually represented in their hex representation, preceded by the hash (“#”) symbol. You would expect that #FFF744 will show the cyan on a webpage. You would be surprised to see a bright yellow instead.\n\nThe reason is that while the Hex representation of a color is constructed by joining the RGB codes for the Web, Excel constructs its color codes by joining the BGR codes. Yep, the R and the B are swapped.\n\nSo, if you want to see our beautiful cyan on your Webpage, swap the first “FF” with the last “44” in our code, resulting to: #44F7FF.\n\nBy the way, you might want to remember that swapping trick when you set specific colors for different controls when you design your User Forms. This will be valid to represent our cyan code in any color property: &HFF3399.\n\nColors are a great candidate for constants, as in many cases their value doesn’t change that often, yet we still want a consistent and readable VBA code.\n\nConstants can take any value, in both Hex and decimal. For example:\n\nTip: as constants cannot be assigned functions, RGB() cannot be used here. A quick way to find the numeric value of any RGB set would be using the Immediate Window in the VBA Editor (CTRL+G). To print out the numeric value of RGB(68,247,255), type in the following statement in the Immediate Window and press Enter: ?RGB(68,247,255)\n\nExcel VBA maintains enumerations for a bunch of popular colors. This means that you don’t have the know the color code of these colors, just use the enumeration label for the color you want.\n\nFor example, vbRed enumerates 255 (the color code for red). Print the value of vbGreen in the immediate Window, what do you get?\n\nSetting the font color of cell A1 to yellow, was never easier than:\n\nIn addition to the Color property used to set the color of some Excel objects, you will also find the ColorIndex property for these objects.\n\nThe ColorIndex property is a legacy from way back versions of Excel, but still supported.\n\nThe idea here is a fixed collection of 56 colors, each assigned its own numeric index. See the table below:\n\nIf these 56 colors satisfy your eye, you can simply assign any of these index numbers to the ColorIndex property of an object to set (or read) its color, like that:\n\nHey, don’t forget to share this Blog post with others! Thanks!"
    },
    {
        "link": "https://forum.ozgrid.com/forum/index.php?thread/94865-identify-the-color-in-an-existing-cell-using-vba/",
        "document": "Hi guys....\n\n \n\nThis isn't vitally important, and I can think of a number of \"workarounds\", but I'm hoping there may be a VBA answer to this question.\n\nHow can I find out the ColorIndex or RGB values for the background for a given cell?\n\nI was sort of hoping there'd be something like\n\n\n\n \n\n(obviously I made up the RGBRedValue bit)\n\n \n\nDoes anyone know of a way to get at an existing cell's interior Colorindex or RGB value?\n\n \n\nSteve"
    },
    {
        "link": "https://learn.microsoft.com/en-us/office/vba/api/excel.interior.color",
        "document": "Returns or sets the primary color of the object, as shown in the table in the remarks section. Use the RGB function to create a color value. Read/write Variant.\n\nexpression An expression that returns an Interior object.\n\nThis example sets the color of the tick-mark labels on the value axis on Chart1.\n\nHave questions or feedback about Office VBA or this documentation? Please see Office VBA support and feedback for guidance about the ways you can receive support and provide feedback."
    },
    {
        "link": "https://stackoverflow.com/questions/37943213/vba-to-iterate-through-rows-working-with-multiple-worksheets",
        "document": "I'd like some advice on creating a macro in VBA which will loop through an array of values in one worksheet, copying the values of two fields, pasting those values into another worksheet, then copying and pasting the output of a calculation made in those values back into the orignal worksheet next to the original rows.\n\nIn the (very trimmed down) example, I have 2 worksheets in a single workbook\n\nThis output then needs to be pasted back into \"VALUES\" at the respective rows in the blank columns.\n\nThe process I've explained above in VBA goes something like this:\n\nMy next job is to wrap the above code into something useful which will repeat the same processes made in the \"Forumla\" worksheet while working its way down rows in the \"Values\" worksheet.\n\nI've found numerous examples on how to loop/iterate through rows but nothing much on how to do it while jumping between worksheets and copying/pasting from one to the other etc.\n\nNote: The real calculations made on the data in the worksheet are complex and can't be incorporated into the code.\n\nEDIT: To clarify, I don't need any additional rows created in the worksheet - this worksheet is solely used to perform calculations on the data pasted from . The ouput generated in then needs to be pasted back into the worksheet in the 2 output columns - this is where the looping through rows needs to occur.\n\nEDIT 2: I've created a gif demonstrating the manual process I'd like to replicate using VBA\n\nNote this isn't the actual workbook I'll be using, it's just a quick demo for the purposes of this question)"
    },
    {
        "link": "https://stackoverflow.com/questions/33628362/vba-macro-looping-through-multiple-worksheets-and-returning-exact-matches",
        "document": "I have run through the relevant topics on the Internet, however I cannot find a solution to the problem I have encountered. I am working on a macro which would copy relevant data from one workbook into a newly created sheet in another workbook and then loop through the remaining worksheets of the latter to find exact matches to the data in this newly created sheet. The part in which I copy and paste the data works fine, however, when it comes to looping through worksheets an error occurs.\n\nI worked up multiple versions of this macro to see whether different solutions would work, however, actually none seems to work. I the destination workbook, the worksheet contain data tickers (sort of an id) in column A, the measure of data relevance in column B and names of the variables in column C.\n\nWhat I am trying to do is, after copying and pasting the data to a newly created sheet - where the data tickers are contained in column L, loop through all the default sheets in the destination workbook to check whether the tickers in column L of the newly created sheet overlap with the tickers in column A of the remainig worksheets, and, if so, copy the variable name from column C of the relevant worksheet into the newly created worksheet column M. The newly created worksheet is called \"Settings\" and contains headers in row 1 (it also consists of about 110 rows), the remaining worksheets contain no headers (and have 70 rows maximum).\n\nThe macro looks like this:\n\nAlternative version looks like this (skipping the copy-paste part):\n\nWhen I launch the first version of the macro I get an error:\n\nWhen I run the second version of the macro the error message reads:\n\nI suspect the problem is the definition and use of the ws (Worksheet) object. I am confused now because I use VBA a lot and I've done tasks much harder than this one. And yet I still can't solve the problem. Could you please suggest some solution. I will appreciate your help."
    },
    {
        "link": "https://learn.microsoft.com/en-us/office/troubleshoot/excel/loop-through-data-using-macro",
        "document": "How to loop through a list of data on a worksheet by using macros in Excel\n\nWhen you write a Microsoft Visual Basic for Applications (VBA) macro, you may have to loop through a list of data on a worksheet. There are several methods for performing this task. The \"More Information\" section of this article contains information about the methods that you can use to search the following types of lists:\n• A list that contains a known, constant number of rows.\n• A dynamic list, or a list with an unknown number of rows.\n\nMicrosoft provides programming examples for illustration only, without warranty either expressed or implied. This includes, but is not limited to, the implied warranties of merchantability or fitness for a particular purpose. This article assumes that you are familiar with the programming language that is being demonstrated and with the tools that are used to create and to debug procedures. Microsoft support engineers can help explain the functionality of a particular procedure, but they will not modify these examples to provide added functionality or construct procedures to meet your specific requirements. The following code samples assume that the list has a header row that starts in cell A1 and data that starts in cell A2.\n\nTo Search a List with a Constant, Known Number of Rows\n\nThis code moves down column A to the end of the list:\n\nTo Search a Dynamic List or a List with an Unknown Number of Rows\n\nThis code moves down column A to the end of the list. (This code assumes that each cell in column A contains an entry until the end.)\n\nNote If there are empty cells in column A throughout the data, modify this code to account for this condition. Make sure that the empty cells are a consistent distance apart. For example, if every other cell in column A is empty (for example, this situation may occur if every 'record' uses two rows, with the second row indented one cell), this loop can be modified as follows:\n\nThis code moves down column A to the end of the list:"
    },
    {
        "link": "https://learn.microsoft.com/en-us/office/vba/excel/concepts/excel-performance/excel-tips-for-optimizing-performance-obstructions",
        "document": "Follow these tips for optimizing many frequently occurring performance obstructions in Excel.\n\nLearn how to improve performance related to types of references and links.\n\nDo not use forward referencing and backward referencing\n\nTo increase clarity and avoid errors, design your formulas so that they don't refer forward (to the right or below) to other formulas or cells. Forward referencing usually does not affect calculation performance, except in extreme cases for the first calculation of a workbook, where it might take longer to establish a sensible calculation sequence if there are many formulas that need to have their calculation deferred.\n\nMinimize use of circular references with iteration\n\nCalculating circular references with iterations is slow because multiple calculations are needed, and these calculations are single-threaded. Frequently you can \"unroll\" the circular references by using algebra so that iterative calculation is no longer needed. For example, in cash flow and interest calculations, try to calculate the cash flow before interest, calculate the interest, and then calculate the cash flow including the interest.\n\nExcel calculates circular references sheet-by-sheet without considering dependencies. Therefore, you usually get slow calculation if your circular references span more than one worksheet. Try to move the circular calculations onto a single worksheet or optimize the worksheet calculation sequence to avoid unnecessary calculations.\n\nBefore the iterative calculations start, Excel must recalculate the workbook to identify all the circular references and their dependents. This process is equal to two or three iterations of the calculation.\n\nAfter the circular references and their dependents are identified, each iteration requires Excel to calculate not only all the cells in the circular reference, but also any cells that depend on the cells in the circular reference chain, together with volatile cells and their dependents. If you have a complex calculation that depends on cells in the circular reference, it can be faster to isolate this into a separate closed workbook and open it for recalculation after the circular calculation has converged.\n\nIt's important to reduce the number of cells in the circular calculation and the calculation time that is taken by these cells.\n\nAvoid inter-workbook links when it is possible; they can be slow, easily broken, and not always easy to find and fix.\n\nUsing fewer larger workbooks is usually, but not always, better than using many smaller workbooks. Some exceptions to this might be when you have many front-end calculations that are so rarely recalculated that it makes sense to put them in a separate workbook, or when you have insufficient RAM.\n\nTry to use simple direct cell references that work on closed workbooks. By doing this, you can avoid recalculating all your linked workbooks when you recalculate any workbook. Also, you can see the values Excel has read from the closed workbook, which is frequently important for debugging and auditing the workbook.\n\nIf you cannot avoid using linked workbooks, try to have them all open instead of closed, and open the workbooks that are linked to before you open the workbooks that are linked from.\n\nUsing many worksheets can make your workbook easier to use, but generally it is slower to calculate references to other worksheets than references within worksheets.\n\nTo save memory and reduce file size, Excel tries to store information about only the area on a worksheet that was used. This is called the used range. Sometimes various editing and formatting operations extend the used range significantly beyond the range that you would currently consider used. This can cause performance obstructions and file-size obstructions.\n\nYou can check the visible used range on a worksheet by using Ctrl+End. Where this is excessive, you should consider deleting all the rows and columns below and to the right of your real last used cell, and then saving the workbook. Create a backup copy first. If you have formulas with ranges that extend into or refer to the deleted area, these ranges will be reduced in size or changed to #N/A.\n\nWhen you frequently add rows or columns of data to your worksheets, you need to find a way of having your Excel formulas automatically refer to the new data area, instead of trying to find and change your formulas every time.\n\nYou can do this by using a large range in your formulas that extends well beyond your current data boundaries. However, this can cause inefficient calculation under certain circumstances, and it is difficult to maintain because deleting rows and columns can decrease the range without you noticing.\n\nStarting in Excel 2007, you can use structured table references, which automatically expand and contract as the size of the referenced table increases or decreases.\n\nThis solution has several advantages:\n• None Fewer performance disadvantages exist than the alternatives of whole column referencing and dynamic ranges.\n• None It's easy to have multiple tables of data on a single worksheet.\n• None Formulas that are embedded in the table also expand and contract with the data.\n\nAlternatively, use whole column and row references\n\nAn alternative approach is to use a whole column reference, for example $A:$A. This reference returns all the rows in Column A. Therefore, you can add as much data as you want, and the reference will always include it.\n\nThis solution has both advantages and disadvantages:\n• None Many Excel built-in functions (SUM, SUMIF) calculate whole column references efficiently because they automatically recognize the last used row in the column. However, array calculation functions like SUMPRODUCT either cannot handle whole column references or calculate all the cells in the column.\n• None User-defined functions don't automatically recognize the last-used row in the column and, therefore, frequently calculate whole column references inefficiently. However, it is easy to program user-defined functions so that they recognize the last-used row.\n• None It's difficult to use whole column references when you have multiple tables of data on a single worksheet.\n• None In Excel 2007 and later versions, array formulas can handle whole-column references, but this forces calculation for all the cells in the column, including empty cells. This can be slow to calculate, especially for 1 million rows.\n\nBy using the OFFSET or INDEX and COUNTA functions in the definition of a named range, you can make the area that the named range refers to dynamically expand and contract. For example, create a defined name using one of the following formulas:\n\nWhen you use the dynamic range name in a formula, it automatically expands to include new entries.\n\nUsing the INDEX formula for a dynamic range is generally preferable to the OFFSET formula because OFFSET has the disadvantage of being a volatile function that will be calculated at every recalculation.\n\nPerformance decreases because the COUNTA function inside the dynamic range formula must examine many rows. You can minimize this performance decrease by storing the COUNTA part of the formula in a separate cell or defined name, and then referring to the cell or name in the dynamic range:\n\nYou can also use functions such as INDIRECT to construct dynamic ranges, but INDIRECT is volatile and always calculates single-threaded.\n\nDynamic ranges have the following advantages and disadvantages:\n• None Dynamic ranges work well to limit the number of calculations performed by array formulas.\n• None Using many dynamic ranges can decrease performance.\n\nIn Office 365 version 1809 and later, Excel's VLOOKUP, HLOOKUP, and MATCH for exact match on unsorted data is much faster than ever before when looking up multiple columns (or rows with HLOOKUP) from the same table range.\n\nThat said, for earlier Excel versions, Lookups continue to be frequently significant calculation obstructions. Fortunately, there are many ways of improving lookup calculation time. If you use the exact match option, the calculation time for the function is proportional to the number of cells scanned before a match is found. For lookups over large ranges, this time can be significant.\n\nLookup time using the approximate match options of VLOOKUP, HLOOKUP, and MATCH on sorted data is fast and is not significantly increased by the length of the range you are looking up. Characteristics are the same as binary search.\n\nEnsure that you understand the match-type and range-lookup options in MATCH, VLOOKUP, and HLOOKUP.\n\nThe following code example shows the syntax for the MATCH function. For more information, see the Match method of the WorksheetFunction object.\n• None Matchtype=1 returns the largest match less than or equal to the lookup value when the lookup array is sorted ascending (approximate match). If the lookup array is not sorted ascending, MATCH will return an incorrect answer. The default option is approximate match sorted ascending.\n• None Matchtype=0 requests an exact match and assumes that the data is not sorted.\n• None Matchtype=-1 returns the smallest match greater than or equal to the lookup value if the lookup array is sorted descending (approximate match).\n\nThe following code example shows the syntax for the VLOOKUP and HLOOKUP functions. For more information, see the VLOOKUP and HLOOKUP methods of the WorksheetFunction object.\n• None Range-lookup=TRUE returns the largest match less than or equal to the lookup value (approximate match). This is the default option. Table array must be sorted ascending.\n• None Range-lookup=FALSE requests an exact match and assumes the data is not sorted.\n\nAvoid performing lookups on unsorted data where possible because it is slow. If your data is sorted, but you want an exact match, see Use two lookups for sorted data with missing values.\n\nUse INDEX and MATCH or OFFSET instead of VLOOKUP\n\nTry using the INDEX and MATCH functions instead of VLOOKUP. Although VLOOKUP is slightly faster (approximately 5 percent faster), simpler, and uses less memory than a combination of MATCH and INDEX, or OFFSET, the additional flexibility that MATCH and INDEX offer often enables you to significantly save time. For example, you can store the result of an exact MATCH in a cell and reuse it in several INDEX statements.\n\nThe INDEX function is fast and is a non-volatile function, which speeds up recalculation. The OFFSET function is also fast; however, it is a volatile function, and it sometimes significantly increases the time taken to process the calculation chain.\n\nIt's easy to convert VLOOKUP to INDEX and MATCH. The following two statements return the same answer:\n\nBecause exact match lookups can be slow, consider the following options for improving performance:\n• None Use one worksheet. It's faster to keep lookups and data on the same sheet.\n• None When you can, SORT the data first (SORT is fast), and use approximate match.\n• None When you must use an exact match lookup, restrict the range of cells to be scanned to a minimum. Use tables and structured references or dynamic range names rather than referring to a large number of rows or columns. Sometimes you can pre-calculate a lower-range limit and upper-range limit for the lookup.\n\nUse two lookups for sorted data with missing values\n\nTwo approximate matches are significantly faster than one exact match for a lookup over more than a few rows. (The breakeven point is about 10-20 rows.)\n\nIf you can sort your data but still cannot use approximate match because you cannot be sure that the value you are looking up exists in the lookup range, you can use this formula:\n\nThe first part of the formula works by doing an approximate lookup on the lookup column itself.\n\nYou can check if the answer from the lookup column is the same as the lookup value (in which case you have an exact match) by using the following formula:\n\nIf this formula returns True, you have found an exact match, so you can do the approximate lookup again, but this time, return the answer from the column you want.\n\nIf the answer from the lookup column did not match the lookup value, you have a missing value, and the formula returns \"notexist\".\n\nBe aware that if you look up a value smaller than the smallest value in the list, you receive an error. You can handle this error by using IFERROR, or by adding a small test value to the list.\n\nUse IFERROR function for unsorted data with missing values\n\nIf you must use exact match lookup on unsorted data, and you cannot be sure whether the lookup value exists, you often must handle the #N/A that is returned if no match is found. Beginning with Excel 2007, you can use the IFERROR function, which is both simple and fast.\n\nIn earlier versions, a simple but slow way is to use an IF function that contains two lookups.\n\nYou can avoid the double exact lookup if you use exact MATCH once, store the result in a cell, and then test the result before doing an INDEX.\n\nIf you cannot use two cells, use COUNTIF. It's generally faster than an exact match lookup.\n\nUse MATCH and INDEX for exact match lookups on multiple columns\n\nYou can often reuse a stored exact MATCH many times. For example, if you are doing exact lookups on multiple result columns, you can save time by using one MATCH and many INDEX statements rather than many VLOOKUP statements.\n\nAdd an extra column for the MATCH to store the result ( ), and for each result column use the following:\n\nAlternatively, you can use VLOOKUP in an array formula. (Array formulas must be entered by using Ctrl+-Shift+Enter. Excel will add the { and } to show you that this is an array formula).\n\nUse INDEX for a set of contiguous rows or columns\n\nYou can also return many cells from one lookup operation. To look up several contiguous columns, you can use the INDEX function in an array formula to return multiple columns at once (use 0 as the column number). You can also use the INDEX function to return multiple rows at one time.\n\nThis returns column A to column J from the stored row created by a previous MATCH statement.\n\nUse MATCH to return a rectangular block of cells\n\nUse the MATCH and OFFSET functions to return a rectangular block of cells.\n\nUse MATCH and INDEX for two-dimensional lookup\n\nYou can efficiently do a two-dimensional table lookup by using separate lookups on the rows and columns of a table by using an INDEX function with two embedded MATCH functions, one for the row and one for the column.\n\nIn large worksheets, you may frequently need to look up by using multiple indexes, such as looking up product volumes in a country/region. To do this, you can concatenate the indexes and perform the lookup by using concatenated lookup values. However, this is inefficient for two reasons:\n\nIt's often more efficient to calculate a subset range for the lookup (for example, by finding the first and last row for the country/region, and then looking up the product within that subset range).\n\nTo look up the table to use in addition to the row and the column, you can use the following techniques, focusing on how to make Excel look up or choose the table.\n\nIf each table that you want to look up (the third dimension) is stored as a set of named structured tables, range names, or as a table of text strings that represent ranges, you might be able to use the CHOOSE or INDIRECT functions.\n• None Using CHOOSE and range names can be an efficient method. CHOOSE is not volatile, but it is best-suited to a relatively small number of tables. This example dynamically uses to choose which range name ( ) to use for the lookup table.\n• None The following example uses the INDIRECT function and to dynamically create the sheet name to use for the lookup table. This method has the advantage of being simple and able to handle a large number of tables. Because INDIRECT is a volatile single-threaded function, the lookup is single-thread calculated at every calculation even if no data has changed. Using this method is slow.\n• None You could also use the VLOOKUP function to find the name of the sheet or the text string to use for the table, and then use the INDIRECT function to convert the resulting text into a range.\n\nAnother technique is to aggregate all your tables into one giant table that has an additional column that identifies the individual tables. You can then use the techniques for multiple-index lookup shown in the previous examples.\n\nThe MATCH, VLOOKUP, and HLOOKUP functions allow you to use the wildcard characters ? (any single character) and * (no character or any number of characters) on alphabetical exact matches. Sometimes you can use this method to avoid multiple matches.\n\nArray formulas and the SUMPRODUCT function are powerful, but you must handle them carefully. A single array formula might require many calculations.\n\nThe key to optimizing the calculation speed of array formulas is to ensure that the number of cells and expressions that are evaluated in the array formula is as small as possible. Remember that an array formula is a bit like a volatile formula: if any one of the cells that it references has changed, is volatile, or has been recalculated, the array formula calculates all the cells in the formula and evaluates all the virtual cells it needs to do the calculation.\n\nTo optimize the calculation speed of array formulas:\n• None Take expressions and range references out of the array formulas into separate helper columns and rows. This makes much better use of the smart recalculation process in Excel.\n• None Do not reference complete rows, or more rows and columns than you need. Array formulas are forced to calculate all the cell references in the formula even if the cells are empty or unused. With 1 million rows available starting in Excel 2007, an array formula that references a whole column is extremely slow to calculate.\n• None Starting in Excel 2007, use structured references where you can to keep the number of cells that are evaluated by the array formula to a minimum.\n• None In versions earlier than Excel 2007, use dynamic range names where possible. Although they are volatile, it is worthwhile because they minimize the size of the ranges.\n• None Be careful with array formulas that reference both a row and a column: this forces the calculation of a rectangular range.\n• None Use SUMPRODUCT if possible; it is slightly faster than the equivalent array formula.\n\nConsider options for using SUM for multiple-condition array formulas\n\nYou should always use the SUMIFS, COUNTIFS, and AVERAGEIFS functions instead of array formulas where you can because they are much faster to calculate. Excel 2016 introduces fast MAXIFS and MINIFS functions.\n\nIn versions earlier than Excel 2007, array formulas are often used to calculate a sum with multiple conditions. This is relatively easy to do, especially if you use the Conditional Sum Wizard in Excel, but it is often slow. Usually there are much faster ways of getting the same result. If you have only a few multiple-condition SUMs, you may be able to use the DSUM function, which is much faster than the equivalent array formula.\n\nIf you must use array formulas, some good methods of speeding them up are as follows:\n• None Use dynamic range names or structured table references to minimize the number of cells.\n• None Split out the multiple conditions into a column of helper formulas that return True or False for each row, and then reference the helper column in a SUMIF or array formula. This might not appear to reduce the number of calculations for a single array formula; however, most of the time it enables the smart recalculation process to recalculate only the formulas in the helper column that need to be recalculated.\n• None Consider concatenating together all the conditions into a single condition, and then using SUMIF.\n• None If the data can be sorted, count groups of rows and limit the array formulas to looking at the subset groups.\n\nThese functions evaluate each of the conditions from left to right in turn. Therefore, it is more efficient to put the most restrictive condition first, so that subsequent conditions only need to look at the smallest number of rows.\n\nConsider options for using SUMPRODUCT for multiple-condition array formulas\n\nStarting in Excel 2007, you should always use the SUMIFS, COUNTIFS, and AVERAGEIFS functions, and in Excel 2016 MAXIFS and MINIFS functions, instead of SUMPRODUCT formulas where possible.\n\nIn earlier versions, there are a few advantages to using SUMPRODUCT instead of SUM array formulas:\n• None SUMPRODUCT does not have to be array-entered by using Ctrl+Shift+Enter.\n• None SUMPRODUCT is usually slightly faster (5 to 10 percent).\n\nUse SUMPRODUCT for multiple-condition array formulas as follows:\n\nIn this example, and are conditional expressions such as . Because conditional expressions return True or False instead of numbers, they must be coerced to numbers inside the SUMPRODUCT function. You can do this by using two minus signs (--), or by adding 0 (+0), or by multiplying by 1 (x1). Using -- is slightly faster than +0 or x1.\n\nNote that the size and shape of the ranges or arrays that are used in the conditional expressions and range to sum must be the same, and they cannot contain entire columns.\n\nYou can also directly multiply the terms inside SUMPRODUCT rather than separate them by commas:\n\nThis is usually slightly slower than using the comma syntax, and it gives an error if the range to sum contains a text value. However, it is slightly more flexible in that the range to sum may have, for example, multiple columns when the conditions have only one column.\n\nUse SUMPRODUCT to multiply and add ranges and arrays\n\nIn cases like weighted average calculations, where you need to multiply a range of numbers by another range of numbers and sum the results, using the comma syntax for SUMPRODUCT can be 20 to 25 percent faster than an array-entered SUM.\n\nThese three formulas all produce the same result, but the third formula, which uses the comma syntax for SUMPRODUCT, takes only about 77 percent of the calculation time that the other two formulas need.\n\nBe aware of potential array and function calculation obstructions\n\nThe calculation engine in Excel is optimized to exploit array formulas and functions that reference ranges. However, some unusual arrangements of these formulas and functions can sometimes, but not always, cause significantly increased calculation time.\n\nIf you find a calculation obstruction that involves array formulas and range functions, you should look for the following:\n• None Array formulas and range functions that reference part of a block of cells that are calculated in another array formula or range function. This situation can frequently occur in time series analysis.\n• None One set of formulas referencing by row, and a second set of formulas referencing the first set by column.\n• None A large set of single-row array formulas covering a block of columns, with SUM functions at the foot of each column.\n\nFunctions significantly extend the power of Excel, but the way in which you use them can often affect calculation time.\n\nMost native Excel functions work well with multi-threaded calculation. However, where possible, avoid using the following single-threaded functions:\n• VBA and Automation user-defined functions (UDFs), but XLL-based UDFs can be multi-threaded\n• CELL when either the \"format\" or \"address\" argument is used\n• ADDRESS where the fifth parameter (the ) is given\n• Any database function (DSUM, DAVERAGE, and so on) that refers to a PivotTable\n\nUse tables for functions that handle ranges\n\nFor functions like SUM, SUMIF, and SUMIFS that handle ranges, the calculation time is proportional to the number of used cells you are summing or counting. Unused cells are not examined, so whole column references are relatively efficient, but it is better to ensure that you don't include more used cells than you need. Use tables, or calculate subset ranges or dynamic ranges.\n\nVolatile functions can slow recalculation because they increase the number of formulas that must be recalculated at each calculation.\n\nYou can often reduce the number of volatile functions by using INDEX instead of OFFSET, and CHOOSE instead of INDIRECT. However, OFFSET is a fast function and can often be used in creative ways that give fast calculation.\n\nUse C or C++ user-defined functions\n\nUser-defined functions that are programmed in C or C++ and that use the C API (XLL add-in functions) generally perform faster than user-defined functions that are developed by using VBA or Automation (XLA or Automation add-ins). For more information, see Developing Excel 2010 XLLs.\n\nThe performance of VBA user-defined functions is sensitive to how you program and call them.\n\nIt's usually faster to use the Excel formula calculations and worksheet functions than to use VBA user-defined functions. This is because there is a small overhead for each user-defined function call and significant overhead transferring information from Excel to the user-defined function. But well-designed and called user-defined functions can be much faster than complex array formulas.\n\nEnsure that you have put all the references to worksheet cells in the user-defined function input parameters instead of in the body of the user-defined function, so that you can avoid adding Application.Volatile unnecessarily.\n\nIf you must have many formulas that use user-defined functions, ensure that you are in manual calculation mode, and that the calculation is initiated from VBA. VBA user-defined functions calculate much more slowly if the calculation is not called from VBA (for example, in automatic mode or when you press F9 in manual mode). This is particularly true when the Visual Basic Editor (Alt+F11) is open or has been opened in the current Excel session.\n\nYou can trap F9 and redirect it to a VBA calculation subroutine as follows. Add this subroutine to the Thisworkbook module.\n\nUser-defined functions in Automation add-ins (Excel 2002 and later versions) don't incur the Visual Basic Editor overhead because they don't use the integrated editor. Other performance characteristics of Visual Basic 6 user-defined functions in Automation add-ins are similar to VBA functions.\n\nIf your user-defined function processes each cell in a range, declare the input as a range, assign it to a variant that contains an array, and loop on that. If you want to handle whole column references efficiently, you must make a subset of the input range, dividing it at its intersection with the used range, as in this example.\n\nIf your user-defined function is using worksheet functions or Excel object model methods to process a range, it is generally more efficient to keep the range as an object variable than to transfer all the data from Excel to the user-defined function.\n\nIf your user-defined function is called early in the calculation chain, it can be passed as uncalculated arguments. Inside a user-defined function, you can detect uncalculated cells by using the following test for empty cells that contain a formula:\n\nA time overhead exists for each call to a user-defined function and for each transfer of data from Excel to VBA. Sometimes one multi-cell array formula user-defined function can help you minimize these overheads by combining multiple function calls into a single function with a multi-cell input range that returns a range of answers.\n\nMinimize range of cells that SUM and SUMIF reference\n\nThe Excel SUM and SUMIF functions are frequently used over a large number of cells. Calculation time for these functions is proportionate to the number of cells covered, so try to minimize the range of cells that the functions are referencing.\n\nUse wildcard SUMIF, COUNTIF, SUMIFS, COUNTIFS, and other IFS functions\n\nUse the wildcard characters ? (any single character) and * (no character or any number of characters) in the criteria for alphabetical ranges as part of the SUMIF, COUNTIF, SUMIFS, COUNTIFS, and other IFS functions.\n\nThere are two methods of doing period-to-date or cumulative SUMs. Suppose the numbers that you want to cumulatively SUM are in column A, and you want column B to contain the cumulative sum; you can do either of the following:\n• None You can create a formula in column B such as and drag it down as far as you need. The beginning cell of the SUM is anchored in A1, but because the finishing cell has a relative row reference, it automatically increases for each row.\n• None You can create a formula such as in cell B1 and in cell B2 and drag it down as far as you need. This calculates the cumulative cell by adding this row's number to the previous cumulative SUM.\n\nFor 1,000 rows, the first method makes Excel do about 500,000 calculations, but the second method makes Excel do only about 2,000 calculations.\n\nWhen you have multiple sorted indexes to a table (for example, Site within Area) you can often save significant calculation time by dynamically calculating the address of a subset range of rows (or columns) to use in the SUM or SUMIF function.\n\nTo calculate the address of a subset range of row or columns:\n• None Count the number of rows for each subset block.\n• None Add the counts cumulatively for each block to determine its start row.\n• None Use OFFSET with the start row and count to return a subset range to the SUM or SUMIF that covers only the subset block of rows.\n\nUse the SUBTOTAL function to SUM filtered lists. The SUBTOTAL function is useful because, unlike SUM, it ignores the following:\n• None Hidden rows that result from filtering a list. Starting in Excel 2003, you can also make SUBTOTAL ignore all hidden rows, not just filtered rows.\n\nThe AGGREGATE function is a powerful and efficient way of calculating 19 different methods of aggregating data (such as SUM, MEDIAN, PERCENTILE and LARGE). AGGREGATE has options for ignoring hidden or filtered rows, error values, and nested SUBTOTAL and AGGREGATE functions.\n\nThe DFunctions DSUM, DCOUNT, DAVERAGE, and so on are significantly faster than equivalent array formulas. The disadvantage of the DFunctions is that the criteria must be in a separate range, which makes them impractical to use and maintain in many circumstances. Starting in Excel 2007, you should use SUMIFS, COUNTIFS, and AVERAGEIFS functions instead of the DFunctions.\n\nUse the following tips to create faster VBA macros.\n\nTurn off everything but the essentials while code is running\n\nTo improve performance for VBA macros, explicitly turn off the functionality that is not required while your code executes. Often, one recalculation or one redraw after your code runs is all that is necessary and can improve performance. After your code executes, restore the functionality to its original state.\n\nThe following functionality can usually be turned off while your VBA macro executes:\n• None Application.ScreenUpdating Turn off screen updating. If Application.ScreenUpdating is set to False, Excel does not redraw the screen. While your code runs, the screen updates quickly, and it is usually not necessary for the user to see each update. Updating the screen once, after the code executes, improves performance.\n• None Application.DisplayStatusBar Turn off the status bar. If Application.DisplayStatusBar is set to False, Excel does not display the status bar. The status bar setting is separate from the screen updating setting so that you can still display the status of the current operation even while the screen is not updating. However, if you don't need to display the status of every operation, turning off the status bar while your code runs also improves performance.\n• None Application.Calculation Switch to manual calculation. If Application.Calculation is set to xlCalculationManual, Excel only calculates the workbook when the user explicitly initiates the calculation. In automatic calculation mode, Excel determines when to calculate. For example, every time a cell value that is related to a formula changes, Excel recalculates the formula. If you switch the calculation mode to manual, you can wait until all the cells associated with the formula are updated before recalculating the workbook. By only recalculating the workbook when necessary while your code runs, you can improve performance.\n• None Application.EnableEvents Turn off events. If Application.EnableEvents is set to False, Excel does not raise events. If there are add-ins listening for Excel events, those add-ins consume resources on the computer as they record the events. If it is not necessary for the add-in to record the events that occur while your code runs, turning off events improves performance.\n• None ActiveSheet.DisplayPageBreaks Turn off page breaks. If ActiveSheet.DisplayPageBreaks is set to False, Excel does not display page breaks. It's not necessary to recalculate page breaks while your code runs, and calculating the page breaks after the code executes improves performance.\n\nThe following example shows the functionality that you can turn off while your VBA macro executes.\n\nRead and write large blocks of data in a single operation\n\nOptimize your code by explicitly reducing the number of times data is transferred between Excel and your code. Instead of looping through cells one at a time to get or set a value, get or set the values in the entire range of cells in one line, using a variant containing a two-dimensional array to store values as needed. The following code examples compare these two methods.\n\nThe following code example shows non-optimized code that loops through cells one at a time to get and set the values of cells A1:C10000. These cells don't contain formulas.\n\nThe following code example shows optimized code that uses an array to get and set the values of cells A1:C10000 all at the same time. These cells don't contain formulas.\n\nUse .Value2 rather than .Value or .Text when reading data from an Excel range\n• .Text returns the formatted value of a cell. This is slow, can return ### if the user zooms, and can lose precision.\n• .Value returns a VBA currency or VBA date variable if the range was formatted as Date or Currency. This is slow, can lose precision, and can cause errors when calling worksheet functions.\n• .Value2 is fast and does not alter the data being retrieved from Excel.\n\nSelecting and activating objects is more processing intensive than referencing objects directly. By referencing an object such as a Range or a Shape directly, you can improve performance. The following code examples compare the two methods.\n\nThe following code example shows non-optimized code that selects each Shape on the active sheet and changes the text to \"Hello\".\n\nThe following code example shows optimized code that references each Shape directly and changes the text to \"Hello\".\n\nThe following is a list of additional performance optimizations you can use in your VBA code:\n• None Return results by assigning an array directly to a Range.\n• None Declare variables with explicit types to avoid the overhead of determining the data type, possibly multiple times in a loop, during code execution.\n• None For simple functions that you use frequently in your code, implement the functions yourself in VBA instead of using the WorksheetFunction object. For more information, see Use faster VBA user-defined functions.\n• None Use the Range.SpecialCells method to scope down the number of cells with which your code interacts.\n• None Consider the performance gains if you implemented your functionality by using the C API in the XLL SDK. For more information, see the Excel 2010 XLL SDK Documentation.\n\nConsider performance and size of Excel file formats\n\nStarting in Excel 2007, Excel contains a wide variety of file formats compared to earlier versions. Ignoring the Macro, Template, Add-in, PDF, and XPS file format variations, the three main formats are XLS, XLSB, and XLSX.\n• The XLS format is the same format as earlier versions. When you use this format, you are restricted to 256 columns and 65,536 rows. When you save an Excel 2007 or Excel 2010 workbook in XLS format, Excel runs a compatibility check. File size is almost the same as earlier versions (some additional information may be stored), and performance is slightly slower than earlier versions. Any multi-threaded optimization Excel does with respect to cell calculation order is not saved in the XLS format. Therefore, calculation of a workbook can be slower after saving the workbook in the XLS format, closing, and re-opening the workbook.\n• XLSB is the binary format starting in Excel 2007. It's structured as a compressed folder that contains many binary files. It's much more compact than the XLS format, but the amount of compression depends on the contents of the workbook. For example, ten workbooks show a size reduction factor ranging from two to eight with an average reduction factor of four. Starting in Excel 2007, opening and saving performance is only slightly slower than the XLS format.\n• XLSX is the XML format starting in Excel 2007, and is the default format starting in Excel 2007. The XLSX format is a compressed folder that contains many XML files (if you change the file name extension to .zip, you can open the compressed folder and examine its contents). Typically, the XLSX format creates larger files than the XLSB format (1.5 times larger on average), but they are still significantly smaller than the XLS files. You should expect opening and saving times to be slightly longer than for XLSB files.\n\nYou may find that opening, closing, and saving workbooks is much slower than calculating them. Sometimes this is just because you have a large workbook, but there can also be other reasons.\n\nIf one or more of your workbooks open and close more slowly than is reasonable, it might be caused by one of the following issues.\n• Temporary files can accumulate in your \\Windows\\Temp directory (in Windows 95, Windows 98, and Windows ME), or your \\Documents and Settings\\User Name\\Local Settings\\Temp directory (in Windows 2000 and Windows XP). Excel creates these files for the workbook and for controls that are used by open workbooks. Software installation programs also create temporary files. If Excel stops responding for any reason, you might need to delete these files. Too many temporary files can cause problems, so you should occasionally clean them out. However, if you have installed software that requires that you restart your computer, and you have not yet done so, you should restart before deleting the temporary files.\n\nAn easy way to open your temp directory is from the Windows Start menu: Click Start, and then click Run. In the text box, type %temp%, and then click OK.\n• Tracking changes in a shared workbook causes your workbook file-size to increase rapidly.\n• Be sure that your Windows swap file is located on a disk that has a lot of space and that you defragment the disk periodically.\n• A workbook that has its structure protected with a password (Tools menu > Protection > Protect Workbook > enter the optional password) opens and closes much slower than one that is protected without the optional password.\n• Oversized used ranges can cause slow opening and increased file size, especially if they are caused by hidden rows or columns that have non-standard height or width. For more information about used range problems, see Minimize the used range.\n• A large number of controls (check boxes, hyperlinks, and so on) on worksheets can slow down opening a workbook because of the number of temporary files that are used. This might also cause problems opening or saving a workbook on a WAN (or even a LAN). If you have this problem, you should consider redesigning your workbook.\n• None Large number of links to other workbooks If possible, open the workbooks that you are linking to before you open the workbook that contains the links. Often it is faster to open a workbook than to read the links from a closed workbook.\n• Some virus scanner settings can cause problems or slowness with opening, closing, or saving, especially on a server. If you think that this might be the problem, try temporarily switching the virus scanner off.\n• Under some circumstances, Excel recalculates your workbook when it opens or saves it. If the calculation time for your workbook is long and is causing a problem, ensure that you have calculation set to manual, and consider turning off the calculate before save option (Tools > Options > Calculation).\n• Check the size of your toolbar file. A typical toolbar file is between 10 KB and 20 KB. You can find your XLB files by searching for by using Windows search. Each user has a unique XLB file. Adding, changing, or customizing toolbars increases the size of your toolbar.xlb file. Deleting the file removes all your toolbar customizations (renaming it \"toolbar.OLD\" is safer). A new XLB file is created the next time you open Excel.\n\nYou can make performance improvements in the following areas.\n• PivotTables provide an efficient way to summarize large amounts of data.\n• None Totals as final results. If you need to produce totals and subtotals as part of the final results of your workbook, try using PivotTables.\n• None Totals as intermediate results. PivotTables are a great way to produce summary reports, but try to avoid creating formulas that use PivotTable results as intermediate totals and subtotals in your calculation chain unless you can ensure the following conditions:\n• None The PivotTable has been refreshed correctly during the calculation.\n• None The PivotTable has not been changed so that the information is still visible. If you still want to use PivotTables as intermediate results, use the GETPIVOTDATA function.\n• Conditional formats and data validation are great, but using a lot of them can significantly slow down calculation. If the cell is displayed, every conditional format formula is evaluated at each calculation and when the display of the cell that contains the conditional format is refreshed. The Excel object model has a Worksheet.EnableFormatConditionsCalculation property so that you can enable or disable the calculation of conditional formats.\n• Defined names are one of the most powerful features in Excel, but they do take additional calculation time. Using names that refer to other worksheets adds an additional level of complexity to the calculation process. Also, you should try to avoid nested names (names that refer to other names). Because names are calculated every time a formula that refers to them is calculated, you should avoid putting calculation-intensive formulas or functions in defined names. In these cases, it can be significantly faster to put your calculation-intensive formula or function in a spare cell somewhere and refer to that cell instead, either directly or by using a name.\n• None Formulas that are used only occasionally Many workbooks contain a significant number of formulas and lookups that are concerned with getting the input data into the appropriate shape for the calculations, or are being used as defensive measures against changes in the size or shape of the data. When you have blocks of formulas that are used only occasionally, you can copy and paste special values to temporarily eliminate the formulas, or you can put them in a separate, rarely opened workbook. Because worksheet errors are often caused by not noticing that formulas have been converted to values, the separate workbook method may be preferable.\n• The 32-bit version of Excel can use up to 2 GB of RAM or up to 4 GB of RAM for Large Address Aware 32-bit versions of Excel 2013 and 2016. However, the computer that is running Excel also requires memory resources. Therefore, if you only have 2 GB of RAM on your computer, Excel cannot take advantage of the full 2 GB because a portion of the memory is allocated to the operating system and other programs that are running. To optimize the performance of Excel on a 32-bit computer, we recommend that the computer have at least 3 GB of RAM. The 64-bit version of Excel does not have a 2 GB or up to 4 GB limit. For more information, see the \"Large data sets and the 64-bit version of Excel\" section in Excel performance: Performance and limit improvements.\n\nThis article covered ways to optimize Excel functionality such as links, lookups, formulas, functions, and VBA code to avoid common obstructions and improve performance.\n\nHave questions or feedback about Office VBA or this documentation? Please see Office VBA support and feedback for guidance about the ways you can receive support and provide feedback."
    },
    {
        "link": "https://thesmallman.com/looping-through-worksheets",
        "document": "Looping through worksheets with Excel VBA is generally done when you want to perform the same task repeatedly through the workbook. There are a number of ways to loop through the sheets in an Excel workbook. The looping method you choose in up to you. The following is an example of looping through each sheet and sorting the data in ascending order with VBA. SortIt2() 'VBA macro to Loop through sheets and sorts Cols A:E in Ascending order. \n\n\n\n ws In Sheets ws.Range(\"A2\", ws.Range(\"E1048576\").End(xlUp)).Sort ws.[A2], 'Insert No at end for Descending order ws \n\n Here is a cool way to copy the contents of one Excel sheet to all of the other sheets in the same workbook. This VBA procedure is done without the use of a loop. Basically copying the data from one sheet to all sheets.\n\n \n\n The following YouTube video outlines some of the methods on this page, demonstrating how to loop through sheets with Excel VBA. \n\n Occasionally you may want Excel to exclude certain sheets from your VBA loop. Mostly you will want to loop through like sheets and exclude sheets which perform other functions. As with everything in Excel there are many ways to perform this task inside the looping construct. I will demonstrate some of the more popular methods of looping through a worksheet with VBA. \n\n The following will exclude 1 sheet from the VBA looping process. \n\n MovethroughWB() 'Excel VBA to exclude sheet3 from the loop. \n\n ws \n\n\n\n ws In Sheets ws.Name <> \"Sheet3\" 'Perform the Excel action you wish (turn cell yellow below)\n\nThe above Excel macro will loop through all of the sheets in an Excel workbook except the sheet with the name \"Sheet3\". This is handy if there are not too many sheets you wish to exclude in the Excel workbook. The VBA loop cycles through each worksheet and colours the range from A10 to A20 yellow. \n\n Quite often you may want to exclude certain sheets from the looping construct which are in a certain position in the workbook. For example, if you wanted to exclude the first tab in the Excel workbook, the tab on the far left, then here is a method for doing just that. \n\n MovethroughWB1() 'Excel VBA looping procedure, loop excludes first tab on the left. \n\n ws \n\n\n\n ws In ThisWorkbook.Worksheets ws.Index <> 1 'Exclude the first sheet on the left from the procedure.n 'Perform the Action you wish. ws\n\nTaking this a step further, the following Excel VBA procedure will include all of the sheets between the first and last sheet in the workbook. So the first sheet on the far left of the workbook (first sheet) and the sheet on the far right of the workbook (last sheet) will be excluded. \n\n LoopMissing2sheets() 'Excel VBA loop to exclude first and last tab (in order) \n\n \n\n\n\n \n\nIf you want to exclude say the first 3 sheets on the left of the workbook change the= 2 to=4. This will mean the first 3 worksheets starting from the left of the file will be excluded. The same is true at the end of the workbook. If you wanted Excel VBA loop to exclude the last two sheets on the far right of the workbook just change - 1 to - 2. \n\n You may have a larger workbook and only want the loop to go through a limited number of sheets and perform an action. In this case the following method uses the Select Case method, where the included sheet names are Sheet1, Sheet2 and Sheet3.\n\nLoopCertain() 'Excel VBA to loop through only include sheets (1-3) \n\n sh \n\n\n\n You could also add the sheets you want to exclude in a Case Statement. The following will exclude Sheets 1, 2 and 3. It looks similar but sheets 1 - 3 are excluded. Notice there is no VBA code when the condition is true. LoopCertain() \n\n sh \n\n\n\n sh In Sheets Case Is =\"Sheet1\", \"Sheet2\", \"Sheet3\"\n\n 'No Code here if excluded \n\n \n\n sh.[b11].Interior.Color=vbRed sh Once again the next VBA code snippet is another method of looping through the sheets of your choice. LoopCertain2() 'Excel VBA to loop and only include sheets(1-3) \n\n sh sh In Array(\"Sheet1\", \"Sheet2\", \"Sheet3\") 'Items in the array are included in the VBA loop. sh In Array(\"Sheet1\", \"Sheet2\", \"Sheet3\") 'Items in the array are included in the VBA loop. \n\n \n\n If you were trying to pinpoint sheets so the data from a sheet stayed in line with other specific sheets then the same method can be extended to do this. Sheets 1, 3 and 5 would all remain identical. CopyIt2() 'Excel VBA to fill the current region of Sheet1 to sheets 3 & 5 \n\nAfter the above VBA looping code has run, Sheets 1, 3 and 5 will all contain the same data as exists in Sheet1 A1 current region. The current region is all of the cells that are continuously used from A1. It is the same as putting your cursor on A1 and pressing Ctrl Shift 8 at the same time. If you have your data setup in a tabular format then all of the data will be identical on sheets (1,3,5). A point of caution with the above example, the sheet you are copying the data from (\"Sheet1\") needs to be in the Array. \n\n So there are a range of Excel VBA methods at your disposal to do a number of different looping tasks within a workbook. The above examples open the smallest window into the world of looping in Excel VBA. There is far more out there and this article gives the smallest glimpse into the world of looping with VBA. Go out and try new things and always try and improve your VBA code."
    }
]