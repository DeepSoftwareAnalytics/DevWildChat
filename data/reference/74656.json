[
    {
        "link": "https://training.bitrix24.com/support/training/course?COURSE_ID=68&CHAPTER_ID=06112&LESSON_PATH=5936.6078.6096.6112",
        "document": "As a matter of fact, today own component may have to be written only when an absolutely new functionality for the website is needed. Since the set of standard components is quite extensive, in most cases just expanding the functionality of the already available components will suffice and there is no need to write new components.\n\nHowever, sooner or later a developer must learn to create their own components.\n• In a web project, the possible types of own components are identified and described during the drawing up of the terms of reference and design.\n• The namespace of own components is determined, for example, by using the project name. The system components of Bitrix Framework are located in the namespace bitrix, which is where the project components can be located, for example in the namespace citybank. Attention! The names of the components to be created must not be the same as the names of standard components.\n• It is determined that a standard component may serve as a basis for creating an own component. The code of standard components contains lots of examples of typical and correct use of API and programming techniques, which is why they are considered a good starting point.\n• An interface is designed for each component 2.0. It should be decided as to which component parameters must be available to the website administrator for editing. For example, for the component displaying a weather forecast, the property Web Service Address and Web Service Connection Timeout may be put in the administrator’s settings, etc.\n• It is decided as to which section of the component tree in the visual editor this component should be located.\n• Component programming. Special attention shall be paid to set up the autocache of the component and its operating profile properly. It must not execute database queries in caching mode, must execute a minimum amount of database queries in case of cache aging, store only necessary data in cache, use a minimum possible volume of RAM (it must not sort arrays of tens or hundreds of megabytes, etc.).\n\nMake the required php code into a separate file in order to use it later as an invoked file. However, the component must also be connected to the system using a description file identifiable by the core of Bitrix Framework. As a result, a user can see the icon with the component name in the visual editor and can set up the component properties.\n\nRemember that a component consists of a php code with terminated functionality made into a separate file, a file of component registration in the system and its parameter descriptions, and also localization files.\n• Component registration\n• Locate files in a folder in the own namespace.\n• Setting up parameters in the component code\n• Localization\n• Prepare files with text constants for the component and registration file: and\n• make changes in the code of both files of the component in order to use these constants (the localization file is connected using the function IncludeTemplateLangFile).\n\nAttention! All keys in $MESS containing the name, description, and parameters of the component and also the identifiers of component branches in the component tree of the visual editor must be unique for the entire product."
    },
    {
        "link": "https://training.bitrix24.com/support/training/course?COURSE_ID=68&CHAPTER_ID=06112",
        "document": "As a matter of fact, today own component may have to be written only when an absolutely new functionality for the website is needed. Since the set of standard components is quite extensive, in most cases just expanding the functionality of the already available components will suffice and there is no need to write new components.\n\nHowever, sooner or later a developer must learn to create their own components.\n• In a web project, the possible types of own components are identified and described during the drawing up of the terms of reference and design.\n• The namespace of own components is determined, for example, by using the project name. The system components of Bitrix Framework are located in the namespace bitrix, which is where the project components can be located, for example in the namespace citybank. Attention! The names of the components to be created must not be the same as the names of standard components.\n• It is determined that a standard component may serve as a basis for creating an own component. The code of standard components contains lots of examples of typical and correct use of API and programming techniques, which is why they are considered a good starting point.\n• An interface is designed for each component 2.0. It should be decided as to which component parameters must be available to the website administrator for editing. For example, for the component displaying a weather forecast, the property Web Service Address and Web Service Connection Timeout may be put in the administrator’s settings, etc.\n• It is decided as to which section of the component tree in the visual editor this component should be located.\n• Component programming. Special attention shall be paid to set up the autocache of the component and its operating profile properly. It must not execute database queries in caching mode, must execute a minimum amount of database queries in case of cache aging, store only necessary data in cache, use a minimum possible volume of RAM (it must not sort arrays of tens or hundreds of megabytes, etc.).\n\nMake the required php code into a separate file in order to use it later as an invoked file. However, the component must also be connected to the system using a description file identifiable by the core of Bitrix Framework. As a result, a user can see the icon with the component name in the visual editor and can set up the component properties.\n\nRemember that a component consists of a php code with terminated functionality made into a separate file, a file of component registration in the system and its parameter descriptions, and also localization files.\n• Component registration\n• Locate files in a folder in the own namespace.\n• Setting up parameters in the component code\n• Localization\n• Prepare files with text constants for the component and registration file: and\n• make changes in the code of both files of the component in order to use these constants (the localization file is connected using the function IncludeTemplateLangFile).\n\nAttention! All keys in $MESS containing the name, description, and parameters of the component and also the identifiers of component branches in the component tree of the visual editor must be unique for the entire product."
    },
    {
        "link": "https://training.bitrix24.com/support/training/course/index.php?COURSE_ID=68&CHAPTER_ID=06112",
        "document": "As a matter of fact, today own component may have to be written only when an absolutely new functionality for the website is needed. Since the set of standard components is quite extensive, in most cases just expanding the functionality of the already available components will suffice and there is no need to write new components.\n\nHowever, sooner or later a developer must learn to create their own components.\n• In a web project, the possible types of own components are identified and described during the drawing up of the terms of reference and design.\n• The namespace of own components is determined, for example, by using the project name. The system components of Bitrix Framework are located in the namespace bitrix, which is where the project components can be located, for example in the namespace citybank. Attention! The names of the components to be created must not be the same as the names of standard components.\n• It is determined that a standard component may serve as a basis for creating an own component. The code of standard components contains lots of examples of typical and correct use of API and programming techniques, which is why they are considered a good starting point.\n• An interface is designed for each component 2.0. It should be decided as to which component parameters must be available to the website administrator for editing. For example, for the component displaying a weather forecast, the property Web Service Address and Web Service Connection Timeout may be put in the administrator’s settings, etc.\n• It is decided as to which section of the component tree in the visual editor this component should be located.\n• Component programming. Special attention shall be paid to set up the autocache of the component and its operating profile properly. It must not execute database queries in caching mode, must execute a minimum amount of database queries in case of cache aging, store only necessary data in cache, use a minimum possible volume of RAM (it must not sort arrays of tens or hundreds of megabytes, etc.).\n\nMake the required php code into a separate file in order to use it later as an invoked file. However, the component must also be connected to the system using a description file identifiable by the core of Bitrix Framework. As a result, a user can see the icon with the component name in the visual editor and can set up the component properties.\n\nRemember that a component consists of a php code with terminated functionality made into a separate file, a file of component registration in the system and its parameter descriptions, and also localization files.\n• Component registration\n• Locate files in a folder in the own namespace.\n• Setting up parameters in the component code\n• Localization\n• Prepare files with text constants for the component and registration file: and\n• make changes in the code of both files of the component in order to use these constants (the localization file is connected using the function IncludeTemplateLangFile).\n\nAttention! All keys in $MESS containing the name, description, and parameters of the component and also the identifiers of component branches in the component tree of the visual editor must be unique for the entire product."
    },
    {
        "link": "https://training.bitrix24.com/support/training/course?COURSE_ID=68&CHAPTER_ID=06078&LESSON_PATH=5936.6078",
        "document": "Components are the main tool for developers when it comes to working with the projects created with Bitrix Framework. Developers’ professionalism largely depends on their ability to use this tool.\n\nComponent - is a logically completed code intended for the retrieval of information from infoblocks and other sources and its conversion to HTML code for displaying as fragments of web pages. It consists of a component proper (controller) and a template (form). The component manipulates data using API of one or more modules. The component template displays data on the page.\n\nComponents implement the design pattern Carrier Rider Mapper to the full extent.\n• Carrier. Carrier of any information that can be accessed by several clients simultaneously.\n• Rider (Reader or Writer) - objects through which the Carrier provides acces to the information stored in it. The clients read and write information stored in the Carrier exclusively using only the objects of the Reader and Writer type. Thus, Reader and Writer are information access interfaces.\n• Mapper (Scanneror Formatter) – objects that cover Reader or Writer, accordingly. Mappers are responsible for the conversion of data formats to the formats convenient for the clients.\n\nIntroducing mappers between Carrier-Rider and clients permits connecting one and the same Carrier-Rider with different types of clients by using appropriate (different) mappers.\n\nThe Use of Components\n\nComponents are used for the following purposes:\n• Creating fully functionining sections on a website, e.g. news section, photo gallery, goods catalog, etc. These sections are created using composite components;\n• Creating frequently used areas in the template or on website pages (e.g., authorization forms and subscription forms);\n• Performing any other operations with data.\n\nWhen placing a component on a page the user sets parameters that are used to retrieve the page program module on this particular page. The set of parameters (including their types) is to be established in the component parameter file as a special hash array.\n\nSeveral components may be placed on a website page. One component may be in charge of displaying the text of the article, the second may display banners, the third may display news related to the subject of this article, etc. One and the same component may be used on different pages of the website and on any website within the same product installation.\n\nComponents may be simple and composite.\n• Logic and visual form are separated in components. Logic is the component itself, and form is the component display template. Several forms may be created for the same logic, including forms which depend on the template of the current website. Visual form (display template) may be written using any template language that can be connected from PHP. For example, templates may be written using PHP, Smarty, XSL etc.\n• There is no need to change the component logic in order to change the specifics of its display. That is why it is quite easy to manage the external appearance of the information displayed by the component. Display template is by far simpler than the component as a whole.\n• Components are stored together in one folder. It ensures the integrity and transparency of a website structure. The folder is available for queries. This means the component and its templates can easily connect their additional resources.\n\nNote: The evolution of the development of Bitrix Framework using the components of regular standards has led to the components that are currently used in 2.0 standard. The regular standard (version 1.0 components) is not supported any longer. However, sometimes outdated components can be found in the projects operating on older versions of Bitrix Site Manager."
    },
    {
        "link": "https://training.bitrix24.com/support/training/course?COURSE_ID=68&CHAPTER_ID=06096",
        "document": "A component is the primary way to retrieve information in Bitrix Framework. Accordingly, it is the work with the component that opens the maximum possibilities to change data display conditions and change (add) system functionalities.\n\nhe following task/solution ratio is recommended:\n• To solve tasks that are aimed at changing the data display form (design) modify the component template.\n• In order to change and expand cached data displayed by the component, please use the options of the file result_modifer.php.\n• In order to implement the logic executed upon each call of the component irrespective of cache, use the options of the file component_epilog.php.\n• In order to make additions and implicit changes (without interfering with the code) of component operation logic the technique of Events can be used.\n• To expand the component operation logic, copy the component to its namespace and change it.\n• To create new logic and new options, create a new component.\n\nQuite often a task has to be solved using a combination of methods. I.e., for example, editing the template and adding a code in result_modifier.php.\n\nIn the chapters that follow, we will review the work with components in the indicated order of tasks and solutions.\n\nAttention! When performing any actions while working with components, please do not forget about caching. Heavy coding introduced in component_epilog.php not be subject to cache. However, there are situations when it is better to customize the component and it may result in better performance (especially when a heavy code is used on a home or a most frequently visited page)."
    },
    {
        "link": "https://training.bitrix24.com/support/training/course?COURSE_ID=68&LESSON_ID=20371",
        "document": "Before starting to write JS code, there is a valid question - where to store it? There are several options:\n• When you develop JS code for component and this code isn't used in any other locations, it's recommended to place the file in the template of the component itself.\n• When JS code is used generally for the complete public section, its better to allocate it within the site template. Usually, subfolder stores such JS files and they are connected within the template by method: Bitrix\\Main\\Page\\Asset::getInstance()->addJs();. However, this path is not suitable when a site has several templates or if you are redeveloping code for administrative section, or a public template update is prohibited due to being updated by Bitrix24 (For example, for Bitrix24 On-premise template).\n• The instance described above uses file storage method by the path . Use the same method when you decide to create your own custom module. Let's examine the last option in more detail. Indeed, you can allocate the code in the site template via . However, more correct solution will be the third approach. Each file within your folder is essentially an individual mini-library, which you need to register. Registering Registering libraries in the module's include.php or within init.php. is performed via the following code: As you can see, this code is universal and you can register several files. You can additionally specify CSS file in the CSS key (in case when CSS code used jointly with JS code), and use the key rel to enumerate codes of other BX libraries which will be automatically connected when connecting this library. When libraries have been registered, they can be connected via the following structure: Two blocks of code, listed above are used together and sometimes - separately. For example, when developing your own module, you need to register in the module's , and initiate (call InitJSCore) in the location you need (for example, in the component template). When two different files must be registered and used depending on the conditions, the following code is logical: <?php AddEventHandler('main', 'OnEpilog', function(){ $arJsConfig = array( 'custom_main' => array( 'js' => '/bitrix/js/custom/main.js', 'css' => '/bitrix/js/custom/main.css', 'rel' => array(), ), 'custom_crm' => array( 'js' => '/bitrix/js/custom/crm.js', 'css' => '/bitrix/js/custom/crm.css', 'rel' => array(), ), ); foreach ($arJsConfig as $ext => $arExt) { \\CJSCore::RegisterExt($ext, $arExt); } if (!crm) { CUtil::InitJSCore(array('custom_main')); } else { CUtil::InitJSCore(array('custom_crm')); } }); However, if options Merge CSS files and Merge JS files are enabled in the main module settings, the files will be merged. To avoid this, specify prefixes in the folder names: not , but"
    },
    {
        "link": "https://training.bitrix24.com/support/training/course/index.php?COURSE_ID=68&LESSON_ID=20371",
        "document": "Before starting to write JS code, there is a valid question - where to store it? There are several options:\n• When you develop JS code for component and this code isn't used in any other locations, it's recommended to place the file in the template of the component itself.\n• When JS code is used generally for the complete public section, its better to allocate it within the site template. Usually, subfolder stores such JS files and they are connected within the template by method: Bitrix\\Main\\Page\\Asset::getInstance()->addJs();. However, this path is not suitable when a site has several templates or if you are redeveloping code for administrative section, or a public template update is prohibited due to being updated by Bitrix24 (For example, for Bitrix24 On-premise template).\n• The instance described above uses file storage method by the path . Use the same method when you decide to create your own custom module. Let's examine the last option in more detail. Indeed, you can allocate the code in the site template via . However, more correct solution will be the third approach. Each file within your folder is essentially an individual mini-library, which you need to register. Registering Registering libraries in the module's include.php or within init.php. is performed via the following code: As you can see, this code is universal and you can register several files. You can additionally specify CSS file in the CSS key (in case when CSS code used jointly with JS code), and use the key rel to enumerate codes of other BX libraries which will be automatically connected when connecting this library. When libraries have been registered, they can be connected via the following structure: Two blocks of code, listed above are used together and sometimes - separately. For example, when developing your own module, you need to register in the module's , and initiate (call InitJSCore) in the location you need (for example, in the component template). When two different files must be registered and used depending on the conditions, the following code is logical: <?php AddEventHandler('main', 'OnEpilog', function(){ $arJsConfig = array( 'custom_main' => array( 'js' => '/bitrix/js/custom/main.js', 'css' => '/bitrix/js/custom/main.css', 'rel' => array(), ), 'custom_crm' => array( 'js' => '/bitrix/js/custom/crm.js', 'css' => '/bitrix/js/custom/crm.css', 'rel' => array(), ), ); foreach ($arJsConfig as $ext => $arExt) { \\CJSCore::RegisterExt($ext, $arExt); } if (!crm) { CUtil::InitJSCore(array('custom_main')); } else { CUtil::InitJSCore(array('custom_crm')); } }); However, if options Merge CSS files and Merge JS files are enabled in the main module settings, the files will be merged. To avoid this, specify prefixes in the folder names: not , but"
    },
    {
        "link": "https://training.bitrix24.com/support/training/course?COURSE_ID=68&LESSON_ID=20371&LESSON_PATH=5936.6148.6155.20371",
        "document": "Before starting to write JS code, there is a valid question - where to store it? There are several options:\n• When you develop JS code for component and this code isn't used in any other locations, it's recommended to place the file in the template of the component itself.\n• When JS code is used generally for the complete public section, its better to allocate it within the site template. Usually, subfolder stores such JS files and they are connected within the template by method: Bitrix\\Main\\Page\\Asset::getInstance()->addJs();. However, this path is not suitable when a site has several templates or if you are redeveloping code for administrative section, or a public template update is prohibited due to being updated by Bitrix24 (For example, for Bitrix24 On-premise template).\n• The instance described above uses file storage method by the path . Use the same method when you decide to create your own custom module. Let's examine the last option in more detail. Indeed, you can allocate the code in the site template via . However, more correct solution will be the third approach. Each file within your folder is essentially an individual mini-library, which you need to register. Registering Registering libraries in the module's include.php or within init.php. is performed via the following code: As you can see, this code is universal and you can register several files. You can additionally specify CSS file in the CSS key (in case when CSS code used jointly with JS code), and use the key rel to enumerate codes of other BX libraries which will be automatically connected when connecting this library. When libraries have been registered, they can be connected via the following structure: Two blocks of code, listed above are used together and sometimes - separately. For example, when developing your own module, you need to register in the module's , and initiate (call InitJSCore) in the location you need (for example, in the component template). When two different files must be registered and used depending on the conditions, the following code is logical: <?php AddEventHandler('main', 'OnEpilog', function(){ $arJsConfig = array( 'custom_main' => array( 'js' => '/bitrix/js/custom/main.js', 'css' => '/bitrix/js/custom/main.css', 'rel' => array(), ), 'custom_crm' => array( 'js' => '/bitrix/js/custom/crm.js', 'css' => '/bitrix/js/custom/crm.css', 'rel' => array(), ), ); foreach ($arJsConfig as $ext => $arExt) { \\CJSCore::RegisterExt($ext, $arExt); } if (!crm) { CUtil::InitJSCore(array('custom_main')); } else { CUtil::InitJSCore(array('custom_crm')); } }); However, if options Merge CSS files and Merge JS files are enabled in the main module settings, the files will be merged. To avoid this, specify prefixes in the folder names: not , but"
    },
    {
        "link": "https://training.bitrix24.com/support/training/course?COURSE_ID=68&LESSON_ID=24664&LESSON_PATH=5936.6148.6155.24664",
        "document": "Sometimes, when developing a component, its template must be supplemented with JS functionality, events and other features. It must look approximately as follows:\n\nSimilar approaches can be seen in Bitrix Framework JS core (located in ). You can get a clearer understanding of Bitrix24 developer JS code after overviewing this example.\n\nThe \"Single\" pattern: you implement it as part of create:\n\nJS class actions: memorizes a specific ID (for example, it can be a container ID) and parameter array, as well as associates handler to a confirmation button click event inside the indicated container form."
    },
    {
        "link": "https://training.bitrix24.com/support/training/course/index.php?COURSE_ID=68&LESSON_ID=20371&LESSON_PATH=5936.6148.6155.20371",
        "document": "Before starting to write JS code, there is a valid question - where to store it? There are several options:\n• When you develop JS code for component and this code isn't used in any other locations, it's recommended to place the file in the template of the component itself.\n• When JS code is used generally for the complete public section, its better to allocate it within the site template. Usually, subfolder stores such JS files and they are connected within the template by method: Bitrix\\Main\\Page\\Asset::getInstance()->addJs();. However, this path is not suitable when a site has several templates or if you are redeveloping code for administrative section, or a public template update is prohibited due to being updated by Bitrix24 (For example, for Bitrix24 On-premise template).\n• The instance described above uses file storage method by the path . Use the same method when you decide to create your own custom module. Let's examine the last option in more detail. Indeed, you can allocate the code in the site template via . However, more correct solution will be the third approach. Each file within your folder is essentially an individual mini-library, which you need to register. Registering Registering libraries in the module's include.php or within init.php. is performed via the following code: As you can see, this code is universal and you can register several files. You can additionally specify CSS file in the CSS key (in case when CSS code used jointly with JS code), and use the key rel to enumerate codes of other BX libraries which will be automatically connected when connecting this library. When libraries have been registered, they can be connected via the following structure: Two blocks of code, listed above are used together and sometimes - separately. For example, when developing your own module, you need to register in the module's , and initiate (call InitJSCore) in the location you need (for example, in the component template). When two different files must be registered and used depending on the conditions, the following code is logical: <?php AddEventHandler('main', 'OnEpilog', function(){ $arJsConfig = array( 'custom_main' => array( 'js' => '/bitrix/js/custom/main.js', 'css' => '/bitrix/js/custom/main.css', 'rel' => array(), ), 'custom_crm' => array( 'js' => '/bitrix/js/custom/crm.js', 'css' => '/bitrix/js/custom/crm.css', 'rel' => array(), ), ); foreach ($arJsConfig as $ext => $arExt) { \\CJSCore::RegisterExt($ext, $arExt); } if (!crm) { CUtil::InitJSCore(array('custom_main')); } else { CUtil::InitJSCore(array('custom_crm')); } }); However, if options Merge CSS files and Merge JS files are enabled in the main module settings, the files will be merged. To avoid this, specify prefixes in the folder names: not , but"
    }
]