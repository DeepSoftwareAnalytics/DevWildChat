[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions",
        "document": "You use a lambda expression to create an anonymous function. Use the lambda declaration operator to separate the lambda's parameter list from its body. A lambda expression can be of any of the following two forms:\n• None Expression lambda that has an expression as its body:\n• None Statement lambda that has a statement block as its body:\n\nTo create a lambda expression, you specify input parameters (if any) on the left side of the lambda operator and an expression or a statement block on the other side.\n\nAny lambda expression can be converted to a delegate type. The types of its parameters and return value define the delegate type to which a lambda expression can be converted. If a lambda expression doesn't return a value, it can be converted to one of the delegate types; otherwise, it can be converted to one of the delegate types. For example, a lambda expression that has two parameters and returns no value can be converted to an Action<T1,T2> delegate. A lambda expression that has one parameter and returns a value can be converted to a Func<T,TResult> delegate. In the following example, the lambda expression , which specifies a parameter named and returns the value of squared, is assigned to a variable of a delegate type:\n\nExpression lambdas can also be converted to the expression tree types, as the following example shows:\n\nYou use lambda expressions in any code that requires instances of delegate types or expression trees. One example is the argument to the Task.Run(Action) method to pass the code that should be executed in the background. You can also use lambda expressions when you write LINQ in C#, as the following example shows:\n\nWhen you use method-based syntax to call the Enumerable.Select method in the System.Linq.Enumerable class, for example in LINQ to Objects and LINQ to XML, the parameter is a delegate type System.Func<T,TResult>. When you call the Queryable.Select method in the System.Linq.Queryable class, for example in LINQ to SQL, the parameter type is an expression tree type . In both cases, you can use the same lambda expression to specify the parameter value. That makes the two calls to look similar although in fact the type of objects created from the lambdas is different.\n\nA lambda expression with an expression on the right side of the operator is called an expression lambda. An expression lambda returns the result of the expression and takes the following basic form:\n\nThe body of an expression lambda can consist of a method call. However, when creating expression trees evaluated by a query provider, limit method calls to those methods recognized by the query provider. Otherwise, the query provider can't replicate the method's function.\n\nA statement lambda resembles an expression lambda except that its statements are enclosed in braces:\n\nThe body of a statement lambda can consist of any number of statements; however, in practice there are typically no more than two or three.\n\nYou can't use statement lambdas to create expression trees.\n\nYou enclose input parameters of a lambda expression in parentheses. Specify zero input parameters with empty parentheses:\n\nIf a lambda expression has only one input parameter, parentheses are optional:\n\nTwo or more input parameters are separated by commas:\n\nThe compiler typically infers the types for parameters to lambda expressions, referred to as an implicitly typed parameter list. You can specify the types explicitly, referred to as an explicitly typed parameter list. An explicitly typed parameter list is shown in the following example. :\n\nInput parameter types must be all explicit or all implicit; otherwise, a CS0748 compiler error occurs. Before C# 14, you must include the explicit type on a parameter if it has any modifiers, such as or . In C# 14, that restriction is removed. However, you must still declare the type if you use the modifier.\n\nYou can use discards to specify two or more input parameters of a lambda expression that aren't used in the expression:\n\nLambda discard parameters can be useful when you use a lambda expression to provide an event handler.\n\nBeginning with C# 12, you can provide default values for explicitly typed parameter lists. The syntax and the restrictions on default parameter values are the same as for methods and local functions. The following example declares a lambda expression with a default parameter, then calls it once using the default and once with two explicit parameters:\n\nYou can also declare lambda expressions with arrays or collections as the last parameter in an explicitly typed parameter list:\n\nAs part of these updates, when a method group that has a default parameter is assigned to a lambda expression, that lambda expression also has the same default parameter. A method group with a collection parameter can also be assigned to a lambda expression.\n\nLambda expressions with default parameters or collections as parameters don't have natural types that correspond to or types. However, you can define delegate types that include default parameter values:\n\nOr, you can use implicitly typed variables with declarations to define the delegate type. The compiler synthesizes the correct delegate type.\n\nFor more information about default parameters on lambda expressions, see the feature spec for default parameters on lambda expressions.\n\nYou can easily create lambda expressions and statements that incorporate asynchronous processing by using the async and await keywords. For example, the following Windows Forms example contains an event handler that calls and awaits an async method, .\n\nYou can add the same event handler by using an async lambda. To add this handler, add an modifier before the lambda parameter list, as the following example shows:\n\nFor more information about how to create and use async methods, see Asynchronous Programming with async and await.\n\nThe C# language provides built-in support for tuples. You can provide a tuple as an argument to a lambda expression, and your lambda expression can also return a tuple. In some cases, the C# compiler uses type inference to determine the types of tuple elements.\n\nYou define a tuple by enclosing a comma-delimited list of its components in parentheses. The following example uses tuple with three components to pass a sequence of numbers to a lambda expression, which doubles each value and returns a tuple with three components that contains the result of the multiplications.\n\nOrdinarily, the fields of a tuple are named , , and so on. You can, however, define a tuple with named components, as the following example does.\n\nFor more information about C# tuples, see Tuple types.\n\nLINQ to Objects, among other implementations, has an input parameter whose type is one of the Func<TResult> family of generic delegates. These delegates use type parameters to define the number and type of input parameters, and the return type of the delegate. delegates are useful for encapsulating user-defined expressions that are applied to each element in a set of source data. For example, consider the Func<T,TResult> delegate type:\n\nThe delegate can be instantiated as a instance where is an input parameter and is the return value. The return value is always specified in the last type parameter. For example, defines a delegate with two input parameters, and , and a return type of . The following delegate, when invoked, returns Boolean value that indicates whether the input parameter is equal to five:\n\nYou can also supply a lambda expression when the argument type is an Expression<TDelegate>, for example in the standard query operators that are defined in the Queryable type. When you specify an Expression<TDelegate> argument, the lambda is compiled to an expression tree.\n\nThe following example uses the Count standard query operator:\n\nThe compiler can infer the type of the input parameter, or you can also specify it explicitly. This particular lambda expression counts those integers ( ) which when divided by two have a remainder of 1.\n\nThe following example produces a sequence that contains all elements in the array that precede the 9, because that's the first number in the sequence that doesn't meet the condition:\n\nThe following example specifies multiple input parameters by enclosing them in parentheses. The method returns all the elements in the array until it finds a number whose value is less than its ordinal position in the array:\n\nYou don't use lambda expressions directly in query expressions, but you can use them in method calls within query expressions, as the following example shows:\n\nWhen writing lambdas, you often don't have to specify a type for the input parameters because the compiler can infer the type based on the lambda body, the parameter types, and other factors as described in the C# language specification. For most of the standard query operators, the first input is the type of the elements in the source sequence. If you're querying an , then the input variable is inferred to be a object, which means you have access to its methods and properties:\n\nThe general rules for type inference for lambdas are as follows:\n• The lambda must contain the same number of parameters as the delegate type.\n• Each input parameter in the lambda must be implicitly convertible to its corresponding delegate parameter.\n• The return value of the lambda (if any) must be implicitly convertible to the delegate's return type.\n\nA lambda expression in itself doesn't have a type because the common type system has no intrinsic concept of \"lambda expression.\" However, it's sometimes convenient to speak informally of the \"type\" of a lambda expression. That informal \"type\" refers to the delegate type or Expression type to which the lambda expression is converted.\n\nA lambda expression can have a natural type. Instead of forcing you to declare a delegate type, such as or for a lambda expression, the compiler can infer the delegate type from the lambda expression. For example, consider the following declaration:\n\nThe compiler can infer to be a . The compiler chooses an available or delegate, if a suitable one exists. Otherwise, it synthesizes a delegate type. For example, the delegate type is synthesized if the lambda expression has parameters. When a lambda expression has a natural type, it can be assigned to a less explicit type, such as System.Object or System.Delegate:\n\nMethod groups (that is, method names without parameter lists) with exactly one overload have a natural type:\n\nIf you assign a lambda expression to System.Linq.Expressions.LambdaExpression, or System.Linq.Expressions.Expression, and the lambda has a natural delegate type, the expression has a natural type of System.Linq.Expressions.Expression<TDelegate>, with the natural delegate type used as the argument for the type parameter:\n\nNot all lambda expressions have a natural type. Consider the following declaration:\n\nThe compiler can't infer a parameter type for . When the compiler can't infer a natural type, you must declare the type:\n\nTypically, the return type of a lambda expression is obvious and inferred. For some expressions that doesn't work:\n\nYou can specify the return type of a lambda expression before the input parameters. When you specify an explicit return type, you must parenthesize the input parameters:\n\nYou can add attributes to a lambda expression and its parameters. The following example shows how to add attributes to a lambda expression:\n\nYou can also add attributes to the input parameters or return value, as the following example shows:\n\nAs the preceding examples show, you must parenthesize the input parameters when you add attributes to a lambda expression or its parameters.\n\nCapture of outer variables and variable scope in lambda expressions\n\nLambdas can refer to outer variables. These outer variables are the variables that are in scope in the method that defines the lambda expression, or in scope in the type that contains the lambda expression. Variables that are captured in this manner are stored for use in the lambda expression even if the variables would otherwise go out of scope and be garbage collected. An outer variable must be definitely assigned before it can be consumed in a lambda expression. The following example demonstrates these rules:\n\nThe following rules apply to variable scope in lambda expressions:\n• A variable that is captured isn't garbage-collected until the delegate that references it becomes eligible for garbage collection.\n• Variables introduced within a lambda expression aren't visible in the enclosing method.\n• A lambda expression can't directly capture an in, ref, or out parameter from the enclosing method.\n• A return statement in a lambda expression doesn't cause the enclosing method to return.\n• A lambda expression can't contain a goto, break, or continue statement if the target of that jump statement is outside the lambda expression block. It's also an error to have a jump statement outside the lambda expression block if the target is inside the block.\n\nYou can apply the modifier to a lambda expression to prevent unintentional capture of local variables or instance state by the lambda:\n\nA static lambda can't capture local variables or instance state from enclosing scopes, but can reference static members and constant definitions.\n\nFor more information, see the Anonymous function expressions section of the C# language specification.\n\nFor more information about these features, see the following feature proposal notes:\n• Use local function instead of lambda (style rule IDE0039)"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/linq",
        "document": "Language-Integrated Query (LINQ) is the name for a set of technologies based on the integration of query capabilities directly into the C# language. Traditionally, queries against data are expressed as simple strings without type checking at compile time or IntelliSense support. Furthermore, you have to learn a different query language for each type of data source: SQL databases, XML documents, various Web services, and so on. With LINQ, a query is a first-class language construct, just like classes, methods, and events.\n\nWhen you write queries, the most visible \"language-integrated\" part of LINQ is the query expression. Query expressions are written in a declarative query syntax. By using query syntax, you perform filtering, ordering, and grouping operations on data sources with a minimum of code. You use the same query expression patterns to query and transform data from any type of data source.\n\nThe following example shows a complete query operation. The complete operation includes creating a data source, defining the query expression, and executing the query in a statement.\n\nYou might need to add a directive, , for the preceding example to compile. The most recent versions of .NET make use of implicit usings to add this directive as a global using. Older versions require you to add it in your source.\n• Query expressions query and transform data from any LINQ-enabled data source. For example, a single query can retrieve data from an SQL database and produce an XML stream as output.\n• Query expressions use many familiar C# language constructs, which make them easy to read.\n• The variables in a query expression are all strongly typed.\n• A query isn't executed until you iterate over the query variable, for example in a statement.\n• At compile time, query expressions are converted to standard query operator method calls according to the rules defined in the C# specification. Any query that can be expressed by using query syntax can also be expressed by using method syntax. In some cases, query syntax is more readable and concise. In others, method syntax is more readable. There's no semantic or performance difference between the two different forms. For more information, see C# language specification and Standard query operators overview.\n• Some query operations, such as Count or Max, have no equivalent query expression clause and must therefore be expressed as a method call. Method syntax can be combined with query syntax in various ways.\n• Query expressions can be compiled to expression trees or to delegates, depending on the type that the query is applied to. IEnumerable<T> queries are compiled to delegates. IQueryable and IQueryable<T> queries are compiled to expression trees. For more information, see Expression trees.\n\nHow to enable LINQ querying of your data source\n\nThere are two ways you enable LINQ querying of in-memory data. If the data is of a type that implements IEnumerable<T>, you query the data by using LINQ to Objects. If it doesn't make sense to enable enumeration by implementing the IEnumerable<T> interface, you define LINQ standard query operator methods, either in that type or as extension methods for that type. Custom implementations of the standard query operators should use deferred execution to return the results.\n\nThe best option for enabling LINQ querying of a remote data source is to implement the IQueryable<T> interface.\n\nLINQ providers that implement IQueryable<T> can vary widely in their complexity.\n\nA less complex provider might access a single method from a Web service. This type of provider is very specific because it expects specific information in the queries that it handles. It has a closed type system, perhaps exposing a single result type. Most of the execution of the query occurs locally, for example by using the Enumerable implementations of the standard query operators. A less complex provider might examine only one method call expression in the expression tree that represents the query, and let the remaining logic of the query be handled elsewhere.\n\nAn provider of medium complexity might target a data source that has a partially expressive query language. If it targets a Web service, it might access more than one method of the Web service and select which method to call based on the information that the query seeks. A provider of medium complexity would have a richer type system than a simple provider, but it would still be a fixed type system. For example, the provider might expose types that have one-to-many relationships that can be traversed, but it wouldn't provide mapping technology for user-defined types.\n\nA complex provider, such as the Entity Framework Core provider, might translate complete LINQ queries to an expressive query language, such as SQL. A complex provider is more general because it can handle a wider variety of questions in the query. It also has an open type system and therefore must contain extensive infrastructure to map user-defined types. Developing a complex provider requires a significant amount of effort."
    },
    {
        "link": "https://infoworld.com/article/2265912/how-to-use-lambda-expressions-in-csharp.html",
        "document": "Lambda expressions were first introduced in .NET 3.5, at the same time that Language Integrated Query (LINQ) was made available. Lambda expressions are like anonymous methods but with much more flexibility. When using a lambda expression, you don’t need to specify the type of the input. Hence, a lambda expression provides a shorter and cleaner way of representing anonymous methods.\n\nIn this article, we’ll look at how we can use lambda expressions in C#. To work with the code examples provided in this article, you should have Visual Studio 2019 installed in your system. If you don’t already have a copy, you can download Visual Studio 2019 here.\n\nFirst off, let’s create a .NET Core console application project in Visual Studio. Assuming Visual Studio 2019 is installed in your system, follow the steps outlined below to create a new .NET Core console application project in Visual Studio.\n• In the “Create new project” window, select “Console App (.NET Core)” from the list of templates displayed.\n• In the “Configure your new project” window shown next, specify the name and location for the new project.\n\nFollowing these steps should result in a new .NET Core console application project in Visual Studio 2019. We’ll use this project to work with C# lambda expressions in the subsequent sections of this article.\n\nEssentially a lambda expression is a method that doesn’t have a declaration. In other words, a lambda expression is a method that doesn’t have an access specifier or a name. A lambda expression can be divided into two sections — the left part and the right part. The left part is used for input, and the right part is used for writing expressions.\n\nHere is the syntax for using lambda expressions in C#.\n\nYou can have two types of lambda expressions, an expression lambda and a statement lambda. An expression lambda is comprised of an input on the left side and an expression on the right side, as shown below.\n\nA statement lambda is comprised of an input on the left side and a set of statements on the right side, as shown below.\n\nWriting a lambda expression is simple — you just need to remove the delegate keyword and parameter type from an anonymous method. Consider the following anonymous method that uses the delegate keyword as well as a parameter type.\n\nThe above statement can be converted to a lambda expression as shown in the code snippet given below.\n\nIn the above statement is the parameter and is the lambda operator. The following statement is the expression.\n\nHere is another example of a lambda expression that displays the odd numbers between 1 and 9 at the console window.\n\nLambda expressions with and without parameters\n\nLambda expressions can be parameterless or have one or more parameters. The following code snippet illustrates a lambda expression that doesn’t have any parameters.\n\nLambda expressions can also have one or more parameters. The following code snippet illustrates how you can pass one parameter to a lambda expression.\n\nYou can also specify the type of the parameter in a lambda expression, as shown in the code snippet given below.\n\nYou can even specify multiple statements in a lambda expression using curly braces. This is shown in the following code snippet.\n\nA statement lambda uses a syntax identical to expression lambdas. The difference is that, instead of having an expression to the right of the operator, the statement lambda has a code block that includes one or more statements.\n\nThe following code snippet illustrates how you can take advantage of a statement lambda to display the even numbers between 1 and 9 at the console window.\n\nLambda expressions are a great feature in .NET and .NET Core that provide a shorter way of representing anonymous methods. Lambda expressions can have zero parameters or one or more. You can even assign lambda expressions to Func, Action, or Predicate delegates. In a future article here, we’ll explore these and other features of lambda expressions. We’ll also explore how we can work with lambda expressions and LINQ as well as async lambdas.\n\nHow to do more in C#:\n• When to use an abstract class vs. interface in C#\n• How to work with AutoMapper in C#\n• How to use lambda expressions in C#\n• How to work with Action, Func, and Predicate delegates in C#\n• How to work with delegates in C#\n• How to implement a simple logger in C#\n• How to work with attributes in C#\n• How to work with log4net in C#\n• How to implement the repository design pattern in C#\n• How to work with reflection in C#\n• How to work with filesystemwatcher in C#\n• How to perform lazy initialization in C#\n• How to work with MSMQ in C#\n• How to work with extension methods in C#\n• How to us lambda expressions in C#\n• When to use the volatile keyword in C#\n• How to use the yield keyword in C#\n• How to implement polymorphism in C#\n• How to build your own task scheduler in C#\n• How to work with RabbitMQ in C#\n• How to work with a tuple in C#\n• Exploring virtual and abstract methods in C#"
    },
    {
        "link": "https://oreilly.com/library/view/c-60-cookbook/9781491921456/ch04.html",
        "document": "Language Integrated Query (LINQ) is a great way to access data from many different sources. LINQ provides a single querying model that can operate against different data domains individually or all together in a single query. LINQ brings the ability to query data to .NET languages, and some of the languages have provided extensions to make its use even more intuitive. One of these languages is C#; there are a number of extensions to the language in C# that help to facilitate querying in a rich and intuitive manner. Traditional object-oriented programming is based on an imperative style wherein developers describe in detail not only what they want to happen, but also exactly how it should be performed through code. LINQ helps to take coding down a more declarative path that facilitates describing what the developer wants to do instead of detailing how to accomplish the goal. LINQ also enables a more functional style of programming. These changes can dramatically shorten the amount of code it takes to perform some tasks. That said, object-oriented programming is still very much alive and well in C# and .NET, but for the first time the language is offering you the chance to choose the style of programming based on your needs. Note, however, that LINQ will not fit into every scenario and is not a replacement for good design or practice. You can write bad code using LINQ just as you can write bad object-oriented or procedural code. The trick, as it always has been, is to figure out when it is appropriate to use which technique. The initial version of LINQ encompasses a number of data domains: As you begin your examination of LINQ, it is easy to think of it as a new object relational mapping layer, or some neat new widget on , or a new XML API, or even just an excuse to not write SQL directly anymore. You can use it as any of these things, but we would encourage you to instead think of LINQ as how your program asks for, calculates, or transforms sets of data from both single and disparate sources. It takes a bit of time and playing with LINQ for its functionality to click, but once it does, you will be surprised at what you can do with it. This chapter begins to show some of what is possible with LINQ and will hopefully get you thinking of which of your scenarios are applicable to this new capability in C#. To write the LINQ query expressions to specify criteria and select data, we use lambda expressions. They are a convenient way to represent the delegate passed to LINQ queries like when the method is called as part of narrowing down a result set. Lambda expressions are functions with a different syntax that enables them to be used in an expression context instead of the usual object-oriented method of being a member of a class. This means that with a single syntax, we can express a method definition, declaration, and the invocation of delegate to execute it, just as anonymous methods can, but with a more terse syntax. A projection is a lambda expression that translates one type into another. A lambda expression looks like this: This means “using as the parameter to the function, goes to the result of .” The can be read as “goes to” for both this and a projection declared like so: If you think about it, in C# 1.0 you could do the same thing: In C# 2.0 with anonymous methods, the C# 1.0 syntax could be reduced to the following example, as it is no longer necessary to provide the name for the delegate since all we want is the result of the operation: This brings us back to C# today and lambda expressions, where we can now just write: public static void ExecuteCSharp6_0() { // declare the lambda expression IncreaseByANumber increase = j => j * 42; // invoke the method and print 420 to the console Console.WriteLine(increase(10)); MultipleIncreaseByANumber multiple = (j, k, l) => ((j * 42) / k) % l; Console.WriteLine(multiple(10, 11, 12)); } Type inference helps the compiler to infer the type of from the declaration of the delegate type. If there were multiple arguments, then the lambda expression could look like this: This chapter’s recipes make use of delegates, events, and lambda expressions. Among other topics, these recipes cover:\n• Various uses of lambda expressions, closures, and functors If you are not familiar with delegates, events, or lambda expressions, you should read the MSDN documentation on these topics. There are also good tutorials and example code showing you how to set them up and use them in a basic fashion.\n\nYou want to be able to query for messages with specific criteria from an existing message queue. Use the class to write a LINQ query to retrieve messages using the type: string queuePath = @\".\\private$\\LINQMQ\"; EnumerableMessageQueue messageQueue = null; if (!EnumerableMessageQueue.Exists(queuePath)) messageQueue = EnumerableMessageQueue.Create(queuePath); else messageQueue = new EnumerableMessageQueue(queuePath); using (messageQueue) { BinaryMessageFormatter messageFormatter = new BinaryMessageFormatter(); // Query the message queue for specific messages with the following criteria: // 1) the label must be less than 5 // 2) the name of the type in the message body must contain 'CSharpRecipes.D' // 3) the results should be in descending order by type name (from the body) var query = from Message msg in messageQueue // The first assignment to msg.Formatter is so that we can touch the // Message object. It assigns the BinaryMessageFormatter to each message // instance so that it can be read to determine if it matches the // criteria. This is done and then checks that the formatter was // correctly assigned by performing an equality check which satisfies the // where clause's need for a Boolean result while still executing the // assignment of the formatter. where ((msg.Formatter = messageFormatter) == messageFormatter) && int.Parse(msg.Label) < 5 && msg.Body.ToString().Contains(\"CSharpRecipes.D\") orderby msg.Body.ToString() descending select msg; // check our results for messages with a label > 5 and containing // a 'D' in the name foreach (var msg in query) Console.WriteLine($\"Label: {msg.Label}\" + $\" Body: {msg.Body}\"); } The query retrieves the data from the by selecting the messages where the is a number greater than 5 and the message body contains the text “CSharpRecipes.D”. These messages are then returned, sorted by the message body in descending order. There are a number of keywords in this LINQ code that were not previously used to access a message queue: instructs the compiler to infer the variable type from the right side of the statement. In essence, the variable type is determined by what is on the right side of the operator, separating the keyword and the expression. This allows for implicitly typed local variables. The keyword sets out the source collection to query against and a range variable to represent a single element from that collection. It is always the first clause in a query operation. This may seem counterintuitive if you are used to SQL and expect to be first, but if you consider that we need to know what to work on before we determine what to return, it makes sense. In fact, if we weren’t already used to how SQL works, it would be SQL that seems counterintuitive. The keyword specifies the constraints by which the elements to return are filtered. Each condition must evaluate to a Boolean result, and when all expressions evaluate to , the element of the collection is allowed to be selected. indicates that the result set should be sorted according to the criteria specified. The default order is ascending, and elements use the default comparer. allows the projection of an entire element from the collection, the construction of a new type with parts of that element and other calculated values, or a subcollection of items into the result. The collection is of type , which implements the interface. This is important, as the LINQ methods provided need a set or collection to implement at least in order to work with that set or collection. It is possible to implement a set of extension methods that do not need , but most people will not have the need to do so. It is even better when the set or collection implements , as LINQ then knows the type of element in the set or collection with which it is working. Even though implements the interface (but not ), the original implementation of had some problems, so now if you try to use it, it doesn’t actually enumerate any results. You will also get a deprecation warning reading This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead. if you try to use on . To address this, we have created the , which derives from but uses the suggested method to implement both and . So we can just use the instance with LINQ: public class EnumerableMessageQueue : MessageQueue, IEnumerable<Message> { public EnumerableMessageQueue() : base() { } public EnumerableMessageQueue(string path) : base(path) { } public EnumerableMessageQueue(string path, bool sharedModeDenyReceive) : base (path, sharedModeDenyReceive) { } public EnumerableMessageQueue(string path, QueueAccessMode accessMode) : base (path, accessMode) { } public EnumerableMessageQueue(string path, bool sharedModeDenyReceive, bool enableCache) : base (path, sharedModeDenyReceive, enableCache) { } public EnumerableMessageQueue(string path, bool sharedModeDenyReceive, bool enableCache, QueueAccessMode accessMode) : base (path, sharedModeDenyReceive, enableCache, accessMode) { } public static new EnumerableMessageQueue Create(string path) => Create(path, false); public static new EnumerableMessageQueue Create(string path, bool transactional) { // Use MessageQueue directly to make sure the queue exists if (!MessageQueue.Exists(path)) MessageQueue.Create(path, transactional); // create the enumerable queue once we know it is there return new EnumerableMessageQueue(path); } public new MessageEnumerator GetMessageEnumerator() { throw new NotSupportedException(\"Please use GetEnumerator\"); } public new MessageEnumerator GetMessageEnumerator2() { throw new NotSupportedException(\"Please use GetEnumerator\"); } IEnumerator<Message> IEnumerable<Message>.GetEnumerator() { //NOTE: In .NET 3.5, you used to be able to call \"GetEnumerator\" on //MessageQueue via normal LINQ semantics and have it work. Now we //have to call GetMessageEnumerator2, as GetEnumerator has been //deprecated. Now we use EnumerableMessageQueue which deals with //this for us... MessageEnumerator messageEnumerator = base.GetMessageEnumerator2(); while (messageEnumerator.MoveNext()) { yield return messageEnumerator.Current; } } IEnumerator IEnumerable.GetEnumerator() { //NOTE: In .NET 3.5, you used to be able to call \"GetEnumerator\" on //MessageQueue via normal LINQ semantics and have it work. Now we have // to call GetMessageEnumerator2, as GetEnumerator has been deprecated. //Now we use EnumerableMessageQueue which deals with this for us... MessageEnumerator messageEnumerator = base.GetMessageEnumerator2(); while (messageEnumerator.MoveNext()) { yield return messageEnumerator.Current; } } } Now the query provides the element type , as shown in the line in the LINQ query: In the Solution, the messages in the queue have been sent with . To be able to query against them correctly, the property must be set on each before it is examined as part of the clause: // The first assignment to msg.Formatter is so that we can touch the // Message object. It assigns the BinaryMessageFormatter to each message // instance so that it can be read to determine if it matches the criteria. // This is done, and then it checks that the formatter was correctly assigned // by performing an equality check, which satisfies the where clause's need // for a boolean result, while still executing the assignment of the formatter. where ((msg.Formatter = messageFormatter) == messageFormatter) && There are two uses of the keyword in the Solution code: var query = from Message msg in messageQueue ... foreach (var msg in query) ... The first usage infers that an will be returned and assigned to the variable. The second usage infers that the type of is because the variable is of type and the variable is an element from that . It is also worth noting that when performing operations in a query, you can use actual C# code to determine the conditions, and there is more than just the predetermined set of operators. In the clause of this query, both and . are used to help filter messages: Finally, the is used to sort the results in descending order: Recipe 4.9, and the “MessageQueue class,” “Implicitly typed local variable,” “from keyword,” “where keyword,” “orderby keyword,” and “select keyword” topics in the MSDN documentation.\n\nYou would like to work with your collections using set operations for union, intersections, exceptions, and distinct items. Use the set operators provided as part of the standard query operators to perform those operations. Console.WriteLine(\"Employees on only one project\"); var onlyProjectEmployees = allProjectEmployees.Except(unionIntersect); The standard query operators are the set of methods that represent the LINQ pattern. This set includes operators to perform many different types of operations, such as filtering, projection, sorting, grouping, and many others, including set operations. The set operations for the standard query operators are: The operator extracts all nonduplicate items from the collection or result set being worked with. Say, for example, that we had a set of strings representing today’s login and logout behavior for a virtual machine in a common use development environment: string[] dailySecurityLog = { \"Rakshit logged in\", \"Aaron logged in\", \"Rakshit logged out\", \"Ken logged in\", \"Rakshit logged in\", \"Mahesh logged in\", \"Jesse logged in\", \"Jason logged in\", \"Josh logged in\", \"Melissa logged in\", \"Rakshit logged out\", \"Mary-Ellen logged out\", \"Mahesh logged in\", \"Alex logged in\", \"Scott logged in\", \"Aaron logged out\", \"Jesse logged out\", \"Scott logged out\", \"Dave logged in\", \"Ken logged out\", \"Alex logged out\", \"Rakshit logged in\", \"Dave logged out\", \"Josh logged out\", \"Jason logged out\"}; From that collection, we would like to determine the list of people who logged in to the virtual machine today. Since people can log in and log out many times during the course of a day or remain logged in for the whole day, we need to eliminate the duplicate login entries. is an extension method on the class (which implements the standard query operators) that we can call on the string array (which supports ) in order to get the distinct set of items from the collection. (For more information on extension methods, see Recipe 4.4.) To get the set, we use another of the standard query operators, , which takes a lambda expression that determines the filter criteria for the set and examines each string in the to determine if the string has “logged in.” Lambda expressions are inline statements (similar to anonymous methods) that can be used in place of a delegate. (See Recipe 4.12 for more on lambda expressions.) If the strings have logged in, then they are selected. narrows down the set of strings further to eliminate duplicate “logged in” records, leaving only one per user: IEnumerable<string> whoLoggedIn = dailySecurityLog.Where( logEntry => logEntry.Contains(\"logged in\")).Distinct(); Console.WriteLine(\"Everyone who logged in today:\"); foreach (string who in whoLoggedIn) Console.WriteLine(who); To make things a bit more interesting, for the rest of the operators we will work with sets of employees on various projects in a company. An is a pretty simple class with a and overrides for , , and , as shown here: You might wonder why and are overloaded for such a simple class. The reason is that when LINQ compares elements in the sets or collections, it uses the default comparison, which in turn uses and to determine if one instance of a reference type is the same as another. If you do not include the semantics in the reference type class to provide the same hash code or equals value when the data for two instances of the object is the same, then by default the instances will be different, as two reference types have different hash codes by default. We override that so that if the is the same for each , the hash code and the equals value will both correctly identify the instances as the same. There are also overloads for the set operators that take a custom comparer, which would also allow you to make this determination even for classes for which you can’t make the changes to and . Having done this, we can now assign s to projects like so: Employee[] project1 = { new Employee(){ Name = \"Rakshit\" }, new Employee(){ Name = \"Jason\" }, new Employee(){ Name = \"Josh\" }, new Employee(){ Name = \"Melissa\" }, new Employee(){ Name = \"Aaron\" }, new Employee() { Name = \"Dave\" }, new Employee() {Name = \"Alex\" } }; Employee[] project2 = { new Employee(){ Name = \"Mahesh\" }, new Employee() {Name = \"Ken\" }, new Employee() {Name = \"Jesse\" }, new Employee(){ Name = \"Melissa\" }, new Employee(){ Name = \"Aaron\" }, new Employee(){ Name = \"Alex\" }, new Employee(){ Name = \"Mary-Ellen\" } }; Employee[] project3 = { new Employee(){ Name = \"Mike\" }, new Employee(){ Name = \"Scott\" }, new Employee(){ Name = \"Melissa\" }, new Employee(){ Name = \"Aaron\" }, new Employee(){ Name = \"Alex\" }, new Employee(){ Name = \"Jon\" } }; To find all s on all projects, we can use to get all nonduplicate s in all three projects and write them out, as will give you all distinct s of all three projects: // Union Console.WriteLine(\"Employees for all projects\"); var allProjectEmployees = project1.Union(project2.Union(project3)); foreach (Employee employee in allProjectEmployees) Console.WriteLine(employee); We can then use to get the s on every project, as will determine the common s from each project and return those: // Intersect Console.WriteLine(\"Employees on every project\"); var everyProjectEmployees = project1.Intersect(project2.Intersect(project3)); foreach (Employee employee in everyProjectEmployees) Console.WriteLine(employee); Finally, we can use a combination of and to find s that are on only one project, as filters out all s on more than one project: // Except var intersect1_3 = project1.Intersect(project3); var intersect1_2 = project1.Intersect(project2); var intersect2_3 = project2.Intersect(project3); var unionIntersect = intersect1_2.Union(intersect1_3).Union(intersect2_3); Console.WriteLine(\"Employees on only one project\"); var onlyProjectEmployees = allProjectEmployees.Except(unionIntersect); foreach (Employee employee in onlyProjectEmployees) Console.WriteLine(employee); Output for the code shown is: Everyone who logged in today: Rakshit logged in Aaron logged in Ken logged in Mahesh logged in Jesse logged in Jason logged in Josh logged in Melissa logged in Alex logged in Scott logged in Dave logged in Employees for all projects Rakshit Jason Josh Melissa Aaron Dave Alex Mahesh Ken Jesse Mary-Ellen Mike Scott Jon Employees on every project Melissa Aaron Alex Employees on only one project Rakshit Jason Josh Dave Mahesh Ken Jesse Mary-Ellen Mike Scott Jon The “Standard Query Operators,” “Distinct method,” “Union method,” “Intersect method,” and “Except method” topics in the MSDN documentation.\n\nYou want to be able to take a data set from a database and represent it as XML. Use LINQ to Entities and LINQ to XML to retrieve and transform the data all in one query. In this case, we will select the top five customers in the Northwind database whose contact is the owner and those owners who placed orders totaling more than $10,000, then create XML containing the company name, contact name, phone number, and total amount of the orders. Finally, the results are written out to the BigSpenders.xml file: NorthwindEntities dataContext = new NorthwindEntities(); // Log the generated SQL to the console dataContext.Database.Log = Console.WriteLine; // select the top 5 customers whose contact is the owner and // those owners placed orders spending more than $10000 this year var bigSpenders = new XElement(\"BigSpenders\", from top5 in ( (from customer in ( from c in dataContext.Customers // get the customers where the contact is the // owner and they placed orders where c.ContactTitle.Contains(\"Owner\") && c.Orders.Count > 0 join orderData in ( from c in dataContext.Customers // get the customers where the contact is the // owner and they placed orders where c.ContactTitle.Contains(\"Owner\") && c.Orders.Count > 0 from o in c.Orders // get the order details join od in dataContext.Order_Details on o.OrderID equals od.OrderID select new { c.CompanyName, c.CustomerID, o.OrderID, // have to calc order value from orderdetails //(UnitPrice*Quantity as Total)- // (Total*Discount) as NetOrderTotal NetOrderTotal = ( (((double)od.UnitPrice) * od.Quantity) - ((((double)od.UnitPrice) * od.Quantity) * od.Discount)) } ) on c.CustomerID equals orderData.CustomerID into customerOrders select new { c.CompanyName, c.ContactName, c.Phone, // Get the total amount spent by the customer TotalSpend = customerOrders.Sum(order => order.NetOrderTotal) } ) // only worry about customers that spent > 10000 where customer.TotalSpend > 10000 orderby customer.TotalSpend descending // only take the top 5 spenders select new { CompanyName = customer.CompanyName, ContactName = customer.ContactName, Phone = customer.Phone, TotalSpend = customer.TotalSpend }).Take(5) ).ToList() // format the data as XML select new XElement(\"Customer\", new XAttribute(\"companyName\", top5.CompanyName), new XAttribute(\"contactName\", top5.ContactName), new XAttribute(\"phoneNumber\", top5.Phone), new XAttribute(\"amountSpent\", top5.TotalSpend))); using (XmlWriter writer = XmlWriter.Create(\"BigSpenders.xml\")) { bigSpenders.WriteTo(writer); } When building larger queries, you may find it is sometimes easier to use the functional approach ( ) to build up the query instead of the query expression manner ( ) if you have done more C# than SQL. LINQ to SQL is the part of LINQ to ADO.NET that facilitates rapid database development. It is targeted at the scenarios where you want to program almost directly against the database schema. Most of these scenarios have one-to-one correlations between strongly typed classes and database tables. If you are in more of an enterprise development scenario with lots of stored procedures and databases that have moved away from “one table equals one entity” scenarios, you would want to look into LINQ to Entities. You can access the LINQ to SQL visual designer by adding a new or opening an existing “LINQ to SQL Classes” item (*.dbml file) to the project, which opens the designer. This helps you to build out the and entity classes for your database, which can then be used with LINQ (or other programming constructs if you wish). A is analogous to an ADO.NET and object rolled into one. You use it to establish your connection, execute queries, or access tables directly via entity classes. The data context is a strongly typed instance of a and is partially shown here: public partial class NorthwindLinq2SqlDataContext : System.Data.Linq.DataContext { private static System.Data.Linq.Mapping.MappingSource mappingSource = new AttributeMappingSource(); #region Extensibility Method Definitions partial void OnCreated(); partial void InsertCategory(Category instance); partial void UpdateCategory(Category instance); partial void DeleteCategory(Category instance); partial void InsertTerritory(Territory instance); partial void UpdateTerritory(Territory instance); partial void DeleteTerritory(Territory instance); partial void InsertCustomerCustomerDemo(CustomerCustomerDemo instance); partial void UpdateCustomerCustomerDemo(CustomerCustomerDemo instance); partial void DeleteCustomerCustomerDemo(CustomerCustomerDemo instance); partial void InsertCustomerDemographic(CustomerDemographic instance); partial void UpdateCustomerDemographic(CustomerDemographic instance); partial void DeleteCustomerDemographic(CustomerDemographic instance); partial void InsertCustomer(Customer instance); partial void UpdateCustomer(Customer instance); partial void DeleteCustomer(Customer instance); partial void InsertEmployee(Employee instance); partial void UpdateEmployee(Employee instance); partial void DeleteEmployee(Employee instance); partial void InsertEmployeeTerritory(EmployeeTerritory instance); partial void UpdateEmployeeTerritory(EmployeeTerritory instance); partial void DeleteEmployeeTerritory(EmployeeTerritory instance); partial void InsertOrder_Detail(Order_Detail instance); partial void UpdateOrder_Detail(Order_Detail instance); partial void DeleteOrder_Detail(Order_Detail instance); partial void InsertOrder(Order instance); partial void UpdateOrder(Order instance); partial void DeleteOrder(Order instance); partial void InsertProduct(Product instance); partial void UpdateProduct(Product instance); partial void DeleteProduct(Product instance); partial void InsertRegion(Region instance); partial void UpdateRegion(Region instance); partial void DeleteRegion(Region instance); partial void InsertShipper(Shipper instance); partial void UpdateShipper(Shipper instance); partial void DeleteShipper(Shipper instance); partial void InsertSupplier(Supplier instance); partial void UpdateSupplier(Supplier instance); partial void DeleteSupplier(Supplier instance); #endregion public NorthwindLinq2SqlDataContext() : base( global::NorthwindLinq2Sql.Properties.Settings.Default.NorthwindConnectionString, mappingSource) { OnCreated(); } public NorthwindLinq2SqlDataContext(string connection) : base(connection, mappingSource) { OnCreated(); } public NorthwindLinq2SqlDataContext(System.Data.IDbConnection connection) : base(connection, mappingSource) { OnCreated(); } public NorthwindLinq2SqlDataContext(string connection, System.Data.Linq.Mapping.MappingSource mappingSource) : base(connection, mappingSource) { OnCreated(); } public NorthwindLinq2SqlDataContext(System.Data.IDbConnection connection, System.Data.Linq.Mapping.MappingSource mappingSource) : base(connection, mappingSource) { OnCreated(); } public System.Data.Linq.Table<Category> Categories { get { return this.GetTable<Category>(); } } public System.Data.Linq.Table<Territory> Territories { get { return this.GetTable<Territory>(); } } public System.Data.Linq.Table<CustomerCustomerDemo> CustomerCustomerDemos { get { return this.GetTable<CustomerCustomerDemo>(); } } public System.Data.Linq.Table<CustomerDemographic> CustomerDemographics { get { return this.GetTable<CustomerDemographic>(); } } public System.Data.Linq.Table<Customer> Customers { get { return this.GetTable<Customer>(); } } public System.Data.Linq.Table<Employee> Employees { get { return this.GetTable<Employee>(); } } public System.Data.Linq.Table<EmployeeTerritory> EmployeeTerritories { get { return this.GetTable<EmployeeTerritory>(); } } public System.Data.Linq.Table<Order_Detail> Order_Details { get { return this.GetTable<Order_Detail>(); } } public System.Data.Linq.Table<Order> Orders { get { return this.GetTable<Order>(); } } public System.Data.Linq.Table<Product> Products { get { return this.GetTable<Product>(); } } public System.Data.Linq.Table<Region> Regions { get { return this.GetTable<Region>(); } } public System.Data.Linq.Table<Shipper> Shippers { get { return this.GetTable<Shipper>(); } } public System.Data.Linq.Table<Supplier> Suppliers { get { return this.GetTable<Supplier>(); } } } The entity class definitions for the Northwind database are all present in the generated code as well, with each table having an entity class defined for it. The entity classes are indicated by the attribute with no parameters. This means that the name of the entity class matches the table name: [global::System.Data.Linq.Mapping.TableAttribute(Name=\"dbo.Customers\")] public partial class Customer : INotifyPropertyChanging, INotifyPropertyChanged { private static PropertyChangingEventArgs emptyChangingEventArgs = new PropertyChangingEventArgs(String.Empty); private string _CustomerID; private string _CompanyName; private string _ContactName; private string _ContactTitle; private string _Address; private string _City; private string _Region; private string _PostalCode; private string _Country; private string _Phone; private string _Fax; private EntitySet<CustomerCustomerDemo> _CustomerCustomerDemos; private EntitySet<Order> _Orders; #region Extensibility Method Definitions partial void OnLoaded(); partial void OnValidate(System.Data.Linq.ChangeAction action); partial void OnCreated(); partial void OnCustomerIDChanging(string value); partial void OnCustomerIDChanged(); partial void OnCompanyNameChanging(string value); partial void OnCompanyNameChanged(); partial void OnContactNameChanging(string value); partial void OnContactNameChanged(); partial void OnContactTitleChanging(string value); partial void OnContactTitleChanged(); partial void OnAddressChanging(string value); partial void OnAddressChanged(); partial void OnCityChanging(string value); partial void OnCityChanged(); partial void OnRegionChanging(string value); partial void OnRegionChanged(); partial void OnPostalCodeChanging(string value); partial void OnPostalCodeChanged(); partial void OnCountryChanging(string value); partial void OnCountryChanged(); partial void OnPhoneChanging(string value); partial void OnPhoneChanged(); partial void OnFaxChanging(string value); partial void OnFaxChanged(); #endregion public Customer() { this._CustomerCustomerDemos = new EntitySet<CustomerCustomerDemo>(new Action<CustomerCustomerDemo>(this.attach_CustomerCustomerDemos), new Action<CustomerCustomerDemo>(this.detach_CustomerCustomerDemos)); this._Orders = new EntitySet<Order>( new Action<Order>(this.attach_Orders), new Action<Order>(this.detach_Orders)); OnCreated(); } public event PropertyChangingEventHandler PropertyChanging; public event PropertyChangedEventHandler PropertyChanged; protected virtual void SendPropertyChanging() { if ((this.PropertyChanging != null)) { this.PropertyChanging(this, emptyChangingEventArgs); } } protected virtual void SendPropertyChanged(String propertyName) { if ((this.PropertyChanged != null)) { this.PropertyChanged(this, new PropertyChangedEventArgs(propertyName)); } } The standard property change notifications are implemented via and and have and events for conveying the change to a property. There is also a set of partial methods that will report when a specific property is modified on this entity class if they are implemented in another partial class definition for the entity class. Many of the classes generated by Microsoft .NET are generated as partial classes. This is so that you can extend them in your own partial class and add methods and properties to the class without being in danger of the code generator stomping on your code the next time it is regenerated. In this case, if no other partial class definition is found, the compiler will remove those notifications. Partial methods enable the declaration of a method signature in one file of a partial class declaration and the implementation of the method in another. If the signature is found but the implementation is not, the signature is removed by the compiler. The properties in the entity class match up to the columns in the database via the attribute, where the value is the database column name and the value is the internal storage for the class of the data. Events for the property changes are wired into the setter for the property: [global::System.Data.Linq.Mapping.ColumnAttribute(Storage=\"_CompanyName\", DbType=\"NVarChar(40) NOT NULL\", CanBeNull=false)] public string CompanyName { get { return this._CompanyName; } set { if ((this._CompanyName != value)) { this.OnCompanyNameChanging(value); this.SendPropertyChanging(); this._CompanyName = value; this.SendPropertyChanged(\"CompanyName\"); this.OnCompanyNameChanged(); } } } For a one-to-many child relationship, an of the child entity class is declared with an attribute. The attribute specifies the relationship information between the parent and child entity classes, as shown here for the property on : LINQ to SQL covers much more than what has been shown here, and we encourage you to investigate it more. Now, however, let’s move on to the other data domain we are dealing with: LINQ to XML. LINQ to XML is not only how you perform queries against XML, it is also a more developer-friendly way to work with XML. One of the main classes in LINQ to XML is , which allows you to create XML in a manner that more closely resembles the structure of the XML itself. This may not seem like a big deal, but when you can see the XML taking shape in your code, it’s easier to know where you are. (Ever forget which you were on? We have!) You can get more details and examples about using in Chapter 10, so we won’t go much further into it here, but as you can see, it is very easy to build up XML in a query. The first part of the query deals with setting up the main XML element, , and getting the initial set of customers where the contact is the owner: var bigSpenders = new XElement(\"BigSpenders\", from top5 in ( (from customer in ( from c in dataContext.Customers // get the customers where the contact is the owner // and they placed orders where c.ContactTitle.Contains(\"Owner\") && c.Orders.Count > 0 The middle of the query deals with joining the order and order detail information with the customer information to get the for the order. It also creates order data containing that value, the customer and order IDs, and the company name. We need the in the last part of the query, so stay tuned! join orderData in ( from c in dataContext.Customers // get the customers where the contact is the owner // and they placed orders where c.ContactTitle.Contains(\"Owner\") && c.Orders.Count > 0 from o in c.Orders // get the order details join od in dataContext.OrderDetails on o.OrderID equals od.OrderID select new { c.CompanyName, c.CustomerID, o.OrderID, // have to calc order value from orderdetails //(UnitPrice*Quantity as Total) (Total*Discount) // as NetOrderTotal NetOrderTotal = ( (((double)od.UnitPrice) * od.Quantity) - ((((double)od.UnitPrice) * od.Quantity) * od.Discount)) } ) on c.CustomerID equals orderData.CustomerID into customerOrders The last part of the query determines the for that customer across all orders using the function on for the generated collection. Finally, the query selects only the top five customers with a value greater than 10,000 by using the function. ( is the equivalent to in SQL.) We then use those records to construct one inner element with attributes that nest inside the root element we set up in the first part of the query: select new { c.CompanyName, c.ContactName, c.Phone, // Get the total amount spent by the customer TotalSpend = customerOrders.Sum(order => order. NetOrderTotal) } ) // only worry about customers that spent > 10000 where customer.TotalSpend > 10000 orderby customer.TotalSpend descending // only take the top 5 spenders select customer).Take(5) ) // format the data as XML select new XElement(\"Customer\", new XAttribute(\"companyName\", top5.CompanyName), new XAttribute(\"contactName\", top5.ContactName), new XAttribute(\"phoneNumber\", top5.Phone), new XAttribute(\"amountSpent\", top5.TotalSpend))); It is much easier to build large-nested queries as individual queries first and then put them together once you are sure the inner query is working. At this point, for all of the code here, nothing has happened yet. That’s right: until the query is accessed, nothing happens because of the magic of deferred execution. LINQ has constructed a query expression, but nothing has talked to the database; there is no XML in memory, nada. Once the method is called on the query expression, the query is evaluated by LINQ to SQL, and the XML is constructed. The method writes out the constructed XML to the provided, and we are done: If you are interested in what that SQL will look like, connect the property to a (like the console): // Log the generated SQL to the console dataContext.Log = Console.Out; This query generates SQL that looks like this: Generated SQL for query - output via DataContext.Log SELECT [t10].[CompanyName], [t10].[ContactName], [t10].[Phone], [t10].[TotalSpend] FROM ( SELECT TOP (5) [t0].[Company Name] AS [CompanyName], [t0].[Contact Name] AS [ContactName], [t0].[Phone], [t9].[value] AS [TotalSpend] FROM [Customers] AS [t0] OUTER APPLY ( SELECT COUNT(*) AS [value] FROM [Orders] AS [t1] WHERE [t1].[Customer ID] = [t0].[Customer ID] ) AS [t2] OUTER APPLY ( SELECT SUM([t8].[value]) AS [value] FROM ( SELECT [t3].[Customer ID], [t6].[Order ID], ([t7].[Unit Price] * (CONVERT(Decimal(29,4),[t7].[Quantity]))) - ([t7].[Unit Price] * (CONVERT(Decimal(29,4),[t7].[Quantity])) * (CONVERT(Decimal(29,4),[t7].[Discount]))) AS [value], [t7].[Order ID] AS [Order ID2], [t3].[Contact Title] AS [ContactTitle], [t5].[value] AS [value2], [t6].[Customer ID] AS [CustomerID] FROM [Customers] AS [t3] OUTER APPLY ( SELECT COUNT(*) AS [value] FROM [Orders] AS [t4] WHERE [t4].[Customer ID] = [t3].[Customer ID] ) AS [t5] CROSS JOIN [Orders] AS [t6] CROSS JOIN [Order Details] AS [t7] ) AS [t8] WHERE ([t0].[Customer ID] = [t8].[Customer ID]) AND ([t8].[Order ID] = [ t8].[Order ID2]) AND ([t8].[ContactTitle] LIKE @p0) AND ([t8].[value2] > @p1) AN D ([t8].[CustomerID] = [t8].[Customer ID]) ) AS [t9] WHERE ([t9].[value] > @p2) AND ([t0].[Contact Title] LIKE @p3) AND ([t2].[va lue] > @p4) ORDER BY [t9].[value] DESC ) AS [t10] ORDER BY [t10].[TotalSpend] DESC -- @p0: Input String (Size = 0; Prec = 0; Scale = 0) [%Owner%] -- @p1: Input Int32 (Size = 0; Prec = 0; Scale = 0) [0] -- @p2: Input Decimal (Size = 0; Prec = 29; Scale = 4) [10000] -- @p3: Input String (Size = 0; Prec = 0; Scale = 0) [%Owner%] -- @p4: Input Int32 (Size = 0; Prec = 0; Scale = 0) [0] -- Context: SqlProvider(SqlCE) Model: AttributedMetaModel Build: 3.5.20706.1 The “The Three Parts of a LINQ Query,” “DataContext.Log, property,” “DataContext class,” “XElement class,” and “LINQ to SQL” topics in the MSDN documentation.\n\nC# includes a feature called lambda expressions. While you can view lambda expressions as syntactic sugar for making anonymous method definition less difficult, you also want to understand all of the different ways that you can use them to help you in your daily programming chores as well as the ramifications of those uses. Lambda expressions can be implemented by the compiler from methods created by the developer. There are two orthogonal characteristics that lambda expressions may have:\n• Parameter lists may have explicit or implicit types.\n• Bodies may be expressions or statement blocks. Let’s start with the original way to use delegates. First, you would declare a delegate type— in this case—and then create an instance of it (as shown here in the method). Declaring the instance of the delegate requires that you specify a method to execute when the delegate is invoked, and here the method has been connected. The delegate is invoked, and the text is written to the console via the method: class OldWay { // declare delegate delegate int DoWork(string work); // have a method to create an instance of and call the delegate public void WorkItOut() { // declare instance DoWork dw = new DoWork(DoWorkMethodImpl); // invoke delegate int i = dw(\"Do work the old way\"); } // Have a method that the delegate is tied to with a matching signature // so that it is invoked when the delegate is called public int DoWorkMethodImpl(string s) { Console.WriteLine(s); return s.GetHashCode(); } } Lambda expressions allow you to set up code to run when a delegate is invoked, but you do not need to give a named formal method declaration to the delegate. The method thus declared is nameless and closed over the scope of the outer method. For example, you could have written the preceding code using a lambda expression such as this: class LambdaWay { // declare delegate delegate int DoWork(string work); // have a method to create an instance of and call the delegate public void WorkItOut() { // declare instance DoWork dw = s => { Console.WriteLine(s); return s.GetHashCode(); }; // invoke delegate int i = dw(\"Do some inline work\"); } } Notice that instead of having a method called , you use the operator to directly assign the code from that method inline to the delegate. The assignment looks like this: You also provide the parameter required by the delegate ( ), and your code returns an ( ) as the delegate requires. When you’re setting up a lambda expression, the code must match the delegate signature, or you will get a compiler error.\n• If explicitly typed, the lambda parameters must exactly match the delegate parameters. If implicitly typed, the lambda parameters get the delegate parameter types.\n• The body of the lambda must be a legal expression or statement block given the parameter types.\n• The return type of the lambda must be implicitly convertible to the return type of the delegate. It need not match exactly. There is yet another way you can set up the delegate: through the magic of delegate inference. Delegate inference allows you to assign the method name directly to the delegate instance without having to write the code to create a new delegate object. Under the covers, C# actually writes the IL for creating the delegate object, but you don’t have to do it explicitly here. Using delegate inference instead of writing out everywhere helps to unclutter the code involved in delegate use, as shown here: class DirectAssignmentWay { // declare delegate delegate int DoWork(string work); // have a method to create an instance of and call the delegate public void WorkItOut() { // declare instance and assign method DoWork dw = DoWorkMethodImpl; // invoke delegate int i = dw(\"Do some direct assignment work\"); } // Have a method that the delegate is tied to with a matching signature // so that it is invoked when the delegate is called public int DoWorkMethodImpl(string s) { Console.WriteLine(s); return s.GetHashCode(); } } Notice that all that is assigned to the delegate instance is the method name . There is no call as there was in older C# code. Remember, the underlying delegate wrapper does not go away; delegate inference just simplifies the syntax a bit by hiding some of it. Alternatively, you can also set up lambda expressions that take generic type parameters to enable working with generic delegates, as you see here in the class: class GenericWay { // have a method to create two instances of and call the delegates public void WorkItOut() { Func<string, string> dwString = s => { Console.WriteLine(s); return s; }; // invoke string delegate string retStr = dwString(\"Do some generic work\"); Func<int, int> dwInt = i => { Console.WriteLine(i); return i; }; // invoke int delegate int j = dwInt(5); } } One of the useful things about lambda expressions is the concept of outer variables. The official definition of outer variable is any local variable, value parameter, or parameter array with a scope that contains the lambda expression. This means that, inside the code of the lambda expression, you can touch variables outside the scope of that method. This introduces the concept of “capturing” the variables, which occurs when a lambda expression actually makes reference to one of the outer variables. In the following example, the variable is captured and incremented by the lambda expression. The variable is not part of the original scope of the lambda expression but rather part of the outer scope. It is incremented, and then the incremented value is returned and totaled: What capturing actually does is extend the lifetime of the outer variable to coincide with the lifetime of the underlying delegate instance that represents the lambda expression. This should encourage you to be careful about what you touch from inside a lambda expression. You could be causing things to hang around a lot longer than you originally planned. The garbage collector won’t get a chance to clean up those outer variables until later, when they are used in the lambda expression. Capturing outer variables has another garbage-collector effect: when locals or value parameters are captured, they are no longer considered to be fixed but are now movable, so any unsafe code must now fix that variable—via the keyword—before the variable is used. Outer variables can affect how the compiler generates the internal IL for the lambda expression. If the lambda expression uses outer variables, the lambda expression is generated as a private method of a nested class. If the lambda expression does not use outer variables, it would be generated as another private method of the class in which it is declared. If the outer method is static, then the lambda expression cannot access instance members via the keyword, as the nested class will also be generated as static. There are two types of lambda expressions: expression lambdas and statement lambdas. This expression lambda has no parameters and simply increments the variable in an expression: Statement lambdas have the body enclosed in curly braces and can contain any number of statements like this: A few last things to remember about lambda expressions:\n• They can’t use , , or to jump from the lambda expression to a target outside the lambda expression block.\n• No unsafe code can be executed inside a lambda expression.\n• Lambda expressions cannot be used on the left side of the operator.\n• Since lambda expressions are a superset of anonymous methods, all restrictions that apply to anonymous methods also apply to lambda expressions. The “Lambda Expressions (C# Programming Guide)” topic in the MSDN documentation.\n\n4.13 Using Different Parameter Modifiers in Lambda Expressions You know you can pass parameters to lambda expressions, but you need to figure out what parameter modifiers are valid with them. Lambda expressions can use and parameter modifiers but not the modifier in their parameter list. However, this does not prevent the creation of delegates with any of these modifiers, as shown here: Even though the delegate is defined with the keyword on the parameter, it can still be used as a type for a lambda expression, as you’ll see in a bit. To use the delegate, create a lambda expression inline using the keyword and assign it to the delegate instance. Inside the lambda expression body, the variable is assigned a value first (as it doesn’t have one by definition as an parameter), writes it to the console, and returns the string hash code. Note that in the parameter list, you must provide the type of (i.e., ), as type is not inferred for variables marked with the or keywords. It is not inferred for or variables to preserve the representation at the call site and the parameter declaration site to help the developer clearly reason about the possible assignment to these variables: To run the lambda expression code, invoke the delegate with an parameter, and then print out the result to the console: To use the parameter modifier in a lambda expression, create an inline method to hook up to the delegate with a parameter. In the method, you write the original value , reassign the value, and get the hash code of the new value. Remember that, as with the keyword, you must provide the type of ( ) in the parameter list, as type cannot be inferred for a variable marked with the keyword: To run the lambda expression, assign a value to the string and then pass it as a parameter to the delegate that is instantiated. Upon the return from the delegate call, write out the new value for the string: While it is possible to declare a delegate with the modifier, you cannot hook up the delegate using a lambda expression with the keyword in the parameter list. If you try this, the compiler displays the CS1670 params is not valid in this context compiler error on the line: ////Done as an lambda expression you also get ////CS1670 \"params is not valid in this context\" //DoParamsWork dpwl = (params object[] workItems) => //{ // foreach (object o in workItems) // { // Console.WriteLine(o.ToString()); // } // return workItems.GetHashCode(); //}; Even if you attempt this using an anonymous method instead of a lambda expression, you still cannot hook up this delegate with the keyword in the parameter list. If you try, the compiler still displays the CS1670 params is not valid in this context compiler error on the line: //Done as an anonymous method you get CS1670 \"params is not valid in this context\" //DoParamsWork dpwa = delegate (params object[] workItems) //{ // foreach (object o in workItems) // { // Console.WriteLine(o.ToString()); // } // return workItems.GetHashCode(); //}; You can, however, omit the keyword and still set up the lambda expression for the delegate, as shown here: // All we have to do is omit the params keyword. DoParamsWork dpw = workItems => { foreach (object o in workItems) Console.WriteLine(o.ToString()); return workItems.GetHashCode(); }; Notice that although you’ve removed the keyword from the lambda expression, this doesn’t stop you from using the same syntax. The keyword is present on the delegate type, so you can invoke it thusly: So this illustrates that you can bind a lambda expression to a delegate declared using , and once you’ve done that, you can invoke the lambda expression, passing in any number of parameters you like, just as you’d expect. Lambda expressions cannot access the or parameters of an outer scope. This means any or variables that were defined as part of the containing method are off-limits for use inside the body of the lambda expression: public void TestOut(out string outStr) { // declare instance DoWork dw = s => { Console.WriteLine(s); // Causes error CS1628: // \"Cannot use ref or out parameter 'outStr' inside an // anonymous method, lambda expression, or query expression\" outStr = s; return s.GetHashCode(); }; // invoke delegate int i = dw(\"DoWorkMethodImpl1\"); } public void TestRef(ref string refStr) { // declare instance DoWork dw = s => { Console.WriteLine(s); // Causes error CS1628: // \"Cannot use ref or out parameter 'refStr' inside an // anonymous method, lambda expression, or query expression\" refStr = s; return s.GetHashCode(); }; // invoke delegate int i = dw(\"DoWorkMethodImpl1\"); } Interestingly enough, lambda expressions can access outer variables with the modifier: Because the modifier is there for the benefit of the calling site (so the compiler knows to make this a method call that supports variable-length argument lists) and because lambda expressions are never called directly (they’re always called via a delegate), it makes no sense for a lambda expression to be decorated with something there for the benefit of the calling site—as there is no calling site. This is why it doesn’t matter that you can’t use the keyword on a lambda expression. For lambda expressions, the calling site is always calling through the delegate, so what matters is whether that delegate has the keyword or not. Recipe 1.17; the “CS1670,” “CS1525,” “CS1628,” “out,” “ref,” “params,” and “System.ParamArrayAttribute” topics in the MSDN documentation.\n\nYou have a LINQ query that performs an expensive operation that slows down the processing, and you would like to speed it up. Use PLINQ (Parallel LINQ) to utilize the full capacities of your machine to process the query faster. To demonstrate this, let’s consider the plight of Brooke and Katie. Brooke and Katie are working on a cookbook together and they need to evaluate all of the recipes for all of the chapters. Since there are so many recipes, they want to be able to hand off the rudimentary validation steps for the recipes and then Brooke or Katie gets a final pass at each recipe as the main editor for final fit and finish. Each has a number of s in it, and the validation steps are:\n• Read the text of the recipe for premise.\n• Check the recipe accuracy of ingredients and measurements.\n• Prepare the recipe and taste once for each rank of difficulty for the recipe.\n• Have Brooke or Katie perform the final editing pass. If any stage of the recipe evaluation fails, that stage needs to be redone unless it is the tasting stage. If a fails the tasting stage, it needs to start over. To process the collection of s (chapters in the example) with regular LINQ, we could use the following statement: is a method that performs the evaluation of the and all of the in the while timing the evaluation. is called once for each in the to perform the validation steps: In order to process the s faster, we add a call to the extension method before we call to invoke for each : Your results will vary based on your hardware, but the following times were recorded on a run using regular LINQ and then subsequently PLINQ: Full Chapter Evaluation with LINQ took: 00:01:19.1395258 Full Chapter Evaluation with PLINQ took: 00:00:25.1708103 When you’re using PLINQ, the main thing to keep in mind is that the unit of work being parallelized must be significant enough to justify the cost of the parallelization. There are additional setup and teardown costs to doing operations in parallel (like partitioning of the data set) and if the data set is too small or the operation on each member of the set is not expensive enough to be helped by using parallel techniques, you could actually perform worse. If PLINQ determines that it cannot effectively parallelize the query, it will process it sequentially. If this happens, there are a number of additional methods you can use to adjust depending upon your particular situation ( , ). As in all engineering, measuring your results is the key to understanding if you are improving or not, so with that in mind, we created the method to call from our statement: times the process of evaluating every in the and wraps that value in calls to and for timing. The timing results are then available in . Note that if you restart the without calling , the timer will add to the value already in the and you may get a bigger value than you expected: performs the validation steps on each recipe recursively until it passes the final edit from Brooke and Katie. is called to simulate work for each step: private static Recipe EvaluateRecipe(Recipe r, Random rnd) { //Recipe Editing steps if (!r.TextApproved) { //Read the recipe to make sure it makes sense Thread.Sleep(50); int evaluation = rnd.Next(1, 10); // 7 means it didn't make sense so don't approve it, // send it back for rework if (evaluation == 7) { LogOutput($\"{r} failed the readthrough! Reworking...\"); } else r.TextApproved = true; return EvaluateRecipe(r, rnd); } else if (!r.IngredientsApproved) { //Check the ingredients and measurements Thread.Sleep(100); int evaluation = rnd.Next(1, 10); // 3 means the ingredients or measurements are incorrect, // send it back for rework if (evaluation == 3) { LogOutput($\"{r} had incorrect measurements! Reworking...\"); } else r.IngredientsApproved = true; return EvaluateRecipe(r, rnd); } else if (r.RecipeEvaluated != r.Rank) { //Prepare recipe and taste Thread.Sleep(50 * r.Rank); int evaluation = rnd.Next(1, 10); // 4 means it didn't taste right, send it back for rework if (evaluation == 4) { r.TextApproved = false; r.IngredientsApproved = false; r.RecipeEvaluated = 0; LogOutput($\"{r} tasted bad! Reworking...\"); } else r.RecipeEvaluated++; return EvaluateRecipe(r, rnd); } else { //Final editing pass(Brooke or Katie) Thread.Sleep(50 * r.Rank); int evaluation = rnd.Next(1, 10); // 1 means it just wasn't quite ready, send it back for rework if (evaluation == 1) { r.TextApproved = false; r.IngredientsApproved = false; r.RecipeEvaluated = 0; LogOutput($\"{r} failed final editing! Reworking...\"); return EvaluateRecipe(r, rnd); } else { r.FinalEditingComplete = true; LogOutput($\"{r} is ready for release!\"); } } return r; } Here are the definitions of the and classes used to help Brooke and Katie evaluate all of the recipes: public class RecipeChapter { public int Number { get; set; } public string Title { get; set; } public List<Recipe> Recipes { get; set; } public override string ToString() => $\"{Number} - {Title}\"; } public class Recipe { public RecipeChapter Chapter { get; set; } public string MainIngredient { get; set; } public int Number { get; set; } public bool TextApproved { get; set; } public bool IngredientsApproved { get; set; } /// <summary> /// Recipe should be evaluated as many times as the Rank of the recipe /// </summary> public int RecipeEvaluated { get; set; } public bool FinalEditingComplete { get; set; } public int Rank { get; set; } public override string ToString() => $\"{Chapter.Number}.{Number} ({Chapter.Title}:{MainIngredient})\"; } Sample output from the LINQ run looks like this and processes the collection in sequential order: Running Cookbook Evaluation Evaluating Chapter 1 - Soups 1.1 (Soups:Sprouts, Mung Bean) is ready for release! 1.2 (Soups:Potato Bread) is ready for release! 1.3 (Soups:Chicken Liver) tasted bad! Reworking... 1.3 (Soups:Chicken Liver) is ready for release! 1.4 (Soups:Cherimoya) tasted bad! Reworking... 1.4 (Soups:Cherimoya) had incorrect measurements! Reworking... 1.4 (Soups:Cherimoya) is ready for release! 1.5 (Soups:High-Protein Bread) is ready for release! 1.6 (Soups:Flat Bread) failed the readthrough! Reworking... 1.6 (Soups:Flat Bread) is ready for release! 1.7 (Soups:Pomegranate) is ready for release! 1.8 (Soups:Carissa, Natal Plum) had incorrect measurements! Reworking... 1.8 (Soups:Carissa, Natal Plum) is ready for release! 1.9 (Soups:Ideal Flat Bread) is ready for release! 1.10 (Soups:Banana Bread) tasted bad! Reworking... 1.10 (Soups:Banana Bread) is ready for release! Finished Evaluating Chapter 1 - Soups Evaluating Chapter 2 - Salads 2.1 (Salads:Caraway) tasted bad! Reworking... 2.1 (Salads:Caraway) tasted bad! Reworking... 2.1 (Salads:Caraway) had incorrect measurements! Reworking... 2.1 (Salads:Caraway) is ready for release! 2.2 (Salads:Potatoes, Red) had incorrect measurements! Reworking... 2.2 (Salads:Potatoes, Red) tasted bad! Reworking... 2.2 (Salads:Potatoes, Red) is ready for release! 2.3 (Salads:Lemon) is ready for release! 2.4 (Salads:Cream cheese) is ready for release! 2.5 (Salads:Artichokes, Domestic) is ready for release! 2.6 (Salads:Grapefruit) is ready for release! 2.7 (Salads:Lettuce, Iceberg) is ready for release! 2.8 (Salads:Fenugreek) is ready for release! 2.9 (Salads:Ostrich) is ready for release! 2.10 (Salads:Brazil Nuts) tasted bad! Reworking... 2.10 (Salads:Brazil Nuts) had incorrect measurements! Reworking... 2.10 (Salads:Brazil Nuts) tasted bad! Reworking... 2.10 (Salads:Brazil Nuts) is ready for release! Finished Evaluating Chapter 2 - Salads Evaluating Chapter 3 - Appetizers 3.1 (Appetizers:Loquat) tasted bad! Reworking... 3.1 (Appetizers:Loquat) had incorrect measurements! Reworking... 3.1 (Appetizers:Loquat) tasted bad! Reworking... 3.1 (Appetizers:Loquat) is ready for release! 3.2 (Appetizers:Bergenost) is ready for release! 3.3 (Appetizers:Tomato Red Roma) had incorrect measurements! Reworking... 3.3 (Appetizers:Tomato Red Roma) tasted bad! Reworking... 3.3 (Appetizers:Tomato Red Roma) tasted bad! Reworking... 3.3 (Appetizers:Tomato Red Roma) is ready for release! 3.4 (Appetizers:Guava) failed final editing! Reworking... 3.4 (Appetizers:Guava) is ready for release! 3.5 (Appetizers:Squash Flower) is ready for release! 3.6 (Appetizers:Radishes, Red) is ready for release! 3.7 (Appetizers:Goose Liver) tasted bad! Reworking... 3.7 (Appetizers:Goose Liver) had incorrect measurements! Reworking... 3.7 (Appetizers:Goose Liver) is ready for release! 3.8 (Appetizers:Okra) had incorrect measurements! Reworking... 3.8 (Appetizers:Okra) is ready for release! 3.9 (Appetizers:Borage) is ready for release! 3.10 (Appetizers:Peppers) is ready for release! Finished Evaluating Chapter 3 - Appetizers Evaluating Chapter 4 - Entrees 4.1 (Entrees:Plantain) is ready for release! 4.2 (Entrees:Pignola (Pine)) is ready for release! 4.3 (Entrees:Potatoes, Gold) is ready for release! 4.4 (Entrees:Ribeye) failed the readthrough! Reworking... 4.4 (Entrees:Ribeye) is ready for release! 4.5 (Entrees:Sprouts, Mung Bean) failed the readthrough! Reworking... 4.5 (Entrees:Sprouts, Mung Bean) had incorrect measurements! Reworking... 4.5 (Entrees:Sprouts, Mung Bean) failed final editing! Reworking... 4.5 (Entrees:Sprouts, Mung Bean) is ready for release! 4.6 (Entrees:Squash) had incorrect measurements! Reworking... 4.6 (Entrees:Squash) is ready for release! 4.7 (Entrees:Squash, Winter) tasted bad! Reworking... 4.7 (Entrees:Squash, Winter) is ready for release! 4.8 (Entrees:Corn, Blue) is ready for release! 4.9 (Entrees:Snake) had incorrect measurements! Reworking... 4.9 (Entrees:Snake) tasted bad! Reworking... 4.9 (Entrees:Snake) tasted bad! Reworking... 4.9 (Entrees:Snake) is ready for release! 4.10 (Entrees:Prosciutto) is ready for release! Finished Evaluating Chapter 4 - Entrees Evaluating Chapter 5 - Desserts 5.1 (Desserts:Mushroom, White, Silver Dollar) tasted bad! Reworking... 5.1 (Desserts:Mushroom, White, Silver Dollar) had incorrect measurements! Reworking... 5.1 (Desserts:Mushroom, White, Silver Dollar) tasted bad! Reworking... 5.1 (Desserts:Mushroom, White, Silver Dollar) tasted bad! Reworking... 5.1 (Desserts:Mushroom, White, Silver Dollar) had incorrect measurements! Reworking... 5.1 (Desserts:Mushroom, White, Silver Dollar) is ready for release! 5.2 (Desserts:Eggplant) is ready for release! 5.3 (Desserts:Asparagus Peas) tasted bad! Reworking... 5.3 (Desserts:Asparagus Peas) failed the readthrough! Reworking... 5.3 (Desserts:Asparagus Peas) failed the readthrough! Reworking... 5.3 (Desserts:Asparagus Peas) is ready for release! 5.4 (Desserts:Squash, Kabocha) failed the readthrough! Reworking... 5.4 (Desserts:Squash, Kabocha) tasted bad! Reworking... 5.4 (Desserts:Squash, Kabocha) is ready for release! 5.5 (Desserts:Sprouts, Radish) is ready for release! 5.6 (Desserts:Mushroom, Black Trumpet) is ready for release! 5.7 (Desserts:Tea Cakes) tasted bad! Reworking... 5.7 (Desserts:Tea Cakes) tasted bad! Reworking... 5.7 (Desserts:Tea Cakes) failed the readthrough! Reworking... 5.7 (Desserts:Tea Cakes) is ready for release! 5.8 (Desserts:Blueberries) had incorrect measurements! Reworking... 5.8 (Desserts:Blueberries) tasted bad! Reworking... 5.8 (Desserts:Blueberries) is ready for release! 5.9 (Desserts:Sago Palm) is ready for release! 5.10 (Desserts:Opossum) had incorrect measurements! Reworking... 5.10 (Desserts:Opossum) is ready for release! Finished Evaluating Chapter 5 - Desserts Evaluating Chapter 6 - Snacks 6.1 (Snacks:Cheddar) tasted bad! Reworking... 6.1 (Snacks:Cheddar) is ready for release! 6.2 (Snacks:Melon, Bitter) is ready for release! 6.3 (Snacks:Scallion) is ready for release! 6.4 (Snacks:Squash Chayote) failed final editing! Reworking... 6.4 (Snacks:Squash Chayote) is ready for release! 6.5 (Snacks:Roasted Turkey) is ready for release! 6.6 (Snacks:Lime) is ready for release! 6.7 (Snacks:Hazelnut) is ready for release! 6.8 (Snacks:Radishes, Daikon) tasted bad! Reworking... 6.8 (Snacks:Radishes, Daikon) tasted bad! Reworking... 6.8 (Snacks:Radishes, Daikon) failed the readthrough! Reworking... 6.8 (Snacks:Radishes, Daikon) tasted bad! Reworking... 6.8 (Snacks:Radishes, Daikon) is ready for release! 6.9 (Snacks:Salami) failed the readthrough! Reworking... 6.9 (Snacks:Salami) is ready for release! 6.10 (Snacks:Mushroom, Oyster) failed the readthrough! Reworking... 6.10 (Snacks:Mushroom, Oyster) is ready for release! Finished Evaluating Chapter 6 - Snacks Evaluating Chapter 7 - Breakfast 7.1 (Breakfast:Daikon Radish) had incorrect measurements! Reworking... 7.1 (Breakfast:Daikon Radish) is ready for release! 7.2 (Breakfast:Lettuce, Red Leaf) failed final editing! Reworking... 7.2 (Breakfast:Lettuce, Red Leaf) is ready for release! 7.3 (Breakfast:Alfalfa Sprouts) is ready for release! 7.4 (Breakfast:Tea Cakes) is ready for release! 7.5 (Breakfast:Chia seed) is ready for release! 7.6 (Breakfast:Tangerine) is ready for release! 7.7 (Breakfast:Spinach) is ready for release! 7.8 (Breakfast:Flank Steak) is ready for release! 7.9 (Breakfast:Loganberries) had incorrect measurements! Reworking... 7.9 (Breakfast:Loganberries) had incorrect measurements! Reworking... 7.9 (Breakfast:Loganberries) had incorrect measurements! Reworking... 7.9 (Breakfast:Loganberries) is ready for release! 7.10 (Breakfast:Opossum) is ready for release! Finished Evaluating Chapter 7 - Breakfast Evaluating Chapter 8 - Sandwiches 8.1 (Sandwiches:Rhubarb) tasted bad! Reworking... 8.1 (Sandwiches:Rhubarb) is ready for release! 8.2 (Sandwiches:Pickle, Brine) is ready for release! 8.3 (Sandwiches:Oranges) tasted bad! Reworking... 8.3 (Sandwiches:Oranges) had incorrect measurements! Reworking... 8.3 (Sandwiches:Oranges) is ready for release! 8.4 (Sandwiches:Chayote, Pipinella, Vegetable Pear) tasted bad! Reworking... 8.4 (Sandwiches:Chayote, Pipinella, Vegetable Pear) is ready for release! 8.5 (Sandwiches:Bear) is ready for release! 8.6 (Sandwiches:Panela) had incorrect measurements! Reworking... 8.6 (Sandwiches:Panela) is ready for release! 8.7 (Sandwiches:Peppers, Red) had incorrect measurements! Reworking... 8.7 (Sandwiches:Peppers, Red) tasted bad! Reworking... 8.7 (Sandwiches:Peppers, Red) failed the readthrough! Reworking... 8.7 (Sandwiches:Peppers, Red) failed the readthrough! Reworking... 8.7 (Sandwiches:Peppers, Red) had incorrect measurements! Reworking... 8.7 (Sandwiches:Peppers, Red) tasted bad! Reworking... 8.7 (Sandwiches:Peppers, Red) is ready for release! 8.8 (Sandwiches:Oat Bread) is ready for release! 8.9 (Sandwiches:Peppers, Green) is ready for release! 8.10 (Sandwiches:Garlic) is ready for release! Finished Evaluating Chapter 8 - Sandwiches *********************************************** Full Chapter Evaluation with LINQ took: 00:01:19.1395258 *********************************************** Sample output from the PLINQ run looks like this, processes in parallel (note the evaluation of four s at the beginning), and processes items out of sequential order: Evaluating Chapter 5 - Desserts Evaluating Chapter 3 - Appetizers Evaluating Chapter 1 - Soups Evaluating Chapter 7 - Breakfast 7.1 (Breakfast:Daikon Radish) failed the readthrough! Reworking... 1.1 (Soups:Sprouts, Mung Bean) failed the readthrough! Reworking... 3.1 (Appetizers:Loquat) had incorrect measurements! Reworking... 1.1 (Soups:Sprouts, Mung Bean) had incorrect measurements! Reworking... 7.1 (Breakfast:Daikon Radish) tasted bad! Reworking... 5.1 (Desserts:Mushroom, White, Silver Dollar) tasted bad! Reworking... 3.1 (Appetizers:Loquat) failed final editing! Reworking... 7.1 (Breakfast:Daikon Radish) is ready for release! 3.1 (Appetizers:Loquat) tasted bad! Reworking... 5.1 (Desserts:Mushroom, White, Silver Dollar) tasted bad! Reworking... 1.1 (Soups:Sprouts, Mung Bean) is ready for release! 3.1 (Appetizers:Loquat) is ready for release! 1.2 (Soups:Potato Bread) had incorrect measurements! Reworking... 1.2 (Soups:Potato Bread) is ready for release! 1.3 (Soups:Chicken Liver) failed the readthrough! Reworking... 3.2 (Appetizers:Bergenost) is ready for release! 1.3 (Soups:Chicken Liver) had incorrect measurements! Reworking... 7.2 (Breakfast:Lettuce, Red Leaf) failed final editing! Reworking... 5.1 (Desserts:Mushroom, White, Silver Dollar) is ready for release! 5.2 (Desserts:Eggplant) is ready for release! 7.2 (Breakfast:Lettuce, Red Leaf) tasted bad! Reworking... 3.3 (Appetizers:Tomato Red Roma) is ready for release! 1.3 (Soups:Chicken Liver) is ready for release! 3.4 (Appetizers:Guava) is ready for release! 5.3 (Desserts:Asparagus Peas) is ready for release! 1.4 (Soups:Cherimoya) is ready for release! 5.4 (Desserts:Squash, Kabocha) is ready for release! 1.5 (Soups:High-Protein Bread) had incorrect measurements! Reworking... 7.2 (Breakfast:Lettuce, Red Leaf) failed final editing! Reworking... 1.5 (Soups:High-Protein Bread) failed final editing! Reworking... 5.5 (Desserts:Sprouts, Radish) is ready for release! 3.5 (Appetizers:Squash Flower) is ready for release! 3.6 (Appetizers:Radishes, Red) failed the readthrough! Reworking... 1.5 (Soups:High-Protein Bread) is ready for release! 5.6 (Desserts:Mushroom, Black Trumpet) tasted bad! Reworking... 1.6 (Soups:Flat Bread) is ready for release! 1.7 (Soups:Pomegranate) is ready for release! 3.6 (Appetizers:Radishes, Red) is ready for release! 7.2 (Breakfast:Lettuce, Red Leaf) is ready for release! 5.6 (Desserts:Mushroom, Black Trumpet) failed final editing! Reworking... 1.8 (Soups:Carissa, Natal Plum) is ready for release! 7.3 (Breakfast:Alfalfa Sprouts) is ready for release! 7.4 (Breakfast:Tea Cakes) is ready for release! 5.6 (Desserts:Mushroom, Black Trumpet) is ready for release! 3.7 (Appetizers:Goose Liver) is ready for release! 1.9 (Soups:Ideal Flat Bread) is ready for release! 5.7 (Desserts:Tea Cakes) tasted bad! Reworking... 3.8 (Appetizers:Okra) is ready for release! 3.9 (Appetizers:Borage) tasted bad! Reworking... 3.9 (Appetizers:Borage) failed the readthrough! Reworking... 3.9 (Appetizers:Borage) failed the readthrough! Reworking... 7.5 (Breakfast:Chia seed) is ready for release! 3.9 (Appetizers:Borage) is ready for release! 1.10 (Soups:Banana Bread) is ready for release! Finished Evaluating Chapter 1 - Soups Evaluating Chapter 2 - Salads 3.10 (Appetizers:Peppers) is ready for release! Finished Evaluating Chapter 3 - Appetizers Evaluating Chapter 4 - Entrees 5.7 (Desserts:Tea Cakes) is ready for release! 7.6 (Breakfast:Tangerine) is ready for release! 4.1 (Entrees:Plantain) is ready for release! 4.2 (Entrees:Pignola (Pine)) failed the readthrough! Reworking... 2.1 (Salads:Caraway) is ready for release! 5.8 (Desserts:Blueberries) is ready for release! 5.9 (Desserts:Sago Palm) failed the readthrough! Reworking... 5.9 (Desserts:Sago Palm) tasted bad! Reworking... 5.9 (Desserts:Sago Palm) is ready for release! 4.2 (Entrees:Pignola (Pine)) is ready for release! 2.2 (Salads:Potatoes, Red) is ready for release! 2.3 (Salads:Lemon) had incorrect measurements! Reworking... 4.3 (Entrees:Potatoes, Gold) is ready for release! 7.7 (Breakfast:Spinach) failed final editing! Reworking... 2.3 (Salads:Lemon) had incorrect measurements! Reworking... 4.4 (Entrees:Ribeye) had incorrect measurements! Reworking... 7.7 (Breakfast:Spinach) tasted bad! Reworking... 4.4 (Entrees:Ribeye) is ready for release! 2.3 (Salads:Lemon) tasted bad! Reworking... 5.10 (Desserts:Opossum) is ready for release! Finished Evaluating Chapter 5 - Desserts Evaluating Chapter 6 - Snacks 6.1 (Snacks:Cheddar) is ready for release! 4.5 (Entrees:Sprouts, Mung Bean) is ready for release! 7.7 (Breakfast:Spinach) is ready for release! 6.2 (Snacks:Melon, Bitter) is ready for release! 6.3 (Snacks:Scallion) failed the readthrough! Reworking... 7.8 (Breakfast:Flank Steak) tasted bad! Reworking... 2.3 (Salads:Lemon) failed final editing! Reworking... 7.8 (Breakfast:Flank Steak) is ready for release! 4.6 (Entrees:Squash) is ready for release! 2.3 (Salads:Lemon) tasted bad! Reworking... 4.7 (Entrees:Squash, Winter) failed the readthrough! Reworking... 4.7 (Entrees:Squash, Winter) had incorrect measurements! Reworking... 6.3 (Snacks:Scallion) is ready for release! 6.4 (Snacks:Squash Chayote) is ready for release! 4.7 (Entrees:Squash, Winter) is ready for release! 7.9 (Breakfast:Loganberries) is ready for release! 2.3 (Salads:Lemon) is ready for release! 7.10 (Breakfast:Opossum) is ready for release! Finished Evaluating Chapter 7 - Breakfast Evaluating Chapter 8 - Sandwiches 8.1 (Sandwiches:Rhubarb) had incorrect measurements! Reworking... 4.8 (Entrees:Corn, Blue) is ready for release! 2.4 (Salads:Cream cheese) failed final editing! Reworking... 2.4 (Salads:Cream cheese) is ready for release! 6.5 (Snacks:Roasted Turkey) failed final editing! Reworking... 4.9 (Entrees:Snake) is ready for release! 4.10 (Entrees:Prosciutto) failed the readthrough! Reworking... 6.5 (Snacks:Roasted Turkey) had incorrect measurements! Reworking... 2.5 (Salads:Artichokes, Domestic) tasted bad! Reworking... 4.10 (Entrees:Prosciutto) tasted bad! Reworking... 8.1 (Sandwiches:Rhubarb) tasted bad! Reworking... 4.10 (Entrees:Prosciutto) had incorrect measurements! Reworking... 4.10 (Entrees:Prosciutto) is ready for release! Finished Evaluating Chapter 4 - Entrees 6.5 (Snacks:Roasted Turkey) is ready for release! 6.6 (Snacks:Lime) had incorrect measurements! Reworking... 2.5 (Salads:Artichokes, Domestic) failed final editing! Reworking... 8.1 (Sandwiches:Rhubarb) is ready for release! 6.6 (Snacks:Lime) tasted bad! Reworking... 6.6 (Snacks:Lime) is ready for release! 2.5 (Salads:Artichokes, Domestic) is ready for release! 6.7 (Snacks:Hazelnut) is ready for release! 8.2 (Sandwiches:Pickle, Brine) is ready for release! 2.6 (Salads:Grapefruit) is ready for release! 2.7 (Salads:Lettuce, Iceberg) failed final editing! Reworking... 2.7 (Salads:Lettuce, Iceberg) is ready for release! 6.8 (Snacks:Radishes, Daikon) is ready for release! 8.3 (Sandwiches:Oranges) is ready for release! 6.9 (Snacks:Salami) tasted bad! Reworking... 2.8 (Salads:Fenugreek) is ready for release! 8.4 (Sandwiches:Chayote, Pipinella, Vegetable Pear) tasted bad! Reworking... 2.9 (Salads:Ostrich) failed the readthrough! Reworking... 6.9 (Snacks:Salami) is ready for release! 6.10 (Snacks:Mushroom, Oyster) is ready for release! Finished Evaluating Chapter 6 - Snacks 2.9 (Salads:Ostrich) failed final editing! Reworking... 2.9 (Salads:Ostrich) failed the readthrough! Reworking... 2.9 (Salads:Ostrich) failed the readthrough! Reworking... 8.4 (Sandwiches:Chayote, Pipinella, Vegetable Pear) is ready for release! 8.5 (Sandwiches:Bear) is ready for release! 2.9 (Salads:Ostrich) failed final editing! Reworking... 8.6 (Sandwiches:Panela) tasted bad! Reworking... 8.6 (Sandwiches:Panela) failed the readthrough! Reworking... 2.9 (Salads:Ostrich) is ready for release! 8.6 (Sandwiches:Panela) had incorrect measurements! Reworking... 8.6 (Sandwiches:Panela) is ready for release! 2.10 (Salads:Brazil Nuts) is ready for release! Finished Evaluating Chapter 2 - Salads 8.7 (Sandwiches:Peppers, Red) tasted bad! Reworking... 8.7 (Sandwiches:Peppers, Red) tasted bad! Reworking... 8.7 (Sandwiches:Peppers, Red) is ready for release! 8.8 (Sandwiches:Oat Bread) is ready for release! 8.9 (Sandwiches:Peppers, Green) is ready for release! 8.10 (Sandwiches:Garlic) is ready for release! Finished Evaluating Chapter 8 - Sandwiches *********************************************** Full Chapter Evaluation with PLINQ took: 00:00:25.1708103 *********************************************** Cookbook Evaluation Complete If you are running a PLINQ query and the operation invoked throws an exception, it will not stop the set evaluation at that point but will continue to the end, recording any exceptions into an , which can be caught after the query is evaluated (not declared). The “Parallel LINQ” topic in the MSDN documentation."
    },
    {
        "link": "https://stackoverflow.com/questions/17231101/how-to-debug-a-linq-lambda-expression",
        "document": "I am using Entity Framework and Linq to Entitites.\n\nI would like to know if there is any way in Visual Studio 2012 to debug this code, step by step. At the moment when placing a break point, the cursor goes over it but does not step inside.\n\nI am more interested to see the value of x.e... not the sql generated for example.\n\nNotes: I'm fine with using other tools or Visual Studio plugins."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.string.join?view=net-9.0",
        "document": "Concatenates the members of a constructed IEnumerable<T> collection of type String, using the specified separator between each member. Public Shared Function Join (separator As String, values As IEnumerable(Of String)) As String The string to use as a separator. is included in the returned string only if has more than one element. A collection that contains the strings to concatenate. A string that consists of the elements of delimited by the string. Empty if has zero elements. The length of the resulting string overflows the maximum allowed length (Int32.MaxValue). The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100. It assigns the result to a List<T> object of type String, which it then passes to the Join(String, IEnumerable<String>) method. using System; using System.Collections.Generic; public class Example { public static void Main() { int maxPrime = 100; List<int> primes = GetPrimes(maxPrime); Console.WriteLine(\"Primes less than {0}:\", maxPrime); Console.WriteLine(\" {0}\", String.Join(\" \", primes)); } private static List<int> GetPrimes(int maxPrime) { Array values = Array.CreateInstance(typeof(int), new int[] { maxPrime - 1}, new int[] { 2 }); // Use Sieve of Eratosthenes to determine prime numbers. for (int ctr = values.GetLowerBound(0); ctr <= (int) Math.Ceiling(Math.Sqrt(values.GetUpperBound(0))); ctr++) { if ((int) values.GetValue(ctr) == 1) continue; for (int multiplier = ctr; multiplier <= maxPrime / 2; multiplier++) if (ctr * multiplier <= maxPrime) values.SetValue(1, ctr * multiplier); } List<int> primes = new List<int>(); for (int ctr = values.GetLowerBound(0); ctr <= values.GetUpperBound(0); ctr++) if ((int) values.GetValue(ctr) == 0) primes.Add(ctr); return primes; } } // The example displays the following output: // Primes less than 100: // 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 open System let getPrimes maxPrime = let values = Array.CreateInstance(typeof<int>, [| maxPrime - 1 |], [| 2 |]) // Use Sieve of Eratosthenes to determine prime numbers. for i = values.GetLowerBound 0 to values.GetUpperBound 0 |> float |> sqrt |> ceil |> int do if values.GetValue i :?> int <> 1 then for multiplier = i to maxPrime / 2 do if i * multiplier <= maxPrime then values.SetValue(1, i * multiplier) let primes = ResizeArray() for i = values.GetLowerBound 0 to values.GetUpperBound 0 do if values.GetValue i :?> int = 0 then primes.Add i primes let maxPrime = 100 let primes = getPrimes maxPrime printfn $\"Primes less than {maxPrime}:\" printfn $\"\"\" {String.Join(\" \", primes)}\"\"\" // The example displays the following output: // Primes less than 100: // 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 Imports System.Collections.Generic Module Example Public Sub Main() Dim maxPrime As Integer = 100 Dim primes As List(Of String) = GetPrimes(maxPrime) Console.WriteLine(\"Primes less than {0}:\", maxPrime) Console.WriteLine(\" {0}\", String.Join(\" \", primes)) End Sub Private Function GetPrimes(maxPrime As Integer) As List(Of String) Dim values As Array = Array.CreateInstance(GetType(Integer), _ New Integer() { maxPrime - 1}, New Integer(){ 2 }) ' Use Sieve of Eratosthenes to determine prime numbers. For ctr As Integer = values.GetLowerBound(0) To _ CInt(Math.Ceiling(Math.Sqrt(values.GetUpperBound(0)))) If CInt(values.GetValue(ctr)) = 1 Then Continue For For multiplier As Integer = ctr To maxPrime \\ 2 If ctr * multiplier <= maxPrime Then values.SetValue(1, ctr * multiplier) Next Next Dim primes As New List(Of String) For ctr As Integer = values.GetLowerBound(0) To values.GetUpperBound(0) If CInt(values.GetValue(ctr)) = 0 Then primes.Add(ctr.ToString()) Next Return primes End Function End Module ' The example displays the following output: ' Primes less than 100: ' 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 If is , an empty string (String.Empty) is used instead. If any member of is , an empty string is used instead. Join(String, IEnumerable<String>) is a convenience method that lets you concatenate each element in an collection without first converting the elements to a string array. It is particularly useful with Language-Integrated Query (LINQ) query expressions. The following example passes a object that contains either the uppercase or lowercase letters of the alphabet to a lambda expression that selects letters that are equal to or greater than a particular letter (which, in the example, is \"M\"). The collection returned by the Enumerable.Where method is passed to the Join(String, IEnumerable<String>) method to display the result as a single string. using System; using System.Collections.Generic; using System.Linq; public class Example { public static void Main() { string output = String.Join(\" \", GetAlphabet(true).Where( letter => letter.CompareTo(\"M\") >= 0)); Console.WriteLine(output); } private static List<string> GetAlphabet(bool upper) { List<string> alphabet = new List<string>(); int charValue = upper ? 65 : 97; for (int ctr = 0; ctr <= 25; ctr++) alphabet.Add(((char)(charValue + ctr)).ToString()); return alphabet; } } // The example displays the following output: // M N O P Q R S T U V W X Y Z // This F# example uses Seq.filter instead of Linq. open System let getAlphabet upper = let charValue = if upper then 65 else 97 seq { for i = 0 to 25 do charValue + i |> char |> string } String.Join(\" \", getAlphabet true |> Seq.filter (fun letter -> letter.CompareTo \"M\" >= 0)) |> printfn \"%s\" // The example displays the following output: // M N O P Q R S T U V W X Y Z Imports System.Collections.Generic Imports System.Linq Module modMain Public Sub Main() Dim output As String = String.Join(\" \", GetAlphabet(True).Where(Function(letter) _ letter >= \"M\")) Console.WriteLine(output) End Sub Private Function GetAlphabet(upper As Boolean) As List(Of String) Dim alphabet As New List(Of String) Dim charValue As Integer = CInt(IIf(upper, 65, 97)) For ctr As Integer = 0 To 25 alphabet.Add(ChrW(charValue + ctr).ToString()) Next Return alphabet End Function End Module ' The example displays the following output: ' M N O P Q R S T U V W X Y Z\n\nConcatenates the elements of an object array, using the specified separator between each element. Public Shared Function Join (separator As String, ParamArray values As Object()) As String The string to use as a separator. is included in the returned string only if has more than one element. An array that contains the elements to concatenate. A string that consists of the elements of delimited by the string. Empty if has zero elements. .NET Framework only: Empty if the first element of is . The length of the resulting string overflows the maximum allowed length (Int32.MaxValue). The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100. It assigns the result to a integer array, which it then passes to the Join(String, Object[]) method. using System; using System.Collections.Generic; public class Example { public static void Main() { int maxPrime = 100; int[] primes = GetPrimes(maxPrime); Console.WriteLine(\"Primes less than {0}:\", maxPrime); Console.WriteLine(\" {0}\", String.Join(\" \", primes)); } private static int[] GetPrimes(int maxPrime) { Array values = Array.CreateInstance(typeof(int), new int[] { maxPrime - 1}, new int[] { 2 }); // Use Sieve of Eratosthenes to determine prime numbers. for (int ctr = values.GetLowerBound(0); ctr <= (int) Math.Ceiling(Math.Sqrt(values.GetUpperBound(0))); ctr++) { if ((int) values.GetValue(ctr) == 1) continue; for (int multiplier = ctr; multiplier <= maxPrime / 2; multiplier++) if (ctr * multiplier <= maxPrime) values.SetValue(1, ctr * multiplier); } List<int> primes = new List<int>(); for (int ctr = values.GetLowerBound(0); ctr <= values.GetUpperBound(0); ctr++) if ((int) values.GetValue(ctr) == 0) primes.Add(ctr); return primes.ToArray(); } } // The example displays the following output: // Primes less than 100: // 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 open System let getPrimes maxPrime = let values = Array.CreateInstance(typeof<int>, [| maxPrime - 1 |], [| 2 |]) // Use Sieve of Eratosthenes to determine prime numbers. for i = values.GetLowerBound 0 to values.GetUpperBound 0 |> float |> sqrt |> ceil |> int do if values.GetValue i :?> int <> 1 then for multiplier = i to maxPrime / 2 do if i * multiplier <= maxPrime then values.SetValue(1, i * multiplier) [| for i = values.GetLowerBound 0 to values.GetUpperBound 0 do if values.GetValue i :?> int = 0 then i |] let maxPrime = 100 let primes = getPrimes maxPrime printfn $\"Primes less than {maxPrime}:\" printfn $\"\"\" {String.Join(\" \", primes)}\"\"\" // The example displays the following output: // Primes less than 100: // 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 Module Example Public Sub Main() Dim maxPrime As Integer = 100 Dim primes() As Integer = GetPrimes(maxPrime) Console.WriteLine(\"Primes less than {0}:\", maxPrime) Console.WriteLine(\" {0}\", String.Join(\" \", primes)) End Sub Private Function GetPrimes(maxPrime As Integer) As Integer() Dim values As Array = Array.CreateInstance(GetType(Integer), _ New Integer() { maxPrime - 1}, New Integer(){ 2 }) ' Use Sieve of Eratosthenes to determine prime numbers. For ctr As Integer = values.GetLowerBound(0) To _ CInt(Math.Ceiling(Math.Sqrt(values.GetUpperBound(0)))) If CInt(values.GetValue(ctr)) = 1 Then Continue For For multiplier As Integer = ctr To maxPrime \\ 2 If ctr * multiplier <= maxPrime Then values.SetValue(1, ctr * multiplier) Next Next Dim primes As New System.Collections.Generic.List(Of Integer) For ctr As Integer = values.GetLowerBound(0) To values.GetUpperBound(0) If CInt(values.GetValue(ctr)) = 0 Then primes.Add(ctr) Next Return primes.ToArray() End Function End Module ' The example displays the following output: ' Primes less than 100: ' 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 If is or if any element of other than the first element is , an empty string (String.Empty) is used instead. See the Notes for Callers section if the first element of is . Join(String, Object[]) is a convenience method that lets you concatenate each element in an object array without explicitly converting its elements to strings. The string representation of each object in the array is derived by calling that object's method. .NET Framework only: If the first element of is , the Join(String, Object[]) method does not concatenate the elements in but instead returns Empty. A number of workarounds for this issue are available. The easiest is to assign a value of Empty to the first element of the array, as the following example shows. object[] values = { null, \"Cobb\", 4189, 11434, .366 }; if (values[0] == null) values[0] = String.Empty; Console.WriteLine(String.Join(\"|\", values)); // The example displays the following output: // |Cobb|4189|11434|0.366 let values: obj[] = [| null; \"Cobb\"; 4189; 11434; 0.366 |] if values[0] = null then values[0] <- String.Empty printfn $\"\"\"{String.Join(\"|\", values)}\"\"\" // The example displays the following output: // |Cobb|4189|11434|0.366 Dim values() As Object = { Nothing, \"Cobb\", 4189, 11434, .366 } If values(0) Is Nothing Then values(0) = String.Empty Console.WriteLine(String.Join(\"|\", values)) ' The example displays the following output: ' |Cobb|4189|11434|0.366\n\nConcatenates all the elements of a string array, using the specified separator between each element. Public Shared Function Join (separator As String, ParamArray value As String()) As String Public Shared Function Join (separator As String, value As String()) As String The string to use as a separator. is included in the returned string only if has more than one element. An array that contains the elements to concatenate. A string that consists of the elements in delimited by the string. Empty if has zero elements. The length of the resulting string overflows the maximum allowed length (Int32.MaxValue). The following example demonstrates the Join method. using namespace System; String^ MakeLine( int initVal, int multVal, String^ sep ) { array<String^>^sArr = gcnew array<String^>(10); for ( int i = initVal; i < initVal + 10; i++ ) sArr[ i - initVal ] = String::Format( \"{0, -3}\", i * multVal ); return String::Join( sep, sArr ); } int main() { Console::WriteLine( MakeLine( 0, 5, \", \" ) ); Console::WriteLine( MakeLine( 1, 6, \" \" ) ); Console::WriteLine( MakeLine( 9, 9, \": \" ) ); Console::WriteLine( MakeLine( 4, 7, \"< \" ) ); } // The example displays the following output: // 0 , 5 , 10 , 15 , 20 , 25 , 30 , 35 , 40 , 45 // 6 12 18 24 30 36 42 48 54 60 // 81 : 90 : 99 : 108: 117: 126: 135: 144: 153: 162 // 28 < 35 < 42 < 49 < 56 < 63 < 70 < 77 < 84 < 91 using System; public class JoinTest { public static void Main() { Console.WriteLine(MakeLine(0, 5, \", \")); Console.WriteLine(MakeLine(1, 6, \" \")); Console.WriteLine(MakeLine(9, 9, \": \")); Console.WriteLine(MakeLine(4, 7, \"< \")); } private static string MakeLine(int initVal, int multVal, string sep) { string [] sArr = new string [10]; for (int i = initVal; i < initVal + 10; i++) sArr[i - initVal] = String.Format(\"{0,-3}\", i * multVal); return String.Join(sep, sArr); } } // The example displays the following output: // 0 , 5 , 10 , 15 , 20 , 25 , 30 , 35 , 40 , 45 // 6 12 18 24 30 36 42 48 54 60 // 81 : 90 : 99 : 108: 117: 126: 135: 144: 153: 162 // 28 < 35 < 42 < 49 < 56 < 63 < 70 < 77 < 84 < 91 open System let makeLine initVal multVal (sep: string) = let sArr = Array.zeroCreate<string> 10 for i = initVal to initVal + 9 do sArr[i - initVal] <- String.Format(\"{0,-3}\", i * multVal) String.Join(sep, sArr) printfn $\"\"\"{makeLine 0 5 \", \"}\"\"\" printfn $\"\"\"{makeLine 1 6 \" \"}\"\"\" printfn $\"\"\"{makeLine 9 9 \": \"}\"\"\" printfn $\"\"\"{makeLine 4 7 \"< \"}\"\"\" // The example displays the following output: // 0 , 5 , 10 , 15 , 20 , 25 , 30 , 35 , 40 , 45 // 6 12 18 24 30 36 42 48 54 60 // 81 : 90 : 99 : 108: 117: 126: 135: 144: 153: 162 // 28 < 35 < 42 < 49 < 56 < 63 < 70 < 77 < 84 < 91 Public Class JoinTest Public Shared Sub Main() Console.WriteLine(MakeLine(0, 5, \", \")) Console.WriteLine(MakeLine(1, 6, \" \")) Console.WriteLine(MakeLine(9, 9, \": \")) Console.WriteLine(MakeLine(4, 7, \"< \")) End Sub Private Shared Function MakeLine(initVal As Integer, multVal As Integer, sep As String) As String Dim sArr(10) As String Dim i As Integer For i = initVal To (initVal + 10) - 1 sArr((i - initVal)) = [String].Format(\"{0,-3}\", i * multVal) Next i Return [String].Join(sep, sArr) End Function 'MakeLine End Class ' The example displays the following output: ' 0 , 5 , 10 , 15 , 20 , 25 , 30 , 35 , 40 , 45 ' 6 12 18 24 30 36 42 48 54 60 ' 81 : 90 : 99 : 108: 117: 126: 135: 144: 153: 162 ' 28 < 35 < 42 < 49 < 56 < 63 < 70 < 77 < 84 < 91 For example, if is \", \" and the elements of are \"apple\", \"orange\", \"grape\", and \"pear\", returns \"apple, orange, grape, pear\". If is , an empty string (String.Empty) is used instead. If any element in is , an empty string is used instead.\n\nConcatenates the specified elements of a string array, using the specified separator between each element. Public Shared Function Join (separator As String, value As String(), startIndex As Integer, count As Integer) As String The string to use as a separator. is included in the returned string only if has more than one element. An array that contains the elements to concatenate. The first element in to use. The number of elements of to use. A string that consists of elements of starting at delimited by the character. or is less than 0. plus is greater than the number of elements in . The following example concatenates two elements from an array of names of fruit. // Sample for String::Join(String, String[], int int) using namespace System; int main() { array<String^>^val = {\"apple\",\"orange\",\"grape\",\"pear\"}; String^ sep = \", \"; String^ result; Console::WriteLine( \"sep = '{0}'\", sep ); Console::WriteLine( \"val[] = {{'{0}' '{1}' '{2}' '{3}'}}\", val[ 0 ], val[ 1 ], val[ 2 ], val[ 3 ] ); result = String::Join( sep, val, 1, 2 ); Console::WriteLine( \"String::Join(sep, val, 1, 2) = '{0}'\", result ); } /* This example produces the following results: sep = ', ' val[] = {'apple' 'orange' 'grape' 'pear'} String::Join(sep, val, 1, 2) = 'orange, grape' */ String[] val = {\"apple\", \"orange\", \"grape\", \"pear\"}; String sep = \", \"; String result; Console.WriteLine(\"sep = '{0}'\", sep); Console.WriteLine(\"val[] = {{'{0}' '{1}' '{2}' '{3}'}}\", val[0], val[1], val[2], val[3]); result = String.Join(sep, val, 1, 2); Console.WriteLine(\"String.Join(sep, val, 1, 2) = '{0}'\", result); // This example produces the following results: // sep = ', ' // val[] = {'apple' 'orange' 'grape' 'pear'} // String.Join(sep, val, 1, 2) = 'orange, grape' open System let vals = [| \"apple\"; \"orange\"; \"grape\"; \"pear\" |] let sep = \", \" printfn $\"sep = '{sep}'\" printfn $\"vals[] = {{'{vals[0]}' '{vals[1]}' '{vals[2]}' '{vals[3]}'}}\" let result = String.Join(sep, vals, 1, 2) printfn $\"String.Join(sep, vals, 1, 2) = '{result}'\" // This example produces the following results: // sep = ', ' // vals[] = {'apple' 'orange' 'grape' 'pear'} // String.Join(sep, vals, 1, 2) = 'orange, grape' Class Sample Public Shared Sub Main() Dim val As [String]() = {\"apple\", \"orange\", \"grape\", \"pear\"} Dim sep As [String] = \", \" Dim result As [String] Console.WriteLine(\"sep = '{0}'\", sep) Console.WriteLine(\"val() = {{'{0}' '{1}' '{2}' '{3}'}}\", val(0), val(1), val(2), val(3)) result = [String].Join(sep, val, 1, 2) Console.WriteLine(\"String.Join(sep, val, 1, 2) = '{0}'\", result) End Sub End Class 'This example displays the following output: ' sep = ', ' ' val() = {'apple' 'orange' 'grape' 'pear'} ' String.Join(sep, val, 1, 2) = 'orange, grape' For example, if is \", \" and the elements of are \"apple\", \"orange\", \"grape\", and \"pear\", returns \"orange, grape\". If is , an empty string (String.Empty) is used instead. If any element in is , an empty string is used instead.\n\nConcatenates the members of a collection, using the specified separator between each member. Public Shared Function Join(Of T) (separator As String, values As IEnumerable(Of T)) As String The type of the members of . The string to use as a separator. is included in the returned string only if has more than one element. A collection that contains the objects to concatenate. A string that consists of the elements of delimited by the string. Empty if has no elements. The length of the resulting string overflows the maximum allowed length (Int32.MaxValue). The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100. It assigns the result to a List<T> object of type integer, which it then passes to the Join<T>(String, IEnumerable<T>) method. using System; using System.Collections.Generic; public class Example { public static void Main() { int maxPrime = 100; List<int> primes = GetPrimes(maxPrime); Console.WriteLine(\"Primes less than {0}:\", maxPrime); Console.WriteLine(\" {0}\", String.Join(\" \", primes)); } private static List<int> GetPrimes(int maxPrime) { Array values = Array.CreateInstance(typeof(int), new int[] { maxPrime - 1}, new int[] { 2 }); // Use Sieve of Eratosthenes to determine prime numbers. for (int ctr = values.GetLowerBound(0); ctr <= (int) Math.Ceiling(Math.Sqrt(values.GetUpperBound(0))); ctr++) { if ((int) values.GetValue(ctr) == 1) continue; for (int multiplier = ctr; multiplier <= maxPrime / 2; multiplier++) if (ctr * multiplier <= maxPrime) values.SetValue(1, ctr * multiplier); } List<int> primes = new List<int>(); for (int ctr = values.GetLowerBound(0); ctr <= values.GetUpperBound(0); ctr++) if ((int) values.GetValue(ctr) == 0) primes.Add(ctr); return primes; } } // The example displays the following output: // Primes less than 100: // 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 open System let getPrimes maxPrime = let values = Array.CreateInstance(typeof<int>, [| maxPrime - 1 |], [| 2 |]) // Use Sieve of Eratosthenes to determine prime numbers. for i = values.GetLowerBound 0 to values.GetUpperBound 0 |> float |> sqrt |> ceil |> int do if values.GetValue i <> 1 then for multiplier = i to maxPrime / 2 do if i * multiplier <= maxPrime then values.SetValue(1, i * multiplier) let primes = ResizeArray() for i = values.GetLowerBound 0 to values.GetUpperBound 0 do if values.GetValue i :?> int = 0 then primes.Add i primes let maxPrime = 100 let primes = getPrimes maxPrime printfn $\"Primes less than {maxPrime}:\" printfn $\"\"\" {String.Join(\" \", primes)}\"\"\" // The example displays the following output: // Primes less than 100: // 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 Imports System.Collections.Generic Module Example Public Sub Main() Dim maxPrime As Integer = 100 Dim primes As List(Of Integer) = GetPrimes(maxPrime) Console.WriteLine(\"Primes less than {0}:\", maxPrime) Console.WriteLine(\" {0}\", String.Join(\" \", primes)) End Sub Private Function GetPrimes(maxPrime As Integer) As List(Of Integer) Dim values As Array = Array.CreateInstance(GetType(Integer), _ New Integer() { maxPrime - 1}, New Integer(){ 2 }) ' Use Sieve of Eratosthenes to determine prime numbers. For ctr As Integer = values.GetLowerBound(0) To _ CInt(Math.Ceiling(Math.Sqrt(values.GetUpperBound(0)))) If CInt(values.GetValue(ctr)) = 1 Then Continue For For multiplier As Integer = ctr To maxPrime \\ 2 If ctr * multiplier <= maxPrime Then values.SetValue(1, ctr * multiplier) Next Next Dim primes As New System.Collections.Generic.List(Of Integer) For ctr As Integer = values.GetLowerBound(0) To values.GetUpperBound(0) If CInt(values.GetValue(ctr)) = 0 Then primes.Add(ctr) Next Return primes End Function End Module ' The example displays the following output: ' Primes less than 100: ' 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 If is , an empty string (String.Empty) is used instead. If any member of is , an empty string is used instead. Join<T>(String, IEnumerable<T>) is a convenience method that lets you concatenate each member of an IEnumerable<T> collection without first converting them to strings. The string representation of each object in the IEnumerable<T> collection is derived by calling that object's method. This method is particular useful with Language-Integrated Query (LINQ) query expressions. For example, the following code defines a very simple class that contains the name of an animal and the order to which it belongs. It then defines a List<T> object that contains a number of objects. The Enumerable.Where extension method is called to extract the objects whose property equals \"Rodent\". The result is passed to the Join<T>(String, IEnumerable<T>) method. using System; using System.Collections.Generic; using System.Linq; public class Animal { public string Kind; public string Order; public Animal(string kind, string order) { this.Kind = kind; this.Order = order; } public override string ToString() { return this.Kind; } } public class Example { public static void Main() { List<Animal> animals = new List<Animal>(); animals.Add(new Animal(\"Squirrel\", \"Rodent\")); animals.Add(new Animal(\"Gray Wolf\", \"Carnivora\")); animals.Add(new Animal(\"Capybara\", \"Rodent\")); string output = String.Join(\" \", animals.Where( animal => (animal.Order == \"Rodent\"))); Console.WriteLine(output); } } // The example displays the following output: // Squirrel Capybara // This example uses F#'s Seq.filter function instead of Linq. open System type Animal = { Kind: string Order: string } override this.ToString() = this.Kind let animals = ResizeArray() animals.Add { Kind = \"Squirrel\"; Order = \"Rodent\" } animals.Add { Kind = \"Gray Wolf\"; Order = \"Carnivora\" } animals.Add { Kind = \"Capybara\"; Order = \"Rodent\" } String.Join(\" \", animals |> Seq.filter (fun animal -> animal.Order = \"Rodent\")) |> printfn \"%s\" // The example displays the following output: // Squirrel Capybara Imports System.Collections.Generic Public Class Animal Public Kind As String Public Order As String Public Sub New(kind As String, order As String) Me.Kind = kind Me.Order = order End Sub Public Overrides Function ToString() As String Return Me.Kind End Function End Class Module Example Public Sub Main() Dim animals As New List(Of Animal) animals.Add(New Animal(\"Squirrel\", \"Rodent\")) animals.Add(New Animal(\"Gray Wolf\", \"Carnivora\")) animals.Add(New Animal(\"Capybara\", \"Rodent\")) Dim output As String = String.Join(\" \", animals.Where(Function(animal) _ animal.Order = \"Rodent\")) Console.WriteLine(output) End Sub End Module ' The example displays the following output: ' Squirrel Capybara"
    },
    {
        "link": "https://ironpdf.com/blog/net-help/csharp-string-join",
        "document": "Test in production without watermarks.\n\nWorks wherever you need it to."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/how-to/concatenate-multiple-strings",
        "document": "How to concatenate multiple strings (C# Guide)\n\nConcatenation is the process of appending one string to the end of another string. You concatenate strings by using the operator. For string literals and string constants, concatenation occurs at compile time; no run-time concatenation occurs. For string variables, concatenation occurs only at run time.\n\nThe following example splits a long string literal into smaller strings to improve readability in the source code. The code concatenates the smaller strings to create the long string literal. The parts are concatenated into a single string at compile time. There's no run-time performance cost regardless of the number of strings involved.\n\nTo concatenate string variables, you can use the or operators, string interpolation or the String.Format, String.Concat, String.Join or StringBuilder.Append methods. The operator is easy to use and makes for intuitive code. Even if you use several operators in one statement, the string content is copied only once. The following code shows examples of using the and operators to concatenate strings:\n\nIn some expressions, it's easier to concatenate strings using string interpolation, as the following code shows:\n\nYou can use string interpolation to initialize a constant string when all the expressions used for placeholders are also constant strings.\n\nAnother method to concatenate strings is String.Format. This method works well when you're building a string from a few component strings.\n\nIn other cases, you might be combining strings in a loop where the actual number of source strings can be large. The StringBuilder class was designed for these scenarios. The following code uses the Append method of the StringBuilder class to concatenate strings.\n\nYou can read more about the reasons to choose string concatenation or the class.\n\nAnother option to join strings from a collection is to use String.Concat method. Use String.Join method if a delimiter should separate source strings. The following code combines an array of words using both methods:\n\nAt last, you can use LINQ and the Enumerable.Aggregate method to join strings from a collection. This method combines the source strings using a lambda expression. The lambda expression does the work to add each string to the existing accumulation. The following example combines an array of words, adding a space between each word in the array:\n\nThis option can cause more allocations than other methods for concatenating collections, as it creates an intermediate string for each iteration. If optimizing performance is critical, consider the class or the or method to concatenate a collection, instead of .\n\nYou can use GitHub Copilot in your IDE to generate C# code to concatenate multiple strings. You can customize the prompt to specify strings and the method to use per your requirements.\n\nThe following text shows an example prompt for Copilot Chat:\n\nGitHub Copilot is powered by AI, so surprises and mistakes are possible. For more information, see Copilot FAQs.\n\nLearn more about GitHub Copilot in Visual Studio and GitHub Copilot in VS Code."
    },
    {
        "link": "https://stackoverflow.com/questions/7687788/string-join-in-net-3-5",
        "document": "I have a .net 3.5 project in vs2008 and I'm trying to use this overload of (the one that takes a and ) and the compiler does not seem to know about this overload.\n\nThis is the code that I tried\n\nOf course, if I use it works but I'm wondering why the overload that takes won't work.\n\nMSDN in classic view says it's compatible with vs2008/.net 3.5"
    },
    {
        "link": "https://geeksforgeeks.org/c-sharp-join-method-set-1",
        "document": "In C#, Join() is a string method. This method is used to concatenates the members of a collection or the elements of the specified array, using the specified separator between each member or element. This method can be overloaded by passing different parameters to it. There are total 5 methods in the overload list of the Join() method in which 3 are discussed in this article and remaining 2 will be discussed in C# | Join() Method | Set – 2.\n\nThis method is used to concatenate the elements of an object array with the help of a separator between each element of the object array.\n• Parameters: This method takes two parameters, One of them is the separator of the type System.String which is used to define a separator according to the user’s choice. Another parameter is an array of type System.Object[] which contains the elements to be concatenated.\n• Return Type: The return type of this method is System.String.\n• Exception: This method can give ArgumentNullException if the array is null.\n\nExample: In the below code, first an array of objects is created and then it is passed to the join method along with the separator to be used, here ‘, ‘ comma separator is used and after method’s return, the string is taken as the output.\n\nThis method is used to concatenate the elements of a String array with the help of a user-specified separator between each element of the string array.\n• Parameters: This method takes two parameters, One of them is the separator of the type System.String which is used to define a separator according to the user’s choice. Another parameter is an array of type System.String[] which contains the elements to be concatenated.\n• Return Type: The return type of this method is System.String.\n• Exception: This method can give ArgumentNullException if the array is null.\n\nExample:In below code, first an array of strings is created and is passed to the join method along with the separator to be used, here ‘/’ slash separator is used and after method’s return, the string is print as the output.\n\nThis method is used to concatenate the elements of a String array between the specified positions with the help of a user-defined separator between each element of the array.\n• Parameters: This method takes four parameters, first one is the separator of the type System.String which is used to define a separator according to the user’s choice. Second parameter is an array of type System.String[] which contains the elements to be concatenated. Third parameter is pos1 of type System.Int32 which is the first element in array to be used and important point to remember about this parameter is that it used zero-based index. Fourth parameter is pos2 of type System.Int32 which is used to specify the number of elements of array to be used and it always starts from 1 i.e it counts the pos1’value as its first element.\n• Return Type: The return type of this method is System.String. Also it can return of type String.Empty if value of pos2 is zero.\n• Exceptions: This method can give ArgumentNullException if the array is null. ArgumentOutOfRangeException can be given if the pos1 or pos2 is less than zero or pos1 + pos2 is greater than the number of elements in array and also this method can give OutOfMemoryException.\n\nExample: In below code, an array of strings is created and suppose that user wants to join the strings from position index 2 and want to cover five elements."
    }
]