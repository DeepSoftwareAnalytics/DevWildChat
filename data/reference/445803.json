[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch",
        "document": "The Fetch API provides a JavaScript interface for making HTTP requests and processing the responses. Fetch is the modern replacement for : unlike , which uses callbacks, Fetch is promise-based and is integrated with features of the modern web such as service workers and Cross-Origin Resource Sharing (CORS). With the Fetch API, you make a request by calling , which is available as a global function in both and contexts. You pass it a object or a string containing the URL to fetch, along with an optional argument to configure the request. The function returns a which is fulfilled with a object representing the server's response. You can then check the request status and extract the body of the response in various formats, including text and JSON, by calling the appropriate method on the response. Here's a minimal function that uses to retrieve some JSON data from a server: async function getData() { const url = \"https://example.org/products.json\"; try { const response = await fetch(url); if (!response.ok) { throw new Error(`Response status: ${response.status}`); } const json = await response.json(); console.log(json); } catch (error) { console.error(error.message); } } We declare a string containing the URL and then call , passing the URL with no extra options. The function will reject the promise on some errors, but not if the server responds with an error status like : so we also check the response status and throw if it is not OK. Otherwise, we fetch the response body content as JSON by calling the method of , and log one of its values. Note that like itself, is asynchronous, as are all the other methods to access the response body content. In the rest of this page we'll look in more detail at the different stages of this process.\n\nThe request body is the payload of the request: it's the thing the client is sending to the server. You cannot include a body with requests, but it's useful for requests that send content to the server, such as or requests. For example, if you want to upload a file to the server, you might make a request and include the file as the request body. To set a request body, pass it as the option: You can supply the body as an instance of any of the following types: Other objects are converted to strings using their method. For example, you can use a object to encode form data (see setting headers for more information): const response = await fetch(\"https://example.org/post\", { method: \"POST\", headers: { \"Content-Type\": \"application/x-www-form-urlencoded\", }, // Automatically converted to \"username=example&password=password\" body: new URLSearchParams({ username: \"example\", password: \"password\" }), // ... }); Note that just like response bodies, request bodies are streams, and making the request reads the stream, so if a request contains a body, you can't make it twice: const request = new Request(\"https://example.org/post\", { method: \"POST\", body: JSON.stringify({ username: \"example\" }), }); const response1 = await fetch(request); console.log(response1.status); // Will throw: \"Body has already been consumed.\" const response2 = await fetch(request); console.log(response2.status); Instead, you would need to create a clone of the request before sending it: See Locked and disturbed streams for more information.\n\nCredentials are cookies, TLS client certificates, or authentication headers containing a username and password. To control whether or not the browser sends credentials, as well as whether the browser respects any response headers, set the option, which can take one of the following three values:\n• : never send credentials in the request or include credentials in the response.\n• (the default): only send and include credentials for same-origin requests. Note that if a cookie's attribute is set to or , then the cookie will not be sent cross-site, even if is set to . Including credentials in cross-origin requests can make a site vulnerable to CSRF attacks, so even if is set to , the server must also agree to their inclusion by including the header in its response. Additionally, in this situation the server must explicitly specify the client's origin in the response header (that is, is not allowed). This means that if is set to and the request is cross-origin, then:\n• If the request is a simple request, then the request will be sent with credentials, but the server must set the and response headers, or the browser will return a network error to the caller. If the server does set the correct headers, then the response, including credentials, will be delivered to the caller.\n• If the request is not a simple request, then the browser will send a preflighted request without credentials, and the server must set the and response headers, or the browser will return a network error to the caller. If the server does set the correct headers, then the browser will follow up with the real request, including credentials, and will deliver the real response, including credentials, to the caller.\n\nRequest and response bodies are actually objects, and whenever you read them, you're streaming the content. This is good for memory efficiency, because the browser doesn't have to buffer the entire response in memory before the caller retrieves it using a method like . This also means that the caller can process the content incrementally as it is received. For example, consider a request that fetches a large text file and processes it in some way, or displays it to the user: const url = \"https://www.example.org/a-large-file.txt\"; async function fetchText(url) { try { const response = await fetch(url); if (!response.ok) { throw new Error(`Response status: ${response.status}`); } const text = await response.text(); console.log(text); } catch (e) { console.error(e); } } If we use , as above, we must wait until the whole file has been received before we can process any of it. If we stream the response instead, we can process chunks of the body as they are received from the network: const url = \"https://www.example.org/a-large-file.txt\"; async function fetchTextAsStream(url) { try { const response = await fetch(url); if (!response.ok) { throw new Error(`Response status: ${response.status}`); } const stream = response.body.pipeThrough(new TextDecoderStream()); for await (const value of stream) { console.log(value); } } catch (e) { console.error(e); } } In this example, we iterate asynchronously over the stream, processing each chunk as it arrives. Note that when you access the body directly like this, you get the raw bytes of the response and must transform it yourself. In this case we call to pipe the response through a , which decodes the UTF-8-encoded body data as text."
    },
    {
        "link": "https://chipcullen.com/how-to-post-data-with-fetch-api",
        "document": "How to POST *Data* with the Fetch API\n\nThe Fetch API has been around for a few years, and is newer way to make XHR (read: AJAX) calls. It's a thorny API, though, and when I was trying to work with it, I found almost no examples of how to make a POST request with it, while sending data as part of the call. (Every example of POST fetch calls seemed to not pass data, which seemed ... odd).\n\nAs a point of reference, you might have seen a jQuery call like this:\n\nHow do you do this with fetch?\n\nLet's start with what it looks like overall, then I'll break it down:\n\nFirst, I stashed our URL in a variable to make reading easier later:\n\nThis is the crux of the issue - and it took me a while to figure this out. A coworker of mine and I paired on it for about half an hour, which is what I'm trying to save you.\n\nWhen passing data via Fetch, you have a few different ways that you can do it. In my case, I was posting to a Django backend that was expecting a query parameter string.\n\nTo do that, the trick was using URLSearchParams, which is built into JavaScript, much like or . What it does is take key value pairs and translates them into a query parameter string. You add to it with the method that it has.\n\nSo, think of if like this:\n\nKnowing all that, this is how I built the data object:\n\nYou may have to experiment with how you construct your data object based on the API that you are POSTing to. This is what worked for me.\n\nNow we can build the second argument in the function, which is an object. It contains options that we want to make as part of our request, including the data we just built.\n\nMy example here is rather simple. See this page on MDN for all of the options available to you, including things like .\n\nAll together now - making the fetch\n\nNow that we have to two arguments for , it's pretty easy:\n\nreturns a Promise, so we need to handle that with .\n\nI'm using the variable name here to represent the Response object from the API.\n\nOne big thing you need to understand about is:\n\nFetch, which returns a promise, will not reject if the API returns an error such as 404, 500, etc. It will only reject if there is a network issue.\n\nThe response does have the property, which you can check:\n\nIn order to handle network issues, as well as errors from the API, I handle both with this :\n\nIn the case of the from earlier, when I throw , that becomes in the catch.\n\nAt this point, I've passed the response to or .\n\nAs noted on MDN, however, know that the response:\n\nYou can see how to handle responses with .json here.\n\nI hope that this article has explained how to POST data with the Fetch API in a way that is clear and helpful."
    },
    {
        "link": "https://stackoverflow.com/questions/51935090/how-do-i-post-data-and-parameters-like-in-axios-using-fetch-api",
        "document": "Take the following Axios example:\n\nHow can I do the same thing using fetch API? I see that parameters are done like this:\n\nSince the body key is being used to store the parameters, do I need to serialize my entire reportData object and concatenate it to the existing parameters?\n\nI don't understand why Fetch API is using the body key for parameters.\n\nAdditionally, this is not my own API and I cannot change the expected POST request."
    },
    {
        "link": "https://dev.to/sanjampreetsingh/simplifying-api-calls-with-urlsearchparams-and-fetch-8gn",
        "document": "Have you ever had to deal with complicated query parameters while using GET API calls?\n\nIntroducing URLSearchParams, a JavaScript interface that makes it simple to manage query parameters.\n\nLet's explore how it might raise the bar for your Fetch method use.\n\n\n\nURLSearchParams: We may create, modify, and manage query parameters within URLs using this convenient interface. It is ideal for writing exact API calls without manually adding '&' and '=' symbols.\n\n Use URLSearchParams to generate a clean, well-organized parameter string rather than manually concatenating strings.\n\nIf you like what you read, consider connecting with me on LinkedIn"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 . * Some parts of this feature may have varying levels of support.\n\nNote: This feature is available in Web Workers. The interface defines utility methods to work with the query string of a URL. objects are iterable, so they can directly be used in a structure to iterate over key/value pairs in the same order as they appear in the query string, for example the following two lines are equivalent: for (const [key, value] of mySearchParams) { } for (const [key, value] of mySearchParams.entries()) { } Although is functionally similar to a , when iterating, it may suffer from some pitfalls that doesn't encounter due to how it's implemented.\n\nReturns an allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string. Appends a specified key/value pair as a new search parameter. Deletes search parameters that match a name, and optional value, from the list of all search parameters. Returns an allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string. Allows iteration through all values contained in this object via a callback function. Returns the first value associated with the given search parameter. Returns all the values associated with a given search parameter. Returns a boolean value indicating if a given parameter, or parameter and value pair, exists. Returns an allowing iteration through all keys of the key/value pairs contained in this object. Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted. Sorts all key/value pairs, if any, by their keys. Returns a string containing a query string suitable for use in a URL. Returns an allowing iteration through all values of the key/value pairs contained in this object.\n\nobjects percent-encode anything in the percent-encode set (which contains all code points except ASCII alphanumeric, , , , and ), and encode U+0020 SPACE as . However, it only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version. // Creation from parsing a string: percent-encoding is decoded const params = new URLSearchParams(\"%24%25%26=%28%29%2B\"); // Retrieving all keys/values: only decoded values are returned console.log([...params]); // [[\"$%&\", \"()+\"]] // Getting an individual value: use the decoded key and get the decoded value console.log(params.get(\"$%&\")); // \"()+\" console.log(params.get(\"%24%25%26\")); // null // Setting an individual value: use the unencoded key and value params.append(\"$%&$#@+\", \"$#&*@#()+\"); // Serializing: percent-encoding is applied console.log(params.toString()); // \"%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B\" If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again.\n\nThe constructor interprets plus signs ( ) as spaces, which might cause problems. In the example below, we use hexadecimal escape sequences to mimic a string containing binary data (where every byte carries information) that needs to be stored in the URL search params. Note how the encoded string produced by contains and isn't preserved by . const rawData = \"\\x13à\\x17@\\x1F\\x80\"; const base64Data = btoa(rawData); // 'E+AXQB+A' const searchParams = new URLSearchParams(`bin=${base64Data}`); // 'bin=E+AXQB+A' const binQuery = searchParams.get(\"bin\"); // 'E AXQB A', '+' is replaced by spaces console.log(atob(binQuery) === rawData); // false Never construct objects using dynamically interpolated strings. Instead, use the method, which as mentioned above, interprets all characters as-is.\n\nThe property exposes the URL's string as a object. When updating this , the URL's is updated with its serialization. However, encodes a subset of characters that does, and encodes spaces as instead of . This may cause some surprising interactions—if you update , even with the same values, the URL may be serialized differently. const url = new URL(\"https://example.com/?a=b ~\"); console.log(url.href); // \"https://example.com/?a=b%20~\" console.log(url.searchParams.toString()); // \"a=b+%7E\" // This should be a no-op, but it changes the URL's query to the // serialization of its searchParams url.searchParams.sort(); console.log(url.href); // \"https://example.com/?a=b+%7E\" const url2 = new URL(\"https://example.com?search=1234¶m=my%20param\"); console.log(url2.search); // \"?search=1234¶m=my%20param\" url2.searchParams.delete(\"search\"); console.log(url2.search); // \"?param=my+param\""
    },
    {
        "link": "https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forms_and_events",
        "document": "If performance is not an issue (and it usually isn't!), inlining handlers is easiest as you can just use type inference and contextual typing:\n\nBut if you need to define your event handler separately, IDE tooling really comes in handy here, as the @type definitions come with a wealth of typing. Type what you are looking for and usually the autocomplete will help you out. Here is what it looks like for an for a form event:\n\nInstead of typing the arguments and return values with and , you may alternatively apply types to the event handler itself (contributed by @TomasHubelbauer):\n\nIf you don't quite care about the type of the event, you can just use . If your target form has custom named inputs that you'd like to access, you can use a type assertion:\n\nOf course, if you're making any sort of significant form, you should use Formik or React Hook Form, which are written in TypeScript."
    },
    {
        "link": "https://stackoverflow.com/questions/70646761/typescript-type-for-form-submit-event",
        "document": "What you have with is fine - but you can also omit it entirely (which I'd recommend) - there's no need to annotate types that TS can infer automatically. Less code when not necessary often means fewer possibilities of typos, fewer puzzles to solve, and greater readability, when there isn't lots of boilerplate to distract from the core functionality.\n\nWhich is expected - the is the element the event was dispatched to, which in this case is the form. It's not an array.\n\nIf you want the iterate over all values of the inputs, then either use separate states for them and then just log each state like you're doing currently (and make sure to give the states an initial string value, not an initial undefined value):\n\nOr, if the number of inputs is dynamic, construct an array of strings for state instead."
    },
    {
        "link": "https://epicreact.dev/how-to-type-a-react-form-on-submit-handler",
        "document": "Truly maintainable, flexible, simple, and reusable components require more thought than: \"I need it to do this differently, so I'll accept a new prop for that\". Seasoned React developers know this leads to nothing but pain and frustration for both the maintainer and user of the component."
    },
    {
        "link": "https://stackoverflow.com/questions/42081549/typescript-react-event-types",
        "document": "What is the correct type for React events?\n\nInitially I just used for the sake of simplicity. Now, I am trying to clean things up and avoid use of completely.\n\nSo in a simple form like this:\n\nWhat type do I use here as event type?\n\ndoes not seem to be working as I get an error that and do not exist on .\n\nMore generalised answer for all events would be really appreciated."
    },
    {
        "link": "https://claritydev.net/blog/typescript-typing-form-events-in-react",
        "document": "Handling user interactions and events is crucial for creating a dynamic and engaging user experience in web development. React, a popular JavaScript library, makes it easy to manage these events, and its approach is quite similar to handling events on DOM elements. However, there are a few differences and unique aspects that developers need to be aware of to get the most out of React event handling. For instance, event names in React follow the camel case convention, whereas in the DOM they are all lowercase. Additionally, in React, the function itself is passed as the event handler instead of its name in string form.\n\nThe most significant difference, however, is that in React the event handlers will receive as an argument a React event object, more commonly known as a \"synthetic event\". They are not 100% equivalent to the browser's native events, although the native event can still be accessed if necessary via the property of the event object. As a result, typing form events in React differs from native events, with React providing its own types.\n\nIn this post, we'll see how to type form events in React on the example of a simple form component. We will discuss how to properly type the event handlers for both controlled and uncontrolled forms, and highlight some best practices to follow when building forms in React.\n\nLet's use this simple signup form as an example:\n\nIf we want to collect form data and send it to a server, we have two main choices. The first option is to leave the form uncontrolled and get the data in the callback. The second option is to save the data in the form's state and send it when the form is submitted. We'll consider both approaches here.\n\nTo collect the form data when it's submitted, we'll add an callback and get the data from each element using the element's property.\n\nFor the sake of simplicity, data validation and error handling (as well as CSS styling) have been omitted in this code. To prevent the page from reloading before we collect the form data, it's important to call event.preventDefault() at the top of the callback function. Returning from the callback won't work here since synthetic events and native DOM events behave differently in this case.\n\nTo collect form data, we can either access it directly from the event's target by the element's or through the target's property. For example, both and work. We can also use the attribute to retrieve form element values, but since ids are already set up to connect inputs to their labels through the attribute, we'll use the attribute.\n\nNote that the event type is currently , meaning there's no type checking. To address this, we need to define the type of the for the callback.\n\nFor synthetic events, we can use the type definitions provided by React. The first choice would be to use with the type argument. However, this won't work for our form because we want to retrieve data from the attribute, which by default has the generic type. type eventually boils down to , where the last argument is used for the attribute type. It seems like we don't have control over the type of target attribute, and even if we did (we can always assert the type if needed) it still doesn't know which form elements our form has.\n\nLooking deeper into the type definitions of , we can see that the second type argument gets assigned to the property of the event. Therefore, it seems like to fix our type issue we just need to switch from to .\n\nThis approach almost works and would function correctly if we didn't have an input element with an id of in the form. As it currently stands, our overrides the attribute of the . However, there is a more significant issue with this method: the lack of proper type checking for target attributes.\n\nFor instance, attempting to access a non-existent form element via would not be caught by TypeScript because it is unaware of the elements present in the form. A more effective solution would involve defining the id-element pairs and typing the current target accordingly.\n\nTo accomplish this, we need to examine the type definition of . We can see that it includes , which comes with useful documentation:\n\nThis refers to the attribute we discussed earlier, except in this case, it is on the .\n\nBy connecting all the pieces, it appears we can extend with our form elements and then overwrite with that interface.\n\nThis takes care of the type issue and also provides proper type checking when accessing the values of the form elements.\n\nAlthough it is useful to know how to properly type uncontrolled form event handlers, this kind of form is less common in React components. Most of the time, we want the form to have controlled elements, with values and callbacks that can also come from the parent components. In such cases, it's common to save the form values onto the component's state and then send them to the server when the form is submitted, or even without using the form's submit event. Fortunately, typing such event handlers is more straightforward than the previous form example.\n\nAs an example, let's save the values entered by a user onto the state and then send them via an API when the user clicks Sign up. For simplicity's sake, we'll use one state object (similar to how the state is saved in class-based components):\n\nAlthough it's often preferable to use the hook to handle complex state, works for this demonstration. To update the form elements' values on the state, we'll need to assign handlers to each of the fields. The most obvious course of action here is to assign a different handler to each element, for example:\n\nHowever, there is an easier way. Similar to how the form's submit event has all the elements' ids or names saved onto the target, the change event's target has and attributes, which can be used to assign the respective element's value to the state. As we already have the ids defined on the fields (and these ids have the same names as the fields we're collecting the data from), we'll use them to match field data to the state.\n\nThere's a minor issue with this approach, though, and that is that we have one checkbox element. For checkbox elements, we're looking for the property instead of the value. In such cases, it's acceptable to have a separate handler for each element type, such as and . However, since we have a simple form with only one checkbox, let's add a condition to the handler, which will retrieve the property for the checkbox field based on the target's type.\n\nTypeScript types for the onChange event in form elements\n\nNote that we also reverted to the type for the submit event, since we no longer access the values from it. Now we just need to type the event. Initially, we try to type the event as , but that doesn't seem sufficient, as we encounter a type error indicating that all the properties we're trying to access do not exist on the event's target, for example: \"Property 'value' does not exist on type 'EventTarget & Element'\".\n\nUpon examining the definition for , we can see that it accepts a type argument, which defaults to a generic . Since all the form's elements are inputs, we'll use the type argument for :\n\nNow all the target's attributes are properly recognized; however, a new issue appears when reassigning to the value - \"Type 'boolean' is not assignable to type 'string'\".\n\nThis occurs because when we declare the value with , TypeScript infers its type to be a string, which is the type for the input's value. To fix this, we need to let TypeScript know that our value can also be a boolean: . This solution works well, but wouldn't it be better if TypeScript could automatically infer the type of value based on the state?\n\nFor instance, let's say we add a new field , which is an input with a type of number. To save it onto the state, we'd add this block to :\n\nTo eliminate the TypeScript error, we'd have to update the type of value to . However, if we eventually decided to remove the field, we'd also need to remember to update the value types again. We could define a separate type, where we declare the types for all the fields, but there's a better way.\n\nWe already have the types of state values available from the state, and we know that those types are the only ones each field will have. In such cases, it's better to infer the types from existing data, as this will automatically keep them in sync in case the data structure changes. To infer the types from the state, we can use this TypeScript notation:\n\nHere, we're telling TypeScript that we expect to be the type of the values present on the state, and if any of them change in the future, those changes will be automatically reflected in the type of .\n\nThe final code for the form looks like this:\n\nIn conclusion, understanding how to properly type form events in React is crucial for creating dynamic, engaging, and robust web applications. The article provided a step-by-step guide on how to define TypeScript input types and how they are used in conjunction with React's synthetic events. We dived into creating custom event handlers for event types and demonstrated the importance of typing form elements and event handlers for a more reliable and robust application. Additionally, we examined in TypeScript and its relevance in extracting user input from form elements. By following the guidelines and best practices shared in this article, you will be better equipped to tackle the challenges of form handling in your React applications using TypeScript."
    }
]