[
    {
        "link": "https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.BaggingClassifier.html",
        "document": "A Bagging classifier is an ensemble meta-estimator that fits base classifiers each on random subsets of the original dataset and then aggregate their individual predictions (either by voting or by averaging) to form a final prediction. Such a meta-estimator can typically be used as a way to reduce the variance of a black-box estimator (e.g., a decision tree), by introducing randomization into its construction procedure and then making an ensemble out of it.\n\nThis algorithm encompasses several works from the literature. When random subsets of the dataset are drawn as random subsets of the samples, then this algorithm is known as Pasting [1]. If samples are drawn with replacement, then the method is known as Bagging [2]. When random subsets of the dataset are drawn as random subsets of the features, then the method is known as Random Subspaces [3]. Finally, when base estimators are built on subsets of both samples and features, then the method is known as Random Patches [4].\n\nRead more in the User Guide.\n\nThe base estimator to fit on random subsets of the dataset. If None, then the base estimator is a . Added in version 1.2: was renamed to . The number of base estimators in the ensemble. The number of samples to draw from X to train each base estimator (with replacement by default, see for more details). The number of features to draw from X to train each base estimator ( without replacement by default, see for more details). Whether samples are drawn with replacement. If False, sampling without replacement is performed. Whether features are drawn with replacement. Whether to use out-of-bag samples to estimate the generalization error. Only available if bootstrap=True. When set to True, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just fit a whole new ensemble. See the Glossary. The number of jobs to run in parallel for both and . means 1 unless in a context. means using all processors. See Glossary for more details. Controls the random resampling of the original dataset (sample wise and feature wise). If the base estimator accepts a attribute, a different seed is generated for each instance in the ensemble. Pass an int for reproducible output across multiple function calls. See Glossary. Controls the verbosity when fitting and predicting. The base estimator from which the ensemble is grown. Added in version 1.2: was renamed to . Number of features seen during fit. Names of features seen during fit. Defined only when has feature names that are all strings. The subset of drawn samples for each base estimator. The subset of drawn features for each base estimator. Score of the training dataset obtained using an out-of-bag estimate. This attribute exists only when is True. Decision function computed with out-of-bag estimate on the training set. If n_estimators is small it might be possible that a data point was never left out during the bootstrap. In this case, might contain NaN. This attribute exists only when is True.\n\nNote that this method is only relevant if (see ). Please see User Guide on how the routing mechanism works. The options for each parameter are:\n• None : metadata is requested, and passed to if provided. The request is ignored if metadata is not provided.\n• None : metadata is not requested and the meta-estimator will not pass it to .\n• None : metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n• None : metadata should be passed to the meta-estimator with this given alias instead of the original name. The default ( ) retains the existing request. This allows you to change the request for some parameters and not others. This method is only relevant if this estimator is used as a sub-estimator of a meta-estimator, e.g. used inside a . Otherwise it has no effect."
    },
    {
        "link": "https://scikit-learn.org/0.18/modules/generated/sklearn.ensemble.BaggingClassifier.html",
        "document": "A Bagging classifier is an ensemble meta-estimator that fits base classifiers each on random subsets of the original dataset and then aggregate their individual predictions (either by voting or by averaging) to form a final prediction. Such a meta-estimator can typically be used as a way to reduce the variance of a black-box estimator (e.g., a decision tree), by introducing randomization into its construction procedure and then making an ensemble out of it.\n\nThis algorithm encompasses several works from the literature. When random subsets of the dataset are drawn as random subsets of the samples, then this algorithm is known as Pasting [R151]. If samples are drawn with replacement, then the method is known as Bagging [R152]. When random subsets of the dataset are drawn as random subsets of the features, then the method is known as Random Subspaces [R153]. Finally, when base estimators are built on subsets of both samples and features, then the method is known as Random Patches [R154].\n\nRead more in the User Guide.\n\nThe base estimator to fit on random subsets of the dataset. If None, then the base estimator is a decision tree. The number of base estimators in the ensemble. The number of samples to draw from X to train each base estimator. The number of features to draw from X to train each base estimator. Whether samples are drawn with replacement. Whether features are drawn with replacement. Whether to use out-of-bag samples to estimate the generalization error. When set to True, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just fit a whole new ensemble. The number of jobs to run in parallel for both and . If -1, then the number of jobs is set to the number of cores. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by . Controls the verbosity of the building process. The base estimator from which the ensemble is grown. The subset of drawn samples (i.e., the in-bag samples) for each base estimator. Each subset is defined by a boolean mask. The subset of drawn features for each base estimator. Score of the training dataset obtained using an out-of-bag estimate. Decision function computed with out-of-bag estimate on the training set. If n_estimators is small it might be possible that a data point was never left out during the bootstrap. In this case, might contain NaN.\n\nThe subset of drawn samples for each base estimator. Returns a dynamically generated list of boolean masks identifying the samples used for for fitting each member of the ensemble, i.e., the in-bag samples. Note: the list is re-created at each call to the property in order to reduce the object memory footprint by not storing the sampling data. Thus fetching the property may be slower than expected."
    },
    {
        "link": "https://github.com/scikit-learn/scikit-learn/blob/main/sklearn/ensemble/_bagging.py",
        "document": ""
    },
    {
        "link": "https://scikit-learn.org/stable/user_guide.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/26592769/should-it-be-possible-to-use-the-sklearn-ensemble-baggingclassifier-with-gaussia",
        "document": "I get an error when I try to use a BaggingClassifier with the GaussianNB naive bayes classifier and I'm not sure if it should be possible to use them together.\n\nMy question is. Should it be possible to use the sklearn.ensemble.BaggingClassifier with GaussianNB classifier?\n\nI want to use the BaggingClassifier ensemble method to train the GaussianNB classifier with a sequence of random subsets of my 300+ predictor columns. Here are the parameters I use to initialise\n\nMy dataset has over 300 columns and only a tiny subset will be suited for prediction for each of the different and unique datasets I am working with (each is a time series of stock market price data)\n\nI may give up and attempt to code this myself but I'm very new to sklearn so I dont want to reinvent the wheel. Perhaps there is another mechanism to do what I am trying to do.\n\nAny help is greatly appreciated :)"
    },
    {
        "link": "https://scikit-learn.org/stable/modules/ensemble.html",
        "document": "Ensemble methods combine the predictions of several base estimators built with a given learning algorithm in order to improve generalizability / robustness over a single estimator.\n\nTwo very famous examples of ensemble methods are gradient-boosted trees and random forests.\n\nMore generally, ensemble models can be applied to any base learner beyond trees, in averaging methods such as Bagging methods, model stacking, or Voting, or in boosting, as AdaBoost.\n\nIn ensemble algorithms, bagging methods form a class of algorithms which build several instances of a black-box estimator on random subsets of the original training set and then aggregate their individual predictions to form a final prediction. These methods are used as a way to reduce the variance of a base estimator (e.g., a decision tree), by introducing randomization into its construction procedure and then making an ensemble out of it. In many cases, bagging methods constitute a very simple way to improve with respect to a single model, without making it necessary to adapt the underlying base algorithm. As they provide a way to reduce overfitting, bagging methods work best with strong and complex models (e.g., fully developed decision trees), in contrast with boosting methods which usually work best with weak models (e.g., shallow decision trees). Bagging methods come in many flavours but mostly differ from each other by the way they draw random subsets of the training set:\n• None When random subsets of the dataset are drawn as random subsets of the samples, then this algorithm is known as Pasting [B1999].\n• None When samples are drawn with replacement, then the method is known as Bagging [B1996].\n• None When random subsets of the dataset are drawn as random subsets of the features, then the method is known as Random Subspaces [H1998].\n• None Finally, when base estimators are built on subsets of both samples and features, then the method is known as Random Patches [LG2012]. In scikit-learn, bagging methods are offered as a unified meta-estimator (resp. ), taking as input a user-specified estimator along with parameters specifying the strategy to draw random subsets. In particular, and control the size of the subsets (in terms of samples and features), while and control whether samples and features are drawn with or without replacement. When using a subset of the available samples the generalization accuracy can be estimated with the out-of-bag samples by setting . As an example, the snippet below illustrates how to instantiate a bagging ensemble of estimators, each built on random subsets of 50% of the samples and 50% of the features. L. Breiman, “Pasting small votes for classification in large databases and on-line”, Machine Learning, 36(1), 85-103, 1999. G. Louppe and P. Geurts, “Ensembles on Random Patches”, Machine Learning and Knowledge Discovery in Databases, 346-361, 2012.\n\nStacked generalization is a method for combining estimators to reduce their biases [W1992] [HTF]. More precisely, the predictions of each individual estimator are stacked together and used as input to a final estimator to compute the prediction. This final estimator is trained through cross-validation. The and provide such strategies which can be applied to classification and regression problems. The parameter corresponds to the list of the estimators which are stacked together in parallel on the input data. It should be given as a list of names and estimators: The will use the predictions of the as input. It needs to be a classifier or a regressor when using or , respectively: To train the and , the method needs to be called on the training data: During training, the are fitted on the whole training data . They will be used when calling or . To generalize and avoid over-fitting, the is trained on out-samples using internally. For , note that the output of the is controlled by the parameter and it is called by each estimator. This parameter is either a string, being estimator method names, or which will automatically identify an available method depending on the availability, tested in the order of preference: , and . A and can be used as any other regressor or classifier, exposing a , , or method, e.g.: Note that it is also possible to get the output of the stacked using the method: In practice, a stacking predictor predicts as good as the best predictor of the base layer and even sometimes outperforms it by combining the different strengths of the these predictors. However, training a stacking predictor is computationally expensive. For , when using , the first column is dropped when the problem is a binary classification problem. Indeed, both probability columns predicted by each estimator are perfectly collinear. Multiple stacking layers can be achieved by assigning to a or :\n\nThe module includes the popular boosting algorithm AdaBoost, introduced in 1995 by Freund and Schapire [FS1995]. The core principle of AdaBoost is to fit a sequence of weak learners (i.e., models that are only slightly better than random guessing, such as small decision trees) on repeatedly modified versions of the data. The predictions from all of them are then combined through a weighted majority vote (or sum) to produce the final prediction. The data modifications at each so-called boosting iteration consists of applying weights \\(w_1\\), \\(w_2\\), …, \\(w_N\\) to each of the training samples. Initially, those weights are all set to \\(w_i = 1/N\\), so that the first step simply trains a weak learner on the original data. For each successive iteration, the sample weights are individually modified and the learning algorithm is reapplied to the reweighted data. At a given step, those training examples that were incorrectly predicted by the boosted model induced at the previous step have their weights increased, whereas the weights are decreased for those that were predicted correctly. As iterations proceed, examples that are difficult to predict receive ever-increasing influence. Each subsequent weak learner is thereby forced to concentrate on the examples that are missed by the previous ones in the sequence [HTF]. AdaBoost can be used both for classification and regression problems: The following example shows how to fit an AdaBoost classifier with 100 weak learners: The number of weak learners is controlled by the parameter . The parameter controls the contribution of the weak learners in the final combination. By default, weak learners are decision stumps. Different weak learners can be specified through the parameter. The main parameters to tune to obtain good results are and the complexity of the base estimators (e.g., its depth or minimum required number of samples to consider a split ).\n• None Multi-class AdaBoosted Decision Trees shows the performance of AdaBoost on a multi-class problem.\n• None Two-class AdaBoost shows the decision boundary and decision function values for a non-linearly separable two-class problem using AdaBoost-SAMME.\n• None Decision Tree Regression with AdaBoost demonstrates regression with the AdaBoost.R2 algorithm. Y. Freund, and R. Schapire, “A Decision-Theoretic Generalization of On-Line Learning and an Application to Boosting”, 1997."
    },
    {
        "link": "https://scikit-learn.org/stable/modules/cross_validation.html",
        "document": "Learning the parameters of a prediction function and testing it on the same data is a methodological mistake: a model that would just repeat the labels of the samples that it has just seen would have a perfect score but would fail to predict anything useful on yet-unseen data. This situation is called overfitting. To avoid it, it is common practice when performing a (supervised) machine learning experiment to hold out part of the available data as a test set . Note that the word “experiment” is not intended to denote academic use only, because even in commercial settings machine learning usually starts out experimentally. Here is a flowchart of typical cross validation workflow in model training. The best parameters can be determined by grid search techniques.\n\nIn scikit-learn a random split into training and test sets can be quickly computed with the helper function. Let’s load the iris data set to fit a linear support vector machine on it:\n\nWe can now quickly sample a training set while holding out 40% of the data for testing (evaluating) our classifier:\n\nWhen evaluating different settings (“hyperparameters”) for estimators, such as the setting that must be manually set for an SVM, there is still a risk of overfitting on the test set because the parameters can be tweaked until the estimator performs optimally. This way, knowledge about the test set can “leak” into the model and evaluation metrics no longer report on generalization performance. To solve this problem, yet another part of the dataset can be held out as a so-called “validation set”: training proceeds on the training set, after which evaluation is done on the validation set, and when the experiment seems to be successful, final evaluation can be done on the test set.\n\nHowever, by partitioning the available data into three sets, we drastically reduce the number of samples which can be used for learning the model, and the results can depend on a particular random choice for the pair of (train, validation) sets.\n\nA solution to this problem is a procedure called cross-validation (CV for short). A test set should still be held out for final evaluation, but the validation set is no longer needed when doing CV. In the basic approach, called k-fold CV, the training set is split into k smaller sets (other approaches are described below, but generally follow the same principles). The following procedure is followed for each of the k “folds”:\n• None A model is trained using \\(k-1\\) of the folds as training data;\n• None the resulting model is validated on the remaining part of the data (i.e., it is used as a test set to compute a performance measure such as accuracy).\n\nThe performance measure reported by k-fold cross-validation is then the average of the values computed in the loop. This approach can be computationally expensive, but does not waste too much data (as is the case when fixing an arbitrary validation set), which is a major advantage in problems such as inverse inference where the number of samples is very small.\n\nThe following sections list utilities to generate indices that can be used to generate dataset splits according to different cross validation strategies. Assuming that some data is Independent and Identically Distributed (i.i.d.) is making the assumption that all samples stem from the same generative process and that the generative process is assumed to have no memory of past generated samples. The following cross-validators can be used in such cases. While i.i.d. data is a common assumption in machine learning theory, it rarely holds in practice. If one knows that the samples have been generated using a time-dependent process, it is safer to use a time-series aware cross-validation scheme. Similarly, if we know that the generative process has a group structure (samples collected from different subjects, experiments, measurement devices), it is safer to use group-wise cross-validation. divides all the samples in \\(k\\) groups of samples, called folds (if \\(k = n\\), this is equivalent to the Leave One Out strategy), of equal sizes (if possible). The prediction function is learned using \\(k - 1\\) folds, and the fold left out is used for test. Example of 2-fold cross-validation on a dataset with 4 samples: Here is a visualization of the cross-validation behavior. Note that is not affected by classes or groups. Each fold is constituted by two arrays: the first one is related to the training set, and the second one to the test set. Thus, one can create the training/test sets using numpy indexing: repeats K-Fold n times. It can be used when one requires to run n times, producing different splits in each repetition. Similarly, repeats Stratified K-Fold n times with different randomization in each repetition. (or LOO) is a simple cross-validation. Each learning set is created by taking all the samples except one, the test set being the sample left out. Thus, for \\(n\\) samples, we have \\(n\\) different training sets and \\(n\\) different tests set. This cross-validation procedure does not waste much data as only one sample is removed from the training set: Potential users of LOO for model selection should weigh a few known caveats. When compared with \\(k\\)-fold cross validation, one builds \\(n\\) models from \\(n\\) samples instead of \\(k\\) models, where \\(n > k\\). Moreover, each is trained on \\(n - 1\\) samples rather than \\((k-1) n / k\\). In both ways, assuming \\(k\\) is not too large and \\(k < n\\), LOO is more computationally expensive than \\(k\\)-fold cross validation. In terms of accuracy, LOO often results in high variance as an estimator for the test error. Intuitively, since \\(n - 1\\) of the \\(n\\) samples are used to build each model, models constructed from folds are virtually identical to each other and to the model built from the entire training set. However, if the learning curve is steep for the training size in question, then 5- or 10- fold cross validation can overestimate the generalization error. As a general rule, most authors, and empirical evidence, suggest that 5- or 10- fold cross validation should be preferred to LOO.\n• None L. Breiman, P. Spector Submodel selection and evaluation in regression: The X-random case, International Statistical Review 1992;\n• None R. Kohavi, A Study of Cross-Validation and Bootstrap for Accuracy Estimation and Model Selection, Intl. Jnt. Conf. AI\n• None R. Bharat Rao, G. Fung, R. Rosales, On the Dangers of Cross-Validation. An Experimental Evaluation, SIAM 2008; is very similar to as it creates all the possible training/test sets by removing \\(p\\) samples from the complete set. For \\(n\\) samples, this produces \\({n \\choose p}\\) train-test pairs. Unlike and , the test sets will overlap for \\(p > 1\\). Example of Leave-2-Out on a dataset with 4 samples: The iterator will generate a user defined number of independent train / test dataset splits. Samples are first shuffled and then split into a pair of train and test sets. It is possible to control the randomness for reproducibility of the results by explicitly seeding the pseudo random number generator. Here is a visualization of the cross-validation behavior. Note that is not affected by classes or groups. is thus a good alternative to cross validation that allows a finer control on the number of iterations and the proportion of samples on each side of the train / test split. Some classification problems can exhibit a large imbalance in the distribution of the target classes: for instance there could be several times more negative samples than positive samples. In such cases it is recommended to use stratified sampling as implemented in and to ensure that relative class frequencies is approximately preserved in each train and validation fold. is a variation of k-fold which returns stratified folds: each set contains approximately the same percentage of samples of each target class as the complete set. Here is an example of stratified 3-fold cross-validation on a dataset with 50 samples from two unbalanced classes. We show the number of samples in each class and compare with . We can see that preserves the class ratios (approximately 1 / 10) in both train and test dataset. Here is a visualization of the cross-validation behavior. can be used to repeat Stratified K-Fold n times with different randomization in each repetition. is a variation of ShuffleSplit, which returns stratified splits, i.e which creates splits by preserving the same percentage for each target class as in the complete set. Here is a visualization of the cross-validation behavior. For some datasets, a pre-defined split of the data into training- and validation fold or into several cross-validation folds already exists. Using it is possible to use these folds e.g. when searching for hyperparameters. For example, when using a validation set, set the to 0 for all samples that are part of the validation set, and to -1 for all other samples. The i.i.d. assumption is broken if the underlying generative process yields groups of dependent samples. Such a grouping of data is domain specific. An example would be when there is medical data collected from multiple patients, with multiple samples taken from each patient. And such data is likely to be dependent on the individual group. In our example, the patient id for each sample will be its group identifier. In this case we would like to know if a model trained on a particular set of groups generalizes well to the unseen groups. To measure this, we need to ensure that all the samples in the validation fold come from groups that are not represented at all in the paired training fold. The following cross-validation splitters can be used to do that. The grouping identifier for the samples is specified via the parameter. is a variation of k-fold which ensures that the same group is not represented in both testing and training sets. For example if the data is obtained from different subjects with several samples per-subject and if the model is flexible enough to learn from highly person specific features it could fail to generalize to new subjects. makes it possible to detect this kind of overfitting situations. Imagine you have three subjects, each with an associated number from 1 to 3: Each subject is in a different testing fold, and the same subject is never in both testing and training. Notice that the folds do not have exactly the same size due to the imbalance in the data. If class proportions must be balanced across folds, is a better option. Here is a visualization of the cross-validation behavior. Similar to , the test sets from will form a complete partition of all the data. While attempts to place the same number of samples in each fold when , when it attempts to place equal number of distinct groups in each fold (but doesn not account for group sizes). is a cross-validation scheme that combines both and . The idea is to try to preserve the distribution of classes in each split while keeping each group within a single split. That might be useful when you have an unbalanced dataset so that using just might produce skewed splits.\n• None With the current implementation full shuffle is not possible in most scenarios. When shuffle=True, the following happens:\n• None Groups are sorted by standard deviation of classes using stable sort.\n• None Sorted groups are iterated over and assigned to folds. That means that only groups with the same standard deviation of class distribution will be shuffled, which might be useful when each group has only a single class.\n• None The algorithm greedily assigns each group to one of n_splits test sets, choosing the test set that minimises the variance in class distribution across test sets. Group assignment proceeds from groups with highest to lowest variance in class frequency, i.e. large groups peaked on one or few classes are assigned first.\n• None This split is suboptimal in a sense that it might produce imbalanced splits even if perfect stratification is possible. If you have relatively close distribution of classes in each group, using is better. Here is a visualization of cross-validation behavior for uneven groups: is a cross-validation scheme where each split holds out samples belonging to one specific group. Group information is provided via an array that encodes the group of each sample. Each training set is thus constituted by all the samples except the ones related to a specific group. This is the same as with and the same as with equal to the number of unique labels passed to the parameter. For example, in the cases of multiple experiments, can be used to create a cross-validation based on the different experiments: we create a training set using the samples of all the experiments except one: Another common application is to use time information: for instance the groups could be the year of collection of the samples and thus allow for cross-validation against time-based splits. is similar as , but removes samples related to \\(P\\) groups for each training/test set. All possible combinations of \\(P\\) groups are left out, meaning test sets will overlap for \\(P>1\\). Example of Leave-2-Group Out: The iterator behaves as a combination of and , and generates a sequence of randomized partitions in which a subset of groups are held out for each split. Each train/test split is performed independently meaning there is no guaranteed relationship between successive test sets. Here is a visualization of the cross-validation behavior. This class is useful when the behavior of is desired, but the number of groups is large enough that generating all possible partitions with \\(P\\) groups withheld would be prohibitively expensive. In such a scenario, provides a random sample (with replacement) of the train / test splits generated by . Using cross-validation iterators to split train and test# The above group cross-validation functions may also be useful for splitting a dataset into training and testing subsets. Note that the convenience function is a wrapper around and thus only allows for stratified splitting (using the class labels) and cannot account for groups. To perform the train and test split, use the indices for the train and test subsets yielded by the generator output by the method of the cross-validation splitter. For example: Time series data is characterized by the correlation between observations that are near in time (autocorrelation). However, classical cross-validation techniques such as and assume the samples are independent and identically distributed, and would result in unreasonable correlation between training and testing instances (yielding poor estimates of generalization error) on time series data. Therefore, it is very important to evaluate our model for time series data on the “future” observations least like those that are used to train the model. To achieve this, one solution is provided by . is a variation of k-fold which returns first \\(k\\) folds as train set and the \\((k+1)\\) th fold as test set. Note that unlike standard cross-validation methods, successive training sets are supersets of those that come before them. Also, it adds all surplus data to the first training partition, which is always used to train the model. This class can be used to cross-validate time series data samples that are observed at fixed time intervals. Example of 3-split time series cross-validation on a dataset with 6 samples: Here is a visualization of the cross-validation behavior.\n\noffers another way to evaluate the performance of classifiers. It provides a permutation-based p-value, which represents how likely an observed performance of the classifier would be obtained by chance. The null hypothesis in this test is that the classifier fails to leverage any statistical dependency between the features and the labels to make correct predictions on left out data. generates a null distribution by calculating different permutations of the data. In each permutation the labels are randomly shuffled, thereby removing any dependency between the features and the labels. The p-value output is the fraction of permutations for which the average cross-validation score obtained by the model is better than the cross-validation score obtained by the model using the original data. For reliable results should typically be larger than 100 and between 3-10 folds. A low p-value provides evidence that the dataset contains real dependency between features and labels and the classifier was able to utilize this to obtain good results. A high p-value could be due to a lack of dependency between features and labels (there is no difference in feature values between the classes) or because the classifier was not able to use the dependency in the data. In the latter case, using a more appropriate classifier that is able to utilize the structure in the data, would result in a lower p-value. Cross-validation provides information about how well a classifier generalizes, specifically the range of expected errors of the classifier. However, a classifier trained on a high dimensional dataset with no structure may still perform better than expected on cross-validation, just by chance. This can typically happen with small datasets with less than a few hundred samples. provides information on whether the classifier has found a real class structure and can help in evaluating the performance of the classifier. It is important to note that this test has been shown to produce low p-values even if there is only weak structure in the data because in the corresponding permutated datasets there is absolutely no structure. This test is therefore only able to show when the model reliably outperforms random guessing. Finally, is computed using brute force and internally fits models. It is therefore only tractable with small datasets for which fitting an individual model is very fast.\n• None Test with permutations the significance of a classification score"
    },
    {
        "link": "https://pluralsight.com/resources/blog/guides/ensemble-modeling-scikit-learn",
        "document": "Ensemble methods are advanced techniques, often used to solve complex machine learning problems. In simple terms, it is a process where different and independent models (also referred to as the \"weak learners\") are combined to produce an outcome. The hypothesis is that combining multiple models can produce better results by decreasing the generalization error. Three of the most popular methods for ensemble modeling are Bagging, Boosting, and Voting. In this guide, you will learn how to implement the following ensemble modeling techniques using scikit-learn: We will begin by understanding the Problem Statement and the data.\n\nIn this guide, we will try to recognize letters, which is one of the earliest applications of machine learning. In this problem, we will build a model that uses statistics of images of four letters in the Roman alphabet - A, B, P, and R - to predict which letter an image corresponds to. The data comes from the UCI Machine Learning Repository, and contains 3116 records of 17 variables:\n• letter - The letter that the image corresponds to (A, B, P or R). This is the target variable.\n• xbox - The horizontal position of where the smallest box covering the letter shape begins.\n• ybox - The vertical position of where the smallest box covering the letter shape begins.\n• width - The width of the smallest box.\n• height - The height of the smallest box.\n• onpix - The total number of \"on\" pixels in the character image.\n• xbar - The mean horizontal position of all of the \"on\" pixels.\n• ybar - The mean vertical position of all of the \"on\" pixels.\n• x2bar - The mean squared horizontal position of all of the \"on\" pixels in the image.\n• y2bar - The mean squared vertical position of all of the \"on\" pixels in the image.\n• xybar - The mean of the product of the horizontal and vertical position of all of the \"on\" pixels in the image.\n• x2ybar - The mean of the product of the squared horizontal position and the vertical position of all of the \"on\" pixels.\n• xy2bar - The mean of the product of the horizontal position and the squared vertical position of all of the \"on\" pixels.\n• xedge - The mean number of edges (the number of times an \"off\" pixel is followed by an \"on\" pixel, or the image boundary is hit) as the image is scanned from left to right, along the whole vertical length of the image.\n• xedgeycor - The mean of the product of the number of horizontal edges at each vertical position and the vertical position.\n• yedge - The mean number of edges as the image is scanned from top to bottom, along the whole horizontal length of the image.\n• yedgexcor = The mean of the product of the number of vertical edges at each horizontal position and the horizontal position.\n\nThe goal of ensemble modeling is to improve the performance over an individual model by combining multiple models. So, we will set the baseline performance measure by starting with one algorithm. In our case, we will build the Logistic Regression Algorithm. The first line of code creates the training and test set, with the 'test_size' argument specifying the percentage of data to be kept in the test data. The second line instantiates the Logistic Regression algorithm, while the third line fits the model on the training dataset. The fourth line generates predictions on the test data, while the fifth to seventh lines of code prints the output.\n\nThis method performs best with algorithms that have high variance, for example, the decision trees. In scikit-learn, bagging methods are offered as a unified BaggingClassifier meta-estimator. The first line of code creates the kfold cross validation framework. The second line instantiates the BaggingClassifier() model, with Decision Tree as the base estimator and 100 as the number of trees. The third line generates the cross validated scores on the data, while the fourth line prints the mean cross-validation accuracy score.\n\nRandom Forest is an extension of bagged decision trees, where the samples of the training dataset are taken with replacement. The trees are constructed with the objective of reducing the correlation between the individual decision trees. In scikit-learn, a random forest model is constructed by using the RandomForestClassifier class. The first line of code creates the kfold cross validation object. The second line instantiates the RandomForestClassifier() ensemble. The third line generates the cross validated scores on the data, while the fourth line prints the mean cross-validation accuracy score.\n\nAdaBoost, short for 'Adaptive Boosting', is the first practical boosting algorithm proposed by Freund and Schapire in 1996. It focuses on classification problems and aims to convert a set of weak classifiers into a strong one. In scikit-learn, an adaboost model is constructed by using the AdaBoostClassifier class. The first line of code creates the kfold cross validation object. The second line instantiates the AdaBoostClassifier() ensemble. The third line generates the cross validated scores on the data, while the fourth line prints the mean cross-validation accuracy score.\n\nIn scikit-learn, a stochastic gradient boosting model is constructed by using the GradientBoostingClassifier class. The steps to perform this ensembling technique are almost exactly like the ones discussed above, with the exception being the third line of code. Running the codes and looking at the output below, we observe that the accuracy of the ensemble is 98.39 percent.\n\nVoting is a simple but extremely effective ensemble technique that works by combining the predictions from multiple machine learning algorithms. In scikit-learn, it is constructed by using the VotingClassifier class. The first line of code creates the kfold cross validation object. The second to eight lines of code instantiates three models - Logistic Regression, Decision Tree, and Support Vector Machine - and appends these algorithms into an object ‘estimator’. The ninth line instantiates the VotingClassifier() ensemble. The tenth line generates the cross validated scores on the data, while the last line of code prints the mean cross-validation accuracy score. Looking at the output below, we observe that the accuracy of the ensemble is 98.52 percent."
    },
    {
        "link": "https://scikit-learn.org/stable/common_pitfalls.html",
        "document": "The purpose of this chapter is to illustrate some common pitfalls and anti-patterns that occur when using scikit-learn. It provides examples of what not to do, along with a corresponding correct example.\n\nscikit-learn provides a library of Dataset transformations, which may clean (see Preprocessing data), reduce (see Unsupervised dimensionality reduction), expand (see Kernel Approximation) or generate (see Feature extraction) feature representations. If these data transforms are used when training a model, they also must be used on subsequent datasets, whether it’s test data or data in a production system. Otherwise, the feature space will change, and the model will not be able to perform effectively. For the following example, let’s create a synthetic dataset with a single feature: The train dataset is scaled, but not the test dataset, so model performance on the test dataset is worse than expected: Instead of passing the non-transformed to , we should transform the test data, the same way we transformed the training data: Alternatively, we recommend using a , which makes it easier to chain transformations with estimators, and reduces the possibility of forgetting a transformation: Pipelines also help avoiding another common pitfall: leaking the test data into the training data.\n\nData leakage occurs when information that would not be available at prediction time is used when building the model. This results in overly optimistic performance estimates, for example from cross-validation, and thus poorer performance when the model is used on actually novel data, for example during production. A common cause is not keeping the test and train data subsets separate. Test data should never be used to make choices about the model. The general rule is to never call on the test data. While this may sound obvious, this is easy to miss in some cases, for example when applying certain pre-processing steps. Although both train and test data subsets should receive the same preprocessing transformation (as described in the previous section), it is important that these transformations are only learnt from the training data. For example, if you have a normalization step where you divide by the average value, the average should be the average of the train subset, not the average of all the data. If the test subset is included in the average calculation, information from the test subset is influencing the model. Below are some tips on avoiding data leakage:\n• None Always split the data into train and test subsets first, particularly before any preprocessing steps.\n• None Never include test data when using the and methods. Using all the data, e.g., , can result in overly optimistic scores. Conversely, the method should be used on both train and test subsets as the same preprocessing should be applied to all the data. This can be achieved by using on the train subset and on the test subset.\n• None The scikit-learn pipeline is a great way to prevent data leakage as it ensures that the appropriate method is performed on the correct data subset. The pipeline is ideal for use in cross-validation and hyper-parameter tuning functions. An example of data leakage during preprocessing is detailed below. We here choose to illustrate data leakage with a feature selection step. This risk of leakage is however relevant with almost all transformations in scikit-learn, including (but not limited to) , , and . A number of Feature selection functions are available in scikit-learn. They can help remove irrelevant, redundant and noisy features as well as improve your model build time and performance. As with any other type of preprocessing, feature selection should only use the training data. Including the test data in feature selection will optimistically bias your model. To demonstrate we will create this binary classification problem with 10,000 randomly generated features: Using all the data to perform feature selection results in an accuracy score much higher than chance, even though our targets are completely random. This randomness means that our and are independent and we thus expect the accuracy to be around 0.5. However, since the feature selection step ‘sees’ the test data, the model has an unfair advantage. In the incorrect example below we first use all the data for feature selection and then split the data into training and test subsets for model fitting. The result is a much higher than expected accuracy score: To prevent data leakage, it is good practice to split your data into train and test subsets first. Feature selection can then be formed using just the train dataset. Notice that whenever we use or , we only use the train dataset. The score is now what we would expect for the data, close to chance: Here again, we recommend using a to chain together the feature selection and model estimators. The pipeline ensures that only the training data is used when performing and the test data is used only for calculating the accuracy score: The pipeline can also be fed into a cross-validation function such as . Again, the pipeline ensures that the correct data subset and estimator method is used during fitting and predicting:\n\nSome scikit-learn objects are inherently random. These are usually estimators (e.g. ) and cross-validation splitters (e.g. ). The randomness of these objects is controlled via their parameter, as described in the Glossary. This section expands on the glossary entry, and describes good practices and common pitfalls w.r.t. this subtle parameter. For an optimal robustness of cross-validation (CV) results, pass instances when creating estimators, or leave to . Passing integers to CV splitters is usually the safest option and is preferable; passing instances to splitters may sometimes be useful to achieve very specific use-cases. For both estimators and splitters, passing an integer vs passing an instance (or ) leads to subtle but significant differences, especially for CV procedures. These differences are important to understand when reporting results. For reproducible results across executions, remove any use of . Using or instances, and repeated calls to and # The parameter determines whether multiple calls to fit (for estimators) or to split (for CV splitters) will produce the same results, according to these rules:\n• None If an integer is passed, calling or multiple times always yields the same results.\n• None If or a instance is passed: and will yield different results each time they are called, and the succession of calls explores all sources of entropy. is the default value for all parameters. We here illustrate these rules for both estimators and CV splitters. Since passing is equivalent to passing the global instance from ( ), we will not explicitly mention here. Everything that applies to instances also applies to using . Passing instances means that calling multiple times will not yield the same results, even if the estimator is fitted on the same data and with the same hyper-parameters: We can see from the snippet above that repeatedly calling has produced different models, even if the data was the same. This is because the Random Number Generator (RNG) of the estimator is consumed (i.e. mutated) when is called, and this mutated RNG will be used in the subsequent calls to . In addition, the object is shared across all objects that use it, and as a consequence, these objects become somewhat inter-dependent. For example, two estimators that share the same instance will influence each other, as we will see later when we discuss cloning. This point is important to keep in mind when debugging. If we had passed an integer to the parameter of the , we would have obtained the same models, and thus the same scores each time. When we pass an integer, the same RNG is used across all calls to . What internally happens is that even though the RNG is consumed when is called, it is always reset to its original state at the beginning of . Randomized CV splitters have a similar behavior when a instance is passed; calling multiple times yields different data splits: We can see that the splits are different from the second time is called. This may lead to unexpected results if you compare the performance of multiple estimators by calling many times, as we will see in the next section. While the rules that govern the parameter are seemingly simple, they do however have some subtle implications. In some cases, this can even lead to wrong conclusions. Different `random_state` types lead to different cross-validation procedures Depending on the type of the parameter, estimators will behave differently, especially in cross-validation procedures. Consider the following snippet: We see that the cross-validated scores of and are different, as should be expected since we didn’t pass the same parameter. However, the difference between these scores is more subtle than it looks, and the cross-validation procedures that were performed by significantly differ in each case:\n• None Since was passed an integer, every call to uses the same RNG: this means that all random characteristics of the random forest estimator will be the same for each of the 5 folds of the CV procedure. In particular, the (randomly chosen) subset of features of the estimator will be the same across all folds.\n• None Since was passed a instance, each call to starts from a different RNG. As a result, the random subset of features will be different for each folds. While having a constant estimator RNG across folds isn’t inherently wrong, we usually want CV results that are robust w.r.t. the estimator’s randomness. As a result, passing an instance instead of an integer may be preferable, since it will allow the estimator RNG to vary for each fold. Here, will use a non-randomized CV splitter (as is the default), so both estimators will be evaluated on the same splits. This section is not about variability in the splits. Also, whether we pass an integer or an instance to isn’t relevant for our illustration purpose: what matters is what we pass to the estimator. Another subtle side effect of passing instances is how will work: Since a instance was passed to , and are not clones in the strict sense, but rather clones in the statistical sense: and will still be different models, even when calling on the same data. Moreover, and will influence each-other since they share the same internal RNG: calling will consume ’s RNG, and calling will consume ’s RNG, since they are the same. This bit is true for any estimators that share a parameter; it is not specific to clones. If an integer were passed, and would be exact clones and they would not influence each other. Even though is rarely used in user code, it is called pervasively throughout scikit-learn codebase: in particular, most meta-estimators that accept non-fitted estimators call internally ( , , , etc.). When passed a instance, CV splitters yield different splits each time is called. When comparing different estimators, this can lead to overestimating the variance of the difference in performance between the estimators: Directly comparing the performance of the estimator vs the estimator on each fold would be a mistake: the splits on which the estimators are evaluated are different. Indeed, will internally call on the same instance, but the splits will be different each time. This is also true for any tool that performs model selection via cross-validation, e.g. and : scores are not comparable fold-to-fold across different calls to , since would have been called multiple times. Within a single call to , however, fold-to-fold comparison is possible since the search estimator only calls once. For comparable fold-to-fold results in all scenarios, one should pass an integer to the CV splitter: . While fold-to-fold comparison is not advisable with instances, one can however expect that average scores allow to conclude whether one estimator is better than another, as long as enough folds and data are used. What matters in this example is what was passed to . Whether we pass a instance or an integer to is not relevant for our illustration purpose. Also, neither nor are randomized estimators. In order to obtain reproducible (i.e. constant) results across multiple program executions, we need to remove all uses of , which is the default. The recommended way is to declare a variable at the top of the program, and pass it down to any object that accepts a parameter: We are now guaranteed that the result of this script will always be 0.84, no matter how many times we run it. Changing the global variable to a different value should affect the results, as expected. It is also possible to declare the variable as an integer. This may however lead to less robust cross-validation results, as we will see in the next section. We do not recommend setting the global seed by calling . See here for a discussion. When we evaluate a randomized estimator performance by cross-validation, we want to make sure that the estimator can yield accurate predictions for new data, but we also want to make sure that the estimator is robust w.r.t. its random initialization. For example, we would like the random weights initialization of a to be consistently good across all folds: otherwise, when we train that estimator on new data, we might get unlucky and the random initialization may lead to bad performance. Similarly, we want a random forest to be robust w.r.t the set of randomly selected features that each tree will be using. For these reasons, it is preferable to evaluate the cross-validation performance by letting the estimator use a different RNG on each fold. This is done by passing a instance (or ) to the estimator initialization. When we pass an integer, the estimator will use the same RNG on each fold: if the estimator performs well (or bad), as evaluated by CV, it might just be because we got lucky (or unlucky) with that specific seed. Passing instances leads to more robust CV results, and makes the comparison between various algorithms fairer. It also helps limiting the temptation to treat the estimator’s RNG as a hyper-parameter that can be tuned. Whether we pass instances or integers to CV splitters has no impact on robustness, as long as is only called once. When is called multiple times, fold-to-fold comparison isn’t possible anymore. As a result, passing integer to CV splitters is usually safer and covers most use-cases."
    },
    {
        "link": "https://inside-machinelearning.com/en/cross-validation-tutorial",
        "document": "Cross Validation – THE Tutorial How To Use it – sklearn\n\nIn this tutorial we will see how to simply use Cross Validation with Scikit-Learn and how to use it for prediction.\n\nThere are only 4 steps to perform a Cross Validation:\n• evaluate the model on the last subgroup\n• repeat steps 2 and 3 so that all subgroups are evaluated\n\nHere, the Cross Validation will give us, at the end of the workflow, 5 different Machine Learning models.\n\nThis multiplicity of models will allow us to have a diversity in the final predictions.\n\nActually, Cross Validation give us the opinion of 5 experts (5 models) instead of only one.\n\nYou can choose the number of subgroups created during Cross Validation, be it 2, 3, 5 or 40. The only constraint is to have enough data in each subgroup to get a robust model.\n\nOnce we have all these opinions, we’ll have to decide which expert to follow. This is what we will see in this article.\n\nThis tutorial is following our detailed article on learning Machine Learning.\n\nBut of course, you can follow this tutorial without having followed the previous one. You only have to download the dataset winequality-white.csv from this Github address.\n\nOur dataset ranks wines according to their quality. The objective is to predict the quality level of wines from their features (acidity, alcohol level, pH, etc).\n\nOnce the dataset is loaded in your working environment, open it with the Pandas library:\n\nTo make sure that these subgroups have a fair distribution, we first shuffle the dataset with the function:\n\nreset the index of each line after the shuffling.\n\nNext, we prepare our features (X) and label (Y) for the Cross Validation:\n\nNote: Here we don’t need train and test data. Indeed in Cross Validation, each subgroup is used once for testing and N-1 times for training. It is, therefore, not necessary to indicate train and test set because all subgroups go through these stages.\n\nLet’s load the best performing model from our article for learning Machine Learning: Decision Tree.\n\nWith this model we had obtained an accuracy of 60%.\n\nCan we do better?\n\nWe can see that directly with sklearn function:\n\nFor this evaluation we’ve chosen to perform a Cross Validation on 10 subgroups by indicating .\n\nThis allow us to train 10 different models of Decision Tree.\n\nLet’s display the result of these 10 models:\n\nMost of the models have an accuracy above 60%. This is a very good signal!\n\nLet’s calculate the mean to know the real potential of this Cross Validation:\n\n61.9% of accuracy, that’s 1.9% more than the score obtained in the first tutorial.\n\nThe problem is that does not recover the trained models.\n\nThis function only test Cross Validation on our dataset and our model.\n\nActually, enables Data Scientists and Machine Learning Engineers to know if it is worth implementing Cross Validation.\n\nNow that we know Cross Validation will improve our model, we can get down to business!\n\nFirst, I suggest to divide our dataset in two:\n• Data for Cross Validation, which we will call\n• Data for testing the final models, which we will call for global test\n\nTo separate our dataset we use the function ( will be composed of 10% of our dataset):\n\nAnd now we can implement the REAL Cross Validation.\n\nFor this, it’s simple, we use the function.\n\nWe can now display the score for each of the 10 trained models:\n\nWe’ve gained 0.8% for the test data. It’s not much but it’s an acceptable score.\n\nWhat about the global test data that the model has never seen?\n\nTo measure our Cross Validation, we will go through each of our models (stored in the variable ) and calculate the score for and :\n\nHere is the final score of the Cross Validation:\n\nWe gain 1.8% of precision compared to our basic model! This is huge! 🎉\n\n1.8% improvement in accuracy may seem not enough from the point of view of a novice in Machine Learning but any expert knows it is a huge improvement!\n\nIndeed, Machine Learning competitions are sometimes played with only 0.001% difference in accuracy.\n\nHow to use CV models for predictions?\n\nThere are different approaches depending on the practitioner:\n• Take the best of the N models and use it directly\n• Take the best of the N models and re-train it on the whole data set\n• Keep the N models and rely on the opinion of the majority\n\nI want to make it clear that there is no wrong way to do this. Each method is worthwhile and will be useful depending on your particular context. The best option is to test by yourself!\n\nAfter reading our article to learn Machine Learning, you should be able to use the first two options.\n\nI propose to detail the 3rd option which is the most complex, especially since it is divided into two techniques.\n\nIn the following parts, we’ll predict the result for the first wine of .\n• – the raw results, in our case the quality of wine: 3, 4, 5, 6, 7, 8 or 9\n\nIn this part, we use the predict() option.\n\nWe predict, for each of the 10 models, the quality of the first wine of our data:\n\nEach of these results are stored in a list, which can be displayed:\n\nThe objective now is to take the prediction that has appeared the most often.\n\nHere, we see that most of our models conclude that the wine is of quality 5, when three of them predicted 6.\n\nWe extract the most frequently predicted value…\n\n… which we can compared with the real value:\n\nHere the real value is well predicted! The majority was right!\n\nFinally, I’d like to use the option which is the most complex of all.\n\nFor our Machine Learning model, 7 levels of wine quality are possible: 3, 4, 5, 6, 7, 8 or 9.\n\nWith we get the probability that our wine is of each quality. For example: 20% that the wine is of quality 3, 8% for quality 4, 58% for quality 5, etc.\n\nWith our Cross Validation, we’ll obtain 10 lists of probabilities.\n\nTo calculate the prediction of the Cross Validation, we’ll sum all these probabilities together and divide the result by the number of subgroups, 10.\n\nActually, we average all our probabilities to determine the quality with the highest overall probability.\n\nFirst, we sum the probabilities together:\n\nThen we calculate the average:\n\nWe extract the index with the highest probability:\n\nHere, the index is 2, it indicates a quality of 5.\n\nIndeed, if we take our list of possible results , the first index being 0, quality 3, the second corresponds to quality 5:\n\nHere, the end result for the raw prediction and the probabilistic prediction remains the same, but keep in mind that this is not always the case.\n\nIn this article, we learned how to improve the accuracy of our Machine Learning model by 1.8% and how to use Cross Validation for prediction.\n\nOther methods exist to improve a Machine Learning model like:\n\nOne last thing: Cross Validation is not to be taken lightly. It is a technique used in 2022 by the best experts to push Machine Learning models to their maximum performance.\n\nCross Validation is even used for Deep Learning!\n\nSoon, an article will be published on the subject.\n\nIn the meantime, if you want to stay informed, don’t hesitate to subscribe to our newsletter 😉"
    }
]