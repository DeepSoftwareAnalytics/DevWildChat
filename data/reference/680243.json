[
    {
        "link": "https://geeksforgeeks.org/converting-context-free-grammar-chomsky-normal-form",
        "document": "Chomsky Normal Form (CNF) is a way to simplify context-free grammars (CFGs) so that all production rules follow specific patterns. In CNF, each rule either produces two non-terminal symbols, a single terminal symbol, or, in some cases, the empty string. Converting a CFG to CNF is an important step in many parsing algorithms, like the CYK algorithm, and helps in understanding the structure of languages.\n\nA context free grammar (CFG) is in Chomsky Normal Form (CNF) if all production rules satisfy one of the following conditions:\n\nConsider the following grammars,\n\nThe grammar G1 is in CNF as production rules satisfy the rules specified for CNF. However, the grammar G2 is not in CNF as the production rule S->aZ contains terminal followed by non-terminal which does not satisfy the rules specified for CNF.\n• None A single CFG can be converted into different equivalent CNF forms.\n• None CNF produces the same language as the original CFG.\n• None CNF is widely used in parsing algorithms such as:\n• None For a string of length nnn, a CNF derivation requires at most 2n-1 derivation steps.\n• None Any CFG that does not generate ε has an equivalent CNF.\n\nIf start symbol S is at the RHS of any production in the grammar, create a new production as: S0->S where S0 is the new start symbol.\n• Null (ε) Productions: ε , remove it by modifying other rules accordingly.\n• Unit Productions: If a rule has a single non – [Tex]A→B[/Tex]\n\nEliminate terminals from RHS if they exist with other terminals or non-terminals. e.g,; production rule X->xY can be decomposed as: X->ZY, Z->x\n\nStep 4: Reduce Productions with More Than Two Non-Terminals\n\nEliminate RHS with more than two non-terminals. e.g,; production rule X->XYZ can be decomposed as: X->PZ, P->XY\n\nLet us take an example to convert CFG to CNF. Consider the given grammar G1:\n\nAs start symbol S appears on the RHS, we will create a new production rule S0->S. Therefore, the grammar will become:\n\nAs grammar contains null production A-> ε, its removal from the grammar yields:\n\nNow, it creates null production B→ ε, its removal from the grammar yields:\n\nNow, it creates unit production B->A, its removal from the grammar yields:\n\nAlso, removal of unit production S0->S from grammar yields:\n\nAlso, removal of unit production S->S and S0->S from grammar yields:\n\nIn production rule A->aAS |aS and B-> SbS|aAS|aS, terminals a and b exist on RHS with non-terminates. Removing them from RHS:\n\nAlso, B->bb can’t be part of CNF, removing it from grammar yields:\n\nIn production rule S0->ASB, RHS has more than two symbols, removing it from grammar yields:\n\nSimilarly, S->ASB has more than two symbols, removing it from grammar yields:\n\nSimilarly, A->XAS has more than two symbols, removing it from grammar yields:\n\nSimilarly, B->SYS has more than two symbols, removing it from grammar yields:\n\nSimilarly, B->XAX has more than two symbols, removing it from grammar yields:\n\nSo this is the required CNF for given grammar.\n\nWhat are null, unit, and useless productions?\n\nIs it possible to convert ambiguous grammars to CNF?\n\nCan deterministic context-free languages always be converted to unambiguous CNF?"
    },
    {
        "link": "https://github.com/BaseMax/CFG2CNF",
        "document": "Python tool able to convert a Context Free Grammar in Chomsky Normal Form\n\nI read 7 chapters of the book and the result of my study was writing this program.\n\nAn Introduction to Formal Languages and Automata by Peter Linz\n\nChomsky Normal Form is a context-free grammar that has been put into a specific format. It was developed by Noam Chomsky in 1978 and is part of formal language theory.\n\nThe above grammar is equivalent to the following grammar:\n\nThe image below will change your think of the Automata:\n\nSure, We are need this subject all of the day, Also programming languages!\n\nFollow this way by reading following book.\n\nIf you find a problem or bugs in program, please send Issue or PR, i'm a new member in this study...\n\nThanks to Khalilian for providing these videos and the great help he did.\n\nMy nickname is Max, Programming language developer, Full-stack programmer. I love computer scientists, researchers, and compilers. (Max Base)"
    },
    {
        "link": "https://shane.st/teaching/571/aut19/hw2.html",
        "document": "This assignment is due Wednesday, October 9 at 11PM.\n\nThrough this assignment you will:\n• Begin development of an automatic parser.\n• Homework #3 will require the implementation of the CKY algorithm.\n• Improve your understanding of Chomsky Normal Form (CNF) and weak grammatical equivalence through implementaiton.\n\nPlease review the class slides and readings in the textbook on Chomsky Normal Form conversion.\n\nAs noted in the text, the CKY algorithm requires a grammar in Chomsky Normal Form (CNF). While it is not always intuitively clear how to write a grammar from scratch in CNF, it is fairly straightforward to convert a context-free grammar into a weakly equivalent grammar in CNF.\n\nFollowing the approach outlined in class, implement a procedure to convert an input grammar of the form to be used for the first assignment to a new weakly equivalent grammar in CNF.\n\nYou will want to create data structures corresponding to RULE, RHS, LHS, etc. You may use whatever programming language you like, in accordance with the Course Policy. You may use existing implementations of these data structures in NLTK or other NLP toolkits (e.g. the Stanford Parser), but you must implement the grammar conversion algorithm yourself.\n\nThe program you submit should do the following:\n• Print out the rules of the converted grammar to a file.\n\nCreate a program named hw2_tocnf to perform the conversion described above. Your program should be able to be invoked with:\n• is the name of the file holding the grammar to convert to CNF.\n• is the name of the output file for the CNF conversion. The file should be in the NLTK grammar format, but now in Chomsky Normal Form.\n\nUsing your system from HW#1, you will parse a set of sentences with\n\nNOTE: You will need to run your code yourself in both these conditions with the files specified below. You will include the output parse files in your submission tar file. You do not need to run this code as part of your condor file.\n\nYou will find the following files in /dropbox/19-20/571/hw2:\n• :\n• CFG grammar to test your CNF conversion program on.\n• :\n• Set of sentences for validation of your CNF conversion.\n• You will use your HW #1 system to parse these sentences both:\n• With your CNF-convertd version of the ATIS grammar.\n• :\n• Directory with other NLTK-format CFG grammars for you to test with.\n• , containing the following:\n• Your source code required for to run.\n• :\n• Results of running your CNF conversion program on the grammar file.\n• :\n• Results of parsing the test sentences using the original grammar file.\n• :\n• Results of parsing the test sentences using your CNF-converted grammar file (hw2_grammar_cnf.cfg from above).\n• :\n• job definition that drives your parser, by calling the script.\n• Your CNF conversion program must run on using:\n• Please see the CLMS wiki pages for help on using condor.\n• All files created by the condor run should appear in the top level of the directory.\n• :\n• This file should describe and discuss your work on this assignment. Include problems you came across and how (or if) you were able to solve them, any insights, special features, and what you learned. Give examples if possible. If you were not able to complete parts of the project, discuss what you tried and/or what did not work. NOTE: Also, please review the parses generated by the original grammar and those from the CNF grammar. Provide a brief discussion of similarities and differences."
    },
    {
        "link": "https://nltk.org/_modules/nltk/treetransforms.html",
        "document": ""
    },
    {
        "link": "https://medium.com/@ivarrvinter/converting-context-free-grammar-to-chomsky-normal-form-step-by-step-guide-f4624a306eee",
        "document": "Mostly, when we want to check if a string is in a language of a certain grammar, we use Chomsky normal form (CNF) — that’s all!\n\nIf you’re new to the topic and don’t know what context-free grammar is, check out the previous post where we had a comprehensive tutorial on context-free grammar using the NLTK library.\n\nJust a quick overview, context-free grammar is a type of formal grammar that its productions are applied regardless of context.\n\nWe use Chomsky normal form in combination with the CYK (Cocke–Younger–Kasami) algorithm — just a parsing algorithm for context-free grammar.\n\nNow that we’ve got a practical panorama, let’s crush this!\n\nP.S. You’ll find a little surprise at the end of the post, so make sure you stay till the end.\n\nWhy Do We Use Normal Forms?\n\nOne may think if we reduce the grammar, the grammar gets standardised, but that’s totally incorrect! That way, the grammar gets minimized. That’s because the RHS (right-hand side) of productions don’t have any specific format. Hence, to standardise the grammar, we bring off normalisation through normal forms, one of which is Chomsky normal form.\n\nIn Chomsky normal form, we have a limitation on the RHS (right-hand side) length, i.e., RHS elements should be either two variables or one terminal. It’s a type of normal form that all of its productions corresponds to:\n\nwhere A, B, and C are variables or nonterminals, and a is a terminal.\n\nIn other words, context-free grammar is in Chomsky normal form if all productions comply with one of the following conditions:\n\nLet’s have the following as an example:\n\nAs you can see, G1 is in Chomsky normal form because productions adhere to CNF rules. In contrast, G2 isn’t in Chomsky normal form because the production rule S → aB consists of a terminal followed by a nonterminal.\n• We can have more than one Chomsky normal form for a given grammar\n• We use Chomsky normal form acting as a preprocessing step for many algorithms like CYK\n• Any context-free grammar that goes without ε has an analogous Chomsky normal form\n\nWhat Is the Application of Chomsky Normal Form?\n\nChomsky normal form is used to determine if a string can be generated from the given grammar in polynomial time.\n\nHow to Convert Context-free Grammar to Chomsky Normal Form?\n\nTo convert context-free grammar to Chomsky normal form, we follow the steps below:\n• Remove the start symbol from RHS (create a new production as S0 → S, which indicates the new start symbol, if the start symbol is at the RHS of any production)\n• Pull out terminals from RHS if they are the case with other terminals or nonterminals (e.g., the production rule A → aB breaks down as A → CB and C → a)\n• Take off RHS with more than two nonterminals (e.g., the production rule A → ABC collapses into A → DC and D → AB)\n\nLet’s see an example to get the hang of the conversion. Consider the given grammar:\n\nStep 1. Clearly, should create a new production rule as the start symbol appeared on the RHS. Now, we have:\n\nStep 2. As is evident from the third line, A → ε is a null production, so we should remove it:\n\nAgain, we should eliminate B → ε:\n\nThen, we bring out the created unit production B → A:\n\nThe removal of the unit production S0 → S from the grammar gives:\n\nLastly, we stamp out the S → S and S0 → S unit productions:\n\nStep 3. In the production rules A → aAS | aS and B → SbS | aAS | aS, a and b terminals are on the RHS with variables. Let’s remove them quickly:\n\nAs seen in the rules, we can’t have B → bb, so it falls down in another nonterminal, and we double it to have it back:\n\nStep 4. The RHS of S0 → ASB has more than two symbols, removing them represents the following:\n\nApparently, S → ASB has more than two symbols:\n\nWe apply the same tactic to A → XAS:\n\nOnce again with B → SYS:\n\nAnd for the last time, we collapse B → XAS into:\n\nThat’s it! That’s the proper Chomsky normal form for the given context-free grammar.\n\nWhen we use Chomsky normal form, three main strong points are coming to us:\n• Parsers can use binary trees, which add up to simplicity and reflect relationships between data\n• The exact length of derivations is patent\n• It helps to steer clear of ambiguity problems during parsing\n\nIn this post, we covered Chomsky normal form, why we need it, and how to implement it step by step, and then we talked about the advantages coming with CNF. Remember that although Chomsky normal form imposes limitations on the grammar rule, it moves on with the original grammar in a reciprocal manner.\n\nYou may also want to try context-free language to Chomsky normal form converter with solutions. That saves you time! :)"
    },
    {
        "link": "https://docs.python.org/3/tutorial/datastructures.html",
        "document": "This chapter describes some things you’ve learned about already in more detail, and adds some new things as well.\n\nThe list data type has some more methods. Here are all of the methods of list objects: Add an item to the end of the list. Similar to . Extend the list by appending all the items from the iterable. Similar to . Insert an item at a given position. The first argument is the index of the element before which to insert, so inserts at the front of the list, and is equivalent to . Remove the first item from the list whose value is equal to x. It raises a if there is no such item. Remove the item at the given position in the list, and return it. If no index is specified, removes and returns the last item in the list. It raises an if the list is empty or the index is outside the list range. Remove all items from the list. Similar to . Return zero-based index in the list of the first item whose value is equal to x. Raises a if there is no such item. The optional arguments start and end are interpreted as in the slice notation and are used to limit the search to a particular subsequence of the list. The returned index is computed relative to the beginning of the full sequence rather than the start argument. Return the number of times x appears in the list. Sort the items of the list in place (the arguments can be used for sort customization, see for their explanation). Reverse the elements of the list in place. Return a shallow copy of the list. Similar to . An example that uses most of the list methods: You might have noticed that methods like , or that only modify the list have no return value printed – they return the default . This is a design principle for all mutable data structures in Python. Another thing you might notice is that not all data can be sorted or compared. For instance, doesn’t sort because integers can’t be compared to strings and can’t be compared to other types. Also, there are some types that don’t have a defined ordering relation. For example, isn’t a valid comparison. The list methods make it very easy to use a list as a stack, where the last element added is the first element retrieved (“last-in, first-out”). To add an item to the top of the stack, use . To retrieve an item from the top of the stack, use without an explicit index. For example: It is also possible to use a list as a queue, where the first element added is the first element retrieved (“first-in, first-out”); however, lists are not efficient for this purpose. While appends and pops from the end of list are fast, doing inserts or pops from the beginning of a list is slow (because all of the other elements have to be shifted by one). To implement a queue, use which was designed to have fast appends and pops from both ends. For example: # The first to arrive now leaves # The second to arrive now leaves List comprehensions provide a concise way to create lists. Common applications are to make new lists where each element is the result of some operations applied to each member of another sequence or iterable, or to create a subsequence of those elements that satisfy a certain condition. For example, assume we want to create a list of squares, like: Note that this creates (or overwrites) a variable named that still exists after the loop completes. We can calculate the list of squares without any side effects using: which is more concise and readable. A list comprehension consists of brackets containing an expression followed by a clause, then zero or more or clauses. The result will be a new list resulting from evaluating the expression in the context of the and clauses which follow it. For example, this listcomp combines the elements of two lists if they are not equal: Note how the order of the and statements is the same in both these snippets. If the expression is a tuple (e.g. the in the previous example), it must be parenthesized. # create a new list with the values doubled # apply a function to all the elements # the tuple must be parenthesized, otherwise an error is raised File , line : did you forget parentheses around the comprehension target? # flatten a list using a listcomp with two 'for' List comprehensions can contain complex expressions and nested functions: The initial expression in a list comprehension can be any arbitrary expression, including another list comprehension. Consider the following example of a 3x4 matrix implemented as a list of 3 lists of length 4: The following list comprehension will transpose rows and columns: As we saw in the previous section, the inner list comprehension is evaluated in the context of the that follows it, so this example is equivalent to: which, in turn, is the same as: # the following 3 lines implement the nested listcomp In the real world, you should prefer built-in functions to complex flow statements. The function would do a great job for this use case: See Unpacking Argument Lists for details on the asterisk in this line.\n\nWe saw that lists and strings have many common properties, such as indexing and slicing operations. They are two examples of sequence data types (see Sequence Types — list, tuple, range). Since Python is an evolving language, other sequence data types may be added. There is also another standard sequence data type: the tuple. A tuple consists of a number of values separated by commas, for instance: File , line , in : # but they can contain mutable objects: As you see, on output tuples are always enclosed in parentheses, so that nested tuples are interpreted correctly; they may be input with or without surrounding parentheses, although often parentheses are necessary anyway (if the tuple is part of a larger expression). It is not possible to assign to the individual items of a tuple, however it is possible to create tuples which contain mutable objects, such as lists. Though tuples may seem similar to lists, they are often used in different situations and for different purposes. Tuples are immutable, and usually contain a heterogeneous sequence of elements that are accessed via unpacking (see later in this section) or indexing (or even by attribute in the case of ). Lists are mutable, and their elements are usually homogeneous and are accessed by iterating over the list. A special problem is the construction of tuples containing 0 or 1 items: the syntax has some extra quirks to accommodate these. Empty tuples are constructed by an empty pair of parentheses; a tuple with one item is constructed by following a value with a comma (it is not sufficient to enclose a single value in parentheses). Ugly, but effective. For example: The statement is an example of tuple packing: the values , and are packed together in a tuple. The reverse operation is also possible: This is called, appropriately enough, sequence unpacking and works for any sequence on the right-hand side. Sequence unpacking requires that there are as many variables on the left side of the equals sign as there are elements in the sequence. Note that multiple assignment is really just a combination of tuple packing and sequence unpacking.\n\nPython also includes a data type for sets. A set is an unordered collection with no duplicate elements. Basic uses include membership testing and eliminating duplicate entries. Set objects also support mathematical operations like union, intersection, difference, and symmetric difference. Curly braces or the function can be used to create sets. Note: to create an empty set you have to use , not ; the latter creates an empty dictionary, a data structure that we discuss in the next section. Here is a brief demonstration: # show that duplicates have been removed # Demonstrate set operations on unique letters from two words # letters in a but not in b # letters in a or b or both # letters in both a and b # letters in a or b but not both Similarly to list comprehensions, set comprehensions are also supported:\n\nAnother useful data type built into Python is the dictionary (see Mapping Types — dict). Dictionaries are sometimes found in other languages as “associative memories” or “associative arrays”. Unlike sequences, which are indexed by a range of numbers, dictionaries are indexed by keys, which can be any immutable type; strings and numbers can always be keys. Tuples can be used as keys if they contain only strings, numbers, or tuples; if a tuple contains any mutable object either directly or indirectly, it cannot be used as a key. You can’t use lists as keys, since lists can be modified in place using index assignments, slice assignments, or methods like and . It is best to think of a dictionary as a set of key: value pairs, with the requirement that the keys are unique (within one dictionary). A pair of braces creates an empty dictionary: . Placing a comma-separated list of key:value pairs within the braces adds initial key:value pairs to the dictionary; this is also the way dictionaries are written on output. The main operations on a dictionary are storing a value with some key and extracting the value given the key. It is also possible to delete a key:value pair with . If you store using a key that is already in use, the old value associated with that key is forgotten. It is an error to extract a value using a non-existent key. Performing on a dictionary returns a list of all the keys used in the dictionary, in insertion order (if you want it sorted, just use instead). To check whether a single key is in the dictionary, use the keyword. Here is a small example using a dictionary: The constructor builds dictionaries directly from sequences of key-value pairs: In addition, dict comprehensions can be used to create dictionaries from arbitrary key and value expressions: When the keys are simple strings, it is sometimes easier to specify pairs using keyword arguments:\n\nWhen looping through dictionaries, the key and corresponding value can be retrieved at the same time using the method. When looping through a sequence, the position index and corresponding value can be retrieved at the same time using the function. To loop over two or more sequences at the same time, the entries can be paired with the function. What is your name? It is lancelot. What is your quest? It is the holy grail. What is your favorite color? It is blue. To loop over a sequence in reverse, first specify the sequence in a forward direction and then call the function. To loop over a sequence in sorted order, use the function which returns a new sorted list while leaving the source unaltered. Using on a sequence eliminates duplicate elements. The use of in combination with over a sequence is an idiomatic way to loop over unique elements of the sequence in sorted order. It is sometimes tempting to change a list while you are looping over it; however, it is often simpler and safer to create a new list instead.\n\nThe conditions used in and statements can contain any operators, not just comparisons. The comparison operators and are membership tests that determine whether a value is in (or not in) a container. The operators and compare whether two objects are really the same object. All comparison operators have the same priority, which is lower than that of all numerical operators. Comparisons can be chained. For example, tests whether is less than and moreover equals . Comparisons may be combined using the Boolean operators and , and the outcome of a comparison (or of any other Boolean expression) may be negated with . These have lower priorities than comparison operators; between them, has the highest priority and the lowest, so that A and not B or C is equivalent to (A and (not B)) or C . As always, parentheses can be used to express the desired composition. The Boolean operators and are so-called short-circuit operators: their arguments are evaluated from left to right, and evaluation stops as soon as the outcome is determined. For example, if and are true but is false, A and B and C does not evaluate the expression . When used as a general value and not as a Boolean, the return value of a short-circuit operator is the last evaluated argument. It is possible to assign the result of a comparison or other Boolean expression to a variable. For example, Note that in Python, unlike C, assignment inside expressions must be done explicitly with the walrus operator . This avoids a common class of problems encountered in C programs: typing in an expression when was intended.\n\nSequence objects typically may be compared to other objects with the same sequence type. The comparison uses lexicographical ordering: first the first two items are compared, and if they differ this determines the outcome of the comparison; if they are equal, the next two items are compared, and so on, until either sequence is exhausted. If two items to be compared are themselves sequences of the same type, the lexicographical comparison is carried out recursively. If all items of two sequences compare equal, the sequences are considered equal. If one sequence is an initial sub-sequence of the other, the shorter sequence is the smaller (lesser) one. Lexicographical ordering for strings uses the Unicode code point number to order individual characters. Some examples of comparisons between sequences of the same type: Note that comparing objects of different types with or is legal provided that the objects have appropriate comparison methods. For example, mixed numeric types are compared according to their numeric value, so 0 equals 0.0, etc. Otherwise, rather than providing an arbitrary ordering, the interpreter will raise a exception."
    },
    {
        "link": "https://stackoverflow.com/questions/16753918/how-to-create-a-complex-type-dict-object",
        "document": "I am trying to create a dict reading the date from a file for further processing but unable to get the code to work. I am working in python and new to this language. My file data looks like this:\n\nNow, I want to create the dict object as:"
    },
    {
        "link": "https://labex.io/tutorials/python-how-to-handle-complex-dictionary-conversions-421896",
        "document": "In Python, dictionaries are powerful and versatile data structures that store key-value pairs. They provide an efficient way to map unique keys to specific values, enabling quick data retrieval and manipulation.\n\nBy mastering these fundamentals, you'll be well-equipped to handle complex dictionary operations in Python. LabEx recommends practicing these techniques to build strong programming skills."
    },
    {
        "link": "https://documentation.bloomreach.com/engagement/docs/datastructures",
        "document": "Sometimes, you want to store multiple values of the same type and meaning. For example, you have a bunch of items that you want to show to your customer in an email. Creating a variable for each one of the names would be too laborious.\n\nTherefore, Jinja contains more complex data structures to serve various cases like this. These data structures are in essence just a collection of variables stored together under one reference name. But, they also provide you with some useful added functionality. There are three of them available and this article will help you understand the key differences between them.\n\nThe simplest data structure available in Jinja is a list. Lists in Jinja are dynamic data structures, which means that you do not need to know the number of variables that your list will represent. Your list will automatically make itself larger if you need to store more items than it currently allows. Also, you do not need to worry about the data type of your list. Not only can lists store any type of data, but you can also store multiple data types in one list.\n\nYou initialize a list using the notation, as with ordinary variables. However, to tell the renderer that you are initializing a list, you need to use the square-brackets notation for lists. In between the square brackets, you can specify the values that your list will contain from the get-go. The values need to be separated by a comma. Initialising an empty list is possible too, just put the square brackets with nothing inside of them. Initializing a list of numbers from 1 to 5 is done through the following command .\n\nLists are also indexed, meaning that every item that is stored in a list, has a special number called an index through which you can access the item. The index of an item indicates the position the item has in the list, beginning from 0. For instance, consider the following list . The letter a is the first element in myList, hence, it will have index 0. The letter k is the fifth element, hence it will have index 4. Once you add an element to a list, it will not change its index, unless you remove the elements preceding it.\n\nYou can use indexing for easy access to the elements from your list using square brackets notation. If you want to retrieve some element from the list and you know its index, you can simply use and you will get the value of the first item of myList list.\n\nBecause lists are dynamic data structures, you can add and remove elements from lists in your jinja template code.\n\nYou can add an element to a list using the append method. Because we wanted to avoid using the underlying python Language, the notation in Bloomreach Engagement somewhat differs from the one officially supported in Jinja. Instead of you will need to use . Nevertheless, the functionality does not change. Your item will still be added to the end of the list.\n\nAnother data structure available in Jinja is a tuple. In simple terms, similarly to lists, tuples are also a bunch of values that are referred to by a common name and they are not data-type specific. However, unlike lists, tuples are immutable, which means that once you define a tuple, you can only access its values but cannot change them. In simple words, tuples are \"read-only\".\n\nYou define a tuple by using round brackets. For instance, will be a tuple containing two values, \"dog\" and \"cat\". As with lists, tuples are also indexed beginning from 0.\n\n Hence, if you want to output the second value \"cat\" from myPair, I will use .\n\nTuples are usually used to store two or more values. But, if you want to create a singleton, a tuple with only one value, you need to put a comma after your value, as in the following example .\n\nThe last data structure available in our implementation of Jinja is a dictionary. As with lists, they are used to store multiple values of arbitrary data types. The main difference comes in the way you can retrieve the values from dictionaries. Dictionaries are not indexed. Instead, they store your values as a key-value pair. To retrieve the value from your dictionary, you simply use the key that you stored the value with.\n\nTo define a dictionary, you need to use curly brackets: . Later, you can access your values by simply invoking which will return the value . You don't need to set your keys to be of type String as in the example, you can also use integers, floats, or even the value none.\n\nData structures can be treated as data types themselves. This allows you to not only data structures containing variables of the primitive data types covered in the basics, but also combine them together. In fact, one such combination was already used in the example for tuples. This yields you a lot of power while working in Bloomreach Engagement. For instance, each row of your catalog can be treated as a dictionary, with the names of columns serving as keys. Then, if you want to work with your catalog data in Jinja, you can create a list of dictionaries or even a dictionary of dictionaries with the keys being the ids of the rows and the values being the rows themselves.\n\nAll of the data structures with the addition of strings are iterable in Jinja2. This means that for each of the data types you can iterate through their content. Strings are iterated through the characters they contain, Pairs and lists through the values they contain and finally, dictionaries are iterated through their keys.\n\nThe primary key for accessing items of Iterables (Strings, Lists, Tuples, Dictionaries) must be a constant. Therefore, when accessing their content dynamically, Jinja throws an error. To get around this, wrap your data structure in another List, Tuple or Dictionary. Firstly, wrap your data structure in the square-brackets. Then, access your item from the wrapped data structure using [myDataStructure][0][myVariable]."
    },
    {
        "link": "https://stackoverflow.com/questions/2544055/python-what-are-efficient-techniques-to-deal-with-deeply-nested-data-in-a-flexi",
        "document": "My question is not about a specific code snippet but more general, so please bear with me:\n\nHow should I organize the data I'm analyzing, and which tools should I use to manage it?\n\nI'm using python and numpy to analyse data. Because the python documentation indicates that dictionaries are very optimized in python, and also due to the fact that the data itself is very structured, I stored it in a deeply nested dictionary.\n\nHere is a skeleton of the dictionary: the position in the hierarchy defines the nature of the element, and each new line defines the contents of a key in the precedent level:\n\nEdit: To explain a bit better my data set:\n\nThe type of operations I perform is for instance to compute properties of the arrays (listed under Ch1, Ch2), pick up arrays to make a new collection, for instance analyze responses of N01 from region 16 (R16) of a given individual at different time points, etc.\n\nThis structure works well for me and is very fast, as promised. I can analyze the full data set pretty quickly (and the dictionary is far too small to fill up my computer's ram : half a gig).\n\nMy problem comes from the cumbersome manner in which I need to program the operations of the dictionary. I often have stretches of code that go like this:\n\nwhich is ugly, cumbersome, non reusable, and brittle (need to recode it for any variant of the dictionary).\n\nI tried using recursive functions, but apart from the simplest applications, I ran into some very nasty bugs and bizarre behaviors that caused a big waste of time (it does not help that I don't manage to debug with pdb in ipython when I'm dealing with deeply nested recursive functions). In the end the only recursive function I use regularly is the following:\n\nI know I'm doing this wrong, because my code is long, noodly and non-reusable. I need to either use better techniques to flexibly manipulate the dictionaries, or to put the data in some database format (sqlite?). My problem is that since I'm (badly) self-taught in regards to programming, I lack practical experience and background knowledge to appreciate the options available. I'm ready to learn new tools (SQL, object oriented programming), whatever it takes to get the job done, but I am reluctant to invest my time and efforts into something that will be a dead end for my needs.\n\nSo what are your suggestions to tackle this issue, and be able to code my tools in a more brief, flexible and re-usable manner?\n\nAddendum: apart of doing something with a particular sub-dictionary of the data dictionary, here are some examples of operations I implemented for the dataset dic, or a sub dictionary of it:\n\nactually I have some recursive functions that worked well:\n\nfor some operations I found no other way than to flatten the dictionary:"
    }
]