[
    {
        "link": "https://lunarmodules.github.io/luasocket",
        "document": "LuaSocket is a Lua extension library that is composed by two parts: a C core that provides support for the TCP and UDP transport layers, and a set of Lua modules that add support for functionality commonly needed by applications that deal with the Internet.\n\nThe core support has been implemented so that it is both efficient and simple to use. It is available to any Lua application once it has been properly initialized by the interpreter in use. The code has been tested and runs well on several Windows and UNIX platforms.\n\nAmong the support modules, the most commonly used implement the SMTP (sending e-mails), HTTP (WWW access) and FTP (uploading and downloading files) client protocols. These provide a very natural and generic interface to the functionality defined by each protocol. In addition, you will find that the MIME (common encodings), URL (anything you could possible want to do with one) and LTN12 (filters, sinks, sources and pumps) modules can be very handy.\n\nThe library is available under the same terms and conditions as the Lua language, the MIT license. The idea is that if you can use Lua in a project, you should also be able to use LuaSocket.\n\nLuaSocket version 3.1.0 is now available for download! It is compatible with Lua 5.1 through 5.4. Chances are it works well on most UNIX distributions and Windows flavors.\n\nThe current version of the library can be found at the LuaSocket project page on GitHub. Besides the full C and Lua source code for the library, the distribution contains several examples, this user's manual and basic test procedures.\n\nTake a look at the installation section of the manual to find out how to properly install the library.\n\nThis marks the first release of LuaSocket that wholeheartedly embraces the open-source development philosophy. After a long hiatus, Matthew Wild finally convinced me it was time for a release including IPv6 and Lua 5.2 support. It was more work than we anticipated. Special thanks to Sam Roberts, Florian Zeitz, and Paul Aurich, Liam Devine, Alexey Melnichuk, and everybody else that has helped bring this library back to life."
    },
    {
        "link": "https://w3.impa.br/~diego/software/luasocket/introduction.html",
        "document": "LuaSocket is a Lua extension library that is composed by two parts: a C core that provides support for the TCP and UDP transport layers, and a set of Lua modules that add support for the SMTP (sending e-mails), HTTP (WWW access) and FTP (uploading and downloading files) protocols and other functionality commonly needed by applications that deal with the Internet. This introduction is about the C core.\n\nCommunication in LuaSocket is performed via I/O objects. These can represent different network domains. Currently, support is provided for TCP and UDP, but nothing prevents other developers from implementing SSL, Local Domain, Pipes, File Descriptors etc. I/O objects provide a standard interface to I/O across different domains and operating systems.\n\nThe API design had two goals in mind. First, users experienced with the C API to sockets should feel comfortable using LuaSocket. Second, the simplicity and the feel of the Lua language should be preserved. To achieve these goals, the LuaSocket API keeps the function names and semantics the C API whenever possible, but their usage in Lua has been greatly simplified.\n\nOne of the simplifications is the receive pattern capability. Applications can read data from stream domains (such as TCP) line by line, block by block, or until the connection is closed. All I/O reads are buffered and the performance differences between different receive patterns are negligible.\n\nAnother advantage is the flexible timeout control mechanism. As in C, all I/O operations are blocking by default. For example, the , and methods of the TCP domain will block the caller application until the operation is completed (if ever!). However, with a call to the method, an application can specify upper limits on the time it can be blocked by LuaSocket (the \" \" timeout), on the time LuaSocket can internally be blocked by any OS call (the \" \" timeout) or a combination of the two. Each LuaSocket call might perform several OS calls, so that the two timeout values are not equivalent.\n\nFinally, the host name resolution is transparent, meaning that most functions and methods accept both IP addresses and host names. In case a host name is given, the library queries the system's resolver and tries the main IP address returned. Note that direct use of IP addresses is more efficient, of course. The and functions from the DNS module are provided to convert between host names and IP addresses.\n\nTogether, these changes make network programming in LuaSocket much simpler than it is in C, as the following sections will show.\n\nTCP (Transfer Control Protocol) is reliable stream protocol. In other words, applications communicating through TCP can send and receive data as an error free stream of bytes. Data is split in one end and reassembled transparently on the other end. There are no boundaries in the data transfers. The library allows users to read data from the sockets in several different granularities: patterns are available for lines, arbitrary sized blocks or \"read up to connection closed\", all with good performance.\n\nThe library distinguishes three types of TCP sockets: master, client and server sockets.\n\nMaster sockets are newly created TCP sockets returned by the function . A master socket is transformed into a server socket after it is associated with a local address by a call to the method followed by a call to the . Conversely, a master socket can be changed into a client socket with the method , which associates it with a remote address.\n\nOn server sockets, applications can use the method to wait for a client connection. Once a connection is established, a client socket object is returned representing this connection. The other methods available for server socket objects are , , , and .\n\nClient sockets are used to exchange data between two applications over the Internet. Applications can call the methods and to send and receive data. The other methods available for client socket objects are , , , , , and .\n\nA simple echo server, using LuaSocket. The program binds to an ephemeral port (one that is chosen by the operating system) on the local host and awaits client connections on that port. When a connection is established, the program reads a line from the remote end and sends it back, closing the connection immediately. You can test it using the telnet program. -- load namespace local socket = require(\"socket\") -- create a TCP socket and bind it to the local host, at any port local server = assert(socket.bind(\"*\", 0)) -- find out which port the OS chose for us local ip, port = server:getsockname() -- print a message informing what's up print(\"Please telnet to localhost on port \" .. port) print(\"After connecting, you have 10s to enter a line to be echoed\") -- loop forever waiting for clients while 1 do -- wait for a connection from any client local client = server:accept() -- make sure we don't block waiting for this client's line client:settimeout(10) -- receive the line local line, err = client:receive() -- if there was no error, send it back to the client if not err then client:send(line .. \"\n\n\") end -- done with client, close the object client:close() end\n\nUDP (User Datagram Protocol) is a non-reliable datagram protocol. In other words, applications communicating through UDP send and receive data as independent blocks, which are not guaranteed to reach the other end. Even when they do reach the other end, they are not guaranteed to be error free. Data transfers are atomic, one datagram at a time. Reading only part of a datagram discards the rest, so that the following read operation will act on the next datagram. The advantages are in simplicity (no connection setup) and performance (no error checking or error correction).\n\nNote that although no guarantees are made, these days networks are so good that, under normal circumstances, few errors happen in practice.\n\nAn UDP socket object is created by the function. UDP sockets do not need to be connected before use. The method can be used immediately after creation to send a datagram to IP address and port. Host names are not allowed because performing name resolution for each packet would be forbiddingly slow. Methods and can be used to retrieve datagrams, the latter returning the IP and port of the sender as extra return values (thus being slightly less efficient).\n\nWhen communication is performed repeatedly with a single peer, an application should call the method to specify a permanent partner. Methods and can no longer be used, but the method can be used to send data directly to the peer, and the method will only return datagrams originating from that peer. There is about 30% performance gain due to this practice.\n\nTo associate an UDP socket with a local address, an application calls the method before sending any datagrams. Otherwise, the socket is automatically bound to an ephemeral address before the first data transmission and once bound the local address cannot be changed. The other methods available for UDP sockets are , , , and .\n\nAlthough not covered in the introduction, LuaSocket offers much more than TCP and UDP functionality. As the library evolved, support for HTTP, FTP, and SMTP were built on top of these. These modules and many others are covered by the reference manual."
    },
    {
        "link": "https://stackoverflow.com/questions/42783263/lua-tcp-ip-simple-client-server-connection",
        "document": "Here is a working client/server example, which is based on luasocket documentation and SO answers. If you have issues with getting it to work, you need to provide specific details about those issues."
    },
    {
        "link": "https://realtimelogic.com/ba/doc?url=SockLib.html",
        "document": "This page uses frames, but your browser doesn't support them."
    },
    {
        "link": "https://github.com/SierraWireless/lua-execution-environments/blob/master/luasocket/2.0/socket.lua",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/56300831/persistent-socket-connection-in-lua-python",
        "document": "I'm trying to create a persistent socket connection between a Lua client and Python server. Effectively a script that'll constantly ping the server with keepalive messages\n\nMy current issue is that the socket closes after each connection without a means to reopen it for transmission.\n\nThe expected result is a keepalive ping every second to ensure the client is still connected to the server."
    },
    {
        "link": "https://stackoverflow.com/questions/26164976/lua-socket-example-trying-different-sites",
        "document": "I am using this example. It prints the text based on this site http://www.google.com/robots.txt\n\nBut, as above, I try with this link, http://www.lua.org/pil/9.4.html and it doesn't work, saying \"HTTP/1.0 302 Moved temporarily\". Did same on many other sites, got similar results. Why is that so? Thanks a lot"
    },
    {
        "link": "https://wiki.luatos.org/api/socket.html?highlight=socket",
        "document": "-- This API was added on 2023.11.15 -- Note that this function is not valid until socket.sntp() is executed and the NTP time is obtained. -- And it is the more accurate value after 2 sntp -- The smaller the network fluctuation, the more stable the timestamp. -- The corresponding table contains multiple data, all of which are integer values. -- Debugging data, debugging, general users do not have to tube -- ssec The second offset of the system start time and 1900.1.1 0:0:0 -- sms The millisecond offset of the system startup time from 1900.1.1 0:0:0\n\nSend data to the opposite end, UDP should not send more than 1460 bytes at a time, otherwise it is easy to fail. or int The opposite IP is ignored if it is TCP application, and if it is UDP, the parameter at connect time is used if it is left blank. if it is IPV4, it can be int value in big-end format. The opposite-end slogan and small-end format are ignored if it is TCP application, and if it is UDP, the parameters at connect time are used if it is left blank. Send parameter, currently reserved, does not work true No exception occurred, false failed, if false, you don’t need to see the next return value, if false, follow-up close true The buffer is full, false is not full, if true, you need to wait for a period of time or wait for the socket.TX_ OK message before trying to send, while ignoring the next return value true A reply has been received, false has not received a reply, and then you need to receive the socket.TX_ OK message, or you can ignore and continue sending full==true\n\nReceive the data sent by the opposite end, note that the data has been cached at the bottom layer, use this function only to extract, UDP mode will only take out one data packet at a time zbuff Store the received data, and automatically expand the capacity if the buffer is not enough. Receiving parameter, currently reserved, does not work Receive data length limit, if specified, only the first N bytes are taken. 2024.1.5 New true No exception occurred, false failed, if false, you don’t need to see the next return value, if false, follow-up close The peer IP is meaningful only in UDP mode. TCP mode returns nil. Pay attention to the format of the return. If it is IPV4,1byte 0x 00 4byte address, if it is IPV6,1byte 0x 01 16byte address The port on the opposite end, which is meaningful only in UDP mode and returned in TCP mode.0 -- Read data from the socket, ctrl is returned by socket.create, please refer demo/socket -- If it is UDP data, if the limit is less than the length of the UDP packet, only the first limit bytes will be taken and the remaining data will be discarded. -- If it is TCP data, if there is any remaining data, it will not be discarded and can continue to be read.. -- New EVENT data is generated only when new data arrives. Data that has not been read will not trigger a new EVENT event. -- Read buffer size, added in 2024.1.5. Note that the old version of firmware will report an error if it does not pass buff parameters. -- For TCP data, the total length of the data to be read is returned here. -- For UDP data, the length of a single UDP packet is returned here \"Length of data to be charged\""
    },
    {
        "link": "https://realtimelogic.com/ba/doc?url=SockLib.html",
        "document": "This page uses frames, but your browser doesn't support them."
    },
    {
        "link": "https://reddit.com/r/lua/comments/1ifq4lo/connecting_to_unix_socket_with_luaposix",
        "document": "Hi all, I'm trying to figure out how to connect to a UNIX socket with luaposix. I've been looking through their API documentation and they have an example on how to connect to web sockets, but not this. It might be similar but I'm severely lacking on socket programming.\n\nThe reason I'm doing this is the Astal framework supports Lua, but it also has no native libraries for Sway as far as I know. So to get my workspaces and query other info about Sway, obviously I'd need to connect to the IPC.\n\nif not sock then\n\nif not result then\n\nif not result then\n\nI don't have this in a code block because everytime I tried, reddit would mash it together onto one line."
    }
]