[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.firstordefault?view=net-9.0",
        "document": "( ) if is empty; otherwise, the first element in .\n\nThe following code example demonstrates how to use FirstOrDefault<TSource>(IEnumerable<TSource>) on an empty array.\n\nSometimes the value of is not the default value that you want to use if the collection contains no elements. Instead of checking the result for the unwanted default value and then changing it if necessary, you can use the DefaultIfEmpty<TSource>(IEnumerable<TSource>, TSource) method to specify the default value that you want to use if the collection is empty. Then, call First<TSource>(IEnumerable<TSource>) to obtain the first element. The following code example uses both techniques to obtain a default value of 1 if a collection of numeric months is empty. Because the default value for an integer is 0, which does not correspond to any month, the default value must be specified as 1 instead. The first result variable is checked for the unwanted default value after the query has finished executing. The second result variable is obtained by using DefaultIfEmpty<TSource>(IEnumerable<TSource>, TSource) to specify a default value of 1.\n\nThe default value for reference and nullable types is .\n\nThe FirstOrDefault method does not provide a way to specify a default value. If you want to specify a default value other than , use the DefaultIfEmpty<TSource>(IEnumerable<TSource>, TSource) method as described in the Example section."
    },
    {
        "link": "https://stackoverflow.com/questions/1024559/when-to-use-first-and-when-to-use-firstordefault-with-linq",
        "document": "And for that matter, what about Take?\n\nAnd when would you want to use .FirstOrDefault ? When you'd always want the default type if no result?\n\nWhen would you want to use .First ? Only when you'd want to catch the exception if no results where returned?\n\nI've searched around and haven't really found a clear answer as to when you'd want to use .First and when you'd want to use .FirstOrDefault with LINQ.\n\nI would use when I know or expect the sequence to have at least one element. In other words, when it is an exceptional occurrence that the sequence is empty. Use when you know that you will need to check whether there was an element or not. In other words, when it is legal for the sequence to be empty. You should not rely on exception handling for the check. (It is bad practice and might hurt performance). Finally, the difference between and is that returns the element itself, while returns a sequence of elements that contains exactly one element.\n\nwill throw an exception when there are no results. won't, it will simply return either null (reference types) or the default value of the value type. (e.g like for an int.) The question here is not when you want the default type, but more: Are you willing to handle an exception or handle a default value? Since exceptions should be exceptional, is preferred when you're not sure if you're going to get results out of your query. When logically the data should be there, exception handling can be considered. and are normally used when setting up paging in results. (Like showing the first 10 results, and the next 10 on the next page, etc.)\n\nwill throw an exception if there's no row to be returned, while will return the default value ( for all reference types) instead. So if you're prepared and willing to handle a possible exception, is fine. If you prefer to check the return value for anyway, then is your better choice. But I guess it's a bit of a personal preference, too. Use whichever makes more sense to you and fits your coding style better.\n• It throw an error when There is no element in the result or source is null.\n• you should use it,If more than one element is expected and you want only first element.\n• Returns first element of a sequence, or a default value if no element is found.\n• It throws an error Only if the source is null.\n• you should use it, If more than one element is expected and you want only first element. Also good if result is empty. We have an UserInfos table, which have some records as shown below. On the basis of this table below I have created example... There is only one record where ID== 1. Should return this record\n\n ID: 1 First Name: Manish Last Name: Dubey Email: [email protected] There are multiple records where FName == \"Rahul\". First record should be return.\n\n ID: 7 First Name: Rahul Last Name: Sharma Email: [email protected] There is no record with ID== 13. An error should be occur.\n\n InvalidOperationException: Sequence contains no elements How to Use FirstOrDefault() There is only one record where ID== 1. Should return this record\n\n ID: 1 First Name: Manish Last Name: Dubey Email: [email protected] There are multiple records where FName == \"Rahul\". First record should be return.\n\n ID: 7 First Name: Rahul Last Name: Sharma Email: [email protected] There is no record with ID== 13. The return value is null Hope it will help you to understand when to use or .\n\nOthers have very well described the difference between and . I want to take a further step in interpreting the semantics of these methods. In my opinion is being overused a lot. In the majority of the cases when you’re filtering data you would either expect to get back a collection of elements matching the logical condition or a single unique element by its unique identifier – such as a user, book, post etc... That’s why we can even get as far as saying that is a code smell not because there is something wrong with it but because it’s being used way too often. This blog post explores the topic in details. IMO most of the times is a much better alternative so watch out for this mistake and make sure you use the most appropriate method that clearly represents your contract and expectations."
    },
    {
        "link": "https://dev.to/dianaiminza/linq-first-and-firstordefault-methods-in-c-o4c",
        "document": "In C#, First() and FirstOrDefault() are two commonly used LINQ extension methods that allow you to query collections, such as arrays, lists, and other IEnumerable types, to retrieve the first element that matches a specified condition. While these methods might seem similar at first glance, they differ in terms of behavior, especially when the collection is empty or when no element matches the condition.\n\nWhat is First()?\n\n First() is a LINQ method that returns the first element in a collection that satisfies a given condition. If the collection is empty or no element matches the condition, First() throws an exception of type InvalidOperationException.\n\nWhat is FirstOrDefault()?\n\n FirstOrDefault() is very similar to First(), but with one key difference: it returns a default value when no element matches the condition or if the collection is empty. The default value depends on the type of the element in the collection. For reference types (like classes), the default value is null, and for value types (like integers), it’s the default value for that type (e.g., 0 for int).\n\nWhen to Use First() and FirstOrDefault()?\n• Use First() when you are sure that the collection will not be empty and that at least one element will satisfy the condition. This method is useful when the absence of elements matching the condition is considered an error in your application.\n\nExample: If you're querying a database and expecting exactly one result, you may use First() to fetch that record.\n• Use FirstOrDefault() when the absence of a matching element is valid and you want to avoid exceptions. This is often used in scenarios where the collection might be empty, or no elements meet the condition, and you want to handle these cases gracefully.\n\nExample: When fetching a user by ID or username, you might use FirstOrDefault() because it’s possible the user might not exist, and you can handle the null result in your code.\n\nScenario: Searching for an Employee by ID\n\n Imagine we have a list of employees, and we want to search for an employee by their ID. The employee list might be empty, or there may not be any employee with the given ID. We will explore how First() and FirstOrDefault() behave in such a case.\n\nEmployee Class:\n\n public class Employee\n\n {\n\n public int Id { get; set; }\n\n public string Name { get; set; }\n\n }\n\n\n\nList of Employees:\n\n List<Employee> employees = new List<Employee>\n\n {\n\n new Employee { Id = 1, Name = \"John Doe\" },\n\n new Employee { Id = 2, Name = \"Jane Smith\" },\n\n new Employee { Id = 3, Name = \"Mike Johnson\" }\n\n };\n\n \n\n Example 1: Using First()\n\n Let’s say we want to find an employee with ID 4. Since there is no employee with that ID in the list, using First() will throw an exception.\n\n \n\n In this case, since no employee has an ID of 4, First() throws an InvalidOperationException, indicating that no element matches the condition.\n\nExample 2: Using FirstOrDefault()\n\n Now let’s see how FirstOrDefault() behaves when trying to find an employee with ID 4.\n\n\n\nIn this example, FirstOrDefault() returns null because no employee with ID 4 exists in the list. Instead of throwing an exception, we can handle the case gracefully by checking if employee is null and displaying a message to the user.\n\nExample 3: Empty List Scenario\n\n Let’s consider a situation where the employee list is empty:\n\n\n\nNow, let’s use FirstOrDefault() with the same empty list:\n• None First() will throw an exception if the collection is empty or if no element satisfies the condition. This is useful when you want to ensure that the element must exist.\n• None FirstOrDefault() will return the default value (null for reference types) if no element matches or if the collection is empty. This allows for safer handling when the absence of a matching element is expected or valid.\n\nBy using FirstOrDefault() in scenarios where the absence of an element is acceptable, you can avoid potential crashes in your application due to unhandled exceptions.\n\nBy understanding these differences, you can write more predictable and error-resistant code, especially when working with dynamic or uncertain data sources."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.linq.queryable.firstordefault?view=net-9.0",
        "document": "( ) if is empty; otherwise, the first element in .\n\nThe following code example demonstrates how to use FirstOrDefault<TSource>(IQueryable<TSource>) on an empty sequence.\n\nSometimes the value of is not the default value that you want to use if the collection contains no elements. Instead of checking the result for the unwanted default value and then changing it if necessary, you can use the DefaultIfEmpty<TSource>(IQueryable<TSource>, TSource) method to specify the default value that you want to use if the collection is empty. Then, call First<TSource>(IQueryable<TSource>) to obtain the first element. The following code example uses both techniques to obtain a default value of 1 if a collection of numeric months is empty. Because the default value for an integer is 0, which does not correspond to any month, the default value must be specified as 1 instead. The first result variable is checked for the unwanted default value after the query is completed. The second result variable is obtained by calling DefaultIfEmpty<TSource>(IQueryable<TSource>, TSource) to specify a default value of 1.\n\nThe FirstOrDefault<TSource>(IQueryable<TSource>) method generates a MethodCallExpression that represents calling FirstOrDefault<TSource>(IQueryable<TSource>) itself as a constructed generic method. It then passes the MethodCallExpression to the Execute<TResult>(Expression) method of the IQueryProvider represented by the Provider property of the parameter.\n\nThe query behavior that occurs as a result of executing an expression tree that represents calling FirstOrDefault<TSource>(IQueryable<TSource>) depends on the implementation of the type of the parameter. The expected behavior is that it returns the first element in , or a default value if is empty.\n\nThe FirstOrDefault method does not provide a way to specify the default value to return if is empty. If you want to specify a default value other than , use the DefaultIfEmpty<TSource>(IQueryable<TSource>, TSource) method as described in the Example section."
    },
    {
        "link": "https://tutorialspoint.com/chash-linq-firstordefault-method",
        "document": "Use the FirstorDefault() method to return the first element of a sequence or a default value if element isn’t there.\n\nThe following is our empty list −\n\nNow, we cannot display the first element, since it is an empty collection. For that, use the FirstorDefault() method to display the default value.\n\nThe following is the complete example."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.singleordefault?view=net-9.0",
        "document": "The single element of the input sequence, or ( ) if the sequence contains no elements.\n\nThe following code example demonstrates how to use SingleOrDefault<TSource>(IEnumerable<TSource>) to select the only element of an array.\n\nThe following code example demonstrates that SingleOrDefault<TSource>(IEnumerable<TSource>) returns a default value when the sequence is empty.\n\nSometimes the value of is not the default value that you want to use if the collection contains no elements. Instead of checking the result for the unwanted default value and then changing it if necessary, you can use the DefaultIfEmpty<TSource>(IEnumerable<TSource>, TSource) method to specify the default value that you want to use if the collection is empty. Then, call Single<TSource>(IEnumerable<TSource>) to obtain the element. The following code example uses both techniques to obtain a default value of 1 if a collection of page numbers is empty. Because the default value for an integer is 0, which is not usually a valid page number, the default value must be specified as 1 instead. The first result variable is checked for the unwanted default value after the query has finished executing. The second result variable is obtained by using DefaultIfEmpty<TSource>(IEnumerable<TSource>, TSource) to specify a default value of 1.\n\nThe default value for reference and nullable types is .\n\nThe SingleOrDefault method does not provide a way to specify a default value. If you want to specify a default value other than , use the DefaultIfEmpty<TSource>(IEnumerable<TSource>, TSource) method as described in the Example section."
    },
    {
        "link": "https://stackoverflow.com/questions/23674792/singleordefault-exception-handling",
        "document": "I have a samle code which calls SingleOrDefault method 3 times and logs exception if any sequence has more than one matching element.\n\nThe problem starts if I want to check which part of this code throws exception.\n\nIs it possible to get some useful information from this exception like predicate parameter or collection type for more detailed trace?\n\nlike this - Sequence contains more than one matching element. Collection IEnumrable|ParamType| param {Predicate param toString()}"
    },
    {
        "link": "https://reddit.com/r/csharp/comments/1e2ttqc/linq_when_to_use_single_vs_singleordefault",
        "document": "When you're in release, the error \"Sequence contains no elements\" do not help. So i should use a custom exception to gather more information.\n\nBut my great question is when should i use this...\n\nOr is it single() meant to only be used in a case when you only would catch an exception in the caller?"
    },
    {
        "link": "https://stackoverflow.com/questions/39366586/practical-usage-of-single-singleordefault-methods",
        "document": "and should be used when you expect one and only one, or one or none (respectively).\n\nYou could do it the way you suggest with by checking counts explicitly (which is the traditional method for such things), but sometimes the code can be more concise and/or easier to follow when you let LINQ throw the exception for you:\n\nSome (myself included) might prefer to have that peripheral validation code (which is essentially what the above represents) out of the way of the main logic block. Note that this does not loose sight of the main logic requirement, as plainly tells us that we expect one and only one item, so there's no loss of knowledge by moving the count validation to an exception handler.\n\nI do wish that it threw a more specific exception than though... that's pretty generic."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.linq.queryable.singleordefault?view=net-9.0",
        "document": "The single element of the input sequence, or ( ) if the sequence contains no elements.\n\nThe following code example demonstrates how to use SingleOrDefault<TSource>(IQueryable<TSource>) to select the only element of an array. The second query demonstrates that SingleOrDefault<TSource>(IQueryable<TSource>) returns a default value when the sequence does not contain exactly one element.\n\nSometimes the value of is not the default value that you want to use if the collection contains no elements. Instead of checking the result for the unwanted default value and then changing it if necessary, you can use the DefaultIfEmpty<TSource>(IQueryable<TSource>, TSource) method to specify the default value that you want to use if the collection is empty. Then, call Single<TSource>(IQueryable<TSource>) to obtain the element. The following code example uses both techniques to obtain a default value of 1 if a collection of page numbers is empty. Because the default value for an integer is 0, which is not usually a valid page number, the default value must be specified as 1 instead. The first result variable is checked for the unwanted default value after the query is completed. The second result variable is obtained by calling DefaultIfEmpty<TSource>(IQueryable<TSource>, TSource) to specify a default value of 1.\n\nThe SingleOrDefault<TSource>(IQueryable<TSource>) method generates a MethodCallExpression that represents calling SingleOrDefault<TSource>(IQueryable<TSource>) itself as a constructed generic method. It then passes the MethodCallExpression to the Execute<TResult>(Expression) method of the IQueryProvider represented by the Provider property of the parameter.\n\nThe query behavior that occurs as a result of executing an expression tree that represents calling SingleOrDefault<TSource>(IQueryable<TSource>) depends on the implementation of the type of the parameter. The expected behavior is that it returns the only element in , or a default value if is empty.\n\nThe SingleOrDefault method does not provide a way to specify a default value. If you want to specify a default value other than , use the DefaultIfEmpty<TSource>(IQueryable<TSource>, TSource) method as described in the Example section."
    }
]