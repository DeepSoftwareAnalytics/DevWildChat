[
    {
        "link": "https://stackoverflow.com/questions/58522253/is-it-possible-to-pass-class-as-a-parameter-in-a-function-in-flutter",
        "document": "Here, I have a utility class in which I have a function for showing DialogBox, so I'm trying to make an AlertDialog Box which can be used anywhere in the whole project.\n\nSo, I have to pass Title, description as an argument and also want to pass Class name so that when the button inside the alert dialog is pressed we can navigate to that screen\n\nRight now I have just kept closing the dialog box but there I want to navigate to another class."
    },
    {
        "link": "https://dart.dev/language/functions",
        "document": "Dart is a true object-oriented language, so even functions are objects and have a type, Function. This means that functions can be assigned to variables or passed as arguments to other functions. You can also call an instance of a Dart class as if it were a function. For details, see Callable objects.\n\nHere's an example of implementing a function:\n\nAlthough Effective Dart recommends type annotations for public APIs, the function still works if you omit the types:\n\nFor functions that contain just one expression, you can use a shorthand syntax:\n\nThe syntax is a shorthand for . The notation is sometimes referred to as arrow syntax.\n\nA function can have any number of required positional parameters. These can be followed either by named parameters or by optional positional parameters (but not both).\n\nYou can use trailing commas when you pass arguments to a function or when you define function parameters.\n\nNamed parameters are optional unless they're explicitly marked as .\n\nWhen defining a function, use to specify named parameters. If you don't provide a default value or mark a named parameter as , their types must be nullable as their default value will be :\n\nWhen calling a function, you can specify named arguments using . For example:\n\nTo define a default value for a named parameter besides , use to specify a default value. The specified value must be a compile-time constant. For example:\n\nIf you instead want a named parameter to be mandatory, requiring callers to provide a value for the parameter, annotate them with :\n\nIf someone tries to create a without specifying the argument, then the analyzer reports an issue.\n\nYou might want to place positional arguments first, but Dart doesn't require it. Dart allows named arguments to be placed anywhere in the argument list when it suits your API:\n\nWrapping a set of function parameters in marks them as optional positional parameters. If you don't provide a default value, their types must be nullable as their default value will be :\n\nHere's an example of calling this function without the optional parameter:\n\nAnd here's an example of calling this function with the third parameter:\n\nTo define a default value for an optional positional parameter besides , use to specify a default value. The specified value must be a compile-time constant. For example:\n\nEvery app must have a top-level function, which serves as the entrypoint to the app. The function returns and has an optional parameter for arguments.\n\nHere's an example of the function for a command-line app that takes arguments:\n\nYou can use the args library to define and parse command-line arguments.\n\nYou can pass a function as a parameter to another function. For example:\n\nYou can also assign a function to a variable, such as:\n\nThis example uses an anonymous function. More about those in the next section.\n\nYou can specify the type of a function, which is known as a function type. A function type is obtained from a function declaration header by replacing the function name by the keyword . Moreover, you are allowed to omit the names of positional parameters, but the names of named parameters can't be omitted. For example:\n\nThough you name most functions, such as or . you can also create functions without names. These functions are called anonymous functions, lambdas, or closures.\n\nAn anonymous function resembles a named function as it has:\nâ€¢ Zero or more parameters, comma-separated\n\nThe following code block contains the function's body:\n\nThe following example defines an anonymous function with an untyped parameter, . The anonymous function passes it to the function. The function, invoked for each item in the list, converts each string to uppercase. Then, the anonymous function passed to , prints each converted string with its length.\n\nIf the function contains only a single expression or return statement, you can shorten it using arrow notation. Paste the following line into DartPad and click Run to verify that it is functionally equivalent.\n\nDart determines the scope of variables based on the layout of its code. A programming language with this feature is termed a lexically scoped language. You can \"follow the curly braces outwards\" to see if a variable is in scope.\n\nExample: A series of nested functions with variables at each scope level:\n\nThe method can use variables from every level, all the way up to the top level.\n\nA function object that can access variables in its lexical scope when the function sits outside that scope is called a closure.\n\nFunctions can close over variables defined in surrounding scopes. In the following example, captures the variable . Wherever the returned function goes, it remembers .\n\nWhen you refer to a function, method, or named constructor without parentheses, Dart creates a tear-off. This is a closure that takes the same parameters as the function and invokes the underlying function when you call it. If your code needs a closure that invokes a named function with the same parameters as the closure accepts, don't wrap the call in a lambda. Use a tear-off.\n\nHere's an example of testing top-level functions, static methods, and instance methods for equality:\n\nAll functions return a value. If no return value is specified, the statement is implicitly appended to the function body.\n\nTo return multiple values in a function, aggregate the values in a record.\n\nWhen you need to lazily produce a sequence of values, consider using a generator function. Dart has built-in support for two kinds of generator functions:\n\nTo implement a synchronous generator function, mark the function body as , and use statements to deliver values:\n\nTo implement an asynchronous generator function, mark the function body as , and use statements to deliver values:\n\nIf your generator is recursive, you can improve its performance by using :\n\nAn external function is a function whose body is implemented separately from its declaration. Include the keyword before a function declaration, like so:\n\nAn external function's implementation can come from another Dart library, or, more commonly, from another language. In interop contexts, introduces type information for foreign functions or values, making them usable in Dart. Implementation and usage is heavily platform specific, so check out the interop docs on, for example, C or JavaScript to learn more.\n\nExternal functions can be top-level functions, instance methods, getters or setters, or non-redirecting constructors. An instance variable can be too, which is equivalent to an external getter and (if the variable is not ) an external setter.\n\nUnless stated otherwise, the documentation on this site reflects Dart 3.7.1. Page last updated on 2025-02-12. View source or report an issue."
    },
    {
        "link": "https://stackoverflow.com/questions/57310810/pass-different-class-object-to-function",
        "document": "I have multiple class objects and i want to create a standalone function that will take any class object as parameter.\n\nhere is my income class\n\nhere is my expense class object\n\ni want to create function that takes any class object\n\nbasically, i want to be able to call insertTransaction and pass any class object and then pass that object to the dao class. when i called dao.toMap(object)); in insertTransaction function. i get error message such as \"The argument type 'T' can't be assigned to the parameter type 'Income'.\"\n\nI guess flutter is not able to determine if object parameter is Income or expense etc. i tried using casting such as (Income)object but didnt work.\n\ncan someone help me on this? im trying to reuse my function (insertTransaction) instead of creating the same function for every object class such as income, expenses, events, etc..."
    },
    {
        "link": "https://api.flutter.dev/flutter/dart-core/Function-class.html",
        "document": "The class is a supertype of all function types, and contains no values itself. All objects that implement have a function type as their runtime type.\n\nThe type does not carry information about the parameter signatures or return type of a function. To express a more precise function type, use the function type syntax, which is the keyword followed by a parameter list, or a type argument list and a parameter list, and which can also have an optional return type.\n\nThe function type syntax mirrors the definition of a function, with the function name replaced by the word \"Function\".\n\nThe type is the type of a function that takes one positional argument and returns a .\n\nA function type can be used anywhere a type is allowed, and is often used for functions taking other functions, \"callbacks\", as arguments.\n\nA function type has all the members declared by Object, since function types are subtypes of Object.\n\nA function type also has a method with a signature that has the same function type as the function type itself. Calling the method behaves just as calling the function. This is mainly used to conditionally call a nullable function value.\n\nThe Function type has a number of special features which are not visible in this declaration.\n\nThe type itself allows any function to be assigned to it, since it is a supertype of any function type, but does not say how the function can be called.\n\nHowever, a value with the static type can still be called like a function.\n\nSuch an invocation is a dynamic invocation, precisely as if the function value had been statically typed as , and is precisely as unsafe as any other dynamic invocation. Checks will be performed at run-time to ensure that the argument list matches the function's parameters, and if not the call will fail with an Error. There is no static type checking for such a call, any argument list is accepted and checked at runtime.\n\nLike every function type has a method with its own function type, the type has a special member which acts as if it is a method with a function type of (which is not a method signature which can be expressed in normal Dart code)."
    },
    {
        "link": "https://docs.flutter.dev/cookbook/navigation/navigate-with-arguments",
        "document": "The provides the ability to navigate to a named route from any part of an app using a common identifier. In some cases, you might also need to pass arguments to a named route. For example, you might wish to navigate to the route and pass information about the user to that route.\n\nYou can accomplish this task using the parameter of the method. Extract the arguments using the method or inside an function provided to the or constructor.\n\nThis recipe demonstrates how to pass arguments to a named route and read the arguments using and using the following steps:\nâ€¢ Define the arguments you need to pass.\nâ€¢ Register the widget in the table.\n\nFirst, define the arguments you need to pass to the new route. In this example, pass two pieces of data: The of the screen and a .\n\nTo pass both pieces of data, create a class that stores this information.\n\nNext, create a widget that extracts and displays the and from the . To access the , use the method. This method returns the current route with the arguments.\n\nNext, add an entry to the provided to the widget. The define which widget should be created based on the name of the route.\n\nFinally, navigate to the when a user taps a button using . Provide the arguments to the route via the property. The extracts the and from these arguments.\n\nInstead of extracting the arguments directly inside the widget, you can also extract the arguments inside an function and pass them to a widget.\n\nThe function creates the correct route based on the given .\n\n// Use this function to identify the named // route being pushed, and create the correct // If you push the PassArguments route // Cast the arguments to the correct // Then, extract the required data from // the arguments and pass the data to the // Other values need to be implemented if we // add them. The assertion here will help remind // us of that higher up in the call stack, since // this assertion would otherwise fire somewhere"
    },
    {
        "link": "https://dart.dev/language/classes",
        "document": "Dart is an object-oriented language with classes and mixin-based inheritance. Every object is an instance of a class, and all classes except descend from . Mixin-based inheritance means that although every class (except for the top class, ) has exactly one superclass, a class body can be reused in multiple class hierarchies. Extension methods are a way to add functionality to a class without changing the class or creating a subclass. Class modifiers allow you to control how libraries can subtype a class.\n\nObjects have members consisting of functions and data (methods and instance variables, respectively). When you call a method, you invoke it on an object: the method has access to that object's functions and data.\n\nUse a dot ( ) to refer to an instance variable or method:\n\nUse instead of to avoid an exception when the leftmost operand is null:\n\nYou can create an object using a constructor. Constructor names can be either or . For example, the following code creates objects using the and constructors:\n\nThe following code has the same effect, but uses the optional keyword before the constructor name:\n\nSome classes provide constant constructors. To create a compile-time constant using a constant constructor, put the keyword before the constructor name:\n\nWithin a constant context, you can omit the before a constructor or literal. For example, look at this code, which creates a const map:\n\nYou can omit all but the first use of the keyword:\n\nIf a constant constructor is outside of a constant context and is invoked without , it creates a non-constant object:\n\nTo get an object's type at runtime, you can use the property , which returns a object.\n\nUp to here, you've seen how to use classes. The rest of this section shows how to implement classes.\n\nAn uninitialized instance variable declared with a nullable type has the value . Non-nullable instance variables must be initialized at declaration.\n\nAll instance variables generate an implicit getter method. Non-final instance variables and instance variables without initializers also generate an implicit setter method. For details, check out Getters and setters.\n\nInitializing a non- instance variable where it's declared sets the value when the instance is created, before the constructor and its initializer list execute. As a result, the initializing expression (after the ) of a non- instance variable can't access .\n\nInstance variables can be , in which case they must be set exactly once. Initialize , non- instance variables at declaration, using a constructor parameter, or using a constructor's initializer list:\n\nIf you need to assign the value of a instance variable after the constructor body starts, you can use one of the following:\nâ€¢ Use , but be careful: a without an initializer adds a setter to the API.\n\nEvery class implicitly defines an interface containing all the instance members of the class and of any interfaces it implements. If you want to create a class A that supports class B's API without inheriting B's implementation, class A should implement the B interface.\n\nA class implements one or more interfaces by declaring them in an clause and then providing the APIs required by the interfaces. For example:\n\nHere's an example of specifying that a class implements multiple interfaces:\n\nUse the keyword to implement class-wide variables and methods.\n\nStatic variables (class variables) are useful for class-wide state and constants:\n\nStatic methods (class methods) don't operate on an instance, and thus don't have access to . They do, however, have access to static variables. As the following example shows, you invoke static methods directly on a class:\n\nYou can use static methods as compile-time constants. For example, you can pass a static method as a parameter to a constant constructor.\n\nUnless stated otherwise, the documentation on this site reflects Dart 3.7.1. Page last updated on 2025-02-12. View source or report an issue."
    },
    {
        "link": "https://dart.dev/language/type-system",
        "document": "The Dart language is type safe: it uses a combination of static type checking and runtime checks to ensure that a variable's value always matches the variable's static type, sometimes referred to as sound typing. Although types are mandatory, type annotations are optional because of type inference.\n\nOne benefit of static type checking is the ability to find bugs at compile time using Dart's static analyzer.\n\nYou can fix most static analysis errors by adding type annotations to generic classes. The most common generic classes are the collection types and .\n\nFor example, in the following code the function prints an integer list, and creates a list and passes it to .\n\nThe preceding code results in a type error on (highlighted above) at the call of :\n\nThe error highlights an unsound implicit cast from to . The variable has static type . This is because the initializing declaration doesn't provide the analyzer with enough information for it to infer a type argument more specific than . The function expects a parameter of type , causing a mismatch of types.\n\nWhen adding a type annotation ( ) on creation of the list (highlighted below) the analyzer complains that a string argument can't be assigned to an parameter. Removing the quotes in results in code that passes static analysis and runs with no errors or warnings.\n\nTry it in DartPad.\n\nSoundness is about ensuring your program can't get into certain invalid states. A sound type system means you can never get into a state where an expression evaluates to a value that doesn't match the expression's static type. For example, if an expression's static type is , at runtime you are guaranteed to only get a string when you evaluate it.\n\nDart's type system, like the type systems in Java and C#, is sound. It enforces that soundness using a combination of static checking (compile-time errors) and runtime checks. For example, assigning a to is a compile-time error. Casting an object to a using fails with a runtime error if the object isn't a .\nâ€¢ None Revealing type-related bugs at compile time.\n\nA sound type system forces code to be unambiguous about its types, so type-related bugs that might be tricky to find at runtime are revealed at compile time.\nâ€¢ None More readable code.\n\nCode is easier to read because you can rely on a value actually having the specified type. In sound Dart, types can't lie.\nâ€¢ None More maintainable code.\n\nWith a sound type system, when you change one piece of code, the type system can warn you about the other pieces of code that just broke.\nâ€¢ None Better ahead of time (AOT) compilation.\n\nWhile AOT compilation is possible without types, the generated code is much less efficient.\n\nMost of the rules for static types are easy to understand. Here are some of the less obvious rules:\n\nLet's see these rules in detail, with examples that use the following type hierarchy:\n\nThe return type of a method in a subclass must be the same type or a subtype of the return type of the method in the superclass. Consider the getter method in the class:\n\nThe getter method returns an . In the subclass, you can replace the getter's return type with (or any other subtype of ), but an unrelated type is not allowed.\n\nThe parameter of an overridden method must have either the same type or a supertype of the corresponding parameter in the superclass. Don't \"tighten\" the parameter type by replacing the type with a subtype of the original parameter.\n\nConsider the method for the class:\n\nThe method takes an . A chases anything. It's OK to override the method to take anything ( ).\n\nThe following code tightens the parameter on the method from to , a subclass of .\n\nThis code is not type safe because it would then be possible to define a cat and send it after an alligator:\n\nA list is good when you want to have a list with different kinds of things in it. However, you can't use a list as a typed list.\n\nThis rule also applies to instances of generic types.\n\nThe following code creates a list of , and assigns it to a list of type , which generates an error during static analysis.\n\nRuntime checks deal with type safety issues that can't be detected at compile time.\n\nFor example, the following code throws an exception at runtime because it's an error to cast a list of dogs to a list of cats:\n\nExpressions with a static type of can be implicitly cast to a more specific type. If the actual type doesn't match, the cast throws an error at run time. Consider the following method:\n\nIn this example, if is a , the cast succeeds. If it's not a subtype of , such as , a is thrown:\n\nThe analyzer can infer types for fields, methods, local variables, and most generic type arguments. When the analyzer doesn't have enough information to infer a specific type, it uses the type.\n\nHere's an example of how type inference works with generics. In this example, a variable named holds a map that pairs string keys with values of various types.\n\nIf you explicitly type the variable, you might write this:\n\nAlternatively, you can use or and let Dart infer the type:\n\nThe map literal infers its type from its entries, and then the variable infers its type from the map literal's type. In this map, the keys are both strings, but the values have different types ( and , which have the upper bound ). So the map literal has the type , and so does the variable.\n\nA field or method that has no specified type and that overrides a field or method from the superclass, inherits the type of the superclass method or field.\n\nA field that does not have a declared or inherited type but that is declared with an initial value, gets an inferred type based on the initial value.\n\nStatic fields and variables get their types inferred from their initializer. Note that inference fails if it encounters a cycle (that is, inferring a type for the variable depends on knowing the type of that variable).\n\nLocal variable types are inferred from their initializer, if any. Subsequent assignments are not taken into account. This may mean that too precise a type may be inferred. If so, you can add a type annotation.\n\nType arguments to constructor calls and generic method invocations are inferred based on a combination of downward information from the context of occurrence, and upward information from the arguments to the constructor or generic method. If inference is not doing what you want or expect, you can always explicitly specify the type arguments.\n\nIn the last example, is inferred as using downward information. The return type of the closure is inferred as using upward information. Dart uses this return type as upward information when inferring the method's type argument: .\n\nWith the inference using bounds feature, Dart's type inference algorithm generates constraints by combining existing constraints with the declared type bounds, not just best-effort approximations.\n\nThis is especially important for F-bounded types, where inference using bounds correctly infers that, in the example below, can be bound to . Without the feature, the type argument must be specified explicitly: :\n\nHere's a more realistic example using everyday types in Dart like or :\n\nWith inference using bounds, Dart can deconstruct type arguments, extracting type information from a generic type parameter's bound. This allows functions like in the following example to preserve both the specific iterable type ( or ) and the element type. Before inference using bounds, this wasn't possible without losing type safety or specific type information.\n\nWithout inference using bounds, would have the type . The previous inference algorithm wouldn't catch the incorrect expression at compile time, and would instead throw at run time. Conversely, would be a compile-time error without inference using bounds, because the previous algorithm couldn't preserve the information that is a .\n\nFor more information on the inference using bounds algorithm, read the design document.\n\nWhen you override a method, you are replacing something of one type (in the old method) with something that might have a new type (in the new method). Similarly, when you pass an argument to a function, you are replacing something that has one type (a parameter with a declared type) with something that has another type (the actual argument). When can you replace something that has one type with something that has a subtype or a supertype?\n\nWhen substituting types, it helps to think in terms of consumers and producers. A consumer absorbs a type and a producer generates a type.\n\nYou can replace a consumer's type with a supertype and a producer's type with a subtype.\n\nLet's look at examples of simple type assignment and assignment with generic types.\n\nWhen assigning objects to objects, when can you replace a type with a different type? The answer depends on whether the object is a consumer or a producer.\n\nConsider the following type hierarchy:\n\nConsider the following simple assignment where is a consumer and is a producer:\n\nIn a consuming position, it's safe to replace something that consumes a specific type ( ) with something that consumes anything ( ), so replacing with is allowed, because is a supertype of .\n\nBut replacing with breaks type safety, because the superclass may provide a type of Cat with different behaviors, such as :\n\nIn a producing position, it's safe to replace something that produces a type ( ) with a more specific type ( ). So, the following is allowed:\n\nAre the rules the same for generic types? Yes. Consider the hierarchy of lists of animalsâ€”a of is a subtype of a of , and a supertype of a of :\n\nIn the following example, you can assign a list to because is a subtype of :\n\nWhat about going in the other direction? Can you assign an list to a ?\n\nThis assignment doesn't pass static analysis because it creates an implicit downcast, which is disallowed from non- types such as .\n\nTo make this type of code pass static analysis, you can use an explicit cast.\n\nAn explicit cast might still fail at runtime, though, depending on the actual type of the list being cast ( ).\n\nWhen overriding a method, the producer and consumer rules still apply. For example:\n\nFor a consumer (such as the method), you can replace the parameter type with a supertype. For a producer (such as the getter method), you can replace the return type with a subtype.\n\nFor more information, see Use sound return types when overriding methods and Use sound parameter types when overriding methods.\n\nSome (rarely used) coding patterns rely on tightening a type by overriding a parameter's type with a subtype, which is invalid. In this case, you can use the keyword to tell the analyzer that you're doing this intentionally. This removes the static error and instead checks for an invalid argument type at runtime.\n\nThe following shows how you might use :\n\nAlthough this example shows using in the subtype, the keyword can be placed in either the superclass or the subclass method. Usually the superclass method is the best place to put it. The keyword applies to a single parameter and is also supported on setters and fields.\n\nThe following resources have further information on sound Dart:\nâ€¢ Fixing type promotion failures - Understand and learn how to fix type promotion errors.\nâ€¢ Customizing static analysis - How to set up and customize the analyzer and linter using an analysis options file.\n\nUnless stated otherwise, the documentation on this site reflects Dart 3.7.1. Page last updated on 2025-03-12. View source or report an issue."
    },
    {
        "link": "https://stackoverflow.com/questions/64001805/how-pass-variable-from-a-class-to-another-class-in-flutter",
        "document": "If you need only this variable \" If it widget \" just use the name of class and then then the name of static variable\n\nIf this a another screen and you want to pass the data to this screen you can do it like this"
    },
    {
        "link": "https://api.flutter.dev/flutter/dart-core/Type-class.html",
        "document": "Type objects represent types. A type object can be created in several ways:\nâ€¢ By a type literal, a type name occurring as an expression, like , or a type variable occurring as an expression, like .\nâ€¢ By reading the run-time type of an object, like .\n\nA type object is intended as an entry point for using . The only operations supported are comparing to other type objects for equality, and converting it to a string for debugging."
    },
    {
        "link": "https://stackoverflow.com/questions/62291533/flutter-dart-class-instance-and-class-variable",
        "document": "I am new to dart and am having issues storing data in a class. I know how to create instances but I then want to store each instance into a map that I can easily access. Here is my code below...\n\nEvery time I call \"addInfoToMap\", the \"myMapOfCars\" instance is reinitialized and empty again. I wanted to add/append into the map so I can have as many cars in there as I want. I am open to other solutions as well, I come from Swift and I know you can do it in Swift. It just makes everything really clean.\n\nThanks for your help!!"
    }
]