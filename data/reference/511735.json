[
    {
        "link": "https://stackoverflow.com/questions/321143/good-programming-practices-for-macro-definitions-define-in-c",
        "document": "For example, never define a macro like this:\n\nThis can potentially be dangerous when we do an operation like this:\n\nInstead, define like this because you don't know how the user of the macro may use it:\n\nThe example is trivial, but that pretty much explains my question. Are there any set of guidelines or best practices that you would recommend when writing a macro?\n\nThanks for your time!"
    },
    {
        "link": "https://stackoverflow.com/questions/31261207/how-memory-is-allocated-to-macros-in-c",
        "document": "are . They are just a common name for some value. In your case, corresponds to value .\n\nMacro is not stored anywhere in the memory. When we compile the program in C or C++, it is done in many stages. First, the syntax is checked. If syntax is correct, it is checked for semantic errors. If it passes then, the program file is converted into . During this conversion, the preprocessors are processed i.e. the header files are included, any external linked file is included and all the macro are replaced with their corresponding values (in your case, at any place the program finds , it will replace that with value ).\n\nAfter this phase, all the code has already been converted to nearly machine level code.\n\nI hope you got your answer."
    },
    {
        "link": "https://spsanderson.com/steveondata/posts/2024-10-09",
        "document": "Programming, C programming, include directive, define directive, Header files in C, Symbolic constants in C, Macros in C, Improving C program organization with include, Boosting C program efficiency with define, Best practices for using include and define in C, Debugging include and define issues in C programming"
    },
    {
        "link": "https://skillsoft.com/course/the-c-preprocessor-optimization-f4175e78-1bcc-11e7-b15b-0242c0a80b07",
        "document": ""
    },
    {
        "link": "https://programiz.com/c-programming/c-preprocessor-macros",
        "document": "The C preprocessor is a macro preprocessor (allows you to define macros) that transforms your program before it is compiled. These transformations can be the inclusion of header files, macro expansions, etc.\n\nAll preprocessing directives begin with a symbol. For example,\n\nSome of the common uses of C preprocessors are:\n\nThe preprocessor is used to include header files to C programs. For example,\n\nHere, is a header file. The preprocessor directive replaces the above line with the contents of header file.\n\nThat's the reason why you need to use before you can use functions like and .\n\nYou can also create your own header file containing function declaration and include it in your program using this preprocessor directive.\n\nVisit this page to learn more about using header files.\n\nA macro is a fragment of code that is given a name. You can define a macro in C using the preprocessor directive.\n\nHere, when we use in our program, it is replaced with .\n\nYou can also define macros that work in a similar way as a function call. This is known as function-like macros. For example,\n\nEvery time the program encounters , it is replaced by .\n\nSuppose, we passed 5 as an argument then, it expands as below:\n\nVisit this page to learn more about macros and #define preprocessor.\n\nIn C programming, you can instruct the preprocessor whether to include a block of code or not. To do so, conditional directives can be used.\n\nIt's similar to a statement with one major difference.\n\nThe statement is tested during the execution time to check whether a block of code should be executed or not whereas, the conditionals are used to include (or skip) a block of code in your program before execution.\n• use different code depending on the machine, operating system\n• compile the same source file in two different programs\n• to exclude certain code from the program but to keep it as a reference for future purposes\n\nHow to use conditional?\n\nTo use conditional, , , , and directives are used.\n\nHere, the conditional codes are included in the program only if is defined.\n\n#if, #elif and #else Directive\n\nHere, is an expression of integer type (can be integers, characters, arithmetic expression, macros, and so on).\n\nThe conditional codes are included in the program only if the is evaluated to a non-zero value.\n\nThe optional directive can be used with directive.\n\nYou can also add nested conditional to your using\n\nThe special operator is used to test whether a certain macro is defined or not. It's often used with directive.\n\nHere are some predefined macros in C programming.\n\nExample 3: Get current time using __TIME__\n\nThe following program outputs the current time using macro."
    },
    {
        "link": "https://en.cppreference.com/w/c/memory/malloc",
        "document": "If allocation succeeds, returns a pointer that is suitably aligned for any object type with fundamental alignment.\n\nIf is zero, the behavior of is implementation-defined. For example, a null pointer may be returned. Alternatively, a non-null pointer may be returned; but such a pointer should not be dereferenced, and should be passed to free to avoid memory leaks.\n\nis thread-safe: it behaves as though only accessing the memory locations visible through its argument, and not any static storage. A previous call to free, free_sized, and free_aligned_sized(since C23) or realloc that deallocates a region of memory synchronizes-with a call to that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by . There is a single total order of all allocation and deallocation functions operating on each particular region of memory.\n\nOn success, returns the pointer to the beginning of newly allocated memory. To avoid a memory leak, the returned pointer must be deallocated with free() or realloc()."
    },
    {
        "link": "https://stackoverflow.com/questions/8477110/which-c-standard-library-functions-use-malloc-under-the-hood",
        "document": "Usually, the only routines in the C99 standard that might use are the standard I/O functions (in where the file structure and the buffer used by it is often allocated as if by . Some of the locale handling may use dynamic memory. All the other routines have no need for dynamic memory allocation in general.\n\nNow, is any of that formally documented? No, I don't think it is. There is no blanket restriction 'the functions in the library shall not use '. (There are, however, restrictions on other functions - such as and and ; they may not be used by the implementation, and the implementation may not use any of the other functions that may return a pointer to a static memory location.) However, one of the reasons why the extremely useful function is not in the standard C library is (reportedly) because it does memory allocation. It also isn't completely clear whether this was a factor in the routines such as and in TR 24731-2 not making it into C1x, but it could have been a factor."
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/malloc?view=msvc-170",
        "document": "returns a void pointer to the allocated space, or if there's insufficient memory available. To return a pointer to a type other than , use a type cast on the return value. The storage space pointed to by the return value is suitably aligned for storage of any type of object that has an alignment requirement less than or equal to that of the fundamental alignment. (In Visual C++, the fundamental alignment is the alignment that's required for a , or 8 bytes. In code that targets 64-bit platforms, it's 16 bytes.) Use to allocate storage for objects that have a larger alignment requirement—for example, the SSE types and , and types that are declared by using where is greater than 8. If is 0, allocates a zero-length item in the heap and returns a valid pointer to that item. Always check the return from , even if the amount of memory requested is small.\n\nThe function allocates a memory block of at least bytes. The block may be larger than bytes because of the space that's required for alignment and maintenance information.\n\nsets to if a memory allocation fails or if the amount of memory requested exceeds . For information about this and other error codes, see , , , and .\n\nThe startup code uses to allocate storage for the , , and variables. The following functions and their wide-character counterparts also call .\n\nThe C++ function sets the new handler mode for . The new handler mode indicates whether, on failure, is to call the new handler routine as set by . By default, doesn't call the new handler routine on failure to allocate memory. You can override this default behavior so that, when fails to allocate memory, calls the new handler routine in the same way that the operator does when it fails for the same reason. To override the default, call early in your program, or link with (see Link options).\n\nWhen the application is linked with a debug version of the C run-time libraries, resolves to . For more information about how the heap is managed during the debugging process, see CRT debug heap details.\n\nis marked and . These attributes mean that the function is guaranteed not to modify global variables, and that the pointer returned isn't aliased. For more information, see and .\n\nBy default, this function's global state is scoped to the application. To change this behavior, see Global state in the CRT.\n\nFor more compatibility information, see Compatibility.\n\nAll versions of the C run-time libraries."
    },
    {
        "link": "https://man7.org/linux/man-pages/man3/free.3.html",
        "document": "Pages that refer to this page: memusage(1), brk(2), clone(2), getrlimit(2), io_uring_register(2), mlock(2), mmap(2), mremap(2), alloca(3), argz_add(3), asprintf(3), ausearch_add_expression(3), avc_init(3), backtrace(3), basename(3), canonicalize_file_name(3), cfree(3), CPU_SET(3), dbopen(3), end(3), exec(3), fopen(3), fseek(3), fts(3), ftw(3), getcwd(3), getgrent(3), getgrnam(3), getifaddrs(3), getline(3), getpwent(3), getpwnam(3), glob(3), hsearch(3), if_nameindex(3), lber-memory(3), ldap_memory(3), mallinfo(3), malloc_get_state(3), malloc_hook(3), malloc_info(3), malloc_stats(3), malloc_trim(3), malloc_usable_size(3), mallopt(3), mcheck(3), mpool(3), mtrace(3), numa(3), open_memstream(3), pam_conv(3), pmaddderived(3), __pmaf(3), pmagetlog(3), pmapi(3), pmarewritedata(3), pmarewritemeta(3), pmdachildren(3), pmdafetch(3), pmdainstance(3), pmdalabel(3), pmdatext(3), pmdatrace(3), pmdiscoverservices(3), pmextractvalue(3), pmfault(3), pmfetch(3), pmfetcharchive(3), pmfetchgroup(3), pmfreelabelsets(3), pmfreeprofile(3), pmfreeresult(3), pmfstring(3), pmgetchildren(3), pmgetchildrenstatus(3), pmgetindom(3), pmgetindomarchive(3), pmhash(3), pmlookupindomtext(3), pmlookuptext(3), pmnameall(3), pmnameid(3), pmnameindom(3), pmnameindomarchive(3), pmnewcontextzone(3), pmnewzone(3), pmnomem(3), __pmparsectime(3), pmparsehostattrsspec(3), pmparsehostspec(3), pmparseinterval(3), pmparsemetricspec(3), __pmparsetime(3), pmparsetimewindow(3), pmparseunitsstr(3), pmregisterderived(3), posix_memalign(3), pthread_setcancelstate(3), random_r(3), readdir(3), readline(3), realpath(3), scandir(3), sd_bus_creds_get_pid(3), sd_bus_error(3), sd_bus_path_encode(3), sd_get_seats(3), sd_journal_get_catalog(3), sd_journal_get_cursor(3), sd-json(3), sd-login(3), sd_machine_get_class(3), sd_path_lookup(3), sd_pid_get_owner_uid(3), sd_seat_get_active(3), sd_session_is_active(3), sd_uid_get_state(3), seccomp_syscall_resolve_name(3), security_class_to_string(3), selabel_get_digests_all_partial_matches(3), selinux_boolean_sub(3), selinux_getpolicytype(3), selinux_raw_context_to_color(3), setbuf(3), sscanf(3), strdup(3), string(3), tempnam(3), tracefs_event_get_file(3), tracefs_instance_set_affinity(3), tracefs_tracers(3), void(3type), wcsdup(3), proc_meminfo(5), environ(7), feature_test_macros(7), signal-safety(7), string_copying(7)"
    },
    {
        "link": "https://gnu.org/s/libc/manual/pdf/libc.pdf",
        "document": ""
    }
]