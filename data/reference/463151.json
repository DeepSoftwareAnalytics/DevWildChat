[
    {
        "link": "https://forums.unrealengine.com/t/best-practices-for-tracking-memory-allocations-in-ios/439518",
        "document": "So far, we’ve been mostly tracking allocations using memreport for assets, and xcode’s allocations instrument for pretty much everything else.\n\nHowever, we’ve found that this approach has some serious blind spots, there are some allocations that for whatever reason, the allocations instrument doesn’t seem to see (despite the debugging session reporting an increase in memory usage), and memreport only returns information about types that have implemented GetResourceSizeEx. This leaves a large amount of our program invisible.\n\nAre there other tools that we could investigate that would allow us to get a better sense of allocations in systems that aren’t tied to assets (and that don’t generate so much noise that getting usable info is relatively manageable)? Or is there an engine level way to assign memory pools to different systems in our code so that we can control the amount of memory that gets allocated where, and have an easy way to detect when something unexpected has occurred (ie/ we crash because that pool runs out of memory?)"
    },
    {
        "link": "https://forums.unrealengine.com/t/how-to-profile-games-on-ios-device/11924",
        "document": "Right now what’s the best method to profile games on iOS device? I can only use some console commands right now, which is not enough. For example, the “stat unit” does not show the “GPU” like PC, and the “Frame” is really high but the “Game” and “Draw” is not high, so I still don’t get the bottleneck. Furthermore, it seems the profiler in session frontend cannot connect to the device. Maybe I do something wrong, can I use the profiler to profile the game on iOS device remotely right now? Also, is there a way to transfer the profile file to PC recorded by “stat startfile” command from iOS device?\n\nAs far as I am aware the best way to profile an IOS device is to use Xcode’s profiling tools on Mac OS X. The current release version of Unreal Engine 4 (4.4.3) does not seem to work all that fantastically well between Windows and IOS devices, so your best bet is using Xcode! Let me know if you need any more help\n\nAs far as I am aware the best way to profile an IOS device is to use Xcode’s profiling tools on Mac OS X. The current release version of Unreal Engine 4 (4.4.3) does not seem to work all that fantastically well between Windows and IOS devices, so your best bet is using Xcode! Let me know if you need any more help Thank you! I didn’t use Xcode’s profiling tools before. I find there are many tools in Instruments of Xcode, so could you give some advice that what tools are better for profiling UE4 project?\n\npianpian, unfortunately for tiled based GPUs (all mobile chips but nVidia’s Tegra K1), we can’t get timing information per draw call, only the total frame time (it’s a limitation of the way the GPU works). Sounds like you are gpu bound, since the Frame time is a max of GPU, (CPU) Game and (CPU) Render. Take a look in here for some tips for optimization: Performance Guidelines for Mobile Devices | Unreal Engine Documentation\n\nCan I use “ProfileGPU” console command now? I tried it on iOS device, after I set RHI.ShowProfilerAfterProfilingGPU=0. The output says: xxxx/Engine/Source/Runtime/ShaderCore/Public/Shader.h(926): Assertion failed: ShaderRef != NULL && *ShaderRef != NULL That won’t work for Mobile (as I mentioned, we can’t get timing information per draw call). You can only do “stat unit” to see if you are CPU bound (and get total frame time); the Xcode frame stats will also show you how’s gpu perf."
    },
    {
        "link": "https://medium.com/@kazmiekr/what-every-ios-developer-should-be-doing-with-instruments-d1661eeaf64f",
        "document": "What every iOS Developer should be doing with Instruments\n\nYou’ve just wrapped up development on a shiny new iOS project and have done your best to ensure that the app doesn’t crash and it seems to run ok on your test devices, but is it ready to submit? If you haven’t done any profiling in Instruments, the answer is probably no. Just because it doesn’t crash doesn’t mean that it’s going to behave and run well on your user’s devices.\n\nXcode includes a performance tuning application named Instruments that you can use to profile your application using all sorts of different metrics. They have tools to inspect CPU usage, memory usage, leaks, file/network activity, and energy usage just to name a few. It’s really easy to start profiling your app from Xcode, but it’s sometimes not as easy to understand what you see when it’s profiling, which deters some developers from being able to use this tool to it’s fullest potential.\n\nWith so many things you can profile, how do you choose what to look at? Obviously if there are any immediate performance issues that you know about, like slow network requests or laggy scrolling, you should target those first. But if things seem to be going ok, I’d suggest that you at least look at your CPU and memory usage during a few runs of the application to ensure that everything is behaving as you might think.\n\nBefore going into this information I did want to note that I don’t expect every developer to be actively profiling their app all the time. Most of us have deadlines and expectations to meet, so profiling your application sometimes get shoved to the side, but let’s talk about some points where you should be profiling.\n\nAt a bare minimum, you should be doing this activity before you submit it to the app store. You don’t want your app to get past review and get into the hands of the users and have bad things happen while they are using your app. You’ll end up with lots of poor reviews, which will seriously hurt your downloads.\n\nI’d suggest that after you finish up some major new features you should do some quick profiles to make sure everything is in order. The longer you wait, the more potential issues you might find and they might pile up into a larger work item to resolve that might delay your launch. As a team you could define some of these check in’s as part of your dev plan so there is time allocated.\n\nThe other time I’d suggest that you fire up Instruments is when you are working with some different pieces of the frameworks you are not as familiar with. With the amount of iOS frameworks and libraries constantly expanding, it’s likely you are going to work with some frameworks you aren’t as familiar with. Most developers will know when this is, and if you have that feeling, you should run some quick profiles to ensure your work is playing nice with the rest of the application. Bringing in 3rd party libraries can also be a good time to profile to ensure that the libraries you are adding are not causing any memory issues that might be out of your control.\n\nXcode has been expanding out the ‘Debug Navigator’ to include lots of information that used to be previously buried inside of Instruments. If you hit CMD-6, you can bring up the view that shows performance information about your application. Here you can see some quick summaries of CPU/Memory/Energy/Disk/Network activity and spot check to see if there are any immediate issues. From here you can even start up Instruments by clicking the ‘Profile in Instruments’ button at the top which will ask you transfer that debug session or start a new one in Instruments.\n\nThe first thing we’ll take a look at is profiling your CPU usage. To start CPU profiling, we’ll choose to select ‘Profile’ product command and select the device as the target. You want to be sure to use an actual device when doing CPU profiling to get accurate information about the CPU usage. If you target a simulator, you’ll be getting CPU information off your machine and not how it’s running on an actual device which will be very different. Ideally you’ll want to use the slowest device you have to ensure it’ll work on that and anything faster.\n\nCPU Profiling works by taking samples of processes running at set intervals. By default it samples every 1ms, but you can change this to customize the behavior if needed. By seeing what processes are still running between snapshots, it can determine how long things are running.\n\nAfter the profile build is finished, Instruments will launch and ask you which profiling template to use. For CPU usage, we’ll use the ‘Time Profiler’.\n\nThis will give us the initial Instruments view with the Time Profiler view setup. Now to actually run the profiler, you’ll need to click the record button to start the profiling. If for some reason the record button is disabled, it should tell you why on the right hand side of the profiler track near the top. I’ve seen it get stuck in a state where it says the ‘device is offline’, and a device reboot usually fixes it. Once you’ve clicked the record button, it’ll start showing information about what’s happening in your application."
    },
    {
        "link": "https://dev.epicgames.com/community/learning/knowledge-base/a3DR/unreal-engine-faq-debugging-optimization-and-profiling?locale=ja-jp",
        "document": ""
    },
    {
        "link": "https://github.com/mikeroyal/Unreal-Engine-Guide",
        "document": "A guide covering Unreal Engine including the applications, libraries and tools that will make you a better and more efficient Unreal Engine developer.\n\nNote: You can easily convert this markdown file to a PDF in VSCode using this handy extension Markdown PDF.\n\nUnreal Engine is a game engine developed by Epic Games with the world's most open and advanced real-time 3D creation tool. Continuously evolving to serve not only its original purpose as a state-of-the-art game engine, today it gives creators across industries the freedom and control to deliver cutting-edge content, interactive experiences, and immersive virtual worlds.\n\nBlueprint Visual Scripting is a complete gameplay scripting system in Unreal Engine based on the concept of using a node-based interface to create gameplay elements from within Unreal Editor. As with many common scripting languages, it is used to define object-oriented (OO) classes or objects in the engine.\n\nDatasmith is a collection of tools and plugins that bring entire pre-constructed scenes and complex assets created in a variety of industry-standard design applications into Unreal Engine.\n\nChaos Physics is a Beta feature that is the light-weight physics simulation solution used in Fortnite, and it includes the following major features.\n\nNiagara VFX System is one of two tools you can use to create and adjust visual effects (VFX) inside Unreal Engine 5 (UE5). Before Niagara, the primary way to create and edit visual effects in UE4 was to use Cascade. It has many of the same of particle manipulation methods that Cascade offers, the way you interact and build visual effects with Niagara is vastly different.\n\nMetaHuman Creator is a free cloud-based app that empowers anyone to create photorealistic digital humans, complete with hair and clothing, in minutes. MetaHumans come fully rigged and ready to animate in your Unreal Engine projects.\n\nTwinmotion is a real-time 3D immersion software that produces high-quality images, panoramas and standard or 360° VR videos in seconds. Developed for architecture, construction, urban planning and landscaping professionals.\n\nBridgew by Quixel is a gateway to create a world of 3D content right inside the Unreal Engine. it includes Megascans—the world's largest library of AAA, cinema-quality assets based on real-world scan data.\n\nLumen is an Unreal Engine 5 feature that uses multiple ray tracing methods to solve Global Illumination and Reflections. Screen traces are done first, followed by a more reliable method. It uses Software Ray Tracing through Signed Distance Fields by default, but can achieve higher quality on supporting video cards when Hardware Ray Tracing is enabled.\n\nNanite is Unreal Engine 5's new virtualized geometry system which uses a new internal mesh format and rendering technology to render pixel scale detail and high object counts. It intelligently does work on only the detail that can be perceived and no more.\n\nNanite Spline Meshes (Experimental) is an initial implementation of SplineMeshComponent for Nanite meshes has been introduced. This feature can be enabled by setting in a settings ```.ini`` file. WARNING: Enabling this feature currently comes with a performance cost that affects culling performance of all Nanite, and there are currently known issues with incorrect culling under extreme deformation.\n\nOrthographic rendering (Experimental) is a very common way to visualize projects in architecture and manufacturing, and is also used in games as a stylistic camera choice. Multiple areas of the engine have been fixed to achieve parity between perspective and orthographic projections. Most modern features of UE5 should now work, including Lumen, Nanite, Shadows, and TSR.\n\nProcedural Content Generation Framework (PCG) is a toolset for creating your own procedural content inside Unreal Engine. It provides artists and designers the ability to build fast, iterative tools and content of any complexity ranging from asset utilities, such as buildings or biome generation, up to entire worlds.\n\nUnreal Engine's VCam system is a Cine Camera in Unreal Engine that uses a modular component system to manipulate camera data and output the final results to a variety of external output devices. In addition, the Virtual Camera system provides its functionality while in the editor and during Play In Editor (PIE) or Standalone Game mode.\n\nPolyEd (PolyGroup Edit) is a tool that includes a suite of operations for editing a mesh with PolyGroups. Common operations such as Extrude, Bevel, Weld, and Bridge are available. Also included are operations that only work with structured PolyGroups, such as Insert Edge Loop and edge loop/ring selection.\n\nPolyDef is a tool that dynamically alters the shape of a mesh through its PolyGroups. Deformation is an efficient way to reshape a mesh quickly and create organic geometry.\n\nPaper 2D is a sprite-based system for creating 2D and 2D/3D hybrid games entirely within the unreal Enginr editor. At the core of Paper 2D are Sprites (which are a Texture Mapped Planar Mesh and associated Material). It can edit Sprites inside Unreal Engine with the Sprite Editor and create sprite-based animations with Flipbooks (which animate a series of Sprites sequentially by using key frames and specifying a duration in frames to display them).\n\nnDisplay is a tool in Unreal Engine that describes how multiple computers work together in an nDisplay rendering network.\n\nAWS Thinkbox Deadline for Unreal Engine is a plugin to integrate and automate Deadline renders from inside the UE Movie Render Queue, allowing customers to streamline the process of connecting AWS Thinkbox Deadline 10.3 and onwards to work originated in UE5.\n\nUnreal Engine Marketplace is Unreal Engine's Store that has a library Of Textures, Models, Animations, Tutorials, and More for creating amazing 3D projects and games.\n\nUnrealBuildTool (UBT) is a tool that manages the process of building UE4 source code across a variety of build configurations.\n\nUnrealHeaderTool (UHT) is a custom parsing and code-generation tool supporting the UObject system.\n\nAutomationTool is a generic system used to automate processes, including testing and building games.\n\nProxy Geometry Tool is a tool-set that was developed as a way to increase your Unreal Engine 4 (UE4) project's performance while keeping the visual quality of your project uneffected.\n\nQuixel Megascans is a massive online scan library of high-resolution, consistent PBR calibrated surface, vegetation and 3D scans, also including desktop applications for managing, mixing and exporting your downloaded scan data.\n\nReplay System is a tool which can record gameplay for later viewing. This feature is available in all games, from live, multiplayer games played on dedicated servers, to single-player games, and even including Play-In-Editor sessions. At a high level, the Replay system works by using a DemoNetDriver to read data drawn from the built-in replication system, similar to how a NetDriver operates in a live, networked gameplay environment.\n\nTake Recorder is a tool that enables the fast iteration of recording performances and quickly reviewing previous takes for virtual production workflows. You can easily record animations from motion capture linked to characters in the level, as well as actual Live Link data for future playback.\n\nCesium for Unreal is a tool that brings the 3D geospatial ecosystem to Unreal Engine. By combining a high-accuracy full-scale WGS84 globe, open APIs and open standards for spatial indexing such as 3D Tiles, and cloud-based real-world content from Cesium ion with Unreal Engine, this project enables a new era of 3D geospatial software.\n\nUnreal Engine Live-streaming Toolkit is a Live-streaming Toolkit for video, alpha and audio (Viewport, Cinecam, 360 Camera) via RTMP/ RTSP/ SRT/ NDI/ Spout/ Virtual Webcam plus direct display and window capture. Available in Unreal Marketplace.\n\nAWS Thinkbox Deadline for Unreal Engine is a plugin to integrate and automate Deadline renders from inside the UE Movie Render Queue, allowing customers to streamline the process of connecting AWS Thinkbox Deadline 10.3 and onwards to work originated in UE5.\n\nNanite Spline Meshes (Experimental) is an initial implementation of SplineMeshComponent for Nanite meshes has been introduced. This feature can be enabled by setting in a settings ```.ini`` file. WARNING: Enabling this feature currently comes with a performance cost that affects culling performance of all Nanite, and there are currently known issues with incorrect culling under extreme deformation.\n\nOrthographic rendering (Experimental) is a very common way to visualize projects in architecture and manufacturing, and is also used in games as a stylistic camera choice. Multiple areas of the engine have been fixed to achieve parity between perspective and orthographic projections. Most modern features of UE5 should now work, including Lumen, Nanite, Shadows, and TSR.\n\nFidelityFX Super Resolution 2 for Unreal Engine is plugin tool for AMD's open source temporal upscaling solution. It uses cutting-edge temporal algorithms to reconstruct fine geometric and texture detail, producing anti-aliased output from aliased input.\n\nNVIDIA DLSS 3 for Unreal Engine is a tool that contains both the DLSS Super Resolution Plugin and the DLSS Frame Generation Plugin.\n\nHoudini Engine for Unreal is a Houdini Engine Plugin for Unreal Engine that brings Houdini's powerful and flexible procedural workflow into Unreal Engine through Houdini Digital Assets. Artists can interactively adjust asset parameters inside the editor and use Unreal assets as inputs. Houdini's procedural engine will then \"cook\" the asset and the results will be available in the editor without the need for baking.\n\nPySide Layout Tool is a python application built to help Technical Artist and Tool Developers to make quick clean parameter layout with python script support.\n\nHttpGPT is an Unreal Engine 5 plugin that facilitates integration with OpenAI's GPT based services (ChatGPT and DALL-E) through asynchronous REST requests, making it easy for developers to communicate with these services. It also includes Editor Tools to integrate Chat GPT and DALL-E image generation directly in the Engine.\n\nDataConfig is a Unreal Engine JSON/MsgPack serialization framework. Unreal Engine features a powerful Property System which implements C++ runtime reflection. DataConfig is a serialization framework build on top of it.\n\nSubstance 3D is a plugin that enables the use of Substance materials directly in Unreal Engine 5 and Unreal Engine 4. Whether you are working on games, visualization and or deploying across mobile, desktop, or XR, Substance delivers a unique experience with optimized features for enhanced productivity. The runtime currently works for Windows, Mac, and Linux.\n• How to migrate your Unreal Engine 4 projects to Unreal Engine 5 Early Access quickly and smoothly\n\nNote: you will need to create an Epic Games account to download Unreal Engine.\n• Unreal Online Learning is a free learning platform that offers hands-on video courses and guided learning paths.\n• Unreal Engine 5 Crash Course with Blueprint by Beau Carnes\n• Learn Game Design with Online Courses and Classes from edX\n• Game Design and Development Specialization Course from Coursera\n• Unreal Engine 5 for Beginners: Dive into the world of game development with Unreal Engine 5 to build amazing 3D games by Sargey Rose\n• Blueprints Visual Scripting for Unreal Engine 5: Unleash the true power of Blueprints to create impressive games and applications in UE5, 3rd Edition by by Marcos Romero, Brenden Sewell, Luis Cataldi\n• Unreal Engine 5 Character Creation, Animation, and Cinematics: Create custom 3D assets and bring them to life in Unreal Engine 5 using MetaHuman, Lumen, and Nanite by Henk Venter, Wilhelm Ogterop\n• Elevating Game Experiences with Unreal Engine 5: Bring your game ideas to life using the new Unreal Engine 5 and C++, 2nd Edition by Goncalo Marques, Devin Sherry, David Pereira, Hammad Fozi\n• Unreal Engine 5 RPG Development with C++ and Blueprint: Volume I: Basics, Combat, and VFX by Dr. Chihming Chiu\n• Build Stunning Real-time VFX with Unreal Engine 5: Start your journey into Unreal particle systems to create realistic visual effects using Niagara by Hrishikesh Andurlekar\n• Game Development Patterns with Unreal Engine 5: Build maintainable and scalable systems with C++ and Blueprint by Stuart Butler , Tom Oliver\n• Unreal Engine 5 Shaders and Effects Cookbook: Over 70 recipes for creating materials and advanced shading techniques, 2nd Edition by Brais Brenlla Ramos\n• Game Development with Unreal Engine 5: Learn the Basics of Game Development in Unreal Engine 5 by by Mitchell Lynn, Cliff Sharif\n• Unreal Engine C++ the Ultimate Developer's Handbook: Learn C++ and Unreal Engine by Creating a Complete Action Game by Stephen Seth Ulibarri\n• Unreal Engine from Zero to Proficiency (Foundations): A Step-by-step guide to your first game with Unreal Engine by Patrick Felicia\n• Reimagining Characters with Unreal Engine's MetaHuman Creator: Elevate your films with cinema-quality character designs and motion capture animation by Brian Rossney, Ciaran Kavanagh\n\nPlayStation® VR Headset is a virtual reality headset developed by Sony Interactive Entertainment. It gives the user an amazing gaming experience with stunning High Dynamic Range visuals and up to 120fps, as two 1920 x 1080 OLED displays deliver a vast 100º field of view. PSVR is fully functional with the PlayStation 4™ and is forward compatible with the PlayStation 5™ home video game console.\n\nPlayStation®VR2 is the next generation of virtual reality gaming by PlayStation. It gives the user an amazing gaming experience with new stunning 4K High Dynamic Range visuals and up to 120fps, as two 2000 x 2040 OLED displays deliver over four times the resolution generated by the original PlayStation®VR headset. A vast 110º field of view and a light, well-balanced Fresnel lens. The lens adjustment dial allows you to customize spacing between lenses to match your eye position for an optimal onscreen image. Along with ground-breaking new controllers and genre-defining games, all made possible by the power of PS5™.\n• Getting your game ready for Steam Deck\n\nSteamworks is a free suite of tools available to any developer to use in their game or software on Steam and the Steam Deck.\n\nSteam Hardware GitLab Repo is a repository that contains CAD files for the external shell (surface topology) of Steam Deck, under a Creative Commons license. This includes an STP model, STL model, and drawings (DWG) for reference.\n\nDynamic Cloud Sync is a tool that Steam will use to automatically upload all modified save game data to the cloud prior to the device entering sleep mode. Users can then resume their game on any PC, laptop or other device. Steam will also automatically download any save game changes when users return to their Steam Deck and wake up the device.\n\nSteam Cloud is a tool that provides an easy and transparent remote file storage system for your game. Files specified in the Auto-Cloud configuration or written to disk (created, modified, deleted, etc.) using the Cloud API will automatically be replicated to the Steam servers after the game exits. If the user changes computers, the files are automatically downloaded to the new computer prior to the game launching. The game can then access the files by reading them through the Cloud API or reading them directly from disk as usual. Avoid machine specific configurations such as video settings.\n\nGamescope is a SteamOS session micro-compositing window manager formerly known as steamcompmgr.\n\nAMD FidelityFX Super Resolution (FSR) is an open source, high-quality solution for producing high resolution frames from lower resolution inputs. It enables “practical performance” for costly render operations, such as hardware ray tracing for the AMD RDNA™ and AMD RDNA™ 2 architectures.\n\nMangoHud is a Vulkan and OpenGL overlay for monitoring FPS, temperatures, CPU/GPU load and more.\n\nGOverlay is an open source project aimed to create a Graphical UI to manage Vulkan/OpenGL overlays. It is still in early development.\n\nReplaySorcery is an open-source, instant-replay solution for Linux.\n\nDeck Verified is a program that reviews games in Steam's catalog verifying their compatibility with the Steam Deck. So when you visit your Library on Steam Deck, you’ll find a compatibility badge on each title, reflecting the kind of experience you can expect when playing each game on Steam Deck.\n\nThe easiest way to install Unreal Engine 5 on your Linux system is using the Epic Asset Manager that's availble on FlatHub as a Flatpak. If you don't have Flatpak installed on your Linux system follow these simple instructions to get started.\n\nEpic Asset Manager is an unofficial client to install Unreal Engine, download and manage purchased assets, projects, plugins and games from the Epic Games Store.\n\nVisual Studio is an integrated development environment (IDE) from Microsoft; which is a feature-rich application that can be used for many aspects of software development. Visual Studio makes it easy to edit, debug, build, and publish your app. By using Microsoft software development platforms such as Windows API, Windows Forms, Windows Presentation Foundation, and Windows Store.\n\nVSExtensibility is a repo for upcoming changes to extensibility in Visual Studio, the new extensibility model, and Language Server Protocol(LSP).\n\nVisual Studio Marketplace is a marketplace for all extensions for Visual Studio, Azure DevOps Services, Azure DevOps Server and Visual Studio Code.\n\nVisual Studio Code is a lightweight but powerful source code editor which runs on your desktop and is available for Windows, macOS and Linux. It comes with built-in support for JavaScript, TypeScript and Node.js and has a rich ecosystem of extensions for other languages (such as C++, C#, Java, Python, PHP, Go) and runtimes (such as .NET and Unity).\n\nVisual Studio Code Marketplace is a marketplace for all extensions for Visual Studio, Azure DevOps Services, Azure DevOps Server and Visual Studio Code.\n\nWorking with GitHub in VS Code\n\nCode Server is a tool that allows you to run VS Code on any machine anywhere and access it in the browser.\n\nGitHub Codespaces is an integrated development environment(IDE) on GitHub. That allows developers to develop entirely in the cloud using Visual Studio and Visual Studio Code. Also, from any repo or pull request on GitHub you can simply press the period (.) key on your keyboard to bring up the browser-based VS Code environment with the source code file ready for editing. That dot (.) press to bring up the web-based VS Code editor takes you to https://github.dev/.\n\nLanguage Server Protocol (LSP) is a tool that defines the protocol used between an editor or IDE and a language server that provides language features like auto complete, go to definition, find all references.\n\nNote: Visual Studio IntelliCode is installed by default with any workload that supports C#, C++, TypeScript/JavaScript, or XAML in Visual Studio 2022.\n\nVisual Assist is a productivity tool for C/C++ and C# that improves IDE features related to navigation, refactoring, code generation, and coding assistance along with specific tooling for UE4/UE5.\n\nResharper is a popular developer productivity extension for Microsoft Visual Studio. It automates most of what can be automated in your coding routines. It finds compiler errors, runtime errors, redundancies, and code smells right as you type, suggesting intelligent corrections for them.\n\nVisual Studio Live Share is an extension that provides a collection of extensions that enable real-time collaborative development with VS Live Share.\n\nVisual Studio Spell Checker is an editor extension that checks the spelling of comments, strings, and plain text as you type or interactively with a tool window. It can also spell check an entire solution, project, or selected items.\n\nGitHub Extensions for Visual Studio is a Visual Studio Extension that brings the GitHub Flow into Visual Studio.\n\nREST API Client Code Generator is a collection of Visual Studio C# custom tool code generators for Swagger / OpenAPI specification files.\n\nCode Maid is an open source Visual Studio extension to cleanup and simplify our C#, C++, F#, VB, PHP, PowerShell, R, JSON, XAML, XML, ASP, HTML, CSS, LESS, SCSS, JavaScript and TypeScript coding.\n\nVS Color Output is an extension for Visual Studio. This extension is a color output for build and debug windows.\n\nVisual Studio Theme Pack is a collection of popular themes, now available for Visual Studio.\n\nMarkdown Editor is afull featured Markdown editor with live preview and syntax highlighting. Supports GitHub flavored Markdown.\n\nSQLite and SQL Server Compact Toolbox is an extension for Visual Studio. This extension adds several features to help your embedded database development efforts: Scripting of tables and data, import from SQL Server and CSV files and much, much more.\n\nNuGet Package Manager collection of tools to automate the process of downloading, installing, upgrading, configuring, and removing packages from a VS Project.\n\nSlowCheetah is a package allows you to automatically transform your app.config (or any file) when you press F5 in Visual Studio. You can have different transformations based on the build configuration. This will enable you to easily have different app settings, connection strings, etc for Debug versus Release.\n\nRoslynator is a collection of 500+ analyzers, refactorings and fixes for C#, powered by Roslyn.\n\nTrailing Whitespace Visualizer is an extension will highlight and remove any trailing whitespace on any line in any editor in Visual Studio. This makes it really easy to get rid of those annoying invisible characters.\n\nMagical C# Debugging—OzCode is a must have Visual Studio Extension which cuts down on debugging time and increases productivity by detecting and isolating bugs, making them easy to fix.\n\nFile Icons is an extension that adds file icons to Solution Explorer for files that Visual Studio doesn't provide icons for.\n\nImage Optimizer is an extension that uses industry standard tools to optimize any JPEG, PNG and Gifs - including animated Gifs. It can do both lossy and lossless optimization.\n\nFile Nesting is an extension that automatically nest files based on file name and enables developers to nest and unnest any file manually.\n\nNCrunch for Visual Studio is an automated parallel continuous testing tool for Visual Studio .NET. It intelligently takes responsibility for running automated tests so that you don't have to, and it gives you a huge amount of useful information about your tests (such as code coverage and performance metrics) inline in your IDE while you work.\n\nSideWaffle Template Pack is an extension that contains both item and project templates suitable for building websites, Windows apps, Windows Phone apps, WPF, Visual Studio extensibilty project and a lot more.\n\nPostSharp is the #1 pattern-aware extension to C# and VB. It allows developers to eradicate boilerplate. Implements some of the most common patterns and gives you the tools to build your own.\n\nVisual Studio Live Share is a service/ extension that enables you to collaboratively edit and debug with others in real time, regardless of the programming languages you're using or app types you're building. You can instantly and securely share your current project, start a joint debugging session, share terminal instances, forward localhost web apps, have voice calls, and more.\n\nGistPad is a Visual Studio Code extension that allows you to edit GitHub Gists and repositories from the comfort of your favorite editor. You can open, create, delete, fork and star gists and repositories, and then seamlessly begin editing files as if they were local, without ever cloning, pushing or pulling anything.\n\nLive Server is an extension for Visual Studio Code that launches a development local Server with live reload feature for static & dynamic pages.\n\nGitHub Pull Requests and Issues is an extension for Visual Studio Code that allows you to review and manage GitHub pull requests and issues in Visual Studio Code.\n\nTerminal is an extension for Visual Studio Code that lets you run terminal command directly in the Editor.\n\nProfile Switcher is an extension for Visual Studio Code that allows you to switch between different profiles you have created.\n\nMaterial Icon Theme is an extension for Visual Studio Code that gets the Material Design icons into your VS Code.\n\nOne Dark Pro is an extension for Visual Studio Code that adds Atom's iconic One Dark theme, which is one of the most installed themes for VS Code.\n\nVSCode Icons is an extension for Visual Studio Code that brings icons to your Visual Studio Code setup.\n\nGitLens is an extension for Visual Studio Code that helps you visualize code authorship at a glance via Git blame annotations and code lens, seamlessly navigate and explore Git repositories, gain valuable insights via powerful comparison commands, and so much more.\n\nImport Cost is an extension for Visual Studio Code that will display inline in the editor the size of the imported/required package. The extension utilizes webpack with babili-webpack-plugin in order to detect the imported size.\n\nMarkdown All in One is an extension for Visual Studio Code that gives you everything you need to write Markdown (keyboard shortcuts, table of contents, auto preview and more).\n\nAuto Rename Tag is an extension for Visual Studio Code that automatically add HTML/XML close tag, same as Visual Studio IDE or Sublime Text.\n\nAuto-Close Tag is an extension for Visual Studio Code that automatically add HTML/XML close tag, same as Visual Studio IDE or Sublime Text does.\n\nSettings Sync is an extension for Visual Studio Code that synchronizes Settings, Snippets, Themes, File Icons, Launch, Keybindings, Workspaces and Extensions Across Multiple Machines Using GitHub Gist.\n\nBookmarks is an extension for Visual Studio Code that lets you mark lines of code and jump to them.\n\nBetter Comments is an extension for Visual Studio Code that improves your code commenting by annotating with alert, informational, TODOs, and more.\n\nCode Spell Checker is an extension for Visual Studio Code that works as a spelling checker for source code.\n\nCSS Peak is an extension for Visual Studio Code that allows peeking to css ID and class strings as definitions from html files to respective CSS. It also allows peek and goto definition.\n\nTailwind CSS IntelliSense is an extension for Visual Studio Code that enhances the Tailwind development experience by providing Visual Studio Code users with advanced features such as autocomplete, syntax highlighting, and linting.\n\nPrettier is an extension for Visual Studio Code that is an opinionated code formatter. It enforces a consistent style by parsing your code and re-printing it with its own rules that take the maximum line length into account, wrapping code when necessary.\n\nNPM Intellisense is an extension for Visual Studio Code that autocompletes npm modules in import statements.\n\nPath Intellisense is an extension for Visual Studio Code that autocompletes filenames.\n\nRelative Path is an extension for Visual Studio Code that gets the relative url paths from files in the current workspace.\n\nPath Autocomplete is an extension for Visual Studio Code that provides path completion for visual studio code.\n\nDiscord Presence is an extension for Visual Studio Code that updates your discord status with a rich presence.\n\nCode Runner is an extension for Visual Studio Code that runs code snippets or code files for multiple languages: C/C++, Java, JavaScript, PHP, Python, Perl, Ruby, Go, Lua, Groovy, PowerShell, BASH/SH, C#, F#, .NET Core, TypeScript, CoffeeScript, Scala, Swift, Julia, OCaml, R, Elixir, Clojure, Haxe, Objective-C, Rust, Racket, Scheme, Kotlin, Dart, Haskell, Nim, D, CUDA, and custom command.\n\nKite is an extension for Visual Studio Code that provides an AI-powered programming assistant that helps you write code faster inside Visual Studio Code. Kite works for all major programming languages: Python, Java, Go, PHP, C/C#/C++, Javascript, HTML/CSS, Typescript, React, Ruby, Scala, Kotlin, Bash, Vue and React.\n\nTabnine is an extension for Visual Studio Code that provides an AI code completion tool trusted by millions of developers to code faster with fewer errors. Whether you are a new dev or a seasoned pro, working solo or part of a team, Tabnine will help push your productivity to new heights while cutting your QA time in your favorite IDE.\n\nXcode includes everything developers need to create great applications for Mac, iPhone, iPad, Apple TV, and Apple Watch. Xcode provides developers a unified workflow for user interface design, coding, testing, and debugging. Xcode 14 is built as an Universal app that runs 100% natively on Intel-based CPUs and Apple Silicon. It includes a unified macOS SDK that features all the frameworks, compilers, debuggers, and other tools you need to build apps that run natively on Apple Silicon and the Intel x86_64 CPU.\n\nXcode Cloud is a continuous integration and delivery service built into Xcode and designed expressly for Apple developers. It accelerates the development and delivery of high-quality apps by bringing together cloud-based tools that help you build apps, run automated tests in parallel, deliver apps to testers, and view and manage user feedback.\n\nSwiftUI is a user interface toolkit that provides views, controls, and layout structures for declaring your app's user interface. The SwiftUI framework provides event handlers for delivering taps, gestures, and other types of input to your application.\n\nUIKit is a framework provides the required infrastructure for your iOS or tvOS apps. It provides the window and view architecture for implementing your interface, the event handling infrastructure for delivering Multi-Touch and other types of input to your app, and the main run loop needed to manage interactions among the user, the system, and your app.\n\nAppKit is a graphical user interface toolkit that contains all the objects you need to implement the user interface for a macOS app such as windows, panels, buttons, menus, scrollers, and text fields, and it handles all the details for you as it efficiently draws on the screen, communicates with hardware devices and screen buffers, clears areas of the screen before drawing, and clips views.\n\nARKit is a set of software development tools to enable developers to build augmented-reality apps for iOS developed by Apple. The latest version ARKit 3.5 takes advantage of the new LiDAR Scanner and depth sensing system on iPad Pro(2020) to support a new generation of AR apps that use Scene Geometry for enhanced scene understanding and object occlusion.\n\nRealityKit is a framework to implement high-performance 3D simulation and rendering with information provided by the ARKit framework to seamlessly integrate virtual objects into the real world.\n\nSceneKit is a high-level 3D graphics framework that helps you create 3D animated scenes and effects in your iOS apps.\n\nMac Catalyst is a set of Apple APIs that developers can use to rapidly port their iOS apps to Apple Silicon M1 Chip and take full advantage of the new capabilities on the new Apple hardware.\n\nInstruments is a powerful and flexible performance-analysis and testing tool that’s part of the Xcode tool set. It’s designed to help you profile your iOS, watchOS, tvOS, and macOS apps, processes, and devices in order to better understand and optimize their behavior and performance.\n\nTestFlight is a tool that makes it easy to invite users to test your apps and App Clips and collect valuable feedback before releasing your apps on the App Store. It allows you to invite up to 10,000 testers using just their email address or by sharing a public link.\n\nmacOS is an advanced desktop operating system (OS) for Apple's series of desktops and laptops.\n\niOS is an advanced mobile operating system (OS) for Apple's series of iPhone products.\n\niPadOS is an advanced mobile operating system (OS) for Apple's series of iPad products.\n\nWatchOS is an advanced mobile operating system (OS) for Apple's series of Watch products.\n\ntvOS is an advanced mobile operating system (OS) for Apple's series of TV products.\n\nNVIDIA Reflex is a new feature that was introduced with the RTX 30(3000) series GPUs that allows game developers to implement a low latency mode that aligns game engine work to complete just-in-time for rendering, eliminating the GPU render queue and reducing CPU back pressure in GPU-bound scenarios. In addition to latency reduction functions, the SDK also features measurement markers to calculate both Game and Render Latency that are great for debugging and visualizing in-game performance counter.\n\nNVIDIA DLSS (Deep Learning Super Sampling) is a temporal image upscaling AI rendering technology that increases graphics performance using dedicated Tensor Core AI processors on GeForce RTX™ GPUs. DLSS uses the power of a deep learning neural network to boost frame rates and generate beautiful, sharp images for your games.\n\nAMD FidelityFX Super Resolution (FSR) is an open source, high-quality solution for producing high resolution frames from lower resolution inputs. It uses a collection of cutting-edge Deep Learning algorithms with a particular emphasis on creating high-quality edges, giving large performance improvements compared to rendering at native resolution directly. FSR enables “practical performance” for costly render operations, such as hardware ray tracing for the AMD RDNA™ and AMD RDNA™ 2 architectures.\n\nIntel Xe Super Sampling (XeSS) is a temporal image upscaling AI rendering technology that increases graphics performance similar to NVIDIA's DLSS (Deep Learning Super Sampling). Intel's Arc GPU architecture (early 2022) will have GPUs that feature dedicated Xe-cores to run XeSS. The GPUs will have Xe Matrix eXtenstions matrix (XMX) engines for hardware-accelerated AI processing. XeSS will be able to run on devices without XMX, including integrated graphics, though, the performance of XeSS will be lower on non-Intel graphics cards because it will be powered by DP4a instruction.\n\nUnigine is a cross-platform game engine designed for development teams (C++/C# programmers, 3D artists) working on interactive 3D apps.\n\nFrostbite is a game engine developed by DICE, designed for cross-platform use on Microsoft Windows and game consoles such as PlayStation 3 Xbox 360, PlayStation 4, Xbox One, Nintendo Switch, PlayStation 5, and Xbox Series X/S.\n\nPanda3D is a game engine, a framework for 3D rendering and game development for Python and C++ programs, developed by Disney and CMU. Panda3D is open-source and free for any purpose, including commercial ventures.\n\nSource 2 is a 3D video game engine in development by Valve as a successor to Source. It is used in Dota 2, Artifact, Dota Underlords, parts of The Lab, SteamVR Home, and Half-Life: Alyx.\n\nHavok is a middleware software suite that provides a realistic physics engine component and related functions to video games. It is supported and optimized across all major platforms, including Nintendo Switch, PlayStation®, Stadia, and Xbox. Along with integrations for Unity and Unreal Engine and are used in countless proprietary game engines.\n\nAutoDesk 3ds Max is a professional software program for 3D modeling, animation, rendering, and visualization. 3ds Max allows you to create stunning game environments, design visualizations, and virtual reality experiences.\n\nHoudini is a 3D procedural software for modeling, rigging, animation, VFX, look development, lighting and rendering in film, TV, advertising and video game pipelines.\n\nA-Frame is a web framework for building virtual reality experiences in WebVR with HTML and Entity-Component. A-Frame works on Vive, Rift, desktop, mobile platforms.\n\nAppGameKit is a powerful game development engine, ideal for Hobbyist and Indie developers. Where you can start coding in the easy to learn AppGameKit BASIC or use the libraries in C++ & XCode.\n\nAmazon Lumberyard is an open source, AAA game engine(based on CryEngine) that gives you the tools you need to create high quality games. Deeply integrated with AWS and Twitch, Amazon Lumberyard includes full source code, allowing you to customize your project at any level.\n\nBlender is the free and open source 3D creation suite. It supports the entirety of the 3D pipeline—modeling, rigging, animation, simulation, rendering, compositing and motion tracking, video editing and 2D animation pipeline.\n\nGameMaker Studio 2 is the latest and greatest incarnation of GameMaker. It has everything you need to take your idea from concept to finished game. With no barriers to entry and powerful functionality, GameMaker Studio 2 is the ultimate 2D development environment.\n\nGodot is a feature-packed, cross-platform game engine to create 2D and 3D games from a unified interface. It provides a comprehensive set of common tools, so that users can focus on making games without having to reinvent the wheel. Games can be exported in one click to a number of platforms, including the major desktop platforms (Linux, Mac OSX, Windows) as well as mobile (Android, iOS) and web-based (HTML5) platforms.\n\nOpen Graphics Library(OpenGL) is an API used acrossed mulitple programming languages and platforms for hardware-accelerated rendering of 2D/3D vector graphics currently developed by the Khronos Group.\n\nOpen Computing Language (OpenCL) is an open standard for parallel programming of heterogeneous platforms consisting of CPUs, GPUs, and other hardware accelerators found in supercomputers, cloud servers, personal computers, mobile devices and embedded platforms.\n\nOpenGL Shading Language(GLSL) is a High Level Shading Language based on the C-style language, so it covers most of the features a user would expect with such a language. Such as control structures (for-loops, if-else statements, etc) exist in GLSL, including the switch statement.\n\nHigh Level Shading Language(HLSL) is the High Level Shading Language for DirectX. Using HLSL, the user can create C-like programmable shaders for the Direct3D pipeline. HLSL was first created with DirectX 9 to set up the programmable 3D pipeline.\n\nDirectX 12 Ultimate is an API(for high performance 2D & 3D graphics) from Microsoft. DirectX 12 Ultimate brings support for ray tracing, mesh shaders, variable rate shading, and sampler feedback. Available in Windows 2004 version(May 2020 Update).\n\nVulkan is a modern cross-platform graphics and compute API that provides high-efficiency, cross-platform access to modern GPUs used in a wide variety of devices from PCs and consoles to mobile phones and embedded platforms. Vulkan is currently in development by the Khronos consortium.\n\nMetal is a low-level GPU programming framework used for rendering 2D and 3D graphics on Apple platforms such as iOS, iPadOS, macOS, watchOS and tvOS.\n\nMoltenVK is an implementation of Vulkan running on iOS and macOS using Apple's Metal graphics framework.\n\nMoltenGL is an implementation of the OpenGL ES 2.0 API that runs on Apple's Metal graphics framework.\n\nMesa 3D Graphics Library is a project began as an open-source implementation of the OpenGL specification. A system for rendering interactive 3D graphics. Mesa ties into several other open-source projects: the Direct Rendering Infrastructure, X.org, and Wayland to provide OpenGL support on Linux, FreeBSD, and other operating systems.\n\nOpenGL ES is the mobile subset of OpenGL. It's supported on all major mobile platforms, and is also the base for WebGL.\n\nOpenCL is a framework for writing programs that execute across heterogeneous platforms consisting of CPUs, GPUs, DSPs, FPGAs and other processors or hardware accelerators.\n\nEGL is an interface between Khronos rendering APIs such as OpenGL or OpenVG and the underlying native platform window system.\n\nVDPAU is the Video Decode and Presentation API for UNIX. It provides an interface to video decode acceleration and presentation hardware present in modern GPUs.\n\nVA API is an open-source library and API specification, which provides access to graphics hardware acceleration capabilities for video processing.\n\nXvMC is an extension of the X video extension (Xv) for the X Window System. The XvMC API allows video programs to offload portions of the video decoding process to the GPU hardware.\n\nAMD Radeon ProRender is a powerful physically-based rendering engine that enables creative professionals to produce stunningly photorealistic images on virtually any GPU, any CPU, and any OS in over a dozen leading digital content creation and CAD applications.\n\nNVIDIA Omniverse is a powerful, multi-GPU, real-time simulation and collaboration platform for 3D production pipelines based on Pixar's Universal Scene Description and NVIDIA RTX.\n\nLibGDX is a cross-platform Java game development framework based on OpenGL (ES) that works on Windows, Linux, Mac OS X, Android, your WebGL enabled browser and iOS.\n\ncocos2d-x is a multi-platform framework for building 2d games, interactive books, demos and other graphical applications. It is based on cocos2d-iphone, but instead of using Objective-C, it uses C++. It works on iOS, Android, macOS, Windows and Linux.\n\nMonoGame is a framework for creating powerful cross-platform games. The spiritual successor to XNA with thousands of titles shipped across desktop, mobile, and console platforms. MonoGame is a fully managed .NET open source game framework without any black boxes.\n\nThree.js is a cross-browser JavaScript library and application programming interface used to create and display animated 3D computer graphics in a web browser using WebGL.\n\nSuperpowers is a downloadable HTML5 app for real-time collaborative projects . You can use it solo like a regular offline game maker, or setup a password and let friends join in on your project through their Web browser.\n\nURHO3D is a free lightweight, cross-platform 2D and 3D game engine implemented in C++ and released under the MIT license. Greatly inspired by OGRE and Horde3D.\n\nVivox is a voice & text chat platform that's trusted by the world's biggest gaming brands and titles such as Fortnite, PUBG, League of Legends, and Rainbow Six Siege.\n\nHGIG is a volunteer group of companies from the game and TV display industries that meet to specify and make available for the public guidelines to improve consumer gaming experiences in HDR.\n\nAugmented Reality (AR) is an interactive experience of a real-world environment where the objects that reside in the real world are enhanced by computer-generated perceptual information.\n\nVirtual Reality (VR) is a simulated experience that can be similar to or completely different from the real world. The applications of virtual reality include entertainment (video games), education (medical or military training) and business (virtual meetings).\n\nMixed Reality (MR) is the merging of real and virtual worlds to produce new environments and visualizations, where physical and digital objects co-exist and interact in real time.\n\nExtended Reality (XR) is a concept referring to all real-and-virtual combined environments and human-machine interactions generated by computer technology and wearables. Including augmented reality (AR), mixed reality (MR) and virtual reality (VR).\n\nARKit is a set of software development tools to enable developers to build augmented-reality apps for iOS developed by Apple. The latest version ARKit 3.5 takes advantage of the new LiDAR Scanner and depth sensing system on iPad Pro(2020) to support a new generation of AR apps that use Scene Geometry for enhanced scene understanding and object occlusion.\n\nRealityKit is a framework to implement high-performance 3D simulation and rendering with information provided by the ARKit framework to seamlessly integrate virtual objects into the real world.\n\nSceneKit is a high-level 3D graphics framework that helps you create 3D animated scenes and effects in your iOS apps.\n\nGPUImage framework is a BSD-licensed iOS library that lets you apply GPU-accelerated filters and other effects to images, live camera video, and movies. In comparison to Core Image (part of iOS 5.0), GPUImage allows you to write your own custom filters, supports deployment to iOS 4.0, and has a simpler interface. However, it currently lacks some of the more advanced features of Core Image, such as facial detection.\n\nGPUImage3 is the third generation of the GPUImage framework, an open source project for performing GPU-accelerated image and video processing on Mac and iOS. The original GPUImage framework was written in Objective-C and targeted Mac and iOS, the second iteration rewritten in Swift using OpenGL to target Mac, iOS, and Linux, and now this third generation is redesigned to use Apple's Metal in place of OpenGL.\n\nARCore is a software development kit developed by Google that allows for augmented reality applications in the real world. These tools include environmental understanding, which allows devices to detect horizontal and vertical surfaces and planes. It also includes motion tracking, which lets phones understand and track their positions relative to the world. Also ARCore’s Light Estimation API lets your digital objects appear realistically as if they’re actually part of the physical world.\n\nAdobe Aero is a powerful new augmented reality (AR) authoring tool that makes it easier for designers to create immersive content.\n\nVuforia is a comprehensive, scalable enterprise AR platform. Our wide-ranging solution suite ensures that we can provide the right AR technology to every customer based on their business needs.\n\nVuforia Studio is a tool that allows anyone to create beautiful 3D augmented reality (AR) experiences in a matter of minutes with no coding required.\n\nOpenVX™ is an open-source, royalty-free standard for cross platform acceleration of computer vision applications. OpenVX enables performance and power-optimized computer vision processing, especially important in embedded and real-time use cases such as face, body and gesture tracking, smart video surveillance, advanced driver assistance systems (ADAS), object and scene reconstruction, augmented reality, visual inspection, robotics and more.\n\nARToolKit is a fast and modern open source tracking and recognition SDK which enables computers to see and understand more in the environment around them. It's built from the ground up using modern computer vision techniques.\n\nARmedia is a plugin tool that makes it easy to develop and create AR experiences without coding.\n\nKundan is a tool that provides proprietary Artificial Perception technologies based on SLAM to enable use cases with significant market potential and impact on our lives such as autonomous driving, robotics, AR/VR and smart cities.\n\nOVR Toolkit is a utility application designed to make viewing the desktop in VR simple and fast, it allows for viewing the desktop within VR, placing desktop windows around the world, mouse input, typing with a virtual keyboard, and quickly switching between windows.\n\nSteamVR is the ultimate tool for experiencing VR content on the hardware of your choice. SteamVR supports the Valve Index, HTC Vive, Oculus Rift, Windows Mixed Reality headsets, and others.\n\nOpenVR is an API and runtime that allows access to VR hardware(Steam Index, HTC Vive, and Oculus Rift) from multiple vendors without requiring that applications have specific knowledge of the hardware they are targeting.\n\nOpenVR Benchmark on Steam is the first benchmark tool for reproducibly testing your real VR performance, rendering inside of your VR headset.\n\nOpenHMD is open source API and drivers that supports a wide range of HMD(head-mounted display) devices such as Oculus Rift, HTC Vive, Sony PSVR, and others.\n\nopenXR is a free, open standard that provides high-performance access to Augmented Reality (AR) and Virtual Reality (VR) collectively known as XR—platforms and devices.\n\nMonado is the first OpenXR™ runtime for GNU/Linux. Monado aims to jump-start development of an open source XR ecosystem and provide the fundamental building blocks for device vendors to target the GNU/Linux platform.\n\nLibsurvive is a set of tools and libraries that enable 6 dof tracking on lighthouse and vive based systems that is completely open source and can run on any device. It currently supports both SteamVR 1.0 and SteamVR 2.0 generation of devices and should support any tracked object commercially available.\n\nSimula is a VR window manager for Linux that runs on top of Godot. It takes less than 1 minute to install. Simula is officially compatible with SteamVR headsets equipped with Linux drivers (e.g. HTC Vive, HTC Vive Pro, & Valve Index). We have also added experimental support to OpenXR headsets that have Monado drivers (e.g. North Star, OSVR HDK, and PSVR). Some people have gotten the Oculus Rift S to run Simula via OpenHMD (see here).\n\nVulkan® is a modern cross-platform graphics and compute API that provides high-efficiency, cross-platform access to modern GPUs used in a wide variety of devices from PCs and consoles to mobile phones and embedded platforms. Vulkan is currently in development by the Khronos consortium.\n\nVulkan SDK is a set of tools that enables Vulkan developers to develop Vulkan applications.\n\nSPIR-V is a set of tools that enables high-level language front-ends to emit programs in a standardized intermediate form to be ingested by Vulkan, OpenGL or OpenCL drivers. It eliminates the need for high-level language front-end compilers in device drivers, significantly reducing driver complexity, enables a broad range of language and framework front-ends to run on diverse hardware architectures and encourages a vibrant ecosystem of open source analysis, porting, debug and optimization tools.\n\nSPIRV-Reflect is a lightweight library that provides a C/C++ reflection API for SPIR-V shader bytecode in Vulkan applications.\n\nVulkan® Tools is a project that provides Khronos official Vulkan Tools and Utilities for Windows, Linux, Android, and macOS.\n\nVulkan-Hpp is a API that provides a header only C++ bindings for the Vulkan C API to improve the developers Vulkan experience without introducing CPU runtime cost. It adds features like type safety for enums and bitfields, STL container support, exceptions and simple enumerations.\n\nVulkan® Memory Allocator (VMA) is a library that provides a simple and easy to integrate API to help you allocate memory for Vulkan® buffer and image storage.\n\nAMD Open Source Driver for Vulkan® is an open-source Vulkan driver for AMD Radeon™ graphics adapters on Linux®.\n\nNVIDIA® Nsight™ Visual Studio Edition is an application development environment for heterogeneous platforms which brings GPU computing into Microsoft Visual Studio. NVIDIA Nsight™ VSE allows you to build and debug integrated GPU kernels and native CPU code as well as inspect the state of the GPU and memory.\n\nRadeon™ GPU Profiler is a performance tool that can be used by developers to optimize DirectX®12, Vulkan® and OpenCL™ applications for AMD RDNA™ and GCN hardware.\n\nRadeon™ GPU Analyzer is a compiler and code analysis tool for Vulkan®, DirectX®, OpenGL® and OpenCL™.\n\nRadeon™ Memory Visualizer (RMV) is a tool provided by AMD for use by game engine developers. It allows engineers to examine, diagnose, and understand the GPU memory management within their projects.\n\nDXVK is a Vulkan-based translation layer for Direct3D 9/10/11 which allows running 3D applications on Linux using Wine.\n\nMoltenVK is an implementation of Vulkan running on iOS and macOS using Apple's Metal graphics framework.\n\nRenderDoc is a stand-alone graphics debugger that allows quick and easy single-frame capture and detailed introspection of any application using Vulkan, D3D11, OpenGL & OpenGL ES or D3D12 across Windows, Linux, Android, Stadia, or Nintendo Switch™.\n\nPerfDoc is a cross-platform Vulkan layer which checks Vulkan applications for best practices on Arm Mali devices.\n\nGLFW is an Open Source, multi-platform library for OpenGL, OpenGL ES and Vulkan application development. It provides a simple, platform-independent API for creating windows, contexts and surfaces, reading input, handling events, etc. GLFW natively supports Windows, macOS and Linux and other Unix-like systems. On Linux both X11 and Wayland are supported.\n\nVulkanSharp is a project provides a .NET binding for the Vulkan API.\n\nVortice.Vulkan is a .NET Standard 2.0 and .NET5 low-level bindings for Vulkan API.\n\nVKD3D-Proton is a fork of VKD3D, which aims to implement the full Direct3D 12 API on top of Vulkan.\n\nImGui is a bloat-free graphical user interface library for C++. It outputs optimized vertex buffers that you can render anytime in your 3D-pipeline enabled application. It is fast, portable, renderer agnostic and self-contained (no external dependencies).\n\nAsh is a very lightweight wrapper around Vulkan.\n\ngfx-rs is a low-level, cross-platform graphics and compute abstraction library in Rust.\n\nVulkan.jl is a lightweight wrapper around the Vulkan graphics and compute library. It exposes abstractions over the underlying C interface, primarily geared towards developers looking for a more natural way to work with Vulkan with minimal overhead.\n\nMetal is a low-level API that provides a platform-optimized, low-overhead API for developing the latest 3D pro applications and amazing games using a rich shading language with tighter integration between graphics and compute programs. To help you do more while managing ever more complex shader code, Metal adds an unparalleled suite of advanced GPU debugging tools to help you realize the full potential of your graphics code.\n\nMetal 3 is Apple's newest graphics API that introduces advanced features and compiler tools to load resources faster, compile shader binaries at build time, process complex geometry with mesh shaders, render high-resolution graphics in less time, train machine learning networks faster, and more.\n\nMTLDevice is the Metal interface to a GPU that you use to draw graphics or do parallel computation.\n\nMetal-cpp is a low-overhead C++ interface for Metal that helps you add Metal functionality to graphics apps, games, and game engines that are written in C++. Sample Code\n\nMetal plugin for TensorFlow is a TensorFlow-Metal PluggableDevice that adds improvements to machine learning training with new operations accelerated on GPU, custom operations, and distributed training support.\n\nMetalFX is a new API that provides platform optimized graphics effects for Metal applications. With MetalFX Upscaling, your application can now render frames at a lower resolution, reducing rendering time, without compromising rendering quality. We'll also show you how and when to use its two effects: spatial upscaling, which delivers substantial performance gains, and temporal AA and upscaling, which delivers the highest quality rendering.\n\nMetalPetal is a GPU accelerated image and video processing framework based on Metal designed to provide real-time processing for still image and video with easy to use programming interfaces.\n\nApple Foundation Framework is a framework provides a base layer of functionality for apps and frameworks, including data storage and persistence, text processing, date and time calculations, sorting and filtering, and networking. The classes, protocols, and data types defined by Foundation are used throughout the macOS, iOS, watchOS, and tvOS SDKs.\n\nApple Core Animation Framework is a graphics rendering and animation infrastructure that provides high frame rates and smooth animations without burdening the CPU and slowing down your app.\n\nApple Core Graphics Frameworkis a framework based on the Quartz advanced drawing engine. It provides low-level, lightweight 2D rendering with unmatched output fidelity.\n\nParavirtualized Graphics Framework is a framework that implements hardware-accelerated graphics for macOS running in a virtual machine, hereafter known as the guest. The macOS operating system provides a graphics driver that runs inside the guest, communicating with the framework in the host operating system to take advantage of Metal-accelerated graphics.\n\nXcode includes everything developers need to create great applications for Mac, iPhone, iPad, Apple TV, and Apple Watch. Xcode provides developers a unified workflow for user interface design, coding, testing, and debugging. Xcode 12 is built as an Universal app that runs 100% natively on Intel-based CPUs and Apple Silicon. It includes a unified macOS SDK that features all the frameworks, compilers, debuggers, and other tools you need to build apps that run natively on Apple Silicon and the Intel x86_64 CPU.\n\nSwiftUI is a user interface toolkit that provides views, controls, and layout structures for declaring your app's user interface. The SwiftUI framework provides event handlers for delivering taps, gestures, and other types of input to your application.\n\nUIKit is a framework provides the required infrastructure for your iOS or tvOS apps. It provides the window and view architecture for implementing your interface, the event handling infrastructure for delivering Multi-Touch and other types of input to your app, and the main run loop needed to manage interactions among the user, the system, and your app.\n\nAppKit is a graphical user interface toolkit that contains all the objects you need to implement the user interface for a macOS app such as windows, panels, buttons, menus, scrollers, and text fields, and it handles all the details for you as it efficiently draws on the screen, communicates with hardware devices and screen buffers, clears areas of the screen before drawing, and clips views.\n\nARKit is a set of software development tools to enable developers to build augmented-reality apps for iOS developed by Apple. The latest version ARKit 3.5 takes advantage of the new LiDAR Scanner and depth sensing system on iPad Pro(2020) to support a new generation of AR apps that use Scene Geometry for enhanced scene understanding and object occlusion.\n\nRealityKit is a framework to implement high-performance 3D simulation and rendering with information provided by the ARKit framework to seamlessly integrate virtual objects into the real world.\n\nSceneKit is a high-level 3D graphics framework that helps you create 3D animated scenes and effects in your iOS apps.\n\nInstruments is a powerful and flexible performance-analysis and testing tool that’s part of the Xcode tool set. It’s designed to help you profile your iOS, watchOS, tvOS, and macOS apps, processes, and devices in order to better understand and optimize their behavior and performance.\n\nCocoapods is a dependency manager for Swift and Objective-C used in Xcode projects by specifying the dependencies for your project in a simple text file. CocoaPods then recursively resolves dependencies between libraries, fetches source code for all dependencies, and creates and maintains an Xcode workspace to build your project.\n\nAppCode is constantly monitoring the quality of your code. It warns you of errors and smells and suggests quick-fixes to resolve them automatically. AppCode provides lots of code inspections for Objective-C, Swift, C/C++, and a number of code inspections for other supported languages.\n\nMoltenVK is an implementation of Vulkan running on iOS and macOS using Apple's Metal graphics framework.\n\nMicrosoft DirectX® is a low-level API that handles tasks related to multimedia for game programming and video on Microsoft platforms(Windows & Xbox).\n\nGetting Started with the DirectX 12 Agility SDK\n\nVisual Studio is an integrated development environment (IDE) from Microsoft; which is a feature-rich application that can be used for many aspects of software development. Visual Studio makes it easy to edit, debug, build, and publish your app. By using Microsoft software development platforms such as Windows API, Windows Forms, Windows Presentation Foundation, and Windows Store.\n\nVisual Studio Code is a code editor redefined and optimized for building and debugging modern web and cloud applications.\n\nDirectX-Graphics-Samples is a project that contains the DirectX 12 Graphics samples that demonstrate how to build graphics intensive applications for Windows 10.\n\nPIX on Windows is a performance tuning and debugging tool for DirectX 12 games on Windows.\n\nDirectStorage API is an API in the DirectX family originally designed for the Velocity Architecture to Windows. The DirectX API is architected in a way that takes all this into account and maximizes performance throughout the entire pipeline from NVMe drive all the way to the GPU. It does this in several ways: by reducing per-request NVMe overhead, enabling batched many-at-a-time parallel IO requests which can be efficiently fed to the GPU, and giving games finer grain control over when they get notified of IO request completion instead of having to react to every tiny IO completion. The DirectStorage API will be available on Windows 11 PCs with NVMe SSDs, but will also be support in Windows 10 version 1909 and newer.\n\nNVIDIA® Nsight™ Visual Studio Edition is an application development environment for heterogeneous platforms which brings GPU computing into Microsoft Visual Studio. NVIDIA Nsight™ VSE allows you to build and debug integrated GPU kernels and native CPU code as well as inspect the state of the GPU and memory.\n\nNVRHI (NVIDIA Rendering Hardware Interface) is a library that implements a common abstraction layer over multiple graphics APIs (GAPIs): Direct3D 11, Direct3D 12, and Vulkan 1.2. It works on Windows (x64 only) and Linux (x64 and ARM64).\n\nRTXMU - RTX Memory Utility SDK is an SDK tool that batchs up all of the acceleration structure build inputs and pass them to RTXMU which in turn will perform all the suballocation memory requests and build details including compaction. Then post build info is abstracted away by the SDK in order to do compaction under the hood. RTXMU returns acceleration structure handle ids that are used to reference the underlying memory buffers. These handle ids are passed into RTXMU to create compaction copy workloads, deallocate unused build resources or remove all memory associated with an acceleration structure.\n\nRadeon™ GPU Profiler is a performance tool that can be used by developers to optimize DirectX®12, Vulkan® and OpenCL™ applications for AMD RDNA™ and GCN hardware.\n\nRadeon™ GPU Analyzer is a compiler and code analysis tool for Vulkan®, DirectX®, OpenGL® and OpenCL™.\n\nRadeon™ Memory Visualizer (RMV) is a tool provided by AMD for use by game engine developers. It allows engineers to examine, diagnose, and understand the GPU memory management within their projects.\n\nFNA is an XNA4 reimplementation that focuses solely on developing a fully accurate XNA4 runtime for the desktop.\n\nFAudio is an XAudio reimplementation that focuses solely on developing fully accurate DirectX Audio runtime libraries for the FNA project, including XAudio2, X3DAudio, XAPO, and XACT3.\n\nSimple DirectMedia Layer is a cross-platform development library designed to provide low level access to audio, keyboard, mouse, joystick, and graphics hardware via OpenGL and Direct3D. It is used by video playback software, emulators, and popular games including Valve's award winning catalog.\n\nDXVK is a Vulkan-based translation layer for Direct3D 9/10/11 which allows running 3D applications on Linux using Wine.\n\nVKD3D-Proton is a fork of VKD3D, which aims to implement the full Direct3D 12 API on top of Vulkan.\n\nRenderDoc is a stand-alone graphics debugger that allows quick and easy single-frame capture and detailed introspection of any application using Vulkan, D3D11, OpenGL & OpenGL ES or D3D12 across Windows, Linux, Android, Stadia, or Nintendo Switch™.\n\nComputer Vision is a field of Artificial Intelligence (AI) that focuses on enabling computers to identify and understand objects and people in images and videos.\n\nOpenCV is a highly optimized library with focus on real-time computer vision applications. The C++, Python, and Java interfaces support Linux, MacOS, Windows, iOS, and Android.\n\nMicrosoft Cognitive Toolkit (CNTK) is an open-source toolkit for commercial-grade distributed deep learning. It describes neural networks as a series of computational steps via a directed graph. CNTK allows the user to easily realize and combine popular model types such as feed-forward DNNs, convolutional neural networks (CNNs) and recurrent neural networks (RNNs/LSTMs). CNTK implements stochastic gradient descent (SGD, error backpropagation) learning with automatic differentiation and parallelization across multiple GPUs and servers.\n\nScikit-Learn is a Python module for machine learning built on top of SciPy, NumPy, and matplotlib, making it easier to apply robust and simple implementations of many popular machine learning algorithms.\n\nNVIDIA cuDNN is a GPU-accelerated library of primitives for deep neural networks. cuDNN provides highly tuned implementations for standard routines such as forward and backward convolution, pooling, normalization, and activation layers. cuDNN accelerates widely used deep learning frameworks, including Caffe2, Chainer, Keras, MATLAB, MxNet, PyTorch, and TensorFlow.\n\nAutomated Driving Toolbox™ is a MATLAB tool that provides algorithms and tools for designing, simulating, and testing ADAS and autonomous driving systems. You can design and test vision and lidar perception systems, as well as sensor fusion, path planning, and vehicle controllers. Visualization tools include a bird’s-eye-view plot and scope for sensor coverage, detections and tracks, and displays for video, lidar, and maps. The toolbox lets you import and work with HERE HD Live Map data and OpenDRIVE® road networks. It also provides reference application examples for common ADAS and automated driving features, including FCW, AEB, ACC, LKA, and parking valet. The toolbox supports C/C++ code generation for rapid prototyping and HIL testing, with support for sensor fusion, tracking, path planning, and vehicle controller algorithms.\n\nLRSLibrary is a Low-Rank and Sparse Tools for Background Modeling and Subtraction in Videos. The library was designed for moving object detection in videos, but it can be also used for other computer vision and machine learning problems.\n\nImage Processing Toolbox™ is a tool that provides a comprehensive set of reference-standard algorithms and workflow apps for image processing, analysis, visualization, and algorithm development. You can perform image segmentation, image enhancement, noise reduction, geometric transformations, image registration, and 3D image processing.\n\nComputer Vision Toolbox™ is a tool that provides algorithms, functions, and apps for designing and testing computer vision, 3D vision, and video processing systems. You can perform object detection and tracking, as well as feature detection, extraction, and matching. You can automate calibration workflows for single, stereo, and fisheye cameras. For 3D vision, the toolbox supports visual and point cloud SLAM, stereo vision, structure from motion, and point cloud processing.\n\nStatistics and Machine Learning Toolbox™ is a tool that provides functions and apps to describe, analyze, and model data. You can use descriptive statistics, visualizations, and clustering for exploratory data analysis; fit probability distributions to data; generate random numbers for Monte Carlo simulations, and perform hypothesis tests. Regression and classification algorithms let you draw inferences from data and build predictive models either interactively, using the Classification and Regression Learner apps, or programmatically, using AutoML.\n\nLidar Toolbox™ is a tool that provides algorithms, functions, and apps for designing, analyzing, and testing lidar processing systems. You can perform object detection and tracking, semantic segmentation, shape fitting, lidar registration, and obstacle detection. Lidar Toolbox supports lidar-camera cross calibration for workflows that combine computer vision and lidar processing.\n\nMapping Toolbox™ is a tool that provides algorithms and functions for transforming geographic data and creating map displays. You can visualize your data in a geographic context, build map displays from more than 60 map projections, and transform data from a variety of sources into a consistent geographic coordinate system.\n\nUAV Toolbox is an application that provides tools and reference applications for designing, simulating, testing, and deploying unmanned aerial vehicle (UAV) and drone applications. You can design autonomous flight algorithms, UAV missions, and flight controllers. The Flight Log Analyzer app lets you interactively analyze 3D flight paths, telemetry information, and sensor readings from common flight log formats.\n\nParallel Computing Toolbox™ is a tool that lets you solve computationally and data-intensive problems using multicore processors, GPUs, and computer clusters. High-level constructs such as parallel for-loops, special array types, and parallelized numerical algorithms enable you to parallelize MATLAB® applications without CUDA or MPI programming. The toolbox lets you use parallel-enabled functions in MATLAB and other toolboxes. You can use the toolbox with Simulink® to run multiple simulations of a model in parallel. Programs and models can run in both interactive and batch modes.\n\nPartial Differential Equation Toolbox™ is a tool that provides functions for solving structural mechanics, heat transfer, and general partial differential equations (PDEs) using finite element analysis.\n\nROS Toolbox is a tool that provides an interface connecting MATLAB® and Simulink® with the Robot Operating System (ROS and ROS 2), enabling you to create a network of ROS nodes. The toolbox includes MATLAB functions and Simulink blocks to import, analyze, and play back ROS data recorded in rosbag files. You can also connect to a live ROS network to access ROS messages.\n\nRobotics Toolbox™ provides a toolbox that brings robotics specific functionality(designing, simulating, and testing manipulators, mobile robots, and humanoid robots) to MATLAB, exploiting the native capabilities of MATLAB (linear algebra, portability, graphics). The toolbox also supports mobile robots with functions for robot motion models (bicycle), path planning algorithms (bug, distance transform, D*, PRM), kinodynamic planning (lattice, RRT), localization (EKF, particle filter), map building (EKF) and simultaneous localization and mapping (EKF), and a Simulink model a of non-holonomic vehicle. The Toolbox also including a detailed Simulink model for a quadrotor flying robot.\n\nDeep Learning Toolbox™ is a tool that provides a framework for designing and implementing deep neural networks with algorithms, pretrained models, and apps. You can use convolutional neural networks (ConvNets, CNNs) and long short-term memory (LSTM) networks to perform classification and regression on image, time-series, and text data. You can build network architectures such as generative adversarial networks (GANs) and Siamese networks using automatic differentiation, custom training loops, and shared weights. With the Deep Network Designer app, you can design, analyze, and train networks graphically. It can exchange models with TensorFlow™ and PyTorch through the ONNX format and import models from TensorFlow-Keras and Caffe. The toolbox supports transfer learning with DarkNet-53, ResNet-50, NASNet, SqueezeNet and many other pretrained models.\n\nReinforcement Learning Toolbox™ is a tool that provides an app, functions, and a Simulink® block for training policies using reinforcement learning algorithms, including DQN, PPO, SAC, and DDPG. You can use these policies to implement controllers and decision-making algorithms for complex applications such as resource allocation, robotics, and autonomous systems.\n\nDeep Learning HDL Toolbox™ is a tool that provides functions and tools to prototype and implement deep learning networks on FPGAs and SoCs. It provides pre-built bitstreams for running a variety of deep learning networks on supported Xilinx® and Intel® FPGA and SoC devices. Profiling and estimation tools let you customize a deep learning network by exploring design, performance, and resource utilization tradeoffs.\n\nModel Predictive Control Toolbox™ is a tool that provides functions, an app, and Simulink® blocks for designing and simulating controllers using linear and nonlinear model predictive control (MPC). The toolbox lets you specify plant and disturbance models, horizons, constraints, and weights. By running closed-loop simulations, you can evaluate controller performance.\n\nVision HDL Toolbox™ is a tool that provides pixel-streaming algorithms for the design and implementation of vision systems on FPGAs and ASICs. It provides a design framework that supports a diverse set of interface types, frame sizes, and frame rates. The image processing, video, and computer vision algorithms in the toolbox use an architecture appropriate for HDL implementations.\n\nMicrosoft AirSim is a simulator for drones, cars and more, built on Unreal Engine (with an experimental Unity release). AirSim is open-source, cross platform, and supports software-in-the-loop simulation with popular flight controllers such as PX4 & ArduPilot and hardware-in-loop with PX4 for physically and visually realistic simulations. It is developed as an Unreal plugin that can simply be dropped into any Unreal environment. AirSim is being developed as a platform for AI research to experiment with deep learning, computer vision and reinforcement learning algorithms for autonomous vehicles.\n\nPhotogrammetry is the art and science of extracting 3D information from photographs. The process involves taking overlapping photographs of an object, structure, or space, and converting them into 2D or 3D digital models. Photogrammetry is often used by surveyors, architects, engineers, and contractors to create topographic maps, meshes, point clouds, or drawings based on the real-world.\n\nAerial photogrammetry is process of utilizing aircrafts to produce aerial photography that can be turned into a 3D model or mapped digitally. Now, it is possible to do the same work with a drone.\n\nTerrestrial(Close-range) photogrammetry is when images are captured using a handheld camera or with a camera mounted to a tripod. The output of this method is not to create topographic maps, but rather to make 3D models of a smaller object.\n\nAutodesk® ReCap™ is a software tool that converts reality captured from laser scans or photos into a 3D model or 2D drawing that's ready to be used in your design built for UAV and drone processes.\n\nAutodesk® ReCap™ Photo is a cloud-connected solution tailored for drone/UAV photo capturing workflows. Using ReCap Photo, you can create textured meshes, point clouds with geolocation, and high-resolution orthographic views with elevation maps.\n\nPix4D is a unique suite of photogrammetry software for drone mapping. Capture images with our app, process on desktop or cloud and create maps and 3D models.\n\nPIX4Dmapper is the leading photogrammetry software for professional drone mapping.\n\nRealityCapture is a state-of-the-art photogrammetry software solution that creates virtual reality scenes, textured 3D meshes, orthographic projections, geo-referenced maps and much more from images and/or laser scans completely automatically.\n\nAdobe Scantastic is a tool that makes the creation of 3D assets accessible to everyone. It can be used with just a mobile device (combined with Adobe's server-based photogrammetry pipeline), users can easily scan objects in their physical environment and turn them into 3D models which can then be imported into tools like Adobe Dimension and Adobe Aero.\n\nAdobe Aero is a tool that helps you build, view, and share immersive AR experiences. Simply build a scene by bringing in 2D images from Adobe Photoshop and Illustrator, or 3D models from Adobe Dimension, Substance, third-party apps like Cinema 4D, or asset libraries like Adobe Stock and TurboSquid. Aero optimizes a wide array of assets, including OBJ, GLB, and glTF files, for AR, so you can visualize them in real time.\n\nAgisoft Metashape is a stand-alone software product that performs photogrammetric processing of digital images and generates 3D spatial data to be used in GIS applications, cultural heritage documentation, and visual effects production as well as for indirect measurements of objects of various scales.\n\nMicroStation is a CAD software platform for 2D and 3D dimensional design and drafting, developed and sold by Bentley Systems. It generates 2D/3D vector graphics objects and elements and includes building information modeling (BIM) features.\n\nLeica Photogrammetry Suite (LPS) is a powerful photogrammetry system that delivers full analytical triangulation, the generation of digital terrain models, orthophoto production, mosaicking, and 3D feature extraction in a user-friendly environment that guarantees results even for photogrammetry novices.\n\nTerramodel is a powerful software package for the surveyor, civil engineer or contractor who requires a CAD and design package with integrated support for raw survey data.\n\nMicMac is a free and open-source photogrammetry software tools for 3D reconstruction.\n\n3DF Zephyr is a photogrammetry software solution by 3Dflow. It allows you automatically reconstruct 3D models from photos and deal with any 3D reconstruction and scanning challenge. No matter what camera sensor, drone or laser scanner device you are going to use.\n\nCOLMAP is a general-purpose Structure-from-Motion (SfM) and Multi-View Stereo (MVS) pipeline with a graphical and command-line interface. It offers a wide range of features for reconstruction of ordered and unordered image collections.\n\nMulti-View Environment (MVE) is an effort to ease the work with multi-view datasets and to support the development of algorithms based on multiple views. It features Structure from Motion, Multi-View Stereo and Surface Reconstruction. MVE is developed at the TU Darmstadt.\n\nAliceVision is a Photogrammetric Computer Vision Framework which provides 3D Reconstruction and Camera Tracking algorithms. AliceVision comes up with strong software basis and state-of-the-art computer vision algorithms that can be tested, analyzed and reused.\n\nMeshroom is a free, open-source 3D Reconstruction Software based on the AliceVision framework.\n\nPhotoModeler is a software extracts Measurements and Models from photographs taken with an ordinary camera. A cost-effective way for accurate 2D or 3D measurement, photo-digitizing, surveying, 3D scanning, and reality capture.\n\nODM is an open source command line toolkit to generate maps, point clouds, 3D models and DEMs from drone, balloon or kite images.\n\nWebODM is a user-friendly, commercial grade software for drone image processing. Generate georeferenced maps, point clouds, elevation models and textured 3D models from aerial images. It supports multiple engines for processing, currently ODM and MicMac.\n\nNodeODM is a standard API specification for processing aerial images with engines such as ODM. The API is used by clients such as WebODM, CloudODM and PyODM.\n\nClusterODM is a reverse proxy, load balancer and task tracker with optional cloud autoscaling capabilities for NodeODM API compatible nodes. In a nutshell, it's a program to link together multiple NodeODM API compatible nodes under a single network address.\n\nFIELDimageR is an R package to analyze orthomosaic images from agricultural field trials.\n\nRegard3D is a free and open source structure-from-motion program. It converts photos of an object, taken from different angles, into a 3D model of this object.\n\nPhotoCatch is the first app for Apple's Object Capture API, enabling anyone to create stunning 3D models in minutes, not days, with no code or 3D experience required.\n\nPhotoCatch Desktop is a Professional photogrammetry workstation for exporting beautiful 3D assets ready for Augmented Reality and Visual Effects. It provides performance optimizations for M1 Max and M1 Ultra on MacBook Pro and Mac Studio, so you can process up to 4 3D models at the same time.\n\nPhotoCatch Cloud is a professional service that brings desktop class photogrammetry and 3D editing tools to mobile devices, so you can capture, edit, and share 3D content on-site. It Syncs photo capture with your equipment and use Depth Capture so your 3D models stay the same size as the real world objects.\n\nMartin is a tile server able to generate vector tiles from large PostGIS databases on the fly, or serve tiles from PMTile and MBTile files. Martin optimizes for speed and heavy traffic, and is written in Rust.\n\nAutodesk is a global leader in design and make technology, with expertise across architecture, engineering, construction, design, manufacturing, and entertainment.\n\nCNC programming (Computer Numerical Control Programming) is utilized by manufacturers to create program instructions for computers to control a machine tool. CNC is highly involved in the manufacturing process and improves automation as well as flexibility.\n\nAutoCAD® is computer-aided design (CAD) software that architects, engineers, and construction professionals rely on to create precise 2D and 3D drawings. It also automates tasks such as comparing drawings, counting, adding blocks, creating schedules.\n\nAutoCAD LT® is a powerful 2D computer-aided design (CAD) software that architects, engineers, construction professionals, and designers rely on to design, draft, and document with precise 2D geometry.\n\nAutoCAD® Mobile App is a mobile(smartphone or tablet) version of AutoCAD that has the core design and drafting tools. Work on your CAD drawings anytime, anywhere—even offline.\n\nAutoCAD® Web App is a web version of AutoCAD that can edit, create, share, and view CAD drawings in a web browser on any computer.\n\nTinkercad® is a free, easy-to-use app for 3D design, electronics, and coding. It's used by teachers, kids, hobbyists, and designers to imagine, design, and make anything.\n\nRevit® is a BIM (Building Information Modeling) software to drive efficiency and accuracy across the project lifecycle, from conceptual design, visualization, and analysis to fabrication and construction.\n\nAEC(Architecture, Engineering & Construction) Collection® is a set of BIM and CAD tools for designers, engineers, and contractors that is supported by a cloud-based common data environment that facilitates project delivery from early-stage design through to construction.\n\nFusion 360® is an integrated CAD, CAM, CAE, and PCB software application. It unifies design, engineering, electronics, and manufacturing into a single software platform.\n\nFusion 360 with FeatureCAM® is a tool that gives you access to FeatureCAM Ultimate, PartMaker, Fusion 360, Fusion Team, and HSMWorks. With FeatureCAM CNC programming software uses manufacturing knowledge to intelligently make decisions, produce results, and remove repetitive processes.\n\nFusion 360 with Netfabb® is a software that offers a complete toolset for design and implementation for additive manufacturing. It streamlines workflows and automates processes around 3D print preparation. The software also includes access to Fusion 360, Fusion 360 Team, and additional capabilities through Fusion 360 Additive Extensions.\n\nFusion 360 Manage is a product lifecycle management platform that connects your people, processes, and data across departments and geographies. It gives you the flexibility to start today and expand tomorrow with PLM that adapts to your business.\n\nFusion Team is a cloud-based coll tool that helps eliminate the inefficiencies that disparate tools create when working with your internal and external teams.\n\nFusion 360 with PowerInspect® is a 3D measurement software offers a powerful way to inspect, validate, and manage quality for all measurement equipment. Now includes access to Fusion 360, Fusion 360 Team, and Fusion 360 – Machining Extension. PowerInspect includes comprehensive inspection tools that measure parts while they’re still in On Machine Verification (OMV). Machine tool probing helps you make informed scrap or rework decisions quickly.\n\nFusion 360 with PowerMill® CAM is a software provides expert CNC programming strategies for complex 3 and 5-axis manufacturing. This includes access to Fusion 360 and advanced manufacturing capabilities through Fusion 360 extensions.\n\nFusion 360 with PowerShape® is a manufacturing CAD software combines surface, solid, and mesh modeling to help prepare molds, dies, and other complex parts for manufacture. This includes access to Fusion 360 and Fusion 360 Team.\n\nAutodesk PartMaker® is a software that can produce CNC programs that drive main and sub-spindle machining operations. These can be used for turning, indexed and interpolated C-axis milling, Y-axis, and B-axis milling.\n\nRobot Structural Analysis Professional is a structural load analysis software that verifies code compliance and uses BIM-integrated workflows to exchange data with Revit. It can help you to create more resilient, constructible designs that are accurate, coordinated, and connected to BIM.\n\nRevit LT™ is a software that provides the most cost-effective BIM (Building Information Modeling) solution, you can produce high-quality 3D architectural designs and documentation.\n\nMaya® is a 3D computer animation, modeling, simulation, and rendering software that can create realistic effects from explosions to cloth simulation.\n\nMaya LT™ is a game design software for indie game makers that can create and animate realistic-looking characters, props, and environments using the sophisticated 3D modeling and animation tools.\n\n3DS Max® is a 3D modeling and rendering software for design visualization, games, and animation.\n\nArnold is an advanced Monte Carlo ray tracing(Global illumination) renderer that helps you work more efficiently.\n\nReCap™ is a Pro 3D scanning software to transform the physical world into a digital asset. With reality capture data you can better understand and verify existing and as-built conditions to gain insights and make better decisions.\n\nFlame® is a 3D VFX and finishing software provides powerful tools for 3D compositing, visual effects, and editorial finishing. An integrated, creative environment means faster compositing, advanced graphics, color correction, and more.\n\nMudbox® is a 3D digital painting and sculpting software that let's you sculpt and paint highly detailed 3D geometry and textures.\n\nCharacter Generator® is a powerful 3D design and animation tools, Character Generator offers artists a web-based laboratory to create fully rigged 3D characters for animation packages and game engines.\n\nSmoke® is a video effects software helps production studios increase productivity by combining editing workflows with node-based compositing tools in a timeline-centered editing environment.\n\nShotGrid formerly Shotgun Software, is software for creative project management software and review tools for film, TV, and games that streamlines workflows for creative studios.\n\nAdvance Steel® is a 3D modeling software for steel detailing, design, fabrication, and construction. it connects engineers and detailers through a seamless design and detailing workflow between Advance Steel and Revit, you can reduce the time required to move from design to fabrication while simultaneously reducing errors along the way.\n\nMedia & Entertainment Collection® is a collection that includes all of the tools you need to build a powerful and scalable 3D animation pipeline for complex simulations, effects, and rendering.\n\nCivil 3D® is a civil engineering design software supports BIM (Building Information Modeling) with integrated features to improve drafting, design, and construction documentation.\n\nInventor® is a CAD software that provides professional-grade 3D mechanical design, documentation, and product simulation tools. Work efficiently with a powerful blend of parametric, direct, freeform, and rules-based design capabilities.\n\nInventor® CAM is an integrated CAM software for Inventor that simplifies CNC programming processes. Such as the machining workflow with CAD-embedded 2.5-axis to 5-axis milling, turning, and mill-turn capabilities.\n\nInventor Nastran® is a CAD-embedded finite element analysis software that delivers finite element analysis (FEA) tools for engineers and analysts. Simulation covers multiple analysis types, such as linear and nonlinear stress, dynamics, and heat transfer.\n\nInventor® Nesting is a CAD-embedded, true-shape nesting tools for Inventor that helps you optimize yield from flat raw material. Easily compare nesting studies to optimize efficiency and reduce costs, and export 3D models or DXF™ files of the completed nest for cutting path generation.\n\nInventor Tolerance Analysis® is an CAD-embedded tolerance stackup analysis software that is designed to help Inventor users make more informed decisions while specifying manufacturing tolerances.\n\nProduct Design & Manufacturing Collection is an integrated set of professional-grade applications that connect everyone, from concept to production, with shared tools to streamline your product development process.\n\nNavisworks® is a project review software to improve BIM (Building Information Modeling) coordination. That can combine design and construction data into a single model.\n\nBIM Collaborate is cloud-based design collaboration and coordination software that connects AEC teams, helping you execute on design intent and deliver high-quality constructible models on a single platform.\n\nBIM Collaborate Pro is cloud-based design collaboration and coordination software that connects AEC teams, helping you execute on design intent and deliver high-quality constructible models on a single platform.\n\nInfraWorks® is a conceptual design software lets architecture, engineering, and construction professionals model, analyze, and visualize infrastructure design concepts within the context of the built and natural environment—improving decision making and accelerating project approvals.\n\nSketchBook® is a drawing and painting software lets designers, architects, and concept artists sketch ideas quickly and create stunning illustrations.\n\nAlias® is a product design software for sketching, concept modeling, surfacing, visualization. It can create and reuse templates across design and surfacing teams sharing surfacing language.\n\nAssemble BIM Data is a tool that helps keep projects on track. Along with condition and connect BIM data to design reviews, estimating, change management, scheduling, work-in-place tracking, and more.\n\nAutodesk® Forge is a cloud-based developer platform from Autodesk. That let's you access design and engineering data in the cloud with the Forge platform. Whether you want to automate processes, connect teams and workflows, or visualize your data using Forge APIs.\n\nAutodesk® Rendering is a fast, high-resolution cloud rendering software that let's you produce stunning, high-quality renderings from designs and models with cloud rendering. This service uses cloud credits, which is a universal measure across Autodesk consumption-based cloud services to perform certain tasks in the cloud.\n\nAutodesk® CFD is a computational fluid dynamics simulation software that engineers and analysts use to intelligently predict how liquids and gases will perform. It helps to minimize the need for physical prototypes while providing deeper insight into fluid flow design performance.\n\nAutodesk® Drive is a way to securely store, preview, and share your 2D and 3D design data.\n\nAutodesk® Viewer is a tool that supports most 2D and 3D files, including DWG, STEP, DWF, RVT, and Solidworks, and works with over 80 file types on any device. Get the feedback you need with Autodesk Viewer’s annotation and drawing tools for easy online collaboration.\n\nAutodesk BIM 360® is a tool is part of the Autodesk Construction Cloud, connecting workflows, teams, and data to help you build better.\n\nAutodesk® Build is a construction management software for field execution and project management that empowers you to seamlessly collaborate and deliver construction projects on time, on budget.\n\nAutodesk® Takeoff is a tool that helps you work with competitive bids that are generated from accurate estimates produced from integrated 2D takeoffs and 3D quantities.\n\nBuildingConnected is the argest real-time construction network that connects owners and builders through an easy-to-use platform to streamline the bid and risk management process.\n\nBid Board Pro is a tool that helps you see all bid invites across your entire office or division from one place. Know what needs to get done, who’s responsible for it and when it’s due. Track project files, deadlines and more during each stage of the bidding process.\n\nTradeTapp is a tool that helps you significantly decrease the time it takes to analyze subcontractor risk, annually or for a specific project. Advanced risk profiles enable a streamlined process and offer financial benchmarking, key metric calculations, capacity recommendations and safety performance history.\n\nDesign Review is a CAD viewer software lets you view, mark up, print, and track changes to 2D and 3D files for free—without the original design software. Work with a variety of file formats, including: DWF, DWFx, DWG, and DXF (requires installation of free DWG TrueView software); Adobe PDF; as well as image file types such as.bmp, .jpg, .gif, .pcx, .pct, .png, .rlc, .tga, .tif, .mil, .cal, and more.\n\nEAGLE is electronic design automation (EDA) software that lets printed circuit board (PCB) designers seamlessly connect schematic diagrams, component placement, PCB routing, and comprehensive library content.\n\nFabrication ESTmep™, CADmep™, and CAMduct™ is a software that provides an integrated set of tools for MEP specialty contractors to estimate, detail, and drive fabrication of mechanical building systems. Also, create high LOD models of piping, plumbing, or ductwork systems in AutoCAD using CADmep. Content libraries used in ESTmep, CADmep, and CAMduct can also be used in Revit to support BIM workflows. Available stand-alone or in the Architecture, Engineering & Construction Collection..\n\nFormit is an architectural modeling software for BIM-based 3D sketching. The pro version of FormIt includes the tools in the FormIt app, plus Dynamo computation, and collaboration and analysis features.\n\nHelius Composite is a tool that can help you simulate the material behavior of compound components. Built-in solvers minimize the need to have secondary finite element analysis (FEA) software to analyze material characteristics more quickly.\n\nHelius PFA is a progressive failure analysis software that predicts failure stages of composite materials. Helius PFA enables you to integrate composite and elastomeric material properties into your finite element analysis (FEA) program.\n\nHSMWorks is an ambedded CAM software for SOLIDWORKS® to design and generate CAM toolpaths without the hassle of changing software. Reduce cycle time and rework with CAD-embedded 2.5 to 5-axis milling, turning, and mill-turn capabilities. HSMWorks is included with your Fusion 360 subscription.\n\nInsight is a building performance analysis software that empowers architects and engineers to design more energy-efficient buildings with advanced simulation engines and building performance analysis data integrated in Revit.\n\nMoldflow® is a software tool that lets you troubleshoot problems with plastic injection and compression molding for design and manufacturing. Advanced tools and a simplified user interface help you address manufacturing challenges, such as part warpage, cooling channel efficiency, and cycle time reduction.\n\nMotionBuilder® is a 3D character animation software. Work in an interactive environment optimized to help you work faster and more efficiently without compromising creativity.\n\nPlanGrid Build is a Construction app built for the field. It allows you to complete tasks from anywhere on the jobsite with seamless access to Autodesk Build data, even when you’re offline.\n\nPoint Layout is a construction layout software helps contractors and subcontractors bring model accuracy to the field and back. Connect models to layout and quality workflows. Get direct file format compatibility with robotic total station hardware, including Leica, Topcon, and Trimble.\n\nStructural Bridge Design® is a bridge analysis software for small to medium-span bridges used by engineers to deliver design reports faster.\n\nVault® is a product data management (PDM) software helps streamline workflows. Everyone works from a central source of organized data—collaborating, reducing errors, and saving time.\n\nVehicle Tracking® is a swept path analysis and design software to facilitate parking lot layout, roundabout design, and other design challenges impacted by vehicle movement.\n\nVRED® is a 3D visualization software helps automotive designers and engineers create product presentations, design reviews, and virtual prototypes using interactive GPU raytracing and both analytic and cloud-rendering modes.\n\nWithin Medical® is a 3D printing orthopedic implant design software that enables designers to create medical implants to aid osseointegration.\n\nPype is a tool that helps you reduce project risk and strengthen client relationships by automating processes that are critical for owner satisfaction and contract compliance.\n\nPype Closeout is a tool provides a single portal for closeout documentation management, with digital document collection from subcontractors and powerful reporting dashboards. With subcontractor outreach automated, the Closeout platform ensures contract compliance and helps you get paid faster.\n\nPype SmartPlans is a tool that locates and extracts all submittals from your uploaded plans automatically. Export product, equipment, and finish schedules into excel with a single click. SmartPlans’ powerful automation uses cutting edge artificial intelligence and machine learning to intelligently read your drawings to extract submittals and schedules.\n\nCAMplete is a software tool that provides G-code post-processing, verification, and simulation for different kinds of CNC machinery. Import data from leading CAM software then use proven post-processors and highly accurate 3D machine models, developed in partnership with machine tool builders, to rapidly produce high-quality, collision free NC machining code.\n\nVault PLM is a tool that combines Vault Professional with Fusion Lifecycle for enterprise-wide collaboration and product lifecycle management.\n\nLight Detection and Ranging Sensors Course on Coursera\n\nLight Detection and Ranging (lidar) is a technology used to create high-resolution models of ground elevation with a vertical accuracy of 10 centimeters (4 inches). Lidar equipment, which includes a laser scanner, a Global Positioning System (GPS), and an Inertial Navigation System (INS), is typically mounted on a small aircraft. The laser scanner transmits brief pulses of light to the ground surface. Those pulses are reflected or scattered back and their travel time is used to calculate the distance between the laser scanner and the ground. Lidar data is initially collected as a “point cloud” of individual points reflected from everything on the surface, including structures and vegetation. To produce a “bare earth” Digital Elevation Model (DEM), structures and vegetation are stripped away.\n\nMola is a Modular Optimization framework for Localization and mApping (MOLA).\n\nLidar Toolbox™ is a MATLAB tool that provides algorithms, functions, and apps for designing, analyzing, and testing lidar processing systems. You can perform object detection and tracking, semantic segmentation, shape fitting, lidar registration, and obstacle detection. Lidar Toolbox supports lidar-camera cross calibration for workflows that combine computer vision and lidar processing.\n\nAutomated Driving Toolbox™ is a MATLAB tool that provides algorithms and tools for designing, simulating, and testing ADAS and autonomous driving systems. You can design and test vision and lidar perception systems, as well as sensor fusion, path planning, and vehicle controllers. Visualization tools include a bird’s-eye-view plot and scope for sensor coverage, detections and tracks, and displays for video, lidar, and maps. The toolbox lets you import and work with HERE HD Live Map data and OpenDRIVE® road networks. It also provides reference application examples for common ADAS and automated driving features, including FCW, AEB, ACC, LKA, and parking valet. The toolbox supports C/C++ code generation for rapid prototyping and HIL testing, with support for sensor fusion, tracking, path planning, and vehicle controller algorithms.\n\nMicrosoft AirSim is a simulator for drones, cars and more, built on Unreal Engine (with an experimental Unity release). AirSim is open-source, cross platform, and supports software-in-the-loop simulation with popular flight controllers such as PX4 & ArduPilot and hardware-in-loop with PX4 for physically and visually realistic simulations. It is developed as an Unreal plugin that can simply be dropped into any Unreal environment. AirSim is being developed as a platform for AI research to experiment with deep learning, computer vision and reinforcement learning algorithms for autonomous vehicles.\n\nLASer(LAS) is a public file format for the interchange of 3-dimensional point cloud data data between data users. Although developed primarily for exchange of lidar point cloud data, this format supports the exchange of any 3-dimensional x,y,z tuplet. This binary file format is an alternative to proprietary systems or a generic ASCII file interchange system used by many companies. The problem with proprietary systems is obvious in that data cannot be easily taken from one system to another. There are two major problems with the ASCII file interchange. The first problem is performance because the reading and interpretation of ASCII elevation data can be very slow and the file size can be extremely large even for small amounts of data. The second problem is that all information specific to the lidar data is lost. The LAS file format is a binary file format that maintains information specific to the lidar nature of the data while not being overly complex.\n\n3D point cloud is a set of data points defined in a given three-dimensional coordinates system.. Point clouds can be produced directly by 3D scanner which records a large number of points returned from the external surfaces of objects or earth surface. These data are exchanged between LiDAR users mainly through LAS format files (.las).\n\nArcGIS Desktop is powerful and cost-effective desktop geographic information system (GIS) software. It is the essential software package for GIS professionals. ArcGIS Desktop users can create, analyze, manage, and share geographic information so decision-makers can make intelligent, informed decisions.\n\nUSGS 3DEP Lidar Point Cloud Now Available as Amazon Public Dataset\n\nLinear algebra is the math of vectors and matrices. The only prerequisite for this guide is a basic understanding of high school math concepts like numbers, variables, equations, and the fundamental arithmetic operations on real numbers: addition (denoted +), subtraction (denoted −), multiplication (denoted implicitly), and division (fractions). Also, you should also be familiar with functions that take real numbers as inputs and give real numbers as outputs, f : R → R.\n\nLearn Linear Algebra with Online Courses and Classes on edX\n\nThe Math of Data Science: Linear Algebra Course on edX\n\nWe now define the math operations for vectors. The operations we can perform on vectors ~u = (u1, u2, u3) and ~v = (v1, v2, v3) are: addition, subtraction, scaling, norm (length), dot product, and cross product:\n\nThe dot product and the cross product of two vectors can also be described in terms of the angle θ between the two vectors.\n\nWe denote by A the matrix as a whole and refer to its entries as aij .The mathematical operations defined for matrices are the following:\n• determinant (denoted det(A) or |A|) Note that the matrix product is not a commutative operation.\n\nCheck for modules that allow Matrix Operations. Source: DPS Concepts\n\nThe matrix-vector product is an important special case of the matrix product.\n\nThere are two fundamentally different yet equivalent ways to interpret the matrix-vector product. In the column picture, (C), the multiplication of the matrix A by the vector ~x produces a linear combination of the columns of the matrix: x = x1A[:,1] + x2A[:,2], where A[:,1] and A[:,2] are the first and second columns of the matrix A. In the row picture, (R), multiplication of the matrix A by the vector ~x produces a column vector with coefficients equal to the dot products of rows of the matrix with the vector ~x.\n\nThe matrix-vector product is used to define the notion of a linear transformation, which is one of the key notions in the study of linear algebra. Multiplication by a matrix A ∈ R m×n can be thought of as computing a linear transformation TA that takes n-vectors as inputs and produces m-vectors as outputs:\n\nIn this section we’ll look at several different approaches for computing the inverse of a matrix. The matrix inverse is unique so no matter which method we use to find the inverse, we’ll always obtain the same answer.\n\nOne approach for computing the inverse is to use the Gauss–Jordan elimination procedure.\n\nEvery row operation we perform on a matrix is equivalent to a leftmultiplication by an elementary matrix.\n\nFinding the inverse of a matrix is to use the Transpose method.\n\nIn this section discuss a number of other important topics of linear algebra.\n\nIntuitively, a basis is any set of vectors that can be used as a coordinate system for a vector space. You are certainly familiar with the standard basis for the xy-plane that is made up of two orthogonal axes: the x-axis and the y-axis.\n\nThe dimension of a vector space is defined as the number of vectors in a basis for that vector space. Consider the following vector space S = span{(1, 0, 0),(0, 1, 0),(1, 1, 0)}. Seeing that the space is described by three vectors, we might think that S is 3-dimensional. This is not the case, however, since the three vectors are not linearly independent so they don’t form a basis for S. Two vectors are sufficient to describe any vector in S; we can write S = span{(1, 0, 0),(0, 1, 0)}, and we see these two vectors are linearly independent so they form a basis and dim(S) = 2. There is a general procedure for finding a basis for a vector space. Suppose you are given a description of a vector space in terms of m vectors V = span{~v1, ~v2, . . . , ~vm} and you are asked to find a basis for V and the dimension of V. To find a basis for V, you must find a set of linearly independent vectors that span V. We can use the Gauss–Jordan elimination procedure to accomplish this task. Write the vectors ~vi as the rows of a matrix M. The vector space V corresponds to the row space of the matrix M. Next, use row operations to find the reduced row echelon form (RREF) of the matrix M. Since row operations do not change the row space of the matrix, the row space of reduced row echelon form of the matrix M is the same as the row space of the original set of vectors. The nonzero rows in the RREF of the matrix form a basis for vector space V and the numbers of nonzero rows is the dimension of V.\n\nRecall the fundamental vector spaces for matrices that we defined in Section II-E: the column space C(A), the null space N (A), and the row space R(A). A standard linear algebra exam question is to give you a certain matrix A and ask you to find the dimension and a basis for each of its fundamental spaces. In the previous section we described a procedure based on Gauss–Jordan elimination which can be used “distill” a set of linearly independent vectors which form a basis for the row space R(A). We will now illustrate this procedure with an example, and also show how to use the RREF of the matrix A to find bases for C(A) and N (A).\n\nThere is an important distinction between matrices that are invertible and those that are not as formalized by the following theorem. Theorem. For an n×n matrix A, the following statements are equivalent:\n\nThe determinant of a matrix, denoted det(A) or |A|, is a special way to combine the entries of a matrix that serves to check if a matrix is invertible or not.\n\nThe set of eigenvectors of a matrix is a special set of input vectors for which the action of the matrix is described as a simple scaling. When a matrix is multiplied by one of its eigenvectors the output is the same eigenvector multiplied by a constant A eλ. The constant λ is called an eigenvalue of A.\n\nLinear regression is an approach to model the relationship between two variables by fitting a linear equation to observed data. One variable is considered to be an explanatory variable, and the other is considered to be a dependent variable.\n\nFuzzy logic is a heuristic approach that allows for more advanced decision-tree processing and better integration with rules-based programming.\n\nSupport Vector Machine (SVM) is a supervised machine learning model that uses classification algorithms for two-group classification problems.\n\nNeural networks are a subset of machine learning and are at the heart of deep learning algorithms. The name/structure is inspired by the human brain copying the process that biological neurons/nodes signal to one another.\n\nConvolutional Neural Networks (R-CNN) is an object detection algorithm that first segments the image to find potential relevant bounding boxes and then run the detection algorithm to find most probable objects in those bounding boxes.\n\nRecurrent neural networks (RNNs) is a type of artificial neural network which uses sequential data or time series data.\n\nMultilayer Perceptrons (MLPs) is multi-layer neural networks composed of multiple layers of perceptrons with a threshold activation.\n\nRandom forest is a commonly-used machine learning algorithm, which combines the output of multiple decision trees to reach a single result. A decision tree in a forest cannot be pruned for sampling and therefore, prediction selection. Its ease of use and flexibility have fueled its adoption, as it handles both classification and regression problems.\n\nDecision trees are tree-structured models for classification and regression.\n\nNaive Bayes is a machine learning algorithm that is used solved calssification problems. It's based on applying Bayes' theorem with strong independence assumptions between the features.\n\nMachine Learning is a branch of artificial intelligence (AI) focused on building apps using algorithms that learn from data models and improve their accuracy over time without needing to be programmed.\n\nHow to run Jupyter Notebooks in your Azure Machine Learning workspace\n\nLearn Machine Learning with Online Courses and Classes from edX\n\nTensorFlow is an end-to-end open source platform for machine learning. It has a comprehensive, flexible ecosystem of tools, libraries and community resources that lets researchers push the state-of-the-art in ML and developers easily build and deploy ML powered applications.\n\nKeras is a high-level neural networks API, written in Python and capable of running on top of TensorFlow, CNTK, or Theano.It was developed with a focus on enabling fast experimentation. It is capable of running on top of TensorFlow, Microsoft Cognitive Toolkit, R, Theano, or PlaidML.\n\nPyTorch is a library for deep learning on irregular input data such as graphs, point clouds, and manifolds. Primarily developed by Facebook's AI Research lab.\n\nAmazon SageMaker is a fully managed service that provides every developer and data scientist with the ability to build, train, and deploy machine learning (ML) models quickly. SageMaker removes the heavy lifting from each step of the machine learning process to make it easier to develop high quality models.\n\nAzure Databricks is a fast and collaborative Apache Spark-based big data analytics service designed for data science and data engineering. Azure Databricks, sets up your Apache Spark environment in minutes, autoscale, and collaborate on shared projects in an interactive workspace. Azure Databricks supports Python, Scala, R, Java, and SQL, as well as data science frameworks and libraries including TensorFlow, PyTorch, and scikit-learn.\n\nMicrosoft Cognitive Toolkit (CNTK) is an open-source toolkit for commercial-grade distributed deep learning. It describes neural networks as a series of computational steps via a directed graph. CNTK allows the user to easily realize and combine popular model types such as feed-forward DNNs, convolutional neural networks (CNNs) and recurrent neural networks (RNNs/LSTMs). CNTK implements stochastic gradient descent (SGD, error backpropagation) learning with automatic differentiation and parallelization across multiple GPUs and servers.\n\nApple CoreML is a framework that helps integrate machine learning models into your app. Core ML provides a unified representation for all models. Your app uses Core ML APIs and user data to make predictions, and to train or fine-tune models, all on the user's device. A model is the result of applying a machine learning algorithm to a set of training data. You use a model to make predictions based on new input data.\n\nTensorflow_macOS is a Mac-optimized version of TensorFlow and TensorFlow Addons for macOS 11.0+ accelerated using Apple's ML Compute framework.\n\nApache OpenNLP is an open-source library for a machine learning based toolkit used in the processing of natural language text. It features an API for use cases like Named Entity Recognition, Sentence Detection, POS(Part-Of-Speech) tagging, Tokenization Feature extraction, Chunking, Parsing, and Coreference resolution.\n\nApache Airflow is an open-source workflow management platform created by the community to programmatically author, schedule and monitor workflows. Install. Principles. Scalable. Airflow has a modular architecture and uses a message queue to orchestrate an arbitrary number of workers. Airflow is ready to scale to infinity.\n\nOpen Neural Network Exchange(ONNX) is an open ecosystem that empowers AI developers to choose the right tools as their project evolves. ONNX provides an open source format for AI models, both deep learning and traditional ML. It defines an extensible computation graph model, as well as definitions of built-in operators and standard data types.\n\nApache MXNet is a deep learning framework designed for both efficiency and flexibility. It allows you to mix symbolic and imperative programming to maximize efficiency and productivity. At its core, MXNet contains a dynamic dependency scheduler that automatically parallelizes both symbolic and imperative operations on the fly. A graph optimization layer on top of that makes symbolic execution fast and memory efficient. MXNet is portable and lightweight, scaling effectively to multiple GPUs and multiple machines. Support for Python, R, Julia, Scala, Go, Javascript and more.\n\nAutoGluon is toolkit for Deep learning that automates machine learning tasks enabling you to easily achieve strong predictive performance in your applications. With just a few lines of code, you can train and deploy high-accuracy deep learning models on tabular, image, and text data.\n\nAnaconda is a very popular Data Science platform for machine learning and deep learning that enables users to develop models, train them, and deploy them.\n\nPlaidML is an advanced and portable tensor compiler for enabling deep learning on laptops, embedded devices, or other devices where the available computing hardware is not well supported or the available software stack contains unpalatable license restrictions.\n\nOpenCV is a highly optimized library with focus on real-time computer vision applications. The C++, Python, and Java interfaces support Linux, MacOS, Windows, iOS, and Android.\n\nScikit-Learn is a Python module for machine learning built on top of SciPy, NumPy, and matplotlib, making it easier to apply robust and simple implementations of many popular machine learning algorithms.\n\nWeka is an open source machine learning software that can be accessed through a graphical user interface, standard terminal applications, or a Java API. It is widely used for teaching, research, and industrial applications, contains a plethora of built-in tools for standard machine learning tasks, and additionally gives transparent access to well-known toolboxes such as scikit-learn, R, and Deeplearning4j.\n\nCaffe is a deep learning framework made with expression, speed, and modularity in mind. It is developed by Berkeley AI Research (BAIR)/The Berkeley Vision and Learning Center (BVLC) and community contributors.\n\nTheano is a Python library that allows you to define, optimize, and evaluate mathematical expressions involving multi-dimensional arrays efficiently including tight integration with NumPy.\n\nnGraph is an open source C++ library, compiler and runtime for Deep Learning. The nGraph Compiler aims to accelerate developing AI workloads using any deep learning framework and deploying to a variety of hardware targets.It provides the freedom, performance, and ease-of-use to AI developers.\n\nNVIDIA cuDNN is a GPU-accelerated library of primitives for deep neural networks. cuDNN provides highly tuned implementations for standard routines such as forward and backward convolution, pooling, normalization, and activation layers. cuDNN accelerates widely used deep learning frameworks, including Caffe2, Chainer, Keras, MATLAB, MxNet, PyTorch, and TensorFlow.\n\nJupyter Notebook is an open-source web application that allows you to create and share documents that contain live code, equations, visualizations and narrative text. Jupyter is used widely in industries that do data cleaning and transformation, numerical simulation, statistical modeling, data visualization, data science, and machine learning.\n\nApache Spark is a unified analytics engine for large-scale data processing. It provides high-level APIs in Scala, Java, Python, and R, and an optimized engine that supports general computation graphs for data analysis. It also supports a rich set of higher-level tools including Spark SQL for SQL and DataFrames, MLlib for machine learning, GraphX for graph processing, and Structured Streaming for stream processing.\n\nApache Spark Connector for SQL Server and Azure SQL is a high-performance connector that enables you to use transactional data in big data analytics and persists results for ad-hoc queries or reporting. The connector allows you to use any SQL database, on-premises or in the cloud, as an input data source or output data sink for Spark jobs.\n\nApache PredictionIO is an open source machine learning framework for developers, data scientists, and end users. It supports event collection, deployment of algorithms, evaluation, querying predictive results via REST APIs. It is based on scalable open source services like Hadoop, HBase (and other DBs), Elasticsearch, Spark and implements what is called a Lambda Architecture.\n\nCluster Manager for Apache Kafka(CMAK) is a tool for managing Apache Kafka clusters.\n\nBigDL is a distributed deep learning library for Apache Spark. With BigDL, users can write their deep learning applications as standard Spark programs, which can directly run on top of existing Spark or Hadoop clusters.\n\nEclipse Deeplearning4J (DL4J) is a set of projects intended to support all the needs of a JVM-based(Scala, Kotlin, Clojure, and Groovy) deep learning application. This means starting with the raw data, loading and preprocessing it from wherever and whatever format it is in to building and tuning a wide variety of simple and complex deep learning networks.\n\nTensorman is a utility for easy management of Tensorflow containers by developed by System76.Tensorman allows Tensorflow to operate in an isolated environment that is contained from the rest of the system. This virtual environment can operate independent of the base system, allowing you to use any version of Tensorflow on any version of a Linux distribution that supports the Docker runtime.\n\nNumba is an open source, NumPy-aware optimizing compiler for Python sponsored by Anaconda, Inc. It uses the LLVM compiler project to generate machine code from Python syntax. Numba can compile a large subset of numerically-focused Python, including many NumPy functions. Additionally, Numba has support for automatic parallelization of loops, generation of GPU-accelerated code, and creation of ufuncs and C callbacks.\n\nChainer is a Python-based deep learning framework aiming at flexibility. It provides automatic differentiation APIs based on the define-by-run approach (dynamic computational graphs) as well as object-oriented high-level APIs to build and train neural networks. It also supports CUDA/cuDNN using CuPy for high performance training and inference.\n\nXGBoost is an optimized distributed gradient boosting library designed to be highly efficient, flexible and portable. It implements machine learning algorithms under the Gradient Boosting framework. XGBoost provides a parallel tree boosting (also known as GBDT, GBM) that solve many data science problems in a fast and accurate way. It supports distributed training on multiple machines, including AWS, GCE, Azure, and Yarn clusters. Also, it can be integrated with Flink, Spark and other cloud dataflow systems.\n\ncuML is a suite of libraries that implement machine learning algorithms and mathematical primitives functions that share compatible APIs with other RAPIDS projects. cuML enables data scientists, researchers, and software engineers to run traditional tabular ML tasks on GPUs without going into the details of CUDA programming. In most cases, cuML's Python API matches the API from scikit-learn.\n\nDeep Learning is a subset of machine learning, which is essentially a neural network with three or more layers. These neural networks attempt to simulate the behavior of the human brain,though, far from matching its ability. This allows the neural networks to \"learn\" from large amounts of data. The Learning can be supervised, semi-supervised or unsupervised.\n\nMachine Learning Engineering for Production (MLOps) course by Andrew Ng | Coursera\n\nHow to Think About Machine Learning Algorithms | Pluralsight\n\nNVIDIA cuDNN is a GPU-accelerated library of primitives for deep neural networks. cuDNN provides highly tuned implementations for standard routines such as forward and backward convolution, pooling, normalization, and activation layers. cuDNN accelerates widely used deep learning frameworks, including Caffe2, Chainer, Keras, MATLAB, MxNet, PyTorch, and TensorFlow.\n\nNVIDIA DLSS (Deep Learning Super Sampling) is a temporal image upscaling AI rendering technology that increases graphics performance using dedicated Tensor Core AI processors on GeForce RTX™ GPUs. DLSS uses the power of a deep learning neural network to boost frame rates and generate beautiful, sharp images for your games.\n\nAMD FidelityFX Super Resolution (FSR) is an open source, high-quality solution for producing high resolution frames from lower resolution inputs. It uses a collection of cutting-edge Deep Learning algorithms with a particular emphasis on creating high-quality edges, giving large performance improvements compared to rendering at native resolution directly. FSR enables “practical performance” for costly render operations, such as hardware ray tracing for the AMD RDNA™ and AMD RDNA™ 2 architectures.\n\nIntel Xe Super Sampling (XeSS) is a temporal image upscaling AI rendering technology that increases graphics performance similar to NVIDIA's DLSS (Deep Learning Super Sampling). Intel's Arc GPU architecture (early 2022) will have GPUs that feature dedicated Xe-cores to run XeSS. The GPUs will have Xe Matrix eXtenstions matrix (XMX) engines for hardware-accelerated AI processing. XeSS will be able to run on devices without XMX, including integrated graphics, though, the performance of XeSS will be lower on non-Intel graphics cards because it will be powered by DP4a instruction.\n\nJupyter Notebook is an open-source web application that allows you to create and share documents that contain live code, equations, visualizations and narrative text. Jupyter is used widely in industries that do data cleaning and transformation, numerical simulation, statistical modeling, data visualization, data science, and machine learning.\n\nApache Spark is a unified analytics engine for large-scale data processing. It provides high-level APIs in Scala, Java, Python, and R, and an optimized engine that supports general computation graphs for data analysis. It also supports a rich set of higher-level tools including Spark SQL for SQL and DataFrames, MLlib for machine learning, GraphX for graph processing, and Structured Streaming for stream processing.\n\nApache Spark Connector for SQL Server and Azure SQL is a high-performance connector that enables you to use transactional data in big data analytics and persists results for ad-hoc queries or reporting. The connector allows you to use any SQL database, on-premises or in the cloud, as an input data source or output data sink for Spark jobs.\n\nApache PredictionIO is an open source machine learning framework for developers, data scientists, and end users. It supports event collection, deployment of algorithms, evaluation, querying predictive results via REST APIs. It is based on scalable open source services like Hadoop, HBase (and other DBs), Elasticsearch, Spark and implements what is called a Lambda Architecture.\n\nCluster Manager for Apache Kafka(CMAK) is a tool for managing Apache Kafka clusters.\n\nBigDL is a distributed deep learning library for Apache Spark. With BigDL, users can write their deep learning applications as standard Spark programs, which can directly run on top of existing Spark or Hadoop clusters.\n\nEclipse Deeplearning4J (DL4J) is a set of projects intended to support all the needs of a JVM-based(Scala, Kotlin, Clojure, and Groovy) deep learning application. This means starting with the raw data, loading and preprocessing it from wherever and whatever format it is in to building and tuning a wide variety of simple and complex deep learning networks.\n\nDeep Learning Toolbox™ is a tool that provides a framework for designing and implementing deep neural networks with algorithms, pretrained models, and apps. You can use convolutional neural networks (ConvNets, CNNs) and long short-term memory (LSTM) networks to perform classification and regression on image, time-series, and text data. You can build network architectures such as generative adversarial networks (GANs) and Siamese networks using automatic differentiation, custom training loops, and shared weights. With the Deep Network Designer app, you can design, analyze, and train networks graphically. It can exchange models with TensorFlow™ and PyTorch through the ONNX format and import models from TensorFlow-Keras and Caffe. The toolbox supports transfer learning with DarkNet-53, ResNet-50, NASNet, SqueezeNet and many other pretrained models.\n\nReinforcement Learning Toolbox™ is a tool that provides an app, functions, and a Simulink® block for training policies using reinforcement learning algorithms, including DQN, PPO, SAC, and DDPG. You can use these policies to implement controllers and decision-making algorithms for complex applications such as resource allocation, robotics, and autonomous systems.\n\nDeep Learning HDL Toolbox™ is a tool that provides functions and tools to prototype and implement deep learning networks on FPGAs and SoCs. It provides pre-built bitstreams for running a variety of deep learning networks on supported Xilinx® and Intel® FPGA and SoC devices. Profiling and estimation tools let you customize a deep learning network by exploring design, performance, and resource utilization tradeoffs.\n\nParallel Computing Toolbox™ is a tool that lets you solve computationally and data-intensive problems using multicore processors, GPUs, and computer clusters. High-level constructs such as parallel for-loops, special array types, and parallelized numerical algorithms enable you to parallelize MATLAB® applications without CUDA or MPI programming. The toolbox lets you use parallel-enabled functions in MATLAB and other toolboxes. You can use the toolbox with Simulink® to run multiple simulations of a model in parallel. Programs and models can run in both interactive and batch modes.\n\nXGBoost is an optimized distributed gradient boosting library designed to be highly efficient, flexible and portable. It implements machine learning algorithms under the Gradient Boosting framework. XGBoost provides a parallel tree boosting (also known as GBDT, GBM) that solve many data science problems in a fast and accurate way. It supports distributed training on multiple machines, including AWS, GCE, Azure, and Yarn clusters. Also, it can be integrated with Flink, Spark and other cloud dataflow systems.\n\nLIBSVM is an integrated software for support vector classification, (C-SVC, nu-SVC), regression (epsilon-SVR, nu-SVR) and distribution estimation (one-class SVM). It supports multi-class classification.\n\nScikit-Learn is a simple and efficient tool for data mining and data analysis. It is built on NumPy,SciPy, and mathplotlib.\n\nTensorFlow is an end-to-end open source platform for machine learning. It has a comprehensive, flexible ecosystem of tools, libraries and community resources that lets researchers push the state-of-the-art in ML and developers easily build and deploy ML powered applications.\n\nKeras is a high-level neural networks API, written in Python and capable of running on top of TensorFlow, CNTK, or Theano.It was developed with a focus on enabling fast experimentation. It is capable of running on top of TensorFlow, Microsoft Cognitive Toolkit, R, Theano, or PlaidML.\n\nPyTorch is a library for deep learning on irregular input data such as graphs, point clouds, and manifolds. Primarily developed by Facebook's AI Research lab.\n\nAzure Databricks is a fast and collaborative Apache Spark-based big data analytics service designed for data science and data engineering. Azure Databricks, sets up your Apache Spark environment in minutes, autoscale, and collaborate on shared projects in an interactive workspace. Azure Databricks supports Python, Scala, R, Java, and SQL, as well as data science frameworks and libraries including TensorFlow, PyTorch, and scikit-learn.\n\nMicrosoft Cognitive Toolkit (CNTK) is an open-source toolkit for commercial-grade distributed deep learning. It describes neural networks as a series of computational steps via a directed graph. CNTK allows the user to easily realize and combine popular model types such as feed-forward DNNs, convolutional neural networks (CNNs) and recurrent neural networks (RNNs/LSTMs). CNTK implements stochastic gradient descent (SGD, error backpropagation) learning with automatic differentiation and parallelization across multiple GPUs and servers.\n\nTensorflow_macOS is a Mac-optimized version of TensorFlow and TensorFlow Addons for macOS 11.0+ accelerated using Apple's ML Compute framework.\n\nApache Airflow is an open-source workflow management platform created by the community to programmatically author, schedule and monitor workflows. Install. Principles. Scalable. Airflow has a modular architecture and uses a message queue to orchestrate an arbitrary number of workers. Airflow is ready to scale to infinity.\n\nOpen Neural Network Exchange(ONNX) is an open ecosystem that empowers AI developers to choose the right tools as their project evolves. ONNX provides an open source format for AI models, both deep learning and traditional ML. It defines an extensible computation graph model, as well as definitions of built-in operators and standard data types.\n\nApache MXNet is a deep learning framework designed for both efficiency and flexibility. It allows you to mix symbolic and imperative programming to maximize efficiency and productivity. At its core, MXNet contains a dynamic dependency scheduler that automatically parallelizes both symbolic and imperative operations on the fly. A graph optimization layer on top of that makes symbolic execution fast and memory efficient. MXNet is portable and lightweight, scaling effectively to multiple GPUs and multiple machines. Support for Python, R, Julia, Scala, Go, Javascript and more.\n\nAutoGluon is toolkit for Deep learning that automates machine learning tasks enabling you to easily achieve strong predictive performance in your applications. With just a few lines of code, you can train and deploy high-accuracy deep learning models on tabular, image, and text data.\n\nAnaconda is a very popular Data Science platform for machine learning and deep learning that enables users to develop models, train them, and deploy them.\n\nPlaidML is an advanced and portable tensor compiler for enabling deep learning on laptops, embedded devices, or other devices where the available computing hardware is not well supported or the available software stack contains unpalatable license restrictions.\n\nOpenCV is a highly optimized library with focus on real-time computer vision applications. The C++, Python, and Java interfaces support Linux, MacOS, Windows, iOS, and Android.\n\nScikit-Learn is a Python module for machine learning built on top of SciPy, NumPy, and matplotlib, making it easier to apply robust and simple implementations of many popular machine learning algorithms.\n\nWeka is an open source machine learning software that can be accessed through a graphical user interface, standard terminal applications, or a Java API. It is widely used for teaching, research, and industrial applications, contains a plethora of built-in tools for standard machine learning tasks, and additionally gives transparent access to well-known toolboxes such as scikit-learn, R, and Deeplearning4j.\n\nCaffe is a deep learning framework made with expression, speed, and modularity in mind. It is developed by Berkeley AI Research (BAIR)/The Berkeley Vision and Learning Center (BVLC) and community contributors.\n\nTheano is a Python library that allows you to define, optimize, and evaluate mathematical expressions involving multi-dimensional arrays efficiently including tight integration with NumPy.\n\nMicrosoft Project Bonsai is a low-code AI platform that speeds AI-powered automation development and part of the Autonomous Systems suite from Microsoft. Bonsai is used to build AI components that can provide operator guidance or make independent decisions to optimize process variables, improve production efficiency, and reduce downtime.\n\nMicrosoft AirSim is a simulator for drones, cars and more, built on Unreal Engine (with an experimental Unity release). AirSim is open-source, cross platform, and supports software-in-the-loop simulation with popular flight controllers such as PX4 & ArduPilot and hardware-in-loop with PX4 for physically and visually realistic simulations. It is developed as an Unreal plugin that can simply be dropped into any Unreal environment. AirSim is being developed as a platform for AI research to experiment with deep learning, computer vision and reinforcement learning algorithms for autonomous vehicles.\n\nCARLA is an open-source simulator for autonomous driving research. CARLA has been developed from the ground up to support development, training, and validation of autonomous driving systems. In addition to open-source code and protocols, CARLA provides open digital assets (urban layouts, buildings, vehicles) that were created for this purpose and can be used freely.\n\nROS/ROS2 bridge for CARLA(package) is a bridge that enables two-way communication between ROS and CARLA. The information from the CARLA server is translated to ROS topics. In the same way, the messages sent between nodes in ROS get translated to commands to be applied in CARLA.\n\nROS Toolbox is a tool that provides an interface connecting MATLAB® and Simulink® with the Robot Operating System (ROS and ROS 2), enabling you to create a network of ROS nodes. The toolbox includes MATLAB functions and Simulink blocks to import, analyze, and play back ROS data recorded in rosbag files. You can also connect to a live ROS network to access ROS messages.\n\nRobotics Toolbox™ provides a toolbox that brings robotics specific functionality(designing, simulating, and testing manipulators, mobile robots, and humanoid robots) to MATLAB, exploiting the native capabilities of MATLAB (linear algebra, portability, graphics). The toolbox also supports mobile robots with functions for robot motion models (bicycle), path planning algorithms (bug, distance transform, D*, PRM), kinodynamic planning (lattice, RRT), localization (EKF, particle filter), map building (EKF) and simultaneous localization and mapping (EKF), and a Simulink model a of non-holonomic vehicle. The Toolbox also including a detailed Simulink model for a quadrotor flying robot.\n\nImage Processing Toolbox™ is a tool that provides a comprehensive set of reference-standard algorithms and workflow apps for image processing, analysis, visualization, and algorithm development. You can perform image segmentation, image enhancement, noise reduction, geometric transformations, image registration, and 3D image processing.\n\nComputer Vision Toolbox™ is a tool that provides algorithms, functions, and apps for designing and testing computer vision, 3D vision, and video processing systems. You can perform object detection and tracking, as well as feature detection, extraction, and matching. You can automate calibration workflows for single, stereo, and fisheye cameras. For 3D vision, the toolbox supports visual and point cloud SLAM, stereo vision, structure from motion, and point cloud processing.\n\nRobotics Toolbox™ is a tool that provides a toolbox that brings robotics specific functionality(designing, simulating, and testing manipulators, mobile robots, and humanoid robots) to MATLAB, exploiting the native capabilities of MATLAB (linear algebra, portability, graphics). The toolbox also supports mobile robots with functions for robot motion models (bicycle), path planning algorithms (bug, distance transform, D*, PRM), kinodynamic planning (lattice, RRT), localization (EKF, particle filter), map building (EKF) and simultaneous localization and mapping (EKF), and a Simulink model a of non-holonomic vehicle. The Toolbox also including a detailed Simulink model for a quadrotor flying robot.\n\nModel Predictive Control Toolbox™ is a tool that provides functions, an app, and Simulink® blocks for designing and simulating controllers using linear and nonlinear model predictive control (MPC). The toolbox lets you specify plant and disturbance models, horizons, constraints, and weights. By running closed-loop simulations, you can evaluate controller performance.\n\nPredictive Maintenance Toolbox™ is a tool that lets you manage sensor data, design condition indicators, and estimate the remaining useful life (RUL) of a machine. The toolbox provides functions and an interactive app for exploring, extracting, and ranking features using data-based and model-based techniques, including statistical, spectral, and time-series analysis.\n\nVision HDL Toolbox™ is a tool that provides pixel-streaming algorithms for the design and implementation of vision systems on FPGAs and ASICs. It provides a design framework that supports a diverse set of interface types, frame sizes, and frame rates. The image processing, video, and computer vision algorithms in the toolbox use an architecture appropriate for HDL implementations.\n\nAutomated Driving Toolbox™ is a MATLAB tool that provides algorithms and tools for designing, simulating, and testing ADAS and autonomous driving systems. You can design and test vision and lidar perception systems, as well as sensor fusion, path planning, and vehicle controllers. Visualization tools include a bird’s-eye-view plot and scope for sensor coverage, detections and tracks, and displays for video, lidar, and maps. The toolbox lets you import and work with HERE HD Live Map data and OpenDRIVE® road networks. It also provides reference application examples for common ADAS and automated driving features, including FCW, AEB, ACC, LKA, and parking valet. The toolbox supports C/C++ code generation for rapid prototyping and HIL testing, with support for sensor fusion, tracking, path planning, and vehicle controller algorithms.\n\nUAV Toolbox is an application that provides tools and reference applications for designing, simulating, testing, and deploying unmanned aerial vehicle (UAV) and drone applications. You can design autonomous flight algorithms, UAV missions, and flight controllers. The Flight Log Analyzer app lets you interactively analyze 3D flight paths, telemetry information, and sensor readings from common flight log formats.\n\nNavigation Toolbox™ is a tool that provides algorithms and analysis tools for motion planning, simultaneous localization and mapping (SLAM), and inertial navigation. The toolbox includes customizable search and sampling-based path planners, as well as metrics for validating and comparing paths. You can create 2D and 3D map representations, generate maps using SLAM algorithms, and interactively visualize and debug map generation with the SLAM map builder app.\n\nLidar Toolbox™ is a tool that provides algorithms, functions, and apps for designing, analyzing, and testing lidar processing systems. You can perform object detection and tracking, semantic segmentation, shape fitting, lidar registration, and obstacle detection. Lidar Toolbox supports lidar-camera cross calibration for workflows that combine computer vision and lidar processing.\n\nMapping Toolbox™ is a tool that provides algorithms and functions for transforming geographic data and creating map displays. You can visualize your data in a geographic context, build map displays from more than 60 map projections, and transform data from a variety of sources into a consistent geographic coordinate system.\n\nCUDA is a parallel computing platform and programming model developed by NVIDIA for general computing on graphical processing units (GPUs). With CUDA, developers are able to dramatically speed up computing applications by harnessing the power of GPUs. In GPU-accelerated applications, the sequential part of the workload runs on the CPU, which is optimized for single-threaded. The compute intensive portion of the application runs on thousands of GPU cores in parallel. When using CUDA, developers can program in popular languages such as C, C++, Fortran, Python and MATLAB.\n\nNVIDIA NGC is a hub for GPU-optimized software for deep learning, machine learning, and high-performance computing (HPC) workloads.\n\nNVIDIA NGC Containers is a registry that provides researchers, data scientists, and developers with simple access to a comprehensive catalog of GPU-accelerated software for AI, machine learning and HPC. These containers take full advantage of NVIDIA GPUs on-premises and in the cloud.\n\nCUDA Toolkit is a collection of tools & libraries that provide a development environment for creating high performance GPU-accelerated applications. The CUDA Toolkit allows you can develop, optimize, and deploy your applications on GPU-accelerated embedded systems, desktop workstations, enterprise data centers, cloud-based platforms and HPC supercomputers. The toolkit includes GPU-accelerated libraries, debugging and optimization tools, a C/C++ compiler, and a runtime library to build and deploy your application on major architectures including x86, Arm and POWER.\n\nNVIDIA cuDNN is a GPU-accelerated library of primitives for deep neural networks. cuDNN provides highly tuned implementations for standard routines such as forward and backward convolution, pooling, normalization, and activation layers. cuDNN accelerates widely used deep learning frameworks, including Caffe2, Chainer, Keras, MATLAB, MxNet, PyTorch, and TensorFlow.\n\nCUDA-X HPC is a collection of libraries, tools, compilers and APIs that help developers solve the world's most challenging problems. CUDA-X HPC includes highly tuned kernels essential for high-performance computing (HPC).\n\nNVIDIA Container Toolkit is a collection of tools & libraries that allows users to build and run GPU accelerated Docker containers. The toolkit includes a container runtime library and utilities to automatically configure containers to leverage NVIDIA GPUs.\n\nMinkowski Engine is an auto-differentiation library for sparse tensors. It supports all standard neural network layers such as convolution, pooling, unpooling, and broadcasting operations for sparse tensors.\n\nCUTLASS is a collection of CUDA C++ template abstractions for implementing high-performance matrix-multiplication (GEMM) at all levels and scales within CUDA. It incorporates strategies for hierarchical decomposition and data movement similar to those used to implement cuBLAS.\n\nCUB is a cooperative primitives for CUDA C++ kernel authors.\n\nTensorman is a utility for easy management of Tensorflow containers by developed by System76.Tensorman allows Tensorflow to operate in an isolated environment that is contained from the rest of the system. This virtual environment can operate independent of the base system, allowing you to use any version of Tensorflow on any version of a Linux distribution that supports the Docker runtime.\n\nNumba is an open source, NumPy-aware optimizing compiler for Python sponsored by Anaconda, Inc. It uses the LLVM compiler project to generate machine code from Python syntax. Numba can compile a large subset of numerically-focused Python, including many NumPy functions. Additionally, Numba has support for automatic parallelization of loops, generation of GPU-accelerated code, and creation of ufuncs and C callbacks.\n\nChainer is a Python-based deep learning framework aiming at flexibility. It provides automatic differentiation APIs based on the define-by-run approach (dynamic computational graphs) as well as object-oriented high-level APIs to build and train neural networks. It also supports CUDA/cuDNN using CuPy for high performance training and inference.\n\nCuPy is an implementation of NumPy-compatible multi-dimensional array on CUDA. CuPy consists of the core multi-dimensional array class, cupy.ndarray, and many functions on it. It supports a subset of numpy.ndarray interface.\n\nCatBoost is a fast, scalable, high performance Gradient Boosting on Decision Trees library, used for ranking, classification, regression and other machine learning tasks for Python, R, Java, C++. Supports computation on CPU and GPU.\n\ncuDF is a GPU DataFrame library for loading, joining, aggregating, filtering, and otherwise manipulating data. cuDF provides a pandas-like API that will be familiar to data engineers & data scientists, so they can use it to easily accelerate their workflows without going into the details of CUDA programming.\n\ncuML is a suite of libraries that implement machine learning algorithms and mathematical primitives functions that share compatible APIs with other RAPIDS projects. cuML enables data scientists, researchers, and software engineers to run traditional tabular ML tasks on GPUs without going into the details of CUDA programming. In most cases, cuML's Python API matches the API from scikit-learn.\n\nArrayFire is a general-purpose library that simplifies the process of developing software that targets parallel and massively-parallel architectures including CPUs, GPUs, and other hardware acceleration devices.\n\nThrust is a C++ parallel programming library which resembles the C++ Standard Library. Thrust's high-level interface greatly enhances programmer productivity while enabling performance portability between GPUs and multicore CPUs.\n\nAresDB is a GPU-powered real-time analytics storage and query engine. It features low query latency, high data freshness and highly efficient in-memory and on disk storage management.\n\nArraymancer is a tensor (N-dimensional array) project in Nim. The main focus is providing a fast and ergonomic CPU, Cuda and OpenCL ndarray library on which to build a scientific computing ecosystem.\n\nKintinuous is a real-time dense visual SLAM system capable of producing high quality globally consistent point and mesh reconstructions over hundreds of metres in real-time with only a low-cost commodity RGB-D sensor.\n\nGraphVite is a general graph embedding engine, dedicated to high-speed and large-scale embedding learning in various applications.\n\nMATLAB is a programming language that does numerical computing such as expressing matrix and array mathematics directly.\n\nPull, Push and Fetch Files with Git with MATLAB & Simulink\n\nPRMLT is Matlab code for machine learning algorithms in the PRML book.\n\nMATLAB in the Cloud is a service that allows you to run in cloud environments from MathWorks Cloud to Public Clouds including AWS and Azure.\n\nMATLAB Online™ is a service that allows to users to uilitize MATLAB and Simulink through a web browser such as Google Chrome.\n\nSimulink is a block diagram environment for Model-Based Design. It supports simulation, automatic code generation, and continuous testing of embedded systems.\n\nSimulink Online™ is a service that provides access to Simulink through your web browser.\n\nMATLAB Drive™ is a service that gives you the ability to store, access, and work with your files from anywhere.\n\nMATLAB Parallel Server™ is a tool that lets you scale MATLAB® programs and Simulink® simulations to clusters and clouds. You can prototype your programs and simulations on the desktop and then run them on clusters and clouds without recoding. MATLAB Parallel Server supports batch jobs, interactive parallel computations, and distributed computations with large matrices.\n\nMATLAB Schemer is a MATLAB package makes it easy to change the color scheme (theme) of the MATLAB display and GUI.\n\nLRSLibrary is a Low-Rank and Sparse Tools for Background Modeling and Subtraction in Videos. The library was designed for moving object detection in videos, but it can be also used for other computer vision and machine learning problems.\n\nImage Processing Toolbox™ is a tool that provides a comprehensive set of reference-standard algorithms and workflow apps for image processing, analysis, visualization, and algorithm development. You can perform image segmentation, image enhancement, noise reduction, geometric transformations, image registration, and 3D image processing.\n\nComputer Vision Toolbox™ is a tool that provides algorithms, functions, and apps for designing and testing computer vision, 3D vision, and video processing systems. You can perform object detection and tracking, as well as feature detection, extraction, and matching. You can automate calibration workflows for single, stereo, and fisheye cameras. For 3D vision, the toolbox supports visual and point cloud SLAM, stereo vision, structure from motion, and point cloud processing.\n\nStatistics and Machine Learning Toolbox™ is a tool that provides functions and apps to describe, analyze, and model data. You can use descriptive statistics, visualizations, and clustering for exploratory data analysis; fit probability distributions to data; generate random numbers for Monte Carlo simulations, and perform hypothesis tests. Regression and classification algorithms let you draw inferences from data and build predictive models either interactively, using the Classification and Regression Learner apps, or programmatically, using AutoML.\n\nLidar Toolbox™ is a tool that provides algorithms, functions, and apps for designing, analyzing, and testing lidar processing systems. You can perform object detection and tracking, semantic segmentation, shape fitting, lidar registration, and obstacle detection. Lidar Toolbox supports lidar-camera cross calibration for workflows that combine computer vision and lidar processing.\n\nMapping Toolbox™ is a tool that provides algorithms and functions for transforming geographic data and creating map displays. You can visualize your data in a geographic context, build map displays from more than 60 map projections, and transform data from a variety of sources into a consistent geographic coordinate system.\n\nUAV Toolbox is an application that provides tools and reference applications for designing, simulating, testing, and deploying unmanned aerial vehicle (UAV) and drone applications. You can design autonomous flight algorithms, UAV missions, and flight controllers. The Flight Log Analyzer app lets you interactively analyze 3D flight paths, telemetry information, and sensor readings from common flight log formats.\n\nParallel Computing Toolbox™ is a tool that lets you solve computationally and data-intensive problems using multicore processors, GPUs, and computer clusters. High-level constructs such as parallel for-loops, special array types, and parallelized numerical algorithms enable you to parallelize MATLAB® applications without CUDA or MPI programming. The toolbox lets you use parallel-enabled functions in MATLAB and other toolboxes. You can use the toolbox with Simulink® to run multiple simulations of a model in parallel. Programs and models can run in both interactive and batch modes.\n\nPartial Differential Equation Toolbox™ is a tool that provides functions for solving structural mechanics, heat transfer, and general partial differential equations (PDEs) using finite element analysis.\n\nROS Toolbox is a tool that provides an interface connecting MATLAB® and Simulink® with the Robot Operating System (ROS and ROS 2), enabling you to create a network of ROS nodes. The toolbox includes MATLAB functions and Simulink blocks to import, analyze, and play back ROS data recorded in rosbag files. You can also connect to a live ROS network to access ROS messages.\n\nRobotics Toolbox™ provides a toolbox that brings robotics specific functionality(designing, simulating, and testing manipulators, mobile robots, and humanoid robots) to MATLAB, exploiting the native capabilities of MATLAB (linear algebra, portability, graphics). The toolbox also supports mobile robots with functions for robot motion models (bicycle), path planning algorithms (bug, distance transform, D*, PRM), kinodynamic planning (lattice, RRT), localization (EKF, particle filter), map building (EKF) and simultaneous localization and mapping (EKF), and a Simulink model a of non-holonomic vehicle. The Toolbox also including a detailed Simulink model for a quadrotor flying robot.\n\nDeep Learning Toolbox™ is a tool that provides a framework for designing and implementing deep neural networks with algorithms, pretrained models, and apps. You can use convolutional neural networks (ConvNets, CNNs) and long short-term memory (LSTM) networks to perform classification and regression on image, time-series, and text data. You can build network architectures such as generative adversarial networks (GANs) and Siamese networks using automatic differentiation, custom training loops, and shared weights. With the Deep Network Designer app, you can design, analyze, and train networks graphically. It can exchange models with TensorFlow™ and PyTorch through the ONNX format and import models from TensorFlow-Keras and Caffe. The toolbox supports transfer learning with DarkNet-53, ResNet-50, NASNet, SqueezeNet and many other pretrained models.\n\nReinforcement Learning Toolbox™ is a tool that provides an app, functions, and a Simulink® block for training policies using reinforcement learning algorithms, including DQN, PPO, SAC, and DDPG. You can use these policies to implement controllers and decision-making algorithms for complex applications such as resource allocation, robotics, and autonomous systems.\n\nDeep Learning HDL Toolbox™ is a tool that provides functions and tools to prototype and implement deep learning networks on FPGAs and SoCs. It provides pre-built bitstreams for running a variety of deep learning networks on supported Xilinx® and Intel® FPGA and SoC devices. Profiling and estimation tools let you customize a deep learning network by exploring design, performance, and resource utilization tradeoffs.\n\nModel Predictive Control Toolbox™ is a tool that provides functions, an app, and Simulink® blocks for designing and simulating controllers using linear and nonlinear model predictive control (MPC). The toolbox lets you specify plant and disturbance models, horizons, constraints, and weights. By running closed-loop simulations, you can evaluate controller performance.\n\nVision HDL Toolbox™ is a tool that provides pixel-streaming algorithms for the design and implementation of vision systems on FPGAs and ASICs. It provides a design framework that supports a diverse set of interface types, frame sizes, and frame rates. The image processing, video, and computer vision algorithms in the toolbox use an architecture appropriate for HDL implementations.\n\nSoC Blockset™ is a tool that provides Simulink® blocks and visualization tools for modeling, simulating, and analyzing hardware and software architectures for ASICs, FPGAs, and systems on a chip (SoC). You can build your system architecture using memory models, bus models, and I/O models, and simulate the architecture together with the algorithms.\n\nWireless HDL Toolbox™ is a tool that provides pre-verified, hardware-ready Simulink® blocks and subsystems for developing 5G, LTE, and custom OFDM-based wireless communication applications. It includes reference applications, IP blocks, and gateways between frame and sample-based processing.\n\nThingSpeak™ is an IoT analytics service that allows you to aggregate, visualize, and analyze live data streams in the cloud. ThingSpeak provides instant visualizations of data posted by your devices to ThingSpeak. With the ability to execute MATLAB® code in ThingSpeak, you can perform online analysis and process data as it comes in. ThingSpeak is often used for prototyping and proof-of-concept IoT systems that require analytics.\n\nSEA-MAT is a collaborative effort to organize and distribute Matlab tools for the Oceanographic Community.\n\nGramm is a complete data visualization toolbox for Matlab. It provides an easy to use and high-level interface to produce publication-quality plots of complex data with varied statistical visualizations. Gramm is inspired by R's ggplot2 library.\n\nhctsa is a software package for running highly comparative time-series analysis using Matlab.\n\nGNU Octave is a high-level interpreted language, primarily intended for numerical computations. It provides capabilities for the numerical solution of linear and nonlinear problems, and for performing other numerical experiments. It also provides extensive graphics capabilities for data visualization and manipulation.\n\nC++ is a cross-platform language that can be used to build high-performance applications developed by Bjarne Stroustrup, as an extension to the C language.\n\nC is a general-purpose, high-level language that was originally developed by Dennis M. Ritchie to develop the UNIX operating system at Bell Labs. It supports structured programming, lexical variable scope, and recursion, with a static type system. C also provides constructs that map efficiently to typical machine instructions, which makes it one was of the most widely used programming languages today.\n\nEmbedded C is a set of language extensions for the C programming language by the C Standards Committee to address issues that exist between C extensions for different embedded systems. The extensions hep enhance microprocessor features such as fixed-point arithmetic, multiple distinct memory banks, and basic I/O operations. This makes Embedded C the most popular embedded software language in the world.\n\nC & C++ Developer Tools from JetBrains\n\nIntroduction C++ Education course on Google Developers\n\nC and C++ Coding Style Guide by OpenTitan\n\nLearn C : An Interactive C Tutorial\n\nLearn C++ with Online Courses on edX\n\nCoding for Everyone: C and C++ course on Coursera\n\nC++ For C Programmers on Coursera\n\nBasics of Embedded C Programming for Beginners on Udemy\n\nC++ For Programmers Course on Udacity\n\nC++ Fundamentals Course on Pluralsight\n\nIntroduction to C++ on MIT Free Online Course Materials\n\nIntroduction to C++ for Programmers | Harvard\n\nVisual Studio is an integrated development environment (IDE) from Microsoft; which is a feature-rich application that can be used for many aspects of software development. Visual Studio makes it easy to edit, debug, build, and publish your app. By using Microsoft software development platforms such as Windows API, Windows Forms, Windows Presentation Foundation, and Windows Store.\n\nVisual Studio Code is a code editor redefined and optimized for building and debugging modern web and cloud applications.\n\nVcpkg is a C++ Library Manager for Windows, Linux, and MacOS.\n\nReSharper C++ is a Visual Studio Extension for C++ developers developed by JetBrains.\n\nAppCode is constantly monitoring the quality of your code. It warns you of errors and smells and suggests quick-fixes to resolve them automatically. AppCode provides lots of code inspections for Objective-C, Swift, C/C++, and a number of code inspections for other supported languages. All code inspections are run on the fly.\n\nJetBrains Fleet is a IDE(Integrated Development Environment) that uses the IntelliJ code-processing engine, with a distributed IDE architecture. It's available on macOS, Windows, or Linux.\n\nCLion is a cross-platform IDE for C and C++ developers developed by JetBrains.\n\nCode::Blocks is a free C/C++ and Fortran IDE built to meet the most demanding needs of its users. It is designed to be very extensible and fully configurable. Built around a plugin framework, Code::Blocks can be extended with plugins.\n\nCppSharp is a tool and set of libraries which facilitates the usage of native C/C++ code with the .NET ecosystem. It consumes C/C++ header and library files and generates the necessary glue code to surface the native API as a managed API. Such an API can be used to consume an existing native library in your managed code or add managed scripting support to a native codebase.\n\nConan is an Open Source Package Manager for C++ development and dependency management into the 21st century and on par with the other development ecosystems.\n\nHigh Performance Computing (HPC) SDK is a comprehensive toolbox for GPU accelerating HPC modeling and simulation applications. It includes the C, C++, and Fortran compilers, libraries, and analysis tools necessary for developing HPC applications on the NVIDIA platform.\n\nThrust is a C++ parallel programming library which resembles the C++ Standard Library. Thrust's high-level interface greatly enhances programmer productivity while enabling performance portability between GPUs and multicore CPUs. Interoperability with established technologies such as CUDA, TBB, and OpenMP integrates with existing software.\n\nBoost is an educational opportunity focused on cutting-edge C++. Boost has been a participant in the annual Google Summer of Code since 2007, in which students develop their skills by working on Boost Library development.\n\nAutomake is a tool for automatically generating Makefile.in files compliant with the GNU Coding Standards. Automake requires the use of GNU Autoconf.\n\nCmake is an open-source, cross-platform family of tools designed to build, test and package software. CMake is used to control the software compilation process using simple platform and compiler independent configuration files, and generate native makefiles and workspaces that can be used in the compiler environment of your choice.\n\nGDB is a debugger, that allows you to see what is going on `inside' another program while it executes or what another program was doing at the moment it crashed.\n\nGCC is a compiler Collection that includes front ends for C, C++, Objective-C, Fortran, Ada, Go, and D, as well as libraries for these languages.\n\nGSL is a numerical library for C and C++ programmers. It is free software under the GNU General Public License. The library provides a wide range of mathematical routines such as random number generators, special functions and least-squares fitting. There are over 1000 functions in total with an extensive test suite.\n\nOpenGL Extension Wrangler Library (GLEW) is a cross-platform open-source C/C++ extension loading library. GLEW provides efficient run-time mechanisms for determining which OpenGL extensions are supported on the target platform.\n\nLibtool is a generic library support script that hides the complexity of using shared libraries behind a consistent, portable interface. To use Libtool, add the new generic library building commands to your Makefile, Makefile.in, or Makefile.am.\n\nMaven is a software project management and comprehension tool. Based on the concept of a project object model (POM), Maven can manage a project's build, reporting and documentation from a central piece of information.\n\nTAU (Tuning And Analysis Utilities) is capable of gathering performance information through instrumentation of functions, methods, basic blocks, and statements as well as event-based sampling. All C++ language features are supported including templates and namespaces.\n\nClang is a production quality C, Objective-C, C++ and Objective-C++ compiler when targeting X86-32, X86-64, and ARM (other targets may have caveats, but are usually easy to fix). Clang is used in production to build performance-critical software like Google Chrome or Firefox.\n\nOpenCV is a highly optimized library with focus on real-time applications. Cross-Platform C++, Python and Java interfaces support Linux, MacOS, Windows, iOS, and Android.\n\nLibcu++ is the NVIDIA C++ Standard Library for your entire system. It provides a heterogeneous implementation of the C++ Standard Library that can be used in and between CPU and GPU code.\n\nANTLR (ANother Tool for Language Recognition) is a powerful parser generator for reading, processing, executing, or translating structured text or binary files. It's widely used to build languages, tools, and frameworks. From a grammar, ANTLR generates a parser that can build parse trees and also generates a listener interface that makes it easy to respond to the recognition of phrases of interest.\n\nOat++ is a light and powerful C++ web framework for highly scalable and resource-efficient web application. It's zero-dependency and easy-portable.\n\nJavaCPP is a program that provides efficient access to native C++ inside Java, not unlike the way some C/C++ compilers interact with assembly language.\n\nCython is a language that makes writing C extensions for Python as easy as Python itself. Cython is based on Pyrex, but supports more cutting edge functionality and optimizations such as calling C functions and declaring C types on variables and class attributes.\n\nSpdlog is a very fast, header-only/compiled, C++ logging library.\n\nInfer is a static analysis tool for Java, C++, Objective-C, and C. Infer is written in OCaml.\n\nRider is a .NET IDE that also have integration for Unreal Engine and C++ made by Jetbrains.\n\nPython is an interpreted, high-level programming language. Python is used heavily in the fields of Data Science and Machine Learning.\n\nPython Developer’s Guide is a comprehensive resource for contributing to Python – for both new and experienced contributors. It is maintained by the same community that maintains Python.\n\nAzure Functions Python developer guide is an introduction to developing Azure Functions using Python. The content below assumes that you've already read the Azure Functions developers guide.\n\nCheckiO is a programming learning platform and a gamified website that teaches Python through solving code challenges and competing for the most elegant and creative solutions.\n\nGetting Started with Python in Visual Studio Code\n\nLearn Python with Online Courses and Classes from edX\n\nPython Package Index (PyPI) is a repository of software for the Python programming language. PyPI helps you find and install software developed and shared by the Python community.\n\nPyCharm is the best IDE I've ever used. With PyCharm, you can access the command line, connect to a database, create a virtual environment, and manage your version control system all in one place, saving time by avoiding constantly switching between windows.\n\nPython Tools for Visual Studio(PTVS) is a free, open source plugin that turns Visual Studio into a Python IDE. It supports editing, browsing, IntelliSense, mixed Python/C++ debugging, remote Linux/MacOS debugging, profiling, IPython, and web development with Django and other frameworks.\n\nDjango is a high-level Python Web framework that encourages rapid development and clean, pragmatic design.\n\nFlask is a micro web framework written in Python. It is classified as a microframework because it does not require particular tools or libraries.\n\nWeb2py is an open-source web application framework written in Python allowing allows web developers to program dynamic web content. One web2py instance can run multiple web sites using different databases.\n\nAWS Chalice is a framework for writing serverless apps in python. It allows you to quickly create and deploy applications that use AWS Lambda.\n\nTornado is a Python web framework and asynchronous networking library. Tornado uses a non-blocking network I/O, which can scale to tens of thousands of open connections.\n\nHTTPie is a command line HTTP client that makes CLI interaction with web services as easy as possible. HTTPie is designed for testing, debugging, and generally interacting with APIs & HTTP servers.\n\nScrapy is a fast high-level web crawling and web scraping framework, used to crawl websites and extract structured data from their pages. It can be used for a wide range of purposes, from data mining to monitoring and automated testing.\n\nSentry is a service that helps you monitor and fix crashes in realtime. The server is in Python, but it contains a full API for sending events from any language, in any application.\n\nPipenv is a tool that aims to bring the best of all packaging worlds (bundler, composer, npm, cargo, yarn, etc.) to the Python world.\n\nPython Fire is a library for automatically generating command line interfaces (CLIs) from absolutely any Python object.\n\nBottle is a fast, simple and lightweight WSGI micro web-framework for Python. It is distributed as a single file module and has no dependencies other than the Python Standard Library.\n\nSanic is a Python 3.6+ web server and web framework that's written to go fast.\n\nPyramid is a small and fast open source Python web framework. It makes real-world web application development and deployment more fun and more productive.\n\nTurboGears is a hybrid web framework able to act both as a Full Stack framework or as a Microframework.\n\nFalcon is a reliable, high-performance Python web framework for building large-scale app backends and microservices with support for MongoDB, Pluggable Applications and autogenerated Admin.\n\nNeural Network Intelligence(NNI) is an open source AutoML toolkit for automate machine learning lifecycle, including Feature Engineering, Neural Architecture Search, Model Compression and Hyperparameter Tuning.\n\nDash is a popular Python framework for building ML & data science web apps for Python, R, Julia, and Jupyter.\n\nLuigi is a Python module that helps you build complex pipelines of batch jobs. It handles dependency resolution, workflow management, visualization etc. It also comes with Hadoop support built-in.\n\nLocust is an easy to use, scriptable and scalable performance testing tool.\n\nspaCy is a library for advanced Natural Language Processing in Python and Cython.\n\nNumPy is the fundamental package needed for scientific computing with Python.\n\nIPython is a command shell for interactive computing in multiple programming languages, originally developed for the Python programming language, that offers enhanced introspection, rich media, additional shell syntax, tab completion, and rich history.\n\nGraphLab Create is a Python library, backed by a C++ engine, for quickly building large-scale, high-performance machine learning models.\n\nPandas is a fast, powerful, and easy to use open source data structrures, data analysis and manipulation tool, built on top of the Python programming language.\n\nPuLP is an Linear Programming modeler written in python. PuLP can generate LP files and call on use highly optimized solvers, GLPK, COIN CLP/CBC, CPLEX, and GUROBI, to solve these linear problems.\n\nMatplotlib is a 2D plotting library for creating static, animated, and interactive visualizations in Python. Matplotlib produces publication-quality figures in a variety of hardcopy formats and interactive environments across platforms.\n\nScikit-Learn is a simple and efficient tool for data mining and data analysis. It is built on NumPy,SciPy, and mathplotlib.\n\nLua is a subset of the C programming language designed to be a lightweight embeddable scripting language used by many frameworks and games.\n\nLua Language Server is an extension for VSCode that provides support for the Lua Language Server.\n\nApache APISIX is a dynamic, real-time, high-performance API gateway, based on the Nginx library and etcd.\n\nNodeMCU is an open source Lua based firmware for the ESP8266 WiFi SOC from Espressif and uses an on-module flash-based SPIFFS file system.\n\nGopherLua is a Lua 5.1 VM and compiler written in Go.\n\nMoonScript is a programmer friendly language that compiles into Lua.\n\nLapis is a web framework for Lua/MoonScript supporting OpenResty or http.server.\n\nAlgernon is a web server with built-in support for QUIC, HTTP/2, Lua, Markdown, Pongo2, HyperApp, Amber, Sass(SCSS), GCSS, JSX, BoltDB (built-in, stores the database in a file, like SQLite), Redis, PostgreSQL, MariaDB/MySQL, rate limiting, graceful shutdown, plugins, users and permissions.\n\nLua Fun is a high-performance functional programming library for Lua designed with LuaJIT's trace compiler in mind.\n\nLuakit is a fast, light and simple to use micro-browser framework extensible by Lua using the WebKit web content engine and the GTK+ toolkit.\n\nLua Resty HTTP is an HTTP client cosocket driver for OpenResty/ ngx_lua.\n\nNLua is a bridge between Lua world and the .NET (compatible with .NET Core/UWP/Mac/Linux/Android/iOS/tvOS).\n\ncURL is a computer software project providing a library and command-line tool for transferring data using various network protocols(HTTP, HTTPS, FTP, FTPS, SCP, SFTP, TFTP, DICT, TELNET, LDAP LDAPS, MQTT, POP3, POP3S, RTMP, RTMPS, RTSP, SCP, SFTP, SMB, SMBS, SMTP or SMTPS). cURL is also used in cars, television sets, routers, printers, audio equipment, mobile phones, tablets, settop boxes, media players and is the Internet transfer engine for thousands of software applications in over ten billion installations.\n\ncURL Fuzzer is a quality assurance testing for the curl project.\n\nDoH is a stand-alone application for DoH (DNS-over-HTTPS) name resolves and lookups.\n\nAuthelia is an open-source highly-available authentication server providing single sign-on capability and two-factor authentication to applications running behind NGINX.\n\nnginx(engine x) is an HTTP and reverse proxy server, a mail proxy server, and a generic TCP/UDP proxy server, originally written by Igor Sysoev.\n\nProxmox Virtual Environment(VE) is a complete open-source platform for enterprise virtualization. It inlcudes a built-in web interface that you can easily manage VMs and containers, software-defined storage and networking, high-availability clustering, and multiple out-of-the-box tools on a single solution.\n\nWireshark is a very popular network protocol analyzer that is commonly used for network troubleshooting, analysis, and communications protocol development. Learn more about the other useful Wireshark Tools available.\n\nHTTPie is a command-line HTTP client. Its goal is to make CLI interaction with web services as human-friendly as possible. HTTPie is designed for testing, debugging, and generally interacting with APIs & HTTP servers.\n\nHTTPStat is a tool that visualizes curl statistics in a simple layout.\n\nWuzz is an interactive cli tool for HTTP inspection. It can be used to inspect/modify requests copied from the browser's network inspector with the \"copy as cURL\" feature.\n\nWebsocat is a ommand-line client for WebSockets, like netcat (or curl) for ws:// with advanced socat-like functions.\n\nPackets have a header portion that contains information about the packet including the source and destination, timestamps, network hops. The main portion of a packet contains the actual data being transferred. It is sometimes called the body or the payload.\n\nA network interface may be associated with a physical device, or it may be a representation of a virtual interface. The \"loop-back\" device, which is a virtual interface to the local machine, is an example of this.\n\nIf an interface is connected to the WAN, it is generally assumed that it is reachable through the internet.\n\nSome low level protocols are TCP, UDP, IP, and ICMP. Some familiar examples of application layer protocols, built on these lower protocols, are HTTP (for accessing web content), SSH, TLS/SSL, and FTP.\n\nThe TCP/IP model, more commonly known as the Internet protocol suite, is another layering model that is simpler and has been widely adopted.It defines the four separate layers, some of which overlap with the OSI model:\n\nInterfaces are networking communication points for your computer. Each interface is associated with a physical or virtual networking device. Typically, your server will have one configurable network interface for each Ethernet or wireless internet card you have. In addition, it will define a virtual network interface called the \"loopback\" or localhost interface. This is used as an interface to connect applications and processes on a single computer to other applications and processes. You can see this referenced as the \"lo\" interface in many tools.\n\nNetworking works by piggybacks on a number of different protocols on top of each other. In this way, one piece of data can be transmitted using multiple protocols encapsulated within one another.\n\nMedia Access Control(MAC) is a communications protocol that is used to distinguish specific devices. Each device is supposed to get a unique MAC address during the manufacturing process that differentiates it from every other device on the internet. Addressing hardware by the MAC address allows you to reference a device by a unique value even when the software on top may change the name for that specific device during operation. Media access control is one of the only protocols from the link layer that you are likely to interact with on a regular basis.\n\nThe IP protocol is one of the fundamental protocols that allow the internet to work. IP addresses are unique on each network and they allow machines to address each other across a network. It is implemented on the internet layer in the IP/TCP model. Networks can be linked together, but traffic must be routed when crossing network boundaries. This protocol assumes an unreliable network and multiple paths to the same destination that it can dynamically change between. There are a number of different implementations of the protocol. The most common implementation today is IPv4, although IPv6 is growing in popularity as an alternative due to the scarcity of IPv4 addresses available and improvements in the protocols capabilities.\n\nICMP: internet control message protocol is used to send messages between devices to indicate the availability or error conditions. These packets are used in a variety of network diagnostic tools, such as ping and traceroute. Usually ICMP packets are transmitted when a packet of a different kind meets some kind of a problem. Basically, they are used as a feedback mechanism for network communications.\n\nTCP: Transmission control protocol is implemented in the transport layer of the IP/TCP model and is used to establish reliable connections. TCP is one of the protocols that encapsulates data into packets. It then transfers these to the remote end of the connection using the methods available on the lower layers. On the other end, it can check for errors, request certain pieces to be resent, and reassemble the information into one logical piece to send to the application layer. The protocol builds up a connection prior to data transfer using a system called a three-way handshake. This is a way for the two ends of the communication to acknowledge the request and agree upon a method of ensuring data reliability. After the data has been sent, the connection is torn down using a similar four-way handshake. TCP is the protocol of choice for many of the most popular uses for the internet, including WWW, FTP, SSH, and email. It is safe to say that the internet we know today would not be here without TCP.\n\nUDP: User datagram protocol is a popular companion protocol to TCP and is also implemented in the transport layer. The fundamental difference between UDP and TCP is that UDP offers unreliable data transfer. It does not verify that data has been received on the other end of the connection. This might sound like a bad thing, and for many purposes, it is. However, it is also extremely important for some functions. It’s not required to wait for confirmation that the data was received and forced to resend data, UDP is much faster than TCP. It does not establish a connection with the remote host, it simply fires off the data to that host and doesn't care if it is accepted or not. Since UDP is a simple transaction, it is useful for simple communications like querying for network resources. It also doesn't maintain a state, which makes it great for transmitting data from one machine to many real-time clients. This makes it ideal for VOIP, games, and other applications that cannot afford delays.\n\nHTTP: Hypertext transfer protocol is a protocol defined in the application layer that forms the basis for communication on the web. HTTP defines a number of functions that tell the remote system what you are requesting. For instance, GET, POST, and DELETE all interact with the requested data in a different way.\n\nFTP: File transfer protocol is in the application layer and provides a way of transferring complete files from one host to another. It is inherently insecure, so it is not recommended for any externally facing network unless it is implemented as a public, download-only resource.\n\nDNS: Domain name system is an application layer protocol used to provide a human-friendly naming mechanism for internet resources. It is what ties a domain name to an IP address and allows you to access sites by name in your browser.\n\nSSH: Secure shell is an encrypted protocol implemented in the application layer that can be used to communicate with a remote server in a secure way. Many additional technologies are built around this protocol because of its end-to-end encryption and ubiquity. There are many other protocols that we haven't covered that are equally important. However, this should give you a good overview of some of the fundamental technologies that make the internet and networking possible.\n\nREST(REpresentational State Transfer) is an architectural style for providing standards between computer systems on the web, making it easier for systems to communicate with each other.\n\nJSON Web Token (JWT) is a compact URL-safe means of representing claims to be transferred between two parties. The claims in a JWT are encoded as a JSON object that is digitally signed using JSON Web Signature (JWS).\n\nOAuth 2.0 is an open source authorization framework that enables applications to obtain limited access to user accounts on an HTTP service, such as Amazon, Google, Facebook, Microsoft, Twitter GitHub, and DigitalOcean. It works by delegating user authentication to the service that hosts the user account, and authorizing third-party applications to access the user account.\n\nSQL is a standard language for storing, manipulating and retrieving data in relational databases.\n\nNoSQL is a database that is interchangeably referred to as \"nonrelational, or \"non-SQL\" to highlight that the database can handle huge volumes of rapidly changing, unstructured data in different ways than a relational (SQL-based) database with rows and tables.\n\nTransact-SQL(T-SQL) is a Microsoft extension of SQL with all of the tools and applications communicating to a SQL database by sending T-SQL commands.\n\nBest Practices and Recommendations for SQL Server Clustering in AWS EC2.\n\nNetdata is high-fidelity infrastructure monitoring and troubleshooting, real-time monitoring Agent collects thousands of metrics from systems, hardware, containers, and applications with zero configuration. It runs permanently on all your physical/virtual servers, containers, cloud deployments, and edge/IoT devices, and is perfectly safe to install on your systems mid-incident without any preparation.\n\nAzure Data Studio is an open source data management tool that enables working with SQL Server, Azure SQL DB and SQL DW from Windows, macOS and Linux.\n\nAzure SQL Database is the intelligent, scalable, relational database service built for the cloud. It’s evergreen and always up to date, with AI-powered and automated features that optimize performance and durability for you. Serverless compute and Hyperscale storage options automatically scale resources on demand, so you can focus on building new applications without worrying about storage size or resource management.\n\nAzure SQL Managed Instance is a fully managed SQL Server Database engine instance that's hosted in Azure and placed in your network. This deployment model makes it easy to lift and shift your on-premises applications to the cloud with very few application and database changes. Managed instance has split compute and storage components.\n\nAzure Synapse Analytics is a limitless analytics service that brings together enterprise data warehousing and Big Data analytics. It gives you the freedom to query data on your terms, using either serverless or provisioned resources at scale. It brings together the best of the SQL technologies used in enterprise data warehousing, Spark technologies used in big data analytics, and Pipelines for data integration and ETL/ELT.\n\nMSSQL for Visual Studio Code is an extension for developing Microsoft SQL Server, Azure SQL Database and SQL Data Warehouse everywhere with a rich set of functionalities.\n\nSQL Server Data Tools (SSDT) is a development tool for building SQL Server relational databases, Azure SQL Databases, Analysis Services (AS) data models, Integration Services (IS) packages, and Reporting Services (RS) reports. With SSDT, a developer can design and deploy any SQL Server content type with the same ease as they would develop an application in Visual Studio or Visual Studio Code.\n\nBulk Copy Program is a command-line tool that comes with Microsoft SQL Server. BCP, allows you to import and export large amounts of data in and out of SQL Server databases quickly snd efficeiently.\n\nSQL Server Migration Assistant is a tool from Microsoft that simplifies database migration process from Oracle to SQL Server, Azure SQL Database, Azure SQL Database Managed Instance and Azure SQL Data Warehouse.\n\nSQL Server Integration Services is a development platform for building enterprise-level data integration and data transformations solutions. Use Integration Services to solve complex business problems by copying or downloading files, loading data warehouses, cleansing and mining data, and managing SQL Server objects and data.\n\nSQL Server Business Intelligence(BI) is a collection of tools in Microsoft's SQL Server for transforming raw data into information businesses can use to make decisions.\n\nTableau is a Data Visualization software used in relational databases, cloud databases, and spreadsheets. Tableau was acquired by Salesforce in August 2019.\n\nDataGrip is a professional DataBase IDE developed by Jet Brains that provides context-sensitive code completion, helping you to write SQL code faster. Completion is aware of the tables structure, foreign keys, and even database objects created in code you're editing.\n\nRStudio is an integrated development environment for R and Python, with a console, syntax-highlighting editor that supports direct code execution, and tools for plotting, history, debugging and workspace management.\n\nMySQL is a fully managed database service to deploy cloud-native applications using the world's most popular open source database.\n\nPostgreSQL is a powerful, open source object-relational database system with over 30 years of active development that has earned it a strong reputation for reliability, feature robustness, and performance.\n\nAmazon DynamoDB is a key-value and document database that delivers single-digit millisecond performance at any scale. It is a fully managed, multiregion, multimaster, durable database with built-in security, backup and restore, and in-memory caching for internet-scale applications.\n\nApache Cassandra™ is an open source NoSQL distributed database trusted by thousands of companies for scalability and high availability without compromising performance. Cassandra provides linear scalability and proven fault-tolerance on commodity hardware or cloud infrastructure make it the perfect platform for mission-critical data.\n\nApache HBase™ is an open-source, NoSQL, distributed big data store. It enables random, strictly consistent, real-time access to petabytes of data. HBase is very effective for handling large, sparse datasets. HBase serves as a direct input and output to the Apache MapReduce framework for Hadoop, and works with Apache Phoenix to enable SQL-like queries over HBase tables.\n\nHadoop Distributed File System (HDFS) is a distributed file system that handles large data sets running on commodity hardware. It is used to scale a single Apache Hadoop cluster to hundreds (and even thousands) of nodes. HDFS is one of the major components of Apache Hadoop, the others being MapReduce and YARN.\n\nApache Mesos is a cluster manager that provides efficient resource isolation and sharing across distributed applications, or frameworks. It can run Hadoop, Jenkins, Spark, Aurora, and other frameworks on a dynamically shared pool of nodes.\n\nApache Spark is a unified analytics engine for big data processing, with built-in modules for streaming, SQL, machine learning and graph processing.\n\nElasticSearch is a search engine based on the Lucene library. It provides a distributed, multitenant-capable full-text search engine with an HTTP web interface and schema-free JSON documents. Elasticsearch is developed in Java.\n\nLogstash is a tool for managing events and logs. When used generically, the term encompasses a larger system of log collection, processing, storage and searching activities.\n\nKibana is an open source data visualization plugin for Elasticsearch. It provides visualization capabilities on top of the content indexed on an Elasticsearch cluster. Users can create bar, line and scatter plots, or pie charts and maps on top of large volumes of data.\n\nTrino is a Distributed SQL query engine for big data. It is able to tremendously speed up ETL processes, allow them all to use standard SQL statement, and work with numerous data sources and targets all in the same system.\n\nExtract, transform, and load (ETL) is a data pipeline used to collect data from various sources, transform the data according to business rules, and load it into a destination data store.\n\nRedis(REmote DIctionary Server) is an open source (BSD licensed), in-memory data structure store, used as a database, cache, and message broker. It provides data structures such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs, geospatial indexes, and streams.\n\nFoundationDB is an open source distributed database designed to handle large volumes of structured data across clusters of commodity servers. It organizes data as an ordered key-value store and employs ACID transactions for all operations. It is especially well-suited for read/write workloads but also has excellent performance for write-intensive workloads. FoundationDB was acquired by Apple in 2015.\n\nIBM DB2 is a collection of hybrid data management products offering a complete suite of AI-empowered capabilities designed to help you manage both structured and unstructured data on premises as well as in private and public cloud environments. Db2 is built on an intelligent common SQL engine designed for scalability and flexibility.\n\nMongoDB is a document database meaning it stores data in JSON-like documents.\n\nOracleDB is a powerful fully managed database helps developers manage business-critical data with the highest availability, reliability, and security.\n\nMariaDB is an enterprise open source database solution for modern, mission-critical applications.\n\nSQLite is a C-language library that implements a small, fast, self-contained, high-reliability, full-featured, SQL database engine.SQLite is the most used database engine in the world. SQLite is built into all mobile phones and most computers and comes bundled inside countless other applications that people use every day.\n\nSQLite Database Browser is an open source SQL tool that allows users to create, design and edits SQLite database files. It lets users show a log of all the SQL commands that have been issued by them and by the application itself.\n\nInfluxDB is an open source time series platform. This includes APIs for storing and querying data, processing it in the background for ETL or monitoring and alerting purposes, user dashboards, Internet of Things sensor data, and visualizing and exploring the data and more. It also has support for processing data from Graphite.\n\nCouchbaseDB is an open source distributed multi-model NoSQL document-oriented database. It creates a key-value store with managed cache for sub-millisecond data operations, with purpose-built indexers for efficient queries and a powerful query engine for executing SQL queries.\n\ndbWatch is a complete database monitoring/management solution for SQL Server, Oracle, PostgreSQL, Sybase, MySQL and Azure. Designed for proactive management and automation of routine maintenance in large scale on-premise, hybrid/cloud database environments.\n\nCosmos DB Profiler is a real-time visual debugger allowing a development team to gain valuable insight and perspective into their usage of Cosmos DB database. It identifies over a dozen suspicious behaviors from your application’s interaction with Cosmos DB.\n\nAdminer is an SQL management client tool for managing databases, tables, relations, indexes, users. Adminer has support for all the popular database management systems such as MySQL, MariaDB, PostgreSQL, SQLite, MS SQL, Oracle, Firebird, SimpleDB, Elasticsearch and MongoDB.\n\nDBeaver is an open source database tool for developers and database administrators. It offers supports for JDBC compliant databases such as MySQL, Oracle, IBM DB2, SQL Server, Firebird, SQLite, Sybase, Teradata, Firebird, Apache Hive, Phoenix, and Presto.\n\nDbVisualizer is a SQL management tool that allows users to manage a wide range of databases such as Oracle, Sybase, SQL Server, MySQL, H3, and SQLite.\n\nAppDynamics Database is a management product for Microsoft SQL Server. With AppDynamics you can monitor and trend key performance metrics such as resource consumption, database objects, schema statistics and more, allowing you to proactively tune and fix issues in a High-Volume Production Environment.\n\nToad is a SQL Server DBMS toolset developed by Quest. It increases productivity by using extensive automation, intuitive workflows, and built-in expertise. This SQL management tool resolve issues, manage change and promote the highest levels of code quality for both relational and non-relational databases.\n\nLepide SQL Server is an open source storage manager utility to analyse the performance of SQL Servers. It provides a complete overview of all configuration and permission changes being made to your SQL Server environment through an easy-to-use, graphical user interface.\n\nSequel Pro is a fast MacOS database management tool for working with MySQL. This SQL management tool helpful for interacting with your database by easily to adding new databases, new tables, and new rows.\n• If would you like to contribute to this guide simply make a Pull Request.\n\nDistributed under the Creative Commons Attribution 4.0 International (CC BY 4.0) Public License."
    },
    {
        "link": "https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/VMPages.html",
        "document": "If you need more detailed information about virtual memory usage, you can use the , , , and command-line tools for analyzing your Mac apps. The information returned by these tools ranges from summary information about all the system processes to detailed information about a specific process.\n\nThe following sections provide information on using the , , and tools to gather detailed memory information. For more information on using Instruments to analyze memory, see Instruments User Guide and the other articles in this document. For information on how to use the tool, see Performance Overview.\n\nThe tool displays high-level statistics about the current virtual memory usage of the system. By default, displays these statistics once, but you can specify an interval value (in seconds) to update these statistics continuously. For information on the usage of this tool, see the man page. Listing 1 shows an example of the output from .\n\nThe tool displays information about the specified logical pages of a file conforming to the Mach-O executable format. For each specified page of code, symbols (function and static data structure names) are displayed. All pages in the section are displayed if no page numbers are given. Listing 2 shows part of the output from for the TextEdit application. This output is the result of running the tool with the option, which prints information about all of the executable’s code pages. It includes the virtual address locations of each page and the type of information on that page. In the preceding listing, if a page exports any symbols, those symbols are also displayed by the option. If you want to view the symbols for a single page, pass in the desired page number instead of the option. For more information about the tool and its supported options, see the man page.\n\nThe and tools display the virtual memory regions allocated for a specified process. These tools provide access to the virtual memory of 32-bit and 64-bit applications, respectively. You can use them to understand the purpose of memory at a given address and how that memory is being used. For each virtual-memory region, these tools display the type of page, the starting address, region size (in kilobytes), read/write permissions, sharing mode, and the purpose of the pages in that region. The following sections show you how to interpret the output from the tool. For more information about the and tools, see the or man pages. Listing 3 shows some sample output from the tool. This example is not a full listing of the tool’s output but is an abbreviated version showing the primary sections. If you specify the parameter (plus an interval in seconds), takes two snapshots of virtual-memory usage—one at the beginning of a specified interval and the other at the end—and displays the differences. It shows three sets of differences:\n• None regions in the first snapshot that are not in the second\n• None regions in the second snapshot that are not in the first The columns of output have no headings. Instead you can interpret the type of data in each column by its format. Table 1 describes these columns. , , , , and so on The purpose of the memory. This column can contain the name of a Mach-O segment or the memory allocation technique. If present, the zone used for allocation. The virtual memory address of the region. The size of the region, measured in kilobytes Read, write and execution permissions for the region. The first set of flags specifies the current protection for the region. The second set of values specifies the maximum protection for the region. If an entry contains a dash ( ), the process does not have the target permission. Sharing mode for the region, either (copy-on-write), (private), (empty), (aliased), or (shared). The end of the pathname identifying the executable mapped into this region of virtual memory. If the region is stack or heap memory, nothing is displayed in this column. Column 1 identifies the purpose of the memory. A segment contains read-only code and data. A segment contains data that may be both readable and writable. For allocated data, this column shows how the memory was allocated, such as on the stack, using , and so on. For regions loaded from a library, the far right column shows the name of the library loaded into memory. The size of the virtual memory region (column 4) represents the total size reserved for that region. This number may not reflect the actual number of memory pages allocated for the region. For example, calling reserves a set of memory pages but does not allocate any physical memory until the pages are actually touched. Similarly, a memory-mapped file may reserve a set of pages, but the system does not load pages until a read or write event occurs on the file. The protection mode (column 5) describes the access restrictions for the memory region. A memory region contains separate flags for read, write, and execution permissions. Each virtual memory region has a current permission, and a maximum permission. In the output from , the current permission appears first followed by the maximum permission. Thus, if the permissions are “ “ the page is currently read-only but allows read, write, and execution access as its maximum allowed permissions. Typically, the current permissions do not permit writing to a region. However, these permissions may change under certain circumstances. For example, a debugger may request write access to a page in order to set a breakpoint. Note: Pages representing part of a Mach-O executable are usually not writable. The first page ( , starting at address ) has no permissions set. This ensures that any reference to a pointer immediately causes an error. The page just before the stack is similarly protected so that stack overflows cause the application to crash immediately. The sharing mode ( field) tells you whether pages are shared between processes and what happens when pages are modified. Private pages ( ) are visible only to the process and are allocated as they are used. Private pages can also be paged out to disk. Copy-on-write ( ) pages are shared by multiple processes (or shared by a single process in multiple locations). When the page is modified, the writing process then receives its own copy of the page. Empty ( ) sharing implies that the page does not really exist in physical memory. Aliased ( ) and shared ( ) memory are shared between processes. The sharing mode typically describes the general mode controlling the region. For example, as copy-on-write pages are modified, they become private to the application. However, the region containing those private pages is still copy-on-write until all pages become private. Once all pages are private, the sharing mode changes to private. Some lines in the output of describe submaps. A submap is a shared set of virtual memory page descriptions that the operating system can reuse between multiple processes. For example, the memory between and is a submap containing the most common dynamic libraries. Submaps minimize the operating system’s memory usage by representing the virtual memory regions only once. Submaps can either be shared by all processes (machine-wide) or be local to the process (process-only). If the contents of a machine-wide submap are changed—for example, the debugger makes a section of memory for a dynamic library writable so it can insert debugging traps—then the submap becomes local, and the kernel allocates memory to store the extra copy."
    },
    {
        "link": "https://developer.apple.com/documentation/xcode/analyzing-the-memory-usage-of-your-metal-app",
        "document": "Please turn on JavaScript in your browser and refresh the page to view its content."
    },
    {
        "link": "http://jiadongchen.com/2020/02/ios-memory-deep-dive-for-unity-developers",
        "document": "There are often a lot of people wondering why the memory data provided by Unity’s profiler is different from the memory data provided by some native profilers, such as Xcode for iOS. And people are interested in how to analyze the data from these native tools, such as Xcode for iOS. I watched the session Developing and optimizing a procedural game | The Elder Scrolls Blades — Unite Copenhagen recently. The session covered some topics related to iOS memory and Unity. And there is an amazing session last year from WWDC2018, you can find some useful links at the end of the article. However, as for our Unity developers, what should we do to solve iOS memory related problems?\n\nNext, I will discuss how a Unity developer can handle iOS memory related issues at work. The main content includes analyzing the memory management of the iOS system, using the Instrument to view the memory status of a Unity game, and using the command line tools to dig deep into the memory problems in a Unity game.\n\nFirst of all, I want to emphasize that the memory data provided by a profiler tool is only a (set) number, and different tools have different strategies to analyze memory. Therefore, an important question is how exactly do the data we see are obtained?\n\nDepending on the tool we used, the final result may be different. Therefore, if you are looking for a number to summarize all the memory information of an application or game, you may simplify the problem or ignore the complexity of an operating system. For example, different versions of iOS have different statistics on memory overhead. The memory used number of a metal app running on iOS12 is larger than running on iOS11 in the Xcode memory gauge. This is because Apple has changed the statistical strategy for memory, and many of the memory that has not been counted before is now also calculated into memory overhead.\n\nAlso on the iOS platform, the data from Xcode memory gauge and the data from Instrument may not be exactly the same. And the early Instrument Allocation tool was mainly used to count heap memory. Therefore, instead of wasting time comparing data from different tools, it is better to use the same tool as a measure of memory overhead or to determine whether memory optimization is effective.\n\nSo, it’s important to understand how the operating system manages memory, and how to interpret the data provided by a profiler tool. Next, let’s discuss the memory management mechanism of the iOS system, and then look at the memory data captured by Xcode and the memory data captured by Unity.\n\nFirst, each process will have an address space. Its range is supported by pointer size, such as 32bit or 64bit. And the address space is first divided into multiple regions, and then subdivided into 4K in size (early version) or 16KB (after A7) in size pages, these pages inherit the various attributes of the region, such as read-only, readable & writable, etc. Of course, some pages may store less data than the size of a page, and some data may take several pages to store. So the memory overhead of your app or game is equal to the number of pages multiplied by the page size.\n\nOf course, the system also has real physical memory.\n\nVirtual memory allows us to map from this address space to real physical memory, which I think you should know. Mapping is actually a very interesting thing. Because from the perspective of each app process, it has all the memory, that is, virtual memory, but in fact only a part of the virtual memory is mapped to the real physical memory, the part which is mapped to the physical memory is called Resident Memory.\n\nAs showed in the figure above, an app allocates memory and 4 regions are allocated on virtual memory, and the third region includes 13 pages. But at this point, there are only 6 pages that are actually mapped to physical memory. The mapping of virtual memory to real physical memory occurs when the first use of memory, such as reading data from memory or writing data to memory. Resident memory is also virtual memory, but this part of virtual memory has been mapped to real physical memory. I think you may see similar data in Xcode or Instrument. For example, Instrument’s VM Tracker lists Resident and Virtual Size respectively.\n\nA page may be dirty or clean. How to distinguish whether a page is dirty or clean? Simply put, your app or game has modified the content of this page, allocated memory and also modified the contents of the memory, then this page is dirty. Dirty memory can’t be discarded, because the data obviously needs to be stored in memory to keep the program running.\n\nIn contrast, pages that have not been modified for their content are clean page, and clean page can be discarded and recreated by the system. For example, the memory-mapped file, if the operating system needs more memory, it can be discarded. Because the system can always reload it from disk, create a mapping between memory space and files on disk. However, although the memory-mapped file does not consume real physical memory, it consumes the virtual memory of the process.\n\nIn addition to this, there are __TEXT sections of executable files and some DATA CONST sections of frameworks, which are also classified as clean memory.\n\nAt WWDC 2018, Apple’s engineers gave a very vivid example. That is, an array of 20,000 integers is allocated, and pages are created. If only the first element and the last element are assigned, the first page and the last page, that is, the pages where the first and last elements are located, will become dirty, but the pages between the first and last are still clean.\n\nWhen more memory is needed, the system will discard the clean page. But the dirty page can’t be discarded, so what if the dirty memory is too much? Prior to iOS 7, if the process had too much dirty memory, the system would terminate the process directly. After iOS 7, the mechanism of Compressed Memory was introduced. Since iOS doesn’t have a traditional disk swap mechanism (mac OS has), the Swapped Size we saw in Apple’s Profiler tool is actually Compressed Memory.\n\nSince iOS 7, the operating system can compress the dirty memory by using the memory compressor. The memory compressor compresses dirty pages (multiple pages) that have not been accessed for a while. However, when this memory is accessed again, the memory compressor will decompress it for proper access.\n\nIt can be seen that from the perspective of operating system memory management, the memory of a process is actually very complicated. The memory data recorded by Unity, for example, “Reserved Total — Unity”, is mainly from the record of the MemoryManager in the engine.\n\nMemoryManager will call the corresponding Allocator to allocate memory for the engine according to different situations. For example, we can use the free Unity 3D Game Kit project as an example, use Instrument to check its memory allocation.\n\nYou can see that the MemoryManager calls UnityDefaultAllocator. And the figure below shows IphoneNewLabelAllocator is called to allocate memory. That is to say, the memory allocated by Unity’s code, Unity will record. But we can see that in addition to the memory allocated by Unity’s code, there are many frameworks or third-party libraries that allocate memory. And these memory allocations will not be recorded by Unity.\n\n0x02 Use Instrument to review memory used in a Unity game\n\nIn this part, I recommend Valentin Simonov’s article “Understanding iOS Memory (WiP)”, which is great about using some tools to review memory used in a Unity game.\n\nIn addition to using Instrument to investigate memory issues, we can also profile memory problems with the great Xcode memory debugger tool. In particular, after exporting the Memgraph file, you can use a variety of command line tools to assist in the investigation to get more information. And sometimes people will complain that the memory data seen on Xcode’s Memory Report page is not only different from Unity Profiler, but sometimes even different from Apple’s own performance tools such as Instrument. As mentioned above, it is normal for different tools to have different data. But we can also use the Memgraph file and the command line tool to check what the data of the Memory Report focuses on.\n\nStill using the Unity 3D Game Kit project as a demonstration, the test device is iPhone X, but before we start, we need to enable the Scheme -> Run -> Diagnostics -> Malloc Stack option.\n\nAfter running the game, click on Start Game to load the first scene, and we can see in the Memory Report that the memory has reached 1.48G at this time. However, the memory gauge is still in the green part, so the fact that the memory gauge is not a good optimization suggestion, because this memory overhead on iPhone7 will directly lead to the game being terminated by the system.\n\nWe go directly to the Xcode memory debugger. If you want to check if there is a memory leak here, you can click on the option in the Filter. There is a common “fake leak” situation here. If we look at its call stack, it’s mostly related to Animation. I consulted a developer from Animation-Dev team on this issue, confirming that Xcode reports false memory leak in this case, and the memory block is still referenced by the allocator. These memory will be freed when the whole block is freed.\n\nOf course, if you encounter other strange engine-related leaks, you can submit a bug report to Unity as described in this article.\n\nThen you can export the data as a .memgraph file and you can use some command line tools to process it.\n\nThe first command line tool is , which allows us to view the current virtual memory data.\n\nWhen we get a memgraph file, we can consider using this command with the flag to output an overview of the current virtual memory.\n\nThe output of the terminal is shown below: We can find something interesting. First of all, the first four columns are what we discussed before: VIRTUAL SIZE, RESIDENT SIZE, DIRTY SIZE, SWAPPED SIZE.\n\nWe can see the TOTAL part. This game process allocates 2.7G of virtual memory, of which 1.6G is mapped to physical memory, and the DIRTY SIZE value is 1.4G — this value is very close to the value in the Memory Report, and SWAPPED SIZE is 52mb. And this value is the the pre compressed size of memory, not what it compressed down to. Therefore, we mainly pay attention to the DIRTY SIZE item.\n\nSecondly, we can see that IOKit has the most overhead. Its virtual memory not only reaches 832.5mb, but also the size mapped to physical memory reaches 750.4mb. This part is mainly some memory related to GPU, such as render targets, textures, meshes, compiled shaders and so on.\n\nAgain, we can see that MALLOC_** allocates a lot of memory. This part of the memory is mainly allocated by calling Malloc, which includes the allocation by Unity’s native C++ code, as well as the memory allocated by the third-party library and system using Malloc. This memory is stored in the so-called Heap. You can find these words “see MALLOC ZONE table below” , that is, you can find a categorization of each heap zone below. Here we can use the second command line tool to check the contents of Heap memory.\n\nWhen using the command, we can add the flag to sort the data by size, otherwise the default is sorted by the number of type instances. In the above figure, you can see that most of Heap’s memory is occupied by , reaching nearly 700mb, and the objects memory allocation is small, for example, there are 573 instances of , but they only take up 223kb.\n\nI think you might be interested in the content of non-object, but we can’t find more information in this screenshot. So next we can add the flag to group the data by size.\n\nThis is much clearer.\n\nAs you can see, in the category, the highest ranked memory allocations are a 30mb allocation, three 10mb allocations, and a 8mb allocation. Next we will profile these memory allocations.\n\nOf course, the command also provides more functions, such as those allocations with Class Name, we can get the memory address of each instance of a type through ClassName matching. Just add the flag. For example, we can print the address of all GpuProgramMetal instances. We can see that the instance of this class is not large, but the real shader resource it refers to may be a big memory overheads.\n\nWith the memory address of each object, we can find out how they came from by the command mentioned below. But now we are turning our attention to these relatively large memory allocations.\n\nLet’s back to the terminal, and print the virtual memory information, but this time we only focus on the allocation from , so we can use to filter out our target.\n\nNow we get the memory data of MALLOC_LARGE, including its address, size, and information about the Heap Zone. We can find our targets here, a 30mb allocation, three 10mb allocation and an 8mb allocation.\n\nLet’s take a look at the stack calls that allocate them. Here we will use the command with the flag to output the stack information.\n\nYou can see that this 30mb allocation is to allocate a memory pool for FMOD. The other three 10mb allocations are also doing similar things. Finally, let’s take a look at where this 8mb allocation comes from.\n\nYou can see that the memory allocated by Unity for creating a CommandQueue when the multithreaded rendering is enabled.\n\nNext, we can see there is a section of the result from the output is called . According to Valentin Simonov, corresponds to the size of Mono memory, which is managed memory. Is it true? We can look at the memory allocation call stack in the section in the same way as above.\n\nThe screenshot shows that these memory allocations are relatively small, and we also choose the largest block to start. We first use malloc_history to profile the 3mb part.\n\nWe can see that this 3mb memory is allocated by the SimplFXSynth.RenderAudio method in the C# script, which triggers the GC allocation, and the managed heap is expanded.\n\nInteresting, then let’s take a look at how the 1mb memory is allocated.\n\nThis time it’s the Unity’s ScriptingGCHandle::Acquire method to allocate memory on the managed heap. Therefore, the memory of VM_ALLOC does correspond to the Unity’s Mono managed heap. Specifically, you can find out which function triggers GC allocation by malloc_history command.\n\nNow, using the command line tools to profile and find memory problems on the iOS platform is complete. Let’s make a simple summary, after getting the . Memgraph file from a Unity game, you can first view the memory summary through . For the heap, which is the memory allocated by malloc, it can be further analyzed by the command. Once the target object’s memory address is obtained, you can use the command to get the call stack information for the allocated memory. Of course, remember to enable the Malloc Stack in Xcode. After that, you can make an automated analysis tool to process the data to locate memory problems.\n• The 3D Game Kit is a great Unity learn project. Tutorials can be found here: https://learn.unity.com/tutorial/3d-game-kit-reference-guide#5c7f8528edbc2a002053b73f\n• A new iOS API, , is provided in iOS 13, and with this API we can get an estimate of how much memory the current process can get. The figure below shows the estimated memory size that my game can consume when running on iPhone7."
    },
    {
        "link": "https://stackoverflow.com/questions/4024408/how-to-interpret-results-from-allocations-and-vm-tracker-in-instruments",
        "document": "I am tracking a very tough memory leak (or more likely abandoned memory) situation. I do the following:\n\n1) start my application\n\n 2) get to a point where the application will show the leak\n\n 3) start instruments using the 'allocations' choice\n\n 4) attach to my process and start recording\n\n 5) take an initial heapshot\n\n 6) take an initial snapshot with VM tracker\n\n 7) reproduce the steps that cause the memory to rise\n\n 8) take another heapshot\n\n 9) take another snapshot with VM tracker\n\n\n\nIf I do those steps, I see results that don't really make sense. I am hoping that I am missing some information about how these tools work. For example, I know that the 'leaks' tool doesn't track ALL kinds of memory allocations (carbon apps for example). My application is a huge, legacy app that could have weird allocation code in some out dated subsystem that I am not familiar with. That said, this is what I see:\n• in the initial snapshot of VM tracker when I look at the summary, the type MALLOC_SMALL is fairly small at roughly 72MB (virtual size)\n• in the second snapshot, MALLOC_SMALL usage has grown to 224MB (again virtual size)\n• in the second heapshot, it tells me the heapgrowth is 45MB\n\nSo how can MALLOC_SMALL grow from 72MB to 224MB, but the heapgrowth is only 45MB? Is the Allocations instrument missing something that VMTracker is recording?\n\nFurther supporting that I am missing something in the Allocations instrument...if I look at the NEW regions listed under MALLOC_SMALL (ones that weren't in the first snapshot, but were in second), those addresses should correspond to pages that were allocated and account for the 72MB->224MB difference, correct? So then, I remembered the range of addresses for that region (eg, 0x79000000-0x7b000000), and go back to the Allocations instrument and sort of the list of 'All Objects' by address. Then I look for addresses in that range. However, I only see 4 allocations that account only for 4KB?! Where are the other 32MB that VM tracker reported in that region?\n\nAny help would be appreciated....I am hoping it is something basic about how these tools work that I am just not understanding."
    },
    {
        "link": "https://medium.com/better-programming/ios-advanced-memory-debugging-to-the-masses-24d25852a91c",
        "document": "Different devices have a different amount of RAM, and the technique to abstract the different RAM systems to a unified, addresses system is called virtual memory. Virtual memory is not unique to iOS. In fact, all modern operating systems use virtual memory, it was developed more than 60 years ago! Virtual memory addresses being “virtual” means they don’t have to be aligned with any physical address you have. In fact, the virtual memory addresses are only limited by your processor architecture — a 32-bit processor can handle 4GB of addresses and 64-bit processors can handle 18 exabytes, which is 19,327,352,832 GB!\n\nThis shouldn’t come as a surprise to you, but iPhones don’t have that amount of RAM. Actually, you need more than one billion new MacBook pros in order to achieve that memory size. But from the app perspective, it doesn’t really matter. Every process in your app gets this virtual memory space and can access every address in that space. You should take into account that every virtual memory space has the same list of addresses. The same address in one process is a different physical address in other processes, so the process cannot access memory blocks on other processes. Every virtual memory space maps a virtual address to a physical address. And since there are no devices that have 18 exabytes, the system may encounter constraints. Unlike OSX, iOS doesn’t have a backing store, meaning, iOS is not using the disk in order to keep memory data, so the system is limit only to its physical RAM size.\n\nThe virtual memory divides its space into chunks called pages. Pages are 16KB chunks that can hold data from any kind. Data can also be contained on several pages, and a single page is able to hold more than one kind of data. The most important thing to know here is that a page can be marked as dirty, clean or compressed. Clean Memory can be loaded from the disk (“page out”) and contains frameworks, executable code, and read-only files. Dirty Memory is any memory written by the app, heap allocations, singletons, global initializers, and the stack. Compressed memory includes pages that are un-accessed and can be compressed or uncompressed according to your app usage. Bottom line — your memory in use is your dirty + compressed memory. You can easily ignore the clean memory since you can restore it anytime.\n\nThe VM Tracker is part of the allocation instrument. To profile your app in Instruments, select “Product” -> “Profile” in Xcode. Alternatively, you can make a long press on the “Play” button and select “Profile”. After Instruments opens, select “Allocations”, and run the profiler. Now you will see two instruments — one is the heap allocations and the other one is the VM Tracker. The Virtual Memory Tracker can help you track the type of memory that you’re most interested in: the dirty memory. Most of the time, you won’t see any data on the VM Tracker at first. That’s because VM Tracker doesn’t show your virtual memory state continuously. You have to take snapshots to analyze your memory. If you tap the VM Tracker row, a “Snapshots” button will show up at the bottom of the window. Tapping on this button will let you set the snapshots interval and even take snapshots manually. After you have a snapshot, you can see your dirty memory state over time. You can also see what objects take most of your dirty memory. If you want to dig even deeper, use VMMap, which is great for advanced memory debugging.\n\nVMMap, alongside Heap and Leaks, is a great command-line tool which aims to debug your memory objects on the virtual memory environment. In order to use it, VMMap needs a memory graph file of your app. Generating one is easy — in Xcode, stop your app run by tapping the “Debug Memory Graph” button at the bottom of the window, and then under the “File” menu, select “Export Memory Graph”. This option will generate a memory graph file you can use with VMMap. The first step when using VMMap is to get a summary of your virtual memory map. — It contains executable code and constants — If your app contains Objective C code, this region contains Objective C Runtime library code — System Libraries that are shared with other applications, such as Cocoa and OpenGL — This region contains file contents that are frequently accessed and are mapped to the virtual memory in order to enable faster access — Contains the stack memory, including parameters for every function call.\n\nWe previously mentioned dirty and clean memory, but what does it mean? Well, the simplest way to explain this is that clean memory is the memory that if lost, you are able to restore it from code or from storage. In the VMMap summary report, you can see that the region takes more than 100MB of virtual memory, but 0MB of dirty memory, and that’s because region refers to symbol tables that are saved in a file, and therefore can be restored. As you can see from the result, the memory in use is really just the dirty memory.\n\nIn order to reduce dirty memory, we need to remember that data we create dynamically in our app and keep is dirty memory. Also, remember that if cache trades CPU for memory, you can trade memory for more CPU work or local storage. Tips to reduce dirty memory in your app:\n• Try to use constants and not variables: Swift encourages you to use when it’s possible because of safety but using reduce your dirty memory as well. In fact, the object doesn’t count at all when country app memory since its part of the code and therefore it’s considered to be a clean memory.\n• Save big data objects to local storage and load them when you need: If you can save your data to cache files and load it when you need it, you can free your dirty memory. Think of it as a global storage for big chunks of information.\n• Allocate variables in the stack: Allocating variables in the stack, meaning, allocate them as a method variables, does count in the dirty memory column, but once the methods finish their run, this memory is free.\n• Use the smallest data type you can: The default data type is based on the CPU architecture. In 64 bit devices, which are almost all of the active devices today, the default is actually . So try to use / when you can.\n• Use Lazy Loading: It is always best practice to allocate objects only when you need them. The lazy loading in Swift is just for that. If you implement it, there are chances those objects won’t get allocated at all. All those tips seem to be minor, but by combining them all of them you can save a fair amount of memory, and improve your user experience."
    }
]