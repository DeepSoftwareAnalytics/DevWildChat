[
    {
        "link": "https://pandas.pydata.org/docs/reference/api/pandas.read_excel.html",
        "document": "Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, and file. For file URLs, a host is expected. A local file could be: . If you want to pass in a path object, pandas accepts any . By file-like object, we refer to objects with a method, such as a file handle (e.g. via builtin function) or . Deprecated since version 2.1.0: Passing byte strings is deprecated. To read from a byte string, wrap it in a object.\n\nColumn (0-indexed) to use as the row labels of the DataFrame. Pass None if there is no such column. If a list is passed, those columns will be combined into a . If a subset of data is selected with , index_col is based on the subset. Missing values will be forward filled to allow roundtripping with for . To avoid forward filling the missing values use after reading the data instead of .\n\nData type for data or columns. E.g. {‘a’: np.float64, ‘b’: np.int32} Use to preserve data as stored in Excel and not interpret dtype, which will necessarily result in dtype. If converters are specified, they will be applied INSTEAD of dtype conversion. If you use , it will infer the dtype of each column based on the data.\n\nIf io is not a buffer or path, this must be set to identify io. Engine compatibility : When , the following logic will be used to determine the engine:\n• None If is an OpenDocument format (.odf, .ods, .odt), then odf will be used.\n• None Otherwise if is an xls format, will be used.\n• None Otherwise if is in xlsb format, will be used.\n• None Otherwise will be used.\n\nWhether or not to include the default NaN values when parsing the data. Depending on whether is passed in, the behavior is as follows:\n• None If is True, and are specified, is appended to the default NaN values used for parsing.\n• None If is True, and are not specified, only the default NaN values are used for parsing.\n• None If is False, and are specified, only the NaN values specified are used for parsing.\n• None If is False, and are not specified, no strings will be parsed as NaN. Note that if is passed in as False, the and parameters will be ignored.\n\nThe behavior is as follows:\n• None . If True -> try parsing the index.\n• None of int or names. e.g. If [1, 2, 3] -> try parsing columns 1, 2, 3 each as a separate date column.\n• None of lists. e.g. If [[1, 3]] -> combine columns 1 and 3 and parse as a single date column. If a column or index contains an unparsable date, the entire column or index will be returned unaltered as an object data type. If you don`t want to parse some cells as date just change their type in Excel to “Text”. For non-standard datetime parsing, use after .\n\nFunction to use for converting a sequence of string columns to an array of datetime instances. The default uses to do the conversion. Pandas will try to call in three different ways, advancing to the next if an exception occurs: 1) Pass one or more arrays (as defined by ) as arguments; 2) concatenate (row-wise) the string values from the columns defined by into a single array and pass that; and 3) call once for each row using one or more strings (corresponding to the columns defined by ) as arguments. Deprecated since version 2.0.0: Use instead, or read in as and then apply as-needed."
    },
    {
        "link": "https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.to_excel.html",
        "document": "To write a single object to an Excel .xlsx file it is only necessary to specify a target file name. To write to multiple sheets it is necessary to create an object with a target file name, and specify a sheet in the file to write to.\n\nMultiple sheets may be written to by specifying unique . With all data written to the file it is necessary to save the changes. Note that creating an object with a file name that already exists will result in the contents of the existing file being erased.\n\nName of sheet which will contain DataFrame. Format string for floating point numbers. For example will format 0.1234 to 0.12. Write out the column names. If a list of string is given it is assumed to be aliases for the column names. Column label for index column(s) if desired. If not specified, and and are True, then the index names are used. A sequence should be given if the DataFrame uses MultiIndex. Write engine to use, ‘openpyxl’ or ‘xlsxwriter’. You can also set this via the options or . Representation for infinity (there is no native representation for infinity in Excel). Specifies the one-based bottommost row and rightmost column that is to be frozen. Extra options that make sense for a particular storage connection, e.g. host, port, username, password, etc. For HTTP(S) URLs the key-value pairs are forwarded to as header options. For other URLs (e.g. starting with “s3://”, and “gcs://”) the key-value pairs are forwarded to . Please see and for more details, and for more examples on storage options refer here.\n\nFor compatibility with , to_excel serializes lists and dicts to strings before writing.\n\nOnce a workbook has been saved it is not possible to write further data without rewriting the whole workbook.\n\nTo specify the sheet name:\n\nIf you wish to write to more than one sheet in the workbook, it is necessary to specify an ExcelWriter object:\n\nExcelWriter can also be used to append to an existing Excel file:\n\nTo set the library that is used to write the Excel file, you can pass the keyword (the default engine is automatically chosen depending on the file extension):"
    },
    {
        "link": "https://pandas.pydata.org/pandas-docs/version/2.2.0/reference/api/pandas.read_excel.html",
        "document": "Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, and file. For file URLs, a host is expected. A local file could be: . If you want to pass in a path object, pandas accepts any . By file-like object, we refer to objects with a method, such as a file handle (e.g. via builtin function) or . Deprecated since version 2.1.0: Passing byte strings is deprecated. To read from a byte string, wrap it in a object.\n\nColumn (0-indexed) to use as the row labels of the DataFrame. Pass None if there is no such column. If a list is passed, those columns will be combined into a . If a subset of data is selected with , index_col is based on the subset. Missing values will be forward filled to allow roundtripping with for . To avoid forward filling the missing values use after reading the data instead of .\n\nData type for data or columns. E.g. {‘a’: np.float64, ‘b’: np.int32} Use to preserve data as stored in Excel and not interpret dtype, which will necessarily result in dtype. If converters are specified, they will be applied INSTEAD of dtype conversion. If you use , it will infer the dtype of each column based on the data.\n\nIf io is not a buffer or path, this must be set to identify io. Engine compatibility : When , the following logic will be used to determine the engine:\n• None If is an OpenDocument format (.odf, .ods, .odt), then odf will be used.\n• None Otherwise if is an xls format, will be used.\n• None Otherwise if is in xlsb format, will be used.\n• None Otherwise will be used.\n\nWhether or not to include the default NaN values when parsing the data. Depending on whether is passed in, the behavior is as follows:\n• None If is True, and are specified, is appended to the default NaN values used for parsing.\n• None If is True, and are not specified, only the default NaN values are used for parsing.\n• None If is False, and are specified, only the NaN values specified are used for parsing.\n• None If is False, and are not specified, no strings will be parsed as NaN. Note that if is passed in as False, the and parameters will be ignored.\n\nThe behavior is as follows:\n• None . If True -> try parsing the index.\n• None of int or names. e.g. If [1, 2, 3] -> try parsing columns 1, 2, 3 each as a separate date column.\n• None of lists. e.g. If [[1, 3]] -> combine columns 1 and 3 and parse as a single date column. If a column or index contains an unparsable date, the entire column or index will be returned unaltered as an object data type. If you don`t want to parse some cells as date just change their type in Excel to “Text”. For non-standard datetime parsing, use after .\n\nFunction to use for converting a sequence of string columns to an array of datetime instances. The default uses to do the conversion. Pandas will try to call in three different ways, advancing to the next if an exception occurs: 1) Pass one or more arrays (as defined by ) as arguments; 2) concatenate (row-wise) the string values from the columns defined by into a single array and pass that; and 3) call once for each row using one or more strings (corresponding to the columns defined by ) as arguments. Deprecated since version 2.0.0: Use instead, or read in as and then apply as-needed."
    },
    {
        "link": "https://pandas.pydata.org/docs/user_guide/io.html",
        "document": "The pandas I/O API is a set of top level functions accessed like that generally return a pandas object. The corresponding functions are object methods that are accessed like . Below is a table containing available and .\n\nis an informal performance comparison for some of these IO methods.\n\nThe workhorse function for reading text files (a.k.a. flat files) is . See the for some advanced strategies. Either a path to a file (a , , or ), URL (including http, ftp, and S3 locations), or any object with a method (such as an open file or ). sep str, defaults to for , for Delimiter to use. If sep is , the C engine cannot automatically detect the separator, but the Python parsing engine can, meaning the latter will be used and automatically detect the separator by Python’s builtin sniffer tool, . In addition, separators longer than 1 character and different from will be interpreted as regular expressions and will also force the use of the Python parsing engine. Note that regex delimiters are prone to ignoring quoted data. Regex example: . Specifies whether or not whitespace (e.g. or ) will be used as the delimiter. Equivalent to setting . If this option is set to , nothing should be passed in for the parameter. Row number(s) to use as the column names, and the start of the data. Default behavior is to infer the column names: if no names are passed the behavior is identical to and column names are inferred from the first line of the file, if column names are passed explicitly then the behavior is identical to . Explicitly pass to be able to replace existing names. The header can be a list of ints that specify row locations for a MultiIndex on the columns e.g. . Intervening rows that are not specified will be skipped (e.g. 2 in this example is skipped). Note that this parameter ignores commented lines and empty lines if , so header=0 denotes the first line of data rather than the first line of the file. List of column names to use. If file contains no header row, then you should explicitly pass . Duplicates in this list are not allowed. Column(s) to use as the row labels of the , either given as string name or column index. If a sequence of int / str is given, a MultiIndex is used. can be used to force pandas to use the first column as the index, e.g. when you have a malformed file with delimiters at the end of each line. The default value of instructs pandas to guess. If the number of fields in the column header row is equal to the number of fields in the body of the data file, then a default index is used. If it is larger, then the first columns are used as index so that the remaining number of fields in the body are equal to the number of fields in the header. The first row after the header is used to determine the number of columns, which will go into the index. If the subsequent rows contain less columns than the first row, they are filled with . This can be avoided through . This ensures that the columns are taken as is and the trailing data are ignored. Return a subset of the columns. If list-like, all elements must either be positional (i.e. integer indices into the document columns) or strings that correspond to column names provided either by the user in or inferred from the document header row(s). If are given, the document header row(s) are not taken into account. For example, a valid list-like parameter would be or . Element order is ignored, so is the same as . To instantiate a DataFrame from with element order preserved use for columns in order or for order. If callable, the callable function will be evaluated against the column names, returning names where the callable function evaluates to True: Using this parameter results in much faster parsing time and lower memory usage when using the c engine. The Python engine loads the data first before deciding which columns to drop. dtype Type name or dict of column -> type, default Data type for data or columns. E.g. Use or together with suitable settings to preserve and not interpret dtype. If converters are specified, they will be applied INSTEAD of dtype conversion. Support for defaultdict was added. Specify a defaultdict as input where the default determines the dtype of the columns which are not explicitly listed. Which dtype_backend to use, e.g. whether a DataFrame should have NumPy arrays, nullable dtypes are used for all dtypes that have a nullable implementation when “numpy_nullable” is set, pyarrow is used for all dtypes if “pyarrow” is set. The dtype_backends are still experimential. Parser engine to use. The C and pyarrow engines are faster, while the python engine is currently more feature-complete. Multithreading is currently only supported by the pyarrow engine. The “pyarrow” engine was added as an engine, and some features are unsupported, or may not work correctly, with this engine. Dict of functions for converting values in certain columns. Keys can either be integers or column labels. Values to consider as . Values to consider as . Line numbers to skip (0-indexed) or number of lines to skip (int) at the start of the file. If callable, the callable function will be evaluated against the row indices, returning True if the row should be skipped and False otherwise: Number of lines at bottom of file to skip (unsupported with engine=’c’). Number of rows of file to read. Useful for reading pieces of large files. Internally process the file in chunks, resulting in lower memory use while parsing, but possibly mixed type inference. To ensure no mixed types either set , or specify the type with the parameter. Note that the entire file is read into a single regardless, use the or parameter to return the data in chunks. (Only valid with C parser) If a filepath is provided for , map the file object directly onto memory and access the data directly from there. Using this option can improve performance because there is no longer any I/O overhead. Additional strings to recognize as NA/NaN. If dict passed, specific per-column NA values. See below for a list of the values interpreted as NaN by default. Whether or not to include the default NaN values when parsing the data. Depending on whether is passed in, the behavior is as follows:\n• None If is , and are specified, is appended to the default NaN values used for parsing.\n• None If is , and are not specified, only the default NaN values are used for parsing.\n• None If is , and are specified, only the NaN values specified are used for parsing.\n• None If is , and are not specified, no strings will be parsed as NaN. Note that if is passed in as , the and parameters will be ignored. Detect missing value markers (empty strings and the value of na_values). In data without any NAs, passing can improve the performance of reading a large file. Indicate number of NA values placed in non-numeric columns. If , skip over blank lines rather than interpreting as NaN values. parse_dates boolean or list of ints or names or list of lists or dict, default .\n• None If -> try parsing the index.\n• None If -> try parsing columns 1, 2, 3 each as a separate date column.\n• None If -> combine columns 1 and 3 and parse as a single date column.\n• None If -> parse columns 1, 3 as date and call result ‘foo’. If and parse_dates is enabled for a column, attempt to infer the datetime format to speed up the processing. A strict version of this argument is now the default, passing it has no effect. If and parse_dates specifies combining multiple columns then keep the original columns. Function to use for converting a sequence of string columns to an array of datetime instances. The default uses to do the conversion. pandas will try to call date_parser in three different ways, advancing to the next if an exception occurs: 1) Pass one or more arrays (as defined by parse_dates) as arguments; 2) concatenate (row-wise) the string values from the columns defined by parse_dates into a single array and pass that; and 3) call date_parser once for each row using one or more strings (corresponding to the columns defined by parse_dates) as arguments. Use instead, or read in as and then apply as-needed. If used in conjunction with , will parse dates according to this format. For anything more complex, please read in as and then apply as-needed. If True, use a cache of unique, converted dates to apply the datetime conversion. May produce significant speed-up when parsing duplicate date strings, especially ones with timezone offsets. Return object for iteration or getting chunks with . Return object for iteration. See below. For on-the-fly decompression of on-disk data. If ‘infer’, then use gzip, bz2, zip, xz, or zstandard if is path-like ending in ‘.gz’, ‘.bz2’, ‘.zip’, ‘.xz’, ‘.zst’, respectively, and no decompression otherwise. If using ‘zip’, the ZIP file must contain only one data file to be read in. Set to for no decompression. Can also be a dict with key set to one of { , , , } and other key-value pairs are forwarded to , , , or . As an example, the following could be passed for faster compression and to create a reproducible gzip archive: . Character to recognize as decimal point. E.g. use for European data. Specifies which converter the C engine should use for floating-point values. The options are for the ordinary converter, for the high-precision converter, and for the round-trip converter. Character to break file into lines. Only valid with C parser. The character used to denote the start and end of a quoted item. Quoted items can include the delimiter and it will be ignored. Control field quoting behavior per constants. Use one of (0), (1), (2) or (3). When is specified and is not , indicate whether or not to interpret two consecutive elements inside a field as a single element. One-character string used to escape delimiter when quoting is . Indicates remainder of line should not be parsed. If found at the beginning of a line, the line will be ignored altogether. This parameter must be a single character. Like empty lines (as long as ), fully commented lines are ignored by the parameter but not by . For example, if , parsing ‘#empty\n\na,b,c\n\n1,2,3’ with will result in ‘a,b,c’ being treated as the header. Encoding to use for UTF when reading/writing (e.g. ). List of Python standard encodings. If provided, this parameter will override values (default or not) for the following parameters: , , , , , and . If it is necessary to override values, a ParserWarning will be issued. See documentation for more details. Specifies what to do upon encountering a bad line (a line with too many fields). Allowed values are :\n• None ‘error’, raise an ParserError when a bad line is encountered.\n• None ‘warn’, print a warning when a bad line is encountered and skip that line.\n• None ‘skip’, skip bad lines without raising or warning when they are encountered. You can indicate the data type for the whole or individual columns: Fortunately, pandas offers more than one way to ensure that your column(s) contain only one . If you’re unfamiliar with these concepts, you can see to learn more about dtypes, and to learn more about conversion in pandas. For instance, you can use the argument of : Or you can use the function to coerce the dtypes after reading in the data, which will convert all valid parsing to floats, leaving the invalid parsing as . Ultimately, how you deal with reading in columns containing mixed dtypes depends on your specific needs. In the case above, if you wanted to out the data anomalies, then is probably your best option. However, if you wanted for all the data to be coerced, no matter the type, then using the argument of would certainly be worth trying. In some cases, reading in abnormal data with columns containing mixed dtypes will result in an inconsistent dataset. If you rely on pandas to infer the dtypes of your columns, the parsing engine will go and infer the dtypes for different chunks of the data, rather than the whole dataset at once. Consequently, you can end up with column(s) with mixed dtypes. For example, will result with containing an dtype for certain chunks of the column, and for others due to the mixed dtypes from the data that was read in. It is important to note that the overall column will be marked with a of , which is used for columns with mixed dtypes. Setting will result in nullable dtypes for every column. columns can be parsed directly by specifying or . Individual columns can be parsed as a using a dict specification: Specifying will result in an unordered whose are the unique values observed in the data. For more control on the categories and order, create a ahead of time, and pass that for that column’s . When using , “unexpected” values outside of are treated as missing values. This matches the behavior of . With , the resulting categories will always be parsed as strings (object dtype). If the categories are numeric they can be converted using the function, or as appropriate, another converter such as . When is a with homogeneous ( all numeric, all datetimes, etc.), the conversion is done automatically. A file may or may not have a header row. pandas assumes the first row should be used as the column names: By specifying the argument in conjunction with you can indicate other names to use and whether or not to throw away the header row (if any): If the header is in a row other than the first, pass the row number to . This will skip the preceding rows: Default behavior is to infer the column names: if no names are passed the behavior is identical to and column names are inferred from the first non-blank line of the file, if column names are passed explicitly then the behavior is identical to . If the file or header contains duplicate names, pandas will by default distinguish between them so as to prevent overwriting data: There is no more duplicate data because duplicate columns ‘X’, …, ‘X’ become ‘X’, ‘X.1’, …, ‘X.N’. The argument allows you to select any subset of the columns in a file, either using the column names, position numbers or a callable: The argument can also be used to specify which columns not to use in the final result: In this case, the callable is specifying that we exclude the “a” and “c” columns from the output. If the parameter is specified, then completely commented lines will be ignored. By default, completely blank lines will be ignored as well. If , then will not ignore blank lines: The presence of ignored lines might create ambiguities involving line numbers; the parameter uses row numbers (ignoring commented/empty lines), while uses line numbers (including commented/empty lines): If both and are specified, will be relative to the end of . For example: Sometimes comments or meta data may be included in a file: By default, the parser includes the comments in the output: We can suppress the comments using the keyword: The argument should be used for encoded unicode data, which will result in byte strings being decoded to unicode in the result: Some formats which encode all characters as multiple bytes, like UTF-16, won’t parse correctly at all without specifying the encoding. Full list of Python standard encodings. If a file has one more column of data than the number of column names, the first column will be used as the ’s row names: Ordinarily, you can achieve this behavior using the option. There are some exception cases when a file has been prepared with delimiters at the end of each data line, confusing the parser. To explicitly disable the index column inference and discard the last column, pass : If a subset of data is being parsed using the option, the specification is based on that subset, not the original data. To better facilitate working with datetime data, uses the keyword arguments and to allow users to specify a variety of columns and date/time formats to turn the input text data into objects. The simplest case is to just pass in : # Use a column as an index, and parse it as dates. It is often the case that we may want to store date and time data separately, or store various date fields separately. the keyword can be used to specify a combination of columns to parse the dates and/or times from. You can specify a list of column lists to , the resulting date columns will be prepended to the output (so as to not affect the existing column order) and the new column names will be the concatenation of the component column names: By default the parser removes the component date columns, but you can choose to retain them via the keyword: Note that if you wish to combine multiple columns into a single date column, a nested list must be used. In other words, indicates that the second and third columns should each be parsed as separate date columns while means the two columns should be parsed into a single column. You can also use a dict to specify custom name columns: It is important to remember that if multiple text columns are to be parsed into a single date column, then a new column is prepended to the data. The specification is based off of this new set of columns rather than the original data columns: If a column or index contains an unparsable date, the entire column or index will be returned unaltered as an object data type. For non-standard datetime parsing, use after . read_csv has a fast_path for parsing datetime strings in iso8601 format, e.g “2000-01-01T00:01:02+00:00” and similar variations. If you can arrange for your data to store datetimes in this format, load times will be significantly faster, ~20x has been observed. Combining date columns inside read_csv is deprecated. Use on the relevant result columns instead. Finally, the parser allows you to specify a custom . Performance-wise, you should try these methods of parsing dates in order:\n• None If you know the format, use , e.g.: or .\n• None If you different formats for different columns, or want to pass any extra options (such as ) to , then you should read in your data as dtype, and then use . pandas cannot natively represent a column or index with mixed timezones. If your CSV file contains columns with a mixture of timezones, the default result will be an object-dtype column with strings, even with . To parse the mixed-timezone values as a datetime column, read in as dtype and then call with . Here are some examples of datetime strings that can be guessed (all representing December 30th, 2011 at 00:00:00): Note that format inference is sensitive to . With , it will guess “01/12/2011” to be December 1st. With (default) it will guess “01/12/2011” to be January 12th. If you try to parse a column of date strings, pandas will attempt to guess the format from the first non-NaN element, and will then parse the rest of the column with that format. If pandas fails to guess the format (for example if your first string is ), then a warning will be raised and each row will be parsed individually by . The safest way to parse dates is to explicitly set . In the case that you have mixed datetime formats within the same column, you can pass or, if your datetime formats are all ISO8601 (possibly not identically-formatted): While US date formats tend to be MM/DD/YYYY, many international formats use DD/MM/YYYY instead. For convenience, a keyword is provided: allows writing a CSV to a file object opened binary mode. In most cases, it is not necessary to specify as Pandas will auto-detect whether the file object is opened in text or binary mode. The parameter can be specified in order to use a specific floating-point converter during parsing with the C engine. The options are the ordinary converter, the high-precision converter, and the round-trip converter (which is guaranteed to round-trip values after writing to a file). For example: For large numbers that have been written with a thousands separator, you can set the keyword to a string of length 1 so that integers will be parsed correctly: By default, numbers with a thousands separator will be parsed as strings: The keyword allows integers to be parsed correctly: To control which values are parsed as missing values (which are signified by ), specify a string in . If you specify a list of strings, then all values in it are considered to be missing values. If you specify a number (a , like or an like ), the corresponding equivalent values will also imply a missing value (in this case effectively are recognized as ). To completely override the default values that are recognized as missing, specify . Let us consider some examples: In the example above and will be recognized as , in addition to the defaults. A string will first be interpreted as a numerical , then as a . Above, only an empty field will be recognized as . Above, both and as strings are . The default values, in addition to the string are recognized as . like values will be parsed as (positive infinity), and as (negative infinity). These will ignore the case of the value, meaning , will also be parsed as . The common values , , , and are all recognized as boolean. Occasionally you might want to recognize other values as being boolean. To do this, use the and options as follows: Some files may have malformed lines with too few fields or too many. Lines with too few fields will have NA values filled in the trailing fields. Lines with too many fields will raise an error by default: Traceback (most recent call last) in in in in in in in in in : Error tokenizing data. C error: Expected 3 fields in line 3, saw 4 You can elect to skip bad lines: Or pass a callable function to handle the bad line if . The bad line will be a list of strings that was split by the : The callable function will handle only a line with too many fields. Bad lines caused by other errors will be silently skipped. name a,a is of type a 'name,type\n\nname a,a is of type a\n\nname b,\"b\" is of type b\"' 0 name a a is of type a The line was not processed in this case, as a “bad line” here is caused by an escape character. You can also use the parameter to eliminate extraneous column data that appear in some lines but not others: Traceback (most recent call last) in in in in in in \"Usecols do not match columns, columns expected but not found: \" : Usecols do not match columns, columns expected but not found: [0, 1, 2] In case you want to keep all data including the lines with too many fields, you can specify a sufficient number of . This ensures that lines with not enough fields are filled with . 1 name a a is of type a NaN NaN 2 name b b is of type b\" NaN NaN The keyword gives greater flexibility in specifying the file format. By default it uses the Excel dialect but you can specify either the dialect name or a instance. Suppose you had data with unenclosed quotes: By default, uses the Excel dialect and treats the double quote as the quote character, which causes it to fail when it finds a newline before it finds the closing double quote. We can get around this using : All of the dialect options can be specified separately by keyword arguments: Another common dialect option is , to skip any whitespace after a delimiter: The parsers make every attempt to “do the right thing” and not be fragile. Type inference is a pretty big deal. If a column can be coerced to integer dtype without altering the contents, the parser will do so. Any non-numeric columns will come through as object dtype as with the rest of pandas objects. Quotes (and other escape characters) in embedded fields can be handled in any number of ways. One way is to use backslashes; to properly parse this data, you should pass the option: \"hello, \\\"Bob\\\", nice to see you\",5 0 hello, \"Bob\", nice to see you 5 While reads delimited data, the function works with data files that have known and fixed column widths. The function parameters to are largely the same as with two extra parameters, and a different usage of the parameter:\n• None : A list of pairs (tuples) giving the extents of the fixed-width fields of each line as half-open intervals (i.e., [from, to[ ). String value ‘infer’ can be used to instruct the parser to try detecting the column specifications from the first 100 rows of the data. Default behavior, if not specified, is to infer.\n• None : A list of field widths which can be used instead of ‘colspecs’ if the intervals are contiguous.\n• None : Characters to consider as filler characters in the fixed-width file. Can be used to specify the filler character of the fields if it is not spaces (e.g., ‘~’). In order to parse this file into a , we simply need to supply the column specifications to the function along with the file name: Note how the parser automatically picks column names X.<column number> when argument is specified. Alternatively, you can supply just the column widths for contiguous columns: The parser will take care of extra white spaces around the columns so it’s ok to have extra separation between the columns in the file. By default, will try to infer the file’s by using the first 100 rows of the file. It can do it only in cases when the columns are aligned and correctly separated by the provided (default delimiter is whitespace). supports the parameter for specifying the types of parsed columns to be different from the inferred type. Consider a file with one less entry in the header than the number of data column: In this special case, assumes that the first column is to be used as the index of the : Note that the dates weren’t automatically parsed. In that case you would need to do as before: Suppose you have data indexed by two columns: The argument to can take a list of column numbers to turn multiple columns into a for the index of the returned object: By specifying list of row locations for the argument, you can read in a for the columns. Specifying non-consecutive rows will skip the intervening rows. is also able to interpret a more common format of multi-columns indices. If an is not specified (e.g. you don’t have an index, or wrote it with , then any on the columns index will be . is capable of inferring delimited (not necessarily comma-separated) files, as pandas uses the class of the csv module. For this, you have to specify . It’s best to use to combine multiple files. See the for an example. Suppose you wish to iterate through a (potentially very large) file lazily rather than reading the entire file into memory, such as the following: By specifying a to , the return value will be an iterable object of type : Specifying will also return the object: Pandas currently supports three engines, the C engine, the python engine, and an experimental pyarrow engine (requires the package). In general, the pyarrow engine is fastest on larger workloads and is equivalent in speed to the C engine on most other workloads. The python engine tends to be slower than the pyarrow and C engines on most workloads. However, the pyarrow engine is much less robust than the C engine, which lacks a few features compared to the Python engine. Where possible, pandas uses the C parser (specified as ), but it may fall back to Python if C-unsupported options are specified. Currently, options unsupported by the C and pyarrow engines include: Specifying any of the above options will produce a unless the python engine is selected explicitly using . Options that are unsupported by the pyarrow engine which are not covered by the list above include: Specifying these options with will raise a . You can pass in a URL to read or write remote files to many of pandas’ IO functions - the following example shows reading a CSV file: A custom header can be sent alongside HTTP(s) requests by passing a dictionary of header key value mappings to the keyword argument as shown below: All URLs which are not local files or HTTP(s) are handled by fsspec, if installed, and its various filesystem implementations (including Amazon S3, Google Cloud, SSH, FTP, webHDFS…). Some of these implementations will require additional packages to be installed, for example S3 URLs require the s3fs library: When dealing with remote storage systems, you might need extra configuration with environment variables or config files in special locations. For example, to access data in your S3 bucket, you will need to define credentials in one of the several ways listed in the S3Fs documentation. The same is true for several of the storage backends, and you should follow the links at fsimpl1 for implementations built into and fsimpl2 for those not included in the main distribution. You can also pass parameters directly to the backend driver. Since does not utilize the environment variable, we can directly define a dictionary containing the endpoint_url and pass the object into the storage option parameter: More sample configurations and documentation can be found at S3Fs documentation. If you do have S3 credentials, you can still access public data by specifying an anonymous connection, such as also allows complex URLs, for accessing data in compressed archives, local caching of files, and more. To locally cache the above example, you would modify the call to where we specify that the “anon” parameter is meant for the “s3” part of the implementation, not to the caching implementation. Note that this caches to a temporary directory for the duration of the session only, but you can also specify a permanent store. The and objects have an instance method which allows storing the contents of the object as a comma-separated-values file. The function takes a number of arguments. Only the first is required.\n• None : A string path to the file to write or a file object. If a file object it must be opened with\n• None : Whether to write out the column names (default True)\n• None : Column label(s) for index column(s) if desired. If None (default), and and are True, then the index names are used. (A sequence should be given if the uses MultiIndex).\n• None : a string representing the encoding to use if the contents are non-ASCII, for Python versions prior to 3\n• None : Set quoting rules as in csv module (default csv.QUOTE_MINIMAL). Note that if you have set a then floats are converted to strings and csv.QUOTE_NONNUMERIC will treat them as non-numeric\n• None : Character used to quote fields (default ‘”’)\n• None : Character used to escape and when appropriate (default None)\n• None : Number of rows to write at a time The object has an instance method which allows control over the string representation of the object. All arguments are optional:\n• None default None, for example a StringIO object\n• None default None, which columns to write\n• None default None, minimum width of each column.\n• None default None, a dictionary (by column) of functions each of which takes a single argument and returns a formatted string\n• None default None, a function which takes a single (float) argument and returns a formatted string; to be applied to floats in the .\n• None default True, set to False for a with a hierarchical index to print every MultiIndex key at each row.\n• None default True, will print the names of the indices The object also has a method, but with only the , , arguments. There is also a argument which, if set to , will additionally output the length of the Series.\n\nA or can be converted to a valid JSON string. Use with optional parameters:\n• None : the pathname or buffer to write the output. This can be in which case a JSON string is returned.\n• The format of the JSON string\n• None : string, type of date conversion, ‘epoch’ for timestamp, ‘iso’ for ISO8601.\n• None : The number of decimal places to use when encoding floating point values, default 10.\n• None : The time unit to encode to, governs timestamp and ISO8601 precision. One of ‘s’, ‘ms’, ‘us’ or ‘ns’ for seconds, milliseconds, microseconds and nanoseconds respectively. Default ‘ms’.\n• None : The handler to call if an object cannot otherwise be converted to a suitable format for JSON. Takes a single argument, which is the object to convert, and returns a serializable object.\n• None : If orient, then will write each record per line as json.\n• None : string, writer mode when writing to path. ‘w’ for write, ‘a’ for append. Default ‘w’ Note ’s, ’s and will be converted to and objects will be converted based on the and parameters. There are a number of different options for the format of the resulting JSON file / string. Consider the following and : Column oriented (the default for ) serializes the data as nested JSON objects with column labels acting as the primary index: # Not available for Series Index oriented (the default for ) similar to column oriented but the index labels are now primary: Record oriented serializes the data to a JSON array of column -> value records, index labels are not included. This is useful for passing data to plotting libraries, for example the JavaScript library : Value oriented is a bare-bones option which serializes to nested JSON arrays of values only, column and index labels are not included: # Not available for Series Split oriented serializes to a JSON object containing separate entries for values, index and columns. Name is also included for : Table oriented serializes to the JSON Table Schema, allowing for the preservation of metadata including but not limited to dtypes and index names. Any orient option that encodes to a JSON object will not preserve the ordering of index and column labels during round-trip serialization. If you wish to preserve label ordering use the option as it uses ordered containers. Writing to a file, with a date index and a date column: If the JSON serializer cannot handle the container contents directly it will fall back in the following manner:\n• None if the dtype is unsupported (e.g. ) then the , if provided, will be called for each value, otherwise an exception is raised.\n• None if an object is unsupported it will attempt the following:\n• None check if the object has defined a method and call it. A method should return a which will then be JSON serialized.\n• None invoke the if one was provided.\n• None convert the object to a by traversing its contents. However this will often fail with an or give unexpected results. In general the best approach for unsupported objects or dtypes is to provide a . For example: can be dealt with by specifying a simple : Reading a JSON string to pandas object can take a number of parameters. The parser will try to parse a if is not supplied or is . To explicitly force parsing, pass\n• None : a VALID JSON string or file handle / StringIO. The string could be a URL. Valid URL schemes include http, ftp, S3, and file. For file URLs, a host is expected. For instance, a local file could be file ://localhost/path/to/table.json\n• None : type of object to recover (series or frame), default ‘frame’\n• The format of the JSON string\n• None : if True, infer dtypes, if a dict of column to dtype, then use those, if , then don’t infer dtypes at all, default is True, apply only to the data.\n• None : boolean, try to convert the axes to the proper dtypes, default is\n• None : a list of columns to parse for dates; If , then try to parse date-like columns, default is .\n• None : boolean, default . If parsing dates, then parse the default date-like columns.\n• None : boolean, default . Set to enable usage of higher precision (strtod) function when decoding string to double values. Default ( ) is to use fast but less precise builtin functionality.\n• None : string, the timestamp unit to detect if converting dates. Default None. By default the timestamp precision will be detected, if this is not desired then pass one of ‘s’, ‘ms’, ‘us’ or ‘ns’ to force timestamp precision to seconds, milliseconds, microseconds or nanoseconds respectively.\n• None : reads file as one json object per line.\n• None : The encoding to use to decode py3 bytes.\n• None : when used in combination with , return a which reads in lines per iteration.\n• None : Either , the built-in JSON parser, or which dispatches to pyarrow’s . The is only available when The parser will raise one of if the JSON is not parseable. If a non-default was used when encoding to JSON be sure to pass the same option here so that decoding produces sensible results, see Orient Options for an overview. The default of , , and will try to parse the axes, and all of the data into appropriate types, including dates. If you need to override specific dtypes, pass a dict to . should only be set to if you need to preserve string-like numbers (e.g. ‘1’, ‘2’) in an axes. Large integer values may be converted to dates if and the data and / or column labels appear ‘date-like’. The exact threshold depends on the specified. ‘date-like’ means that the column label meets one of the following criteria: When reading JSON data, automatic coercing into dtypes has some quirks:\n• None an index can be reconstructed in a different order from serialization, that is, the returned order is not guaranteed to be the same as before serialization\n• None a column that was data will be converted to if it can be done safely, e.g. a column of\n• None bool columns will be converted to on reconstruction Thus there are times where you may want to specify specific dtypes via the keyword argument. Don’t convert any data (but still convert axes and dates): Dates written in nanoseconds need to be read back in nanoseconds: # Try to parse timestamps as milliseconds -> Won't Work # Or specify that all timestamps are in nanoseconds By setting the argument you can control the default dtypes used for the resulting DataFrame. pandas provides a utility function to take a dict or list of dicts and this semi-structured data into a flat table. The max_level parameter provides more control over which level to end normalization. With max_level=1 the following snippet normalizes until 1st nesting level of the provided dict. pandas is able to read and write line-delimited json files that are common in data processing pipelines using Hadoop or Spark. For line-delimited json files, pandas can also return an iterator which reads in lines at a time. This can be useful for large files or to read from a stream. # reader is an iterator that returns ``chunksize`` lines each iteration Line-limited json can also be read using the pyarrow reader by specifying . Table Schema is a spec for describing tabular datasets as a JSON object. The JSON includes information on the field names, types, and other attributes. You can use the orient to build a JSON string with two fields, and . The field contains the key, which itself contains a list of column name to type pairs, including the or (see below for a list of types). The field also contains a field if the (Multi)index is unique. The second field, , contains the serialized data with the orient. The index is included, and any datetimes are ISO 8601 formatted, as required by the Table Schema spec. The full list of types supported are described in the Table Schema spec. This table shows the mapping from pandas types: A few notes on the generated table schema:\n• None The object contains a field. This contains the version of pandas’ dialect of the schema, and will be incremented with each revision.\n• None All dates are converted to UTC when serializing. Even timezone naive values, which are treated as UTC with an offset of 0.\n• None datetimes with a timezone (before serializing), include an additional field with the time zone name (e.g. ).\n• None Periods are converted to timestamps before serialization, and so have the same behavior of being converted to UTC. In addition, periods will contain and additional field with the period’s frequency, e.g. .\n• None Categoricals use the type and an constraint listing the set of possible values. Additionally, an field is included:\n• None A field, containing an array of labels, is included if the index is unique :\n• None The behavior is the same with MultiIndexes, but in this case the is an array:\n• None The default naming roughly follows these rules:\n• None For series, the is used. If that’s none, then the name is\n• None For , the stringified version of the column name is used\n• None For (not ), is used, with a fallback to if that is None.\n• None For , is used. If any level has no name, then is used. also accepts as an argument. This allows for the preservation of metadata such as dtypes and index names in a round-trippable manner. Please note that the literal string ‘index’ as the name of an is not round-trippable, nor are any names beginning with within a . These are used by default in to indicate missing values and the subsequent read cannot distinguish the intent. When using along with user-defined , the generated schema will contain an additional key in the respective element. This extra key is not standard but does enable JSON roundtrips for extension types (e.g. ). The key carries the name of the extension, if you have properly registered the , pandas will use said name to perform a lookup into the registry and re-convert the serialized data into your custom dtype.\n\nThe method can read Excel 2007+ ( ) files using the Python module. Excel 2003 ( ) files can be read using . Binary Excel ( ) files can be read using . All formats can be read using engine. The instance method is used for saving a to Excel. Generally the semantics are similar to working with data. See the for some advanced strategies. When , the following logic will be used to determine the engine:\n• None If is an OpenDocument format (.odf, .ods, .odt), then odf will be used.\n• None Otherwise if is an xls format, will be used.\n• None Otherwise if is in xlsb format, will be used.\n• None Otherwise will be used. In the most basic use-case, takes a path to an Excel file, and the indicating which sheet to parse. When using the parameter, pandas will pass these arguments to the engine. For this, it is important to know which function pandas is using internally.\n• None For the engine openpyxl, pandas is using to read in ( ) and ( ) files.\n• None For the engine xlrd, pandas is using to read in ( ) files.\n• None For the engine pyxlsb, pandas is using to read in ( ) files.\n• None For the engine odf, pandas is using to read in ( ) files.\n• None For the engine calamine, pandas is using to read in ( ), ( ), ( ), ( ), ( ) files. To facilitate working with multiple sheets from the same file, the class can be used to wrap the file and can be passed into There will be a performance benefit for reading multiple sheets as the file is read into memory only once. The class can also be used as a context manager. The property will generate a list of the sheet names in the file. The primary use-case for an is parsing multiple sheets with different parameters: # For when Sheet1's format differs from Sheet2 Note that if the same parsing parameters are used for all sheets, a list of sheet names can simply be passed to with no loss in performance. can also be called with a object as a parameter. This allows the user to control how the excel file is read. For example, sheets can be loaded on demand by calling with . The second argument is , not to be confused with . An ExcelFile’s attribute provides access to a list of sheets.\n• None The arguments allows specifying the sheet or sheets to read.\n• None The default value for is 0, indicating to read the first sheet\n• None Pass a string to refer to the name of a particular sheet in the workbook.\n• None Pass an integer to refer to the index of a sheet. Indices follow Python convention, beginning at 0.\n• None Pass a list of either strings or integers, to return a dictionary of specified sheets.\n• None Pass a to return a dictionary of all available sheets. Using None to get all sheets: Using a list to get multiple sheets: # Returns the 1st and 4th sheet, as a dictionary of DataFrames. can read more than one sheet, by setting to either a list of sheet names, a list of sheet positions, or to read all sheets. Sheets can be specified by sheet index or sheet name, using an integer or string, respectively. can read a index, by passing a list of columns to and a column by passing a list of rows to . If either the or have serialized level names those will be read in as well by specifying the rows/columns that make up the levels. For example, to read in a index without names: If the index has level names, they will parsed as well, using the same parameters. If the source file has both index and columns, lists specifying each should be passed to and : Missing values in columns specified in will be forward filled to allow roundtripping with for . To avoid forward filling the missing values use after reading the data instead of . It is often the case that users will insert columns to do temporary computations in Excel and you may not want to read in those columns. takes a keyword to allow you to specify a subset of columns to parse. You can specify a comma-delimited set of Excel columns and ranges as a string: If is a list of integers, then it is assumed to be the file column indices to be parsed. Element order is ignored, so is the same as . If is a list of strings, it is assumed that each string corresponds to a column name provided either by the user in or inferred from the document header row(s). Those strings define which columns will be parsed: Element order is ignored, so is the same as . If is callable, the callable function will be evaluated against the column names, returning names where the callable function evaluates to . Datetime-like values are normally automatically converted to the appropriate dtype when reading the excel file. But if you have a column of strings that like dates (but are not actually formatted as dates in excel), you can use the keyword to parse those strings to datetimes: It is possible to transform the contents of Excel cells via the option. For instance, to convert a column to boolean: This options handles missing values and treats exceptions in the converters as missing data. Transformations are applied cell by cell rather than to the column as a whole, so the array dtype is not guaranteed. For instance, a column of integers with missing values cannot be transformed to an array with integer dtype, because NaN is strictly a float. You can manually mask missing data to recover integer dtype: As an alternative to converters, the type for an entire column can be specified using the keyword, which takes a dictionary mapping column names to types. To interpret data with no type inference, use the type or . To write a object to a sheet of an Excel file, you can use the instance method. The arguments are largely the same as described above, the first argument being the name of the excel file, and the optional second argument the name of the sheet to which the should be written. For example: Files with a extension will be written using (if available) or . The will be written in a way that tries to mimic the REPL output. The will be placed in the second row instead of the first. You can place it in the first row by setting the option in to : In order to write separate to separate sheets in a single Excel file, one can pass an . When using the parameter, pandas will pass these arguments to the engine. For this, it is important to know which function pandas is using internally.\n• None For the engine openpyxl, pandas is using to create a new sheet and to append data to an existing sheet. The openpyxl engine writes to ( ) and ( ) files.\n• None For the engine xlsxwriter, pandas is using to write to ( ) files.\n• None For the engine odf, pandas is using to write to ( ) files. pandas supports writing Excel files to buffer-like objects such as or using . # By setting the 'engine' in the ExcelWriter constructor. # Seek to the beginning and read to copy the workbook to a variable in memory is optional but recommended. Setting the engine determines the version of workbook produced. Setting will produce an Excel 2003-format workbook (xls). Using either or will produce an Excel 2007-format workbook (xlsx). If omitted, an Excel 2007-formatted workbook is produced. pandas chooses an Excel writer via two methods:\n• None the filename extension (via the default specified in config options) By default, pandas uses the XlsxWriter for , openpyxl for . If you have multiple engines installed, you can set the default engine through and . pandas will fall back on openpyxl for files if Xlsxwriter is not available. To specify which writer you want to use, you can pass an engine keyword argument to and to . The built-in engines are: # By setting the 'engine' in the DataFrame 'to_excel()' methods. # By setting the 'engine' in the ExcelWriter constructor. The look and feel of Excel worksheets created from pandas can be modified using the following parameters on the ’s method.\n• None : A tuple of two integers representing the bottommost row and rightmost column to freeze. Each of these parameters is one-based, so (1, 1) will freeze the first row and first column (default ). Using the Xlsxwriter engine provides many options for controlling the format of an Excel worksheet created with the method. Excellent examples can be found in the Xlsxwriter documentation here: https://xlsxwriter.readthedocs.io/working_with_pandas.html\n\nis a dict-like object which reads and writes pandas using the high performance HDF5 format using the excellent PyTables library. See the for some advanced strategies pandas uses PyTables for reading and writing HDF5 files, which allows serializing object-dtype data with pickle. Loading pickled data received from untrusted sources can be unsafe. See: https://docs.python.org/3/library/pickle.html for more. Objects can be written to the file just like adding key-value pairs to a dict: In a current or later Python session, you can retrieve stored objects: # dotted (attribute) access provides get as well Deletion of the object specified by the key: # Working with, and automatically closing the store using a context manager supports a top-level API using for reading and for writing, similar to how and work. HDFStore will by default not drop rows that are all missing. This behavior can be changed by setting . The examples above show storing using , which write the HDF5 to in a fixed array format, called the format. These types of stores are not appendable once written (though you can simply remove them and rewrite). Nor are they queryable; they must be retrieved in their entirety. They also do not support dataframes with non-unique column names. The format stores offer very fast writing and slightly faster reading than stores. This format is specified by default when using or or by or . A format will raise a if you try to retrieve using a : Traceback (most recent call last) in \"key must be provided when HDF5 \" # if there is an error, close the store if we opened it. in in in in # start, stop applied to rows, so 0th axis only in \"a Fixed format store. this store must be selected in its entirety\" \"cannot pass a where specification when reading \" \"from a Fixed format store. this store must be selected in its entirety\" : cannot pass a where specification when reading from a Fixed format store. this store must be selected in its entirety supports another format on disk, the format. Conceptually a is shaped very much like a DataFrame, with rows and columns. A may be appended to in the same or other sessions. In addition, delete and query type operations are supported. This format is specified by or to or or . This format can be set as an option as well to enable to by default store in the format. You can also create a by passing or to a operation. Keys to a store can be specified as a string. These can be in a hierarchical path-name like format (e.g. ), which will generate a hierarchy of sub-stores (or in PyTables parlance). Keys can be specified without the leading ‘/’ and are always absolute (e.g. ‘foo’ refers to ‘/foo’). Removal operations can remove everything in the sub-store and below, so be . # remove all nodes under this level You can walk through the group hierarchy using the method which will yield a tuple for each group key along with the relative keys of its contents. Hierarchical keys cannot be retrieved as dotted (attribute) access as described above for items stored under the root node. Traceback (most recent call last) in \"\"\"allow attribute access to get stores\"\"\" in in in \"cannot create a storer if the object is not existing \" \"nor a value are passed\" : cannot create a storer if the object is not existing nor a value are passed # you can directly access the actual PyTables node but using the root node Storing mixed-dtype data is supported. Strings are stored as a fixed-width using the maximum size of the appended column. Subsequent attempts at appending longer strings will raise a . Passing as a parameter to append will set a larger minimum for the string columns. Storing are currently supported. For string columns, passing to append will change the default nan representation on disk (which converts to/from ), this defaults to . Storing MultiIndex as tables is very similar to storing/selecting from homogeneous index . # the levels are automatically included as data columns The keyword is reserved and cannot be use as a level name. and operations have an optional criterion that can be specified to select/delete only a subset of the data. This allows one to have a very large on-disk table and retrieve only a portion of the data. A query is specified using the class under the hood, as a boolean expression.\n• None and are supported indexers of .\n• None if are specified, these can be used as additional indexers.\n• None level name in a MultiIndex, with default name , , … if not provided. These rules are similar to how boolean expressions are used in pandas for indexing.\n• None will be automatically expanded to the comparison operator\n• None is the not operator, but can only be used in very limited circumstances\n• None If a list/tuple of expressions is passed they will be combined via The following are valid expressions: The are on the left-hand side of the sub-expression: The right-hand side of the sub-expression (after a comparison operator) can be:\n• None functions that will be evaluated, e.g.\n• None variables that are defined in the local names space, e.g. Passing a string to a query by interpolating it into the query expression is not recommended. Simply assign the string of interest to a variable and use that variable in an expression. For example, do this The latter will not work and will raise a .Note that there’s a single quote followed by a double quote in the variable. If you interpolate, use the format specifier which will quote . The keyword can be supplied to select a list of columns to be returned, this is equivalent to passing a : and parameters can be specified to limit the total search space. These are in terms of the total number of rows in a table. will raise a if the query expression has an unknown variable reference. Usually this means that you are trying to select on a column that is not a data_column. will raise a if the query expression is not valid. You can store and query using the type. Terms can be specified in the format: , where float may be signed (and fractional), and unit can be for the timedelta. Here’s an example: Selecting from a can be achieved by using the name of the level. If the levels names are , the levels are automatically made available via the keyword with the level of the you want to select from. # the levels are automatically included as data columns with keyword level_n You can create/modify an index for a table with after data is already in the table (after and operation). Creating a table index is highly encouraged. This will speed your queries a great deal when you use a with the indexed dimension as the . Indexes are automagically created on the indexables and any data columns you specify. This behavior can be turned off by passing to . # we have automagically already created an index (in the first section) # change an index by passing new parameters Oftentimes when appending large amounts of data to a store, it is useful to turn off index creation for each append, then recreate at the end. Then create the index when finished appending. See here for how to create a completely-sorted-index (CSI) on an existing store. You can designate (and index) certain columns that you want to be able to perform queries (other than the columns, which you can always query). For instance say you want to perform this common operation, on-disk, and return just the frame that matches this query. You can specify to force all columns to be . # this is in-memory version of this type of selection # we have automagically created this index and the B/C/string/string2 There is some performance degradation by making lots of columns into , so it is up to the user to designate these. In addition, you cannot change data columns (nor indexables) after the first append/put operation (Of course you can simply read in the data and create a new table!). You can pass or to and to return an iterator on the results. The default is 50,000 rows returned in a chunk. You can also use the iterator with which will open, then automatically close the store when finished iterating. Note, that the chunksize keyword applies to the source rows. So if you are doing a query, then the chunksize will subdivide the total rows in the table and the query applied, returning an iterator on potentially unequal sized chunks. Here is a recipe for generating a query and using it to create equal sized return chunks. To retrieve a single indexable or data column, use the method . This will, for example, enable you to get the index very quickly. These return a of the result, indexed by the row number. These do not currently accept the selector. Sometimes you want to get the coordinates (a.k.a the index locations) of your query. This returns an of the resulting locations. These coordinates can also be passed to subsequent operations. Sometime your query can involve creating a list of rows to select. Usually this would be a resulting from an indexing operation. This example selects the months of a datetimeindex which are 5. If you want to inspect the stored object, retrieve via . You could use this programmatically to say get the number of rows in an object. The methods and can perform appending/selecting from multiple tables at once. The idea is to have one table (call it the selector table) that you index most/all of the columns, and perform your queries. The other table(s) are data tables with an index matching the selector table’s index. You can then perform a very fast query on the selector table, yet get lots of data back. This method is similar to having a very wide table, but enables more efficient queries. The method splits a given single DataFrame into multiple tables according to , a dictionary that maps the table names to a list of ‘columns’ you want in that table. If is used in place of a list, that table will have the remaining unspecified columns of the given DataFrame. The argument defines which table is the selector table (which you can make queries from). The argument will drop rows from the input to ensure tables are synchronized. This means that if a row for one of the tables being written to is entirely , that row will be dropped from all tables. If is False, THE USER IS RESPONSIBLE FOR SYNCHRONIZING THE TABLES. Remember that entirely rows are not written to the HDFStore, so if you choose to call , some tables may have more rows than others, and therefore may not work or it may return unexpected results. # you can also create the tables individually You can delete from a table selectively by specifying a . In deleting rows, it is important to understand the deletes rows by erasing the rows, then moving the following data. Thus deleting can potentially be a very expensive operation depending on the orientation of your data. To get optimal performance, it’s worthwhile to have the dimension you are deleting be the first of the . Data is ordered (on the disk) in terms of the . Here’s a simple use case. You store panel-type data, with dates in the and ids in the . The data is then interleaved like this: It should be clear that a delete operation on the will be fairly quick, as one chunk is removed, then the following data moved. On the other hand a delete operation on the will be very expensive. In this case it would almost certainly be faster to rewrite the table using a that selects all but the missing data. Please note that HDF5 DOES NOT RECLAIM SPACE in the h5 files automatically. Thus, repeatedly deleting (or removing nodes) and adding again, WILL TEND TO INCREASE THE FILE SIZE. To the file, use . allows the stored data to be compressed. This applies to all kinds of stores, not just tables. Two parameters are used to control compression: and .\n• None specifies if and how hard data is to be compressed. and disables compression and enables compression.\n• None specifies which compression library to use. If nothing is specified the default library is used. A compression library usually optimizes for either good compression rates or speed and the results will depend on the type of data. Which type of compression to choose depends on your specific needs and data. The list of supported compression libraries:\n• None zlib: The default compression library. A classic in terms of compression, achieves good compression rates but is somewhat slow.\n• \n• None blosc:blosclz This is the default compressor for\n• None blosc:lz4hc: A tweaked version of LZ4, produces better compression ratios at the expense of speed.\n• None blosc:snappy: A popular compressor used in many places.\n• None blosc:zlib: A classic; somewhat slower than the previous ones, but achieving better compression ratios.\n• None blosc:zstd: An extremely well balanced codec; it provides the best compression ratios among the others above, and at reasonably fast speed. If is defined as something other than the listed libraries a exception is issued. If the library specified with the option is missing on your platform, compression defaults to without further ado. Enable compression for all objects within the file: Or on-the-fly compression (this only applies to tables) in stores where compression is not enabled: offers better write performance when tables are compressed after they are written, as opposed to turning on compression at the very beginning. You can use the supplied utility . In addition, can change compression levels after the fact. Furthermore will the file to allow you to reuse previously deleted space. Alternatively, one can simply remove the file and write again, or use the method. is not-threadsafe for writing. The underlying only supports concurrent reads (via threading or processes). If you need reading and writing at the same time , you need to serialize these operations in a single thread in a single process. You will corrupt your data otherwise. See the (GH 2397) for more information.\n• None If you use locks to manage write access between multiple processes, you may want to use before releasing write locks. For convenience you can use to do this for you.\n• None Once a is created columns (DataFrame) are fixed; only exactly the same columns can be appended\n• None Be aware that timezones (e.g., ) are not necessarily equal across timezone versions. So if data is localized to a specific timezone in the HDFStore using one version of a timezone library and that data is updated with another version, the data will be converted to UTC since these timezones are not considered equal. Either use the same version of timezone library or use with the updated timezone definition. will show a if a column name cannot be used as an attribute selector. identifiers contain only letters, numbers, and underscores, and may not begin with a number. Other identifiers cannot be used in a clause and are generally a bad idea. will map an object dtype to the underlying dtype. This means the following types are known to work: categorical : see the section below columns are not supported, and WILL FAIL. You can write data that contains dtypes to a . Queries work the same as if it was an object array. However, the dtyped data is stored in a more efficient manner. The underlying implementation of uses a fixed column width (itemsize) for string columns. A string column itemsize is calculated as the maximum of the length of data (for that column) that is passed to the , in the first append. Subsequent appends, may introduce a string for a column larger than the column can hold, an Exception will be raised (otherwise you could have a silent truncation of these columns, leading to loss of information). In the future we may relax this and allow a user-specified truncation to occur. Pass on the first table creation to a-priori specify the minimum length of a particular string column. can be an integer, or a dict mapping a column name to an integer. You can pass as a key to allow all or to have this min_itemsize. Passing a dict will cause all passed columns to be created as automatically. If you are not passing any , then the will be the maximum of the length of any string passed # A and B have a size of 30 # A is created as a data_column with a size of 30 String columns will serialize a (a missing value) with the string representation. This defaults to the string value . You could inadvertently turn an actual value into a missing value. # here you need to specify a different nan rep\n• None format come with a writing performance penalty as compared to stores. The benefit is the ability to append/delete and query (potentially very large amounts of data). Write times are generally longer as compared with regular stores. Query times can be quite fast, especially on an indexed axis.\n• None You can pass to , specifying the write chunksize (default is 50000). This will significantly lower your memory usage on writing.\n• None You can pass to the first , to set the TOTAL number of rows that will expect. This will optimize read/write performance.\n• None Duplicate rows can be written to tables, but are filtered out in selection (with the last items being selected; thus a table is unique on major, minor pairs)\n• None A will be raised if you are attempting to store types that will be pickled by PyTables (rather than stored as endemic types). See Here for more information and some solutions.\n\nThe module provides a collection of query wrappers to both facilitate data retrieval and to reduce dependency on DB-specific API. Where available, users may first want to opt for Apache Arrow ADBC drivers. These drivers should provide the best performance, null handling, and type detection. For a full list of ADBC drivers and their development status, see the ADBC Driver Implementation Status documentation. Where an ADBC driver is not available or may be missing functionality, users should opt for installing SQLAlchemy alongside their database driver library. Examples of such drivers are psycopg2 for PostgreSQL or pymysql for MySQL. For SQLite this is included in Python’s standard library by default. You can find an overview of supported drivers for each SQL dialect in the SQLAlchemy docs. If SQLAlchemy is not installed, you can use a in place of a SQLAlchemy engine, connection, or URI string. See also some for some advanced strategies. The function is a convenience wrapper around and (and for backward compatibility) and will delegate to specific function depending on the provided input (database table name or sql query). Table names do not need to be quoted if they have special characters. In the following example, we use the SQlite SQL database engine. You can use a temporary SQLite database where data are stored in “memory”. To connect using an ADBC driver you will want to install the using your package manager. Once installed, you can use the DBAPI interface provided by the ADBC driver to connect to your database. To connect with SQLAlchemy you use the function to create an engine object from database URI. You only need to create the engine once per database you are connecting to. For more information on and the URI formatting, see the examples below and the SQLAlchemy documentation If you want to manage your own connections you can pass one of those instead. The example below opens a connection to the database using a Python context manager that automatically closes the connection after the block has completed. See the SQLAlchemy docs for an explanation of how the database connection is handled. When you open a connection to a database you are also responsible for closing it. Side effects of leaving a connection open may include locking the database or other breaking behaviour. Assuming the following data is in a , we can insert it into the database using . With some databases, writing large DataFrames can result in errors due to packet size limitations being exceeded. This can be avoided by setting the parameter when calling . For example, the following writes to the database in batches of 1000 rows at a time: Ensuring consistent data type management across SQL databases is challenging. Not every SQL database offers the same types, and even when they do the implementation of a given type can vary in ways that have subtle effects on how types can be preserved. For the best odds at preserving database types users are advised to use ADBC drivers when available. The Arrow type system offers a wider array of types that more closely match database types than the historical pandas/NumPy type system. To illustrate, note this (non-exhaustive) listing of types available in different databases and pandas backends: Not implemented as of writing, but theoretically possible If you are interested in preserving database types as best as possible throughout the lifecycle of your DataFrame, users are encouraged to leverage the argument of This will prevent your data from being converted to the traditional pandas/NumPy type system, which often converts SQL types in ways that make them impossible to round-trip. In case an ADBC driver is not available, will try to map your data to an appropriate SQL data type based on the dtype of the data. When you have columns of dtype , pandas will try to infer the data type. You can always override the default type by specifying the desired SQL type of any of the columns by using the argument. This argument needs a dictionary mapping column names to SQLAlchemy types (or strings for the sqlite3 fallback mode). For example, specifying to use the sqlalchemy type instead of the default type for string columns: Due to the limited support for timedelta’s in the different database flavors, columns with type will be written as integer values as nanoseconds to the database and a warning will be raised. The only exception to this is when using the ADBC PostgreSQL driver in which case a timedelta will be written to the database as an Columns of dtype will be converted to the dense representation as you would get with (e.g. for string categories this gives an array of strings). Because of this, reading the database table back in does not generate a categorical. Using ADBC or SQLAlchemy, is capable of writing datetime data that is timezone naive or timezone aware. However, the resulting data stored in the database ultimately depends on the supported data type for datetime data of the database system being used. The following table lists supported data types for datetime data for some common databases. Other database dialects may have different data types for datetime data. When writing timezone aware data to databases that do not support timezones, the data will be written as timezone naive timestamps that are in local time with respect to the timezone. is also capable of reading datetime data that is timezone aware or naive. When reading types, pandas will convert the data to UTC. The parameter controls the SQL insertion clause used. Possible values are:\n• None : Uses standard SQL clause (one per row).\n• None : Pass multiple values in a single clause. It uses a SQL syntax not supported by all backends. This usually provides better performance for analytic databases like and , but has worse performance for traditional SQL backend if the table contains many columns. For more information check the SQLAlchemy documentation.\n• None callable with signature : This can be used to implement a more performant insertion method based on specific backend dialect features. Example of a callable using PostgreSQL COPY clause: # Alternative to_sql() *method* for DBs that support COPY FROM data_iter : Iterable that iterates the values to be inserted # gets a DBAPI connection that can provide a cursor will read a database table given the table name and optionally a subset of columns to read. In order to use , you must have the ADBC driver or SQLAlchemy optional dependency installed. ADBC drivers will map database types directly back to arrow types. For other drivers note that pandas infers column dtypes from query outputs, and not by looking up data types in the physical database schema. For example, assume is an integer column in a table. Then, intuitively, will return integer-valued series, while will return object-valued (str) series. Accordingly, if the query output is empty, then all resulting columns will be returned as object-valued (since they are most general). If you foresee that your query will sometimes generate an empty result, you may want to explicitly typecast afterwards to ensure dtype integrity. You can also specify the name of the column as the index, and specify a subset of columns to be read. And you can explicitly force columns to be parsed as dates: If needed you can explicitly specify a format string, or a dict of arguments to pass to : You can check if a table exists using Reading from and writing to different schema’s is supported through the keyword in the and functions. Note however that this depends on the database flavor (sqlite does not have schema’s). For example: You can query using raw SQL in the function. In this case you must use the SQL variant appropriate for your database. When using SQLAlchemy, you can also pass SQLAlchemy Expression language constructs, which are database-agnostic. Of course, you can specify a more “complex” query. The function supports a argument. Specifying this will return an iterator through chunks of the query result: To connect with SQLAlchemy you use the function to create an engine object from database URI. You only need to create the engine once per database you are connecting to. For more information see the examples the SQLAlchemy documentation You can use SQLAlchemy constructs to describe your query. Use to specify query parameters in a backend-neutral way If you have an SQLAlchemy description of your database you can express where conditions using SQLAlchemy expressions You can combine SQLAlchemy expressions with parameters passed to using The use of sqlite is supported without using SQLAlchemy. This mode requires a Python database adapter which respect the Python DB-API. You can create connections like so: And then issue the following queries:"
    },
    {
        "link": "https://pandas.pydata.org/pandas-docs/version/2.1/reference/api/pandas.read_excel.html",
        "document": "Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, and file. For file URLs, a host is expected. A local file could be: . If you want to pass in a path object, pandas accepts any . By file-like object, we refer to objects with a method, such as a file handle (e.g. via builtin function) or . Deprecated since version 2.1.0: Passing byte strings is deprecated. To read from a byte string, wrap it in a object.\n\nColumn (0-indexed) to use as the row labels of the DataFrame. Pass None if there is no such column. If a list is passed, those columns will be combined into a . If a subset of data is selected with , index_col is based on the subset. Missing values will be forward filled to allow roundtripping with for . To avoid forward filling the missing values use after reading the data instead of .\n\nLine numbers to skip (0-indexed) or number of lines to skip (int) at the start of the file. If callable, the callable function will be evaluated against the row indices, returning True if the row should be skipped and False otherwise. An example of a valid callable argument would be .\n\nWhether or not to include the default NaN values when parsing the data. Depending on whether is passed in, the behavior is as follows:\n• None If is True, and are specified, is appended to the default NaN values used for parsing.\n• None If is True, and are not specified, only the default NaN values are used for parsing.\n• None If is False, and are specified, only the NaN values specified are used for parsing.\n• None If is False, and are not specified, no strings will be parsed as NaN. Note that if is passed in as False, the and parameters will be ignored.\n\nThe behavior is as follows:\n• None bool. If True -> try parsing the index.\n• None list of int or names. e.g. If [1, 2, 3] -> try parsing columns 1, 2, 3 each as a separate date column.\n• None list of lists. e.g. If [[1, 3]] -> combine columns 1 and 3 and parse as a single date column. If a column or index contains an unparsable date, the entire column or index will be returned unaltered as an object data type. If you don`t want to parse some cells as date just change their type in Excel to “Text”. For non-standard datetime parsing, use after .\n\nFunction to use for converting a sequence of string columns to an array of datetime instances. The default uses to do the conversion. Pandas will try to call in three different ways, advancing to the next if an exception occurs: 1) Pass one or more arrays (as defined by ) as arguments; 2) concatenate (row-wise) the string values from the columns defined by into a single array and pass that; and 3) call once for each row using one or more strings (corresponding to the columns defined by ) as arguments. Deprecated since version 2.0.0: Use instead, or read in as and then apply as-needed."
    },
    {
        "link": "https://xlsxwriter.readthedocs.io/working_with_pandas.html",
        "document": "Python Pandas is a Python data analysis library. It can read, filter and re-arrange small and large data sets and output them in a range of formats including Excel.\n\nPandas writes Excel xlsx files using either openpyxl or XlsxWriter.\n\nTo use XlsxWriter with Pandas you specify it as the Excel writer engine: # Create a Pandas Excel writer using XlsxWriter as the engine. # Convert the dataframe to an XlsxWriter Excel object. # Close the Pandas Excel writer and output the Excel file. The output from this would look like the following: See the full example at Example: Pandas Excel example.\n\nIn order to apply XlsxWriter features such as Charts, Conditional Formatting and Column Formatting to the Pandas output we need to access the underlying workbook and worksheet objects. After that we can treat them as normal XlsxWriter objects. Continuing on from the above example we do that as follows: # Create a Pandas Excel writer using XlsxWriter as the engine. # Convert the dataframe to an XlsxWriter Excel object. # Get the xlsxwriter objects from the dataframe writer object. This is equivalent to the following code when using XlsxWriter on its own: The Workbook and Worksheet objects can then be used to access other XlsxWriter features, see below.\n\nOnce we have the Workbook and Worksheet objects, as shown in the previous section, we we can use them to apply other features such as adding a chart: # Get the xlsxwriter objects from the dataframe writer object. # Get the dimensions of the dataframe. # Configure the series of the chart from the dataframe data. # Insert the chart into the worksheet. The output would look like this: See the full example at Example: Pandas Excel output with a chart.\n\nXlsxWriter and Pandas provide very little support for formatting the output data from a dataframe apart from default formatting such as the header and index cells and any cells that contain dates or datetimes. In addition it isn’t possible to format any cells that already have a default format applied. If you require very controlled formatting of the dataframe output then you would probably be better off using Xlsxwriter directly with raw data taken from Pandas. However, some formatting options are available. For example it is possible to set the default date and datetime formats via the Pandas interface: See the full example at Example: Pandas Excel output with datetimes. It is possible to format any other, non date/datetime column data using : # Set the format but not the column width. See the full example at Example: Pandas Excel output with column formatting.\n\nPandas writes the dataframe header with a default cell format. Since it is a cell format it cannot be overridden using . If you wish to use your own format for the headings then the best approach is to turn off the automatic header from Pandas and write your own. For example: # Turn off the default header and skip one row to allow us to insert a # Get the xlsxwriter workbook and worksheet objects. # Write the column headers with the defined format. See the full example at Example: Pandas Excel output with user defined header format.\n\nAs explained in Working with Worksheet Tables, tables in Excel are a way of grouping a range of cells into a single entity, like this: The way to do this with a Pandas dataframe is to first write the data without the index or header, and by starting 1 row forward to allow space for the table header: We then create a list of headers to use in : Finally we add the Excel table structure, based on the dataframe and with the column headers we generated from the dataframe columns: See the full example at Example: Pandas Excel output with a worksheet table.\n\nAs explained in Working with Autofilters, autofilters in Excel are a way of filtering a 2d range of data to only display rows that match a user defined criteria. The way to do this with a Pandas dataframe is to first write the data without the index (unless you want to include it in the filtered data): We then get the dataframe and add the autofilter: We can also add an optional filter criteria. The placeholder “Region” in the filter is ignored and can be any string that adds clarity to the expression: However, it isn’t enough to just apply the criteria. The rows that don’t match must also be hidden. We use Pandas to figure our which rows to hide: This gives us a filtered worksheet like this: See the full example at Example: Pandas Excel output with an autofilter.\n\nIt is possible to write more than one dataframe to a worksheet or to several worksheets. For example to write multiple dataframes to multiple worksheets: # Write each dataframe to a different worksheet. See the full example at Example: Pandas Excel with multiple dataframes. It is also possible to position multiple dataframes within the same worksheet: # Position the dataframes in the worksheet. # Write the dataframe without the header and index. See the full example at Example: Pandas Excel dataframe positioning."
    },
    {
        "link": "https://stackoverflow.com/questions/72777237/pandas-style-to-excel-using-xlsxwriter-as-engine",
        "document": "I am trying to return background color and font size but it only works when I return only one value, what's wrong in my code ?\n\nthis one wont work, I get this error :\n\nbut if I return only one it works either fontsize or color\n\nThanks for your help in advanced Dini"
    },
    {
        "link": "https://stackoverflow.com/questions/56921069/how-can-i-use-xlsxwriter-and-excelwriter-together-to-populate-an-excel-file-whic",
        "document": "I am writing a program in python that will work on a csv dataset. The aim of the code is to export the aggregated output in an excel, along with hardcoded header information. The excel file is a final report that is sent to the client; means full and final (as shown in below image).\n\nThis is how I begin: I first created a typical header of the report using xlsxwriter and then tried to export the summary DataFrame (i.e. main table output) below the header using Excelwriter- DataFrame.to_excel\n\nBut as soon as I paste the DataFrame in the excel template I created in above step, the initially created header is wiped out, the cells appear blank. And only the DataFrame (table output) is displayed.\n\nAlternatively, if I first export the dataFrame to the excel and then try to add a header to the excel report, header remains but the DataFrame is gone now.\n\nWhat should I do in order to retain both; dataframe (table output) and header information? I used xlsxwritter, excelwriter of pandas.\n\nBelow are few lines of codes that might be important to explain the story."
    },
    {
        "link": "https://reddit.com/r/learnpython/comments/ond9me/whats_the_fastest_way_to_export_a_dataframe_to_an",
        "document": "I got a dataframe with 70k rows and 50 columns, it takes ages to export it to excel with the df.to_excel() method.\n\n[Updated] From the comments it seems clear that it's supposed to be a quick thing. In my case it's slow as hell (20 min). Further context:\n• it's an ETL solution developed in PyCharm at one point it dumps an excel file into a folder.\n• I got a strong developer computer, hardware is not an issue.\n\nWhat could cause such slowness? It is completely baffling me\n\nI had to install xlsxwriter and use that as an export engine:\n\nThis made the process reasonably faster (40sec), but csv export ( ) is the fastest (1sec)."
    },
    {
        "link": "https://dataquest.io/blog/excel-and-pandas",
        "document": "Using Excel with Python and Pandas\n\nWhy learn to work with Excel with Python? Excel is one of the most popular and widely-used data tools; it's hard to find an organization that doesn't work with it in some way. From analysts, to sales VPs, to CEOs, various professionals use Excel for both quick stats and serious data crunching.\n\nWith Excel being so pervasive, data professionals must be familiar with it. Working with data in Python or R offers serious advantages over Excel's UI, so finding a way to work with Excel using code is critical. Thankfully, there's a great tool already out there for using Excel with Python called .\n\nPandas has excellent methods for reading all kinds of data from Excel files. You can also export your results from pandas back to Excel, if that's preferred by your intended audience. Pandas is great for other routine data analysis tasks, such as:\n• taking cleaned and processed data to any number of data tools\n\nPandas is better at automating data processing tasks than Excel, including processing Excel files.\n\nIn this tutorial, we are going to show you how to work with Excel files in pandas. We will cover the following concepts.\n• setting up your computer with the necessary software\n• reading in data from Excel files into pandas\n• visualizing data in pandas using the matplotlib visualization library\n\nNote that this tutorial does not provide a deep dive into pandas. To explore pandas more, check out our course.\n\nWe will use Python 3 and Jupyter Notebook to demonstrate the code in this tutorial.In addition to Python and Jupyter Notebook, you will need the following Python modules:\n\nThere are multiple ways to get set up with all the modules. We cover three of the most common scenarios below.\n• If you have Python installed via Anaconda package manager, you can install the required modules using the command . For example, to install pandas, you would execute the command - .\n• If you already have a regular, non-Anaconda Python installed on the computer, you can install the required modules using . Open your command line program and execute command to install a module. You should replace with the actual name of the module you are trying to install. For example, to install pandas, you would execute command - .\n• If you don't have Python already installed, you should get it through the Anaconda package manager. Anaconda provides installers for Windows, Mac, and Linux Computers. If you choose the full installer, you will get all the modules you need, along with Python and pandas within a single package. This is the easiest and fastest way to get started.\n\nIn this tutorial, we will use a multi-sheet Excel file we created from Kaggle's IMDB Scores data. You can download the file here.\n\nOur Excel file has three sheets: '1900s,' '2000s,' and '2010s.' Each sheet has data for movies from those years.\n\nWe will use this data set to find the ratings distribution for the movies, visualize movies with highest ratings and net earnings and calculate statistical information about the movies. We will be analyzing and exploring this data using Python and pandas, thus demonstrating pandas capabilities for working with Excel data in Python.\n\nWe need to first import the data from the Excel file into pandas. To do that, we start by importing the pandas module.\n\nWe then use the pandas' read_excel method to read in data from the Excel file. The easiest way to call this method is to pass the file name. If no sheet name is specified then it will read the first sheet in the index (as shown below).\n\nHere, the method read the data from the Excel file into a pandas DataFrame object. Pandas defaults to storing data in DataFrames. We then stored this DataFrame into a variable called .\n\nPandas has a built-in method that we can use to easily display the first few rows of our DataFrame. If no argument is passed, it will display first five rows. If a number is passed, it will display the equal number of rows from the top.\n\nExcel files quite often have multiple sheets and the ability to read a specific sheet or all of them is very important. To make this easy, the pandas method takes an argument called that tells pandas which sheet to read in the data from. For this, you can either use the sheet name or the sheet number. Sheet numbers start with zero. If the argument is not given, it defaults to zero and pandas will import the first sheet.\n\nBy default, pandas will automatically assign a numeric index or row label starting with zero. You may want to leave the default index as such if your data doesn't have a column with unique values that can serve as a better index. In case there is a column that you feel would serve as a better index, you can override the default behavior by setting property to a column. It takes a numeric value for setting a single column as index or a list of numeric values for creating a multi-index.\n\nIn the below code, we are choosing the first column, 'Title', as index (index=0) by passing zero to the argument.\n\nAs you noticed above, our Excel data file has three sheets. We already read the first sheet in a DataFrame above. Now, using the same syntax, we will read in rest of the two sheets too.\n\nSince all the three sheets have similar data but for different recordsmovies, we will create a single DataFrame from all the three DataFrames we created above. We will use the pandas method for this and pass in the names of the three DataFrames we just created and assign the results to a new DataFrame object, . By keeping the DataFrame name same as before, we are over-writing the previously created DataFrame.\n\nWe can check if this concatenation by checking the number of rows in the combined DataFrame by calling the method on it that will give us the number of rows and columns.\n\nUsing the ExcelFile class to read multiple sheets\n\nWe can also use the ExcelFile class to work with multiple sheets from the same Excel file. We first wrap the Excel file using and then pass it to method.\n\nIf you are reading an Excel file with a lot of sheets and are creating a lot of DataFrames, is more convenient and efficient in comparison to . With ExcelFile, you only need to pass the Excel file once, and then you can use it to get the DataFrames. When using , you pass the Excel file every time and hence the file is loaded again for every sheet. This can be a huge performance drag if the Excel file has many sheets with a large number of rows.\n\nNow that we have read in the movies data set from our Excel file, we can start exploring it using pandas. A pandas DataFrame stores the data in a tabular format, just like the way Excel displays the data in a sheet. Pandas has a lot of built-in methods to explore the DataFrame we created from the Excel file we just read in.\n\nWe already introduced the method in the previous section that displays few rows from the top from the DataFrame. Let's look at few more methods that come in handy while exploring the data set.\n\nWe can use the method to find out the number of rows and columns for the DataFrame.\n\nThis tells us our Excel file has 5042 records and 25 columns or observations. This can be useful in reporting the number of records and columns and comparing that with the source data set.\n\nWe can use the method to view the bottom rows. If no parameter is passed, only the bottom five rows are returned.\n\nIn Excel, you're able to sort a sheet based on the values in one or more columns. In pandas, you can do the same thing with the method. For example, let's sort our movies DataFrame based on the Gross Earnings column.\n\nSince we have the data sorted by values in a column, we can do few interesting things with it. For example, we can display the top 10 movies by Gross Earnings.\n\nWe can also create a plot for the top 10 movies by Gross Earnings. Pandas makes it easy to visualize your data with plots and charts through matplotlib, a popular data visualization library. With a couple lines of code, you can start plotting. Moreover, matplotlib plots work well inside Jupyter Notebooks since you can displace the plots right under the code.\n\nFirst, we import the matplotlib module and set matplotlib to display the plots right in the Jupyter Notebook.\n\nWe will draw a bar plot where each bar will represent one of the top 10 movies. We can do this by calling the plot method and setting the argument to . This tells to draw a horizontal bar plot.\n\nLet's create a histogram of IMDB Scores to check the distribution of IMDB Scores across all movies. Histograms are a good way to visualize the distribution of a data set. We use the method on the IMDB Scores series from our movies DataFrame and pass it the argument.\n\nThis data visualization suggests that most of the IMDB Scores fall between six and eight.\n\nGetting statistical information about the data\n\nPandas has some very handy methods to look at the statistical data about our data set. For example, we can use the method to get a statistical summary of the data set.\n\nThe method displays below information for each of the columns.\n• the count or number of values\n\nPlease note that this information will be calculated only for the numeric values.\n\nWe can also use the corresponding method to access this information one at a time. For example, to get the mean of a particular column, you can use the method on that column.\n\nJust like mean, there are methods available for each of the statistical information we want to access. You can read about these methods in our free pandas cheat sheet.\n\nReading files with no header and skipping records\n\nEarlier in this tutorial, we saw some ways to read a particular kind of Excel file that had headers and no rows that needed skipping. Sometimes, the Excel sheet doesn't have any header row. For such instances, you can tell pandas not to consider the first row as header or columns names. And If the Excel sheet's first few rows contain data that should not be read in, you can ask the method to skip a certain number of rows, starting from the top.\n\nFor example, look at the top few rows of this Excel file.\n\nThis file obviously has no header and first four rows are not actual records and hence should not be read in. We can tell read_excel there is no header by setting argument to and we can skip first four rows by setting argument to four.\n\nWe skipped four rows from the sheet and used none of the rows as the header. Also, notice that one can combine different options in a single read statement. To skip rows at the bottom of the sheet, you can use option , which works just like , the only difference being the rows are counted from the bottom upwards.\n\nThe column names in the previous DataFrame are numeric and were allotted as default by the pandas. We can rename the column names to descriptive ones by calling the method on the DataFrame and passing the column names as a list.\n\nNow that we have seen how to read a subset of rows from the Excel file, we can learn how to read a subset of columns.\n\nAlthough read_excel defaults to reading and importing all columns, you can choose to import only certain columns. By passing parse_cols=6, we are telling the method to read only the first columns till index six or first seven columns (the first column being indexed zero).\n\nAlternatively, you can pass in a list of numbers, which will let you import columns at particular indexes.\n\nOne of the much-used features of Excel is to apply formulas to create new columns from existing column values. In our Excel file, we have Gross Earnings and Budget columns. We can get Net earnings by subtracting Budget from Gross earnings. We could then apply this formula in the Excel file to all the rows. We can do this in pandas also as shown below.\n\nAbove, we used pandas to create a new column called Net Earnings, and populated it with the difference of Gross Earnings and Budget. It's worth noting the difference here in how formulas are treated in Excel versus pandas. In Excel, a formula lives in the cell and updates when the data changes - with Python, the calculations happen and the values are stored - if Gross Earnings for one movie was manually changed, Net Earnings won't be updated.\n\nLet's use the method to sort the data by the new column we created and visualize the top 10 movies by Net Earnings.\n\nAdvanced Excel users also often use pivot tables. A pivot table summarizes the data of another table by grouping the data on an index and applying operations such as sorting, summing, or averaging. You can use this feature in pandas too.\n\nWe need to first identify the column or columns that will serve as the index, and the column(s) on which the summarizing formula will be applied. Let's start small, by choosing Year as the index column and Gross Earnings as the summarization column and creating a separate DataFrame from this data.\n\nWe now call on this subset of data. The method takes a parameter . As mentioned, we want to use Year as the index.\n\nThis gave us a pivot table with grouping on Year and summarization on the sum of Gross Earnings. Notice, we didn't need to specify Gross Earnings column explicitly as pandas automatically identified it the values on which summarization should be applied.\n\nWe can use this pivot table to create some data visualizations. We can call the method on the DataFrame to create a line plot and call the method to display the plot in the notebook.\n\nWe saw how to pivot with a single column as the index. Things will get more interesting if we can use multiple columns. Let's create another DataFrame subset but this time we will choose the columns, Country, Language and Gross Earnings.\n\nWe will use columns Country and Language as the index for the pivot table. We will use Gross Earnings as summarization table, however, we do not need to specify this explicitly as we saw earlier.\n\nLet's visualize this pivot table with a bar plot. Since there are still few hundred records in this pivot table, we will plot just a few of them.\n\nIf you're going to be working with colleagues who use Excel, saving Excel files out of pandas is important. You can export or write a pandas DataFrame to an Excel file using pandas method. Pandas uses the Python module internally for writing to Excel files. The method is called on the DataFrame we want to export.We also need to pass a filename to which this DataFrame will be written.\n\nBy default, the index is also saved to the output file. However, sometimes the index doesn't provide any useful information. For example, the DataFrame has a numeric auto-increment index, that was not part of the original Excel data.\n\nYou can choose to skip the index by passing along index-False.\n\nWe need to be able to make our output files look nice before we can send it out to our co-workers. We can use pandas class along with the Python module to apply the formatting.\n\nWe can do use these advanced output options by creating a object and use this object to write to the EXcel file.\n\nWe can apply customizations by calling on the workbook we are writing to. Here we are setting header format as bold.\n\nFinally, we save the output file by calling the method on the writer object.\n\nAs an example, we saved the data with column headers set as bold. And the saved file looks like the image below.\n\nLike this, one can use to apply various formatting to the output Excel file.\n\nPandas is not a replacement for Excel. Both tools have their place in the data analysis workflow and can be very great companion tools. As we demonstrated, pandas can do a lot of complex data analysis and manipulations, which depending on your need and expertise, can go beyond what you can achieve if you are just using Excel. One of the major benefits of using Python and pandas over Excel is that it helps you automate Excel file processing by writing scripts and integrating with your automated data workflow. Pandas also has excellent methods for reading all kinds of data from Excel files. You can export your results from pandas back to Excel too if that's preferred by your intended audience.\n\nOn the other hand, Excel is a such a widely used data tool, it's not a wise to ignore it. Acquiring expertise in both pandas and Excel and making them work together gives you skills that can help you stand out in your organization.\n\nIf you’d like to learn more about this topic, check out Dataquest's interactive Pandas and NumPy Fundamentals course, and our Data Analyst in Python, and Data Scientist in Python paths that will help you become job-ready in around 6 months."
    }
]