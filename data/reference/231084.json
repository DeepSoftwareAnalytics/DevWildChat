[
    {
        "link": "https://docs.python.org/3/library/math.html",
        "document": "This module provides access to the mathematical functions defined by the C standard.\n\nThese functions cannot be used with complex numbers; use the functions of the same name from the module if you require support for complex numbers. The distinction between functions which support complex numbers and those which don’t is made since most users do not want to learn quite as much mathematics as required to understand complex numbers. Receiving an exception instead of a complex result allows earlier detection of the unexpected complex number used as a parameter, so that the programmer can determine how and why it was generated in the first place.\n\nThe following functions are provided by this module. Except when explicitly noted otherwise, all return values are floats.\n\nReturn the number of ways to choose k items from n items without repetition and without order. Evaluates to when and evaluates to zero when . Also called the binomial coefficient because it is equivalent to the coefficient of k-th term in polynomial expansion of . Raises if either of the arguments are not integers. Raises if either of the arguments are negative. Return n factorial as an integer. Raises if n is not integral or is negative. Changed in version 3.10: Floats with integral values (like ) are no longer accepted. Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is . without arguments returns . Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using . Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is . without arguments returns . Return the number of ways to choose k items from n items without repetition and with order. Evaluates to when and evaluates to zero when . If k is not specified or is , then k defaults to n and the function returns . Raises if either of the arguments are not integers. Raises if either of the arguments are negative.\n\nReturn the ceiling of x, the smallest integer greater than or equal to x. If x is not a float, delegates to , which should return an value. Return the absolute value of x. Return the floor of x, the largest integer less than or equal to x. If x is not a float, delegates to , which should return an value. Fused multiply-add operation. Return , computed as though with infinite precision and range followed by a single round to the format. This operation often provides better accuracy than the direct expression . This function follows the specification of the fusedMultiplyAdd operation described in the IEEE 754 standard. The standard leaves one case implementation-defined, namely the result of and . In these cases, returns a NaN, and does not raise any exception. Return the floating-point remainder of , as defined by the platform C library function . Note that the Python expression may not return the same result. The intent of the C standard is that be exactly (mathematically; to infinite precision) equal to for some integer n such that the result has the same sign as x and magnitude less than . Python’s returns a result with the sign of y instead, and may not be exactly computable for float arguments. For example, is , but the result of Python’s is , which cannot be represented exactly as a float, and rounds to the surprising . For this reason, function is generally preferred when working with floats, while Python’s is preferred when working with integers. Return the fractional and integer parts of x. Both results carry the sign of x and are floats. Note that has a different call/return pattern than its C equivalents: it takes a single argument and return a pair of values, rather than returning its second return value through an ‘output parameter’ (there is no such thing in Python). Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference , where is the closest integer to the exact value of the quotient . If is exactly halfway between two consecutive integers, the nearest even integer is used for . The remainder thus always satisfies . Special cases follow IEEE 754: in particular, is x for any finite x, and and raise for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating point, the result of this operation is always exactly representable: no rounding error is introduced. Return x with the fractional part removed, leaving the integer part. This rounds toward 0: is equivalent to for positive x, and equivalent to for negative x. If x is not a float, delegates to , which should return an value. For the , , and functions, note that all floating-point numbers of sufficiently large magnitude are exact integers. Python floats typically carry no more than 53 bits of precision (the same as the platform C double type), in which case any float x with necessarily has no fractional bits.\n\nReturn a float with the magnitude (absolute value) of x but the sign of y. On platforms that support signed zeros, returns -1.0. Return the mantissa and exponent of x as the pair . m is a float and e is an integer such that exactly. If x is zero, returns , otherwise . This is used to “pick apart” the internal representation of a float in a portable way. Note that has a different call/return pattern than its C equivalents: it takes a single argument and return a pair of values, rather than returning its second return value through an ‘output parameter’ (there is no such thing in Python). Return if the values a and b are close to each other and otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. If no errors occur, the result will be: . rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass . The default tolerance is , which assures that the two values are the same within about 9 decimal digits. rel_tol must be nonnegative and less than . abs_tol is the absolute tolerance; it defaults to and it must be nonnegative. When comparing to , is computed as , which is for any nonzero and rel_tol less than . So add an appropriate positive abs_tol argument to the call. The IEEE 754 special values of , , and will be handled according to IEEE rules. Specifically, is not considered close to any other value, including . and are only considered close to themselves. Return if x is neither an infinity nor a NaN, and otherwise. (Note that is considered finite.) Return if x is a positive or negative infinity, and otherwise. Return if x is a NaN (not a number), and otherwise. Return . This is essentially the inverse of function . Return the floating-point value steps steps after x towards y. If x is equal to y, return y, unless steps is zero.\n• None goes up: towards positive infinity.\n• None goes down: towards minus infinity.\n• None goes towards zero.\n• None goes away from zero. Return the value of the least significant bit of the float x:\n• None If x is a NaN (not a number), return x.\n• None If x is equal to zero, return the smallest positive denormalized representable float (smaller than the minimum positive normalized float, ).\n• None If x is equal to the largest positive representable float, return the value of the least significant bit of x, such that the first float smaller than x is .\n• None Otherwise (x is a positive finite number), return the value of the least significant bit of x, such that the first float bigger than x is . ULP stands for “Unit in the Last Place”. See also and .\n\nReturn e raised to the power x, where e = 2.718281… is the base of natural logarithms. This is usually more accurate than or . Return e raised to the power x, minus 1. Here e is the base of natural logarithms. For small floats x, the subtraction in can result in a significant loss of precision; the function provides a way to compute this quantity to full precision: With one argument, return the natural logarithm of x (to base e). With two arguments, return the logarithm of x to the given base, calculated as . Return the natural logarithm of 1+x (base e). The result is calculated in a way which is accurate for x near zero. Return the base-2 logarithm of x. This is usually more accurate than . returns the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros. Return the base-10 logarithm of x. This is usually more accurate than . Return x raised to the power y. Exceptional cases follow the IEEE 754 standard as far as possible. In particular, and always return , even when x is a zero or a NaN. If both x and y are finite, x is negative, and y is not an integer then is undefined, and raises . Unlike the built-in operator, converts both its arguments to type . Use or the built-in function for computing exact integer powers. Changed in version 3.11: The special cases and were changed to return instead of raising , for consistency with IEEE 754.\n\nReturn the Euclidean distance between two points p and q, each given as a sequence (or iterable) of coordinates. The two points must have the same dimension. Return an accurate floating-point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums. The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating-point summation. Return the Euclidean norm, . This is the length of the vector from the origin to the point given by the coordinates. For a two dimensional point , this is equivalent to computing the hypotenuse of a right triangle using the Pythagorean theorem, . Changed in version 3.8: Added support for n-dimensional points. Formerly, only the two dimensional case was supported. Changed in version 3.10: Improved the algorithm’s accuracy so that the maximum error is under 1 ulp (unit in the last place). More typically, the result is almost always correctly rounded to within 1/2 ulp. Calculate the product of all the elements in the input iterable. The default start value for the product is . When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. Return the sum of products of values from two iterables p and q. Raises if the inputs do not have the same length. For float and mixed int/float inputs, the intermediate products and sums are computed with extended precision.\n\nThe mathematical constant π = 3.141592…, to available precision. The mathematical constant e = 2.718281…, to available precision. The mathematical constant τ = 6.283185…, to available precision. Tau is a circle constant equal to 2π, the ratio of a circle’s circumference to its radius. To learn more about Tau, check out Vi Hart’s video Pi is (still) Wrong, and start celebrating Tau day by eating twice as much pie! A floating-point positive infinity. (For negative infinity, use .) Equivalent to the output of . A floating-point “not a number” (NaN) value. Equivalent to the output of . Due to the requirements of the IEEE-754 standard, and are not considered to equal to any other numeric value, including themselves. To check whether a number is a NaN, use the function to test for NaNs instead of or . Example: Changed in version 3.11: It is now always available. CPython implementation detail: The module consists mostly of thin wrappers around the platform C math library functions. Behavior in exceptional cases follows Annex F of the C99 standard where appropriate. The current implementation will raise for invalid operations like or (where C99 Annex F recommends signaling invalid operation or divide-by-zero), and for results that overflow (for example, ). A NaN will not be returned from any of the functions above unless one or more of the input arguments was a NaN; in that case, most functions will return a NaN, but (again following C99 Annex F) there are some exceptions to this rule, for example or . Note that Python makes no effort to distinguish signaling NaNs from quiet NaNs, and behavior for signaling NaNs remains unspecified. Typical behavior is to treat all NaNs as though they were quiet. Complex number versions of many of these functions."
    },
    {
        "link": "https://mpmath.org/doc/current",
        "document": "Mpmath is a Python library for arbitrary-precision floating-point arithmetic. For general information about mpmath, see the project website http://mpmath.org/\n\nThese documentation pages include general information as well as docstring listing with extensive use of examples that can be run in the interactive Python interpreter. For quick access to the docstrings of individual functions, use the index listing, or type in the Python interactive prompt."
    },
    {
        "link": "https://labex.io/tutorials/python-how-to-use-python-s-math-module-for-advanced-math-415478",
        "document": "The module in Python is a built-in library that provides access to the mathematical functions defined by the C standard. This module allows you to perform a wide range of mathematical operations, from basic arithmetic to advanced trigonometric and logarithmic functions.\n\nTo use the module in your Python script, you need to import it. You can do this by adding the following line at the beginning of your code:\n\nOnce you have imported the module, you can access its functions and constants using the dot notation, like this:\n\nThe module provides a variety of functions and constants that you can use in your Python programs. Some of the most commonly used functions include:\n• : Returns the square root of the given number .\n• : Returns the smallest integer greater than or equal to .\n• : Returns the largest integer less than or equal to .\n\nYou can explore the full list of functions and constants available in the module by checking the Python documentation.\n\nUsing the math Module in Code\n\nLet's look at a simple example that demonstrates how to use the module in your Python code:\n\nIn this example, we import the module, use its functions to perform various mathematical operations, and print the results."
    },
    {
        "link": "https://geeksforgeeks.org/python-math-module",
        "document": "Math Module consists of mathematical functions and constants. It is a built-in module made for mathematical tasks.\n\nThe math module provides the math functions to deal with basic operations such as addition(+), subtraction(-), multiplication(*), division(/), and advanced operations like trigonometric, logarithmic, and exponential functions.\n\nIn this article, we learn about the math module from basics to advanced, we will study the functions with the help of good examples.\n\nWhat is a Math Module in Python?\n\nMath Module is an in-built Python library made to simplify mathematical tasks in Python.\n\nIt consists of various mathematical constants and functions that can be used after importing the math module.\n\nAfter importing the math module, you can use various constants and functions, let’s study some of them\n\nThe Python math module provides various values of various constants like pi, and tau. We can easily write their values with these constants. The constants provided by the math module are :\n\nLet’s see constants in math module with examples:\n\nExample: This code imports the module and then prints the value of the mathematical constant .\n\nYou all must be familiar with pi. The pi is depicted as either 22/7 or 3.14. math.pi provides a more precise value for the pi.\n\nExample 1: This code imports the module and then prints the value of the mathematical constant .\n\nExample 2: Let’s find the area of the circle\n\nThe code utilizes the module in Python, defines a radius and the mathematical constant pi, and calculates the area of a circle using the formula‘ . It demonstrates the application of mathematical concepts and the usage of the module for numerical calculations\n\nTau is defined as the ratio of the circumference to the radius of a circle. The math.tau constant returns the value tau: 6.283185307179586.\n\nExample: This code imports the module and then prints the value of the mathematical constant ‘ .\n\nInfinity basically means something which is never-ending or boundless from both directions i.e. negative and positive. It cannot be depicted by a number. The Python math.inf constant returns of positive infinity. For negative infinity, use -math.inf.\n\nExample 1: This code imports the module and then prints the values of positive and negative infinity.\n\nExample 2: Comparing the values of infinity with the maximum floating point value\n\nThis code imports the module and then compares the values of positive and negative infinity to the values of 10e108 and -10e108, respectively.\n\nThe Python math.nan constant returns a floating-point nan (Not a Number) value. This value is not a legal number. The nan constant is equivalent to float(“nan”).\n\nExample: This code imports the module and then prints the value of . represents Not a Number, which is a special value that is used to indicate that a mathematical operation is undefined or the result is not a number.\n\nHere is the list of all mathematical functions in math module, you can use them when you need it in program:\n\nReturns the smallest integral value greater than the number Returns the number with the value of ‘x’ but with the sign of ‘y’ Returns the absolute value of the number Returns the factorial of the number Returns the greatest integral value smaller than the number Returns the remainder when x is divided by y Returns the mantissa and exponent of x as the pair (m, e) Returns the precise floating-point value of sum of elements in an iterable Check whether the value is neither infinity not Nan Check whether the value is infinity or not Returns true if the number is “nan” else returns false Returns the fractional and integer parts of x Returns the truncated integer value of x Returns the value of e raised to the power x(e**x) Returns the value of e raised to the power a (x-1) Returns the logarithmic value of a with base b Returns the natural logarithmic value of 1+x Computes value of log a with base 2 Computes value of log a with base 10 Compute value of x raised to the power y (x**y) Returns the square root of the number Returns the arc cosine of value passed as argument Returns the arc sine of value passed as argument Returns the arc tangent of value passed as argument Returns the cosine of value passed as argument Returns the hypotenuse of the values passed in arguments Returns the sine of value passed as argument Returns the tangent of the value passed as argument Convert argument value from radians to degrees Convert argument value from degrees to radians Returns the inverse hyperbolic cosine of value passed as argument Returns the inverse hyperbolic sine of value passed as argument Returns the inverse hyperbolic tangent of value passed as argument Returns the hyperbolic cosine of value passed as argument Returns the hyperbolic sine of value passed as argument Returns the hyperbolic tangent of value passed as argument Return the gamma function of the argument Return the natural log of the absolute value of the gamma function\n\nIn this section, we will deal with the functions that are used with number theory as well as representation theory such as finding the factorial of a number. We will discuss these numerical functions along with examples and use-cases.\n\n1. Finding the ceiling and the floor value\n\nCeil value means the smallest integral value greater than the number and the floor value means the greatest integral value smaller than the number. This can be easily calculated using the ceil() and floor() method respectively.\n\nThis code imports the module, assigns the value 2.3 to the variable , and then calculates and prints the ceiling and floor of .\n\nThe ceil of 2.3 is : 3\n\nThe floor of 2.3 is : 2\n\n\n\n2. Finding the factorial of the number\n\nUsing the factorial() function we can find the factorial of a number in a single line of the code. An error message is displayed if number is not integral.\n\nExample: This code imports the module, assigns the value 5 to the variable , and then calculates and prints the factorial of .\n\nThe factorial of 5 is : 120\n\n\n\ngcd() function is used to find the greatest common divisor of two numbers passed as the arguments.\n\nExample: This code imports the module, assigns the values 15 and 5 to the variables and , respectively, and then calculates and prints the greatest common divisor (GCD) of and .\n\nThe gcd of 5 and 15 is : 5\n\n\n\nfabs() function returns the absolute value of the number.\n\nExample: This code imports the module, assigns the value -10 to the variable , and then calculates and prints the absolute value of .\n\nThe absolute value of -10 is : 10.0\n\n\n\nRefer to the below article to get detailed information about the numeric functions.\n\nPower functions can be expressed as x^n where n is the power of x whereas logarithmic functions are considered as the inverse of exponential functions.\n\nexp() method is used to calculate the power of e i.e. [Tex]e^y [/Tex] or we can say exponential of y.\n\nExample: This code imports the module and then calculates and prints the exponential values of three different input values: an integer, a negative integer, and a float.\n\npow() function computes x**y. This function first converts its arguments into float and then computes the power.\n\nExample: This code first prints the string “The value of 3**4 is : ” to the console. Then, it calculates the value of 3 raised to the power of 4 using the function and prints the result to the console.\n\nThe value of 3**4 is : 81.0\n• log() function returns the logarithmic value of a with base b. If the base is not mentioned, the computed value is of the natural log.\n• log2(a) function computes value of log a with base 2. This value is more accurate than the value of the function discussed above.\n• log10(a) function computes value of log a with base 10. This value is more accurate than the value of the function discussed above.\n\nThis code imports the module and then calculates and prints the logarithms of three different numbers. The module provides several functions for working with logarithms, including , , and .\n\nThe value of log 2 with base 3 is : 0.6309297535714574\n\nThe value of log2 of 16 is : 4.0\n\nThe value of log10 of 10000 is : 4.0\n\n\n\nsqrt() function returns the square root of the number.\n\nExample: This code imports the module and then calculates and prints the square roots of three different numbers: 0, 4, and 3.5. The module provides several functions for working with mathematical operations, including the square root function .\n\nRefer to the below article to get detailed information about the Logarithmic and Power Functions\n\nYou all must know about Trigonometric and how it may become difficult to find the values of sine and cosine values of any angle. Math module provides built-in functions to find such values and even to change the values between degrees and radians.\n\nsin(), cos(), and tan() functions returns the sine, cosine, and tangent of value passed as the argument. The value passed in this function should be in radians.\n\nExample: This code first imports the module, which provides a variety of mathematical functions. Then, it defines a variable and assigns it the value of , where is the mathematical constant representing the ratio of a circle’s circumference to its diameter.\n\nThe value of sine of pi/6 is : 0.49999999999999994\n\nThe value of cosine of pi/6 is : 0.8660254037844387\n\nThe value of tangent of pi/6 is : 0.5773502691896257\n\n\n\n2. Converting values from degrees to radians and vice versa\n• degrees() function is used to convert argument value from radians to degrees.\n• radians() function is used to convert argument value from degrees to radians.\n\nExample: This code imports the module, which provides mathematical functions and constants. It then defines two variables: and . is assigned the value of , which is approximately 0.5235987755982988 radians. is assigned the value 30, which is 30 degrees.\n\nThe converted value from radians to degrees is : 29.999999999999996\n\nThe converted value from degrees to radians is : 0.5235987755982988\n\n\n\nRefer to the below articles to get detailed information about the trigonometric and angular functions.\n\nBesides all the numeric, logarithmic functions we have discussed yet, the math module provides some more useful functions that does not fall under any category discussed above but may become handy at some point while coding.\n\nThe gamma() function is used to return the gamma value of the argument.\n\nExample: This code imports the module, which provides mathematical functions and constants. It then defines a variable and assigns it the value 6. Next, the code calculates and prints the gamma value of using the module’s function. The function calculates the gamma value of a given argument.\n\nThe gamma value of the given argument is : 120.0\n\n\n\n2. Check if the value is infinity or NaN\n\nisinf() function is used to check whether the value is infinity or not.\n\nExample: This code imports the module and then checks whether the values of , , and are infinite using the function. The function takes a single argument, which is the value to be checked for infinity. It returns if the value is infinite and\n\nisnan() function returns true if the number is “NaN” else returns false.\n\nExample: This code imports the module and then checks whether the values of , , and are Not a Number (NaN) using the function. The function takes a single argument, which is the value to be checked for NaN. It returns if the value is NaN and .\n\nRefer to the below article to get detailed information about the special functions.\n\nWe have explained math module and it’s uses with example. Math module is very important mode in Python and every beginner should know how to use it.\n\nIt is used in various basic Python codes, school projects, etc. Hope you understood how to use math module in Python."
    },
    {
        "link": "https://docs.python.org/3/library/numeric.html",
        "document": "The modules described in this chapter provide numeric and math-related functions and data types. The module defines an abstract hierarchy of numeric types. The and modules contain various mathematical functions for floating-point and complex numbers. The module supports exact representations of decimal numbers, using arbitrary precision arithmetic.\n\nThe following modules are documented in this chapter:"
    },
    {
        "link": "https://medium.com/@saadjamilakhtar/5-best-practices-for-python-exception-handling-5e54b876a20",
        "document": "Exception handling is a fundamental aspect of writing robust and reliable Python code. Just like how a skilled driver navigates through unexpected roadblocks, a proficient programmer gracefully handles exceptions to maintain application stability and provide users with meaningful feedback. In this blog post, we’ll explore the best practices and guidelines for effective exception handling in Python. By following these strategies, you’ll be well-equipped to enhance your code’s resilience and provide a smoother user experience.\n\nCatching specific exceptions is akin to using specialized tools for different tasks. Instead of relying on a generic catch-all statement, it’s essential to catch specific exception types. This practice allows you to differentiate between various errors and deliver accurate error messages, making issue identification and resolution more efficient.\n\nA Real life example would be:\n\nImagine your Python application as a complex puzzle. Error logging acts as your cheat sheet, helping you put the pieces together when things go awry. Utilizing the logging module, you can capture exceptions along with vital information like timestamps, error details, and stack traces. This empowers you to analyze errors comprehensively and enhance the reliability of your application.\n\nThink of custom exception classes as tailored outfits for specific occasions. Python allows you to create custom exception classes that cater to your application’s unique needs. By doing so, you can categorize and encapsulate different errors, leading to better code readability, improved error handling, and modular project development.\n\nHandling exceptions gracefully is like being a composed host at a dinner party when unexpected guests arrive. To prevent application crashes and user confusion, employ try-except blocks to catch exceptions. This allows you to provide suitable error messages or alternative actions. Graceful error handling enhances user experience, maintains application flow, and safeguards against security vulnerabilities.\n\nImagine you’re a responsible party host cleaning up after the festivities. The finally block in exception handling serves a similar purpose. It ensures that certain code will execute regardless of whether an exception occurred or not. This is ideal for performing cleanup tasks, such as closing files or releasing resources, maintaining your application’s integrity."
    },
    {
        "link": "https://jerrynsh.com/python-exception-handling-patterns-and-best-practices",
        "document": "When it comes to raising exceptions and exception handling in Python, I've often found myself pondering, \"Should I re-raise this exception? Or maybe I should raise it from another exception?\"\n\nYou see, the thing is, there are a bunch of ways to handle exceptions in Python. We’d often just wing it without really grasping the why and when to use these patterns.\n\nIn this little exploration, we’re going to uncover the differences behind these different exception-handling patterns with code examples. Today, we'll be unraveling:\n• When to catch and re-raise an exception?\n• When to raise a new exception?\n• When to avoid using each of the above?\n\nEnough talk, let’s dive right into these exception-raising dilemmas and turn them into informed decisions. As we go through the examples, feel free to copy and paste the code snippet to try it out yourself on something like !\n\nIn this pattern, if an exception occurs during the division operation (e.g., division by zero), the original exception will be re-raised with its traceback.\n\nAs a result, the original exception is propagated all the way up the call stack with its original traceback.\n\nGenerally speaking, this is often a good default pattern for its clarity and preservation of original traceback.\n\nWhy? Preserving traceback information is often considered a good practice as it helps in diagnosing errors effectively and understanding the sequence of events that led to the exception.\n\nIn short, this pattern is used when you want to catch a specific exception ( in this case), do something, and then re-raise the exception. It allows you to perform some specific actions before propagating the exception further.\n\nEffectively the same as not having the block at all\n\nWait what?! Then why do we need the block then?\n\nKnowing this, the block in our previous example might suddenly seem redundant. However, you can imagine scenarios where additional logging or error-handling logic would make the block very useful:\n\nHaving that said, if you do not intend to do any additional stuff, feel free to omit the block.\n\nWhile this is generally a useful pattern, there can be scenarios where it might not be the best choice.\n\nFor instance, you may want to avoid using this pattern when you want to hide sensitive information or when the traceback contains sensitive data that you don't want to expose. Here’s an example:\n\nIn this example, if an exception occurs during the sensitive operation, the original exception is re-raised with its traceback. This pattern may expose sensitive information, such as login failure information in the traceback.\n\nThis is often referred to as \"leaking\" or \"revealing\" information. Exposing detailed login failure information is bad because it aids attackers. They can exploit specifics to guess usernames and launch targeted attacks.\n\nTo prevent this, it's better to handle the exception without re-raising it or to raise a new exception with a more generalized error message (see Pattern 3).\n\nIn this example, a new exception is raised with a custom message, while preserving the original exception's traceback. If a occurs, a new is raised with a custom message.\n\nThe traceback will include both the and the that was raised.\n\nThis pattern is useful when you want to raise a different (more meaningful) type of exception to indicate a specific error condition. This still allows us to preserve the original exception’s traceback.\n\nAvoid using this when you need to preserve the original exception.\n\nPattern 3: Raise New Exception from None\n\nThis pattern is similar to Pattern 2. But, using suppresses the original exception.\n\nHere, the traceback will not include the original , only the exception and the custom error message raised.\n\nSimilar to Pattern 2, you would want to use this pattern when you want to raise a new exception with a custom message.\n\nThe difference here is that this will not include the traceback of the original exception. It is useful when you want to hide the details of the original exception from the user.\n\nIf you are wrapping a library that throws internal exceptions and you want to present transformed external exceptions to your application users.\n\nIn this scenario, using this pattern is a suitable approach. Here’s a simple example:\n\nIn this example, wrapping internal exceptions with external exceptions helps isolate your application code from the specifics of the internal library's implementation. This can come in handy when the users of your code don't need to understand or handle the internal exceptions thrown by the library.\n\nAvoid using this approach when you (or your users) need to understand the full context of where the original exception occurred and how it led to the new exception.\n\nSuppressing exceptions can make it more difficult to track down the root cause of an error, so it should only be done when necessary.\n\nAgain, the exception is caught and a new exception is raised with a custom message.\n\nThough, the clause tells Python to pass the original exception as an argument to the new exception. As a result:\n• This allows the caller of the function to know what the original error was\n• The traceback of the original exception ( ) will be included in the printed traceback of the newly raised exception\n\nThis pattern is commonly used when you want to raise a new exception with a custom message and include the traceback of the original exception as its cause. It is useful when you want to provide both the specific error message and the context of the original exception.\n\nIn terms of best practices – it is generally recommended to use the syntax when raising a new exception from an inner block. This allows us to preserve the stack trace of the original error, which (again) can be helpful for debugging.\n\n\"What's the difference between Pattern 2 vs. Pattern 4 then? They seem awfully similar!\"\n\nIn Pattern 2, the exception is simply raised (from the line ) without being handled. This means that the caller of the function will not be aware of the error.\n\nIn comparison, Pattern 4 is more informative and therefore the better choice in most cases. However, Pattern 2 may be used if the caller of the function does not need to know about the original error.\n\nYou're building a file-processing application that uses an external library for reading and processing files. If the library raises an internal , you want to raise your own custom exception to provide more context and information to the user.\n\nIn this example, the is raised with the context of the original . This provides more information to the user and helps in debugging by maintaining the traceback chain.\n\nAvoid using this pattern when you want to hide the details of the original exception or when the original traceback is not needed (see Pattern 3) to understand the higher-level error.\n\nIn some cases, preserving both tracebacks can be confusing if not handled carefully.\n\nException handling in Python is about dealing with errors in your code. The best way to handle exceptions often depends on what you want to achieve.\n\nAnyway, here’s a TL;DR of what we went through:\n• Pattern 1 (good default): Re-raises the same exception with its original traceback.\n• Pattern 2 (situational): Re-raises a new exception, does not lose original traceback.\n• Pattern 3 (situational): Re-raises a new exception with a chained exception relationship ( ), but loses the original traceback.\n• Pattern 4 (best): Re-raises a new exception with a chained exception relationship ( ), including both the new and the original traceback.\n• Use the syntax when raising a new exception from an inner block. This allows us to preserve the stack trace of the original error.\n• Do not suppress exceptions unless it is absolutely necessary. Suppressing exceptions can make it more difficult to track down the root cause of an error.\n• Use meaningful error messages. The error message should be clear and concise, and it should provide enough information to help the user understand what went wrong.\n• Handle all (possible) errors. It is important to handle all possible errors that your code can throw. This will help to prevent your code from crashing unexpectedly.\n\nRemember, the way you handle exceptions should make your code easy to understand and debug. Always think about what helps you and others know what went wrong and why.\n\nBesides learning the right way to handle exceptions, it's just as important to stop using exceptions like this in Python!"
    },
    {
        "link": "https://stackoverflow.com/questions/839636/best-practices-for-python-exceptions",
        "document": "What are the best practices for creating exceptions? I just saw this, and I don't know if I should be horrified, or like it. I read several times in books that exceptions should never ever hold a string, because strings themselves can throw exceptions. Any real truth to this?\n\nBasically from my understanding from the scripts is that this was done so all the inhouse Python libraries will have a common error message format (something that is desperately needed) so I can understand why putting the error message string is a good idea. (Almost every method throws exceptions due to the utter need for nothing invalid getting through).\n\nThe code in question is the following:\n\nThis is just the tip of the iceberg, but can someone give me some insight in what makes this a terrible idea? Or if there is a much better exception coding process/style."
    },
    {
        "link": "https://reviewnprep.com/blog/mastering-exception-handling-in-python-real-life-examples-and-best-practices",
        "document": "Welcome to the beginner’s guide to exception handling in Python! As Python continues to dominate the programming world, it’s essential for developers of all levels to master the art of handling exceptions effectively. Whether you’re just starting out or looking to refresh your skills, this comprehensive guide will take you through the ins and outs of exception handling in Python, using practical examples to bring the concepts to life.\n\nException handling plays a crucial role in writing reliable and robust code, ensuring that your programs gracefully handle unexpected errors and prevent crashes. In this guide, we’ll dive deep into the world of exceptions, exploring the different types of exceptions, how to raise and handle them, and the best practices for error handling in Python.\n\nThrough a series of practical examples, you’ll gain hands-on experience in dealing with common exceptions, such as ValueError, FileNotFoundError, and IndexError. By the end of this guide, you’ll have the confidence and skills to tackle any unforeseen errors that come your way, making your Python programs more resilient and user-friendly.\n\nSo let’s get started on this exception handling journey and level up your Python coding skills!\n\nExceptions are error conditions that disrupt the normal flow of a program. They can occur due to a wide range of reasons, such as invalid input, file operations, or unexpected issues during execution.\n\nThese exceptions halt the normal flow of the program. Without exception handling, our Python scripts would crash whenever they encounter an error condition. By leveraging built-in exception handling tools like the try-except block, we can account for potential exceptions and take appropriate actions.\n\nPython has a wide range of built-in exception classes for different types of errors:\n• – Raised when a module/library cannot be imported\n• – Occurs when trying to access an invalid index in a list, tuple, etc\n• – Happens when using an undeclared variable\n• – Indicates two incompatible types are mixed in an operation\n• – Thrown when dividing by zero\n• – Raised when a file cannot be found at a specified path\n\nAnd many more specialized exceptions…\n\nBeing aware of common error types helps write code that catches the exceptions specific to our program logic and use case.\n\nThe basic structure for handling exceptions in Python is the block. It allows you to catch and handle exceptions gracefully:\n\nThe code inside the try clause is executed. If that code raises no exceptions, then no output from except clause is generated. But if an exception occurs, it is caught and the except block with the matching exception type is executed.\n\nWe can thus anticipate errors and ensure the program doesn’t crash if things go wrong.\n\nUsing Multiple Except Blocks for Different Types of Exceptions\n\nYou can use multiple blocks to handle different types of exceptions:\n\nHaving specific except blocks allow handling exceptions differently instead of generic handling.\n\nThe Else Clause and Finally Clause in Exception Handling\n\nThe clause is executed if the code in the block doesn’t raise any exceptions. The clause is always executed, regardless of whether an exception occurred or not:\n\nThe finally clause helps execute cleanup code like closing files, connections etc irrespective of exceptions.\n\nAlong with built-in exceptions, we can define custom exception classes by subclassing Exception:\n\nWe can raise exceptions manually with raise and catch them later:\n\nThis makes code more readable by separating custom error scenarios.\n\nBest Practices for Exception Handling in Python\n\nHere are some best practices to write clean, robust exception handling:\n• Keep try blocks small and focused to properly handle exceptions\n• Catch specific exceptions instead of generic Exception class to differentiate errors\n• Print custom error messages from except blocks upon failures\n• Use finally clause to execute sections of cleanup code reliably\n• Use blocks only where needed.\n• Don’t wrap your entire code in a massive block; limit it to potential error-prone sections.\n• Avoid using without specifying the exception type, as it can catch unintended errors.\n• Use logging to record exceptions for later analysis.\n\nMastering the basics of exception handling in Python is crucial for writing robust and error-resistant code. By understanding common types of exceptions, using try-except blocks effectively, and following best practices, you can create code that gracefully handles unexpected issues, making your applications more reliable and user-friendly.\n\nWhether you’re working on file operations, game development, or any other project, effective exception handling is a skill that will serve you well in your programming journey.\n\nI hope this guide gave you a solid understanding of key exception handling principles along with actionable coding examples. These learnings will help you eliminate crashes in your Python codebase and handle failures gracefully!"
    },
    {
        "link": "https://docs.python.org/3/tutorial/errors.html",
        "document": "Until now error messages haven’t been more than mentioned, but if you have tried out the examples you have probably seen some. There are (at least) two distinguishable kinds of errors: syntax errors and exceptions.\n\nSyntax errors, also known as parsing errors, are perhaps the most common kind of complaint you get while you are still learning Python: The parser repeats the offending line and displays little arrows pointing at the place where the error was detected. Note that this is not always the place that needs to be fixed. In the example, the error is detected at the function , since a colon ( ) is missing just before it. The file name ( in our example) and line number are printed so you know where to look in case the input came from a file.\n\nEven if a statement or expression is syntactically correct, it may cause an error when an attempt is made to execute it. Errors detected during execution are called exceptions and are not unconditionally fatal: you will soon learn how to handle them in Python programs. Most exceptions are not handled by programs, however, and result in error messages as shown here: File , line , in : File , line , in : name 'spam' is not defined File , line , in : can only concatenate str (not \"int\") to str The last line of the error message indicates what happened. Exceptions come in different types, and the type is printed as part of the message: the types in the example are , and . The string printed as the exception type is the name of the built-in exception that occurred. This is true for all built-in exceptions, but need not be true for user-defined exceptions (although it is a useful convention). Standard exception names are built-in identifiers (not reserved keywords). The rest of the line provides detail based on the type of exception and what caused it. The preceding part of the error message shows the context where the exception occurred, in the form of a stack traceback. In general it contains a stack traceback listing source lines; however, it will not display lines read from standard input. Built-in Exceptions lists the built-in exceptions and their meanings.\n\nIt is possible to write programs that handle selected exceptions. Look at the following example, which asks the user for input until a valid integer has been entered, but allows the user to interrupt the program (using - or whatever the operating system supports); note that a user-generated interruption is signalled by raising the exception. \"Oops! That was no valid number. Try again...\" The statement works as follows.\n• None First, the try clause (the statement(s) between the and keywords) is executed.\n• None If no exception occurs, the except clause is skipped and execution of the statement is finished.\n• None If an exception occurs during execution of the clause, the rest of the clause is skipped. Then, if its type matches the exception named after the keyword, the except clause is executed, and then execution continues after the try/except block.\n• None If an exception occurs which does not match the exception named in the except clause, it is passed on to outer statements; if no handler is found, it is an unhandled exception and execution stops with an error message. A statement may have more than one except clause, to specify handlers for different exceptions. At most one handler will be executed. Handlers only handle exceptions that occur in the corresponding try clause, not in other handlers of the same statement. An except clause may name multiple exceptions as a parenthesized tuple, for example: A class in an clause matches exceptions which are instances of the class itself or one of its derived classes (but not the other way around — an except clause listing a derived class does not match instances of its base classes). For example, the following code will print B, C, D in that order: Note that if the except clauses were reversed (with first), it would have printed B, B, B — the first matching except clause is triggered. When an exception occurs, it may have associated values, also known as the exception’s arguments. The presence and types of the arguments depend on the exception type. The except clause may specify a variable after the exception name. The variable is bound to the exception instance which typically has an attribute that stores the arguments. For convenience, builtin exception types define to print all the arguments without explicitly accessing . # __str__ allows args to be printed directly, # but may be overridden in exception subclasses The exception’s output is printed as the last part (‘detail’) of the message for unhandled exceptions. is the common base class of all exceptions. One of its subclasses, , is the base class of all the non-fatal exceptions. Exceptions which are not subclasses of are not typically handled, because they are used to indicate that the program should terminate. They include which is raised by and which is raised when a user wishes to interrupt the program. can be used as a wildcard that catches (almost) everything. However, it is good practice to be as specific as possible with the types of exceptions that we intend to handle, and to allow any unexpected exceptions to propagate on. The most common pattern for handling is to print or log the exception and then re-raise it (allowing a caller to handle the exception as well): \"Could not convert data to an integer.\" The … statement has an optional else clause, which, when present, must follow all except clauses. It is useful for code that must be executed if the try clause does not raise an exception. For example: The use of the clause is better than adding additional code to the clause because it avoids accidentally catching an exception that wasn’t raised by the code being protected by the … statement. Exception handlers do not handle only exceptions that occur immediately in the try clause, but also those that occur inside functions that are called (even indirectly) in the try clause. For example:\n\nThe statement allows the programmer to force a specified exception to occur. For example: The sole argument to indicates the exception to be raised. This must be either an exception instance or an exception class (a class that derives from , such as or one of its subclasses). If an exception class is passed, it will be implicitly instantiated by calling its constructor with no arguments: If you need to determine whether an exception was raised but don’t intend to handle it, a simpler form of the statement allows you to re-raise the exception:\n\nIf an unhandled exception occurs inside an section, it will have the exception being handled attached to it and included in the error message: File , line , in : [Errno 2] No such file or directory: 'database.sqlite' During handling of the above exception, another exception occurred: File , line , in : To indicate that an exception is a direct consequence of another, the statement allows an optional clause: # exc must be exception instance or None. This can be useful when you are transforming exceptions. For example: File , line , in File , line , in The above exception was the direct cause of the following exception: File , line , in : It also allows disabling automatic exception chaining using the idiom: For more information about chaining mechanics, see Built-in Exceptions.\n\nThe statement has another optional clause which is intended to define clean-up actions that must be executed under all circumstances. For example: If a clause is present, the clause will execute as the last task before the statement completes. The clause runs whether or not the statement produces an exception. The following points discuss more complex cases when an exception occurs:\n• None If an exception occurs during execution of the clause, the exception may be handled by an clause. If the exception is not handled by an clause, the exception is re-raised after the clause has been executed.\n• None An exception could occur during execution of an or clause. Again, the exception is re-raised after the clause has been executed.\n• None If the clause executes a , or statement, exceptions are not re-raised.\n• None If the statement reaches a , or statement, the clause will execute just prior to the , or statement’s execution.\n• None If a clause includes a statement, the returned value will be the one from the clause’s statement, not the value from the clause’s statement. As you can see, the clause is executed in any event. The raised by dividing two strings is not handled by the clause and therefore re-raised after the clause has been executed. In real world applications, the clause is useful for releasing external resources (such as files or network connections), regardless of whether the use of the resource was successful.\n\nSome objects define standard clean-up actions to be undertaken when the object is no longer needed, regardless of whether or not the operation using the object succeeded or failed. Look at the following example, which tries to open a file and print its contents to the screen. The problem with this code is that it leaves the file open for an indeterminate amount of time after this part of the code has finished executing. This is not an issue in simple scripts, but can be a problem for larger applications. The statement allows objects like files to be used in a way that ensures they are always cleaned up promptly and correctly. After the statement is executed, the file f is always closed, even if a problem was encountered while processing the lines. Objects which, like files, provide predefined clean-up actions will indicate this in their documentation.\n\nThere are situations where it is necessary to report several exceptions that have occurred. This is often the case in concurrency frameworks, when several tasks may have failed in parallel, but there are also other use cases where it is desirable to continue execution and collect multiple errors rather than raise the first exception. The builtin wraps a list of exception instances so that they can be raised together. It is an exception itself, so it can be caught like any other exception. By using instead of , we can selectively handle only the exceptions in the group that match a certain type. In the following example, which shows a nested exception group, each clause extracts from the group exceptions of a certain type while letting all other exceptions propagate to other clauses and eventually to be reraised. Note that the exceptions nested in an exception group must be instances, not types. This is because in practice the exceptions would typically be ones that have already been raised and caught by the program, along the following pattern:\n\nWhen an exception is created in order to be raised, it is usually initialized with information that describes the error that has occurred. There are cases where it is useful to add information after the exception was caught. For this purpose, exceptions have a method that accepts a string and adds it to the exception’s notes list. The standard traceback rendering includes all notes, in the order they were added, after the exception. For example, when collecting exceptions into an exception group, we may want to add context information for the individual errors. In the following each exception in the group has a note indicating when this error has occurred. | ExceptionGroup: We have some problems (3 sub-exceptions)"
    }
]