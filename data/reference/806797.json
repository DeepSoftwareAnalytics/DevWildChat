[
    {
        "link": "https://peachpit.com/articles/article.aspx?p=1246986",
        "document": "This chapter provides a high-level overview of the basic concepts, terminology, and definitions of classes and objects in ActionScript 3.0.\n\nThe most important knowledge about ActionScript and object-oriented programming that you can possess is knowing how to work with objects and classes. You may remember from reading Chapter 1 that everything in ActionScript is an object. A MovieClip is an instance of the class; a Sprite is an instance of the class, and so on.\n\nBecause objects and classes are so central to working with ActionScript, nearly every chapter of this book delves into working with classes and objects. You will have gained plenty of experience with them by the time you’ve finished reading and working through the step-by-step instructions. But before you move on, you must understand the basic concepts, terminology, and definitions of classes and objects.\n\nThis chapter provides a high-level overview, beginning with the definition of classes, objects, and class hierarchy and inheritance (the “family tree” of how classes are stored and referenced). It also provides opportunities for you to practice importing classes and instantiating objects using ActionScript so that you can call their methods and set their properties. Finally, this chapter shows you how to work with external ActionScript files, which enables you to work with different ActionScript editors and to separate programming from design.\n\nA class is the blueprint for an object. It defines everything about the object: how it looks, how it acts, what it does, what data it processes, and how it is built.\n\nAn object is an instance of a class, or a copy of the class’s blueprint. Once an object of a class is instantiated, you have access to the public properties, events, and methods of that class to manipulate the object for your programming and display purposes.\n\nClass hierarchy involves the way in which classes are categorized. Classes are external ActionScript files that define objects; they are stored and organized in a specific directory structure in the Flash CS3 program directory (Figure 4.1). To use them in your code, you have to import them.\n\nTo import the ActionScript class files into your code, you don’t need to know the full computer path to the files (the compiler will do that for you), but you do need to know how the classes are categorized. To import a particular class, you need to know what directory, or class package, they are stored in. For example, the class is located in the package. The full import path to the package would thus be .\n\nThe last concept that it’s important to be familiar with is class inheritance. As a general rule, the deeper into a package a class gets, the more it inherits from the parent classes for its core functionality. As discussed in Chapter 3, the class has inherited methods from other classes to help extend its functionality. Classes share, or inherit, methods, properties, and events from one another, so functionality has to be defined only once and shared throughout the class structure. This is not an entirely new concept for ActionScript 3, but it has been universally implemented in this version. This helps improve code performance, reduces the file size of imported classes, and makes future updates and additions to the ActionScript API easier to implement.\n\nWe’ll be seeing more of classes and subclasses throughout the rest of this book, since many classes we’ll work with are subclasses of different class packages."
    },
    {
        "link": "https://isbe.net/CTEDocuments/BMCE-680098.pdf",
        "document": "Every child will make significant academic gains each year, increasing their knowledge, skills, and opportunities so they graduate equipped to pursue a successful future, with the state paying special attention to addressing historic inequities.\n\nAll districts and schools will receive the resources necessary to create safe, healthy, and welcoming learning environments, and will be equipped to meet the unique academic and social and emotional needs of each and every student."
    },
    {
        "link": "https://airsdk.dev/reference/actionscript/3.0/flash/display/DisplayObject.html",
        "document": "For more information, see the \"Display Programming\" chapter of the ActionScript 3.0 Developer's Guide.\n\nSome properties previously used in the ActionScript 1.0 and 2.0 MovieClip, TextField, and Button classes (such as _alpha , _height , _name , _width , _x , _y , and others) have equivalents in the ActionScript 3.0 DisplayObject class that are renamed so that they no longer begin with the underscore (_) character.\n\nThe DisplayObject class contains several broadcast events. Normally, the target of any particular event is a specific DisplayObject instance. For example, the target of an added event is the specific DisplayObject instance that was added to the display list. Having a single target restricts the placement of event listeners to that target and in some cases the target's ancestors on the display list. With broadcast events, however, the target is not a specific DisplayObject instance, but rather all DisplayObject instances, including those that are not on the display list. This means that you can add a listener to any DisplayObject instance to listen for broadcast events. In addition to the broadcast events listed in the DisplayObject class's Events table, the DisplayObject class also inherits two broadcast events from the EventDispatcher class: activate and deactivate .\n\nThe DisplayObject class itself does not include any APIs for rendering content onscreen. For that reason, if you want create a custom subclass of the DisplayObject class, you will want to extend one of its subclasses that do have APIs for rendering content onscreen, such as the Shape, Sprite, Bitmap, SimpleButton, TextField, or MovieClip class.\n\nDisplayObject is an abstract base class; therefore, you cannot call DisplayObject directly. Invoking new DisplayObject() throws an ArgumentError exception.\n\nThe DisplayObject class supports basic functionality like the x and y position of an object, as well as more advanced properties of the object such as its transformation matrix.\n\nThe DisplayObject class is the base class for all objects that can be placed on the display list. The display list manages all objects displayed in the Flash runtimes. Use the DisplayObjectContainer class to arrange the display objects in the display list. DisplayObjectContainer objects can have child display objects, while other display objects, such as Shape and TextField objects, are \"leaf\" nodes that have only parents and siblings, no children.\n\nIndicates the z coordinate position along the z-axis of the DisplayObject instance relative to the 3D parent container.\n\nIndicates the y coordinate of the DisplayObject instance relative to the local coordinates of the parent DisplayObjectContainer.\n\nIndicates the x coordinate of the DisplayObject instance relative to the local coordinates of the parent DisplayObjectContainer.\n\nIndicates the depth scale (percentage) of an object as applied from the registration point of the object.\n\nIndicates the vertical scale (percentage) of an object as applied from the registration point of the object.\n\nIndicates the horizontal scale (percentage) of the object as applied from the registration point.\n\nIndicates the z-axis rotation of the DisplayObject instance, in degrees, from its original orientation relative to the 3D parent container.\n\nIndicates the y-axis rotation of the DisplayObject instance, in degrees, from its original orientation relative to the 3D parent container.\n\nIndicates the x-axis rotation of the DisplayObject instance, in degrees, from its original orientation relative to the 3D parent container.\n\nIndicates the rotation of the DisplayObject instance, in degrees, from its original orientation.\n\n[read-only] For a display object in a loaded SWF file, the root property is the top-most display object in the portion of the display list's tree structure represented by that SWF file.\n\n[read-only] Indicates the y coordinate of the mouse or user input device position, in pixels.\n\n[read-only] Indicates the x coordinate of the mouse or user input device position, in pixels.\n\nObtains the meta data object of the DisplayObject instance if meta data was stored alongside the the instance of this DisplayObject in the SWF file through a PlaceObject4 tag.\n\n[read-only] Returns a LoaderInfo object containing information about loading the file to which this display object belongs.\n\nAn indexed array that contains each filter object currently associated with the display object.\n\nIf non-null, this Matrix object defines how a display object is rendered when cacheAsBitmap is set to true .\n\n[write-only] Sets a shader that is used for blending the foreground and background.\n\nA value from the BlendMode class that specifies which blend mode to use.\n\nIndicates the alpha transparency value of the object specified.\n\nChecks whether an event listener is registered with this EventDispatcher object or any of its ancestors for the specified event type.\n\nIndicates whether the specified property exists and is enumerable.\n\nIndicates whether an instance of the Object class is in the prototype chain of the object specified as the parameter.\n\nEvaluates the display object to see if it overlaps or intersects with the point specified by the x and y parameters.\n\nEvaluates the bounding box of the display object to see if it overlaps or intersects with the bounding box of the obj display object.\n\nChecks whether the EventDispatcher object has any listeners registered for a specific type of event.\n\nReturns a rectangle that defines the boundary of the display object, based on the coordinate system defined by the targetCoordinateSpace parameter, excluding any strokes on shapes.\n\nReturns a rectangle that defines the area of the display object relative to the coordinate system of the targetCoordinateSpace object.\n\nRegisters an event listener object with an EventDispatcher object so that the listener receives notification of an event.\n\n[read-write] A value from the BlendMode class that specifies which blend mode to use. A bitmap can be drawn internally in two ways. If you have a blend mode enabled or an external clipping mask, the bitmap is drawn by adding a bitmap-filled square shape to the vector render. If you attempt to set this property to an invalid value, Flash runtimes set the value to . The property affects each pixel of the display object. Each pixel is composed of three constituent colors (red, green, and blue), and each constituent color has a value between 0x00 and 0xFF. Flash Player or Adobe AIR compares each constituent color of one pixel in the movie clip with the corresponding color of the pixel in the background. For example, if is set to , Flash Player or Adobe AIR compares the red value of the display object with the red value of the background, and uses the lighter of the two as the value for the red component of the displayed color. The following table describes the settings. The BlendMode class defines string values you can use. The illustrations in the table show values applied to a circular display object (2) superimposed on another display object (1). The display object appears in front of the background. Pixel values of the display object override those of the background. Where the display object is transparent, the background is visible. Forces the creation of a transparency group for the display object. This means that the display object is pre-composed in a temporary buffer before it is processed further. This is done automatically if the display object is pre-cached using bitmap caching or if the display object is a display object container with at least one child object with a setting other than . Not supported under GPU rendering. Multiplies the values of the display object constituent colors by the colors of the background color, and then normalizes by dividing by 0xFF, resulting in darker colors. This setting is commonly used for shadows and depth effects. For example, if a constituent color (such as red) of one pixel in the display object and the corresponding color of the pixel in the background both have the value 0x88, the multiplied result is 0x4840. Dividing by 0xFF yields a value of 0x48 for that constituent color, which is a darker shade than the color of the display object or the color of the background. Multiplies the complement (inverse) of the display object color by the complement of the background color, resulting in a bleaching effect. This setting is commonly used for highlights or to remove black areas of the display object. Selects the lighter of the constituent colors of the display object and the color of the background (the colors with the larger values). This setting is commonly used for superimposing type. For example, if the display object has a pixel with an RGB value of 0xFFCC33, and the background pixel has an RGB value of 0xDDF800, the resulting RGB value for the displayed pixel is 0xFFF833 (because 0xFF > 0xDD, 0xCC < 0xF8, and 0x33 > 0x00 = 33). Not supported under GPU rendering. Selects the darker of the constituent colors of the display object and the colors of the background (the colors with the smaller values). This setting is commonly used for superimposing type. For example, if the display object has a pixel with an RGB value of 0xFFCC33, and the background pixel has an RGB value of 0xDDF800, the resulting RGB value for the displayed pixel is 0xDDCC00 (because 0xFF > 0xDD, 0xCC < 0xF8, and 0x33 > 0x00 = 33). Not supported under GPU rendering. Compares the constituent colors of the display object with the colors of its background, and subtracts the darker of the values of the two constituent colors from the lighter value. This setting is commonly used for more vibrant colors. For example, if the display object has a pixel with an RGB value of 0xFFCC33, and the background pixel has an RGB value of 0xDDF800, the resulting RGB value for the displayed pixel is 0x222C33 (because 0xFF - 0xDD = 0x22, 0xF8 - 0xCC = 0x2C, and 0x33 - 0x00 = 0x33). Adds the values of the constituent colors of the display object to the colors of its background, applying a ceiling of 0xFF. This setting is commonly used for animating a lightening dissolve between two objects. For example, if the display object has a pixel with an RGB value of 0xAAA633, and the background pixel has an RGB value of 0xDD2200, the resulting RGB value for the displayed pixel is 0xFFC833 (because 0xAA + 0xDD > 0xFF, 0xA6 + 0x22 = 0xC8, and 0x33 + 0x00 = 0x33). Subtracts the values of the constituent colors in the display object from the values of the background color, applying a floor of 0. This setting is commonly used for animating a darkening dissolve between two objects. For example, if the display object has a pixel with an RGB value of 0xAA2233, and the background pixel has an RGB value of 0xDDA600, the resulting RGB value for the displayed pixel is 0x338400 (because 0xDD - 0xAA = 0x33, 0xA6 - 0x22 = 0x84, and 0x00 - 0x33 < 0x00). Applies the alpha value of each pixel of the display object to the background. This requires the setting of the parent display object to be set to . For example, in the illustration, the parent display object, which is a white background, has . Not supported under GPU rendering. Erases the background based on the alpha value of the display object. This requires the of the parent display object to be set to . For example, in the illustration, the parent display object, which is a white background, has . Not supported under GPU rendering. Adjusts the color of each pixel based on the darkness of the background. If the background is lighter than 50% gray, the display object and background colors are screened, which results in a lighter color. If the background is darker than 50% gray, the colors are multiplied, which results in a darker color. This setting is commonly used for shading effects. Not supported under GPU rendering. Adjusts the color of each pixel based on the darkness of the display object. If the display object is lighter than 50% gray, the display object and background colors are screened, which results in a lighter color. If the display object is darker than 50% gray, the colors are multiplied, which results in a darker color. This setting is commonly used for shading effects. Not supported under GPU rendering. Adjusts the color using a custom shader routine. The shader that is used is specified as the Shader instance assigned to the property. Setting the property of a display object to a Shader instance automatically sets the display object's property to . If the property is set to without first setting the property, the property is set to . Not supported under GPU rendering. \n\n \n\n \n\n \n\n \n\nThe following code creates two sprite objects, a square and a circle, and sets the blend mode of the circle (in the foreground) to when the pointer rolls over the circle: The following code creates two sprite objects, a square and a circle, and sets the blend mode of the circle (in the foreground) towhen the pointer rolls over the circle:\n\n[read-write] If set to , Flash runtimes cache an internal bitmap representation of the display object. This caching can increase performance for display objects that contain complex vector content. All vector data for a display object that has a cached bitmap is drawn to the bitmap instead of the main display. If is null or unsupported, the bitmap is then copied to the main display as unstretched, unrotated pixels snapped to the nearest pixel boundaries. Pixels are mapped 1 to 1 with the parent object. If the bounds of the bitmap change, the bitmap is recreated instead of being stretched. If is non-null and supported, the object is drawn to the off-screen bitmap using that matrix and the stretched and/or rotated results of that rendering are used to draw the object to the main display. No internal bitmap is created unless the property is set to . After you set the property to , the rendering does not change, however the display object performs pixel snapping automatically. The animation speed can be significantly faster depending on the complexity of the vector content. The property is automatically set to whenever you apply a filter to a display object (when its array is not empty), and if a display object has a filter applied to it, is reported as for that display object, even if you set the property to . If you clear all filters for a display object, the setting changes to what it was last set to. A display object does not use a bitmap even if the property is set to and instead renders from vector data in the following cases:\n• The bitmap is too large. In AIR 1.5 and Flash Player 10, the maximum size for a bitmap image is 8,191 pixels in width or height, and the total number of pixels cannot exceed 16,777,215 pixels. (So, if a bitmap image is 8,191 pixels wide, it can only be 2,048 pixels high.) In Flash Player 9 and earlier, the limitation is is 2880 pixels in height and 2,880 pixels in width.\n• The bitmap fails to allocate (out of memory error). The property is best used with movie clips that have mostly static content and that do not scale and rotate frequently. With such movie clips, can lead to performance increases when the movie clip is translated (when its x and y position is changed). \n\n \n\n \n\n \n\n \n\nThe following example applies a drop shadow to a Shape instance. It then traces the value of the property, which is set to when the filter is applied: The following example applies a drop shadow to a Shape instance. It then traces the value of theproperty, which is set towhen the filter is applied:\n\n[read-write] If non-null, this Matrix object defines how a display object is rendered when is set to . The application uses this matrix as a transformation matrix that is applied when rendering the bitmap version of the display object. AIR profile support: This feature is supported on mobile devices, but it is not supported on desktop operating systems. It also has limited support on AIR for TV devices. Specifically, on AIR for TV devices, supported transformations include scaling and translation, but not rotation and skewing. See AIR Profile Support for more information regarding API support across multiple profiles. With set, the application retains a cached bitmap image across various 2D transformations, including translation, rotation, and scaling. If the application uses hardware acceleration, the object will be stored in video memory as a texture. This allows the GPU to apply the supported transformations to the object. The GPU can perform these transformations faster than the CPU. To use the hardware acceleration, set Rendering to GPU in the General tab of the iPhone Settings dialog box in Flash Professional CS5. Or set the property to in the application descriptor file. Note that AIR for TV devices automatically use hardware acceleration if it is available. For example, the following code sends an untransformed bitmap representation of the display object to the GPU: Usually, the identity matrix ( ) suffices. However, you can use another matrix, such as a scaled-down matrix, to upload a different bitmap to the GPU. For example, the following example applies a matrix that is scaled by 0.5 on the x and y axes. The bitmap object that the GPU uses is smaller, however the GPU adjusts its size to match the transform.matrix property of the display object: matrix:Matrix = new Matrix(); // creates an identity matrix matrix.scale(0.5, 0.5); // scales the matrix mySprite.cacheAsBitmapMatrix = matrix; mySprite.cacheAsBitmap = true; Generally, you should choose to use a matrix that transforms the display object to the size that it will appear in the application. For example, if your application displays the bitmap version of the sprite scaled down by a half, use a matrix that scales down by a half. If you application will display the sprite larger than its current dimensions, use a matrix that scales up by that factor. Note: The property is suitable for 2D transformations. If you need to apply transformations in 3D, you may do so by setting a 3D property of the object and manipulating its property. If the application is packaged using GPU mode, this allows the 3D transforms to be applied to the object by the GPU. The is ignored for 3D objects. \n\n \n\n \n\n \n\n \n\nThe following example applies uses the property to apply transformations to a bitmap version of the movie clip . import flash.geom.Matrix; import flash.display.*; import flash.utils.Timer; var my_shape:MovieClip = new MovieClip(); my_shape.graphics.beginFill(0xCCFF00); my_shape.graphics.drawRect(200, 0, 100, 100); addChild(my_shape); var my_timer:Timer = new Timer(250); my_timer.start(); my_timer.addEventListener(TimerEvent.TIMER, timerHandler); // make sure this Display Object remains cached for all 2D transforms my_shape.cacheAsBitmap = true; my_shape.cacheAsBitmapMatrix = new Matrix(); // rotation variables const initAngle:Number = 0; const pi:Number = 3.142; const incrAngle:Number = pi/10; // scaling variables const initScale:Number = 0.25; const incrScale: Number = 1.1; var initHeight : Number = my_shape.height; var initWidth : Number = my_shape.width; // translation variables var incrX : Number = root.width / 20; var incrY : Number = root.height / 10; // do some initial transforms var tempMat : Matrix = my_shape.transform.matrix; tempMat.rotate(initAngle); tempMat.scale(initScale, initScale); my_shape.transform.matrix = tempMat; function timerHandler(evt:TimerEvent):void { tempMat = my_shape.transform.matrix; tempMat.rotate(incrAngle); tempMat.translate(incrX, incrY); tempMat.scale(incrScale, incrScale); my_shape.transform.matrix = tempMat; // ensure we are still in a reasonable state or reset if(my_shape.height > stage.stageHeight/2) { my_shape.height = initHeight; } if(my_shape.width > stage.stageWidth/2) { my_shape.width = initWidth; } if(my_shape.x > stage.stageWidth) { my_shape.x = 0; } else if (my_shape.x < 0) { my_shape.x = stage.stageWidth; } if(my_shape.y > stage.stageHeight) { my_shape.y = 0; } else if (my_shape.y < 0) { my_shape.y = stage.stageHeight; } } The following example applies uses theproperty to apply transformations to a bitmap version of the movie clip\n\n[read-write] An indexed array that contains each filter object currently associated with the display object. The flash.filters package contains several classes that define specific filters you can use. Filters can be applied in Flash Professional at design time, or at run time by using ActionScript code. To apply a filter by using ActionScript, you must make a temporary copy of the entire array, modify the temporary array, then assign the value of the temporary array back to the array. You cannot directly add a new filter object to the array. To add a filter by using ActionScript, perform the following steps (assume that the target display object is named ):\n• Create a new filter object by using the constructor method of your chosen filter class.\n• Assign the value of the array to a temporary array, such as one named .\n• Add the new filter object to the temporary array.\n• Assign the value of the temporary array to the array. If the array is undefined, you do not need to use a temporary array. Instead, you can directly assign an array literal that contains one or more filter objects that you create. The first example in the Examples section adds a drop shadow filter by using code that handles both defined and undefined arrays. To modify an existing filter object, you must use the technique of modifying a copy of the array:\n• Assign the value of the array to a temporary array, such as one named .\n• Modify the property by using the temporary array, . For example, to set the quality property of the first filter in the array, you could use the following code:\n• Assign the value of the temporary array to the array. At load time, if a display object has an associated filter, it is marked to cache itself as a transparent bitmap. From this point forward, as long as the display object has a valid filter list, the player caches the display object as a bitmap. This source bitmap is used as a source image for the filter effects. Each display object usually has two bitmaps: one with the original unfiltered source display object and another for the final image after filtering. The final image is used when rendering. As long as the display object does not change, the final image does not need updating. The flash.filters package includes classes for filters. For example, to create a DropShadow filter, you would write: You can use the operator to determine the type of filter assigned to each index position in the array. For example, the following code shows how to determine the position of the first filter in the array that is a DropShadowFilter: import flash.text.TextField; import flash.filters.*; var tf:TextField = new TextField(); var filter1:DropShadowFilter = new DropShadowFilter(); var filter2:GradientGlowFilter = new GradientGlowFilter(); tf.filters = [filter1, filter2]; tf.text = \"DropShadow index: \" + filterPosition(tf, DropShadowFilter).toString(); // 0 addChild(tf) function filterPosition(displayObject:DisplayObject, filterClass:Class):int { for (var i:uint = 0; i < displayObject.filters.length; i++) { if (displayObject.filters[i] is filterClass) { return i; } } return -1; } Note: Since you cannot directly add a new filter object to the array, the following code has no effect on the target display object, named : \n\n \n\n \n\n \n\n \n\n — When includes a ShaderFilter and the shader output type is not compatible with this operation (the shader must specify a output). — When includes a ShaderFilter and the shader doesn't specify any image input or the first input is not an input. — When includes a ShaderFilter and the shader specifies an image input that isn't provided. — When includes a ShaderFilter, a ByteArray or Vector.<Number> instance as a shader input, and the and properties aren't specified for the ShaderInput object, or the specified values don't match the amount of data in the input data. See the property for more information."
    },
    {
        "link": "https://airsdk.dev/reference/actionscript/3.0/flash/display/DisplayObjectContainer.html",
        "document": "The DisplayObjectContainer class is the base class for all objects that can serve as display object containers on the display list. The display list manages all objects displayed in the Flash runtimes. Use the DisplayObjectContainer class to arrange the display objects in the display list. Each DisplayObjectContainer object has its own child list for organizing the z-order of the objects. The z-order is the front-to-back order that determines which object is drawn in front, which is behind, and so on. The DisplayObjectContainer class is the base class for all objects that can serve as display object containers on the display list. The display list manages all objects displayed in the Flash runtimes. Use the DisplayObjectContainer class to arrange the display objects in the display list. Each DisplayObjectContainer object has its own child list for organizing the z-order of the objects. The z-order is the front-to-back order that determines which object is drawn in front, which is behind, and so on. DisplayObject is an abstract base class; therefore, you cannot call DisplayObject directly. Invoking throws an exception. The DisplayObjectContainer class is an abstract base class for all objects that can contain child objects. It cannot be instantiated directly; calling the constructor throws an exception. The DisplayObjectContainer class is an abstract base class for all objects that can contain child objects. It cannot be instantiated directly; calling theconstructor throws anexception. For more information, see the \"Display Programming\" chapter of the ActionScript 3.0 Developer's Guide. \n\n\n\n[read-write] Determines whether or not the children of the object are mouse, or user input device, enabled. If an object is enabled, a user can interact with it by using a mouse or user input device. The default is . This property is useful when you create a button with an instance of the Sprite class (instead of using the SimpleButton class). When you use a Sprite instance to create a button, you can choose to decorate the button by using the method to add additional Sprite instances. This process can cause unexpected behavior with mouse events because the Sprite instances you add as children can become the target object of a mouse event when you expect the parent instance to be the target object. To ensure that the parent instance serves as the target objects for mouse events, you can set the property of the parent instance to . No event is dispatched by setting this property. You must use the method to create interactive functionality. \n\n \n\n \n\n \n\n \n\nThe following example sets up a Sprite object (a type of display object container) named and shows that when you set its property to , the target of a event is the object, not any one of its child objects: The following example sets up a Sprite object (a type of display object container) namedand shows that when you set itsproperty to, the target of aevent is theobject, not any one of its child objects: [read-only] Returns the number of children of this object. \n\n \n\n \n\n \n\nThe following example sets up two Sprite objects named and . A Sprite is a type of display object container. The example calls the method to set up the display hierarchy: is a child of , and two other display objects, and , are children of . The calls to the method show the number of children of each object. Note that grandchildren are not included in the count: import flash.display.Sprite; var container1:Sprite = new Sprite(); var container2:Sprite = new Sprite(); var circle1:Sprite = new Sprite(); circle1.graphics.beginFill(0xFFCC00); circle1.graphics.drawCircle(40, 40, 40); var circle2:Sprite = new Sprite(); circle2.graphics.beginFill(0x00CCFF); circle2.graphics.drawCircle(80, 40, 40); container2.addChild(container1); container1.addChild(circle1); container1.addChild(circle2); trace(container1.numChildren); // 2 trace(container2.numChildren); // 1 trace(circle1.numChildren); // 0 trace(circle2.numChildren); // 0 The following example sets up two Sprite objects namedand. A Sprite is a type of display object container. The example calls themethod to set up the display hierarchy:is a child of, and two other display objects,and, are children of. The calls to themethod show the number of children of each object. Note that grandchildren are not included in thecount: [read-write] Determines whether the children of the object are tab enabled. Enables or disables tabbing for the children of the object. The default is . Note: Do not use the property with Flex. Instead, use the property. \n\n \n\n \n\n \n\n \n\n — Calling this property of the Stage object throws an exception. The Stage object does not implement this property. \n\n \n\nThe following example creates a display object container and adds two display objects, and , to its child list. The example sets tabChildren to for the children so it can manage its own tab order using : import flash.display.Sprite; var container:Sprite = new Sprite(); container.tabChildren = false; var circle1:Sprite = new Sprite(); circle1.graphics.beginFill(0xFFCC00); circle1.graphics.drawCircle(40, 40, 40); circle1.tabIndex = 1; var circle2:Sprite = new Sprite(); circle2.graphics.beginFill(0x00CCFF); circle2.graphics.drawCircle(120, 40, 40); circle2.tabIndex = 0; container.addChild(circle1); container.addChild(circle2); To see the results of this example, compile and run the file. When you select one of the circles, you can press the TAB key to switch the display object that has focus (indicated by a yellow highlight rectangle). \n\n \n\n The following example creates adisplay object container and adds two display objects,and, to its child list. The example sets tabChildren tofor the children so it can manage its own tab order usingTo see the results of this example, compile and run the file. When you select one of the circles, you can press the TAB key to switch the display object that has focus (indicated by a yellow highlight rectangle). [read-only] \n\n \n\n \n\n \n\nThe following example works only in the Flash authoring environment. Flex does not include any ways of adding static text to a file. To prepare the Flash file for this example, add one or more static text fields in the first frame of a movie. Then insert the following script into the first frame and run the file. The output will be the static text that you added: The following example works only in the Flash authoring environment. Flex does not include any ways of adding static text to a file. To prepare the Flash file for this example, add one or more static text fields in the first frame of a movie. Then insert the following script into the first frame and run the file. The output will be the static text that you added: Calling the constructor throws an exception. You can, however, call constructors for the following subclasses of DisplayObjectContainer: Adds a child DisplayObject instance to this DisplayObjectContainer instance. The child is added to the front (top) of all other children in this DisplayObjectContainer instance. (To add a child to a specific index position, use the method.) If you add a child object that already has a different display object container as a parent, the object is removed from the child list of the other display object container. Note: The command can cause problems with a published SWF file, including security problems and conflicts with other loaded SWF files. There is only one Stage within a Flash runtime instance, no matter how many SWF files you load into the runtime. So, generally, objects should not be added to the Stage, directly, at all. The only object the Stage should contain is the root object. Create a DisplayObjectContainer to contain all of the items on the display list. Then, if necessary, add that DisplayObjectContainer instance to the Stage. — The DisplayObject instance to add as a child of this DisplayObjectContainer instance. — The DisplayObject instance that you pass in the parameter. \n\n — Dispatched when a display object is added to the display list. \n\n — Throws if the child is the same as the parent. Also throws if the caller is a child (or grandchild etc.) of the child being added. \n\n \n\nThe following example sets up two Sprite objects named and . A Sprite is a type of display object container. The example calls the method to set up the display hierarchy: is a child of , and two other display objects, and , are children of . The calls to the method show the number of children of each object. Note that grandchildren are not included in the count: import flash.display.Sprite; var container1:Sprite = new Sprite(); var container2:Sprite = new Sprite(); var circle1:Sprite = new Sprite(); circle1.graphics.beginFill(0xFFCC00); circle1.graphics.drawCircle(40, 40, 40); var circle2:Sprite = new Sprite(); circle2.graphics.beginFill(0x00CCFF); circle2.graphics.drawCircle(80, 40, 40); container2.addChild(container1); container1.addChild(circle1); container1.addChild(circle2); trace(container1.numChildren); // 2 trace(container2.numChildren); // 1 trace(circle1.numChildren); // 0 trace(circle2.numChildren); // 0 The following example sets up two Sprite objects namedand. A Sprite is a type of display object container. The example calls themethod to set up the display hierarchy:is a child of, and two other display objects,and, are children of. The calls to themethod show the number of children of each object. Note that grandchildren are not included in thecount: Adds a child DisplayObject instance to this DisplayObjectContainer instance. The child is added at the index position specified. An index of 0 represents the back (bottom) of the display list for this DisplayObjectContainer object. For example, the following example shows three display objects, labeled a, b, and c, at index positions 0, 2, and 1, respectively: If you add a child object that already has a different display object container as a parent, the object is removed from the child list of the other display object container. — The DisplayObject instance to add as a child of this DisplayObjectContainer instance. — The index position to which the child is added. If you specify a currently occupied index position, the child object that exists at that position and all higher positions are moved up one position in the child list. — The DisplayObject instance that you pass in the parameter. \n\n — Dispatched when a display object is added to the display list. \n\n — Throws if the index position does not exist in the child list. — Throws if the child is the same as the parent. Also throws if the caller is a child (or grandchild etc.) of the child being added. \n\n \n\nThe following example creates a display object container and adds a display objects to its display list. Then, by calling , it adds the object to index position zero (the back), and moves the object to index position 1: import flash.display.Sprite; var container:Sprite = new Sprite(); var circle1:Sprite = new Sprite(); var circle2:Sprite = new Sprite(); container.addChild(circle1); container.addChildAt(circle2, 0); trace(container.getChildAt(0) == circle2); // true trace(container.getChildAt(1) == circle1); // true The following example creates adisplay object container and adds a display objectsto its display list. Then, by calling, it adds theobject to index position zero (the back), and moves theobject to index position 1: Indicates whether the security restrictions would cause any display objects to be omitted from the list returned by calling the method with the specified point. By default, content from one domain cannot access objects from another domain unless they are permitted to do so with a call to the method. For more information, related to security, see the Flash Player Developer Center Topic: Security. The parameter is in the coordinate space of the Stage, which may differ from the coordinate space of the display object container (unless the display object container is the Stage). You can use the and the methods to convert points between these coordinate spaces. — The point under which to look. — if the point contains child display objects with security restrictions. \n\n \n\nThe following code creates a display object container named . The next block of code uses a Loader object to load a JPEG file named \"test.jpg\" from a remote file server. Note that the property of the LoaderContext object used as a parameter in the method is set to . Once the file is loaded, the code calls the method, which in turn calls , which returns a value of because the loaded content is assumed to be from an inaccessible domain: import flash.display.Sprite; import flash.display.Loader; import flash.system.LoaderContext; import flash.net.URLRequest; import flash.events.Event; import flash.geom.Point; var container:Sprite = new Sprite(); var urlReq:URLRequest = new URLRequest(\"http://localhost/RemoteFile.swf\"); var ldr:Loader = new Loader(); var context:LoaderContext = new LoaderContext(); context.checkPolicyFile = false; ldr.load(urlReq, context); ldr.contentLoaderInfo.addEventListener(Event.COMPLETE, loaded); ldr.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, urlNotFound); function loaded(event:Event):void { var pt:Point = new Point(1, 1); trace(container.areInaccessibleObjectsUnderPoint(pt)); // true } function urlNotFound(event:Event):void { trace(\"The URL was not found.\"); } This example assumes that the SWF file produced by this code is loaded from a different domain than that of the JPEG file, and that the loaded JPEG file occupies the point (1, 1). \n\n \n\n The following code creates a display object container named. The next block of code uses a Loader object to load a JPEG file named \"test.jpg\" from a remote file server. Note that theproperty of the LoaderContext object used as a parameter in themethod is set to. Once the file is loaded, the code calls themethod, which in turn calls, which returns a value ofbecause the loaded content is assumed to be from an inaccessible domain:This example assumes that the SWF file produced by this code is loaded from a different domain than that of the JPEG file, and that the loaded JPEG file occupies the point (1, 1). Determines whether the specified display object is a child of the DisplayObjectContainer instance or the instance itself. The search includes the entire display list including this DisplayObjectContainer instance. Grandchildren, great-grandchildren, and so on each return . — if the object is a child of the DisplayObjectContainer or the container itself; otherwise . \n\n \n\nThe following example sets up a number of Sprite objects and adds some to the child list of others. (A Sprite object is a type of display object container.) The relationship between various objects is shown by calling the method: import flash.display.Sprite; var sprite1:Sprite = new Sprite(); var sprite2:Sprite = new Sprite(); var sprite3:Sprite = new Sprite(); var sprite4:Sprite = new Sprite(); sprite1.addChild(sprite2); sprite2.addChild(sprite3); trace(sprite1.contains(sprite1)); // true trace(sprite1.contains(sprite2)); // true trace(sprite1.contains(sprite3)); // true trace(sprite1.contains(sprite4)); // false The following example sets up a number of Sprite objects and adds some to the child list of others. (A Sprite object is a type of display object container.) The relationship between various objects is shown by calling themethod: Returns the child display object instance that exists at the specified index. — The index position of the child object. — The child display object at the specified index position. \n\n — Throws if the index does not exist in the child list. — This child display object belongs to a sandbox to which you do not have access. You can avoid this situation by having the child movie call . \n\n \n\nThe following example creates a display object container named and then adds a three display objects to the child list of the object. The calls to the method then reveal the positions of the child objects: import flash.display.Sprite; var container:Sprite = new Sprite(); var sprite1:Sprite = new Sprite(); var sprite2:Sprite = new Sprite(); var sprite3:Sprite = new Sprite(); container.addChild(sprite1); container.addChild(sprite2); container.addChildAt(sprite3, 0); trace(container.getChildAt(0) == sprite3); // true trace(container.getChildAt(1) == sprite1); // true trace(container.getChildAt(2) == sprite2); // true The following example creates a display object container namedand then adds a three display objects to the child list of theobject. The calls to themethod then reveal the positions of the child objects: Returns the child display object that exists with the specified name. If more that one child display object has the specified name, the method returns the first object in the child list. The method is faster than the method. The method accesses a child from a cached array, whereas the method has to traverse a linked list to access a child. — The name of the child to return. — The child display object with the specified name. \n\n — This child display object belongs to a sandbox to which you do not have access. You can avoid this situation by having the child movie call the method. \n\n \n\nThe following example creates a display object container named and then adds two child display objects to the container. Then, the code calls the and methods to return the index position of the child of the object that has the . import flash.display.Sprite; import flash.display.DisplayObject; var container:Sprite = new Sprite(); var sprite1:Sprite = new Sprite(); sprite1.name = \"sprite1\"; var sprite2:Sprite = new Sprite(); sprite2.name = \"sprite2\"; container.addChild(sprite1); container.addChild(sprite2); var target:DisplayObject = container.getChildByName(\"sprite1\"); trace(container.getChildIndex(target)); // 0 The following example creates a display object container namedand then adds two child display objects to the container. Then, the code calls theandmethods to return the index position of the child of theobject that has the — The index position of the child display object to identify. \n\n — Throws if the child parameter is not a child of this object. \n\n \n\nThe following example creates a display object container named and then adds two child display objects to the container. Then, the code calls the and methods to return the index position of the child of the object that has the . import flash.display.Sprite; import flash.display.DisplayObject; var container:Sprite = new Sprite(); var sprite1:Sprite = new Sprite(); sprite1.name = \"sprite1\"; var sprite2:Sprite = new Sprite(); sprite2.name = \"sprite2\"; container.addChild(sprite1); container.addChild(sprite2); var target:DisplayObject = container.getChildByName(\"sprite1\"); trace(container.getChildIndex(target)); // 0 The following example creates a display object container namedand then adds two child display objects to the container. Then, the code calls theandmethods to return the index position of the child of theobject that has the Returns an array of objects that lie under the specified point and are children (or grandchildren, and so on) of this DisplayObjectContainer instance. Any child objects that are inaccessible for security reasons are omitted from the returned array. To determine whether this security restriction affects the returned array, call the method. The parameter is in the coordinate space of the Stage, which may differ from the coordinate space of the display object container (unless the display object container is the Stage). You can use the and the methods to convert points between these coordinate spaces. — The point under which to look. — An array of objects that lie under the specified point and are children (or grandchildren, and so on) of this DisplayObjectContainer instance. \n\n \n\nThe following example creates a display object container named and then adds two overlapping child display objects to the container. Then the code calls the twice  first using a point that touches only one object, then using a point where the objects overlap  and the of the return Array shows the number of objects at each point in the container: import flash.display.Sprite; import flash.geom.Point; var container:Sprite = new Sprite(); var square1:Sprite = new Sprite(); square1.graphics.beginFill(0xFFCC00); square1.graphics.drawRect(0, 0, 40, 40); var square2:Sprite = new Sprite(); square2.graphics.beginFill(0x00CCFF); square2.graphics.drawRect(20, 0, 30, 40); container.addChild(square1); container.addChild(square2); var pt:Point = new Point(10, 20); var objects:Array = container.getObjectsUnderPoint(pt); trace(objects.length); // 1 pt = new Point(35, 20); objects = container.getObjectsUnderPoint(pt); trace(objects.length); // 2 The following example creates a display object container namedand then adds two overlapping child display objects to the container. Then the code calls thetwice  first using a point that touches only one object, then using a point where the objects overlap  and theof the return Array shows the number of objects at each point in the container: Removes the specified DisplayObject instance from the child list of the DisplayObjectContainer instance. The property of the removed child is set to , and the object is garbage collected if no other references to the child exist. The index positions of any display objects above the child in the DisplayObjectContainer are decreased by 1. The garbage collector reallocates unused memory space. When a variable or object is no longer actively referenced or stored somewhere, the garbage collector sweeps through and wipes out the memory space it used to occupy if no other references to it exist. — The DisplayObject instance that you pass in the parameter. \n\n — Throws if the child parameter is not a child of this object. \n\n \n\nThe following example creates a display object container named and then adds two child display objects to the container. An event listener is added to the object, so that when the user clicks a child object of the container, the method removes the child clicked from the child list of the container: import flash.display.DisplayObject; import flash.display.Sprite; import flash.events.MouseEvent; var container:Sprite = new Sprite(); addChild(container); var circle1:Sprite = new Sprite(); circle1.graphics.beginFill(0xFFCC00); circle1.graphics.drawCircle(40, 40, 40); var circle2:Sprite = new Sprite(); circle2.graphics.beginFill(0x00CCFF); circle2.graphics.drawCircle(120, 40, 40); container.addChild(circle1); container.addChild(circle2); container.addEventListener(MouseEvent.CLICK, clicked); function clicked(event:MouseEvent):void { container.removeChild(DisplayObject(event.target)); } The following example creates a display object container namedand then adds two child display objects to the container. An event listener is added to theobject, so that when the user clicks a child object of the container, themethod removes the child clicked from the child list of the container: Removes a child DisplayObject from the specified position in the child list of the DisplayObjectContainer. The property of the removed child is set to , and the object is garbage collected if no other references to the child exist. The index positions of any display objects above the child in the DisplayObjectContainer are decreased by 1. The garbage collector reallocates unused memory space. When a variable or object is no longer actively referenced or stored somewhere, the garbage collector sweeps through and wipes out the memory space it used to occupy if no other references to it exist. — The child index of the DisplayObject to remove. — The DisplayObject instance that was removed. \n\n — This child display object belongs to a sandbox to which the calling object does not have access. You can avoid this situation by having the child movie call the method. — Throws if the index does not exist in the child list. \n\n \n\nThe following example creates a display object container named and then adds two child display objects to the container. The code then shows that when you call the method to remove the child at the lowest index position (0), any other child object in the list moves down one position: import flash.display.Sprite; var container:Sprite = new Sprite(); var sprite1:Sprite = new Sprite(); sprite1.name = \"sprite1\"; var sprite2:Sprite = new Sprite(); sprite2.name = \"sprite2\"; container.addChild(sprite1); container.addChild(sprite2); trace(container.numChildren) // 2 container.removeChildAt(0); trace(container.numChildren) // 1 trace(container.getChildAt(0).name); // sprite2 The following example creates a display object container namedand then adds two child display objects to the container. The code then shows that when you call themethod to remove the child at the lowest index position (0), any other child object in the list moves down one position: Removes all DisplayObject instances from the child list of the DisplayObjectContainer instance. The property of the removed children is set to , and the objects are garbage collected if no other references to the children exist. The garbage collector reallocates unused memory space. When a variable or object is no longer actively referenced or stored somewhere, the garbage collector sweeps through and wipes out the memory space it used to occupy if no other references to it exist. (default = ) — The beginning position. A value smaller than 0 throws a . (default = ) — The ending position. A value smaller than 0 throws a . \n\n — Throws if the or positions do not exist in the child list. Changes the position of an existing child in the display object container. This affects the layering of child objects. For example, the following example shows three display objects, labeled a, b, and c, at index positions 0, 1, and 2, respectively: When you use the method and specify an index position that is already occupied, the only positions that change are those in between the display object's former and new position. All others will stay the same. If a child is moved to an index LOWER than its current index, all children in between will INCREASE by 1 for their index reference. If a child is moved to an index HIGHER than its current index, all children in between will DECREASE by 1 for their index reference. For example, if the display object container in the previous example is named , you can swap the position of the display objects labeled a and b by calling the following code: This code results in the following arrangement of objects: — The child DisplayObject instance for which you want to change the index number. — The resulting index number for the display object. \n\n — Throws if the index does not exist in the child list. — Throws if the child parameter is not a child of this object. \n\n \n\nThe following example creates a display object container named and then adds three slightly overlapping child display objects to the container. When the user clicks any of these objects, the method calls the method to move the clicked object to the top-most position in the child list of the object: import flash.display.Sprite; import flash.events.MouseEvent; var container:Sprite = new Sprite(); addChild(container); var circle1:Sprite = new Sprite(); circle1.graphics.beginFill(0xFF0000); circle1.graphics.drawCircle(40, 40, 40); circle1.addEventListener(MouseEvent.CLICK, clicked); var circle2:Sprite = new Sprite(); circle2.graphics.beginFill(0x00FF00); circle2.graphics.drawCircle(100, 40, 40); circle2.addEventListener(MouseEvent.CLICK, clicked); var circle3:Sprite = new Sprite(); circle3.graphics.beginFill(0x0000FF); circle3.graphics.drawCircle(70, 80, 40); circle3.addEventListener(MouseEvent.CLICK, clicked); container.addChild(circle1); container.addChild(circle2); container.addChild(circle3); addChild(container); function clicked(event:MouseEvent):void { var circle:Sprite = Sprite(event.target); var topPosition:uint = container.numChildren - 1; container.setChildIndex(circle, topPosition); } The following example creates a display object container namedand then adds three slightly overlapping child display objects to the container. When the user clicks any of these objects, themethod calls themethod to move the clicked object to the top-most position in the child list of theobject: Recursively stops the timeline execution of all MovieClips rooted at this object. Child display objects belonging to a sandbox to which the excuting code does not have access are ignored. Note: Streaming media playback controlled via a NetStream object will not be stopped. Swaps the z-order (front-to-back order) of the two specified child objects. All other child objects in the display object container remain in the same index positions. \n\n — Throws if either child parameter is not a child of this object. \n\n \n\nThe following example creates a display object container named , then adds two child display objects to the container, and then shows the effect of a call to the method: import flash.display.Sprite; var container:Sprite = new Sprite(); var sprite1:Sprite = new Sprite(); sprite1.name = \"sprite1\"; var sprite2:Sprite = new Sprite(); sprite2.name = \"sprite2\"; container.addChild(sprite1); container.addChild(sprite2); trace(container.getChildAt(0).name); // sprite1 trace(container.getChildAt(1).name); // sprite2 container.swapChildren(sprite1, sprite2); trace(container.getChildAt(0).name); // sprite2 trace(container.getChildAt(1).name); // sprite1 The following example creates a display object container named, then adds two child display objects to the container, and then shows the effect of a call to themethod: Swaps the z-order (front-to-back order) of the child objects at the two specified index positions in the child list. All other child objects in the display object container remain in the same index positions. — The index position of the first child object. — The index position of the second child object. \n\n — If either index does not exist in the child list. \n\n \n\nThe following example creates a display object container named , then adds three child display objects to the container, and then shows how a call to the method rearranges the child list of the display object container: import flash.display.Sprite; var container:Sprite = new Sprite(); var sprite1:Sprite = new Sprite(); sprite1.name = \"sprite1\"; var sprite2:Sprite = new Sprite(); sprite2.name = \"sprite2\"; var sprite3:Sprite = new Sprite(); sprite3.name = \"sprite3\"; container.addChild(sprite1); container.addChild(sprite2); container.addChild(sprite3); trace(container.getChildAt(0).name); // sprite1 trace(container.getChildAt(1).name); // sprite2 trace(container.getChildAt(2).name); // sprite3 container.swapChildrenAt(0, 2); trace(container.getChildAt(0).name); // sprite3 trace(container.getChildAt(1).name); // sprite2 trace(container.getChildAt(2).name); // sprite1 The following example creates a display object container named, then adds three child display objects to the container, and then shows how a call to themethod rearranges the child list of the display object container: to create five orange squares in succession. This task is accomplished by performing the following steps:\n• A loop creates the five orange squares and positions them one after another.\n• Each time a CustomSprite object is created, its constructor calls the method of the object, which creates a 50-by-50-pixel square by calling the , , and methods of the Graphics class. The method adds each square to the display list. package { import flash.display.DisplayObject; import flash.display.Sprite; public class DisplayObjectContainerExample extends Sprite { private var gutter:uint = 5; private var childCount:uint = 5; public function DisplayObjectContainerExample() { configureAssets(); } private function configureAssets():void { var child:Sprite = new CustomSprite(); var lastChild:Sprite = child; for (var i:uint = 1; i <= childCount; i++) { child = new CustomSprite(); child.x = lastChild.x + lastChild.width + gutter; addChild(child); lastChild = child; } } } } import flash.display.Sprite; class CustomSprite extends Sprite { private var size:uint = 50; private var bgColor:uint = 0xFFCC00; public function CustomSprite() { draw(size, size); } private function draw(w:uint, h:uint):void { graphics.beginFill(bgColor); graphics.drawRect(0, 0, w, h); graphics.endFill(); } } The following example uses the classto create five orange squares in succession. This task is accomplished by performing the following steps:"
    },
    {
        "link": "https://oreilly.com/library/view/the-actionscript-30/9780596155247/ch01.html",
        "document": "The term “perfect” is a powerful word. From a practical standpoint, it represents a state that arguably cannot be achieved. Hey, that’s a relief already! This book doesn’t expect the impossible. This isn’t the print version of an office know-it-all, itching for you to slip up. You won’t hear any anxious hand wringing in these pages over why you haven’t yet upgraded to, much less mastered, ActionScript 3.0. (Yes, even though it was available in Flash CS3 Professional.) Instead, the following chapters will take their cue from a sage observation by William Fowble: If you chase perfection, you often catch excellence. In other words, chin up! Aim for the best and enjoy the road trip. ActionScript 3.0—the current version of the programming language for the Adobe Flash Platform—is a language that indeed catches excellence. This book is designed to explain a bit about why that is. In so doing, our hope is to help you chase perfection by introducing you to the improved organization, syntax, and workflows of the new language. Catching excellence, for all of us, is a matter of practice, and comes with time.\n\nThis book is going to introduce you to new ways of thinking about the Flash Platform. ActionScript 3.0 requires these new ways because the language is actually structured around them. That’s a big part of why the new language improves on previous versions. Like its precursor, but to a greater extent, ActionScript 3.0 is based on a specification called ECMAScript, which is a standard proposed by a body of experts known as Ecma International. This group is something like the World Wide Web Consortium (W3C), whose responsibility includes HTML, XML, CSS, and other widely used markup languages. Such a standard’s benefit is that ActionScript 3.0 isn’t just an arbitrary language invented to meet Adobe’s needs. ECMAScript is a relatively mature specification, already in its third revision. The Ecma International team includes authorities from industry powerhouses like Microsoft, the Mozilla Foundation, and Adobe. The specification is built on the collective insight and success of these diverse experts in the field. Of all the versions of ActionScript, the current version comes closest into full compliance with this specification—at this point, closer even than the other famous ECMAScript derivative, JavaScript. This makes ActionScript 3.0 a model of best practices, habits you can use in both Flash CS4 Professional and Flex Builder 3. In many cases, you may even find that these practices benefit your involvement with existing projects coded in previous versions of ActionScript. Sure, the syntactical details change, but achievement in programming is all about structure and purpose. It’s the concepts and good habits that carry you.\n\nFor the nuts and bolts, the relevant ActionScript Language Reference is always a mere keystroke away (the F1 key). Even so, a new set of Help docs can be daunting, especially if you’re already well-versed in ActionScript 2.0. Fortunately, the ActionScript 3.0 documentation is every bit as helpful as it used to be, even if it looks different. The layout of the Help docs is still organized around the layout of the language itself—around the classes that define the objects you will use—and its class entries still summarize the usable apparatus of each object: its characteristics, called properties; the things it can do, called methods; and the things it can react to, called events. In the new documentation, code samples are presented as custom classes, rather than frame scripts. This requires you test them as standalone, simple text files, according to the new document class concept described in Chapter 6. Fortunately, this also means you can test these classes in other programs, such as Flex Builder. This book will help you get familiar not only with the new language, but also with the documentation that explains it.\n\nKeep in mind, ramping up to ActionScript 3.0 isn’t merely about learning the latest syntax: it’s about becoming a better, more efficient programmer. This isn’t meant to slight ActionScript 2.0 at all, but plenty has changed since its introduction in late 2003. It’s no exaggeration to say that several aspects of the language have been completely overhauled. In fact, ActionScript 3.0 requires an entirely new virtual machine, which is the module inside Flash Player that interprets compiled ActionScript. As of Flash Player 9, the runtime that displays Flash movies does so with two virtual machines: AVM1 for legacy SWF files based on ActionScript 1.0 and 2.0, and the new AVM2 for ActionScript 3.0. That’s a first in the history of Flash Player. Thanks to the new virtual machine, ActionScript 3.0 runs faster and more efficiently by an order of magnitude. This bodes well for the overriding goal of the new language: to facilitate a wide range of interactive media and Rich Internet Applications (RIAs)—to do so simply, with better performance, and highly compatible with industry standards. As you can imagine, an upgrade of this scale means you may have to reshape some of your current habits. But take heart. Reshape doesn’t necessarily mean tear down and rebuild. As ActionScript has matured, it has consistently moved in the direction it currently stands. Again, honing your skills in light of ActionScript 3.0 will help you in your current projects and also in legacy project maintenance. Migration can be intimidating, but much of that uncertainty comes from trying to find your stride. Once you take the first few steps, the momentum keeps you going.\n\nHere’s a look at some of the new features.\n\nSection 4 of the ECMAScript standard (http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf) defines an important facet of any language that implements it. Such languages “will provide not only the objects and other facilities described in this specification but also certain environment-specific host objects, whose description and behaviour are beyond the scope of this specification.” In other words, any ECMAScript derivative needs a set core functionality that stands on its own and will then provide additional functionality specific to the environment that interprets it. This is exactly what ActionScript 3.0 does, and its host environments include Flash Player for web browsers, intended for Flash-enabled websites such as http://YouTube.com; Flash Lite for devices, such as video games for your cell phone; and Adobe Integrated Runtime (AIR) for applications installed on the hard drive, such as eBay Desktop (http://desktop.ebay.com/). Here is a brief summary of a number of core updates. In ActionScript 2.0, many runtime errors failed without drawing attention to themselves. On the plus side—and this is a very weak plus—this meant that errors of this sort often failed “gracefully.” In other words, they might not halt someone’s experience with something abrupt or laden with technical jargon, such as an alert or dialog box. On the minus side, this also meant such errors might go unnoticed by the developer—until complaints started rolling in that people were experiencing slow playback or even lockups. Such errors could be hard for developers to pinpoint and repair, precisely because they were silent. ActionScript 3.0 allows for a variety of runtime exceptions to be handled with purpose. This includes objects generated both by the runtime environment and, potentially, by the programmer. In ActionScript 3.0, the class is considerably more robust than its forerunner, and tailor-made objects can be built from this class as desired, inheriting and extending its functionality to provide highly customized error messages. Exceptions can even provide source file and line number information, which greatly enhances the debugging experience, letting developers quickly track down errors. ActionScript 2.0 introduced the ability to strongly type variables, parameters, and function return values. This was, and still is, an optional way to let Flash know exactly what sort of data a particular variable, parameter, or return value could cope with. This ability was a boon to developers in terms of debugging, because it gave you a way to display error messages in cases of a type mismatch. For example, if you were going to perform a math operation on two numbers provided by the user, you might take those numbers from input text fields. This would actually make them strings, which meant your math operation would give you unexpected results (for example, 1 + 2 would become “12” instead of 3). By strongly typing the parameters of the function that performed this operation—in other words, by specifying intended variable types with a colon ( ), then the type—you could benefit from a meaningful error message in the Output panel such as this: A type mismatch notice is a great reminder to use something like or to convert those strings into numeric values. Useful indeed, but this was only a first step in a good direction. In ActionScript 2.0, this sort of error checking only occurred at compile time. Under many circumstances—such as evaluating data from dynamic sources like XML—the feature wasn’t “smart” enough to catch every contingency. In ActionScript 3.0, it is. Following in the same vein as runtime exceptions and runtime types, ActionScript 3.0 establishes the concept of sealed classes in a stricter, more formalized way than in ActionScript 2.0. A sealed class is one that can’t have properties or methods assigned to it at runtime, such as . By default, classes in ActionScript 3.0 are sealed, but this can be overruled when you write your own. var str:String = \"\" // Or: new String(); str. = \"This generates a compiler error.\"; // Displays: Access of possibly undefined property // through a reference with static type String. In contrast, a class that actually can have properties and methods assigned to it at runtime is called dynamic. One of the most familiar dynamic classes is , though historically speaking, many frame script developers haven’t considered movie clips in terms of a class. The same could be said of buttons and text fields, because you can create such elements with Flash’s drawing tools. (Of the elements just mentioned, only movie clips are dynamic.) For frame script coders, movie clips are often thought of simply as symbols or timelines, and timelines have always been able to receive new variables at runtime. True enough. What’s really going on, though, is that variables defined in keyframe scripts are in reality dynamic properties of a instance; functions are actually dynamic methods. Declaring a variable in a keyframe of the main timeline or in a movie clip’s timeline is conceptually the same as the following: var mc:MovieClip = new MovieClip(); mc.customProperty = \"This is perfectly acceptable.\"; Custom classes in ActionScript 3.0 can behave this way too, if and only if they are declared with the attribute: On paper, this is also how it was in ActionScript 2.0, but in fact, even non-dynamic classes could be altered at runtime by manipulation of the property (inherited by all objects) or by the array access operator ( ). Advanced programmers who used such an approach in the past will find it no longer works in ActionScript 3.0 for sealed classes. // ActionScript 2.0 var str:String = \"\"; str.customProperty = \"Secret back door.\"; // Displays: There is no property with the name 'customProperty'. str = \"Secret back door.\"; // Works just fine in ActionScript 2.0, but in 3.0 displays: Cannot create property customProperty on String. In ActionScript 3.0, non-dynamic classes actually are what they claim to be. This makes for stricter compile-time checking and improves memory usage because class instances can now be guaranteed to require no more than a pre-declared amount of system memory. Of all the updates to ActionScript 3.0, it’s no surprise that developers, regardless of skill level, encounter one in particular early on: method closures. Why? Because the introduction of method closures changes the point of view, or scope, of methods in ActionScript 3.0. Scope refers to the conceptual area of a program in which code executes. The availability of code definitions, such as variables, functions, properties, and methods, depends on the scope of the code being executed. For example, if a variable is declared in a timeline frame, that variable can be referenced by any other code in that frame, as long as that code appears after the declaration. Even a function defined in that frame can reference the variable scoped to the timeline, because scopes can be nested, and the flow moves from outer scope to inner: the timeline’s definitions become available to the function. // A variable declared here ... var favoriteCereal:String = \"Star Crunchers!\"; // can be referenced here ... trace(favoriteCereal); // Displays: Star Crunchers! function myFunction():void { // and here ... trace(favoriteCereal); // Displays: Star Crunchers! } myFunction(); In contrast, a variable declared inside a function can only be referenced by that function, because the scope of the function is confined to itself. function myFunction():void { // A variable declared here ... var favoriteCereal:String = \"Star Crunchers!\"; // can only be referenced here ... trace(favoriteCereal); // Displays: Star Crunchers! } myFunction(); // but not in the outer scope ... trace(favoriteCereal); // Displays: **Error** Scene=Scene 1, layer=Layer 1, frame=1:Line 10: Access of undefined property favoriteCereal. Up to now, this should be familiar to ActionScript 2.0 developers. How, then, have things changed? Consider the next few examples. In ActionScript 2.0, a button click might be handled like this: Prior to ActionScript 3.0, the scope of the function shown belonged to the instance. In this case, the button code could conveniently be abbreviated with the use of the keyword, which self-referenced the current scope ( ). In some cases, this made for a handy way to achieve certain goals. For example, to repeatedly loop a instance in ActionScript 2.0, the following would do: Again, the function is scoped to the instance. In this case, the expression amounts to invoking the method on the instance. Although convenient in this sort of situation, difficulties arose when the event handler needed to reference objects outside the scope of the function, especially in custom classes. To a large extent, this issue could be addressed in ActionScript 2.0 with the class, which allowed you to reroute the scope as desired: The method accepted two parameters: first, the desired scope; second, the function or method to execute in that scope. Note that because of this change, the function invokes directly. In this case, the keyword no longer refers to the instance to which the listener was attached, but rather to the timeline frame in which the listener was assigned. In ActionScript 3.0, method closures let a function or method remember where it was defined. In short, you get the best of both worlds. In the following ActionScript 3.0, written in a keyframe, the reference to shows that the scope belongs to the main timeline—to the frame in which the function is defined, rather than to the instance. No extra baggage, like the class, is required. To reference the button rather than the frame, use the property of the parameter that is passed into the function automatically by the event. In this snippet, the parameter is arbitrarily named : Flash has long supported XML, but the addition of ECMAScript for XML (E4X) syntax is a significant productivity boost. Like ActionScript, E4X is an Ecma International specification, which affords a powerful yet concise set of language constructs for retrieving data from XML, and manipulating it. In ActionScript 2.0, you can certainly navigate among the nodes of a loaded XML document, but the effort becomes progressively more tedious as the XML’s complexity increases. The ActionScript 2.0 class provides a handful of necessary navigation properties, such as , , , and . Choosing from these, and assuming an XML document has already been loaded and parsed into an instance named , you might select the title of the fifth track of The Beatles’ Abbey Road album (“Octopus’s Garden”) like this: // ActionScript 2.0 ¬ // Contents of the loaded XML document <?xml version=\"1.0\" encoding=\"iso-8859-1\"?> <library> <artist name=\"The Beatles\"> <album name=\"Abbey Road\"> <track title=\"Come Together\" /> <track title=\"Something\" /> <track title=\"Maxwell's Silver Hammer\" /> <track title=\"Oh! Darling\" /> <track title=\"Octopus's Garden\" /> <track title=\"I Want You (She's So Heavy)\" /> <track title=\"Here Comes the Sun\" /> <track title=\"Because\" /> <track title=\"You Never Give Me Your Money\" /> <track title=\"Sun King\" /> <track title=\"Mean Mr. Mustard\" /> <track title=\"Polythene Pam\" /> <track title=\"She Came in Through the Bathroom Window\" /> <track title=\"Golden Slumbers\" /> <track title=\"Carry That Weight\" /> <track title=\"The End\" /> <track title=\"Her Majesty\" /> </album> </artist> </library> In the preceding whopping expression, refers to the parsed XML document; the three mentions of refer, respectively, to the , , and nodes; and refers to the fifth node (bear in mind, returns an array, and arrays start at zero). Finally, the property leads to the attribute of the selected node. E4X lets parsed XML be referenced as if it were a native object. This lets you traverse the loaded data incredibly more intuitively. In the ActionScript 3.0 equivalent, the same track can be referenced like this: or, thanks to the descendent accessor operator ( ), even something as short as this: Which would you rather type? In addition, you can compare data using a familiar set of operators. For example, if the XML document at hand contains numerous recording artists, The Beatles’ node could be singled out as easily as this: The E4X specification is available in Adobe PDF format at the Ecma International website: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-357.pdf. The term regular expressions refers to a set of specialized language constructs for retrieving data from strings (that is, text content), and manipulating such data. In this regard, regular expressions (often abbreviated as regex) shares a number of similarities with E4X: both mechanisms are compact and efficient in their tasks. The syntax of regex tends to be initially harder to grasp than E4X—here, normal letters and punctuation are used to represent whole sets of characters, in addition to filtering rules—but the results are well worth the effort. What can you do with regular expressions? To answer that, consider two familiar methods of the class, and , which have been available in ActionScript for years. These methods both accept two parameters: first, a string to look for within a container string; second, optionally, where to start looking within the container string. Each method takes its starting point from opposite ends of the container string. In the first statement, only one parameter is supplied, , and the return value is 13 because the letter “o” makes its first appearance at index 13 (starting with 0, the thirteenth character in the string ). In the second statement, the return value is 18 because of the optional second parameter , which instructs the method to begin after the index of the first “o”. In the third statement, the return value is 40 because the method begins its search from the end of the string. For simple searches, and fit the bill, but what if the requirement is something like “find all US ZIP codes,” which could be any 5-number combination, or “find all words in this paragraph that contain three or more vowels”? Suddenly, the task seems considerably more difficult, if not impossible. Believe it or not, the class in ActionScript 3.0 handles this requirement very easily. The solution requires a pattern of specialized characters, expressed either as an instance of the class or passed as a parameter to one of the regex-related methods of the String class ( , , or ). Given a variable, , set to the text content of the previous paragraph, the following code shows how to retrieve words with three or more vowels: var re:RegExp = ; var result:Object = re.exec(paragraph); while (result != null) { trace(result[0]); result = re.exec(paragraph); } // Displays: searches, indexOf, lastIndexOf, requirement, // something, and other words with three or more vowels A full discussion of regular expressions syntax is beyond the scope of this book, but here’s a brief overview of how the previous example works. A variable, , is set to an instance of the class by way of the RegExp delimiter operator ( ). Between the two slashes of this operator, the pattern spells out the search requirement. After the second slash, the flags ( ) configure the pattern as global and case insensitive. The method executes the pattern on the string and returns an object ( ) that contains information about the search. The search is repeated until is . If the preceding example seems outlandish, imagine the same sort of power applied to the validation of user input. You can manage even potentially complex requirements without much difficulty. These include questions such as, “Is this email address correctly formed?” (Checking for the “@” character isn’t enough!) “Is this a valid telephone number?” (People might enter anything from (123) 456-7890 to 123.456.46789 to 123456789.) “Has the user tried to sneak in an inappropriate word by using a nonstandard spelling?” Patterns that match these requirements not only find the strings in question, but can also manipulate them in order to, for example, format telephone numbers consistently or replace questionable words with Xs. For an exhaustive and highly regarded treatise on regular expressions, be sure to read Mastering Regular Expressions, by Jeffrey Friedl (O’Reilly). Numerous tutorials are also available online at the unrelated http://www.regular-expressions.info/ website. In advanced programming scenarios, the concept of namespaces brings a valuable new mechanism to ActionScript 3.0. In short, namespaces are essentially custom access specifiers—like , , , and —except with names you choose. Namespaces let you control the visibility of your properties and methods, even to the point of overriding package structures. They also let you qualify members under various guises. As a quick example, you might develop an AIR application that performs one behavior while an Internet connection is present, and another when no connection is present. By using namespaces, you can define multiple versions of the same method that, for instance, checks an online inventory when the user’s WiFi connection is available but defaults to a cached version otherwise. Or you might define series of variables in several languages, where the value of a variable depends on the user’s regional settings. These distinctions are determined by custom prefixes and the name qualifier operator ( ): // Three versions of the same String variable english::newFeatures // Value of \"Lots of new stuff\" german::newFeatures // Value of \"Viele neue Sachen\" french::newFeatures // Value of \"Plien de nouvelles choses\" Namespaces are outfitted with a Universal Resource Identifier (URI) to avoid collisions, and are also used to represent XML namespaces when working with E4X. ActionScript 3.0 introduces two new primitive types, and , bringing the full list to , , , , , , and (note the change in capitalization from ). These new numeric types reduce memory usage in cases when a numeric value need only be an integer. How? The familiar data type is an IEEE-754 double-precision floating-point number, which, thanks to its structure, always requires 64 bits of memory. objects range from 1.79e+308 (1.79 with over 300 zeroes after it!) down to 5e-324. That’s an unimaginably large range, which isn’t always necessary. Sometimes you just want to count through a loop, and all you need is an integer. Enter , which is a relatively small 32-bit number (only 4 bytes), whose range is still an impressive 2,147,483,647 (over two billion) down to −2,147,483,648. That range should do for most of the loops you’ll encounter. By contrast, numbers (unsigned integers) range from 0 to 4,294,967,295, which is the same span as , but entirely on the positive side of the number line. If your loop’s counter, or any other integer value, needs a higher range than offered by , makes a good choice—provided the range doesn’t dip below zero. Neither type ever requests more than 32 bits of system memory. One note of caution: because values are always positive, take care when trying to subtract a into negative territory. A rolls around to 4,294,967,295 if you subtract it past zero, as the following code demonstrates.\n\nIn the “ActionScript 3.0, the Language” section of this chapter, you learned that the ECMAScript specification on which ActionScript is based actually expects the language to provide functionality tailored to the platform that hosts it. In the case of ActionScript, hosts include Flash Player, AIR, and Flash Lite—all various flavors of the Flash Platform. Though each host is designed to meet specific needs—websites, desktop applications, and mobile content, respectively—their overlap is considerable. ActionScript 3.0 institutes a significant restructuring of its application programming interface (API), summarized handily in the colossal migration table available on the Adobe LiveDocs website (http://help.adobe.com/en_US/AS3LCR/Flash_10.0/migration.html) and also in the Help panel in the appendices of the ActionScript 3.0 Language and Component Reference, under the heading “ActionScript 2.0 Migration”. In large part, existing functionality has been restructured into packages that make better sense from an organizational standpoint. However, Flash does have a number of philosophical changes in the way it carries out its fundamental tasks. The following paragraphs list some of the more notable updates. As of the publication of this book, Flash Lite does not yet support ActionScript 3.0, due to the inherent processor and memory limitations of mobile devices. The features recounted here apply to Flash Player 9 (and higher) and AIR, but won’t apply to Flash Lite until that runtime adds support for ActionScript 3.0. Before ActionScript 3.0, you could handle events in Flash in at least five different ways, some of which were interchangeable:\n• None The legacy handler, available since Flash 2 and still in wide use, even in ActionScript 2.0 scenarios, but gone in ActionScript 3.0\n• None The legacy handler, also widely used and unavailable in ActionScript 3.0\n• None The dot notation syntax that combined and replaced and (for example , , and so on)\n• None The method of several—but not all!—ActionScript 2.0 classes, such as , , and\n• None The method used by the v2 component set (user interface, data, and media components) This varied assortment was a result of incremental improvements to ActionScript with every new release of the authoring tool, with the older approaches retained for backward compatibility. For longtime Flash developers, each new technique was simply a small addition to the workflow, but newcomers to recent versions, such as Flash 8 or Flash CS3, were understandably confused by an API with so many seemingly arbitrary possibilities. Are and really so bad? From a workflow standpoint, no. From a practical standpoint, they aren’t nearly as valuable as their dot notation replacement. In ActionScript 2.0, the combination of and provide access to only slightly more than half the events available to movie clips and buttons. In addition, you can’t assign, manipulate, or remove their event handlers at runtime. Their absence in ActionScript 3.0 marks the end of a long transition period from ActionScript 1.0 through 2.0. Because ActionScript 3.0 relies on a new virtual machine, it can afford to make a clean break in the way it handles events. With one small exception (discussed in Chapter 4), event handling is now consolidated across the board into a single, consistent approach: the method. This mechanism is based on the W3C’s Document Object Model (DOM) Level 3 Events Specification (http://www.w3.org/TR/DOM-Level-3-Events/). This means that in ActionScript 3.0, event handling syntax is the same in nearly all cases, no matter if the event dispatcher is a button, an audio clip, or a loader object for XML or JPEG files. The basic structure looks like this: In ActionScript 3.0, movie clips can be instantiated with the keyword as easily as this: which is more intuitive than what it took in ActionScript 2.0: And it gets better. Depth management is now automatic. Notice that the expression does not require a depth parameter. This change is due to a fundamental new approach to the display of visual objects in ActionScript 3.0: a concept called the display list, which represents the hierarchical display of all graphical objects in Flash Player. This concept is embodied in the class, the base class for all objects that can serve as visual containers, including movie clips, the new and classes, and more. Thanks to inheritance, provides new methods to these classes for considerably better control over the management of object z-order. For example, while the class in ActionScript 2.0 featured and , the ActionScript 3.0 version offers all of these: These methods are also available to , which is effectively a movie clip without the overhead of a timeline; , which loads external SWF files and image files (JPEG, PNG, or GIF) at runtime; and any other class in the family tree. Under the display list system, objects can be re-parented at any time. This ability simplifies cases in which groups of objects need to be manipulated at once. Consider a jigsaw puzzle game, for example. If you want to combine partially solved areas, so that snapped-together pieces move as one unit, you can simply remove the piece from its current parent and add it as a child to the parent that represents the partially solved group. Before ActionScript 3.0, this action would have required individual sophisticated tracking of each jigsaw piece. Flash Player 8 was the first to support 32 simultaneous sound channels, a significant increase from the original eight-sound channel limit. Although present for as long as Flash Player has supported sound, these sound channels, as such, had no clear representation in code before ActionScript 3.0. In previous versions of the language, the class was self-contained, handling all of its functionality in a relatively simple manner, but at the cost of some clarity of purpose. For example, in order to control the volume and panning of one sound distinctly from another, you had to associate each sound with its own movie clip. You made this association by way of an optional “target” parameter in the constructor function. Because target movie clips might or might not contain other content, their ambiguous roles had the potential to confuse. ActionScript 3.0 clarifies programmed sound by complementing the class with three companions: , , and . These new APIs give you more explicit control over imported and embedded sounds. The method even lets you retrieve spectral data from sounds, which you can use to program responses to changes in audio pitch and volume. The new class enables interoperability with existing custom protocols, and lets advanced developers read, write, and manipulate data on the byte level. This has led adventurous programmers to cultivate projects previously unheard of in Flash, such as Tinic Uro’s PNG encoder (http://www.kaourantin.net/2005/10/png-encoder-in-as3.html, now updated and featured in the as3corelib library at http://code.google.com/p/as3corelib/) and a dynamic tone generator by André Michelle and Joa Ebert, capable of playing MIDI-like Amiga MOD files (http://8bitboy.popforge.de/).\n\nAlthough this book focuses primarily on the Flash authoring tool, it’s important to realize that Adobe offers two official ActionScript 3.0 compilers. One of these compilers is built into Flash CS4 itself. As you would expect, this one takes into consideration objects in the document’s Library, as well as global SWF file settings, such as background color and frame rate, as configured in the Property inspector. This compiler can also compile previous versions of ActionScript. Separate from that, there’s the command line compiler included with the free Flex Software Development Kit (SDK) available at http://www.adobe.com/go/flex_trial/. This second compiler is the one used by the Flex Builder integrated development environment (IDE), which doesn’t include drawing tools, timelines, or a library. In addition to ActionScript 3.0, the Flex compiler understands MXML, the declarative markup language used for laying out Flex applications. For want of a library, the second compiler lets metadata embed assets into resultant SWF files. The Flash authoring tool supports only limited metadata, an undocumented feature at the time of writing. These distinct compilers serve independent workflows. To facilitate the development of RIAs, the Flex SDK features an elaborate framework of user controls and data handlers that aren’t available to the Flash authoring tool, even though the framework is written in ActionScript 3.0. By comparison, Flash offers a modest subset of user controls in its Components panel, including support for the playback and manipulation of Flash video files (FLV). In the end, there’s only one ActionScript 3.0, and it behaves the same when compiled under either tool. The reason for this consistency is that Flash CS4 and the Flex SDK both publish SWF files for the same Flash Player 9 or higher. It’s quite possible—and often done—to create custom classes that can be used under either circumstance. The concept of the document class (see Chapter 6), introduced in Flash CS3, means that an entire application, composed of numerous external classes, can be compiled by Flash or the Flex command line compiler (including Flex Builder) from identical source files. Because ActionScript 3.0 requires AVM2, as mentioned earlier in this chapter, Flash Player 9 is the minimum required runtime to display such content. Flash Player 9 runs on numerous operating systems, including several versions of Windows, Macintosh, Linux, and Solaris. Due to the varied nature of these operating systems and occasional bug fixes required by each, in addition to ongoing new features, Flash Player 9 includes a number of minor point releases, as summarized in Table 1-1. Flash CS4’s default output is aimed at Flash Player 10, which may eventually see a list of minor point releases just as long. Time will tell. To determine what version of Flash Player the user has installed, reference the static property of the class. ActionScript 3.0, including runtime exceptions and error handling, sealed classes, method closures, ECMAScript for XML (E4X), regular expressions, namespaces, new primitive types, DOM3 event model, display list APIs, new sound APIs, and binary data and sockets. Bug fixes and optimizations related to the Intel-based Macintosh platform. Support for Windows Vista operating system. Addition of and event constants to let a monitor and know when it can or cannot access its property. Security enhancements. Bug fixes and improvements for Adobe Flash CS3 Professional. Affects only Windows and Macintosh platforms. H.264 video and High Efficiency AAC (HE-AAC) audio codec support. Hardware acceleration, hardware scaling, multi-threaded video decoding, and enhanced image scaling. Flash Player cache enables common components, such as the Flex Framework, to be cached locally and then used by any SWF from any domain. Flash Media Server buffering maintains stream buffer while a stream is paused. A full listing of all Flash Player release notes, including bug fixes, can be found at http://www.adobe.com/support/documentation/en/flashplayer/releasenotes.html.\n\nLearning ActionScript 3.0 on the Heels of 2.0 Pretend for a moment you’re a carpenter. For years, you were making do with a hand-crank drill, but then the Macromedia Hardware Company introduced an electric model called ActionScript 1.0 stamped with gold letters on the handle. Beautiful thing! No reason to ever use anything else. Sure, you could operate the drill only within six feet of an electrical outlet (because that was the length of the cord), but the advantages were resoundingly clear. Plus, you could always carry around an extension cable. A few years later, Macromedia announced a new and improved ActionScript 2.0 model. This drill had an optional battery back. For some, the new battery pack was a godsend, because it freed them from the previous six foot limitation. They embraced the new feature and literally found themselves running with it. Other carpenters found the battery pack a bit too advanced. They weren’t sure, for example, if they were supposed to drain the batteries completely before recharging. And honestly, that was fine: the drill still had a cord, of course, so they continued within their previous comfort zone, which was still a considerable improvement over the hand-crank days. Carpenters were a happy bunch. Eventually, the Macromedia Hardware Company became Adobe. Everyone looked forward to the new drill—ActionScript 3.0—and when it came ... they found that the cord had been replaced with a docking station. Suddenly, carpenters who had opted not to use the ActionScript 2.0 battery pack felt trapped. They had no experience with batteries, but if they were going to use an ActionScript 3.0 model, they had no choice. It goes without saying that every analogy has its flaws. Certainly, the changes in ActionScript 3.0 amount to more than the obvious benefit of a battery pack. Clearly, the new APIs are more complex than the question of how to recharge a set of batteries. In any case, ActionScript does a lot more than drill holes! Still, it can be useful to think of ActionScript 2.0 as a preparatory transitional period between, on one hand, the very roots of the language—that is, ActionScript 1.0 and even earlier—and, on the other hand, the current version. As with the carpenter story, numerous features in ActionScript 2.0, such as strict typing ( , , etc.) and formalized custom class files, were optional. (Unlike the analogy, those particular features are still optional in ActionScript 3.0.) Voluntary though they were, such then-new conventions were an early invitation to practice a more efficient workflow. Developers who opted to experiment with object-oriented programming (OOP), to the point of writing their own custom classes, may feel more at home with ActionScript 3.0 than others. For those who were perfectly comfortable with the conventions of ActionScript 1.0, they might understandably feel trepidation in light of the current version, especially now that ActionScript 3.0 has dropped support for some previously optional features, such as and . Flipping through the ActionScript 3.0 Language and Components Reference takes considerably longer than before. Everything has been arranged into a potentially overwhelming new hierarchy of packages. Most of the Help panel sample code has been written as class files, to make it applicable both for keyframe and class file programmers. These changes are big, but not insurmountable. One of this book’s driving purposes is to help you feel caught up, whether or not you pursued the optional new conventions of ActionScript 2.0—the features that, in hindsight, were a gentle ramp up to today’s recommended best practices. The important thing to keep in mind is that ActionScript 3.0 is scalable in terms of complexity. If you want to plunge headlong into OOP principles such as inheritance and design patterns, ActionScript 3.0 will oblige. If you prefer to stick with traditional timeline coding, ActionScript 3.0 will oblige—with a number of provisos covered in the following chapters.\n\nDeciding to Migrate or Write Code from Scratch If you work with a set of in-house templates, be they FLA files, custom classes, or a combination of both, sooner or later you’ll have to decide how to update them. For the sake of discussion, these files are stable ones that have made your company money for years, and they work just fine. Nonetheless, you’d like to take advantage of the speed increases—or any of the other benefits—afforded by ActionScript 3.0. Should you painstakingly tinker with existing files, tweaking as you go, or should you ditch everything and start from square one? Which approach would require less effort? For better or worse, there is no sure-fire way to determine which endeavor is more advantageous in a given situation. While you can theoretically upgrade a FLA file’s Publish Settings to ActionScript 3.0 and compile without errors or warnings, the prospect becomes progressively more unlikely as a project gains in complexity. Chances are high that one incompatibility will occur in concert with many: in other words, when it rains, it pours. That said, here are a few thoughts to consider. If all or most of your code exists on frames in a FLA file, you may have no realistic choice but to migrate the ActionScript in place, for the obvious reason that the code is so closely tied to the file’s visual design. To start from scratch could require careful transportation of symbols from one FLA file to another, possibly including intricate nested timeline effects. For simple banner ads and linear slideshows, an in-place update may not be as difficult as it sounds. Standalone calls to , , and the like, will carry over without a hitch. By all means, select File→Publish Settings→Flash→Script→ActionScript 3.0, and then hold your breath and see what happens. Don’t forget to exhale if the compile works, and frankly, prepare yourself now for numerous entries in the Compiler Errors panel. If any of the frame code involves event handlers, loads external assets, or even calls a new web page ( is now ), you’ll have to update it. The good news is, the Compiler Errors panel is one of many helpful new tools in Flash CS4 (introduced in Flash CS3). This panel not only tells you where the erroneous code is, by class file, scene, layer, keyframe, and line number, it often makes suggestions on what to change, including a list of common migration issues. The Compiler Errors panel and other debugging tools are covered in Chapter 11. If most of your code exists in external class files, your project probably involves more than a smattering of ActionScript. Although this likely means you’ll spend more time on code migration (because there’s more of it!), the fact that your code is separate means you can test and revise each class individually. In either case, frame code or class files, this book will help you get your bearings."
    },
    {
        "link": "https://github.com/robinrodricks/awesome-actionscript3",
        "document": "Adobe AIR provides a single set of APIs to build cross-platform desktop/mobile applications and games. ActionScript 3 is the programming language for AIR. Powerful native functionality such as file system, SQLite, sensors are included by default. To add missing functionality, you can build ANEs (Air Native Extensions) coded in the native language (eg VC++ for Windows, Java for Android, Swift/Objective-C for iOS). To build mobile apps/games with GPU-rendered graphics, use the Starling framework and optionally the Feathers UI. Adobe AIR is very popular in the mobile gaming space.\n\nContributions welcome. To add a useful project simply create an Issue.\n\nThis section includes commercial tools as well as free/open source tools.\n• FlashDevelop - Premiere free & open-source IDE for AS3 & AIR, with code completion, debugging, and more.\n• Powerflasher FDT - Commercial IDE built on the Eclipse platform for development of Adobe Flash/AIR content.\n• Adobe Flash Builder - Commercial IDE for building applications on the Flex framework (with advanced debugging tools).\n• Moonshine IDE - Moonshine is a free and open source middleweight IDE built with ActionScript 3 for ActionScript 3, Apache Flex®, Apache FlexJS® and Feathers development with Cloud and Desktop support.\n• IntelliJ IDEA - Commercial IDE that supports many different languages including AS3.\n• Visual Studio Code - An AS3 & MXML language extension for Visual Studio Code. Runs on Windows, macOS, and Linux.\n• De-Monster Debugger - Advanced tool to debug graphics and data from a live AIR application.\n• De-Monster Debugger (Starling) - Fork of De-Monster Debugger with support for Starling Framework.\n• Sothink Decompiler - Advanced decompiler for AS2/AS3 (supports asset extraction and conversion of SWF to FLA/Flex).\n• FreSharp - Build ANEs using C# with this C# wrapper for FlashRuntimeExtensions .\n• Hummingbird - Build and deploy robust MVC applications for AS3, Mobile and the Starling Framework.\n• Apollo - Dependency injection and messaging framework, which can be used as the basis for MVC projects.\n• Kote - Fast and lightweight MVC framework that brings together the best of PureMVC and as3-signals.\n• Starling - High-performance 2D graphics engine built on Stage3D. API identical to Flash API. (github, help).\n• Flow - Layout, effects, data binding and remoting framework to be used instead of Flex.\n• Swiz - Brutally simple micro-architecture for creating RIAs with AS3 and Adobe Flex.\n• Hiddenwood - User interface library developed for a web app project, written in AS3 and in a MVC pattern.\n• Apache Flex® - The Apache Flex® SDK is the evolution of the popular Adobe Flex SDK. The Apache Flex® SDK is an application development framework for easily building Flash-based applications for mobile devices, web browsers, and desktop platforms.\n• Apache Royale® - The Apache Royale® project is developing a next-generation of the Apache Flex® SDK. Royale has the goal of allowing applications developed in MXML and ActionScript to not only run in the Flash/AIR runtimes, but also to run natively in the browser without Flash, on mobile devices as a PhoneGap/Cordova application, and in embedded JS environments such as Chromium Embedded Framework. Royale has the potential to allow your MXML and ActionScript code to run in even more places than Flash currently does.\n• StarlingPunk - Framework built on Starling to add structure and organization to your game projects.\n• FlashPunk - Framework to build 2D games. Provides graphics, events, inputs, animation, etc.\n• Flixel - Useful base classes that you can extend to make your own game objects.\n• Tetragon - Cross-platform framework to build any kind of game. Provides resource management, debugging facilities, multi-locale support, layered extendability, a game-oriented data structure, and more.\n• Pixelizer - Component based game engine to build 2D games. Provides rendering, animation, input, etc.\n• IsoHill - GPU-based Isometric engine built on Starling, with TILED map parser, layers, etc (website).\n• AwayBuilder - Visual workflow tool to import, optimise and bake 3D assets from a variety of sources.\n• AwayPhysics FP11 - Away Physics - 3D physics library for the Away3D FP 11 (examples).\n• GTween - Small but robust library for programmatic tweening, animation, and transitions.\n• DragonBones - High-speed skeletal animation using Starling, and tools to export animations from Flash Pro.\n• FlashEffNano - FlashEff transition library optimized for mobile devices, with 20+ transitions in 750 styles.\n• AS3-signals - New approach for AS3 events inspired by C# events and signals/slots in Qt.\n• Fa-as3 - Write less, do more framework, modeled like jQuery.\n• AS3FP - Collection of functional idioms based on Haskell and Coffeescript.\n• Raix - Reactive And Interactive eXtensions simplifies working with interactive data (arrays) or reactive data (events).\n• Fxp-as3 - Functional library inspired by the \"mostly adequate guide\".\n• AS3spec - Tiny BDD framework for AS3, inspired by Bacon and RSpec.\n• ASunit - The only unit test framework that supports Flash Players 6, 7, 8, 9 and 10.\n• RobotEyes - End-to-end testing for TDD. Hybrid of WindowLicker and Drew Bourne's Mockolate.\n• ZoomableControl - Allows a pinch to zoom using the multitouch inputs.\n• Toaster - Simple feedback about an operation in a small popup. .\n• TinyTLF - Versatile text layout framework built on top of the Flash Text Engine for Flash/Flex.\n• TransformTool - Free Transform Tool (AS, JS) for manipulating objects in 2D space.\n• Gestures.IO - Simplifies the way you create gesture-based Natural Interactions.\n• Gamepad - Simulates an analog joystick input using the keyboard.\n• Advanced_Joystick - Joystick for the Starling Framework, designed for Adobe AIR Mobile.\n• AS3-Controller-Input - Interact with Ouya and Xbox360 game controllers from Adobe AIR.\n• FLARToolKit - AS3 port of the industry standard ARToolkit library, for Flash Player 11. (website).\n• FLAREmulator - Test AR demos to see what works and what doesn't with or without a webcam.\n• EZFLAR - A little wrapper to ease the way AR works.\n• Firetype - Parse OpenType fonts and render them using Stage3D.\n• BMFontRenderer - AS3 renderer for bitmap font data in the BMFont format.\n• Starling-Particles - Particle system for the Starling framework, compatible with the \"Particle Designer\" from 71squared.com.\n• MotionParticleSprite - Design motion paths in Flash Pro and use it to guide Starling particles.\n• qrcode-as - QR Code reader which supports webcam on Windows, Mac and Linux.\n• AS3-Sound-Manager- Upgraded version of the Sound Manager Class from Matt Przybylski.\n• AS3sfxr - Port of sfxr from C++ to AS3, using the new sound and file capabilities of Flash Player 10.\n• Local-recorder - Local audio recorder (no streaming server required). Currently requires Flash Player 10.1 or above.\n• Flowplayer - Flowplayer Flash, the video player for the Web.\n• AS3Query - Another SQLite ORM and query DSL for ActionScript.\n• AIRdb - AIR ORM for using client-side SQLite within AIR and Flex apps. Supports ActiveRecord style models, migrations and associations.\n• AIR-sqlite - Utilities for working with SQLite databases in AIR.\n• Soup - Mixing CouchDB, Sinatra, AIR and RestfulX to create an offline/online ready app with undo/redo capabilities.\n• EasyAGAL - Simplifies development of AGAL shaders with code completion, code hinting, macros, etc.\n• JSONTools - JSON errors, the speed of the JSWoof JSON library, and E4X style queries dubbed E4J.\n• AS3Icy - Decode and play live MP3 streams from Shoutcast, Icecast and Limewire.\n• Abc-abstraction - Allows ABC to be analyzed, manipulated, packaged back into an SWF, and run.\n• SVGParser - SVG parser and renderer to FIVe3D and HTML5 canvas.\n• XMLSerializer - Library which allows data serialisation from ActionScript to XML and from XML to ActionScript.\n• AStream - XML to Object (and vice versa) mapping library written in AS3. Compatible with XStream.\n• GreenSock LoaderMax - Provides an easy and powerful way to load assets at runtime.\n• OpenTSPS - TSPS is a cross platform Toolkit for Sensing People in Spaces. It performs openCV operations on live video (Kinect, web camera, etc) and sends it to clients as JSON (via WebSockets), OSC, TUIO, or TCP.\n• LeapMotionAS3 - Integrate with the LeapMotion sensor (provides Gestures, Image, Skeleton/Bone @ 210 FPS).\n• Android-Flash-P2P - P2P Communication between a Client.swf and an Android Device with AIR.\n• NetGrouper - Wrapper for NetGroup and RTMFP Multicasting abilities to create quick P2P multiplayer games over local networks or Adobe Cirrus.\n• P2Pmessaging - Simple messaging framework for doing P2P in Flash.\n• ArcusNode - RTMFP Rendevouz Service For Peer Assisted Networking With Adobe Flash on Node JS.\n• SmartSocket - SmartSocket is a Java and PHP socket server engine, to make creating multi-user applications quick and painless.\n• ws-flash-client - Reliable minimalistic WebSocket client (uses Adobe Flash where native WebSocket is not available).\n• AMQP - Client-side implementation of the 0-8 version of AMQP.\n• BlooddyCrypto - High-performance library for processing binary data. This library contains MD5, SHA-1, SHA-2, Base64, CRC32, JSON, PNG/JPEG encoders.\n• AS3Units - Port of NGUnits. Parsing, formatting, and converting between units of measure.\n• Zexpression - Parse and evalate math expressions with functions and variables.\n• AS3eval - Packages the Tamarin ESC compiler to work within Flash Player. (alternate).\n• 8080 Emulator - An actionscript 3 space invaders emulator based on the intel 8080 processor.\n• 8-bit VM - An eight bit virtual machine written in actionscript.\n• Lisp - Lisp dialect written in Actionscript, with compiler and bytecode interpreter.\n• SilentSwitch - ANE for iOS to mute sounds if the hardware silent switch is on.\n• VolumePro - Control native music stream volume and you can listen to the volume changes.\n• SystemVolume - Interact with the system volume for iOS and Android devices.\n• WebView (Tuarua) - Modern WebView for OSX 10.10+, Windows Desktop, iOS 9.0+ and Android 21+. Uses CEF (Chromium Embedded Framework) on Windows, WKWebView on iOS/OSX, and WebView on Android.\n• WebView (FlashLab) - Replacement for StageWebView, allows calling Javascript functions from AIR.\n• PDF - Lets you open PDF files from your AIR mobile apps. Supported on Android and iOS.\n• Speech - Convert strings to voice files and vice versa fully in the background.\n• Barcode - Scan almost any barcode type with this super fast barcode scanner ANE.\n• FileChooser - Enable users to select a file from the device filesystem.\n• ZipManager - Zip or unzip large zip archives super fast using native process on Android and iOS.\n• Spotlight - Integrate with iOS 9 Spotlight Search, to index search items and user generated content.\n• Firebase - API for Google Firebase on Android and iOS with 100% identical ActionScript API.\n• Bluetooth - Scan for other devices, connect to and pair with them and transfer data between them.\n• GPS - Get current device GPS location as fast as possible by automatically checking the best available provider.\n• AlarmManager - Run a scheduled task even if your AIR app is closed.\n• InAppPayments - Identical in-app-billing and in-app-purchase ANE for Android and iOS.\n• PermissionCheck - Check and request for permissions in your Adobe Air app.\n• RateMe - Ask your users to rate your app in the most efficient way.\n• Statusbar - Control the Statusbar in your AIR apps in runtime.\n• Can-Open-URL - ANE for iOS to detect whether an app is installed to handle a specific URL scheme.\n• GCM - Use Google Cloud messaging on Android and iOS. .\n• Baidu - Baidu ANE for for iOS and Android.\n• Chartboost - ANE for the Chartboost SDK with compile scripts."
    },
    {
        "link": "https://helpx.adobe.com/animate/using/best-practices-organizing-actionscript-application.html",
        "document": ""
    },
    {
        "link": "https://home.csulb.edu/~arezaei/ETEC570/Action%20script%203.pdf",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/3595218/actionscript-3-a-loader-that-supports-many-apps",
        "document": "In order to load an external SWF your loader only need the url of the swf to be loaded, this url doesn't have to be hardcoded. There are many ways to pass parameters to a SWF file and they don't necessarily require Javascript.\n\nYou could load a XML file for instance, a simple text file would work too , you could also use a PHP script. Using flahsvars would require Javascript, although only to set your application in your HTML page.\n\nWith the following example , your app doesn't need to recompile , you simply change the url in the text file."
    },
    {
        "link": "https://github.com/labcerouno/awesome-actionscript",
        "document": "We read every piece of feedback, and take your input very seriously."
    },
    {
        "link": "https://airsdk.dev/reference/actionscript/3.0/flash/filters/DropShadowFilter.html",
        "document": "The DropShadowFilter class lets you add a drop shadow to display objects. The shadow algorithm is based on the same box filter that the blur filter uses. You have several options for the style of the drop shadow, including inner or outer shadow and knockout mode. You can apply the filter to any display object (that is, objects that inherit from the DisplayObject class), such as MovieClip, SimpleButton, TextField, and Video objects, as well as to BitmapData objects. The DropShadowFilter class lets you add a drop shadow to display objects. The shadow algorithm is based on the same box filter that the blur filter uses. You have several options for the style of the drop shadow, including inner or outer shadow and knockout mode. You can apply the filter to any display object (that is, objects that inherit from the DisplayObject class), such as MovieClip, SimpleButton, TextField, and Video objects, as well as to BitmapData objects. The use of filters depends on the object to which you apply the filter:\n• To apply filters to display objects use the property (inherited from DisplayObject). Setting the property of an object does not modify the object, and you can remove the filter by clearing the property.\n• To apply filters to BitmapData objects, use the method. Calling on a BitmapData object takes the source BitmapData object and the filter object and generates a filtered image as a result. If you apply a filter to a display object, the value of the property of the display object is set to . If you clear all filters, the original value of is restored. This filter supports Stage scaling. However, it does not support general scaling, rotation, and skewing. If the object itself is scaled (if and are set to a value other than 1.0), the filter is not scaled. It is scaled only when the user zooms in on the Stage. A filter is not applied if the resulting image exceeds the maximum dimensions. In AIR 1.5 and Flash Player 10, the maximum is 8,191 pixels in width or height, and the total number of pixels cannot exceed 16,777,215 pixels. (So, if an image is 8,191 pixels wide, it can only be 2,048 pixels high.) In Flash Player 9 and earlier and AIR 1.1 and earlier, the limitation is 2,880 pixels in height and 2,880 pixels in width. If, for example, you zoom in on a large movie clip with a filter applied, the filter is turned off if the resulting image exceeds the maximum dimensions. \n\n\n\n[read-write] The alpha transparency value for the shadow color. Valid values are 0.0 to 1.0. For example, .25 sets a transparency value of 25%. The default value is 1.0. \n\n \n\n \n\n [read-write] The angle of the shadow. Valid values are 0 to 360 degrees (floating point). The default value is 45. \n\n \n\n \n\n [read-write] The amount of horizontal blur. Valid values are 0 to 255.0 (floating point). The default value is 4.0. \n\n \n\n \n\n [read-write] The amount of vertical blur. Valid values are 0 to 255.0 (floating point). The default value is 4.0. \n\n \n\n \n\n [read-write] The color of the shadow. Valid values are in hexadecimal format 0xRRGGBB. The default value is 0x000000. \n\n \n\n \n\n [read-write] The offset distance for the shadow, in pixels. The default value is 4.0 (floating point). \n\n \n\n \n\n [read-write] Indicates whether or not the object is hidden. The value indicates that the object itself is not drawn; only the shadow is visible. The default is (the object is shown). \n\n \n\n \n\n [read-write] Indicates whether or not the shadow is an inner shadow. The value indicates an inner shadow. The default is , an outer shadow (a shadow around the outer edges of the object). \n\n \n\n \n\n [read-write] Applies a knockout effect ( ), which effectively makes the object's fill transparent and reveals the background color of the document. The default is (no knockout). \n\n \n\n \n\n [read-write] The number of times to apply the filter. The default value is , which is equivalent to applying the filter once. The value applies the filter twice; the value applies it three times. Filters with lower values are rendered more quickly. For most applications, a quality value of low, medium, or high is sufficient. Although you can use additional numeric values up to 15 to achieve different effects, higher values are rendered more slowly. Instead of increasing the value of , you can often get a similar effect, and with faster rendering, by simply increasing the values of the and properties. \n\n \n\n \n\n [read-write] The strength of the imprint or spread. The higher the value, the more color is imprinted and the stronger the contrast between the shadow and the background. Valid values are from 0 to 255.0. The default is 1.0. \n\n \n\n \n\n Creates a new DropShadowFilter instance with the specified parameters. (default = ) — Offset distance for the shadow, in pixels. (default = ) — Angle of the shadow, 0 to 360 degrees (floating point). (default = ) — Color of the shadow, in hexadecimal format 0xRRGGBB. The default value is 0x000000. (default = ) — Alpha transparency value for the shadow color. Valid values are 0.0 to 1.0. For example, .25 sets a transparency value of 25%. (default = ) — Amount of horizontal blur. Valid values are 0 to 255.0 (floating point). (default = ) — Amount of vertical blur. Valid values are 0 to 255.0 (floating point). (default = ) — The strength of the imprint or spread. The higher the value, the more color is imprinted and the stronger the contrast between the shadow and the background. Valid values are 0 to 255.0. (default = ) — The number of times to apply the filter. Use the BitmapFilterQuality constants: For more information about these values, see the property description. (default = ) — Indicates whether or not the shadow is an inner shadow. A value of specifies an inner shadow. A value of specifies an outer shadow (a shadow around the outer edges of the object). (default = ) — Applies a knockout effect ( ), which effectively makes the object's fill transparent and reveals the background color of the document. (default = ) — Indicates whether or not the object is hidden. A value of indicates that the object itself is not drawn; only the shadow is visible. — A new DropShadowFilter instance with all the properties of the original DropShadowFilter instance.\n• Declare three properties that are used to draw the square to which the filter is applied.\n• Create the constructor function. The constructor calls the method, which uses methods of the Graphics class accessed through the property of Sprite to draw an orange square.\n• In the constructor, declare a variable as a BitmapFilter object and assign it to the return value of a call to . The method defines the drop shadow filter used.\n• Create a new Array object and add to the array. Assign the array to the property of the DropShadowFilterExample object. This applies all filters found in , which in this case is only . package { import flash.display.Sprite; import flash.events.Event; import flash.events.MouseEvent; import flash.filters.BitmapFilter; import flash.filters.BitmapFilterQuality; import flash.filters.DropShadowFilter; public class DropShadowFilterExample extends Sprite { private var bgColor:uint = 0xFFCC00; private var size:uint = 80; private var offset:uint = 50; public function DropShadowFilterExample() { draw(); var filter:BitmapFilter = getBitmapFilter(); var myFilters:Array = new Array(); myFilters.push(filter); filters = myFilters; } private function getBitmapFilter():BitmapFilter { var color:Number = 0x000000; var angle:Number = 45; var alpha:Number = 0.8; var blurX:Number = 8; var blurY:Number = 8; var distance:Number = 15; var strength:Number = 0.65; var inner:Boolean = false; var knockout:Boolean = false; var quality:Number = BitmapFilterQuality.HIGH; return new DropShadowFilter(distance, angle, color, alpha, blurX, blurY, strength, quality, inner, knockout); } private function draw():void { graphics.beginFill(bgColor); graphics.drawRect(offset, offset, size, size); graphics.endFill(); } } } The following example creates a yellow square and applies a drop shadow to it. The general workflow of this example is as follows:"
    },
    {
        "link": "https://airsdk.dev/reference/actionscript/3.0/index.html?flash/filters/DropShadowFilter.html&flash/filters/class-list.html",
        "document": "This document is designed to be viewed using the frames feature. If you see this message, you are using a non-frame-capable web client. \n\n Link to Non-frame version."
    },
    {
        "link": "https://helpx.adobe.com/ph_fil/animate/using/graphic-filters.html",
        "document": ""
    },
    {
        "link": "https://home.csulb.edu/~arezaei/ETEC570/Action%20script%203.pdf",
        "document": ""
    },
    {
        "link": "https://helpx.adobe.com/in/animate/using/graphic-filters.html",
        "document": ""
    }
]