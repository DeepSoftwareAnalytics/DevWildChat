[
    {
        "link": "https://doc.rust-lang.org/std/str/struct.Split.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/24542115/how-to-index-a-string-in-rust",
        "document": "Yes, indexing into a string is not available in Rust. The reason for this is that Rust strings are encoded in UTF-8 internally, so the concept of indexing itself would be ambiguous, and people would misuse it: byte indexing is fast, but almost always incorrect (when your text contains non-ASCII symbols, byte indexing may leave you inside a character, which is really bad if you need text processing), while char indexing is not free because UTF-8 is a variable-length encoding, so you have to traverse the entire string to find the required code point.\n\nIf you are certain that your strings contain ASCII characters only, you can use the method on which returns a byte slice, and then index into this slice:\n\nIf you do need to index code points, you have to use the iterator:\n\nAs I said above, this would require traversing the entire iterator up to the th code element.\n\nFinally, in many cases of text processing, it is actually necessary to work with grapheme clusters rather than with code points or bytes. With the help of the unicode-segmentation crate, you can index into grapheme clusters as well:\n\nNaturally, grapheme cluster indexing has the same requirement of traversing the entire string as indexing into code points."
    },
    {
        "link": "https://doc.rust-lang.org/std/string/struct.String.html",
        "document": "is the most common string type. It has ownership over the contents of the string, stored in a heap-allocated buffer (see Representation). It is closely related to its borrowed counterpart, the primitive . You can create a from a literal string with : You can append a to a with the method, and append a with the method: If you have a vector of UTF-8 bytes, you can create a from it with the method: s are always valid UTF-8. If you need a non-UTF-8 string, consider . It is similar, but without the UTF-8 constraint. Because UTF-8 is a variable width encoding, s are typically smaller than an array of the same s: This raises interesting questions as to how should work. What should be here? Several options include byte indices and indices but, because of UTF-8 encoding, only byte indices would provide constant time indexing. Getting the th , for example, is available using : Next, what should return? Because indexing returns a reference to underlying data it could be , , or something else similar. Since we‚Äôre only providing one index, makes the most sense but that might not be what the user expects and can be explicitly achieved with : Due to these ambiguities/restrictions, indexing with a is simply forbidden: ‚ìò s = ; ( \"The first letter of s is {}\" , s[ ]); It is more clear, however, how should work (that is, indexing with a range). It should accept byte indices (to be constant-time) and return a which is UTF-8 encoded. This is also called ‚Äústring slicing‚Äù. Note this will panic if the byte indices provided are not character boundaries - see for more details. See the implementations for for more details on string slicing. For a non-panicking version of string slicing, see . The and methods return iterators over the bytes and codepoints of the string, respectively. To iterate over codepoints along with byte indices, use . implements , and so inherits all of ‚Äôs methods. In addition, this means that you can pass a to a function which takes a by using an ampersand ( ): This will create a from the and pass it in. This conversion is very inexpensive, and so generally, functions will accept s as arguments unless they need a for some specific reason. In certain cases Rust doesn‚Äôt have enough information to make this conversion, known as coercion. In the following example a string slice implements the trait , and the function takes anything that implements the trait. In this case Rust would need to make two implicit conversions, which Rust doesn‚Äôt have the means to do. For that reason, the following example will not compile. There are two options that would work instead. The first would be to change the line to , using the method to explicitly extract the string slice containing the string. The second way changes to . In this case we are dereferencing a to a , then referencing the back to . The second way is more idiomatic, however both work to do the conversion explicitly rather than relying on the implicit conversion. A is made up of three components: a pointer to some bytes, a length, and a capacity. The pointer points to the internal buffer which uses to store its data. The length is the number of bytes currently stored in the buffer, and the capacity is the size of the buffer in bytes. As such, the length will always be less than or equal to the capacity. This buffer is always stored on the heap. You can look at these with the , , and methods: If a has enough capacity, adding elements to it will not re-allocate. For example, consider this program: This will output the following: At first, we have no memory allocated at all, but as we append to the string, it increases its capacity appropriately. If we instead use the method to allocate the correct capacity initially: We end up with a different output: Here, there‚Äôs no need to allocate more memory inside the loop.\n\nThis length is in bytes, not s or graphemes. In other words, it might not be what a human considers the length of the string. Returns if has a length of zero bytes. Checks that -th byte is the first byte in a UTF-8 code point sequence or the end of the string. The start and end of the string (when ) are considered to be boundaries. Returns if is greater than . Finds the closest not exceeding where is . This method can help you truncate a string so that it‚Äôs still valid UTF-8, but doesn‚Äôt exceed a given number of bytes. Note that this is done purely at the character level and can still visually split graphemes, even though the underlying characters aren‚Äôt split. For example, the emoji üßë‚Äçüî¨ (scientist) could be split so that the string only includes üßë (person) instead. Finds the closest not below where is . If is greater than the length of the string, this returns the length of the string. This method is the natural complement to . See that method for more details. Converts a string slice to a byte slice. To convert the byte slice back into a string slice, use the function. The caller must ensure that the content of the slice is valid UTF-8 before the borrow ends and the underlying is used. Use of a whose contents are not valid UTF-8 is undefined behavior. As string slices are a slice of bytes, the raw pointer points to a . This pointer will be pointing to the first byte of the string slice. The caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use . As string slices are a slice of bytes, the raw pointer points to a . This pointer will be pointing to the first byte of the string slice. It is your responsibility to make sure that the string slice only gets modified in a way that it remains valid UTF-8. This is the non-panicking alternative to indexing the . Returns whenever equivalent indexing operation would panic. This is the non-panicking alternative to indexing the . Returns whenever equivalent indexing operation would panic. This is the unchecked alternative to indexing the . Callers of this function are responsible that these preconditions are satisfied:\n‚Ä¢ The starting index must not exceed the ending index;\n‚Ä¢ Indexes must be within bounds of the original slice; Failing that, the returned string slice may reference invalid memory or violate the invariants communicated by the type. This is the unchecked alternative to indexing the . Callers of this function are responsible that these preconditions are satisfied:\n‚Ä¢ The starting index must not exceed the ending index;\n‚Ä¢ Indexes must be within bounds of the original slice; Failing that, the returned string slice may reference invalid memory or violate the invariants communicated by the type. Deprecated since 1.29.0: use instead This is generally not recommended, use with caution! For a safe alternative see and . This new slice goes from to , including but excluding . To get a mutable string slice instead, see the method. Callers of this function are responsible that three preconditions are satisfied:\n‚Ä¢ and must be byte positions within the string slice.\n‚Ä¢ and must lie on UTF-8 sequence boundaries. Deprecated since 1.29.0: use instead This is generally not recommended, use with caution! For a safe alternative see and . This new slice goes from to , including but excluding . To get an immutable string slice instead, see the method. Callers of this function are responsible that three preconditions are satisfied:\n‚Ä¢ and must be byte positions within the string slice.\n‚Ä¢ and must lie on UTF-8 sequence boundaries. Divides one string slice into two at an index. The argument, , should be a byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point. The two slices returned go from the start of the string slice to , and from to the end of the string slice. To get mutable string slices instead, see the method. Panics if is not on a UTF-8 code point boundary, or if it is past the end of the last code point of the string slice. For a non-panicking alternative see . s = ; (first, last) = s.split_at( ); ( , first); ( , last); Divides one mutable string slice into two at an index. The argument, , should be a byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point. The two slices returned go from the start of the string slice to , and from to the end of the string slice. To get immutable string slices instead, see the method. Panics if is not on a UTF-8 code point boundary, or if it is past the end of the last code point of the string slice. For a non-panicking alternative see . s = .to_string(); { (first, last) = s.split_at_mut( ); first.make_ascii_uppercase(); ( , first); ( , last); } ( , s); Divides one string slice into two at an index. The argument, , should be a valid byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point. The method returns if that‚Äôs not the case. The two slices returned go from the start of the string slice to , and from to the end of the string slice. To get mutable string slices instead, see the method. s = ; (first, last) = s.split_at_checked( ).unwrap(); ( , first); ( , last); ( , s.split_at_checked( )); ( , s.split_at_checked( )); Divides one mutable string slice into two at an index. The argument, , should be a valid byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point. The method returns if that‚Äôs not the case. The two slices returned go from the start of the string slice to , and from to the end of the string slice. To get immutable string slices instead, see the method. s = .to_string(); ((first, last)) = s.split_at_mut_checked( ) { first.make_ascii_uppercase(); ( , first); ( , last); } ( , s); ( , s.split_at_mut_checked( )); ( , s.split_at_mut_checked( )); Returns an iterator over the s of a string slice. As a string slice consists of valid UTF-8, we can iterate through a string slice by . This method returns such an iterator. It‚Äôs important to remember that represents a Unicode Scalar Value, and might not match your idea of what a ‚Äòcharacter‚Äô is. Iteration over grapheme clusters may be what you actually want. This functionality is not provided by Rust‚Äôs standard library, check crates.io instead. Remember, s might not match your intuition about characters: Returns an iterator over the s of a string slice, and their positions. As a string slice consists of valid UTF-8, we can iterate through a string slice by . This method returns an iterator of both these s, as well as their byte positions. The iterator yields tuples. The position is first, the is second. Remember, s might not match your intuition about characters: Returns an iterator over the bytes of a string slice. As a string slice consists of a sequence of bytes, we can iterate through a string slice by byte. This method returns such an iterator. The iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of whitespace. ‚ÄòWhitespace‚Äô is defined according to the terms of the Unicode Derived Core Property . If you only want to split on ASCII whitespace instead, use . All kinds of whitespace are considered: If the string is empty or all whitespace, the iterator yields no string slices: The iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of ASCII whitespace. To split by Unicode instead, use . All kinds of ASCII whitespace are considered: If the string is empty or all ASCII whitespace, the iterator yields no string slices: Returns an iterator over the lines of a string, as string slices. Lines are split at line endings that are either newlines ( ) or sequences of a carriage return followed by a line feed ( ). Line terminators are not included in the lines returned by the iterator. Note that any carriage return ( ) not immediately followed by a line feed ( ) does not split a line. These carriage returns are thereby included in the produced lines. The final line ending is optional. A string that ends with a final line ending will return the same lines as an otherwise identical string without a final line ending. The final line does not require any ending: Deprecated since 1.4.0: use lines() instead now Returns an iterator over the lines of a string. Returns an iterator of over the string encoded as UTF-16. Returns if the given pattern matches a sub-slice of this string slice. Returns if it does not. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. Returns if the given pattern matches a prefix of this string slice. Returns if it does not. The pattern can be a , in which case this function will return true if the is a prefix of this string slice. The pattern can also be a , a slice of s, or a function or closure that determines if a character matches. These will only be checked against the first character of this string slice. Look at the second example below regarding behavior for slices of s. Returns if the given pattern matches a suffix of this string slice. Returns if it does not. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. Returns the byte index of the first character of this string slice that matches the pattern. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. More complex patterns using point-free style and closures: Returns the byte index for the first character of the last match of the pattern in this string slice. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. Returns an iterator over substrings of this string slice, separated by characters matched by a pattern. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. The returned iterator will be a if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., , but not for . If the pattern allows a reverse search but its results might differ from a forward search, the method can be used. If the pattern is a slice of chars, split on each occurrence of any of the characters: If a string contains multiple contiguous separators, you will end up with empty strings in the output: Contiguous separators are separated by the empty string. Separators at the start or end of a string are neighbored by empty strings. When the empty string is used as a separator, it separates every character in the string, along with the beginning and end of the string. Contiguous separators can lead to possibly surprising behavior when whitespace is used as the separator. This code is correct: Use for this behavior. Returns an iterator over substrings of this string slice, separated by characters matched by a pattern. Differs from the iterator produced by in that leaves the matched part as the terminator of the substring. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. If the last element of the string is matched, that element will be considered the terminator of the preceding substring. That substring will be the last item returned by the iterator. Returns an iterator over substrings of the given string slice, separated by characters matched by a pattern and yielded in reverse order. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. The returned iterator requires that the pattern supports a reverse search, and it will be a if a forward/reverse search yields the same elements. For iterating from the front, the method can be used. Returns an iterator over substrings of the given string slice, separated by characters matched by a pattern. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. Equivalent to , except that the trailing substring is skipped if empty. This method can be used for string data that is terminated, rather than separated by a pattern. The returned iterator will be a if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., , but not for . If the pattern allows a reverse search but its results might differ from a forward search, the method can be used. Returns an iterator over substrings of , separated by characters matched by a pattern and yielded in reverse order. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. Equivalent to , except that the trailing substring is skipped if empty. This method can be used for string data that is terminated, rather than separated by a pattern. The returned iterator requires that the pattern supports a reverse search, and it will be double ended if a forward/reverse search yields the same elements. For iterating from the front, the method can be used. Returns an iterator over substrings of the given string slice, separated by a pattern, restricted to returning at most items. If substrings are returned, the last substring (the th substring) will contain the remainder of the string. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. The returned iterator will not be double ended, because it is not efficient to support. If the pattern allows a reverse search, the method can be used. v: Vec< str> = .splitn( , |c| c == || c == ).collect(); (v, [ , ]); Returns an iterator over substrings of this string slice, separated by a pattern, starting from the end of the string, restricted to returning at most items. If substrings are returned, the last substring (the th substring) will contain the remainder of the string. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. The returned iterator will not be double ended, because it is not efficient to support. For splitting from the front, the method can be used. v: Vec< str> = .rsplitn( , |c| c == || c == ).collect(); (v, [ , ]); Splits the string on the first occurrence of the specified delimiter and returns prefix before delimiter and suffix after delimiter. Splits the string on the last occurrence of the specified delimiter and returns prefix before delimiter and suffix after delimiter. Returns an iterator over the disjoint matches of a pattern within the given string slice. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. The returned iterator will be a if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., , but not for . If the pattern allows a reverse search but its results might differ from a forward search, the method can be used. Returns an iterator over the disjoint matches of a pattern within this string slice, yielded in reverse order. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. The returned iterator requires that the pattern supports a reverse search, and it will be a if a forward/reverse search yields the same elements. For iterating from the front, the method can be used. Returns an iterator over the disjoint matches of a pattern within this string slice as well as the index that the match starts at. For matches of within that overlap, only the indices corresponding to the first match are returned. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. The returned iterator will be a if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., , but not for . If the pattern allows a reverse search but its results might differ from a forward search, the method can be used. Returns an iterator over the disjoint matches of a pattern within , yielded in reverse order along with the index of the match. For matches of within that overlap, only the indices corresponding to the last match are returned. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. The returned iterator requires that the pattern supports a reverse search, and it will be a if a forward/reverse search yields the same elements. For iterating from the front, the method can be used. ‚ÄòWhitespace‚Äô is defined according to the terms of the Unicode Derived Core Property , which includes newlines. ‚ÄòWhitespace‚Äô is defined according to the terms of the Unicode Derived Core Property , which includes newlines. A string is a sequence of bytes. in this context means the first position of that byte string; for a left-to-right language like English or Russian, this will be left side, and for right-to-left languages like Arabic or Hebrew, this will be the right side. ‚ÄòWhitespace‚Äô is defined according to the terms of the Unicode Derived Core Property , which includes newlines. A string is a sequence of bytes. in this context means the last position of that byte string; for a left-to-right language like English or Russian, this will be right side, and for right-to-left languages like Arabic or Hebrew, this will be the left side. ‚ÄòWhitespace‚Äô is defined according to the terms of the Unicode Derived Core Property . A string is a sequence of bytes. ‚ÄòLeft‚Äô in this context means the first position of that byte string; for a language like Arabic or Hebrew which are ‚Äòright to left‚Äô rather than ‚Äòleft to right‚Äô, this will be the right side, not the left. ‚ÄòWhitespace‚Äô is defined according to the terms of the Unicode Derived Core Property . A string is a sequence of bytes. ‚ÄòRight‚Äô in this context means the last position of that byte string; for a language like Arabic or Hebrew which are ‚Äòright to left‚Äô rather than ‚Äòleft to right‚Äô, this will be the left side, not the right. Returns a string slice with all prefixes and suffixes that match a pattern repeatedly removed. The pattern can be a , a slice of s, or a function or closure that determines if a character matches. Returns a string slice with all prefixes that match a pattern repeatedly removed. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. A string is a sequence of bytes. in this context means the first position of that byte string; for a left-to-right language like English or Russian, this will be left side, and for right-to-left languages like Arabic or Hebrew, this will be the right side. If the string starts with the pattern , returns the substring after the prefix, wrapped in . Unlike , this method removes the prefix exactly once. If the string does not start with , returns . The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. If the string ends with the pattern , returns the substring before the suffix, wrapped in . Unlike , this method removes the suffix exactly once. If the string does not end with , returns . The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. Returns a string slice with all suffixes that match a pattern repeatedly removed. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. A string is a sequence of bytes. in this context means the last position of that byte string; for a left-to-right language like English or Russian, this will be right side, and for right-to-left languages like Arabic or Hebrew, this will be the left side. Returns a string slice with all prefixes that match a pattern repeatedly removed. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. A string is a sequence of bytes. ‚ÄòLeft‚Äô in this context means the first position of that byte string; for a language like Arabic or Hebrew which are ‚Äòright to left‚Äô rather than ‚Äòleft to right‚Äô, this will be the right side, not the left. Returns a string slice with all suffixes that match a pattern repeatedly removed. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. A string is a sequence of bytes. ‚ÄòRight‚Äô in this context means the last position of that byte string; for a language like Arabic or Hebrew which are ‚Äòright to left‚Äô rather than ‚Äòleft to right‚Äô, this will be the left side, not the right. Parses this string slice into another type. Because is so general, it can cause problems with type inference. As such, is one of the few times you‚Äôll see the syntax affectionately known as the ‚Äòturbofish‚Äô: . This helps the inference algorithm understand specifically which type you‚Äôre trying to parse into. can parse into any type that implements the trait. Will return if it‚Äôs not possible to parse this string slice into the desired type. Using the ‚Äòturbofish‚Äô instead of annotating : Checks if all characters in this string are within the ASCII range. If this string slice , returns it as a slice of ASCII characters, otherwise returns . Checks that two strings are an ASCII case-insensitive match. Same as , but without allocating and copying temporaries. Converts this string to its ASCII upper case equivalent in-place. ASCII letters ‚Äòa‚Äô to ‚Äòz‚Äô are mapped to ‚ÄòA‚Äô to ‚ÄòZ‚Äô, but non-ASCII letters are unchanged. To return a new uppercased value without modifying the existing one, use . Converts this string to its ASCII lower case equivalent in-place. ASCII letters ‚ÄòA‚Äô to ‚ÄòZ‚Äô are mapped to ‚Äòa‚Äô to ‚Äòz‚Äô, but non-ASCII letters are unchanged. To return a new lowercased value without modifying the existing one, use . ‚ÄòWhitespace‚Äô refers to the definition used by . ‚ÄòWhitespace‚Äô refers to the definition used by . ‚ÄòWhitespace‚Äô refers to the definition used by . Returns an iterator that escapes each char in with . Note: only extended grapheme codepoints that begin the string will be escaped. Returns an iterator that escapes each char in with . Returns an iterator that escapes each char in with . Returns the range that a substring points to. Returns if does not point within . Unlike , this does not search through the string. Instead, it uses pointer arithmetic to find where in the string is derived from. This is useful for extending and similar methods. Note that this method may return false positives (typically either or ) if is a zero-length that points at the beginning or end of another, independent, . Returns the same string as a string slice . This method is redundant when used directly on , but it helps dereferencing other string-like types to string slices, for example references to or . Replaces all matches of a pattern with another string. creates a new , and copies the data from this string slice into it. While doing so, it attempts to find matches of a pattern. If it finds any, it replaces them with the replacement string slice. When the pattern doesn‚Äôt match, it returns this string slice as : Replaces first N matches of a pattern with another string. creates a new , and copies the data from this string slice into it. While doing so, it attempts to find matches of a pattern. If it finds any, it replaces them with the replacement string slice at most times. When the pattern doesn‚Äôt match, it returns this string slice as : Returns the lowercase equivalent of this string slice, as a new . ‚ÄòLowercase‚Äô is defined according to the terms of the Unicode Derived Core Property . Since some characters can expand into multiple characters when changing the case, this function returns a instead of modifying the parameter in-place. Languages without case are not changed: Returns the uppercase equivalent of this string slice, as a new . ‚ÄòUppercase‚Äô is defined according to the terms of the Unicode Derived Core Property . Since some characters can expand into multiple characters when changing the case, this function returns a instead of modifying the parameter in-place. Scripts without case are not changed: One character can become multiple: This function will panic if the capacity would overflow. Returns a copy of this string where each character is mapped to its ASCII upper case equivalent. ASCII letters ‚Äòa‚Äô to ‚Äòz‚Äô are mapped to ‚ÄòA‚Äô to ‚ÄòZ‚Äô, but non-ASCII letters are unchanged. To uppercase the value in-place, use . To uppercase ASCII characters in addition to non-ASCII characters, use . Returns a copy of this string where each character is mapped to its ASCII lower case equivalent. ASCII letters ‚ÄòA‚Äô to ‚ÄòZ‚Äô are mapped to ‚Äòa‚Äô to ‚Äòz‚Äô, but non-ASCII letters are unchanged. To lowercase the value in-place, use . To lowercase ASCII characters in addition to non-ASCII characters, use ."
    },
    {
        "link": "https://stackoverflow.com/questions/72680342/unexpected-string-split-behaviour",
        "document": "I am reading rustbook and came across the following piece of code:\n\nI ran it, but the program didn't panic, although there is no such symbol in the string and the iterator should have returned None when calling next().\n\nAfter that I went to the documentation and for some reason I didn't find an example with splitting by a pattern which doesn't exist in the string.\n\nPlease explain why None is not returned in this case."
    },
    {
        "link": "https://dev.to/alexmercedcoder/in-depth-guide-to-working-with-strings-in-rust-1522",
        "document": "When working with strings in Rust, it's essential to understand the two primary string types: and . Rust's memory management model introduces some unique aspects to string handling, making it different from other languages.\n\n, also called a string slice, is an immutable reference to a sequence of UTF-8 characters. It's commonly used for string literals or when you want to reference part of an existing string without owning or modifying the data.\n\nWhen to Use:\n‚Ä¢ When you don't need to modify the string data.\n‚Ä¢ When you want to pass a reference to a string without taking ownership.\n‚Ä¢ For string literals, as they are inherently .\n\nA String is an owned, mutable sequence of UTF-8 characters stored on the heap. This type is used when you need to allocate and modify string data dynamically. String allows you to append, mutate, and manage its contents, unlike &str, which is immutable.\n\nWhen to Use:\n‚Ä¢ When you need to own the string data.\n‚Ä¢ When you need to modify the string (e.g., append, remove characters).\n‚Ä¢ When you're working with user input or dynamically generated text.\n‚Ä¢ Memory: String is stored on the heap and owns its data, while &str is a reference to a string slice, typically pointing to data stored elsewhere (stack or heap).\n‚Ä¢ Mutability: String is mutable, allowing modifications, whereas &str is immutable.\n‚Ä¢ None OsString and OsStr: These types are used when dealing with operating system-specific string representations, especially for file paths and command-line arguments.\n‚Ä¢ None CString and CStr: These types are used for interoperability with C strings, which are null-terminated.\n\nUnderstanding which string type to use is crucial for efficient and safe string handling in Rust, as it can impact both performance and memory usage.\n\nWhen working with strings in Rust, it's common to switch between and depending on whether you need ownership or just a reference. Rust provides several methods to easily convert between these types.\n\nConverting a string slice ( ) into an owned is straightforward. You can either use the method or the function.\n\nBoth and achieve the same result, but .to_string() is more common when working with existing string slices.\n\nIf you have an owned String but only need a reference to it, you can convert it to a string slice ( ) using the method or by dereferencing it ( ).\n\nIn most cases, is the preferred approach for converting String to , as it's simpler and more readable.\n\nRust strings can also be converted from or to other types, such as byte arrays, integers, or floating-point values. For instance, converting from bytes or other primitive types is common when dealing with binary data or user input.\n\nKnowing how to convert between string types is essential for working with Rust's strict type system and managing ownership effectively. Depending on whether you need an immutable reference or an owned, mutable string, Rust offers flexible ways to move between String and &str.\n\nNow that you're familiar with the different string types and conversions in Rust, let's dive into some basic string operations, such as concatenation, interpolation, reversing strings, and slicing.\n\nIn Rust, there are multiple ways to concatenate strings. The most common methods are using the operator and the macro.\n\nYou can concatenate a with a using the operator. Keep in mind that this operation consumes the first string ( ) and borrows the second ( ).\n\nThe format!() macro provides a more flexible and readable way to concatenate strings, without moving ownership of the original strings.\n\nString interpolation in Rust is achieved using the macro. This macro allows you to embed variables or expressions directly into strings.\n\nWith , you can combine multiple variables and expressions into a single string easily.\n\nReversing a string in Rust is slightly more complex due to UTF-8 encoding. A simple reversal using can ensure that multi-byte characters (such as emojis or accented letters) are handled correctly.\n\nThis approach iterates over the characters in the string, reverses them, and collects them back into a new String.\n\nString slicing in Rust allows you to reference a portion of a string without copying it. However, because Rust strings are UTF-8 encoded, you need to be cautious when slicing to avoid cutting a multi-byte character in the middle.\n\nHere, slices the first five bytes of the string, which corresponds to the word \"Hello\". Attempting to slice across a character boundary would cause a runtime error.\n‚Ä¢ Concatenation: Use the operator for simple concatenation, or for more complex cases where you want to keep ownership of the original strings.\n‚Ä¢ Interpolation: Use to insert variables or expressions directly into strings.\n‚Ä¢ Reversing Strings: Use to reverse a string while preserving UTF-8 correctness.\n‚Ä¢ Slicing Strings: Safely slice strings by specifying valid byte indices, ensuring you don't split a character in half.\n\nThese operations are essential building blocks when working with strings in Rust. By understanding how to concatenate, interpolate, reverse, and slice strings, you can efficiently handle common string manipulation tasks in your Rust programs.\n\nWhile basic string operations are essential, Rust also provides powerful tools for advanced string manipulation, such as searching, splitting, replacing parts of strings, and trimming whitespace. Let's explore these operations in detail.\n\nRust allows you to search for substrings or patterns within strings using methods like , , and / . These methods can help you identify whether a string contains specific content or matches a certain pattern.\n\nExample: Finding the Index of a Substring\n\n The method returns the index of the first occurrence of the substring, or if it isn't found.\n\n\n\nYou can also use and to check if a string starts or ends with a specific substring.\n\n\n\nRust provides several methods to split strings into substrings based on delimiters, such as , , and more. These methods return an iterator over the parts of the string, which can then be collected into a .\n\nThe method automatically splits a string by any whitespace, which is useful when dealing with user input or unformatted text.\n\n\n\nTo replace parts of a string, Rust provides the and methods. These functions allow you to substitute a substring with a new one, either globally or for a limited number of occurrences.\n\nThe method allows you to specify the number of replacements to perform.\n\n\n\nRust offers several methods to remove leading and trailing whitespace or characters from strings, such as , , and .\n\nYou can also trim specific characters from the start or end of a string using and .\n‚Ä¢ Searching: Use , , , and to search for substrings and patterns.\n‚Ä¢ Splitting: Use or to break strings into smaller parts based on delimiters or whitespace.\n‚Ä¢ Replacing: Use and to substitute substrings in a string.\n‚Ä¢ Trimming: Use , , and to remove whitespace or specific characters from a string.\n\nThese advanced string manipulation techniques allow you to efficiently search, split, replace, and trim strings in Rust, making it easier to work with text in a variety of use cases.\n\nFor more advanced string manipulation and pattern matching, Rust provides support for regular expressions through the crate. Regular expressions (regex) allow you to search for, match, and manipulate string data based on complex patterns, which is useful when dealing with data validation, parsing, or extraction.\n\nTo use regular expressions in Rust, you‚Äôll need to include the crate in your file:\n\n\n\nAfter adding the crate, you can import the necessary modules in your Rust file:\n\n\n\nTo check whether a string matches a specific pattern, you can use the method from the Regex struct. This method returns true if the string matches the pattern and false otherwise.\n\nIn this example, the regex pattern checks if the string is in the format of a date .\n\nRegex in Rust allows you to capture parts of a string using parentheses . These captured groups can then be extracted for further processing.\n\nIn this example, the regex pattern captures the user, domain, and top-level domain (TLD) from an email address and prints each part.\n\nJust like with basic string replacements, you can also use regular expressions to find and replace patterns in strings. The method allows you to replace all matches of a regex pattern with a specified replacement.\n\nHere, the regex pattern matches any sequence of digits and replaces them with the text [REDACTED].\n\nIf you need to extract all occurrences of a pattern in a string, you can use the method. This method returns an iterator over all matches.\n\nExample: Finding All Numbers in a String\n\nThis example iterates over all sequences of digits in the text and prints each match, outputting:\n\n\n\nWhile regular expressions are powerful, they can also be slower than simple string operations. It's important to use them only when necessary, and to avoid overly complex patterns that could impact performance, especially in high-throughput applications.\n\nRust's regex crate is optimized and does not suffer from catastrophic backtracking, making it safe to use in most scenarios without worrying about performance issues. However, it's always a good idea to benchmark your application if you're performing many regex operations in performance-critical sections of your code.\n‚Ä¢ Pattern Matching: Use to check if a string matches a regular expression.\n‚Ä¢ Capturing Groups: Extract parts of a string using parentheses in your regex pattern and access the captured groups.\n‚Ä¢ Replacing with Regex: Use or to replace all matches of a pattern with specified text.\n‚Ä¢ Iterating Over Matches: Use to iterate over all matches of a pattern in a string.\n‚Ä¢ Performance: Regular expressions are powerful but should be used judiciously in performance-sensitive applications.\n\nBy leveraging the regex crate, you can perform advanced pattern matching and string manipulation in Rust, making it easier to handle complex data validation, extraction, and transformation tasks.\n\nWhen working with strings in Rust, performance can become an important consideration, especially in large-scale or high-throughput applications. Due to Rust's strict memory management and ownership model, it offers several performance advantages, but it‚Äôs important to understand how certain string operations can impact your program's efficiency. In this section, we'll explore how to optimize string handling for performance.\n\nOne of the primary performance considerations with strings in Rust is avoiding unnecessary heap allocations. Since is a heap-allocated data structure, repeatedly creating and modifying objects can result in unnecessary memory allocations and deallocations, which may slow down your program.\n‚Ä¢ Prefer Over When Possible: If you don‚Äôt need to modify or own the string data, prefer using string slices ( ) instead of . Slices are just references to an existing string, meaning no additional allocation is required.\n\nUse : When you know in advance how large your string will be (or an estimate), you can use to preallocate memory. This prevents the string from reallocating memory multiple times as it grows.\n\nBy using , you can avoid repeated reallocations, which can improve performance when dealing with large or growing strings.\n\nRust‚Äôs ownership and borrowing model encourages efficient memory usage by allowing you to borrow data instead of copying it. This is especially useful for strings, where copying data can be costly.\n\nBorrow Instead of Cloning: When passing a String to a function, borrow it as a &str instead of transferring ownership or cloning it, unless you specifically need ownership of the data inside the function.\n\nIn this example, borrows the string as a , so no copying or cloning of the string‚Äôs data is necessary.\n\nIterating over strings in Rust requires careful consideration of UTF-8 encoding. While it‚Äôs easy to iterate over bytes in a string, iterating over characters can be more complex since Rust strings are UTF-8 encoded, and characters can be multi-byte.\n\nIn this example, the method safely handles multi-byte characters, such as those in the Unicode \"‰∏ñÁïå\" (meaning \"world\").\n\nWhen performance is critical, you can iterate over bytes instead of characters if you don't need to consider UTF-8 encoding.\n\nThis method is faster but may not be suitable if you're working with non-ASCII characters.\n\nRepeatedly concatenating strings using the + operator or push_str() can lead to performance bottlenecks due to repeated memory reallocations. Instead, consider building your string more efficiently using a String with preallocated capacity, or using the format!() macro to concatenate multiple values at once.\n\nExample: Using format!() for Efficient Concatenation\n\nUsing is often more efficient than repeatedly concatenating strings, especially when combining multiple values.\n\nIt‚Äôs important to profile and benchmark your code to identify performance bottlenecks in string operations. Rust provides a built-in benchmarking tool in the test crate, which you can use to measure the performance of specific string operations.\n\nExample: Using the bencher Crate for Benchmarking\n\nTo enable benchmarking, add the following to your Cargo.toml:\n\n\n\nThen, you can write benchmark tests to measure the performance of string operations.\n\nRunning these benchmarks can help you identify inefficient string operations and optimize accordingly.\n‚Ä¢ Minimize Allocations: Prefer over when possible and use for efficient memory usage.\n‚Ä¢ Borrowing: Borrow strings as to avoid unnecessary cloning or copying of data.\n‚Ä¢ Efficient Iteration: Use to safely iterate over characters, but consider . for performance if non-ASCII characters aren‚Äôt involved.\n‚Ä¢ Avoid Excessive Concatenation: Use or preallocate string capacity to avoid repeated memory reallocations.\n‚Ä¢ Benchmark: Profile and benchmark your string operations to ensure optimal performance.\n\nBy understanding and applying these performance considerations, you can handle strings more efficiently in Rust, avoiding common performance pitfalls while maintaining the language‚Äôs strong memory safety guarantees.\n\n7. Summary and Best Practices for Working with Strings in Rust\n\nBy now, we've covered a broad range of string operations in Rust, from basic concepts to advanced manipulations and performance optimizations. Understanding Rust‚Äôs string handling is critical for writing efficient, safe, and high-performing code. In this section, we'll summarize the key takeaways and highlight some best practices when working with strings in Rust.\n‚Ä¢ \n‚Ä¢ is an immutable reference to a string slice, often used for string literals and when no ownership or mutation is required.\n‚Ä¢ is an owned, heap-allocated, and mutable string. Use it when you need to modify or own the string.\n‚Ä¢ Understand the difference between these two to avoid unnecessary allocations and to make your programs more efficient.\n‚Ä¢ \n‚Ä¢ Converting between and is common in Rust, and you should use methods like and appropriately.\n‚Ä¢ Other conversions, such as from bytes or integers to strings, are useful in various situations, especially when handling user input or binary data.\n‚Ä¢ \n‚Ä¢ Concatenation: Use for simple cases but consider for more complex concatenations to maintain ownership of strings.\n‚Ä¢ Interpolation: Embed variables into strings using to maintain clarity and efficiency.\n‚Ä¢ Reversing: Be aware of UTF-8 encoding and use for safe character-level reversals.\n‚Ä¢ \n‚Ä¢ Searching: Use , , and to efficiently search strings for substrings or patterns.\n‚Ä¢ Splitting: Use or to break strings into smaller parts, depending on your needs.\n‚Ä¢ Replacing: The and methods allow you to efficiently substitute substrings.\n‚Ä¢ Trimming: Use , , and to remove unwanted whitespace or specific characters.\n‚Ä¢ \n‚Ä¢ The crate allows for powerful pattern matching, extraction, and replacements in strings.\n‚Ä¢ Use regex sparingly in performance-critical code, and prefer simpler string methods where possible.\n‚Ä¢ \n‚Ä¢ Minimize unnecessary heap allocations by preferring when possible and using for efficient string construction.\n‚Ä¢ Borrow strings rather than cloning or transferring ownership unless needed.\n‚Ä¢ Benchmark your code to detect and address performance bottlenecks in string operations.\n\nb. Best Practices for Working with Strings in Rust\n‚Ä¢ None Use When You Can: Prefer when you only need to reference a string, as it avoids unnecessary heap allocations. Only use when you need to own or modify the data.\n‚Ä¢ None Preallocate Memory for : When building or modifying large strings, use to preallocate memory and avoid costly reallocations during concatenation or mutation.\n‚Ä¢ None Be Cautious with UTF-8: Always be mindful of Rust‚Äôs UTF-8 encoding when slicing, reversing, or manipulating strings at the character level. Use methods like to ensure safe iteration and manipulation of characters.\n‚Ä¢ None Avoid Overusing Regular Expressions: Regular expressions are powerful but can introduce complexity and performance overhead. Use simpler methods like , , or when regular expressions aren‚Äôt necessary.\n‚Ä¢ None Borrow When Passing Strings to Functions: When passing strings to functions, use as the parameter type unless you need ownership of the string. This reduces unnecessary memory copying and keeps your code more efficient.\n‚Ä¢ None Benchmark and Profile: Especially for high-performance or production-critical code, benchmark your string operations to ensure that your string handling is optimized. The or crates can help you profile your code effectively.\n\nRust‚Äôs approach to string handling is both powerful and efficient, providing developers with fine-grained control over memory management and performance. However, this power comes with the responsibility to carefully consider when to own, borrow, or modify strings, and to be mindful of how strings are stored and processed.\n\nBy understanding the difference between and , efficiently performing common operations, and applying performance considerations, you can ensure that your Rust programs handle strings in an optimal way. Whether you're building small command-line tools or large-scale applications, mastering string manipulation in Rust is essential for writing clear, efficient, and safe code.\n\nNow that you have a comprehensive understanding of Rust strings, you can confidently build more complex string-based operations, knowing that you're making informed decisions about memory usage and performance."
    },
    {
        "link": "https://stackoverflow.com/questions/51899535/when-should-i-use-direct-access-into-a-rust-vec-instead-of-the-get-method",
        "document": "The top answer incorrectly mentioned that is a \"syntactic shortcut for .\n\nI just want to note why and how that that's wrong, for anyone else searching about this as I did.\n\nIn many cases they are similar, but two notable differences:\n‚Ä¢ None is a a method on the general trait Index, which anyone can implement on a custom type\n‚Ä¢ None is a method on the sealed trait SliceIndex, that has certain guarantees regarding it's unsafe methods.\n\nUltimately, in practice, is usually about convenience for common operations. With panic's being acceptable when they represent core logic errors in the code.\n\ne.g. if you write code where it should be guaranteed to always access in bounds then arguably there's no error handling to do for it -- as there should be no cases to handle -- so an error would just be an unwrap or bubbling up to main -- which are just more expensive panics in most cases.\n\nIt would be ideal if all such situations could be compile time checked, but if they can't a panic is considered best practice in most cases.\n\nErrable access -- like is for when you do not believe that the code logic is guaranteed and may need other code to make runtime decisions based on the failure using standard mechanisms. (vs dealing with a panic, which can technically be done, but isn't sop)\n\nTLDR: .get and [] have a few differences that are real. [] is broader and implementable and it dereferences.\n\nBut to your core question: panics aren't inherently wrong. Code panicking in cases where (a) failure should never happen due to the code logic and (b) we have no way of proving that via the compiler -- is best practice.\n\nThis is different than just not panicking because of how you intend to use the code. e.g. -- if you have a function that grabs an index fed to it from an external source -- that should have errors. As there's no way for the code to guarantee that the received index is valid.\n\n However, if you have a code branch where you first check length and then get access based on that: then panicking is valid. As failure indicates a bug in the program -- which is not what error responses are typically designed to catch. (otherwise everything would return an error -- which isn't quite practical)"
    },
    {
        "link": "https://reddit.com/r/rust/comments/11rb9x3/why_does_unwrap_or_require_a_reference",
        "document": "I was going through the official Rust book, and noticed that when using the function, the parameter passed in had to be a reference but I am unsure as to why?\n\nWith the example code, I would require passing i rather than just . I noticed that if I create a copy of the returned from the method I would not require a reference with the parameter.\n\nThank you in advance for any help."
    },
    {
        "link": "https://stackoverflow.com/questions/67015865/unwrap-or-in-rust-that-returns-two-values",
        "document": "That's not possible: Rust is a typed language so everything can only have a single type. The idiomatic way to do what you describe is to use a , which can hold either a value or an error. This can be created with :"
    },
    {
        "link": "https://users.rust-lang.org/t/best-practices-for-unwrap/101335",
        "document": "Is it ever acceptable to use unwrap()/expect() in rust production level code? The more articles I read, the more opinions I see about avoiding unwrap at all costs but it seems as though most crate functions return a Result or an Option type, which would result in so many match or \"if let\" statements if unwrap/expect is not used. For example, say I had a function that has 5 different function calls in it that all return a Result type. Would it be best practice to handle every single one within the function with a match statement or would you normally just propograte up the error to the caller by returning Result<(), Box>? fn example() -> Result<(), Box<dyn std::error::Error>> { match function1() { // Or could use \"if let Err(e) = {} Ok(()) => info!(\"No error occured\"), Err(error) => { error!(\"Error while executing function1: {}\", error); } }; match function2() { // Or could use \"if let Err(e) = {} Ok(()) => info!(\"No error occured\"), Err(error) => { error!(\"Error while executing function2: {}\", error); } }; match function3() { // Or could use \"if let Err(e) = {} Ok(()) => info!(\"No error occured\"), Err(error) => { error!(\"Error while executing function3: {}\", error); }; Ok(()) }\n\nIf you believe that the error can never happen, use or . In other words, if the only way for the error to happen is that there is a bug in the code somewhere, panic. Don't propagate errors resulting from bugs. Propagate if the error is a valid possibility, i.e. if it's a defined part of the function's API.\n\nThe post by burntsushi is very good, and I just want to add that if you have a multithreaded or async program, it is important to remember that threads and tasks are panic boundaries, so you should have some means of propagating them. That is, if you're using when it would only fail due to a bug, you should probably the of the corresponding thread if you can.\n\nIs it ever acceptable to use unwrap()/expect() in rust production level code? which would result in so many match or \"if let\" statements if unwrap/expect is not used. You should propagate most errors using the operator. Do not make decisions on behalf of the caller ‚Äî they won't be able to change the behavior if you hard-code an into your own code. Most errors can occur for whatever reason ‚Äì design for robustness, don't just design for the happy path. That's why -bubbling was invented. Don't try to every single error, that's a code smell in itself (it's what Go does and it hurts). The situation when it is acceptable to use is when the structure or logic of your code makes it provably impossible for the error case to occur. For example:\n‚Ä¢ it is never OK to an I/O error\n‚Ä¢ it is never OK to unwrap an error resulting from parsing arbitrary malformed user input (eg. if the input is a byte stream provided by the user or read from a file)\n‚Ä¢ it is OK to unwrap a or a when you are maintaining a data structure that mandates a known non-empty backing storage\n‚Ä¢ it is OK to unwrap the result of parsing some statically known correct input, eg. the return value of\n\nThank you for the detailed answer, I agree that in most circumstances it is best to have the caller decide what to do. But, by propagating errors via ? to the caller, doesn't that cause generic error displays which would be a bit more difficult to debug? For example, say I had a function that did:\n‚Ä¢ Used reqwest to GET a value\n‚Ä¢ Parse that returned value as json\n‚Ä¢ Do a cast of each String in the Vec to another type (say u32 for example) Each one of those operations results in an .unwrap(), which would propagate up to the function caller because of ?. If the function caller just does a generic error!(\"Failed to fetch data and parse to u32\"); , doesn't that provide a little less context as to what actually went wrong (i.e. fetch vs json parse vs cast)?\n\nI think you misunderstood what the operator actually does. It doesn't do an unwrap, it just a short hand for early returning in case of an error, essentially: fn my_func() -> Result<(), SomeError> { // essentially the same as doing let foo = result?; let foo = match result { Ok(value) => value, Err(error) => return error, }; // .... } There is no missing detail, the caller will get the same error type you did and will decide what to do about it. I hope this helps, I'm not sure I understood your question.\n\nIs it ever acceptable to use unwrap()/expect() in rust production level code? My usual response: It's acceptable whenever you as the developer would be happy getting a \"you have to investigate this today\" bug about it. If I'm pretty sure something isn't possible, it should shout loudly if I'm wrong so I can go fix that. But I also shouldn't be forced to handling things that never happen in practice, because making people write a bunch of never-tested error handling paths reduces both velocity and reliability.\n\nAs far as I am concerned unwrap() is an admission that I have no clue as to how to proceed in the face of that error. Or a statement that if that error happens there is no sensible way to recover. Either way it's better to abort immediately rather than try and limp along in a broken state. It's probably better to use expect() to help with future debugging."
    },
    {
        "link": "https://doc.rust-lang.org/std/vec/struct.Vec.html",
        "document": "The macro is provided for convenient initialization: It can also initialize each element of a with a given value. This may be more efficient than performing allocation and initialization in separate steps, especially when initializing a vector of zeros: For more information, see Capacity and Reallocation. Use a as an efficient stack: The type allows access to values by index, because it implements the trait. An example will be more explicit: However be careful: if you try to access an index which isn‚Äôt in the , your software will panic! You cannot do this: Use and if you want to check whether the index is in the . A can be mutable. On the other hand, slices are read-only objects. To get a slice, use . Example: In Rust, it‚Äôs more common to pass slices as arguments rather than vectors when you just want to provide read access. The same goes for and . The capacity of a vector is the amount of space allocated for any future elements that will be added onto the vector. This is not to be confused with the length of a vector, which specifies the number of actual elements within the vector. If a vector‚Äôs length exceeds its capacity, its capacity will automatically be increased, but its elements will have to be reallocated. For example, a vector with capacity 10 and length 0 would be an empty vector with space for 10 more elements. Pushing 10 or fewer elements onto the vector will not change its capacity or cause reallocation to occur. However, if the vector‚Äôs length is increased to 11, it will have to reallocate, which can be slow. For this reason, it is recommended to use whenever possible to specify how big the vector is expected to get. Due to its incredibly fundamental nature, makes a lot of guarantees about its design. This ensures that it‚Äôs as low-overhead as possible in the general case, and can be correctly manipulated in primitive ways by unsafe code. Note that these guarantees refer to an unqualified . If additional type parameters are added (e.g., to support custom allocators), overriding their defaults may change the behavior. Most fundamentally, is and always will be a (pointer, capacity, length) triplet. No more, no less. The order of these fields is completely unspecified, and you should use the appropriate methods to modify these. The pointer will never be null, so this type is null-pointer-optimized. However, the pointer might not actually point to allocated memory. In particular, if you construct a with capacity 0 via , , , or by calling on an empty Vec, it will not allocate memory. Similarly, if you store zero-sized types inside a , it will not allocate space for them. Note that in this case the might not report a of 0. will allocate if and only if . In general, ‚Äôs allocation details are very subtle ‚Äî if you intend to allocate memory using a and use it for something else (either to pass to unsafe code, or to build your own memory-backed collection), be sure to deallocate this memory by using to recover the and then dropping it. If a has allocated memory, then the memory it points to is on the heap (as defined by the allocator Rust is configured to use by default), and its pointer points to initialized, contiguous elements in order (what you would see if you coerced it to a slice), followed by logically uninitialized, contiguous elements. A vector containing the elements and with capacity 4 can be visualized as below. The top part is the struct, it contains a pointer to the head of the allocation in the heap, length and capacity. The bottom part is the allocation on the heap, a contiguous memory block.\n‚Ä¢ uninit represents memory that is not initialized, see .\n‚Ä¢ Note: the ABI is not stable and makes no guarantees about its memory layout (including the order of fields). will never perform a ‚Äúsmall optimization‚Äù where elements are actually stored on the stack for two reasons:\n‚Ä¢ It would make it more difficult for unsafe code to correctly manipulate a . The contents of a wouldn‚Äôt have a stable address if it were only moved, and it would be more difficult to determine if a had actually allocated memory.\n‚Ä¢ It would penalize the general case, incurring an additional branch on every access. will never automatically shrink itself, even if completely empty. This ensures no unnecessary allocations or deallocations occur. Emptying a and then filling it back up to the same should incur no calls to the allocator. If you wish to free up unused memory, use or . and will never (re)allocate if the reported capacity is sufficient. and will (re)allocate if . That is, the reported capacity is completely accurate, and can be relied on. It can even be used to manually free the memory allocated by a if desired. Bulk insertion methods may reallocate, even when not necessary. does not guarantee any particular growth strategy when reallocating when full, nor when is called. The current strategy is basic and it may prove desirable to use a non-constant growth factor. Whatever strategy is used will of course guarantee O(1) amortized . , , and , will all produce a with at least the requested capacity. If , (as is the case for the macro), then a can be converted to and from a without reallocating or moving the elements. will not specifically overwrite any data that is removed from it, but also won‚Äôt specifically preserve it. Its uninitialized memory is scratch space that it may use however it wants. It will generally just do whatever is most efficient or otherwise easy to implement. Do not rely on removed data to be erased for security purposes. Even if you drop a , its buffer may simply be reused by another allocation. Even if you zero a ‚Äôs memory first, that might not actually happen because the optimizer does not consider this a side-effect that must be preserved. There is one case which we will not break, however: using code to write to the excess capacity, and then increasing the length to match, is always valid. Currently, does not guarantee the order in which elements are dropped. The order has changed in the past and may change again."
    }
]