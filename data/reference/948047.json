[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.numerics.vector3?view=net-9.0",
        "document": "Compares two vectors, on a per-element basis, to compute which has the greater magnitude and returning the other value if an input is .\n\nCompares two vectors, on a per-element basis, to compute which is greater and returning the other value if an element is .\n\nCompares two vectors, on a per-element basis, to compute which has the lesser magnitude and returning the other value if an input is .\n\nCompares two vectors, on a per-element basis, to compute which is lesser and returning the other value if an element is .\n\nAttempts to copy the vector to the given Span<T>. The length of the destination span must be at least 3."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.numerics.vector3.-ctor?view=net-9.0",
        "document": "Collaborate with us on GitHub\n\nThe source for this content can be found on GitHub, where you can also create and review issues and pull requests. For more information, see our contributor guide"
    },
    {
        "link": "https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Numerics/Vector3.cs",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/54442779/how-to-get-the-elements-of-a-system-numerics-vector-in-c",
        "document": "I want to access the elements of a in C#. I'm following the official documentation: https://learn.microsoft.com/en-us/dotnet/api/system.numerics.vector-1?view=netcore-2.2\n\nI'm able to create different vectors with different datatypes. For example:\n\nBut now I have the problem, that I'm unable to call test.Count; it is not possible to call Count on an instance of type .\n\nI can access single elements with the , but I dont know how many elements are in the vector.\n\nAccording to the documentation, there should be the public property:\n\nBut I can not call in on my instance of . Instead I can call it only in a static manner like following:\n\nThis is equal to 2.\n\nAnd now I'm really a bit confused, about how to use this static property. At first, I thought, that this property would return the number of elements stored in the vector (as stated in the documentation). Second, I thought, that this property returns the size of the vector in memory, but this number increases from double to Int32 to Int16.\n\nInterestingly I can not call this static property from my instance created by:\n\nDo you know how to access the elements of ?"
    },
    {
        "link": "https://medium.com/@nikitinsn6/harnessing-the-power-of-simd-with-system-numerics-vectors-in-net-cd88cd103f70",
        "document": "Harnessing the Power of SIMD with System.Numerics.Vectors in .NET Introduction to SIMD: Learn about SIMD and its importance in improving performance for various types of computations, such as linear algebra, image processing, and more. SIMD (Single Instruction, Multiple Data) is a parallel computing concept that allows a single instruction to operate on multiple data points simultaneously. It is a form of data-level parallelism, which is particularly useful for tasks that involve large datasets and repetitive, independent computations. SIMD can significantly improve the performance of applications in various domains, such as linear algebra, image processing, audio processing, cryptography, and machine learning. Modern processors implement SIMD through instruction set extensions, which provide specialized hardware for performing vector operations. Some common SIMD instruction sets include SSE, AVX, NEON, and AltiVec, each with varying degrees of vector length and instruction support. When using SIMD, data is organized into vectors, which are processed in parallel by a single instruction. This can lead to significant performance improvements compared to scalar processing, where each data point is processed one at a time. For example, consider the following code snippet that performs element-wise addition of two float arrays: In scalar processing, this loop would perform one addition operation per iteration. However, by using SIMD, we can process multiple elements in parallel, leading to a potential performance boost: int vectorSize = Vector<float>.Count; // The length of the array should be equal to or greater than the size of the vector (i.e., Vector<float>.Count).\n\nint i;\n\n\n\nfor (i = 0; i <= array1.Length - vectorSize; i += vectorSize)\n\n{\n\n Vector<float> vec1 = new Vector<float>(array1, i);\n\n Vector<float> vec2 = new Vector<float>(array2, i);\n\n\n\n Vector<float> sum = vec1 + vec2;\n\n sum.CopyTo(result, i);\n\n} In this example, we use the class from the namespace in .NET. The class leverages SIMD instructions to perform element-wise addition of float arrays in parallel. Depending on the SIMD instruction set supported by the hardware, the vector size can vary, and more elements can be processed simultaneously, leading to improved performance. It’s important to note that SIMD is not a magic bullet for performance improvement. Its effectiveness depends on the nature of the task and the specific hardware being used. In some cases, SIMD may not provide significant performance gains or may even hurt performance due to additional overhead. Therefore, it is essential to carefully analyze the target application and hardware to determine if SIMD is an appropriate optimization technique.\n\nUnderstanding System.Numerics.Vectors: Get familiar with the System.Numerics.Vectors namespace and the Vector<T> class, including installation and setup. The namespace in .NET provides a set of types to work with SIMD (Single Instruction, Multiple Data) operations. The primary class in this namespace is the class, which represents a vector of a specified numeric type that can be processed using SIMD instructions. The class is designed to work seamlessly with the SIMD instruction sets supported by the underlying hardware, providing a high-level abstraction for vector operations. To get started with , follow these steps:\n• Install the NuGet package. You can install it using the NuGet Package Manager in Visual Studio or via the command line: 2. Add the directive for the namespace in your code: 3. Use the class to perform SIMD operations on your data. Here's a simple example that demonstrates how to create a instance and perform basic operations Random random = new Random();\n\n\n\nint vectorSize = Vector<float>.Count;\n\nfloat[] vec1Values = new float[vectorSize];\n\nfloat[] vec2Values = new float[vectorSize];\n\n\n\nfor (int i = 0; i < vectorSize; i++) {\n\n vec1Values[i] = random.Next(1, 25);\n\n vec2Values[i] = random.Next(1, 25);\n\n}\n\n\n\nVector<float> vec1 = new Vector<float>(vec1Values);\n\nVector<float> vec2 = new Vector<float>(vec2Values);\n\n\n\nVector<float> sum = vec1 + vec2; // Element-wise addition\n\nVector<float> difference = vec1 - vec2; // Element-wise subtraction\n\nVector<float> product = vec1 * vec2; // Element-wise multiplication\n\nVector<float> quotient = vec1 / vec2; // Element-wise division\n\n\n\nConsole.WriteLine(\"Sum: \" + sum);\n\nConsole.WriteLine(\"Difference: \" + difference);\n\nConsole.WriteLine(\"Product: \" + product);\n\nConsole.WriteLine(\"Quotient: \" + quotient); In this example, we create two instances, and , and perform element-wise addition, subtraction, multiplication, and division. The class overloads the standard arithmetic operators, making it easy to perform these operations. The class also provides additional methods for more advanced operations, such as calculating the dot product, squaring the elements, and performing various mathematical functions. You can explore these methods in the official documentation. When using the class, it's crucial to ensure that your target hardware supports SIMD. You can check for SIMD support using the property. If this property returns , you should use a non-SIMD implementation for optimal performance. By using the namespace and the class, you can leverage SIMD capabilities to improve the performance of your .NET applications in a variety of domains, such as image processing, linear algebra, and machine learning.\n\nHardware Acceleration: Discover how to detect SIMD support on your target machine using the Vector.IsHardwareAccelerated property and the importance of providing fallback implementations for machines without SIMD support. When working with SIMD operations using the class in the namespace, it is essential to ensure that your target hardware supports SIMD. Not all processors support SIMD instructions or may support different SIMD instruction sets with varying capabilities. To maximize performance and compatibility, you should provide fallback implementations for machines without SIMD support. The property allows you to check if SIMD is supported on the current machine. This property returns if the class can leverage hardware acceleration through SIMD instructions; otherwise, it returns . You can use this property to decide whether to use a SIMD-based implementation or a fallback scalar implementation. Here’s an example demonstrating how to use the property to detect SIMD support and provide a fallback implementation: using System;\n\nusing System.Numerics;\n\n\n\nclass Program\n\n{\n\n static void Main()\n\n {\n\n float[] array1 = new float[] { 1, 2, 3, 4, 5, 6, 7, 8 };\n\n float[] array2 = new float[] { 8, 7, 6, 5, 4, 3, 2, 1 };\n\n float[] result = new float[array1.Length];\n\n\n\n AddArrays(array1, array2, result);\n\n\n\n Console.WriteLine(\"Result: \" + string.Join(\", \", result));\n\n }\n\n\n\n static void AddArrays(float[] array1, float[] array2, float[] result)\n\n {\n\n if (Vector.IsHardwareAccelerated)\n\n {\n\n int vectorSize = Vector<float>.Count;\n\n int i;\n\n\n\n for (i = 0; i <= array1.Length - vectorSize; i += vectorSize)\n\n {\n\n Vector<float> vec1 = new Vector<float>(array1, i);\n\n Vector<float> vec2 = new Vector<float>(array2, i);\n\n\n\n Vector<float> sum = vec1 + vec2;\n\n sum.CopyTo(result, i);\n\n }\n\n\n\n // Process any remaining elements\n\n for (; i < array1.Length; i++)\n\n {\n\n result[i] = array1[i] + array2[i];\n\n }\n\n }\n\n else\n\n {\n\n // Fallback scalar implementation\n\n for (int i = 0; i < array1.Length; i++)\n\n {\n\n result[i] = array1[i] + array2[i];\n\n }\n\n }\n\n }\n\n} In this example, we check the property before using the class. If SIMD is supported, we perform element-wise addition of the two float arrays using . If SIMD is not supported, we fall back to a simple loop that adds the elements of the two arrays element-wise. By providing fallback implementations, you can ensure that your application runs efficiently on a variety of hardware configurations, taking advantage of SIMD acceleration when available while maintaining compatibility with machines without SIMD support.\n\nVector Operations: Learn how to perform basic vector operations such as addition, subtraction, multiplication, and division using the Vector<T> class, along with more advanced operations like dot product and cross product. The class in the namespace provides a variety of methods and operators for performing vector operations. These operations can leverage SIMD instructions on supported hardware, leading to improved performance for specific types of computations. The class supports basic arithmetic operations such as addition, subtraction, multiplication, and division using overloaded operators. Here's an example demonstrating these operations: These operations are performed element-wise, meaning that each element in the resulting vector is the result of the corresponding operation applied to the elements in the input vectors. The dot product, also known as the scalar product, is an operation that takes two vectors and returns a scalar value. The dot product can be calculated as the sum of the products of the corresponding elements in the input vectors. To calculate the dot product using the class, you can use the method: The cross product, also known as the vector product, is an operation that takes two vectors in three-dimensional space and returns a third vector that is orthogonal to the input vectors. The cross product is commonly used in physics and geometry to compute normals and torques. The class does not directly support the cross product operation for arbitrary vector sizes. However, you can calculate the cross product for 3D vectors using the class from the namespace: By understanding and using the various vector operations available in the class, you can optimize your code for performance in specific domains, such as image processing, linear algebra, and machine learning, leveraging SIMD acceleration on supported hardware.\n\nReal-world Examples: Explore practical examples demonstrating the use of Vector<T> in various scenarios, such as optimizing image processing algorithms, speeding up machine learning calculations, and enhancing physics simulations. Vector<T> can be used to optimize image processing algorithms by processing multiple pixels simultaneously. Here’s an example of a simple brightness adjustment using Vector<float>: public static void AdjustBrightness(float[] image, float brightness)\n\n{\n\n int vectorSize = Vector<float>.Count;\n\n int i;\n\n\n\n Vector<float> brightnessVector = new Vector<float>(brightness);\n\n\n\n for (i = 0; i <= image.Length - vectorSize; i += vectorSize)\n\n {\n\n Vector<float> pixelVector = new Vector<float>(image, i);\n\n Vector<float> adjustedPixelVector = pixelVector + brightnessVector;\n\n adjustedPixelVector.CopyTo(image, i);\n\n }\n\n\n\n // Process any remaining elements\n\n for (; i < image.Length; i++)\n\n {\n\n image[i] += brightness;\n\n }\n\n} In this example, we process the image pixels in parallel using Vector<float> to adjust the brightness of the image more efficiently. Vector<T> can also be used to speed up calculations in machine learning, such as matrix multiplication, which is a core operation in deep learning: public static float[] MultiplyMatrix(float[] A, float[] B, int n)\n\n{\n\n float[] C = new float[n * n];\n\n int vectorSize = Vector<float>.Count;\n\n\n\n for (int i = 0; i < n; i++)\n\n {\n\n for (int j = 0; j < n; j++)\n\n {\n\n Vector<float> sum = Vector<float>.Zero;\n\n\n\n for (int k = 0; k < n; k += vectorSize)\n\n {\n\n Vector<float> vecA = new Vector<float>(A, i * n + k);\n\n Vector<float> vecB = new Vector<float>(B, k * n + j);\n\n\n\n sum += vecA * vecB;\n\n }\n\n\n\n float dotProduct = Vector.Dot(sum, Vector<float>.One);\n\n\n\n for (int k = vectorSize * (n / vectorSize); k < n; k++)\n\n {\n\n dotProduct += A[i * n + k] * B[k * n + j];\n\n }\n\n\n\n C[i * n + j] = dotProduct;\n\n }\n\n }\n\n\n\n return C;\n\n} This example demonstrates how to use Vector<float> to perform matrix multiplication more efficiently by processing multiple elements simultaneously. Using Vector<T> can help optimize calculations in physics simulations, such as performing collision detection and response: public static void UpdateParticlePositions(Particle[] particles, float deltaTime)\n\n{\n\n int vectorSize = Vector<float>.Count;\n\n int i;\n\n\n\n Vector<float> deltaTimeVector = new Vector<float>(deltaTime);\n\n\n\n for (i = 0; i <= particles.Length - vectorSize; i += vectorSize)\n\n {\n\n Vector<float> positionX = new Vector<float>(particles, i, p => p.Position.X);\n\n Vector<float> positionY = new Vector<float>(particles, i, p => p.Position.Y);\n\n\n\n Vector<float> velocityX = new Vector<float>(particles, i, p => p.Velocity.X);\n\n Vector<float> velocityY = new Vector<float>(particles, i, p => p.Velocity.Y);\n\n\n\n positionX += velocityX * deltaTimeVector;\n\n positionY += velocityY * deltaTimeVector;\n\n\n\n positionX.CopyTo(particles, i, (ref Particle p, float value) => p.Position.X = value);\n\n positionY.CopyTo(particles, i, (ref Particle p, float value) => p.Position.Y = value);\n\n }\n\n\n\n // Process any remaining elements\n\n for (; i < particles.Length; i++)\n\n {\n\n particles[i].Position.X += particles[i].Velocity.X * deltaTime;\n\n particles[i].Position.Y += particles[i].Velocity.Y * deltaTime;\n\n }\n\n}\n\n\n\npublic struct Particle\n\n{\n\n public Vector2 Position;\n\n public Vector2 Velocity;\n\n} In this example, we update the positions of particles in a physics simulation using Vector<float> to process multiple particles simultaneously, improving the performance of the simulation. These examples demonstrate the practical use of Vector<T> in various scenarios to optimize performance by leveraging SIMD instructions on supported hardware. By using Vector<T> in your applications, you can achieve significant performance improvements in areas like image processing, machine learning, and physics simulations."
    },
    {
        "link": "https://stackoverflow.com/questions/897455/best-way-of-implementing-these-3-classes-in-c-vector-direction-unit-vector",
        "document": "\n• All Points are Vectors, and all Vectors are Points.\n• All Directions are Vectors, NOT all Vectors are Directions (this shouldn't mean both way conversion shouldn't be allowed).\n\nI want to have the operators overridden once for all preferably since they're all completely identical. In C++ I can just define class Vector { float x,y,z; }, and do typedef Point = Vector, typedef Direction = Vector; In C# there is no equivalent (\"using Point=Vector;\" sucks as you have to place it in every single document you use, and it's not enforced by the compiler).\n\nI tried to define 3 different classes and override the operators for each, then do implicit type casting which would make the code run slower, etc.\n\nI tried defining just Vector, then Point:Vector and Direction:Vector, this way I only write the operators once but then I can't do implicit type casting Point <-> Vector or Direction <->Vector.\n\nI could simply define the Vector class and use that everywhere, but that would create ambiguity as to weather a variable is supposed to be a position in space (Point), a relative position in space (Vector) or a unit vector (Direction). For example the function:\n\nYou can't know whether it's expecting any vectors or unit vectors. In C++ you could do that, so why not in C#?\n\nNote: having structs instead of classes would be ideal if possible."
    },
    {
        "link": "https://stackoverflow.com/questions/45641509/normalized-vector-cross-product-non-zero-vector-unnormalized-vector",
        "document": "It is clear to me that if we cross product two vectors, let say AxB then we will get a new vector C that perpendicular to A and B (either in the positive or negative position). That's OK! Also, it's clear to me the differences between unit vector and non-zero vector. The unit vector is the result of normalizing a non-zero vector and we can say the unit vector is the vector divided by its length.\n\nIf we have two vectors, one of them is a unit vector and the other one is a non-zero vector. Let say A is the unit vector and B is the non-zero vector in this example.\n• Can we cross product them (unit vector x non-zero vector)? Or we must normalize the non-zero vector?\n\nIf we must normalize the non-zero vector. Why must we do so?"
    },
    {
        "link": "https://codeproject.com/Articles/17425/A-Vector-Type-for-Csharp",
        "document": "A guide through a Vector type in C# using Cartesian and Euclidian Geometry\n• Latest source can be found on GitHub but may not match the article.\n\nFor years I have seen people struggle with vector mathematics. This guide should walk you through the creation of a reusable type in c# and the mathematics behind it all. The post-fixed 3 simply refers to the vector being in 3-dimensions (x,y,z).\n\nThe code is not designed to be fast or efficient but is to be as simple and understandable as possible. To this end, and as a personal preference, the Vector3 type is packed with relevent functionality and multiple interfaces to methods (e.g. static and non-static variants of methods). Many would deem this bloated code, however, I think that it makes the code programmer friendly. Obviously, as a projects grows I would tend to refactor functionality back out as I create objects and types for which the functions better fit. I see this as achieving maximum cohesion and minimising coupling and dependencies.\n\nI have used the Cartesian coordinate system in three-dimensions (i.e. three perpendicular axis of x, y and z) and Euclidian geometry. Don't worry about these terms; they are just the formal names for some of the maths covered at senior school. The vector space is volumetric (cube); note that you can use other vector spaces, such as a cylindrical space where one axis (usually z) relates to the radius of the cylinder.\n\nYou may have guessed that computers are quite slow with this type of math. Matrix mathematics is more efficient but much harder to understand. You will need a basic grasp of trigonometry and algebra to understand this guide.\n\nUnless stated otherwise I assume that the vector is positional, originating at point (0,0,0). Alternatives to positional vectors are: unit vectors, which can be interpreted as either having no magnitude or an infinite magnitude; and vector pairs where the origin of the vector is another vector, magnitude being a distance from the origin vector.\n\nPlease note that this guide is extremely verbose and may seem patronising to experienced C# programmers. Please do not be offended, I have written the guide for a wide audience.\n• Operator, this is the symbol used to define an operation such as plus ( ) in (a+b)\n• Operand, these are the variables used in an operation such as (a) and (b) in (a+b). The left-hand-side (LHS) operand is (a) where as the right-hand-side (RHS) operand is (b).\n\nTo begin with, let us define how the vector information will be stored. I don't often create structs when coding, but for our this is perfect. If you are reading this article you probably already know that a vector represents values along a number of axes. For this tutorial we will be developing a three-dimensional type so... thee variables and three axis.\n\nWhat orientation are the axes in? Being from a visualization background I always assume:\n\nYou may have noticed that Z is negative as you look down the axis. This is a common convention in graphics libraries such as OpenGL. This will become important later on when considering pitch, roll and yaw methods.\n\nA quick diversion: Why a struct instead of a class?\n\n \n\n The differences between struct and class:\n• A struct is a value type created on the stack instead of the heap, thus reducing garbage collection overheads.\n• They are passed by value not by reference.\n• They are created and disposed of quickly and efficiently.\n• You cannot derive other types from them (i.e. non-inheritable).\n• They are only appropriate for types with a small number of members (variables). Microsoft recommends a struct should be less than 16 bytes.\n• You do not need the new keyword to instantiate a struct.\n\nBasically, it looks like, acts like, and is a primitive type. Although, there is no reason why the vector type could not be created as a class. A drawback of developing a struct is that collection classes in the .NET framework cast structs as classes. This means that a large collection of 's will have a high casting overhead. Generic types were intoduced in C# v2.0 and can be used to reduce the performance cost of casting and boxing structs in collections.\n\nA more in-depth article on structs has been written by S. Senthil Kumar here\n\nDid you notice that the variables were private and readonly?\n\nWhile I have chosen to build a struct, I habitually hide my variables and create public accessor and mutator properties. This is not strictly good practice for structs, but I have created them in case I feel the need to convert to a class at a later date (this is good practice for class structures). In fact, in this type I will not be creating public mutators because a struct should be immutable.\n\nThe variables are readonly because this class will be immutable. The x, y, and z variables can only be set when the struct is being constructed. This means that once a is built, it will always have the same value. All operations that are performed on the will produce another struct. This is important because structs are passed by value which means that they are copied when passed to another method. If you change (or mutate) the values in another method then the changes are lost when you return to the calling method.\n\nIn addition to the properties, an array style interface has also been provided. This allows the user call the with , , . Additionally, the user can get all of the components as an array using the property.\n\nA property has also been provided to access the magnitude of a vector. The magnitude (or absolute value) of a vector is its length , irrespective of direction and can be determined using the formula:\n\nThe method (used below) can be seen later in this article.\n\nTo construct the type using typical class syntax the following constructor methods have been provided:\n\nWe now have a framework for storing, accessing and mutating the and its components (x,y,z). We can now consider mathematical operations applicable to a vector. Let's begin by overloading the basic mathematical operators.\n\nOverloading operators allows the programmer to define how a type is used in the code. Take, for example, the plus operator ( ). For numeric types this would suggest addition of two numbers. For strings it represents the concatenation of two strings. Operator overloading is of huge benefit to programmers when describing how a type should interact with the system. In C# the following operators can be overloaded:\n• Difference\\comparison operators, less-than or equal-to and greater-than or equal-to( and )\n\nQuick Note: MSDN calls this operator overloading, however, what we are doing is more like operator overwriting. If the operators were defined on a base class then we would be using the term operator overwriting.\n\nThe addition of two vectors is achieved by simply adding the x, y, and z components of one vector to the other (i.e. x+x, y+y, z+z).\n\nSubtraction of two vectors is simply the subtraction of the x, y, and z components of one vector from the other (i.e. x-x, y-y, z-z).\n\nNegation of a vector inverts its direction. This is achieved by simply negating each of the component parts of the vector.\n\nReinforcement of a vector actually does nothing but return the original vector given the rules of addition, (i.e. +-x = -x and ++x = +x).\n\nOverloads for the following operators can be found elsewhere in the article:\n• Less than or equal to\n• Greater than or equal to\n\nWhen checking for equality we examine the component parts (x,y,z) of the vectors. When comparing two vectors we compare the magnitude.\n\nComparing doubles (the magnitude or the component parts of the vector) seems strait forward, the .Net double type provides operators <, >, <=, >=, ==, != and implements IComparable and IEquatable. However, these operations are not reliable. This is because of the way that fractional numbers (i.e. float, double, and decimal variables) are stored in binary representation and the error margin of calculations on them. This gets more complicated when you try to account for special cases numbers: positive and negative 0, positive and negative infinity and Not-A-Number. See Bruce Dawson's article for more information.\n\nThere has been a lot of discussion in the comments of this article regarding the use of a threshold when calculating equality. I personally agree with red Baron who suggests that the end user should be responsible for tolerance as it relates to their application:\n\n\"... you should not implement a tolerance value inside your code.\n\n What is a suitable value for this tolerance?\n\n It is depending on the problem ...\"\n\nOperator signatures cannot be overloaded to take additional parameters so 's comparison operators will remain as intolerant as the double type's operators. When making a comparison between vectors it is recommended that you use , , , with a reasonable tolerance related to the end user application. This is in preference to equality operators , and . The Equals method, however, can be overloaded.\n\nThere are a number of approaches to tolerant comparisons, those described in Bruce Dawson's article are:\n• Epsilon comparison / Absolute error tolerance\n\n Best suited for numbers close to 0\n• Relative epsilon comparison / Relative error tolerance\n\n Best suited for numbers larger than 0 but difficult to define an appropriate value\n• Ulp (Units in the Last Place)\n\n Best suited for numbers larger than 0\n\nFor the purposes of this article, only absolute error tolerance has been implemented and only as overloads where appropriate. It is important to remember that the operators (<, >, <=, >=, ==, !=) will not accept a tolerance value.\n\nLess-than compares two vectors, returning true only if the magnitude of the left-hand-side vector (v1) is less than the magnitude of the other (v2). To improve efficiency, we do not need to take the final step when calculating the magnitude of a vector, which is to square root the result. The comparison will be the same for the magnitude squared.\n\nLess-than or equal-to compares two vectors returning true only if the magnitude of the left-hand-side vector (v1) is less than the magnitude of the other (v2) or the two magnitudes are equal. Again we use the squared magnitude for efficiency.\n\nGreater-than compares two vectors returning true only if the magnitude of the left-hand-side vector (v1) is greater than the magnitude of the other (v2). Again we use the squared magnitude for efficiency.\n\nGreater-than or equal-to compares two vectors returning true only if the magnitude of the left-hand-side vector (v1) is greater than the magnitude of the other (v2) or the two magnitudes are equal. Again we use the squared magnitude for efficiency.\n\nTo check if two vectors are equal we simply check the component pairs. We AND the results so that any pair which is not equal will result in false.\n\nIf the operator == (equal) is overridden, C# forces us to override != (not-equal). This is simply the inverse of equality.\n\nThe method checks for equality between two vectors and implements the and interfaces provided by the .Net framework. In most cases the result is identical to the == operator. However, one of the special values of a double, the NaN (Not a number), works differently.\n\nThis is consistent with the operator == and implementation of .Equals for a double. The reasons for this are described in this article.\n\nAs mentioned, the method can be overloaded to allow a tolerance value.\n\nThe method is defined on the base class for all objects in C# to provide quick equality comparisons for hash based collections such as . Hash code comparisons should produce the same result as the Equals method so we must override when we override the method. For more information see MSDN.\n\nThe hash codes of each of the component parts of the vector are bitwise combined with XOR. The prime number 397 is of sufficient size to cause the component hash code to overflow providing a better distribution of hash codes. stops the compiler from checking for numeric overflow, which in this unusual situation is something we want. There are many valid ways to compute a hash code.\n\nThe method implements a comparison of two vectors which returns:\n• -1 if the magnitude is less than the others magnitude\n• 0 if the magnitude equals the magnitude of the other\n• 1 if the magnitude is greater than the magnitude of the other\n\nThis allows the vector type to implement the and interfaces provided by the .Net framework.\n\nAgain, can be overloaded to allow a tolerance value. Here the absolute tolerance calculation is handled by the method overload.\n\nMultiplication of vectors is tricky. There are three distinct types of vector multiplication:\n\nOnly multiplication by scalar and division by scalar have been implemented as operator overloads. I have seen operators such as overloaded for the dot product to distinguish it from cross product; I believe that this can lead to confusion and have chosen not to provide operators for dot and cross products leaving the user to call the appropriate method instead.\n\nMultiplication by scalar is achieved by multiplying each of the component parts by the scalar value.\n\nThe order of operands in multiplication can be reversed; this is known as being commutable.\n\nThe cross product of two vectors produces a normal to the plane created by the two vectors given.\n\nThe formula for this (where v1 = A and v2 = B) is\n\nThis equation always produces a vector as the result.\n\nThe sine of theta is used to account for the direction of the vector. Theta always takes the smallest angle between A and B (i.e. ).\n\nThe right hand side of the formula is arrived at by expanding and simplifying the left hand side using the rules:\n\nIn a matrix style notation this looks like:\n\nYou should be aware that this equation is non-commutable. This means that v1 cross-product v2 is NOT the same as v2 cross-product v1.\n\nThe C# code for all of this is:\n\nWhere possible I have created static methods to extend the programmer's options when making use of the type. Methods which directly affect or are effected by the instance simply call the static methods. As such the instance counterpart of the static method is:\n\nNote that this instance method does not affect the instance from which it is called but returns a new object. I have chosen to implement cross product in this fashion for two reasons; one, to make it consistent with dot product which cannot produce a vector, and two, because cross product is usually used to generate a normal used somewhere else, the original needing to be left intact.\n\n[Side note] A quick template for manually calculating the cross product of two vectors is:\n\nThe dot product of two vectors is a scalar value defined by the formula;\n\nThe equation should always produce a scalar as the result.\n\nCosine theta is used to account for the direction of the vector. Theta always takes the smallest angle between A and B (i.e. ).\n\nThe right hand side of the formula is arrived at by expanding and simplifying the left hand side using the rules:\n\nThe C# code for this is:\n\nDivision of a vector by a scalar number (e.g. 2) is achieved by dividing each of the component parts by the divisor (s2).\n\nWe now have all the basic functionality required of a type. To make this type really useful I have provided additional functionality.\n\nA unit vector has a magnitude of 1. To test if a vector is a unit vector we simply check for 1 against the magnitude method already defined.\n\nAs this is a comparison we also provide a tolerant overload.\n\nNormalization is the process of converting some vector to a unit vector. The formula for this is:\n\nThere are a number of special cases that need to be handled when implementing this formula:\n• The vector to be normalised has no magnitude.\n• The vector to be normalised is already a unit vector.\n• The vector to be normalised has one or more components (x,y,z) of NaN.\n• The vector has an infinte magnitude and components are all (+/-) infinity or (+/-) 0.\n• The vector has an infinite magnitude with real number components.\n\nMathematically you cannot normalise a vector with a magnitude of 0, however, for convenience to the programmer, many vector implementations will return a zero vector (0,0,0). Similarly, for all of the special cases listed there varying results in the implementations I have found from other libraries.\n\nThe first implementation for normalisation that I provide throws exceptions for the special cases except where a mathematically correct value can be provided, for example (infinity, 0, 0) when normalised is (1,0,0).\n\nI have also implemented an alternative method that will behave differently for exceptional conditions. will return a vector of (0,0,0) if the magnitude is 0 or vector (NaN,NaN,NaN) if any of the components are NaN.\n\nThe developer using this code should choose the correct overload for their application. The difference is that will require exception handlers but will tell the developer what the exceptional circumstance was and the method will allow execution to continue but the calling code must be able to handle the unusual results.\n\nThe absolute value of a vector is its magnitude. The method has been provided to help programmers who are not aware that the two functions are the same and provide a static interface to the magnitude operator.\n\nThis method finds the angle between two vectors using normalization and dot product.\n\n^ refers to a normalized (unit) vector.\n\n || refers to the magnitude of a Vector.\n\n \n\n Due the inherent inprecision of calculations on decimal numbers in a binary system, calculations that should produce an angle of 0 or 1 radian will often be slightly out. To illeviate this, the test for equality and Min have been added to \"snap\" results back into the correct range. Thanks to Dennis E. Cox in the comments for this solution.\n\nThis method interprets a vector as a face normal and determines whether the normal represents a back facing plane given a line-of-sight vector. A back facing plane will be invisible in a rendered scene and as such can be except from many scene calculations.\n\nIf then if\n\nIf then if\n\nThis method finds the distance between two positional vectors using Pythagoras theorem.\n\nThis method takes an interpolated value from between two vectors. This method takes three arguments, a starting point (vector v1), and end point (Vector v2), and a control which is a fraction between 1 and 0. The control determines which point between v1 and v2 is taken. A control of 0 will return v1 and a control of 1 will return v2.\n\nn = Current value\n\n n = Initial value (v1)\n\n n = Final value (v2)\n\n t = Control parameter, where , and where, ,\n\n\n\n Extrapolation, where the control value is greter than one or less than 0, is allowed but only if a flag is set. This allows vectors to be returned that sit on the immaginary line that passes through both v1 and v2 but does not have to be between the two.\n\n\n\nThese methods compare the magnitude of two vectors and return the vector with the largest or smallest magnitude respectively.\n\nThe code for this method was provided by Michał Bryłka. The method calculates the scalar triple product of three vectors. This is the volume of a parallelepiped geometric shape. More information is available on Wikipedia. This method is non-commutable.\n\nThis method checks if two vectors are perpendicular (i.e. if one vector is the normal of the other).\n\n\n\nSome of the special case logic found in the method has been extracted into a private class for this slightly different useage. This is simply for code reuse and seperation of concerns.\n\nA vector can be projected onto another using the formula:\n\nProjection is the transformation of a vector on one plane onto another. You can visualise this as shining a light from the pane of the original vector onto a card (the target plane).\n\nShown with two vectors this looks like:\n\nIn the code this is:\n\nRejection is the vector representing the change of a vector’s projection to its original value.\n\nThe formula for this is simply:\n\nIn the code this is:\n\nReflect a vector about another to provide a mirror image of the original vector.\n\nThe formula for this is:\n\nEuler rotation around axis x,y,z is performed using the methods , and .\n\nWhile these methods are unambiguous I prefer the more contextful pitch, yaw, and roll respectively.\n\nEric__ commented that he would expect a different configuration.\n\n\"... Roll, pitch and yaw refer back to the concept of an aircraft's motion.\n\n It is standard notation that X is forward (out the nose), Y is out the right wing and Z is down (toward Earth for level flight).\n\n Therefore it follows that roll is positive about +X, Pitch is positive about +Y (pitch-up means climb), and Yaw is positive around +Z (positive yaw is when the aircraft nose moves to the right).\"\n\nTo illustrate his point consider the following diagram:\n\nThis would appear to make perfect sense. It does! But only when considering the single aeroplane object. When we consider a virtual scene with multiple objects (for example a computer game or virtual reality environment), all objects must be relevant to the user perceiving them. The standard axis for a virtual scene have the user look down the Z axis.\n\nSo taking the aeroplane example, it is quite probable that we will be following the aircraft as it flies into the scene:\n\n\n\nHopefully, this explains why the axis are as described and the pitch, yaw, roll configuration is such.\n\n \n\n\n\nor rotates a vector around the X axis by a given number of radians (Euler rotation around X).\n\nThe hypotenuse (R) cancels out in the equation.\n\nor rotates a vector around the Y axis by a given number of degrees (Euler rotation around Y).\n\nThe hypotenuse (R) cancels out in the equation.\n\nor rotates a vector around the Z axis by a given number of radians (Euler rotation around Z).\n\nThe hypotenuse (R) cancels out in the equation.\n\nMethods to rotate the vector arround a specified point have been implemented. This can also be thought of as offseting the axis before rotation.\n\nThese methods round the components of a vector to:\n\nThis method changes the magnitude of a vector to a specified value without changing the direction.\n\nI have provided a number of functions which target the vectors components. These are not mathematically valid for the vector as a whole. For example, there is no concept of raising a vector to a power (that I know of) however the method can be used to raise each of x,y,z to a given power.\n\nThis method simply adds together the vector components (x, y, z).\n\nThis method multiplies the vectors components to a given power.\n\nThis method applies the square root function to each of the vectors components.\n\nThis method squares to each of the vectors components.\n\nThis method finds the sum of each of the vectors components squared.\n\nIf any of the components (x,y,z) are NaN the whole vector should be considered \"Not A Number\". This method returns true if any of the components (x,y,z) are NaN.\n\nWe have seen implementations for the .Net interfaces , , and . For completeness is also implemented. The method defined by the interface, , returns a textual description of the type has also been provided to provide a verbose textual description. can accept a numeric format string optionally proceeded by a character x, y or z which indicates the relevant vector component to describe.\n\nimplements the attribute and can therefore be written to file. I suggest the following:\n\nWhich produces an XML file containing:\n\nWe now have a type with the following public functionality:\n\nA quick comparison of some of the common features in a selection of libraries that support vectors in .Net. This article’s code execution speed appears to be somewhere in the middle of the selection.\n\nSome of the faster libraries are using floats not doubles and it should be noted that the cross product result for Math.Net is likely a misunderstanding of the library and should probably be ignored.\n\nThere were a number of resources I used during the development of this article and source code provided, I would like to acknowledge the following:\n• methods are now encapsulated in a property\n• Generic and interfaces have been implemented\n• Square components method was pointing to the square root static method\n• Added comments about meaning of comparison operations on two vectors\n• Changed the implementation of to help avoid NaN results\n• The class is now immutable, property setters have been removed and mutable methods return a new\n• Updated comments to read better under intellisense.\n• Added scale operations which used to be accessable through the magnitude mutable property\n• Changed the method to use\n• Added rotate arround x, y or z (with or without axis offsets)\n• Fixed an infinity issue in the method\n• Unit testing proved that is not the same as - Altered .Equals method to be consistent with the .Net framework\n• Added special cases where we can normalize vectors with infinite components.\n• now uses to account for special cases of infinty."
    },
    {
        "link": "https://khanacademy.org/computing/computer-programming/programming-natural-simulations/programming-vectors/a/vector-magnitude-normalization",
        "document": ""
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.windows.vector.crossproduct?view=windowsdesktop-9.0",
        "document": "Some information relates to prerelease product that may be substantially modified before it’s released. Microsoft makes no warranties, express or implied, with respect to the information provided here.\n\nThe cross product of and . The following formula is used to calculate the cross product:\n\nThe following example shows how to use this method to calculate the cross product of two Vector structures."
    }
]