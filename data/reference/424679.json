[
    {
        "link": "https://stackoverflow.com/questions/71803814/how-do-i-use-a-while-loop-when-dealing-with-an-input-that-could-raise-an-excepti",
        "document": "I'm working on code for my uni project and this one part requires the user to input a file name, and while the file name is not found, it should display a message and then prompt the user to display a valid filename. This is what I have so far but it stops after a second invalid input and I'm not sure how to use a while loop with this. If someone could help, that would be great. Thank you!"
    },
    {
        "link": "https://geeksforgeeks.org/python-while-loop",
        "document": "Python While Loop is used to execute a block of statements repeatedly until a given condition is satisfied. When the condition becomes false, the line immediately after the loop in the program is executed.\n\nIn this example, the condition for while will be True as long as the counter variable (count) is less than 3.\n\nLet’s take a look at Python While Loop in detail:\n• condition: This is a boolean expression. If it evaluates to True, the code inside the loop will execute.\n• statement(s): These are the statements that will be executed during each iteration of the loop.\n\nThe while loop will continue running the code block as long as the condition evaluates to True. Each time the loop executes, the condition is checked again. If it is True, the loop continues; if it is False, the loop terminates, and the program moves to the next statement after the loop.\n\nHere, the value of the condition is always True. Therefore, the body of the loop is run infinite times until the memory is full.\n\nLoop control statements change execution from their normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed. Python supports the following control statements.\n\nPython Continue Statement returns the control to the beginning of the loop.\n\nPython Break Statement brings control out of the loop.\n\nThe Python pass statement to write empty loops. Pass is also used for empty control statements, functions, and classes.\n\nwhile loop with else\n\nAs discussed above, while loop executes the block until a condition is satisfied. When the condition becomes false, the statement immediately after the loop is executed. The else clause is only executed when your while condition becomes false. If you break out of the loop, or if an exception is raised, it won’t be executed.\n\nNote: The else block just after for/while is executed only when the loop is NOT terminated by a break statement.\n\nHow to write while loop in Python?\n\nWhat are typical use cases for using while loops in Python?\n\nHow to control a while loop with\n\n: Exits the loop immediately, regardless of the condition. \n\n s= input(\"Enter something (or 'quit' to stop): \") \n\n\n\n\n\n : Skips the rest of the code inside the loop for the current iteration and jumps back to the beginning to re-evaluate the condition.\n\nWhat are the dangers of using a while loop in Python?\n\nHow can we use a while loop to read user input in Python?"
    },
    {
        "link": "https://geeksforgeeks.org/get-user-input-in-loop-using-python",
        "document": "In Python, for and while loops are used to iterate over a sequence of elements or to execute a block of code repeatedly. When it comes to user input, these loops can be used to prompt the user for input and process the input based on certain conditions. In this article, we will explore how to use for and while loops for user input in Python.\n\nUser Input and For Loops in Python\n\nBelow are some of the examples by which we can understand how we can use for loop for user input in Python:\n\nExample 1: Taking User Input Using for Loop\n\nIn this example, the code prompts the user for an integer input, then iteratively takes that many additional integer inputs to form a list, printing the resulting list of numbers."
    },
    {
        "link": "https://w3schools.com/python/python_while_loops.asp",
        "document": "With the while loop we can execute a set of statements as long as a condition is true.\n\nThe while loop requires relevant variables to be ready, in this example we need to define an indexing variable, i, which we set to 1.\n\nWith the break statement we can stop the loop even if the while condition is true:\n\nWith the continue statement we can stop the current iteration, and continue with the next:\n\nWith the else statement we can run a block of code once when the condition no longer is true:"
    },
    {
        "link": "https://stackoverflow.com/questions/60046771/how-to-make-a-while-loop-using-input-from-user",
        "document": "I was wondering how I could make a loop like in the example below, but using a number that the user inputted instead of a word (for example any number equal to or lower then 100 would print something different. I've looked on this website, but I couldn't understand the answers for questions similar to mine."
    },
    {
        "link": "https://geeksforgeeks.org/python-lists",
        "document": "In Python, a list is a built-in dynamic sized array (automatically grows and shrinks). We can store all types of items (including another list) in a list. A list may contain mixed type of items, this is possible because a list mainly stores references at contiguous locations and actual items maybe stored at different locations.\n• None List in Python are Mutable. Hence, we can modify, replace or delete the items.\n• None List are ordered. It maintain the order of elements based on how they are added.\n• None Accessing items in List can be done directly using their position (index), starting from 0.\n• None The list contains a mix of integers (10, 20, 40), a string (“GfG”) and a boolean (True).\n• None The list is printed and individual elements are accessed using their indexes (starting from 0).\n\nHere are some common methods to create a list:\n\nWe can also create a list by passing an iterable (like a string, tuple or another list) to list() function.\n\nWe can create a list with repeated elements using the multiplication operator.\n\nElements in a list can be accessed using indexing. Python indexes start at 0, so a[0] will access the first element, while negative indexing allows us to access elements from the end of the list. Like index -1 represents the last elements of list.\n\nWe can add elements to a list using the following methods:\n• append(): Adds an element at the end of the list.\n• extend(): Adds multiple elements to the end of the list.\n\nWe can change the value of an element by accessing it using its index.\n\nWe can remove elements from a list using:\n• remove(): Removes the first occurrence of an element.\n• pop(): Removes the element at a specific index or the last element if no index is specified.\n• del statement: Deletes an element at a specified index.\n\nWe can iterate the Lists easily by using a for loop or other iteration methods. Iterating over lists is useful when we want to do some operation on each item or access specific items based on certain conditions. Let’s take an example to iterate over the list using for loop.\n\nA nested list is a list within another list, which is useful for representing matrices or tables. We can access nested elements by chaining indexes.\n• None Minimum Swaps To Group All Ones"
    },
    {
        "link": "https://realpython.com/python-quiz-application",
        "document": "In this tutorial, you’ll build a Python quiz application for the terminal. You’ll start by developing a basic app capable of asking questions, collecting answers, and checking correctness. As you progress, you’ll enhance the app by adding features like user-friendly interfaces, storing questions in external files, handling multiple correct answers, and providing hints and explanations.\n\nBy the end of this tutorial, you’ll understand that:\n• A quiz application is a nice beginner project as it involves basic Python concepts like data structures and control flow.\n• The function helps you to interact with the user in the terminal.\n• You can structure questions and answers in data files.\n• TOML or JSON files are suitable for storing data in small games due to their readability and ease of integration with Python.\n\nThe word quiz was first used in 1781 to mean eccentric person. Nowadays, it’s mostly used to describe short tests of trivia or expert knowledge with questions like the following:\n\nBy following along in this step-by-step project, you’ll build an application that can test a person’s expertise on a range of topics. You can use this project to strengthen your own knowledge or to challenge your friends to a fun battle of wits.\n\nThe quiz application is a comprehensive project for anyone comfortable with the basics of Python. Throughout the tutorial, you’ll get all the code you need in separate, bite-size steps. You can also find the full source code of the application by clicking on the link below:\n\nWhether you’re an eccentric person or not, read on to learn how to create your own quiz.\n\nIn this step, you’ll learn how to create a program that can ask questions and check answers. This will be the foundation of your quiz application, which you’ll improve upon in the rest of the tutorial. At the end of this step, your program will look like this: Your program will be able to ask questions and check answers. This version includes the basic functionality that you need, but you’ll add more functionality in later steps. If you prefer, then you can download the source code as it’ll look when you’re done with this step by clicking the link below and entering the directory: Get Source Code: Click here to get access to the source code that you’ll use to build your quiz application. One of Python’s built-in functions is . You can use it to get information from the user. For a first example, run the following in a Python REPL: takes an optional prompt that’s displayed to the user before the user enters information. In the example above, the prompt is shown in the highlighted line, and the user enters before hitting . Whatever the user enters is returned from . This is seen in the REPL example, as the string has been assigned to . You can use to have Python ask you questions and check your answers. Try the following: \"When was the first known use of the word 'quiz'? \" When was the first known use of the word 'quiz'? 1781 This example shows one thing that you need to be aware of: always returns a text string, even if that string contains only digits. As you’ll soon see, this won’t be an issue for the quiz application. However, if you wanted to use the result of for mathematical calculations, then you’d need to convert it first. Time to start building your quiz application. Open your editor and create the file with the following content: \"When was the first known use of the word 'quiz'? \" \"The answer is '1781', not This code is very similar to what you experimented with in the REPL above. You can run your application to check your knowledge: python quiz.py When was the first known use of the word 'quiz'? 1871 The answer is '1781', not '1871' If you happen to give the wrong answer, then you’ll be gently corrected so that you’ll hopefully do better next time. Note: The before your quoted string literal inside the clause indicates that the string is a formatted string, usually called an f-string. Python evaluates expressions inside curly braces ( ) within f-strings and inserts them into the string. You can optionally add different format specifiers. For example, indicates that should be inserted based on its representation. In practice, this means that strings are shown surrounded by single quotes, like . A quiz with only one question isn’t very exciting! You can ask another question by repeating your code: \"When was the first known use of the word 'quiz'? \" \"The answer is '1781', not \"Which built-in function can get information from the user? \" \"The answer is 'input', not You’ve added a question by copying and pasting the previous code then changing the question text and the correct answer. Again, you can test this by running the script: python quiz.py When was the first known use of the word 'quiz'? 1781 Which built-in function can get information from the user? get The answer is 'input', not 'get' It works! However, copying and pasting code like this isn’t great. There’s a programming principle called Don’t Repeat Yourself (DRY), which says that you should usually avoid repeated code because it gets hard to maintain. Next, you’ll start improving your code to make it easier to work with. Use Lists and Tuples to Avoid Repetitive Code Python provides several flexible and powerful data structures. You can usually replace repeated code with a tuple, a list, or a dictionary in combination with a loop or a loop. Instead of repeating code, you’ll treat your questions and answers as data and move them into a data structure that your code can loop over. The immediate—and often challenging—question then becomes how you should structure your data. There’s never one uniquely perfect data structure. You’ll usually choose between several alternatives. Throughout this tutorial, you’ll revisit your choice of data structure several times as your application grows.\n• Each question element will be a two-tuple consisting of the question text and the answer. You can then store your questions as follows: \"When was the first known use of the word 'quiz'\" \"Which built-in function can get information from the user\" This fits nicely with how you want to use your data. You’ll loop over each question, and for each question, you want access to both the question and answer. Change your file so that you store your questions and answers in the data structure: \"When was the first known use of the word 'quiz'\" \"Which built-in function can get information from the user\" \"Which keyword do you use to loop over a given list of elements\" When you run this code, it shouldn’t look any different from how it did earlier. In fact, you haven’t added any new functionality. Instead, you’ve refactored your code so that it’ll be easier to add more questions to your application. In the previous version of your code, you needed to add five new lines of code for each question that you added. Now, the loop takes care of running those five lines for each question. To add a new question, you only need to add one line spelling out the question and the corresponding answer. Note: You’re learning about quizzes in this tutorial, so questions and answers are important. Each code example will introduce a new question. To keep the code listings in this tutorial at a manageable size, some of the older questions may be removed. However, feel free to keep all questions in your code, or to even replace these with your own questions and answers. The questions you’ll see in the examples are related to the tutorial, even though you won’t find all the answers in the text. Feel free to search online if you’re curious about more details about a question or an answer. Next, you’ll make your quiz application easier to use by adding answer alternatives for each question. Using is a great way to read input from your user. However, the way you’re currently using it can end up being frustrating. For example, someone may answer one of your questions like this: Which built-in function can get information from the user? input() The answer is 'input', not 'input()' Should they really be marked wrong because they included the parentheses to indicate that the function is callable? You can take away a lot of guesswork for the users by giving them alternatives. For example: Which built-in function can get information from the user? input Here, the alternatives show that you expect the answer to be entered without parentheses. In the example, the alternatives are listed before the question. This is a bit counterintuitive, but it’s easier to implement into your current code. You’ll improve this in the next step. In order to implement answer alternatives, you need your data structure to be able to record three pieces of information for each question: It’s time to revisit for the first—but not the last—time and make some changes to it. It makes sense to store the answer alternatives in a list, as there can be any number of them and you just want to display them to the screen. Furthermore, you can treat the correct answer as one of the answer alternatives and include it in the list, as long as you’re able to retrieve it later. You decide to change to a dictionary where the keys are your questions and the values are the lists of answer alternatives. You consistently put the correct answer as the first item in the list of alternatives so that you can identify it. Note: You could continue to use a list of two-tuples to hold your questions. In fact, you’re only iterating over the questions and answers, not looking up the answers by using a question as a key. Therefore, you could argue that the list of tuples is a better data structure for your use case than a dictionary. However, you use a dictionary because it looks better visually in your code, and the roles of questions and answer alternatives are more distinct. You update your code to loop over each item in your newly minted dictionary. For each question, you pick out the correct answer from the alternatives, and you print out all the alternatives before asking the question: \"When was the first known use of the word 'quiz'\" \"Which built-in function can get information from the user\" \"Which keyword do you use to loop over a given list of elements\" \"What's the purpose of the built-in zip() function\" \"To iterate over two or more sequences at the same time\" \"To combine several strings into one\" \"To compress several files into one archive\" \"To get information from the user\" If you always showed the correct answer as the first alternative, then your users would soon catch on and be able to guess the correct answer every time. Instead, you change the order of the alternatives by sorting them. Test your application: python quiz.py When was the first known use of the word 'quiz'? 1781 - To combine several strings into one - To compress several files into one archive - To get information from the user - To iterate over two or more sequences at the same time What's the purpose of the built-in zip() function? To itertate over two or more sequences at the same time The answer is 'To iterate over two or more sequences at the same time', not 'To itertate over two or more sequences at the same time' The last question reveals another experience that can be frustrating for the user. In this example, they’ve chosen the correct alternative. However, as they were typing it, a typo snuck in. Can you make your application more forgiving? You know that the user will answer with one of the alternatives, so you just need a way for them to communicate which alternative they choose. You can add a label to each alternative and only ask the user to enter the label. Update the application to use to print the index of each answer alternative: \"Which keyword do you use to loop over a given list of elements\" \"What's the purpose of the built-in zip() function\" \"To iterate over two or more sequences at the same time\" \"To combine several strings into one\" \"To compress several files into one archive\" \"To get information from the user\" \"What's the name of Python's sorting algorithm\" You store the reordered alternatives as so that you can look up the full answer based on the answer label that the user enters. Recall that always returns a string, so you need to convert it to an integer before you treat it as a list index. Now, it’s more convenient to answer the questions: python quiz.py Which keyword do you use to loop over a given list of elements? 2 The answer is 'for', not 'loop' 0) To combine several strings into one 1) To compress several files into one archive 2) To get information from the user 3) To iterate over two or more sequences at the same time What's the purpose of the built-in zip() function? 3 What's the name of Python's sorting algorithm? 3 Great! You’ve created quite a capable quiz application! In the next step, you won’t add any more functionality. Instead, you’ll make your application more user-friendly.\n\nIn this second step, you’ll improve on your quiz application to make it easier to use. In particular, you’ll improve the following:\n• How the application looks and feels\n• How you summarize the user’s results\n• What happens if your user enters a nonexistent alternative\n• Which order you present the questions and alternatives in At the end of this step, your application will work as follows: Your program will still work similarly to now, but it’ll be more robust and attractive. You can find the source code as it’ll look at the end of this step in the directory by clicking below: Get Source Code: Click here to get access to the source code that you’ll use to build your quiz application. Look back at how your quiz application is currently presented. It’s not very attractive. There are no blank lines that tell you where a new question starts, and the alternatives are listed above the question, which is a bit confusing. Furthermore, the numbering of the different choices start at instead of , which would be more natural. In your next update to , you’ll number the questions themselves and present the question text above the answer alternatives. Additionally, you’ll use lowercase letters instead of numbers to identify answers: \"What's the purpose of the built-in zip() function\" \"To iterate over two or more sequences at the same time\" \"To combine several strings into one\" \"To compress several files into one archive\" \"To get information from the user\" \"What's the name of Python's sorting algorithm\" \"What does dict.get(key) return if key isn't found in dict\" You use to get letters that label your answer alternatives. You combine letters and alternatives with and store them in a dictionary as follows: You use these labeled alternatives when you display the options to the user and when you look up the user’s answer based on the label that they entered. Note the use of the special escape string . This is interpreted as a newline and adds a blank line on the screen. This is a simple way to add some organization to your output: python quiz.py What's the purpose of the built-in zip() function? a) To combine several strings into one b) To compress several files into one archive c) To get information from the user d) To iterate over two or more sequences at the same time What's the name of Python's sorting algorithm? The answer is 'Timsort', not 'Quicksort' Your output is still mostly monochrome in the terminal, but it’s more visually pleasing, and it’s easier to read. Now that you’re numbering the questions, it would also be nice to keep track of how many questions the user answers correctly. You can add a variable, , to take care of this: \"What does dict.get(key) return if key isn't found in dict\" \"How do you iterate over both indices and elements in an iterable\" You increase for each correct answer. The loop variable already counts the total number of questions, so you can use that to report the user’s result. So far, you haven’t worried too much about what happens if the user enters an answer that’s not valid. In the different versions of your app, this oversight could result in the program raising an error or—less dramatically—registering a user’s invalid answer as wrong. You can handle user errors in a better way by allowing the user to re-enter their answer when they enter something invalid. One way to do this is to wrap in a loop: The condition does a few things at once. It uses an assigment expression ( ), often called the walrus operator, to store the user input as and compare it to the string . The while loop will run until you type at the prompt. See The Walrus Operator: Python 3.8 Assignment Expressions for more examples. Note: If you’re using an older version of Python than 3.8, then the assignment expression will cause a syntax error. You can rewrite the code to avoid using the walrus operator. There’s a version of the quiz application that runs on Python 3.7 in the source code that you downloaded earlier. In your quiz application, you use a similar construct to loop until the user gives a valid answer: \"How do you iterate over both indices and elements in an iterable\" \"What's the official name of the := operator\" If you enter an invalid choice at the prompt, then you’ll be reminded about your valid choices: python quiz.py How do you iterate over both indices and elements in an iterable? Please answer one of a, b, c, d Note that once the loops exits, you’re guaranteed that is one of the keys in , so it’s safe to look up directly. Next, you’ll add one more improvement by injecting some randomness into your quiz. Currently, when you run your quiz application, you’re always asking the questions in the same order as they’re listed in your source code. Additionally, the answer alternatives for a given question also come in a fixed order that never changes. You can add some variety to your quiz by changing things up a little. You can randomize both the order of the questions and the order of the answer alternatives for each question: \"What's the official name of the := operator\" \"The random numbers are more random.\" \"The first random number is always 42.\" You use to randomize the order of your questions and the order of the answer alternatives. Usually, picks out a few random samples from a collection. However, if you ask for as many samples as there are items in the sequence, then you’re effectively randomly reordering the whole sequence: Additionally, you cap the number of questions in the quiz to which is initially set to five. If you include more than five questions in your application, then this also adds some variety as to which questions get asked in addition to the order in which they’re asked. Note: You can also use to shuffle your questions and alternatives. The difference is that reorders sequences in place, which means that it changes your underlying data structure. creates new lists of questions and alternatives, instead. In your current code, using wouldn’t be a problem because is reset every time you run your quiz application. It could become a problem down the line, for example if you implement the possibility of asking the same question several times. Your code is usually simpler to reason about if you don’t change or mutate your underlying data structure. Throughout this step, you’ve improved on your quiz application. It’s now time to take a step back and consider the code itself. In the next section, you’ll reorganize the code so that you keep it modular and ready for further development.\n\nIn this step, you’ll refactor your code. Refactoring means that you’ll change your code, but your application’s behavior and your user’s experience will stay as they are. This may not sound very exciting, but it’ll be tremendously useful down the line, as good refactorings make it more convenient to maintain and expand your code. Note: If you’d like to see two Real Python team members work through refactoring some code, then check out Refactoring: Prepare Your Code to Get Help. You’ll also learn how to ask clear, concise programming questions. Currently, your code isn’t particularly organized. All your statements are fairly low level. You’ll define functions to improve your code. A few of their advantages are the following:\n• Functions name higher-level operations that can help you get an overview of your code. To see how the code will look after you’ve refactored it, click below and check out the folder: Get Source Code: Click here to get access to the source code that you’ll use to build your quiz application. In your quiz application, you first read the available questions, then you ask each of the questions, before finally reporting the final score. If you look back at your current code, then you’ll see these three steps in the code. But the organization is still a bit hidden within all the details. You can make the main functionality clearer by encapsulating it in a function. You don’t need to update your file yet, but note that you can translate the previous paragraph into code that looks like this: This code won’t run as it is. The functions and haven’t been defined, and there are some other details missing. Still, encapsulates the functionality of your application at a high level. Writing down your application flow at a high level like this can be a great start to uncover which functions are natural building blocks in your code. In the rest of this section, you’ll fill in the missing details: You’re now going to make quite substantial changes to the code of your quiz application as you’re refactoring it to use functions. Before doing so, it’s a good idea to make sure you can revert to the current state, which you know works. You can do this either by saving a copy of your code with a different filename or by making a commit if you’re using a version control system. Once you’ve safely stored your current code, start with a new that only contains your imports and global variables. You can copy these from your previous version: \"The random numbers are more random.\" \"The first random number is always 42.\" \"When does __name__ == '__main__' equal True in a Python file\" \"When the file is run as a script\" \"When the file is imported as a module\" \"When the file has a valid name\" \"When the file only has one function\" Remember that you’re only reorganizing your code. You’re not adding new functionality, so you won’t need to import any new libraries. Next, you’ll implement the necessary preprocessing. In this case, this means that you’ll prepare the data structure so that it’s ready to be used in your main loop. For now, you’ll potentially limit the number of questions and make sure they’re listed in a random order: Note that deals with general and parameters. Afterward, you’ll pass in your specific and as arguments. This means that you don’t depend on global variables in your function. With this decoupling, your function is more general, and you can later more readily replace the source of your questions. Look back on your sketch for the function and remember that it contains your main loop. For each question, you’ll call . Your next task is to implement that helper function. Think about what needs to do:\n• Pick out the correct answer from the list of alternatives\n• Print the question to the screen\n• Print all alternatives to the screen\n• Get the answer from the user\n• Check that the user’s answer is valid\n• Check whether the user answered correctly or not\n• Add to the count of correct answers if the answer is correct These are a lot of small things to do in one function, and you could consider whether there’s potential for further modularization. For example, items 3 to 6 in the list above are all about interacting with the user, and you can pull them into yet another helper function. To achieve this modularization, add the following helper function to your source code: This function accepts a question text and a list of alternatives. You then use the same techniques as earlier to label the alternatives and ask the user to enter a valid label. Finally, you return the user’s answer. Using simplifies your implementation of , as you no longer need to handle the user interaction. You can do something like the following: You first randomly reorder the answer alternatives using , as you did earlier. Next, you call , which handles all details about getting an answer from the user. You can therefore finish up by checking the correctness of the answer. Observe that you return or , which indicates to the calling function whether the answer was correct or not. Note: You could replace the return values with Booleans. Instead of , you could return , and instead of , you could return . This would work because Python treats Booleans as integers in calculations: In some cases, your code reads more naturally when you use and . In this case, you’re counting correct answers, so it seems more intuitive to use numbers. You’re now ready to implement properly. One thing you’ve learned while implementing and is which arguments you need to pass on: As earlier, you use to keep a counter that numbers the questions you ask. You can increment based on the return value of . Observe that is your only function that directly interacts with and . Your refactoring is now complete, except for one thing. If you run now, then it’ll seem like nothing happens. In fact, Python will read your global variables and define your functions. However, you’re not calling any of those functions. You therefore need to add a function call that starts your application: You call at the end of , outside of any function. It’s good practice to protect such a call to your main function with the name-main idiom. This special incantation is a Python convention that means that is called when you run as a script, but it’s not called when you import as a module. That’s it! You’ve refactored your code into several functions. This will help you in keeping track of the functionality of your application. It’ll also be useful in this tutorial, as you can consider changes to individual functions instead of changing the whole script. For the rest of the tutorial, you’ll see your full code listed in collapsible boxes like the one below. Expand these to see the current state and get an overview of your full application: The full source code of your quiz application is listed below: \"When was the first known use of the word 'quiz'\" \"Which built-in function can get information from the user\" \"Which keyword do you use to loop over a given list of elements\" \"What's the purpose of the built-in zip() function\" \"To iterate over two or more sequences at the same time\" \"To combine several strings into one\" \"To compress several files into one archive\" \"To get information from the user\" \"What's the name of Python's sorting algorithm\" \"What does dict.get(key) return if key isn't found in dict\" \"How do you iterate over both indices and elements in an iterable\" \"What's the official name of the := operator\" \"The random numbers are more random.\" \"The first random number is always 42.\" \"When does __name__ == '__main__' equal True in a Python file\" \"When the file is run as a script\" \"When the file is imported as a module\" \"When the file has a valid name\" \"When the file only has one function\" Through this step, you’ve refactored your code to make it more convenient to work with. You separated your commands into well-organized functions that you can continue to develop. In the next step, you’ll take advantage of this by improving how you read questions into your application.\n\nStep 4: Separate Data Into Its Own File You’ll continue your refactoring journey in this step. Your focus will now be how you provide questions to your application. So far, you’ve stored the questions directly in your source code in the data structure. It’s usually better to separate your data from your code. This separation can make your code more readable, but more importantly, you can take advantage of systems designed for handling data if it’s not hidden inside your code. In this section, you’ll learn how to store your questions in a separate data file formatted according to the TOML standard. Other options—that you won’t cover in this tutorial—are storing the questions in a different file format like JSON or YAML, or storing them in a database, either a traditional relational one or a NoSQL database. To peek at how you’ll improve your code in this step, click below and go to the directory: Get Source Code: Click here to get access to the source code that you’ll use to build your quiz application. TOML is branded as “a config file format for humans” (Source). It’s designed to be readable by humans and uncomplicated to parse by computers. Information is represented in key-value pairs that can be mapped to a hash table data structure, like a Python dictionary. TOML supports several data types, including strings, integers, floating-point numbers, Booleans, and dates. Additionally, data can be structured in arrays and tables, which are similar to Python’s lists and dictionaries, respectively. TOML has been gaining popularity over the last years, and the format is stable after version 1.0.0 of the format specification was released in January 2021. Create a new text file that you’ll call , and add the following content: \"When does __name__ == '__main__' equal True in a Python file\" \"When the file is run as a script\" \"When the file is imported as a module\" \"When the file has a valid name\" \"When the file only has one function\" \"Which version of Python is the first with TOML support built in\" While there are differences between TOML syntax and Python syntax, you’ll recognize elements like using quotation marks ( ) for text and square brackets ( ) for lists of elements. To work with TOML files in Python, you need a library that parses them. In this tutorial, you’ll use . This will be the only package you use in this project that’s not part of Python’s standard library. Note: TOML support is added to Python’s standard library in Python 3.11. If you’re already using Python 3.11, then you can skip the instructions below to create a virtual environment and install . Instead, you can immediately start coding by replacing any mentions of in your code with the compatible . Later in this section, you’ll learn how to write code that can use if it’s available and fall back to if necessary. Before installing , you should create and activate a virtual environment: You can then install with : You can check that you have available by parsing , which you created earlier. Open up your Python REPL and test the following code: {\"When does __name__ == '__main__' equal True in a Python file\": ['When the file is run as a script', 'When the file is imported as a module', 'When the file has a valid name', 'When the file only has one function'], 'Which version of Python is the first with TOML support built-in': First, observe that is a regular Python dictionary that has the same form as your data structure that you’ve been using so far. You can use to parse TOML information in two different ways. In the example above, you use to read TOML from an open file handle. Alternatively, you could use to read TOML from a text string. Note: You need to open files in binary mode by using before passing them to . This is so that can make sure that the UTF-8 encoding of the TOML file is correctly handled. If you use , then the string you pass in will be interpreted as UTF-8. You can integrate the TOML file into your quiz application by updating the preamble of your code, where you do your imports and define the global variables: Instead of doing a plain like you did earlier, you wrap your import in a … statement that first tries to import . If that fails, then you import but rename it to . The effect of this is that you’ll use the Python 3.11 if it’s available and fall back to if it’s not. You’re using to handle the path to . Instead of hard-coding the path to you rely on the special variable. In practice, you’re stating that it’s located in the same directory as your file. Finally, you use to read the TOML file as a text string and then to parse that string into a dictionary. As you saw in the previous example, loading the TOML file results in the same data structure as you previously had for your questions. Once you’ve made the changes to , your quiz application should still function the same, although the questions are defined in the TOML file instead of in your source code. Go ahead and add a few more questions to your TOML file to confirm that it’s being used. You’ve moved your question data out of your source code and into a dedicated data file format. One advantage of TOML over a regular Python dictionary is that you can add some more structure to your data while keeping it fairly readable and maintainable. One notable feature of TOML is tables. These are named sections that map to nested dictionaries in Python. Furthermore, you can use arrays of tables, which are represented by lists of dictionaries in Python. You can take advantage of these to be more explicit when defining your questions. Consider the following TOML snippet: \"Which version of Python is the first with TOML support built in\" Regular tables start with a single-bracketed line like . You indicate an array of tables by using double brackets, like above. You can parse the TOML with : question = \"Which version of Python is the first with TOML support built in\" 'question': 'Which version of Python is the first with TOML support built in', This results in a nested data structure, with an outer dictionary in which the key points to a list of dictionaries. The inner dictionaries have the , , and keys. This structure is a bit more complicated than what you’ve used so far. However, it’s also more explicit, and you don’t need to rely on conventions such as the first answer alternative representing the correct answer. You’ll now convert your quiz application so that it takes advantage of this new data structure for your questions. First, reformat your questions in . You should format them as follows: \"Which version of Python is the first with TOML support built in\" \"What's the name of the list-like data structure in TOML\" Each question is stored inside an individual table with key-value pairs for the question text, the correct answer, and the answer alternatives. Principally, you’ll need to make two changes to your application source code to use the new format:\n• Read questions from the inner list.\n• Use the inner question dictionaries when asking questions. These changes touch on your main data structure, so they require several small code changes throughout your code. First, change how you read the questions from the TOML file: You change to do the reading of the TOML file and pick out the list. Additionally, you can simplify the main loop in since all information about a question is contained in a dictionary. You don’t keep track of the question text and alternatives separately. This latter point requires some changes in as well: You now pick out the question text, the correct answer, and the answer alternatives explicitly from the new dictionary. One nice thing with this is that it’s more readable than the earlier convention of assuming the first answer alternative to be the correct answer. You don’t need to make any changes in , because that function already dealt with question text and lists of alternatives in general. That hasn’t changed. You can find the current, full source code of your application inside the collapsed sections below: The full data file is reproduced below: \"When was the first known use of the word 'quiz'\" \"Which built-in function can get information from the user\" \"What's the purpose of the built-in zip() function\" \"To iterate over two or more sequences at the same time\" \"To combine several strings into one\" \"To compress several files into one archive\" \"To get information from the user\" \"What does dict.get(key) return if key isn't found in dict\" \"How do you iterate over both indices and elements in an iterable\" \"What's the official name of the := operator\" \"The random numbers are more random.\" \"The first random number is always 42.\" \"When does __name__ == '__main__' equal True in a Python file\" \"When the file is run as a script\" \"When the file is imported as a module\" \"When the file has a valid name\" \"When the file only has one function\" \"Which version of Python is the first with TOML support built in\" \"What's the name of the list-like data structure in TOML\" Save this file in the same folder as . The full source code of your quiz application is listed below: Your new flexible format for defining questions gives you some options in adding more functionality to your quiz application. You’ll dive into some of these in the next step.\n\nIn this fifth step, you’ll add more functionality to your quiz application. Finally, the refactoring you’ve done in the previous steps will pay off! You’ll add the following features:\n• Hints that can point toward the correct answer\n• Explanations that can act as teaching moments At the end of this step, your application will work as follows: These new features provide a more interesting experience to anyone challenging themselves through your quiz application. You can see how the source code of your application will look when you’re done with this step by clicking below and moving into the directory: Get Source Code: Click here to get access to the source code that you’ll use to build your quiz application. Some questions may have multiple correct answers, and it’ll be great if your quiz can handle those as well. In this section, you’ll add support for multiple correct answers. First, you need to consider how you can represent several correct answers in your data file. One advantage of the more explicit data structure that you introduced in the previous step is that you can use an array to specify the correct answers as well. Replace each key in your TOML file with an key that wraps each correct answer within square brackets ( ). Your questions file will then look something like the following: \"What's the name of the list-like data structure in TOML\" \"How can you run a Python script named quiz.py\" For old questions with only one correct answer, there will be only one answer listed in the array. The last question above shows an example of a question with two correct answer alternatives. Once your data structure is updated, you’ll need to implement the feature in your code as well. You don’t need to make any changes in or . In you need to check that all correct answers are given, while in , you need to be able to read multiple answers from the user. Start with the latter challenge. How can the user enter multiple answers, and how can you validate that each one is valid? One possibility is to enter multiple answers as a comma-separated string. You can then convert the string to a list as follows: You could use to split directly on commas. However, first replacing commas with spaces and then splitting on the default whitespace adds some leniency with spaces allowed around the commas. This will be a better experience for your users, as they can write , , or even without commas, and your program should interpret it as intended. The test for valid answers becomes a bit more complicated, though. You therefore replace the tight loop with a more flexible one. In order to loop until you get a valid answer, you initiate an infinite loop that you return out of once all tests are satisfied. Rename to and update it as follows: Before looking too closely at the details in the code, take the function for a test run: 'e' is not a valid choice. Please use a, b, c, d Your function first checks that the answer includes the appropriate number of choices. Then each one is checked to make sure it’s a valid choice. If any of these checks fail, then a helpful message is printed to the user. In the code, you also make some effort to handle the distinction between one and several items when it comes to grammar. You use to modify text strings to include plural s when needed. Additionally, you convert the answers to a set to quickly ignore duplicate alternatives. An answer string like is interpreted as . Finally, note that returns a list of strings instead of the plain string returned by . Next, you adapt to the possibility of multiple correct answers. Since already handles most of the complications, what’s left is to check all answers instead of only one. Recall that is a dictionary with all information about a question, so you don’t need to pass any longer. Because the order of the answers is irrelevant, you use when comparing the given answers to the correct ones: You only score a point for the user if they find all the correct answers. Otherwise, you list all correct answers. You can now run your Python quiz application again: python quiz.py How can you run a Python script named quiz.py? What's the name of the list-like data structure in TOML? 'e' is not a valid choice. Please use a, b, c, d You got 1 correct out of 2 questions Allowing multiple correct answers gives you more flexibility in which kinds of questions you can ask in your quizzes. Add Hints to Help the User Sometimes when you’re asked a question, you need a bit of help to jog your memory. Giving the users the option of seeing a hint can make your quizzes more fun. In this section, you’ll extend your application to include hints. You can include hints in your data file, for example by adding as an optional key-value pair: \"How can you run a Python script named quiz.py\" \"One option uses the filename, and the other uses the module name.\" \"PEPs are used to evolve Python.\" Each question in the TOML file is represented by a dictionary in Python. The new fields show up as new keys in those dictionaries. One effect of this is that you don’t need to change how you read the question data, even when you make small changes to your data structure. Instead, you adapt your code to take advantage of the new optional field. In you only need to make one small change: You use instead of because not all questions come with hints. If one of the dictionaries doesn’t define as a key, then returns , which is then passed into . Again, you’ll make bigger changes to . You’ll add the hint as one of the answer alternatives, with a special question mark ( ) label: If a hint is provided, then it’s added to the end of . The user can then use to see the hint printed to the screen. If you test your quiz application, then you’ll now get a bit of friendly help: python quiz.py HINT: PEPs are used to evolve Python. In the next section, you’ll add a similar feature. In addition to showing an optional hint before the user answers a question, you’ll show an explanation after they’ve answered it. You can implement explanations similarly to how you implemented hints in the previous section. First, you’ll add an optional field in your data file. Then, in your application, you’ll show the explanation after the user has answered a question. \"PEPs are used to evolve Python.\" information to the Python community. PEPs are used to propose new features for the Python language, to collect community input on an issue, and to \"How can you add a docstring to a function\" \"By writing a string literal as the first statement in the function\" \"By assigning a string to the function's .__doc__ attribute\" \"By using the built-in @docstring decorator\" \"By returning a string from the function\" \"They're parsed from your code and stored on the function object.\" Docstrings document functions and other Python objects. A docstring is a string literal that occurs as the first statement in a module, function, class, or method definition. Such a docstring becomes the .__doc__ special attribute of that object. See PEP 257 for more information. There is no built-in @docstring decorator. Many functions naturally return strings. Such a feature can therefore not be used for docstrings. TOML supports multiline strings by using triple quotes ( ) in the same way as Python. These are great for explanations that may span a few sentences. The explanations will be printed to the screen after the user has answered a question. In other words, the explanations aren’t part of the user interaction done in . Instead, you’ll print them inside : Because you print the explanation after giving the user feedback on whether their answer was correct or not, you can’t return inside the … block any longer. You therefore move the statement to the end of the function. Your explanations look something like the following when you run your quiz application: python quiz.py How can you add a docstring to a function? a) By returning a string from the function b) By assigning a string to the function's .__doc__ attribute c) By writing a string literal as the first statement in the function d) By using the built-in @docstring decorator - By writing a string literal as the first statement in the function - By assigning a string to the function's .__doc__ attribute Docstrings document functions and other Python objects. A docstring is a string literal that occurs as the first statement in a module, function, class, or method definition. Such a docstring becomes the .__doc__ special attribute of that object. See PEP 257 for more information. There is no built-in @docstring decorator. Many functions naturally return strings. Such a feature can therefore not be used for docstrings. The improvements to your Python quiz application add up. Feel free to expand the collapsed sections below to see the full source code with all your new features: The full data file is reproduced below: \"When was the first known use of the word 'quiz'\" \"Which built-in function can get information from the user\" \"What's the purpose of the built-in zip() function\" \"To iterate over two or more sequences at the same time\" \"To combine several strings into one\" \"To compress several files into one archive\" \"To get information from the user\" \"What does dict.get(key) return if key isn't found in dict\" \"How do you iterate over both indices and elements in an iterable\" \"What's the official name of the := operator\" \"The random numbers are more random.\" \"The first random number is always 42.\" \"When does __name__ == '__main__' equal True in a Python file\" \"When the file is run as a script\" \"When the file is imported as a module\" \"When the file has a valid name\" \"When the file only has one function\" \"Which version of Python is the first with TOML support built in\" \"What's the name of the list-like data structure in TOML\" \"How can you run a Python script named quiz.py\" \"One option uses the filename, and the other uses the module name.\" \"PEPs are used to evolve Python.\" information to the Python community. PEPs are used to propose new features for the Python language, to collect community input on an issue, and to \"How can you add a docstring to a function\" \"By writing a string literal as the first statement in the function\" \"By assigning a string to the function's .__doc__ attribute\" \"By using the built-in @docstring decorator\" \"By returning a string from the function\" \"They are parsed from your code and stored on the function object.\" Docstrings document functions and other Python objects. A docstring is a string literal that occurs as the first statement in a module, function, class, or method definition. Such a docstring becomes the .__doc__ special attribute of that object. See PEP 257 for more information. There is no built-in @docstring decorator. Many functions naturally return strings. Such a feature can therefore not be used for docstrings. Save this file in the same folder as . The full source code of your quiz application is listed below: In the final step, you’ll add one more feature: support for several quiz topics within your application.\n\nIn this section, you’ll make one final improvement that will make your Python quiz application more fun, varied, and interesting. You’ll add the option of grouping questions into different topics and letting your users pick which topic they’ll be quizzed about. The final version of your Python quiz application will look as follows: More topics and new questions will keep your quiz application fresh. Click below and navigate to the directory to see how the source code will look after you’ve added these: Get Source Code: Click here to get access to the source code that you’ll use to build your quiz application. Sections in TOML files can be nested. You create nested tables by adding periods ( ) in the section headers. As an illustrative example, consider the following TOML document: Here, the section header is represented as nested within . Similarly, keys with periods are also interpreted as nested dictionaries, as evidenced by in this example. You can reorganize to include a section for each topic. In addition to the nested arrays, you’ll add a key that provides a name for each topic. Update your data file to use the following format: \"How can you add a docstring to a function\" \"By writing a string literal as the first statement in the function\" \"By assigning a string to the function's .__doc__ attribute\" \"By using the built-in @docstring decorator\" \"By returning a string from the function\" \"They're parsed from your code and stored on the function object.\" Docstrings document functions and other Python objects. A docstring is a string literal that occurs as the first statement in a module, function, class, or method definition. Such a docstring becomes the .__doc__ special attribute of that object. See PEP 257 for more information. There's no built-in @docstring decorator. Many functions naturally return strings. Such a feature can therefore not be used for docstrings. \"When was the first public version of Python released?\" \"The first public version was labeled version 0.9.0.\" Guido van Rossum started work on Python in December 1989. He posted Python v0.9.0 to the alt.sources newsgroup in February 1991. Python reached version 1.0.0 in January 1994. The next major versions, Python 2.0 and Python 3.0, were released in October 2000 and December Oslo was founded as a city in the 11th century and established as a trading place. It became the capital of Norway in 1299. The city was destroyed by a fire in 1624 and rebuilt as Christiania, named in honor of the reigning king. The city was renamed back to Oslo in 1925. \"SciPy is held there each year.\" Austin is named in honor of Stephen F. Austin. It was purpose-built to be the capital of Texas and was incorporated in December 1839. Houston, Harrisburg, Columbia, and Galveston are all earlier capitals of Texas. Now, there are two topics included in the data file: Python and Capitals. Within each topic section, the question tables are still structured the same as before. This means that the only change you need to make is how you prepare the questions. You start by reading and parsing . Next, you pick out each topic and store it in a new, temporary dictionary. You need to ask the user about which topic they’d like to try. Luckily, you can reuse to get input about this. Finally, you pick out the questions belonging to the chosen topic and shuffle them up: \"Which topic do you want to be quizzed about\" The data structure returned by is still the same as before, so you don’t need to make any changes to , , or . When these kinds of updates only require you to edit one or a few functions, that’s a good sign indicating that your code is well-structured, with good abstractions. Run your Python quiz application. You’ll be greeted by the new topic prompt: python quiz.py Which topic do you want to be quizzed about? Oslo was founded as a city in the 11th century and established as a trading place. It became the capital of Norway in 1299. The city was destroyed by a fire in 1624 and rebuilt as Christiania, named in honor of the reigning king. The city was renamed back to Oslo in 1925. This ends the guided part of this journey. You’ve created a powerful Python quiz application in the terminal. You can see the complete source code as well as a list of questions by expanding the boxes below: The full data file is reproduced below: \"When was the first known use of the word 'quiz'\" \"Which built-in function can get information from the user\" \"What's the purpose of the built-in zip() function\" \"To iterate over two or more sequences at the same time\" \"To combine several strings into one\" \"To compress several files into one archive\" \"To get information from the user\" \"What does dict.get(key) return if key isn't found in dict\" \"How do you iterate over both indices and elements in an iterable\" \"What's the official name of the := operator\" \"The random numbers are more random.\" \"The first random number is always 42.\" \"Which version of Python is the first with TOML support built in\" \"How can you run a Python script named quiz.py\" \"One option uses the filename, and the other uses the module name.\" \"What's the name of the list-like data structure in TOML\" \"PEPs are used to evolve Python.\" information to the Python community. PEPs are used to propose new features for the Python language, to collect community input on an issue, and to \"How can you add a docstring to a function\" \"By writing a string literal as the first statement in the function\" \"By assigning a string to the function's .__doc__ attribute\" \"By using the built-in @docstring decorator\" \"By returning a string from the function\" \"They are parsed from your code and stored on the function object.\" Docstrings document functions and other Python objects. A docstring is a string literal that occurs as the first statement in a module, function, class, or method definition. Such a docstring becomes the .__doc__ special attribute of that object. See PEP 257 for more information. There's no built-in @docstring decorator. Many functions naturally return strings. Such a feature can therefore not be used for docstrings. \"When was the first public version of Python released\" \"The first public version was labeled version 0.9.0.\" Guido van Rossum started work on Python in December 1989. He posted Python v0.9.0 to the alt.sources newsgroup in February 1991. Python reached version 1.0.0 in January 1994. The next major versions, Python 2.0 and Python 3.0, were released in October 2000 and December Oslo was founded as a city in the 11th century and established as a trading place. It became the capital of Norway in 1299. The city was destroyed by a fire in 1624 and rebuilt as Christiania, named in honor of the reigning king. The city was renamed back to Oslo in 1925. \"SciPy is held there each year.\" Austin is named in honor of Stephen F. Austin. It was purpose-built to be the capital of Texas and was incorporated in December 1839. Houston, Harrisburg, Columbia, and Galveston are all earlier capitals of Texas. Save this file in the same folder as . The full source code of your quiz application is listed here: \"Which topic do you want to be quizzed about\" You can also access the source code and the questions file by clicking below: Get Source Code: Click here to get access to the source code that you’ll use to build your quiz application. You’ll find the final version of the application in the directory ."
    },
    {
        "link": "https://h2kinfosys.com/blog/understanding-python-list-index-with-example",
        "document": "Python is one of the most in-demand programming languages in today’s technology-driven world. From data science to web development, Python is everywhere. One of its most powerful and commonly used features is lists. Lists allow developers to store and manipulate ordered data efficiently. In this blog, we will dive deep into Understanding Python list index with clear explanations and practical examples. If you’re aspiring to boost your Python skills or pursue a Python certification course, this guide will be your perfect companion.\n\nA list is perhaps the most frequently used inbuilt data structure in Python. It is a container that is used to store a collection of data. The data could be of different data types. Be it strings, integers, booleans, Nonetype, floats, etc. The data are encapsulated in square brackets ([]), and each element (or item) is separated by a comma (,).\n\nThe elements in a list are accessed through indexing. The index can be seen as a pointer to the actual data. The indexes of elements in a list are numbers from 0 to the list’s length. It is important to emphasize that the indexing begins from 0 and not one. This means that the first element has an index of 0. Following that pattern, the last element has an index of n-1 where n is the number of elements in the list.\n\nSeveral functions or methods are used to carry out different operations to a list. You can add a new element to a list, remove an element from a list, sort a list, loop over a list, add a list to a list (nested lists), and many more. This tutorial will focus on one of those methods, an important one. And that’s the index() function. We will go a step further to see other methods of getting the index of a list.\n\nBy the end of this tutorial, you will learn.\n• How to use the index() function\n• How to use for loops to find list indexes\n• How to use list comprehensions\n• How to use while loops to find list indexes\n• How to use NumPy to find the indexes in a list\n\nLet’s jump right into it.\n\nUnderstanding Python list structures and their indexing is critical for solving real-world problems efficiently. Python, as one of the most versatile programming languages, leverages lists and their indices to access, manage, and manipulate data seamlessly. Below are some practical applications of Python list indexing across various domains:\n• Data Analysis:\n• Extract specific data points from datasets stored in lists.In data analysis, datasets are often stored in lists or list-like structures. Understanding Python list indexing helps extract specific data points or subsets of data quickly and efficiently. For instance, you can retrieve rows or individual values from a dataset to perform further analysis or computations.\n• Web Scraping:\n• Access and organize scraped data using list indexing.Python is widely used for web scraping due to its robust libraries like BeautifulSoup and Scrapy. After extracting data from a website, the scraped information is often stored in lists. Understanding Python list indices enables you to organize and access specific data points effectively.\n• Game Development:\n• Manage player scores or game elements efficiently using list indices.In game development, Python lists and their indices play a key role in managing dynamic elements like player scores, game levels, and inventory items. Understanding how to work with Python list indices allows you to track and modify these elements seamlessly.\n• Machine Learning:\n• Handle training datasets and split data into training and testing sets.Machine learning workflows often involve handling large datasets. Understanding Python list indexing is essential for splitting data into training and testing sets or selecting specific features for analysis. Python lists make this process intuitive and efficient.\n\nThe index() method is used to find the index of a list. There are several other methods to return the list index, but the easiest is the index() method. It takes the element whose index you want to be returned. If that element appears more than once in the list, the index() function returns the first copy of that element’s index. Let’s see its syntax.\n\nThe start and end arguments are optional. As explained earlier, python begins indexing from 0 and according to its documentation, stops at 9223372036854775807. You can modify how you want the Python interpreter to start and stop its indexing by defining the start and end argument.\n\nPassing an element that is not on the list.\n\nIf the element passed in the index() method is not on the list for some reason, the python interpreter returns a Value Error. We can try it out. Obviously, ‘Toby’ is not on the list. Let’s see what happens if we pass it as an argument.\n\nThe Value Error was returned as expected.\n\nFinding the index of an element using for loop\n\nWhile using the index method may be the easiest way to return the index of a list, other methods are available. We can also use a for loop to traverse the elements in a list and return their index. The index is captured by calling the range() function on the len() function. Let’s take a coding example.\n\nFinding the index of an element that appears more than once\n\nWith for loops, if an element appears more than once, you can return the index of each element. Recall that when using the index() method, it returns only the first copy of the element in the event that it appears more than once in the list. Let’s see an example.\n\nFinding the index of a list using List comprehension\n\nList comprehension provides a shorter alternative to writing for loops and appending results to a list. Hence, the previous section’s example can be reproduced using for loops. See the code below.\n\nUsing While Loops to return Indexes of elements appearing more than once.\n\nWhile loops can as well be used to return the index of an element that appears more than once. They are used along with the index() method to achieve this. While loops are generally longer than for loops. See the coding example below.\n\nUsing the Enumerate Function to get the index of a list.\n\nThe enumerate function is another method of returning the index of elements in a list. The enumerate function, when called, returns a list of tuples that contains the index and element of the list.\n\nFor example, if a list contains say [‘Felix’, ‘Vijay’, ‘Tom’,’Felix’, ‘Felix’, ‘Anna’, ‘Ola’, ‘Wu’] calling he enumerate function returns [(0, ‘Felix’), (1, ‘Vijay’), (2, ‘Tom’), (3, ‘Felix’), (4, ‘Felix’), (5, ‘Anna’), (6, ‘Ola’), (7, ‘Wu’)]\n\nNow let us see how to use the enumerate function to return the index of a specific element in a list.\n\nUsing NumPy to get the index of an element in a list\n\nNumpy is a popular Python library used for numerical computation. You can also use the NumPy library to find the index of an element in a library. First off, you have to make sure you have NumPy running on your machine. To do so, type\n\nOn your command prompt and wait for it to download all its requirements. Once it’s done, you can try to import it to check if it was installed correctly. To import numpy, just type\n\nIf the above code runs without any errors, it means that it has run successfully. To use lists in NumPy, you need to convert the list into a NumPy array. After using the where() method to return the index of the element where a condition is satisfied. In our case, the condition would be where the element in the list is Felix. See the coding example below.\n\nIn summary, you have seen the different methods to access the elements in a list. Here are some vital takeaway\n• The index() method returns the index of the first element that matches the argument passes. It is the quickest and easiest method.\n• In cases where the argument passed is not an element in the list, the python interpreter throws a ValueError\n• You can use for and while loops to find the index of elements in a list.\n• You can use list comprehensions to make for loops shorter\n• You can use the enumerate function\n• You can use the numpy.where() function to return the index of the list’s element.\n• Indexing starts from 0 and supports negative values for reverse access.\n• List slicing allows you to access multiple elements efficiently.\n\nUnderstanding Python list index is fundamental for every Python programmer. Whether you’re slicing, accessing, or modifying elements, list indexing enables efficient data handling and precise control over your data structures. For beginners, mastering indexing opens up pathways to writing cleaner, more efficient code, while for professionals, it acts as a foundation for advanced concepts like list comprehensions, data manipulation, and algorithm development.\n\nWhen working on real-world projects, the ability to access, slice, and modify lists ensures that you can manage large data efficiently. Whether it’s organizing data in a web application, processing information in machine learning models, or building powerful automation scripts, Python lists remain a crucial tool.\n\nBy mastering list indexing, you will be well-equipped to handle practical programming tasks, making your code more readable and maintainable. The skills you gain here are directly applicable to Python-related careers, including data science, software engineering, and automation testing.\n\nIf you are ready to take your Python knowledge to the next level, H2K Infosys Python certification course is designed to provide in-depth, hands-on training. Enroll today to gain industry-relevant skills, work on real-world projects, and advance your career with confidence!"
    },
    {
        "link": "https://medium.com/@cssjhnnamae/use-cases-of-list-data-structures-in-python-ec2e538db830",
        "document": "An article that focuses with the use cases of list data structures in Python\n\nLists are one of the most versatile data structures in Python, acting like a flexible container that can hold multiple elements. Whether you’re packing for an adventure or managing data in an application, lists allow you to store, modify, and access data efficiently. This guide explores the fundamentals of lists, including their capabilities, how to iterate through them, and practical examples of their real-world applications, such as storing user input, managing shopping carts, and processing data.\n\nWhat is a list in Python?\n\nThink of packing for a big adventure. You have a backpack with different compartments for your items — some for clothes, some for snacks, and maybe a special pocket for your favorite treasures. In Python, a list is like that backpack. It’s a flexible container that holds different pieces of information called “elements.” These elements can be numbers, words, or even other lists. Just like you can rearrange or remove things from your backpack, you can also change the elements in a Python list. Lists can store various types of data and come with useful methods like adding, removing, and looping through items. Overall, Python lists are flexible and practical tools for organizing and managing data effectively.\n\nIn Python, sequences are a fundamental way to store and organize data. A sequence is an ordered collection of items, where each item has a specific position, or index, that allows you to access and manipulate it easily. The most commonly used sequence types in Python include lists, tuples, and strings.\n\nLists: Lists are the most flexible sequence type in Python. They can store items of different data types such as numbers, strings, or even other lists. Lists are mutable, meaning you can modify them by adding, removing, or changing elements.\n\nTuples: Tuples are similar to lists but are immutable, meaning that once you create a tuple, its contents cannot be changed. They are often used when you need a sequence of items that should remain constant throughout your program.\n\nStrings: Strings are sequences of characters and are also immutable. You can access individual characters of a string using indexing, but you cannot change the characters directly.\n\nIterating over a list of lists is a common task in Python, especially when dealing with datasets or matrices. In this article, we will explore various methods and techniques for efficiently iterating over nested lists, covering both basic and advanced Python concepts. In this article, we will see how we can iterate over a list of lists in Python.\n\nIn this example, a list named `list_of_lists` is created, containing nested lists. Using nested for loops, each element in the inner lists is iterated over, and the `print` statement displays the elements horizontally within each sublist, with each sublist on a new line.\n\nlist_of_lists = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nfor sublist in list_of_lists:\n\n for item in sublist:\n\n print(item, end=’ ‘)\n\n print()\n\nIn this example, a nested list named `nested_list` is created. List comprehension is used to flatten the nested structure into a single list named `flattened_list`. The resulting flattened list is then printed, showcasing a concise and powerful approach to list manipulation.\n\nnested_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nflattened_list = [item for sublist in nested_list for item in sublist]\n\nprint(flattened_list)\n\nIn data structures, stack and queue are part of linear data structure.\n\nStack follows the principle of LIFO (Last in First out) i.e. element which is inserted at last will be removed first. The operation for insertion of elements in stack is known as Push operation and the operation for deletion of element in stack is known as Pop operation.\n\nA stack follows the Last In, First Out (LIFO) principle.\n\nQueue follows the principle of FIFO (First in First out) i.e. element which is inserted first will be removed first. The operation for insertion of elements is known as enqueue operation and the operation for deletion of elements is known as dequeue operation.\n\nA queue follows the First In, First Out (FIFO) principle.\n\nReal-world examples where Python developers commonly use lists to solve problems.\n\nLists can capture multiple user responses in applications like surveys or quizzes. Each input is appended to a list, allowing easy collection and retrieval.\n\nIn e-commerce applications, lists are used to manage items a user wants to purchase. Users can add or remove items dynamically.\n\nLists are used to hold data for processing, such as sorting or searching algorithms. They provide a way to manipulate datasets effectively.\n\nIn summary, Python lists are essential tools for any developer, allowing for the efficient storage and manipulation of collections of data. Their versatility enables the implementation of a variety of real-world applications, from user input handling to e-commerce and algorithmic processing. By leveraging lists effectively, you can enhance your programs’ functionality and performance. Understanding how to utilize lists, along with their associated methods, equips you with the skills to tackle diverse programming challenges with confidence. As you continue your Python journey, mastering lists will be a crucial step in developing efficient and organized code."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/understanding-lists-in-python-3",
        "document": "A list is a data structure in Python that is a mutable, or changeable, ordered sequence of elements. Each element or value that is inside of a list is called an item. Just as strings are defined as characters between quotes, lists are defined by having values between square brackets .\n\nLists are great to use when you want to work with many related values. They enable you to keep data together that belongs together, condense your code, and perform the same methods and operations on multiple values at once.\n\nWhen thinking about Python lists and other data structures that are types of collections, it is useful to consider all the different collections you have on your computer: your assortment of files, your song playlists, your browser bookmarks, your emails, the collection of videos you can access on a streaming service, and more.\n\nYou should have Python 3 installed and a programming environment set up on your computer or server. If you don’t have a programming environment set up, you can refer to the installation and setup guides for a local programming environment or for a programming environment on your server appropriate for your operating system (Ubuntu, CentOS, Debian, etc.)\n\nTo get started, let’s create a list that contains items of the string data type:\n\nWhen we print out the list, the output responds exactly like the list we created:\n\nAs an ordered sequence of elements, each item in a list can be called individually, through indexing. Lists are a compound data type made up of smaller parts, and are very flexible because they can have values added, removed, and changed. When you need to store a lot of values or iterate over values, and you want to be able to readily modify those values, you’ll likely want to work with list data types.\n\nIn this tutorial, we’ll go through some of the ways that we can work with lists in Python.\n\nEach item in a list corresponds to an index number, which is an integer value, starting with the index number .\n\nFor the list , the index breakdown looks like this:\n\nThe first item, the string starts at index , and the list ends at index with the item .\n\nBecause each item in a Python list has a corresponding index number, we’re able to access and manipulate lists in the same ways we can with other sequential data types.\n\nNow we can call a discrete item of the list by referring to its index number:\n\nThe index numbers for this list range from - , as shown in the table above. So to call any of the items individually, we would refer to the index numbers like this:\n\nIf we call the list with an index number of any that is greater than 4, it will be out of range as it will not be valid:\n\nIn addition to positive index numbers, we can also access items from the list with a negative index number, by counting backwards from the end of the list, starting at . This is especially useful if we have a long list and we want to pinpoint an item towards the end of a list.\n\nFor the same list , the negative index breakdown looks like this:\n\nSo, if we would like to print out the item by using its negative index number, we can do so like this:\n\nWe can concatenate string items in a list with other strings using the operator:\n\nWe were able to concatenate the string item at index number with the string . We can also use the operator to concatenate 2 or more lists together.\n\nWith index numbers that correspond to items within a list, we’re able to access each item of a list discretely and work with those items.\n\nWe can use indexing to change items within the list, by setting an index number equal to a different value. This gives us greater control over lists as we are able to modify and update the items that they contain.\n\nIf we want to change the string value of the item at index from to , we can do so like this:\n\nNow when we print , the list will be different:\n\nWe can also change the value of an item by using a negative index number instead:\n\nNow has replaced at the negative index number of (which corresponds to the positive index number of ).\n\nBeing able to modify items in lists gives us the ability to change and update lists in an efficient way.\n\nWe can also call out a few items from the list. Let’s say we would like to only print the middle items of , we can do so by creating a slice. With slices, we can call multiple values by creating a range of index numbers separated by a colon :\n\nWhen creating a slice, as in , the first index number is where the slice starts (inclusive), and the second index number is where the slice ends (exclusive), which is why in our example above the items at position, , , and are the items that print out.\n\nIf we want to include either end of the list, we can omit one of the numbers in the syntax. For example, if we want to print the first 3 items of the list — which would be , , — we can do so by typing:\n\nThis printed the beginning of the list, stopping right before index .\n\nTo include all the items at the end of a list, we would reverse the syntax:\n\nWe can also use negative index numbers when slicing lists, similar to positive index numbers:\n\nOne last parameter that we can use with slicing is called stride, which refers to how many items to move forward after the first item is retrieved from the list. So far, we have omitted the stride parameter, and Python defaults to the stride of 1, so that every item between two index numbers is retrieved.\n\nThe syntax for this construction is , with referring to stride. Let’s make a larger list, then slice it, and give the stride a value of 2:\n\nOur construction prints the values between index numbers inclusive of and exclusive of , then the stride value of tells the program to print out only every other item.\n\nWe can omit the first two parameters and use stride alone as a parameter with the syntax :\n\nBy printing out the list with the stride set to , only every third item is printed:\n\nSlicing lists with both positive and negative index numbers and indicating stride provides us with the control to manipulate lists and receive the output we’re trying to achieve.\n\nOperators can be used to make modifications to lists. We’ll review using the and operators and their compound forms and .\n\nThe operator can be used to concatenate two or more lists together:\n\nBecause the operator can concatenate, it can be used to add an item (or several) in list form to the end of another list. Remember to place the item in square brackets:\n\nThe operator can be used to multiply lists. Perhaps you need to make copies of all the files in a directory onto a server, or share a playlist with friends — in these cases you would need to multiply collections of data.\n\nLet’s multiply the list by 2 and the list by 3:\n\nBy using the operator we can replicate our lists by the number of times we specify.\n\nWe can also use compound forms of the and operators with the assignment operator . The and compound operators can be used to populate lists in a quick and automated way. You can use these operators to fill in lists with placeholders that you can modify at a later time with user-provided input, for example.\n\nLet’s add an item in list form to the list . This item will act as a placeholder, and we’d like to add this placeholder item several times. To do this, we’ll use the operator with a for loop.\n\nFor each iteration of the for loop, an extra list item of is added to the original list .\n\nThe operator behaves in a similar way:\n\nThe operators and can be used to concatenate lists and multiply lists. The compound operators and can concatenate lists and multiply lists and pass the new identity to the original list.\n\nItems can be removed from lists by using the statement. This will delete the value at the index number you specify within a list.\n\nFrom the list, let’s remove the item . This item is located at the index position of . To remove the item, we’ll use the statement then call the list variable and the index number of that item:\n\nNow the item at index position , the string , is no longer in our list .\n\nWe can also specify a range with the statement. Say we wanted to remove not only the item , but also and as well. We can call a range in with the statement to accomplish this:\n\nBy using a range with the statement, we were able to remove the items between the index number of (inclusive), and the index number of (exclusive), leaving us with a list of 3 items following the removal of 3 items.\n\nThe statement allows us to remove specific items from the list data type.\n\nLists can be defined with items that are made up of lists, with each bracketed list enclosed inside the larger brackets of the parent list:\n\nThese lists within lists are called nested lists.\n\nTo access an item within this list, we will have to use multiple indices:\n\nThe first list, since it is equal to an item, will have the index number of 0, which will be the first number in the construction, and the second list will have the index number of 1. Within each inner nested list there will be separate index numbers, which we will call in the second index number:\n\nWhen working with lists of lists, it is important to keep in mind that you’ll need to refer to more than one index number in order to access specific items within the relevant nested list.\n\nThe list data type is a flexible data type that can be modified throughout the course of your program. This tutorial covered the basic features of lists, including indexing, slicing, modifying, and concatenating lists.\n\nFrom here, you can find out more about working with lists in Python by reading “How To Use List Methods,” and about list comprehensions to create lists based on existing lists. To learn more about data types in general you can read our “Understanding Data Types” tutorial."
    }
]