[
    {
        "link": "https://docs.python.org/3/library/string.html",
        "document": "A string containing all ASCII characters that are considered whitespace. This includes the characters space, tab, linefeed, return, formfeed, and vertical tab.\n\nBy design, string.printable.isprintable() returns False . In particular, string.printable is not printable in the POSIX sense (see LC_CTYPE ).\n\nString of ASCII characters which are considered printable by Python. This is a combination of digits , ascii_letters , punctuation , and whitespace .\n\nString of ASCII characters which are considered punctuation characters in the C locale: !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~ .\n\nThe uppercase letters 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' . This value is not locale-dependent and will not change.\n\nThe lowercase letters 'abcdefghijklmnopqrstuvwxyz' . This value is not locale-dependent and will not change.\n\nThe concatenation of the ascii_lowercase and ascii_uppercase constants described below. This value is not locale-dependent.\n\nConverts the value (returned by get_field() ) given a conversion type (as in the tuple returned by the parse() method). The default version understands ‘s’ (str), ‘r’ (repr) and ‘a’ (ascii) conversion types.\n\nformat_field() simply calls the global format() built-in. The method is provided so that subclasses can override it.\n\nImplement checking for unused arguments if desired. The arguments to this function is the set of all argument keys that were actually referred to in the format string (integers for positional arguments, and strings for named arguments), and a reference to the args and kwargs that was passed to vformat. The set of unused args can be calculated from these parameters. check_unused_args() is assumed to raise an exception if the check fails.\n\nIf the index or keyword refers to an item that does not exist, then an IndexError or KeyError should be raised.\n\nSo for example, the field expression ‘0.name’ would cause get_value() to be called with a key argument of 0. The name attribute will be looked up after get_value() returns by calling the built-in getattr() function.\n\nFor compound field names, these functions are only called for the first component of the field name; subsequent components are handled through normal attribute and indexing operations.\n\nThe args parameter is set to the list of positional arguments to vformat() , and the kwargs parameter is set to the dictionary of keyword arguments.\n\nRetrieve a given field value. The key argument will be either an integer or a string. If it is an integer, it represents the index of the positional argument in args; if it is a string, then it represents a named argument in kwargs.\n\nGiven field_name as returned by parse() (see above), convert it to an object to be formatted. Returns a tuple (obj, used_key). The default version takes strings of the form defined in PEP 3101 , such as “0[name]” or “label.title”. args and kwargs are as passed in to vformat() . The return value used_key has the same meaning as the key parameter to get_value() .\n\nThe values in the tuple conceptually represent a span of literal text followed by a single replacement field. If there is no literal text (which can happen if two replacement fields occur consecutively), then literal_text will be a zero-length string. If there is no replacement field, then the values of field_name, format_spec and conversion will be None .\n\nLoop over the format_string and return an iterable of tuples (literal_text, field_name, format_spec, conversion). This is used by vformat() to break the string into either literal text, or replacement fields.\n\nIn addition, the Formatter defines a number of methods that are intended to be replaced by subclasses:\n\nThis function does the actual work of formatting. It is exposed as a separate function for cases where you want to pass in a predefined dictionary of arguments, rather than unpacking and repacking the dictionary as individual arguments using the *args and **kwargs syntax. vformat() does the work of breaking up the format string into character data and replacement fields. It calls the various methods described below.\n\nThe primary API method. It takes a format string and an arbitrary set of positional and keyword arguments. It is just a wrapper that calls vformat() .\n\nThe built-in string class provides the ability to do complex variable substitutions and value formatting via the format() method described in PEP 3101 . The Formatter class in the string module allows you to create and customize your own string formatting behaviors using the same implementation as the built-in format() method.\n\nThe method and the class share the same syntax for format strings (although in the case of , subclasses can define their own format string syntax). The syntax is related to that of formatted string literals, but it is less sophisticated and, in particular, does not support arbitrary expressions.\n\nFormat strings contain “replacement fields” surrounded by curly braces . Anything that is not contained in braces is considered literal text, which is copied unchanged to the output. If you need to include a brace character in the literal text, it can be escaped by doubling: and .\n\nThe grammar for a replacement field is as follows:\n\nIn less formal terms, the replacement field can start with a field_name that specifies the object whose value is to be formatted and inserted into the output instead of the replacement field. The field_name is optionally followed by a conversion field, which is preceded by an exclamation point , and a format_spec, which is preceded by a colon . These specify a non-default format for the replacement value.\n\nSee also the Format Specification Mini-Language section.\n\nThe field_name itself begins with an arg_name that is either a number or a keyword. If it’s a number, it refers to a positional argument, and if it’s a keyword, it refers to a named keyword argument. An arg_name is treated as a number if a call to on the string would return true. If the numerical arg_names in a format string are 0, 1, 2, … in sequence, they can all be omitted (not just some) and the numbers 0, 1, 2, … will be automatically inserted in that order. Because arg_name is not quote-delimited, it is not possible to specify arbitrary dictionary keys (e.g., the strings or ) within a format string. The arg_name can be followed by any number of index or attribute expressions. An expression of the form selects the named attribute using , while an expression of the form does an index lookup using .\n\nThe conversion field causes a type coercion before formatting. Normally, the job of formatting a value is done by the method of the value itself. However, in some cases it is desirable to force a type to be formatted as a string, overriding its own definition of formatting. By converting the value to a string before calling , the normal formatting logic is bypassed.\n\nThree conversion flags are currently supported: which calls on the value, which calls and which calls .\n\nThe format_spec field contains a specification of how the value should be presented, including such details as field width, alignment, padding, decimal precision and so on. Each value type can define its own “formatting mini-language” or interpretation of the format_spec.\n\nMost built-in types support a common formatting mini-language, which is described in the next section.\n\nA format_spec field can also include nested replacement fields within it. These nested replacement fields may contain a field name, conversion flag and format specification, but deeper nesting is not allowed. The replacement fields within the format_spec are substituted before the format_spec string is interpreted. This allows the formatting of a value to be dynamically specified.\n\nSee the Format examples section for some examples.\n\n“Format specifications” are used within replacement fields contained within a format string to define how individual values are presented (see Format String Syntax and f-strings). They can also be passed directly to the built-in function. Each formattable type may define how the format specification is to be interpreted. Most built-in types implement the following options for format specifications, although some of the formatting options are only supported by the numeric types. A general convention is that an empty format specification produces the same result as if you had called on the value. A non-empty format specification typically modifies the result. The general form of a standard format specifier is: If a valid align value is specified, it can be preceded by a fill character that can be any character and defaults to a space if omitted. It is not possible to use a literal curly brace (” ” or “ ”) as the fill character in a formatted string literal or when using the method. However, it is possible to insert a curly brace with a nested replacement field. This limitation doesn’t affect the function. The meaning of the various alignment options is as follows: Forces the field to be left-aligned within the available space (this is the default for most objects). Forces the field to be right-aligned within the available space (this is the default for numbers). Forces the padding to be placed after the sign (if any) but before the digits. This is used for printing fields in the form ‘+000000120’. This alignment option is only valid for numeric types, excluding . It becomes the default for numbers when ‘0’ immediately precedes the field width. Forces the field to be centered within the available space. Note that unless a minimum field width is defined, the field width will always be the same size as the data to fill it, so that the alignment option has no meaning in this case. The sign option is only valid for number types, and can be one of the following: indicates that a sign should be used for both positive as well as negative numbers. indicates that a sign should be used only for negative numbers (this is the default behavior). indicates that a leading space should be used on positive numbers, and a minus sign on negative numbers. The option coerces negative zero floating-point values to positive zero after rounding to the format precision. This option is only valid for floating-point presentation types. Changed in version 3.11: Added the option (see also PEP 682). The option causes the “alternate form” to be used for the conversion. The alternate form is defined differently for different types. This option is only valid for integer, float and complex types. For integers, when binary, octal, or hexadecimal output is used, this option adds the respective prefix , , , or to the output value. For float and complex the alternate form causes the result of the conversion to always contain a decimal-point character, even if no digits follow it. Normally, a decimal-point character appears in the result of these conversions only if a digit follows it. In addition, for and conversions, trailing zeros are not removed from the result. The option signals the use of a comma for a thousands separator for floating-point presentation types and for integer presentation type . For other presentation types, this option is an error. For a locale aware separator, use the integer presentation type instead. Changed in version 3.1: Added the option (see also PEP 378). The option signals the use of an underscore for a thousands separator for floating-point presentation types and for integer presentation type . For integer presentation types , , , and , underscores will be inserted every 4 digits. For other presentation types, specifying this option is an error. Changed in version 3.6: Added the option (see also PEP 515). width is a decimal integer defining the minimum total field width, including any prefixes, separators, and other formatting characters. If not specified, then the field width will be determined by the content. When no explicit alignment is given, preceding the width field by a zero ( ) character enables sign-aware zero-padding for numeric types, excluding . This is equivalent to a fill character of with an alignment type of . Changed in version 3.10: Preceding the width field by no longer affects the default alignment for strings. The precision is a decimal integer indicating how many digits should be displayed after the decimal point for presentation types and , or before and after the decimal point for presentation types or . For string presentation types the field indicates the maximum field size - in other words, how many characters will be used from the field content. The precision is not allowed for integer presentation types. Finally, the type determines how the data should be presented. The available string presentation types are: String format. This is the default type for strings and may be omitted. The available integer presentation types are: Character. Converts the integer to the corresponding unicode character before printing. Hex format. Outputs the number in base 16, using lower-case letters for the digits above 9. Hex format. Outputs the number in base 16, using upper-case letters for the digits above 9. In case is specified, the prefix will be upper-cased to as well. Number. This is the same as , except that it uses the current locale setting to insert the appropriate number separator characters. In addition to the above presentation types, integers can be formatted with the floating-point presentation types listed below (except and ). When doing so, is used to convert the integer to a floating-point number before formatting. The available presentation types for and values are: Scientific notation. For a given precision , formats the number in scientific notation with the letter ‘e’ separating the coefficient from the exponent. The coefficient has one digit before and digits after the decimal point, for a total of significant digits. With no precision given, uses a precision of digits after the decimal point for , and shows all coefficient digits for . If , the decimal point is omitted unless the option is used. Scientific notation. Same as except it uses an upper case ‘E’ as the separator character. Fixed-point notation. For a given precision , formats the number as a decimal number with exactly digits following the decimal point. With no precision given, uses a precision of digits after the decimal point for , and uses a precision large enough to show all coefficient digits for . If , the decimal point is omitted unless the option is used. Fixed-point notation. Same as , but converts to and to . General format. For a given precision , this rounds the number to significant digits and then formats the result in either fixed-point format or in scientific notation, depending on its magnitude. A precision of is treated as equivalent to a precision of . The precise rules are as follows: suppose that the result formatted with presentation type and precision would have exponent . Then, if , where is -4 for floats and -6 for , the number is formatted with presentation type and precision . Otherwise, the number is formatted with presentation type and precision . In both cases insignificant trailing zeros are removed from the significand, and the decimal point is also removed if there are no remaining digits following it, unless the option is used. With no precision given, uses a precision of significant digits for . For , the coefficient of the result is formed from the coefficient digits of the value; scientific notation is used for values smaller than in absolute value and values where the place value of the least significant digit is larger than 1, and fixed-point notation is used otherwise. Positive and negative infinity, positive and negative zero, and nans, are formatted as , , , and respectively, regardless of the precision. General format. Same as except switches to if the number gets too large. The representations of infinity and NaN are uppercased, too. Number. This is the same as , except that it uses the current locale setting to insert the appropriate number separator characters. Percentage. Multiplies the number by 100 and displays in fixed ( ) format, followed by a percent sign. For this is like the type, except that when fixed-point notation is used to format the result, it always includes at least one digit past the decimal point, and switches to the scientific notation when . When the precision is not specified, the latter will be as large as needed to represent the given value faithfully. For , this is the same as either or depending on the value of for the current decimal context. The overall effect is to match the output of as altered by the other format modifiers. The result should be correctly rounded to a given precision of digits after the decimal point. The rounding mode for matches that of the builtin. For , the rounding mode of the current context will be used. The available presentation types for are the same as those for ( is not allowed). Both the real and imaginary components of a complex number are formatted as floating-point numbers, according to the specified presentation type. They are separated by the mandatory sign of the imaginary part, the latter being terminated by a suffix. If the presentation type is missing, the result will match the output of (complex numbers with a non-zero real part are also surrounded by parentheses), possibly altered by other format modifiers.\n\nThis section contains examples of the syntax and comparison with the old -formatting. In most of the cases the syntax is similar to the old -formatting, with the addition of the and with used instead of . For example, can be translated to . The new format syntax also supports new and different options, shown in the following examples. is formed from the real part 'The complex number (3-5j) is formed from the real part 3.0 and the imaginary part -5.0.' Aligning the text and specifying a width: Replacing , , and and specifying a sign: # show only the minus -- same as '{:f}; {:f}' Replacing and and converting the value to different bases: # with 0x, 0o, or 0b as prefix: Using the comma as a thousands separator:"
    },
    {
        "link": "https://geeksforgeeks.org/python-string-module",
        "document": "The Python module provides a wide range of functions and constants related to string manipulation. It makes our life easy when working with Python Strings. Whether we're building a text-processing application, working with patterns, or cleaning up data, the module simplifies many common string operations.\n\nIn this article, we’ll cover all major concepts of the module, discuss its constants and functions, and demonstrate real-world use cases.\n\nThe module is part of Python’s standard library and is specifically designed for common string operations. It provides constants representing commonly used sets of characters (like lowercase and uppercase letters, digits, and punctuation) as well as utility functions like for manipulating strings.\n\nThe module is useful for:\n\nWe can import the module by:\n\nLet’s dive into the constants and functions it offers.\n\nThe module provides several constants that represent predefined sets of characters. These constants are useful for validating, cleaning, or manipulating strings.\n\nis a concatenation of all ASCII lowercase and uppercase letters:\n\ncontains all decimal digits from 0 to 9:\n\ncontains all characters used in hexadecimal numbers (0-9 and A-F):\n\ncontains all characters used in octal numbers (0-7):\n\ncontains all characters that are considered punctuation marks:\n\ncontains all characters that are printable, including digits, letters, punctuation, and whitespace:\n\ncontains all characters that are considered whitespace (spaces, tabs, newlines, etc.):\n\nWe can use to check if a string contains only whitespace characters:\n\nApart from constants, the module provides several useful functions for string manipulation.\n\nThe function capitalizes the first letter of every word in a string and lowers the rest of the letters. It also replaces multiple spaces between words with a single space.\n\nWe can use to format user input or generate titles for articles, books, etc.\n\nprovides an extensible way to create custom string formatting. It works behind the scenes in Python’s method but can be customized to fit our needs.\n\nIf we need special formatting rules beyond what provides, we can use to define our own logic.\n\nThe class allows us to create string templates where placeholders can be replaced by values. It's useful for situations where we need simple string substitution.\n\nThe class also offers safe substitution ( ) which will not raise an exception if a placeholder is missing:\n\nWe can use for creating email templates where placeholders like or are replaced with actual values.\n\nReal-World Use Cases of the Python String Module\n\nLet's now see some real world use cases which can help in our next Python Project.\n\nThe constants in the module make it easy to validate user input. For example, to check if a string consists only of digits:\n\nUsing , we can create custom formatting logic. For example, we could create a function that converts numbers into custom-formatted text:\n\nIf we're working with data files (like logs) and need to extract specific pieces of information, can simplify this process:\n\nSuppose, we are working on a project, and we need to verify the file name uploaded by a user to prevent any potential issue.\n\nHere, we are forcing that the filename must not contain any punctuations.\n\nThe module in Python is a powerful toolkit that simplifies working with strings. It provides constants for common character sets, functions for capitalization and formatting, and tools for creating templates. These features can help us handle various real-world problems, such as validating user input, formatting data, parsing text files, validate file name, etc.\n\nBy understanding and using the module effectively, we can streamline our text-processing tasks and write more efficient and readable code."
    },
    {
        "link": "https://docs.python.org/3/library/curses.ascii.html",
        "document": "The module supplies name constants for ASCII characters and functions to test membership in various ASCII character classes. The constants supplied are names for control characters as follows:\n\nNote that many of these have little practical significance in modern usage. The mnemonics derive from teleprinter conventions that predate digital computers.\n\nThe module supplies the following functions, patterned on those in the standard C library:\n\nThese functions accept either integers or single-character strings; when the argument is a string, it is first converted using the built-in function .\n\nNote that all these functions check ordinal bit values derived from the character of the string you pass in; they do not actually know anything about the host machine’s character encoding.\n\nThe following two functions take either a single-character string or integer byte value; they return a value of the same type.\n\nThe following function takes either a single-character string or integer value; it returns a string."
    },
    {
        "link": "https://w3schools.com/python/python_ref_string.asp",
        "document": "Python has a set of built-in methods that you can use on strings.\n\nLearn more about strings in our Python Strings Tutorial."
    },
    {
        "link": "https://geeksforgeeks.org/python-string-ascii_letters",
        "document": "constant in Python is part of the module and is a predefined string that contains all the lowercase and uppercase ASCII letters. It includes:\n\nIt is equivalent to the concatenation of string.ascii_lowercase and string.ascii_uppercase.\n• None It contains all lowercase (‘a’ to ‘z’) and uppercase (‘A’ to ‘Z’) ASCII characters in sequence.\n• None This constant does not take any parameters as it is predefined in the\n• None Returns a string containing all ASCII alphabetic characters, both lowercase and uppercase.\n\nIf we want to validate whether all characters in a string are ASCII letters. Here’s how we can achieve this using the constant:\n• None contains digits (‘123’), which are not part of\n• None since not all characters are ASCII letters.\n\nSometimes, we need to generate a random string of alphabetic characters for tasks like creating random identifiers. Using , this becomes straightforward:\n• None method combines these characters into a single string, resulting in a random string of alphabetic characters.\n\nWe may want to count how many ASCII letters are present in a given string. This is a common task when analyzing text data:\n• None The generator expression iterates over each character in the string\n• None For each character that is in , the count is incremented, resulting in the total count of ASCII letters.\n\nExample 4: Separating letters from other characters\n\nConsider a situation where we need to extract only the alphabetic characters from a mixed string. simplifies this task:\n• None The generator expression filters out characters not in\n• None method combines the filtered characters into a new string containing only letters.\n\n1. How does differ from and ?\n\n2. Can we use to check for non-ASCII letters?\n\n4. How can we use in list comprehensions?"
    },
    {
        "link": "https://docs.python.org/3/library/random.html",
        "document": "This module implements pseudo-random number generators for various distributions.\n\nFor integers, there is uniform selection from a range. For sequences, there is uniform selection of a random element, a function to generate a random permutation of a list in-place, and a function for random sampling without replacement.\n\nOn the real line, there are functions to compute uniform, normal (Gaussian), lognormal, negative exponential, gamma, and beta distributions. For generating distributions of angles, the von Mises distribution is available.\n\nAlmost all module functions depend on the basic function , which generates a random float uniformly in the half-open range . Python uses the Mersenne Twister as the core generator. It produces 53-bit precision floats and has a period of 2**19937-1. The underlying implementation in C is both fast and threadsafe. The Mersenne Twister is one of the most extensively tested random number generators in existence. However, being completely deterministic, it is not suitable for all purposes, and is completely unsuitable for cryptographic purposes.\n\nThe functions supplied by this module are actually bound methods of a hidden instance of the class. You can instantiate your own instances of to get generators that don’t share state.\n\nClass can also be subclassed if you want to use a different basic generator of your own devising: see the documentation on that class for more details.\n\nThe module also provides the class which uses the system function to generate random numbers from sources provided by the operating system.\n\nReturn a random element from the non-empty sequence seq. If seq is empty, raises . Return a k sized list of elements chosen from the population with replacement. If the population is empty, raises . If a weights sequence is specified, selections are made according to the relative weights. Alternatively, if a cum_weights sequence is given, the selections are made according to the cumulative weights (perhaps computed using ). For example, the relative weights are equivalent to the cumulative weights . Internally, the relative weights are converted to cumulative weights before making selections, so supplying the cumulative weights saves work. If neither weights nor cum_weights are specified, selections are made with equal probability. If a weights sequence is supplied, it must be the same length as the population sequence. It is a to specify both weights and cum_weights. The weights or cum_weights can use any numeric type that interoperates with the values returned by (that includes integers, floats, and fractions but excludes decimals). Weights are assumed to be non-negative and finite. A is raised if all weights are zero. For a given seed, the function with equal weighting typically produces a different sequence than repeated calls to . The algorithm used by uses floating-point arithmetic for internal consistency and speed. The algorithm used by defaults to integer arithmetic with repeated selections to avoid small biases from round-off error. Changed in version 3.9: Raises a if all weights are zero. To shuffle an immutable sequence and return a new shuffled list, use instead. Note that even for small , the total number of permutations of x can quickly grow larger than the period of most random number generators. This implies that most permutations of a long sequence can never be generated. For example, a sequence of length 2080 is the largest that can fit within the period of the Mersenne Twister random number generator. Return a k length list of unique elements chosen from the population sequence. Used for random sampling without replacement. Returns a new list containing elements from the population while leaving the original population unchanged. The resulting list is in selection order so that all sub-slices will also be valid random samples. This allows raffle winners (the sample) to be partitioned into grand prize and second place winners (the subslices). Members of the population need not be hashable or unique. If the population contains repeats, then each occurrence is a possible selection in the sample. Repeated elements can be specified one at a time or with the optional keyword-only counts parameter. For example, is equivalent to . To choose a sample from a range of integers, use a object as an argument. This is especially fast and space efficient for sampling from a large population: . If the sample size is larger than the population size, a is raised. Changed in version 3.11: The population must be a sequence. Automatic conversion of sets to lists is no longer supported.\n\nThe following functions generate specific real-valued distributions. Function parameters are named after the corresponding variables in the distribution’s equation, as used in common mathematical practice; most of these equations can be found in any statistics text. Return the next random floating-point number in the range Return a random floating-point number N such that for and for . The end-point value may or may not be included in the range depending on floating-point rounding in the expression . Return a random floating-point number N such that and with the specified mode between those bounds. The low and high bounds default to zero and one. The mode argument defaults to the midpoint between the bounds, giving a symmetric distribution. Beta distribution. Conditions on the parameters are and . Returned values range between 0 and 1. Exponential distribution. lambd is 1.0 divided by the desired mean. It should be nonzero. (The parameter would be called “lambda”, but that is a reserved word in Python.) Returned values range from 0 to positive infinity if lambd is positive, and from negative infinity to 0 if lambd is negative. Changed in version 3.12: Added the default value for . Gamma distribution. (Not the gamma function!) The shape and scale parameters, alpha and beta, must have positive values. (Calling conventions vary and some sources define ‘beta’ as the inverse of the scale). Normal distribution, also called the Gaussian distribution. mu is the mean, and sigma is the standard deviation. This is slightly faster than the function defined below. Multithreading note: When two threads call this function simultaneously, it is possible that they will receive the same return value. This can be avoided in three ways. 1) Have each thread use a different instance of the random number generator. 2) Put locks around all calls. 3) Use the slower, but thread-safe function instead. Changed in version 3.11: mu and sigma now have default arguments. Log normal distribution. If you take the natural logarithm of this distribution, you’ll get a normal distribution with mean mu and standard deviation sigma. mu can have any value, and sigma must be greater than zero. Normal distribution. mu is the mean, and sigma is the standard deviation. Changed in version 3.11: mu and sigma now have default arguments. mu is the mean angle, expressed in radians between 0 and 2*pi, and kappa is the concentration parameter, which must be greater than or equal to zero. If kappa is equal to zero, this distribution reduces to a uniform random angle over the range 0 to 2*pi. Weibull distribution. alpha is the scale parameter and beta is the shape parameter.\n\n# Even integer from 0 to 100 inclusive ['four', 'two', 'ace', 'three'] # of 52 playing cards, and determine the proportion of cards # Estimate the probability of getting 5 or more heads from 7 spins # of a biased coin that settles on heads 60% of the time. # Probability of the median of 5 samples being in middle two quartiles Example of statistical bootstrapping using resampling with replacement to estimate a confidence interval for the mean of a sample: Example of a resampling permutation test to determine the statistical significance or p-value of an observed difference between the effects of a drug versus a placebo: # Example from \"Statistics is Easy\" by Dennis Shasha and Manda Wilson 'at least as extreme as the observed difference of leads us to reject the null' 'hypothesis that there is no difference between the drug and the placebo.' Simulation of arrival times and service deliveries for a multiserver queue: # time when each server becomes available Statistics for Hackers a video tutorial by Jake Vanderplas on statistical analysis using just a few fundamental concepts including simulation, sampling, shuffling, and cross-validation. Economics Simulation a simulation of a marketplace by Peter Norvig that shows effective use of many of the tools and distributions provided by this module (gauss, uniform, sample, betavariate, choice, triangular, and randrange). A Concrete Introduction to Probability (using Python) a tutorial by Peter Norvig covering the basics of probability theory, how to write simulations, and how to perform data analysis using Python.\n\nThese recipes show how to efficiently make random selections from the combinatoric iterators in the module: \"Choose r elements with replacement. Order the result to match the iterable.\" # Result will be in set(itertools.combinations_with_replacement(iterable, r)). The default returns multiples of 2⁻⁵³ in the range 0.0 ≤ x < 1.0. All such numbers are evenly spaced and are exactly representable as Python floats. However, many other representable floats in that interval are not possible selections. For example, isn’t an integer multiple of 2⁻⁵³. The following recipe takes a different approach. All floats in the interval are possible selections. The mantissa comes from a uniform distribution of integers in the range 2⁵² ≤ mantissa < 2⁵³. The exponent comes from a geometric distribution where exponents smaller than -53 occur half as often as the next larger exponent. All real valued distributions in the class will use the new method: The recipe is conceptually equivalent to an algorithm that chooses from all the multiples of 2⁻¹⁰⁷⁴ in the range 0.0 ≤ x < 1.0. All such numbers are evenly spaced, but most have to be rounded down to the nearest representable Python float. (The value 2⁻¹⁰⁷⁴ is the smallest positive unnormalized float and is equal to .) Generating Pseudo-random Floating-Point Values a paper by Allen B. Downey describing ways to generate more fine-grained floats than normally generated by ."
    },
    {
        "link": "https://geeksforgeeks.org/create-a-random-password-generator-using-python",
        "document": "In this article, we will see how to create a random password generator using Python.\n\nPasswords are a means by which a user proves that they are authorized to use a device. It is important that passwords must be long and complex. It should contain at least more than ten characters with a combination of characters such as percent (%), commas(,), and parentheses, as well as lower-case and upper-case alphabets and numbers. Here we will create a random password using Python code.\n\nstring – For accessing string constants. The ones we would need are –\n• string.ascii_letters: ASCII is a system that is used to represent characters digitally, every ASCII character has its own unique code. string.ascii_letters is a string constant which contains all the letters in ASCII ranging from A to Z and a to z. Its value is non-locale dependent and it is just a concatenation of ascii_uppercase and ascii_lowercase. Thus it provides us the whole letter set as a string that can be used as desired.\n• string.digits: This is a pre-initialized string that contains all the digits in the Arabic numeral system i.e. 0, 1, 2, 3, 4, 5, 6, 7, 8, 9. It should be kept in mind that even though these are digits, the type is still a string constant, and all digits are concatenated like this – “0123456789”. If we want to access specific numbers then we can do so using slicing.\n• string.punctuation: Apart from letters and digits, python also provides us all the special characters in a pre-initialized string constant. These include various kinds of braces, logical operators, comparison operators, arithmetical operators as well as punctuation marks like commas, inverted commas, periods, exclamations marks, and question marks. The whole string is – !”#$%&'()*+, -./:;<=>?@[\\]^_`{|}~\n\nrandom – The python random module helps a user to generate pseudo-random numbers. Inside the module, there are various functions that just depend on the function “random()”. This function generates a random float uniformly in the semi-open range [0.0, 1.0) i.e. it generates a decimal number greater than or equal to 0 and strictly less than one. Other functions use this number in their own ways. These functions can be used for bytes, integers, and sequences. for our task, we are interested in sequences. There are functions random. choices that take in a sequence as its argument and return a random element from that sequence.\n\nFirst, take the length of the password as input. Then we can display a prompt about the possible list of characters that a user wants to include in the password –\n• For including letters in the character set append string.ascii_letters in the character list.\n• For including letters in the character set append string.digits in the character list.\n• For including letters in character set append string.punctuation in the character list.\n\nRun a for loop till the length of the password and in each iteration choose a random character using random.choice() from characterList. Finally, print the password.\n\nInput 1: Taking only letters in the character set\n\nInput 3: Taking letters numbers as well as special characters\n\nStrong Password Generator Only by entering the size of password"
    },
    {
        "link": "https://pynative.com/python-generate-random-string",
        "document": "In this lesson, you will learn how to create a random string and passwords in Python.\n\nBelow is the list of string constants you can use to get a different set of characters as a source for creating a random string.\n\nHow to Create a Random String in Python\n\nExample to generate a random string of any length\n\nIn Python, to generate a random string with the combination of lowercase and uppercase letters, we need to use the constant as the source. This constant contains all the lowercase and uppercase letters.\n\nIf you wanted to generate a random string from a fixed set of characters, please use the following example.\n\nNote: The method can repeat characters. If you don’t want repeated characters in a resultant string, then use the random.sample() method.\n\n: As you can see in the output, all characters are unique, but it is less secure because it will reduce the probability of combinations of letters because we are not allowing repetitive letters and digits.\n\nA password that contains a combination of characters, digits, and special symbols is considered a strong password.\n\nAssume, you want to generate a random password like: –\n\nWe can generate a random string password in Python with letters, special characters, and digits using the following two ways.\n• Combine the following three constants and use them as a data source for the function to select random characters from it.\n• : To include letters from a-z and A-Z\n• : To include digits from 1 to 10\n• Use the constant and function. The contains a combination of digits, ascii_letters (lowercase and uppercase letters), punctuation, and whitespace.\n\nRandom password with a fixed count of letters, digits, and symbols\n\nIt is a widespread use case that passwords must contain some count of digits and special symbols.\n\nLet’s see how to generate a random password that contains at least one lowercase letter, one uppercase letter, one digit, and one special symbol.\n• First, select the number of random lowercase and uppercase letters specified\n• Next, choose the number of random digits\n• Next, choose the number of special symbols\n• Combine both letters, digits, and special symbols into a list\n• At last shuffle the list\n\nAbove all, examples are not cryptographically secure. The cryptographically secure random generator generates random data using synchronization methods to ensure that no two processes can obtain the same data simultaneously.\n\nIf you are producing random passwords or strings for a security-sensitive application, then you must use this approach.\n\nIf you are using Python version less than 3.6, then use the function instead of .\n\nIf you are using a Python version higher than 3.6 you can use the secrets module to generate a secure random password.\n\nUse function instead of\n\nWe often want to create a random string containing both letters and digits such as ab23cd, jkml98, 87thki. In such cases, we use the and constants to get the combinations of letters and numbers in our random string.\n\nNow, let’s see the to create a random string with the combination of a letter from A-Z, a-z, and digits 0-9.\n\nRandom alphanumeric string with a fixed count of letters and digits\n\nFor example, I want to create a random alpha-numeric string that contains 5 letters and 3 numbers.\n\nThe above examples depend on String constants and random module functions. There are also other ways to generate a random string in Python. Let see those now.\n\nWe can use to get a secure random text in hexadecimal format.\n\nThe random string generated using a UUID module is suitable for the Cryptographically secure application. The UUID module has various functions to do this. Here in this example, we are using a function to generate a random string Id.\n\nUse the StringGenerator module to generate a random string\n\nThe StringGenerator module is not a part of a standard library. However, if you want you can install it using pip and start using it.\n• Use a function of StringGenerator to generate randomized strings of characters using a template\n\nLet see the example now.\n\nI want to hear from you. What do you think of this article? Or maybe I missed one of the ways to generate random string in Python. Either way, let me know by leaving a comment below.\n\nAlso, try to solve the random module exercise and quiz to have a better understanding of working with random data in Python.\n\nCreate a random alphanumeric string of length ten that must contain at least four digits. For example, the output can be anything like 1o32WzUS87, 1P56X9Vh87"
    },
    {
        "link": "https://stackoverflow.com/questions/7479442/high-quality-simple-random-password-generator",
        "document": "I'm interested in creating a very simple, high (cryptographic) quality random password generator. Is there a better way to do this?\n\nThe difficult thing with passwords is to make them strong enough and still be able to remember them. If the password is not meant to be remembered by a human being, then it is not really a password. You use Python's : that's good. For any practical purpose (even cryptography), the output of is indistinguishable from true alea. Then you use it as seed in , which is less good: that one is a non-cryptographic PRNG, and its output may exhibit some structure which will not register in a statistical measurement tool, but might be exploited by an intelligent attacker. You should work with all along. To make things simple: choose an alphabet of length 64, e.g. letters (uppercase and lowercase), digits, and two extra punctuation characters (such as '+' and '/'). Then, for each password character, get one byte from , reduce the value modulo 64 (this is unbiased because 64 divides 256) and use the result as index in your array. With an alphabet of length 64, you get 6 bits of entropy per character (because 26 = 64). Thus, with 13 characters, you get 78 bits of entropy. This is not ultimately strong in all cases, but already very strong (it could be defeated with a budget which will be counted in months and billions of dollars, not mere millions).\n\nJust two days ago, Kragen Javier Sitaker posted a program to do this at http://lists.canonical.org/pipermail/kragen-hacks/2011-September/000527.html (gone now - try https://github.com/jesterpm/bin/blob/master/mkpasswd) kragen at inexorable:~/devel/inexorable-misc$ ./mkpass.py 5 12 Your password is \"learned damage saved residential stages\". That's equivalent to a 60-bit key. That password would take 2.5e+03 CPU-years to crack on my inexpensive Celeron E1200 from 2008, assuming an offline attack on a MS-Cache hash, which is the worst password hashing algorithm in common use, slightly worse than even simple MD5. The most common password-hashing algorithm these days is FreeBSD’s iterated MD5; cracking such a hash would take 5.2e+06 CPU-years. But a modern GPU can crack about 250 times as fast, so that same iterated MD5 would fall in 2e+04 GPU-years. That GPU costs about US$1.45 per day to run in 2011, so cracking the password would cost about US$3e+09. I've started using a password generated this way in place of a 9-printable- ASCII-character random password, which is equally strong. Munroe's assertion that these passwords are much easier to memorize is correct. However, there is still a problem: because there are many fewer bits of entropy per character (about 1.7 instead of 6.6) there is a lot of redundancy in the password, and so attacks such as the ssh timing-channel attack (the Song, Wagner, and Tian Herbivore attack, which I learned about from Bram Cohen in the Bagdad Café in the wee hours one morning, years ago) and keyboard audio recording attacks have a much better chance of capturing enough information to make the password attackable. My countermeasure to the Herbivore attack, which works well with 9-character password but is extremely annoying with my new password, is to type the password with a half-second delay between characters, so that the timing channel does not carry much information about the actual characters used. Additionally, the lower length of the 9-character password inherently gives the Herbivore approach much less information to chew on. Other possible countermeasures include using Emacs shell-mode, which prompts you locally for the password when it recognizes a password prompt and then sends the whole password at once, and copying and pasting the password from somewhere else. As you'd expect, this password also takes a little while longer to type: about 6 seconds instead of about 3 seconds. #!/usr/bin/python # -*- coding: utf-8 -*- import random, itertools, os, sys def main(argv): try: nwords = int(argv[1]) except IndexError: return usage(argv[0]) try: nbits = int(argv[2]) except IndexError: nbits = 11 filename = os.path.join(os.environ['HOME'], 'devel', 'wordlist') wordlist = read_file(filename, nbits) if len(wordlist) != 2**nbits: sys.stderr.write(\"%r contains only %d words, not %d.\n\n\" % (filename, len(wordlist), 2**nbits)) return 2 display_password(generate_password(nwords, wordlist), nwords, nbits) return 0 def usage(argv0): p = sys.stderr.write p(\"Usage: %s nwords [nbits]\n\n\" % argv0) p(\"Generates a password of nwords words, each with nbits bits\n\n\") p(\"of entropy, choosing words from the first entries in\n\n\") p(\"$HOME/devel/wordlist, which should be in the same format as\n\n\") p(\"<http://canonical.org/~kragen/sw/wordlist>, which is a text file\n\n\") p(\"with one word per line, preceded by its frequency, most frequent\n\n\") p(\"words first.\n\n\") p(\"\n\nRecommended:\n\n\") p(\" %s 5 12\n\n\" % argv0) p(\" %s 6\n\n\" % argv0) return 1 def read_file(filename, nbits): return [line.split()[1] for line in itertools.islice(open(filename), 2**nbits)] def generate_password(nwords, wordlist): choice = random.SystemRandom().choice return ' '.join(choice(wordlist) for ii in range(nwords)) def display_password(password, nwords, nbits): print 'Your password is \"%s\".' % password entropy = nwords * nbits print \"That's equivalent to a %d-bit key.\" % entropy print # My Celeron E1200 # (<http://ark.intel.com/products/34440/Intel-Celeron-Processor-E1200-(512K-Cache-1_60-GHz-800-MHz-FSB)>) # was released on January 20, 2008. Running it in 32-bit mode, # john --test (<http://www.openwall.com/john/>) reports that it # can do 7303000 MD5 operations per second, but I’m pretty sure # that’s a single-core number (I don’t think John is # multithreaded) on a dual-core processor. t = years(entropy, 7303000 * 2) print \"That password would take %.2g CPU-years to crack\" % t print \"on my inexpensive Celeron E1200 from 2008,\" print \"assuming an offline attack on a MS-Cache hash,\" print \"which is the worst password hashing algorithm in common use,\" print \"slightly worse than even simple MD5.\" print t = years(entropy, 3539 * 2) print \"The most common password-hashing algorithm these days is FreeBSD’s\" print \"iterated MD5; cracking such a hash would take %.2g CPU-years.\" % t print # (As it happens, my own machines use Drepper’s SHA-2-based # hashing algorithm that was developed to replace the one # mentioned above; I am assuming that it’s at least as slow as the # MD5-crypt.) # <https://en.bitcoin.it/wiki/Mining_hardware_comparison> says a # Core 2 Duo U7600 can do 1.1 Mhash/s (of Bitcoin) at a 1.2GHz # clock with one thread. The Celeron in my machine that I # benchmarked is basically a Core 2 Duo with a smaller cache, so # I’m going to assume that it could probably do about 1.5Mhash/s. # All common password-hashing algorithms (the ones mentioned # above, the others implemented in John, and bcrypt, but not # scrypt) use very little memory and, I believe, should scale on # GPUs comparably to the SHA-256 used in Bitcoin. # The same mining-hardware comparison says a Radeon 5870 card can # do 393.46 Mhash/s for US$350. print \"But a modern GPU can crack about 250 times as fast,\" print \"so that same iterated MD5 would fall in %.1g GPU-years.\" % (t / 250) print # Suppose we depreciate the video card by Moore’s law, # i.e. halving in value every 18 months. That's a loss of about # 0.13% in value every day; at US$350, that’s about 44¢ per day, # or US$160 per GPU-year. If someone wanted your password as # quickly as possible, they could distribute the cracking job # across a network of millions of these cards. The cards # additionally use about 200 watts of power, which at 16¢/kWh # works out to 77¢ per day. If we assume an additional 20% # overhead, that’s US$1.45/day or US$529/GPU-year. cost_per_day = 1.45 cost_per_crack = cost_per_day * 365 * t print \"That GPU costs about US$%.2f per day to run in 2011,\" % cost_per_day print \"so cracking the password would cost about US$%.1g.\" % cost_per_crack def years(entropy, crypts_per_second): return float(2**entropy) / crypts_per_second / 86400 / 365.2422 if __name__ == '__main__': sys.exit(main(sys.argv))\n\nBuilt my own CLI answer to the topic at hand (full source code at the following URL): Wrote a password generator using argparse. Hope this helps someone (either building a password generator or using argparse)! Either way, it was fun to build! $ ./pwgen.py -h usage: pwgen.py [-h] [-c COUNT] [-a] [-l] [-n] [-s] [-u] [-p] Create a random password Special characters, numbers, UPPERCASE -\"Oscar\", and lowercase -\"lima\" to avoid confusion. Default options (no arguments): -c 16 -a Enjoy! [email protected] optional arguments: -h, --help show this help message and exit -c COUNT, --count COUNT password length -a, --all same as -l -n -s -u -l, --lower include lowercase characters -n, --number include 0-9 -s, --special include special characters -u, --upper include uppercase characters -p, --license print license and exit #!/usr/bin/env python2 # -*- coding: utf-8 -*- license = \"\"\" # pwgen -- the pseudo-random password generator # # This software is distributed under the MIT license. # # The MIT License (MIT) # # Copyright (c) 2016 0NetEnv [email protected] # Permission is hereby granted, free of charge, to any # person obtaining a copy of this software and associated # documentation files (the \"Software\"), to deal in the # Software without restriction, including without # limitation the rights to use, copy, modify, merge, # publish, distribute, sublicense, and/or sell copies # of the Software, and to permit persons to whom the # Software is furnished to do so, subject to the following # conditions: # # The above copyright notice and this permission notice # shall be included in all copies or substantial portions # of the Software. # # THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF # ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED # TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A # PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT # SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY # CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION # OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR # IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER # DEALINGS IN THE SOFTWARE. # # NOTE: # This software was tested on Slackware 14.2, Raspbian, & # Mac OS X 10.11 # \"\"\" import string import random import sys # first time using argparse library import argparse # wanted to change the formatting of the help menu a little bit, so used RawTextHelpFormatter directly from argparse import RawTextHelpFormatter typo = '' c = 16 counter = 0 line = '-' * 40 # CREATE FUNCTION for PWGEN def pwgen(z, t): # EMPTY SET OF CHARACTERS charsset = '' # UPPERCASE -\"O\" U = 'ABCDEFGHIJKLMNPQRSTUVWXYZ' # lowercase -\"l\" L = 'abcdefghijkmnopqrstuvwxyz' N = '0123456789' S = '!@#$%^&*?<>' # make sure we're using an integer, not a char/string z = int(z) for type in t: if 'u' in t: charsset = charsset + U if 'l' in t: charsset = charsset + L if 'n' in t: charsset = charsset + N if 's' in t: charsset = charsset + S if 'a' == t: charsset = charsset + U + L + N + S return ''.join(random.choice(charsset) for _ in range(0, int(z))) # GET ARGUMENTS using ARGPARSE parser = argparse.ArgumentParser(description='\n\n Create a random password\n\n\\ Special characters, numbers, UPPERCASE -\"Oscar\",\n\n\\ and lowercase -\"lima\" to avoid confusion.\n\n\\ Default options (no arguments): -c 16 -a\n\n\\ \\t\\tEnjoy! [email protected]', formatter_class=argparse.RawTextHelpFormatter) parser.add_argument(\"-c\", \"--count\", dest=\"count\", action=\"store\", help=\"password length\") parser.add_argument(\"-a\", \"--all\", help=\"same as -l -n -s -u\", action=\"store_true\") parser.add_argument(\"-l\", \"--lower\", help=\"include lowercase characters\", action=\"store_true\") parser.add_argument(\"-n\", \"--number\", help=\"include 0-9\", action=\"store_true\") parser.add_argument(\"-s\", \"--special\", help=\"include special characters\", action=\"store_true\") parser.add_argument(\"-u\", \"--upper\", help=\"include uppercase characters\", action=\"store_true\") parser.add_argument(\"-p\", \"--license\", help=\"print license and exit\", action=\"store_true\") # COLLECT ARGPARSE RESULTS results = args = parser.parse_args() # CHECK RESULTS # Check that a length was given. # If not, gripe and exit. if args.count == '0': print (\"Input error:\n\nCannot create a zero length password.\n\nExiting\") exit (0) # check character results and add to counter if # selection is made. if args.lower: typo = typo + 'l' counter = counter + 1 #print \"lower\" if args.number: typo = typo + 'n' counter = counter + 1 #print \"number\" if args.special: typo = typo + 's' counter = counter + 1 #print \"special\" if args.upper: typo = typo + 'u' counter = counter + 1 #print \"upper\" if args.all: typo = 'a' counter = counter + 1 #print \"all\" if args.license: print (license) exit (1) # CHECK COUNTER # Check our counter and see if we used any command line # options. We don't want to error out. # try it gracefully. If no arguments are given, # use defaults and tell the user. # args.count comes from argparse and by default requires # an input to '-c'. We want to get around that for the # sake of convenience. # Without further adieu, here's our if statement: if args.count: if counter == 0: typo = 'a' print (\"defaulting to '--all'\") print (line) print (pwgen(results.count,typo)) else: if counter == 0: typo = 'a' print (\"defaulting to '--count 16 --all'\") print (line) print (pwgen(c,typo)) print (line) #print typo\n\nHere is another implementation (python 2; would require some minor rewrites to get it working in 3) that is much faster than OJW's, which seems to loop through the dictionary for each word, despite the comment/implication to the contrary. Timing of OJW's script on my machine, with an 80,000 IOP SSD: The following script loads the whole dictionary into a list, then picks words based on a random selection of the index value, using OJW's regex for filtering. This also generates 10 passphrase sets, allows passing command-line parameters to adjust the number of words, and adds number and symbol padding (also adjustable length). Usage: xkcdpass-mod.py 2 4 (for example; these are the default values). It prints spaces in the output for easy reading, although I've almost never encountered an online service that allows using them, so I would just ignore them. This could definitely be cleaned up with argparse or getopt and allowing switches for including spaces or not, including/excluding symbols, capitals, etc., plus some additional refactoring, but I haven't gotten to that yet. So, without further ado: #!/usr/bin/env python #Copyright AMH, 2013; dedicated to public domain. import os, re, sys, random from sys import argv def getargs(): if len(argv) == 3: numwords = argv[1] numpads = argv[2] return(numwords, numpads) elif len(argv) == 2: numwords = argv[1] numpads = 4 return (numwords, numpads) else: numwords = 2 numpads = 4 return (numwords, numpads) def dicopen(dictionary=\"/usr/share/dict/american-english\"): f = open(dictionary, \"r\") dic = f.readlines() return dic def genPassword(numwords, numpads): r = random.SystemRandom() pads = '0123456789!@#$%^&*()' padding = [] words = dicopen() wordlist = [] for i in range (0,int(numpads)): padding.append(pads[r.randint(0,len(pads)-1)]) #initialize counter for only adding filtered words to passphrase j = 0 while (j < int(numwords)): inclusion_criteria = re.compile('^[a-z]{5,10}$') #Select a random number, then pull the word at that index value, rather than looping through the dictionary for each word current_word = words[r.randint(0,len(words)-1)].strip() #Only append matching words if inclusion_criteria.match(current_word): wordlist.append(current_word) j += 1 else: #Ignore non-matching words pass return(\" \".join(wordlist)+' '+''.join(padding)) if(__name__ == \"__main__\"): for i in range (1,11): print \"item \"+str(i)+\"\n\n\"+genPassword(getargs()[0], getargs()[1]) And going for the full \"correct horse battery staple\" (CHBS), no padding: According to https://www.grc.com/haystack.htm, for all practical purposes, assuming 100 trillion guesses per second (i.e., 100 TH/s) the shorter version would take about 50-60 million centuries to crack; the full CHBS = 1.24 hundred trillion trillion centuries; adding padding to that, 15.51 trillion trillion trillion centuries. Even enlisting the entire Bitcoin mining network (~2500 TH/s as of this writing), the short version would still likely take 250-300 million years to break, which is probably secure enough for most purposes.\n\n\"\"\" This code below in any shape or form is owned by A.S Gallery This code is the asnwer for Password Generator quiz - CodeHs This code works 100% Have fun exploring !!! \"\"\" # Imports import random import time print \"Hi !!!\" password_output = \"this is your new password : \" ask_name = input(\"Enter your Name : \") greetings_name = \"Hi \"+ str(ask_name) + \"!!! \" print greetings_name print \"Now we will make your new password using the ULTIMATE password generator !!!\" time.sleep(8) print \"Our password generator will give you multiple choices, you can choose any password generator you want !!! \" time.sleep(8) print \"You can choose if you want a strong password or a weak password !! (strong recommended) \" time.sleep(8) print \"You can also make your own password, to make your own password type own !!! \" time.sleep(8) print \"If you want to choose strong type strong, if weak then type weak !!! \" time.sleep(8) # Example: # Returns random number within and including 0 and 10. def strong_password(): user_input = int(input(\"Enter a number : \")) print type(user_input) time.sleep(3) # calculate_input = user_input * user_input calculate_types = input(\"Do you want to add, multiply or mod the numbers : \") time.sleep(3) if calculate_types == \"add\": calculate_input = user_input + user_input elif calculate_types == \"multiply\" : calculate_input = user_input * user_input elif calculate_types == \"mod\": calculate_input = user_input & user_input else: print \"Check your spelling and try again :( \" # Random element in a string time.sleep(4) want_symbols = input(\"Do you want symbols ?(Y/N) : \") time.sleep(4) random_element = random.choice('abcdefg345') if want_symbols == \"Y\": random_element2 = random.choice('@#()@*($*(@)(*^()*()(#$)*@#)*((@*()@*#)(*)@*($*(%#*)#(*@@_!_()(') elif want_symbols == \"N\": random_element2 = random.choice('29371294203712492703740182903820498201381204AKSJFKSHEHJKFJAODL') random_element3 = random.choice('abcdefghiiasudasdjsiasdhwudagsjdgaskdjsafgjasj') random_element4 = random.choice('abcdefghijsdhjaskdhkasjdhakdjhaskdasjdhakjsd') random_element5 = random.choice('abcdefghijsdhsakjdhsajdldasjdasdjasldas') random_elements6 = random.choice('129389230928308290382109830293943827492347') random_elements7 = random.choice('2473285473q9mdnuwyr8KSDJKDSJKL932uc3487389473289479h3289wjdi94802w') random_elements8 = random.choice('AKDJKAJDKJIKJDUIFHSJHUFRUDIJFDKLDJKDJLJFKLJKLDJLDJKLDJLDJLSKJDKLJDLJDKSLJD') time.sleep(8) print str(ask_name) + \" \" + str(password_output) + str(calculate_input) + str(random_element) + str(random_element2) + str(random_element3) + str(random_element4) + str(random_element5) + str(random_elements6) + str(random_elements7) + str(random_elements8) def weak_password(): user_input = int(input(\"Enter a number : \")) print type(user_input) time.sleep(3) # calculate_input = user_input * user_input calculate_types = input(\"Do you want to add, multiply or mod the numbers : \") time.sleep(3) if calculate_types == \"add\": calculate_input = user_input + user_input elif calculate_types == \"multiply\" : calculate_input = user_input * user_input elif calculate_types == \"mod\": calculate_input = user_input & user_input else: time.sleep(3) print \"Check your spelling and try again :( \" # Random element in a string random_ness = random.choice(\"ABCDEFGHI*(#*#$()#*$)(E)(UWIJEDSH(*#U$()UDSLKH)UW*)$(*&#*(YE(*DY#*YUHSLDF:LKDDSDK\") my_tuple = (calculate_input, random_ness, user_input, ask_name) new_tuple = my_tuple[1] new_tuple1 = my_tuple[2] new_tuple2 = my_tuple[3] time.sleep(7) print str(ask_name) + str(password_output) + str(new_tuple) + str(new_tuple1) + str(new_tuple2) def own_password(): my_list = [] ask_times = int(input(\"How many characters do you want ? (between 1 - 8) : \")) time.sleep(10) if ask_times > 8: print \"Invalid Request\" elif ask_times < 1: print \"Invalid Request\" else: time.sleep(2) print \"You CANNOT include symbols or numbers in this option !!! \" for i in range(ask_times): user_ask = input(\"Enter the character: \") time.sleep(0.6) my_list.append(user_ask) own_password = \"\".join(map(str,my_list)) time.sleep(4) print \"Your own password is : \" + own_password strong_pass = input(\"Do you want a strong password or a weak one or make your own password !! ? : \") if strong_pass == \"strong\": strong_password() elif strong_pass == \"weak\": weak_password() elif strong_pass == \"own\": own_password() else : print \"Invalid Request\" time.sleep(3) print \"Congrats, on creating your best password !!! I belived you used strong password generator because its the BEST !!\" time.sleep(7) print \"If not, no problem just restart the program and type strong when prompted !!! \" time.sleep(6) print \"Have a nice day !\" This code is the answer for CodeHs Quiz too (if you had any ) !!!"
    },
    {
        "link": "https://geeksforgeeks.org/python-random-module",
        "document": "Python Random module generates random numbers in Python. These are pseudo-random numbers means they are not truly random.\n\nThis module can be used to perform random actions such as generating random numbers, printing random a value for a list or string, etc. It is an in-built function in Python.\n\nList of all the functions Python Random Module\n\nThere are different random functions in the Random Module of Python. Look at the table below to learn more about these functions:\n\nLet’s discuss some common operations performed by Random module in Python.\n\nExample 1: Printing a random value from a list in Python.\n\nThis code uses the module to select a random element from the list using the function. It prints a random element from the list, demonstrating how to pick a random item from a sequence in Python.\n\nExample 2: Creating random numbers with Python seed() in Python.\n\nAs stated above random module creates pseudo-random numbers. Random numbers depend on the seeding value. For example, if the seeding value is 5 then the output of the below program will always be the same. Therefore, it must not be used for encryption.\n\nThe code sets the random number generator’s seed to 5 using , ensuring reproducibility. It then prints two random floating-point numbers between 0 and 1 using . The seed makes these numbers the same every time you run the code with a seed of 5, providing consistency in the generated random values.\n\nrandom.randint() method is used to generate random integers between the given range.\n\nThis code uses the ‘ module to generate random integers within specific ranges. It first generates a random integer between 5 and 15 (inclusive) and then between -10 and -2 (inclusive). The generated integers are printed with appropriate formatting.\n\nA random.random() method is used to generate random floats between 0.0 to 1.\n\nIn this code, we are using the function from the ‘ module in Python. It prints a random floating-point number between 0 and 1 when you call .\n\nRandom sampling from a list in Python (random.choice, and sample)\n\nExample 1: Python random.choice() function is used to return a random item from a list, tuple, or string.\n\nThe code uses the function from the module to randomly select elements from different data types. It demonstrates selecting a random element from a list, a string, and a tuple. The chosen elements will vary each time you run the code, making it useful for random selection from various data structures.\n\nExample 2: Python random.sample() function is used to return a random item from a list, tuple, or string.\n\nThis code utilizes the function from the ‘ module to obtain random samples from various data types. It selects three random elements without replacement from a list, a tuple, and a string, demonstrating its versatility in generating distinct random samples. With each execution, the selected elements will differ, providing random subsets from the input data structures.\n\nA random.shuffle() method is used to shuffle a sequence (list). Shuffling means changing the position of the elements of the sequence. Here, the shuffling operation is inplace.\n\nThis code uses the function from the ‘ module to shuffle the elements of a list named ‘ . It first prints the original order of the list, then shuffles it twice. The second shuffle creates a new random order, and the list’s content is displayed after each shuffle. This demonstrates how the elements are rearranged randomly in the list with each shuffle operation.\n\nIn this article we discussed about Python Random module, and also saw some examples of functions in random module in Python. Random module in Python is very important and contains very useful functions.\n\nHope this helps you in using Python Random module functions.\n\nWhat is a random module in Python?\n\nWhat is random vs Randint in Python?\n\nHow many functions are there in the random module?\n\nWhat is the syntax of the random function?\n\nWhat is the difference between the math module and the random module?"
    }
]