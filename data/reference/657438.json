[
    {
        "link": "https://docs.python.org/3/library/itertools.html",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/python-itertools-chain",
        "document": "The itertools is a module in Python having a collection of functions that are used for handling iterators. They make iterating through the iterables like lists and strings very easily. One such itertools function is chain().\n\nNote: For more information, refer to Python Itertools\n\n\n\nIt is a function that takes a series of iterables and returns one iterable. It groups all the iterables together and produces a single iterable as output. Its output cannot be used directly and thus explicitly converted into iterables. This function come under the category iterators terminating iterators.\n\nSyntax :\n\nThe internal working of chain can be implemented as given below :\n\nExample 1: The odd numbers and even numbers are in separate lists. Combine them to form a new single list.\n\nExample 2: Some of the consonants are in a list. The vowels are given in a list. Combine them and also sort them.\n\nExample 3: In the example below, Each String is considered to be an iterable and each character in it is considered to be an element in the iterator. Thus every character is yielded\n\nchain.from_iterable() function\n\nIt is similar to chain, but it can be used to chain items from a single iterable. The difference is demonstrated in the example given below:\n\nExample 5:\n\nExample 6: Now consider a list like the one given below :\n\nYou are supposed to calculate the sum of the list taking every single digit into account. So the answer should be :\n\nThis can be achieved easily using the code below :\n\nTo simplify it, we combine the steps. An optimized approach is given below:"
    },
    {
        "link": "https://stackoverflow.com/questions/27443890/why-is-chaining-iterables-this-complicated-simplify-this-code",
        "document": "You could build your generator by hand:\n\nWhich is certainly not the most beautiful code, but it does what you want. Explanations:\n\nIf your input is indefinitely long you have to read it in chunks (or character wise). Whenever you encounter a non-digit (whitespace), you convert the characters you have read until that point into an integer and yield it. You also have to consider what happens when you reach the EOF. My implementation is probably not very well performed, due to the fact that I'm reading char-wise. Using chunks one could speed it up significantly.\n\nEDIT as to why your approach will never work:\n\ndoes simply not do what you appear to think it does. applies the given function to each element of the iterator given as the second parameter. In your case that is a stream, i.e. a file object, in the case of sys.stdin specifically a io.TextIOBase object. Which indeed can be iterated over. Line by line, which emphatically is NOT what you want! In effect you iterate over your input line by line and split each line into words. The map generator iterates over (many) lists of words NOT over A list of words. Which is why you have to chain them together to get a single list to iterate on.\n\nAlso, the in is redundant. chains its arguments (each an inalterable object) together into one iterator. You only give it one argument so there is nothing to chain together, it basically returns the map object unchanged. on the other hand takes one argument, which is expected to be an iterator of iterators (e.g. a list of lists) and flattens it into one iterator (list)."
    },
    {
        "link": "https://docs.python.org/3.10/library/itertools.html?highlight=pairwise",
        "document": ""
    },
    {
        "link": "https://iterchain.readthedocs.io",
        "document": "Iterchain is a library intended to make manipulating iterators in Python easier and more ergonomic. The design is heavily inspired by the Rust iterator design, and a lot of the functionality comes from the standard Python itertools library.\n\nWhy would I need this?¶\n\nSay we want to know the sum of all the squares of even numbers up to 100.\n\n How can we do this?\n\nThis works, but if you read this for the first time it can take a bit of effort to figure out what’s happening, especially in slightly less trivial cases. So, how about we use iterators instead?\n\nThat’s pretty nice! Much shorter, and much easier to understand.\n\n But there’s a problem, this pattern only works for relatively simple manipulations. In those cases you could try using the python and builtins (and the slightly more hidden ). They let you construct more complex processing chains.\n\nLet’s rewrite our iterator to use those functions instead:\n\nOkay, now that is a mess…\n\n I don’t know about you, but it would take me quite a while to unravel what’s happening here. The problem is that the whole expression is inside out. The gets applied first, but it’s hidden in the middle of the expression, and the gets applied last but it is all the way in the front. Makes no sense…\n\nSo, how can we improve on this? of course!\n\n (you probably saw this coming already)\n\nSo, let’s see how it looks using :\n\nIsn’t this much better? The operations are listed in the order that they’re executed, are clearly separated, and you can have as few or as many operations as you want. This is why you should use !"
    },
    {
        "link": "https://geeksforgeeks.org/reading-writing-text-files-python",
        "document": "Python provides built-in functions for creating, writing, and reading files. Two types of files can be handled in Python, normal text files and binary files (written in binary language, 0s, and 1s).\n• Text files: In this type of file, Each line of text is terminated with a special character called EOL (End of Line), which is the new line character (‘\n\n’) in Python by default.\n• Binary files: In this type of file, there is no terminator for a line, and the data is stored after converting it into machine-understandable binary language.\n\nThis article will focus on opening, closing, reading, and writing data in a text file. Here, we will also see how to get Python output in a text file.\n\nIt is done using the open() function. No module is required to be imported for this function.\n\nExample: Here, file1 is created as an object for MyFile1 and file2 as object for MyFile2.\n\nThere are three ways to read txt file in Python:\n\nread(): Returns the read bytes in form of a string. Reads n bytes, if no n specified, reads the entire file.\n\nreadline(): Reads a line of the file and returns in form of a string.For specified n, reads at most n bytes. However, does not reads more than one line, even if n exceeds the length of the line.\n\nreadlines(): Reads all the lines and return them as each line a string element in a list.\n\nNote: ‘\n\n’ is treated as a special character of two bytes.\n\nIn this example, a file named “myfile.txt” is created and opened in write mode ( ). Data is written to the file using and methods. The file is then reopened in read and append mode ( ). Various read operations, including , , , and the use of , demonstrate different ways to retrieve data from the file. Finally, the file is closed.\n\nThere are two ways to write in a file:\n\nwrite(): Inserts the string str1 in a single line in the text file.\n\nwritelines(): For a list of string elements, each string is inserted in the text file.Used to insert multiple strings at a single time.\n\nIn this example, a file named “myfile.txt” is initially opened in write mode ( ) to write lines of text. The file is then reopened in append mode ( ), and “Today” is added to the existing content. The output after appending is displayed using . Subsequently, the file is reopened in write mode, overwriting the content with “Tomorrow”. The final output after writing is displayed using\n\nPython close() function closes the file and frees the memory space acquired by that file. It is used at the time when the file is no longer needed or if it is to be opened in a different file mode. File_object.close()\n\nReading and Writing to text files in Python – FAQs\n\nAccess modes govern the type of operations possible in the opened file. It refers to how the file will be used once it’s opened. These modes also define the location of the File Handle in the file. The file handle is like a cursor, which defines from where the data has to be read or written in the file and we can get Python output in text file. There are 6 access modes in Python:\n• Read Only (‘r’): Open text file for reading. The handle is positioned at the beginning of the file. If the file does not exist, raises the I/O error. This is also the default mode in which a file is opened.\n• Read and Write (‘r+’): Open the file for reading and writing. The handle is positioned at the beginning of the file. Raises I/O error if the file does not exist.\n• Write Only (‘w’): Open the file for writing. For the existing files, the data is truncated and over-written. The handle is positioned at the beginning of the file. Creates the file if the file does not exist.\n• Write and Read (‘w+’) : Open the file for reading and writing. For an existing file, data is truncated and over-written. The handle is positioned at the beginning of the file.\n• Append Only (‘a’) : Open the file for writing. The file is created if it does not exist. The handle is positioned at the end of the file. The data being written will be inserted at the end, after the existing data.\n• Append and Read (‘a+’): Open the file for reading and writing. The file is created if it does not exist. The handle is positioned at the end of the file. The data being written will be inserted at the end, after the existing data.\n\nHow to read a file and write to another file in Python?\n\nHow Files are Loaded into Primary Memory?\n\nThere are two kinds of memory in a computer i.e. Primary and Secondary memory every file that you saved or anyone saved is on secondary memory causing any data in primary memory to be deleted when the computer is powered off. So when you need to change any text file or just to work with them in Python you need to load that file into primary memory. Python interacts with files loaded in primary memory or main memory through “file handlers” ( This is how your operating system gives access to Python to interact with the file you opened by searching the file in its memory if found it returns a file handler and then you can work with the file).\n\nWhat is the difference between reading and writing files in Python?\n\nWhich function is used to read data from a text file?"
    },
    {
        "link": "https://digitalocean.com/community/tutorials/how-to-handle-plain-text-files-in-python-3",
        "document": "Python is a great tool for processing data. Some of the most common tasks in programming involve reading, writing, or manipulating data. For this reason, it’s especially useful to know how to handle different file formats which store different types of data.\n\nFor example, consider a Python program that checks a list of users for access control. Your list of users may be stored as a text file, allowing you to check access or modify permissions. With Python, being able to open, read from, write to, and close files will help you work with tasks such as this.\n\nThis tutorial will briefly describe some of the file formats Python is able to handle. After a brief introduction to those, you’ll learn how to open, read, and write a text file in Python 3. When you’re finished, you’ll be able to handle any plain text file in Python.\n\nFor this tutorial, you should have Python 3 installed as well as a local programming environment set up on your computer. If this is not the case, you can get set up by following the appropriate installation and set up guide for your operating system:\n\nPython is very flexible and can handle a number of different file formats with ease, including but not limited to the following:\n\nThis tutorial will focus on working with plain text files.\n\nBefore we can begin working in Python, we need to make sure we have a file to work with. To do this, open your code editor and create a new plain text file called .\n\nIn the new file, enter a few lines of text listing the days of the week:\n\nNext, save your file and make make note of its location. For this example, our user sammy, saved the file here as . This will be very important in later steps, where we open the file in Python.\n\nNow that you have a file to process, you can begin to code.\n\nIn your code editor, create a new Python file and name it .\n\nTo open a file in Python, we first need some way to associate the file on disk with a variable in Python. This process is called opening a file, and the variable called a file handle. We begin by telling Python where the file is. The location of your file is often referred to as the file path — in this example. Create a variable to store this path information.\n\nNow, you can use Python’s function to open our file. The function requires the file path as its first argument. The function also accepts many other parameters. However, most important is the optional parameter. This is an optional string that specifies the mode in which the file is opened. The mode you choose will depend on what you wish to do with the file. Here are some of the available modes:\n• : use for reading from a file\n• : use for writing to a file\n• : use for appending to a file\n• : use for reading and writing to the same file\n\nIn this example, we only want to read from the file, so we will use the mode. Use the function to open the file and assign the resulting file handle to the variable .\n\nNow that you have opened the file, the next step will walk you through reading its contents.\n\nSince our file has been opened, we can now manipulate it (i.e. read from it) through the variable it was assigned to. Python provides three related operations for reading information from a file. Let’s take a moment to understand how each of them work.\n\nThe first operation returns the entire contents of the file as a single string. For example:\n\nThe result would be:\n\nThe second operation returns the next line of the file, returning the text up to and including the next newline character. More simply put, this operation will read a file line-by-line.\n\nThe result would be:\n\nOnce you read a line with the operation the current point at which the file will be read will move to the next line. If you were to call this operation again, it would return the next line in the file like so:\n\nThe last operation, returns a list of the lines in the file, where each item of the list represents a single line.\n\nSomething to keep in mind when you are reading from files, once a file has been read using one of the read operations, it cannot be read again. For example, if you were to first run followed by the second operation would return an empty string. Therefore, anytime you wish to read from a file you will have to first open a new file variable or use the method, which is beyond the scope of this tutorial. If you’d like to learn more, Python has excellent documentation about these methods.\n\nNow that we have read from a file, let’s learn how to write to a new file.\n\nIn this step, you will write a new file that includes the title Days of the Week followed by the contents of the first file. First, create a variable.\n\nYou will also need to store the days of the week in a variable, which we’ll call . This code opens the file in read mode, reads the file, and stores the returned output from the read operation in our new variable . To make it easier to follow, the code from Step 2 is included.\n\nNow that you have variables for title and days of the week, you can begin writing to your new file. First, specify the location of the file. Again, we will use the directory , so our path will be . You can then open the new file in write mode, using the function with the mode specified.\n\nOnce the new file is opened, you can add data using the method. This method takes a single string parameter and writes that data to the file. If you want to start a new line in the file, you must explicitly provide the newline character, , which was included when you assigned to the variable.\n\nWrite the title to the file followed by the days of the week. It may be helpful add in some statements of what we are writing to the file, which is often used for tracking your scripts’ progress.\n\nLastly, whenever you are finished with a file, it’s important to close it.\n\nClosing a file makes sure that the connection between the file on disk and the file handle is finished. Closing files also ensures that other programs are able to access them and keeps your data safe. If you are not using statements as described in Step 6, always make sure to close your files. For this example, close all our files using the method.\n\nNow that the script is finished using the files, it releases the file handles using the method.\n\nThe recommended way to work with files in Python (often called the Pythonic way) is to use a feature of the language called statements. These statements are shorthand ways to set up a context in which work is done and, once that context is over, final details are automatically taken care of in order to prevent common errors. In the case of working with files, a statement will automatically close the file so that you don’t have those file handles lingering once you are finished with your task.\n\nAs with any block in Python such as function definitions, statements, or loops, statements take the form of a simple statement followed by a and a block of indented code. Here is an example of code that opens a file and prints its contents:\n\nLet’s walk through what this code does step by step. As before, we open the file using Python’s builtin function, passing the file path and mode parameters. However, since we are using the statement, rather than assigning the resulting file handle to a variable using , we assign it using the keyword. This is part of the full statement’s syntax:\n\nAfter the , we move to the next line and indent our code, which is how Python organizes blocks of functionality. As before, we have access to the file handle in the variable, so we can call the method to get all of the contents and them.\n\nNote how there is no method called, however. This is because as soon as the code leaves this block (that is, as soon as either the next line of code is not indented or the file ends), the statement’s context knows to close those files automatically. The benefits to this are not just that you don’t need to remember to close your files every time, but also that all of your logic for dealing with that file in particular is visually and logically distinct within that block. This structure helps keep your code clean and readable.\n\nWith this in mind, let’s rewrite our code form before using the statement:\n\nNow the code is much more organized. We begin as before by defining some variables: the paths of our two files and the title that we will use for heading up the new file. After that, we begin our statement, opening our two files and storing their connections in appropriately named variables. As before, we read the contents of , then write the title and those contents to . Finally, we end the block by de-indenting our code in order to print the values of and that we read.\n\nWhile there are some cases where you will want to use the method as described earlier on and it is important to know how it works, you will most commonly use statements when working with files in Python.\n\nBefore you run your code, it’s a good idea to make sure everything seems correct. The final product should be something like this:\n\nAfter saving your code, open up terminal and run your Python script, like so:\n\nThe output will be as follows:\n\nNow, double check the code fully worked by opening the new file ( ). If all went well, it should contain this:\n\nIn this tutorial, we went through how to handle and manipulate plain text files in Python 3. Now you can open, read, write, and close files in Python, and you can continue working with your own data in Python. Python provides many other helpful methods when working with input and output, and also provides documentation to learn more."
    },
    {
        "link": "https://docs.python.org/3/tutorial/inputoutput.html",
        "document": "There are several ways to present the output of a program; data can be printed in a human-readable form, or written to a file for future use. This chapter will discuss some of the possibilities.\n\nSo far we’ve encountered two ways of writing values: expression statements and the function. (A third way is using the method of file objects; the standard output file can be referenced as . See the Library Reference for more information on this.) Often you’ll want more control over the formatting of your output than simply printing space-separated values. There are several ways to format output.\n• None To use formatted string literals, begin a string with or before the opening quotation mark or triple quotation mark. Inside this string, you can write a Python expression between and characters that can refer to variables or literal values.\n• None The method of strings requires more manual effort. You’ll still use and to mark where a variable will be substituted and can provide detailed formatting directives, but you’ll also need to provide the information to be formatted. In the following code block there are two examples of how to format variables: Notice how the are padded with spaces and a negative sign only for negative numbers. The example also prints multiplied by 100, with 2 decimal places and followed by a percent sign (see Format Specification Mini-Language for details).\n• None Finally, you can do all the string handling yourself by using string slicing and concatenation operations to create any layout you can imagine. The string type has some methods that perform useful operations for padding strings to a given column width. When you don’t need fancy output but just want a quick display of some variables for debugging purposes, you can convert any value to a string with the or functions. The function is meant to return representations of values which are fairly human-readable, while is meant to generate representations which can be read by the interpreter (or will force a if there is no equivalent syntax). For objects which don’t have a particular representation for human consumption, will return the same value as . Many values, such as numbers or structures like lists and dictionaries, have the same representation using either function. Strings, in particular, have two distinct representations. The value of x is 32.5, and y is 40000... # The repr() of a string adds string quotes and backslashes: # The argument to repr() may be any Python object: The module contains a class that offers yet another way to substitute values into strings, using placeholders like and replacing them with values from a dictionary, but offers much less control of the formatting. Formatted string literals (also called f-strings for short) let you include the value of Python expressions inside a string by prefixing the string with or and writing expressions as . An optional format specifier can follow the expression. This allows greater control over how the value is formatted. The following example rounds pi to three places after the decimal: 'The value of pi is approximately The value of pi is approximately 3.142. Passing an integer after the will cause that field to be a minimum number of characters wide. This is useful for making columns line up. Other modifiers can be used to convert the value before it is formatted. applies , applies , and applies : 'My hovercraft is full of My hovercraft is full of eels. 'My hovercraft is full of My hovercraft is full of 'eels'. The specifier can be used to expand an expression to the text of the expression, an equal sign, then the representation of the evaluated expression: See self-documenting expressions for more information on the specifier. For a reference on these format specifications, see the reference guide for the Format Specification Mini-Language. Basic usage of the method looks like this: We are the knights who say \"Ni!\" The brackets and characters within them (called format fields) are replaced with the objects passed into the method. A number in the brackets can be used to refer to the position of the object passed into the method. If keyword arguments are used in the method, their values are referred to by using the name of the argument. Positional and keyword arguments can be arbitrarily combined: The story of Bill, Manfred, and Georg. If you have a really long format string that you don’t want to split up, it would be nice if you could reference the variables to be formatted by name instead of by position. This can be done by simply passing the dict and using square brackets to access the keys. This could also be done by passing the dictionary as keyword arguments with the notation. This is particularly useful in combination with the built-in function , which returns a dictionary containing all local variables: __name__: __main__; __doc__: None; __package__: None; __loader__: ... As an example, the following lines produce a tidily aligned set of columns giving integers and their squares and cubes: For a complete overview of string formatting with , see Format String Syntax. Here’s the same table of squares and cubes, formatted manually: # Note use of 'end' on previous line The method of string objects right-justifies a string in a field of a given width by padding it with spaces on the left. There are similar methods and . These methods do not write anything, they just return a new string. If the input string is too long, they don’t truncate it, but return it unchanged; this will mess up your column lay-out but that’s usually better than the alternative, which would be lying about a value. (If you really want truncation you can always add a slice operation, as in .) There is another method, , which pads a numeric string on the left with zeros. It understands about plus and minus signs: The % operator (modulo) can also be used for string formatting. Given (where format is a string), conversion specifications in format are replaced with zero or more elements of values. This operation is commonly known as string interpolation. For example: 'The value of pi is approximately The value of pi is approximately 3.142. More information can be found in the printf-style String Formatting section.\n\nreturns a file object, and is most commonly used with two positional arguments and one keyword argument: The first argument is a string containing the filename. The second argument is another string containing a few characters describing the way in which the file will be used. mode can be when the file will only be read, for only writing (an existing file with the same name will be erased), and opens the file for appending; any data written to the file is automatically added to the end. opens the file for both reading and writing. The mode argument is optional; will be assumed if it’s omitted. Normally, files are opened in text mode, that means, you read and write strings from and to the file, which are encoded in a specific encoding. If encoding is not specified, the default is platform dependent (see ). Because UTF-8 is the modern de-facto standard, is recommended unless you know that you need to use a different encoding. Appending a to the mode opens the file in binary mode. Binary mode data is read and written as objects. You can not specify encoding when opening file in binary mode. In text mode, the default when reading is to convert platform-specific line endings ( on Unix, on Windows) to just . When writing in text mode, the default is to convert occurrences of back to platform-specific line endings. This behind-the-scenes modification to file data is fine for text files, but will corrupt binary data like that in or files. Be very careful to use binary mode when reading and writing such files. It is good practice to use the keyword when dealing with file objects. The advantage is that the file is properly closed after its suite finishes, even if an exception is raised at some point. Using is also much shorter than writing equivalent - blocks: # We can check that the file has been automatically closed. If you’re not using the keyword, then you should call to close the file and immediately free up any system resources used by it. Calling without using the keyword or calling might result in the arguments of not being completely written to the disk, even if the program exits successfully. After a file object is closed, either by a statement or by calling , attempts to use the file object will automatically fail. The rest of the examples in this section will assume that a file object called has already been created. To read a file’s contents, call , which reads some quantity of data and returns it as a string (in text mode) or bytes object (in binary mode). size is an optional numeric argument. When size is omitted or negative, the entire contents of the file will be read and returned; it’s your problem if the file is twice as large as your machine’s memory. Otherwise, at most size characters (in text mode) or size bytes (in binary mode) are read and returned. If the end of the file has been reached, will return an empty string ( ). 'This is the entire file.\n\n' reads a single line from the file; a newline character ( ) is left at the end of the string, and is only omitted on the last line of the file if the file doesn’t end in a newline. This makes the return value unambiguous; if returns an empty string, the end of the file has been reached, while a blank line is represented by , a string containing only a single newline. 'This is the first line of the file.\n\n' 'Second line of the file\n\n' For reading lines from a file, you can loop over the file object. This is memory efficient, fast, and leads to simple code: This is the first line of the file. If you want to read all the lines of a file in a list you can also use or . writes the contents of string to the file, returning the number of characters written. Other types of objects need to be converted – either to a string (in text mode) or a bytes object (in binary mode) – before writing them: returns an integer giving the file object’s current position in the file represented as number of bytes from the beginning of the file when in binary mode and an opaque number when in text mode. To change the file object’s position, use . The position is computed from adding offset to a reference point; the reference point is selected by the whence argument. A whence value of 0 measures from the beginning of the file, 1 uses the current file position, and 2 uses the end of the file as the reference point. whence can be omitted and defaults to 0, using the beginning of the file as the reference point. # Go to the 6th byte in the file # Go to the 3rd byte before the end In text files (those opened without a in the mode string), only seeks relative to the beginning of the file are allowed (the exception being seeking to the very file end with ) and the only valid offset values are those returned from the , or zero. Any other offset value produces undefined behaviour. File objects have some additional methods, such as and which are less frequently used; consult the Library Reference for a complete guide to file objects. Strings can easily be written to and read from a file. Numbers take a bit more effort, since the method only returns strings, which will have to be passed to a function like , which takes a string like and returns its numeric value 123. When you want to save more complex data types like nested lists and dictionaries, parsing and serializing by hand becomes complicated. Rather than having users constantly writing and debugging code to save complicated data types to files, Python allows you to use the popular data interchange format called JSON (JavaScript Object Notation). The standard module called can take Python data hierarchies, and convert them to string representations; this process is called serializing. Reconstructing the data from the string representation is called deserializing. Between serializing and deserializing, the string representing the object may have been stored in a file or data, or sent over a network connection to some distant machine. The JSON format is commonly used by modern applications to allow for data exchange. Many programmers are already familiar with it, which makes it a good choice for interoperability. If you have an object , you can view its JSON string representation with a simple line of code: Another variant of the function, called , simply serializes the object to a text file. So if is a text file object opened for writing, we can do this: To decode the object again, if is a binary file or text file object which has been opened for reading: JSON files must be encoded in UTF-8. Use when opening JSON file as a text file for both of reading and writing. This simple serialization technique can handle lists and dictionaries, but serializing arbitrary class instances in JSON requires a bit of extra effort. The reference for the module contains an explanation of this. Contrary to JSON, pickle is a protocol which allows the serialization of arbitrarily complex Python objects. As such, it is specific to Python and cannot be used to communicate with applications written in other languages. It is also insecure by default: deserializing pickle data coming from an untrusted source can execute arbitrary code, if the data was crafted by a skilled attacker."
    },
    {
        "link": "https://geeksforgeeks.org/file-handling-python",
        "document": "File handling refers to the process of performing operations on a file such as creating, opening, reading, writing and closing it, through a programming interface. It involves managing the data flow between the program and the file system on the storage device, ensuring that data is handled safely and efficiently.\n\nTo open a file we can use function, which requires file path and mode as arguments:\n\nWhen opening a file, we must specify the mode we want to which specifies what we want to do with the file. Here’s a table of the different modes available:\n\nOpens the file for reading. File must exist; otherwise, it raises an error. Opens the file for reading binary data. File must exist; otherwise, it raises an error. Opens the file for both reading and writing. File must exist; otherwise, it raises an error. Opens the file for both reading and writing binary data. File must exist; otherwise, it raises an error. Opens the file for writing. Creates a new file or truncates the existing file. Opens the file for writing binary data. Creates a new file or truncates the existing file. Opens the file for both writing and reading. Creates a new file or truncates the existing file. Opens the file for both writing and reading binary data. Creates a new file or truncates the existing file. Opens the file for appending data. Creates a new file if it doesn’t exist. Opens the file for appending binary data. Creates a new file if it doesn’t exist. Opens the file for appending and reading. Creates a new file if it doesn’t exist. Opens the file for appending and reading binary data. Creates a new file if it doesn’t exist. Creates a new file. Raises an error if the file already exists. Creates a new binary file. Raises an error if the file already exists. Creates a new file for reading and writing. Raises an error if the file exists. Exclusive creation with read and write in binary mode. Creates a new binary file for reading and writing. Raises an error if the file exists.\n\nFor this article we are using text file with text:\n\nReading a file can be achieved by file.read() which reads the entire content of the file. After reading the file we can close the file using file.close() which closes the file after reading it, which is necessary to free up system resources.\n\nWriting to a file is done using file.write() which writes the specified string to the file. If the file exists, its content is erased. If it doesn’t exist, a new file is created.\n\nExample: Writing to a File in Write Mode (w)\n\nIt is done using adds the specified string to the end of the file without erasing its existing content.\n\nExample: For this example, we will use the Python file created in the previous example.\n\nClosing a file is essential to ensure that all resources used by the file are properly released. loses the file and ensures that any changes made to the file are saved.\n\nstatement is used for resource management. It ensures that file is properly closed after its suite finishes, even if an exception is raised. with open() as method automatically handles closing the file once the block of code is exited, even if an error occurs. This reduces the risk of file corruption and resource leakage.\n\nIt’s important to handle exceptions to ensure that files are closed properly, even if an error occurs during file operations.\n• None Versatility : File handling in Python allows us to perform a wide range of operations, such as creating, reading, writing, appending, renaming and deleting files.\n• Flexibility : File handling in Python is highly flexible, as it allows us to work with different file types (e.g. text files, binary files, CSV files , etc.) and to perform different operations on files (e.g. read, write, append, etc.).\n• User – friendly : Python provides a user-friendly interface for file handling, making it easy to create, read and manipulate files.\n• Cross-platform : Python file-handling functions work across different platforms (e.g. Windows, Mac, Linux), allowing for seamless integration and compatibility.\n• Error-prone: File handling operations in Python can be prone to errors, especially if the code is not carefully written or if there are issues with the file system (e.g. file permissions, file locks, etc.).\n• Security risks : File handling in Python can also pose security risks, especially if the program accepts user input that can be used to access or modify sensitive files on the system.\n• Complexity : File handling in Python can be complex, especially when working with more advanced file formats or operations. Careful attention must be paid to the code to ensure that files are handled properly and securely.\n• Performance : File handling operations in Python can be slower than other programming languages, especially when dealing with large files or performing complex operations.\n\nWhat are the types of files in Python?\n\nWhat are the 4 file handling functions?\n\nWhy is file handling useful?\n\nIn Python file handling, is a method of file objects that returns the current position of the file pointer (cursor) within the file. It returns an integer representing the byte offset from the beginning of the file where the next read or write operation will occur. # Open a file in read mode file = open('example.txt', 'r') # Read the first 10 characters content = file.read(10) print(content) # Check the current position of the file pointer position = file.tell() print(\"Current position:\", position) # Close the file file.close()\n• None reads the first 10 characters from the file.\n• None returns the current position of the file pointer after reading."
    },
    {
        "link": "https://freecodecamp.org/news/file-handling-in-python",
        "document": "In this tutorial, you will learn how to open a file, write to the file, and close it. You will also learn how to read from the file using Python.\n\nBy the end of this tutorial, you should know the basics of how to use files in Python.\n\nFile handling is an important activity in every web app. The types of activities that you can perform on the opened file are controlled by Access Modes. These describe how the file will be used after it has been opened.\n\nThese modes also specify where the file handle should be located within the file. Similar to a pointer, a file handle indicates where data should be read or put into the file.\n\nIn Python, there are six methods or access modes, which are:\n• Read Only ('r’): This mode opens the text files for reading only. The start of the file is where the handle is located. It raises the I/O error if the file does not exist. This is the default mode for opening files as well.\n• Read and Write ('r+’): This method opens the file for both reading and writing. The start of the file is where the handle is located. If the file does not exist, an I/O error gets raised.\n• Write Only ('w’): This mode opens the file for writing only. The data in existing files are modified and overwritten. The start of the file is where the handle is located. If the file does not already exist in the folder, a new one gets created.\n• Write and Read ('w+’): This mode opens the file for both reading and writing. The text is overwritten and deleted from an existing file. The start of the file is where the handle is located.\n• Append Only ('a’): This mode allows the file to be opened for writing. If the file doesn't yet exist, a new one gets created. The handle is set at the end of the file. The newly written data will be added at the end, following the previously written data.\n• Append and Read (‘a+’): Using this method, you can read and write in the file. If the file doesn't already exist, one gets created. The handle is set at the end of the file. The newly written text will be added at the end, following the previously written data.\n\nBelow is the code required to create, write to, and read text files using the Python file handling methods or access modes.\n\nHow to Create Files in Python\n\nIn Python, you use the function with one of the following options – \"x\" or \"w\" – to create a new file:\n• \"x\" – Create: this command will create a new file if and only if there is no file already in existence with that name or else it will return an error.\n\nExample of creating a file in Python using the \"x\" command:\n\nWe've now created a new empty text file! But if you retry the code above – for example, if you try to create a new file with the same name as you used above (if you want to reuse the filename above) you will get an error notifying you that the file already exists. It'll look like the image below:\n• \"w\" – Write: this command will create a new text file whether or not there is a file in the memory with the new specified name. It does not return an error if it finds an existing file with the same name – instead it will overwrite the existing file.\n\nExample of how to create a file with the \"w\" command:\n\nWith the code above, whether the file exists or the file doesn't exist in the memory, you can still go ahead and use that code. Just keep in mind that it will overwrite the file if it finds an existing file with the same name.\n\nHow to Write to a File in Python\n\nThere are two methods of writing to a file in Python, which are:\n\nThis function inserts the string into the text file on a single line.\n\nBased on the file we have created above, the below line of code will insert the string into the created text file, which is \"myfile.txt.”\n\nThis function inserts multiple strings at the same time. A list of string elements is created, and each string is then added to the text file.\n\nUsing the previously created file above, the below line of code will insert the string into the created text file, which is \"myfile.txt.”\n\nHow to Read From a Text File in Python\n\nThere are three methods of reading data from a text file in Python. They are:\n\nThis function returns the bytes read as a string. If no n is specified, it then reads the entire file.\n\nThis function reads a line from a file and returns it as a string. It reads at most n bytes for the specified n. But even if n is greater than the length of the line, it does not read more than one line.\n\nThis function reads all of the lines and returns them as string elements in a list, one for each line.\n\nYou can read the first two lines by calling twice, reading the first two lines of the file:\n\nHow to Close a Text File in Python\n\nIt is good practice to always close the file when you are done with it.\n\nThis function closes the text file when you are done modifying it:\n\nThe close() function at the end of the code tells Python that well, I am done with this section of either creating or reading – it is just like saying End.\n\nThe program below shows more examples of ways to read and write data in a text file. Each line of code has comments to help you understand what's going on:\n\nThis is the output of the above code when run in the shell. I assigned \"This is Lagos\", \"This is Python\", and \"This is Fcc\" to \"L\" and then asked it to print using the ''file.read'' function.\n\nThe code above shows that the \"readline()\" function is returning the letter based on the number specified to it, while the \"readlines()\" function is returning every string assigned to \"L\" including the \n\n. That is, the \"readlines()\" function will print out all data in the file.\n\nHopefully, after going through this tutorial, you should understand what file handling is in Python. We also learned the modes/methods required to create, write, read, and close() a text file using some basic examples from Python."
    }
]