[
    {
        "link": "https://geeksforgeeks.org/comparator-interface-java",
        "document": "Comparator interface in Java is used to order the objects of user-defined classes. A comparator object is capable of comparing two objects of the same class. Following function compare obj1 with obj2.\n\nSuppose we have an Array/ArrayList of our own class type, containing fields like roll no, name, address, DOB, etc, and we need to sort the array based on Roll no or name?\n• Method 1: One obvious approach is to write our own sort() function using one of the standard algorithms. This solution requires rewriting the whole sorting code for different criteria like Roll No. and Name.\n• Method 2: Using comparator interface – Comparator interface is used to order the objects of a user-defined class. This interface is present in java.util package and contains 2 methods compare(Object obj1, Object obj2) and equals(Object element). Using a comparator, we can sort the elements based on data members. For instance, it may be on roll no, name, age, or anything else.\n\nHow do the sort() method of Collections class work?\n\nMethod of Collections class for sorting List elements is used to sort the elements of List by the given comparator.\n\nTo sort a given List, ComparatorClass must implement a Comparator interface.\n\nInternally the Sort method does call Compare method of the classes it is sorting. To compare two elements, it asks “Which is greater?” Compare method returns -1, 0, or 1 to say if it is less than, equal, or greater to the other. It uses this result to then determine if they should be swapped for their sort.\n\nBy changing the return value inside the compare method, you can sort in any order that you wish to, for example: For descending order just change the positions of ‘a’ and ‘b’ in the above compare method.\n\nSort Collection by more than one field\n\nIn the previous example, we have discussed how to sort the list of objects on the basis of a single field using the Comparable and Comparator interface But, what if we have a requirement to sort ArrayList objects in accordance with more than one field like firstly, sort according to the student name and secondly, sort according to student age.\n\nWe can use the method mentioned below for achieving same results"
    },
    {
        "link": "https://stackoverflow.com/questions/20393524/how-does-a-static-method-use-a-comparator",
        "document": "For using a Comparator, there is no difference between using it from a static- or non-static method. In either case an instance of the Comparator has to be used.\n\nThe Garbage Collector of modern JVMs is very efficient at handling short-lived objects. Therefore the penalty to be paid for using a fresh instance (via new) every time is usually no issue. However, if you don't want to use a fresh instance every time, I think the best option would be to add a static field to your SportsMenComparator, containing a singleton instance of the comparator:"
    },
    {
        "link": "https://stackoverflow.com/questions/2839137/how-to-use-comparator-in-java-to-sort",
        "document": "Use instead; this defines the natural ordering for .\n\nA can also be defined in addition, but is not the right way of doing things.\n\nThe two overloads for are different:\n\nYou're confusing the two by trying to sort a (which is again why it doesn't make sense that ). Again, to use , you need one of these to be true:\n• The type must be (use the 1-arg )\n• A for the type must be provided (use the 2-args )\n• When to use Comparable vs Comparator\n\nAlso, do not use raw types in new code. Raw types are unsafe, and it's provided only for compatibility.\n\nThat is, instead of this:\n\nyou should've used the typesafe generic declaration like this:\n\nYou will then find that your code doesn't even compile!! That would be a good thing, because there IS something wrong with the code ( does not ), but because you used raw type, the compiler didn't check for this, and instead you get a at run-time!!!\n\nThis should convince you to always use typesafe generic types in new code. Always.\n• What is a raw type and why shouldn't we use it?"
    },
    {
        "link": "https://geeksforgeeks.org/implement-priorityqueue-comparator-java",
        "document": "Prerequisite : Priority Queue, Comparator Priority Queue is like a regular queue, but each element has a “priority” associated with it. In a priority queue, an element with high priority is served before an element with low priority. For this, it uses a comparison function which imposes a total ordering of the elements.\n\nThe elements of the priority queue are ordered according to their natural ordering, or by a Comparator provided at queue construction time, depending on which constructor is used Constructors :\n• public PriorityQueue() : This creates a PriorityQueue with the default initial capacity (11) that orders its elements according to their natural ordering.\n• public PriorityQueue(Collection c) : This creates a PriorityQueue containing the elements in the specified collection(c). If the specified collection is an instance of a SortedSet, this priority queue will be ordered according to the same ordering, else this priority queue will be ordered according to the natural ordering of its elements.\n• public PriorityQueue(int capacity, Comparator comparator) : This creates a PriorityQueue with the specified initial capacity that orders its elements according to the specified comparator.\n• public PriorityQueue(SortedSet ss) : Creates a PriorityQueue containing the elements in the specified sorted set. This priority queue will be ordered according to the same ordering as the given sorted set.\n\nSample code provided illustrates students with high priority(based on cgpa) are served before the students having low cgpa.\n\nNote : This type of Priority queue is preferred in scenarios where customized ordering is required, i.e when one wants a different sorting order, then one can define its own way of comparing instances. Comparator can be implemented if there is a more complex comparing algorithm, e.g. multiple fields and so on."
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html",
        "document": "A comparison function, which imposes aon some collection of objects. Comparators can be passed to a sort method (such as or ) to allow precise control over the sort order. Comparators can also be used to control the order of certain data structures (such as or ), or to provide an ordering for collections of objects that don't have a\n\nThe ordering imposed by a comparator on a set of elements is said to be consistent with equals if and only if has the same boolean value as for every and in .\n\nCaution should be exercised when using a comparator capable of imposing an ordering inconsistent with equals to order a sorted set (or sorted map). Suppose a sorted set (or sorted map) with an explicit comparator is used with elements (or keys) drawn from a set . If the ordering imposed by on is inconsistent with equals, the sorted set (or sorted map) will behave \"strangely.\" In particular the sorted set (or sorted map) will violate the general contract for set (or map), which is defined in terms of .\n\nFor example, suppose one adds two elements and such that to an empty with comparator . The second operation will return true (and the size of the tree set will increase) because and are not equivalent from the tree set's perspective, even though this is contrary to the specification of the method.\n\nNote: It is generally a good idea for comparators to also implement , as they may be used as ordering methods in serializable data structures (like , ). In order for the data structure to serialize successfully, the comparator (if provided) must implement .\n\nFor the mathematically inclined, the relation that defines the imposed ordering that a given comparator imposes on a given set of objects is:\n\nThefor this total order is:It follows immediately from the contract forthat the quotient is anon, and that the imposed ordering is aon. When we say that the ordering imposed byonis, we mean that the quotient for the ordering is the equivalence relation defined by the objects' method(s):\n\nUnlike , a comparator may optionally permit comparison of null arguments, while maintaining the requirements for an equivalence relation.\n\nThis interface is a member of the Java Collections Framework."
    },
    {
        "link": "https://geeksforgeeks.org/queue-interface-java",
        "document": "The Queue Interface is present in java.util package and extends the Collection interface. It stores and processes the data in FIFO(First In First Out) order. It is an ordered list of objects limited to inserting elements at the end of the list and deleting elements from the start of the list.\n• No Null Elements do not allow null elements.\n• Use Cases : Commonly used for Task scheduling, Message passing, and Buffer management in applications.\n• Iteration : Supports iterating through elements. The order of iteration depends on the implementation.\n\nBeing an interface the queue needs a concrete class for the declaration and the most common classes are the PriorityQueue and LinkedList in Java. Note that neither of these implementations is thread-safe. PriorityBlockingQueue is one alternative implementation if the thread-safe implementation is needed.\n\nThe Queue interface is declared as:\n\nSince Queue is an interface, objects cannot be created of the type queue. We always need a class which extends this list in order to create an object. And also, after the introduction of Generics in Java 1.5, it is possible to restrict the type of object that can be stored in the Queue. This type-safe queue can be defined as:\n\nIn Java, the Queue interface is a subtype of the Collection interface and represents a collection of elements in a specific order. It follows the first-in, first-out (FIFO) principle, which means that the elements are retrieved in the order in which they were added to the queue.\n\nThe Queue interface provides several methods for adding, removing, and inspecting elements in the queue. Here are some of the most commonly used methods:\n• add(element) : Adds an element to the rear of the queue. If the queue is full, it throws an exception.\n• offer(element) : Adds an element to the rear of the queue. If the queue is full, it returns false.\n• remove() : Removes and returns the element at the front of the queue. If the queue is empty, it throws an exception.\n• poll() : Removes and returns the element at the front of the queue. If the queue is empty, it returns null.\n• element() : Returns the element at the front of the queue without removing it. If the queue is empty, it throws an exception.\n• peek() : Returns the element at the front of the queue without removing it. If the queue is empty, it returns null.\n\nThe Queue interface is implemented by several classes in Java, including LinkedList, ArrayDeque, and PriorityQueue. Each of these classes provides different implementations of the queue interface, with different performance characteristics and features.\n\nOverall, the Queue interface is a useful tool for managing collections of elements in a specific order, and is widely used in many different applications and industries.\n\nLet’s see how to perform a few frequently used operations on the queue using the Priority Queue class.\n\nIn order to add an element in a queue, we can use the add() method. The insertion order is not retained in the PriorityQueue. The elements are stored based on the priority order which is ascending by default.\n\nIn order to remove an element from a queue, we can use the remove() method. If there are multiple such objects, then the first occurrence of the object is removed. Apart from that, poll() method is also used to remove the head and return it.\n\nThere are multiple ways to iterate through the Queue. The most famous way is converting the queue to the array and traversing using the for loop. However, the queue also has an inbuilt iterator which can be used to iterate through the queue.\n\nThe following are the characteristics of the queue:\n• None The Queue is used to insert elements at the end of the queue and removes from the beginning of the queue. It follows FIFO concept.\n• None The Java Queue supports all methods of Collection interface including insertion, deletion, etc.\n• None are the most frequently used implementations.\n• None If any null operation is performed on BlockingQueues, NullPointerException is thrown.\n• None The Queues which are available in java.util package are Unbounded Queues.\n• None The Queues which are available in java.util.concurrent package are the Bounded Queues.\n• None All Queues except the Deques supports insertion and removal at the tail and head of the queue respectively. The Deques support element insertion and removal at both ends.\n\nPriorityQueue class which is implemented in the collection framework provides us a way to process the objects based on the priority. It is known that a queue follows the First-In-First-Out algorithm, but sometimes the elements of the queue are needed to be processed according to the priority, that’s when the PriorityQueue comes into play. Let’s see how to create a queue object using this class.\n\nLinkedList is a class which is implemented in the collection framework which inherently implements the linked list data structure. It is a linear data structure where the elements are not stored in contiguous locations and every element is a separate object with a data part and address part. The elements are linked using pointers and addresses. Each element is known as a node. Due to the dynamicity and ease of insertions and deletions, they are preferred over the arrays or queues. Let’s see how to create a queue object using this class.\n\nIt is to be noted that both the implementations, the PriorityQueue and LinkedList are not thread-safe. PriorityBlockingQueue is one alternative implementation if thread-safe implementation is needed. PriorityBlockingQueue is an unbounded blocking queue that uses the same ordering rules as class PriorityQueue and supplies blocking retrieval operations. \n\nSince it is unbounded, adding elements may sometimes fail due to resource exhaustion resulting in OutOfMemoryError. Let’s see how to create a queue object using this class.\n\nThe queue interface inherits all the methods present in the collections interface while implementing the following methods:\n\nThis method is used to add an element at a particular index in the queue. When a single parameter is passed, it simply adds the element at the end of the queue. This method is used to add all the elements in the given collection to the queue. When a single parameter is passed, it adds all the elements of the given collection at the end of the queue. This method is used to return the size of the queue. This method is used to remove all the elements in the queue. However, the reference of the queue created is still stored. This method is used to remove the element from the front of the queue. This method removes an element from the specified index. It shifts subsequent elements(if any) to left and decreases their indexes by 1. This method is used to remove and return the first occurrence of the given element in the queue. This method returns elements at the specified index. This method replaces elements at a given index with the new element. This function returns the element which was just replaced by a new element. This method returns the first occurrence of the given element or -1 if the element is not present in the queue. This method returns the last occurrence of the given element or -1 if the element is not present in the queue. This method is used to compare the equality of the given element with the elements of the queue. This method is used to return the hashcode value of the given queue. This method is used to check if the queue is empty or not. It returns true if the queue is empty, else false. This method is used to check if the queue contains the given element or not. It returns true if the queue contains the element. This method is used to check if the queue contains all the collection of elements. This method is used to sort the elements of the queue on the basis of the given This method is used to insert the specified element into a queue and return true upon success. This method is used to insert the specified element into the queue. This method is used to retrieve and removes the head of the queue, or returns null if the queue is empty. This method is used to retrieves, but does not remove, the head of queue. This method is used to retrieves, but does not remove, the head of this queue, or returns null if this queue is empty.\n\nAdvantages of using the Queue Interface in Java\n• Order preservation : The Queue interface provides a way to store and retrieve elements in a specific order, following the first-in, first-out (FIFO) principle.\n• Flexibility : The Queue interface is a subtype of the Collection interface, which means that it can be used with many different data structures and algorithms, depending on the requirements of the application.\n• Thread safety : Some implementations of the Queue interface, such as the java.util.concurrent.ConcurrentLinkedQueue class, are thread-safe, which means that they can be accessed by multiple threads simultaneously without causing conflicts.\n• Performance : The Queue interface provides efficient implementations for adding, removing, and inspecting elements, making it a useful tool for managing collections of elements in performance-critical applications.\n\nDisadvantages of using the Queue Interface in Java\n• Limited functionality: The Queue interface is designed specifically for managing collections of elements in a specific order, which means that it may not be suitable for more complex data structures or algorithms.\n• Size restrictions: Some implementations of the Queue interface, such as the ArrayDeque class, have a fixed size, which means that they cannot grow beyond a certain number of elements.\n• Memory usage: Depending on the implementation, the Queue interface may require more memory than other data structures, especially if it needs to store additional information about the order of the elements.\n• Complexity : The Queue interface can be difficult to use and understand for novice programmers, especially if they are not familiar with the principles of data structures and algorithms."
    },
    {
        "link": "https://stackoverflow.com/questions/2555284/java-priority-queue-with-a-custom-anonymous-comparator",
        "document": "Forgive me if this is a tried question, but I'm having a little difficulty figuring it out.\n\nI currently have a class Node, and each 'node' is a square in a maze. I'm trying to implement the A* algorithm, so each of these nodes will have an f-cost (int) data member inside of it. I was wondering if there's a way that I can create a priority queue of these nodes, and set up the f-cost variable as the comparator?\n\nI've looked at examples online, but all I can find are String priority queues. Can I implement Comparator for the Node class? Would this allow me to access the data member stored inside it?"
    },
    {
        "link": "https://geeksforgeeks.org/implement-priorityqueue-comparator-java",
        "document": "Prerequisite : Priority Queue, Comparator Priority Queue is like a regular queue, but each element has a “priority” associated with it. In a priority queue, an element with high priority is served before an element with low priority. For this, it uses a comparison function which imposes a total ordering of the elements.\n\nThe elements of the priority queue are ordered according to their natural ordering, or by a Comparator provided at queue construction time, depending on which constructor is used Constructors :\n• public PriorityQueue() : This creates a PriorityQueue with the default initial capacity (11) that orders its elements according to their natural ordering.\n• public PriorityQueue(Collection c) : This creates a PriorityQueue containing the elements in the specified collection(c). If the specified collection is an instance of a SortedSet, this priority queue will be ordered according to the same ordering, else this priority queue will be ordered according to the natural ordering of its elements.\n• public PriorityQueue(int capacity, Comparator comparator) : This creates a PriorityQueue with the specified initial capacity that orders its elements according to the specified comparator.\n• public PriorityQueue(SortedSet ss) : Creates a PriorityQueue containing the elements in the specified sorted set. This priority queue will be ordered according to the same ordering as the given sorted set.\n\nSample code provided illustrates students with high priority(based on cgpa) are served before the students having low cgpa.\n\nNote : This type of Priority queue is preferred in scenarios where customized ordering is required, i.e when one wants a different sorting order, then one can define its own way of comparing instances. Comparator can be implemented if there is a more complex comparing algorithm, e.g. multiple fields and so on."
    },
    {
        "link": "https://stackoverflow.com/questions/40766984/how-to-build-priority-queue-with-customized-comparator-in-linear-time",
        "document": "In the constructor of PriorityQueue, we can pass in a collection like List or Set, which builds the PriorityQueue in linear time. However, this also means the PriorityQueue will use a default Comparator.\n\nI want to use my own comparator, so I can have something else other than a min heap. The only way I can think of is to wrap the collection in a SortedSet and put a customized comparator in it.\n\nIs there any other good way to do this?"
    },
    {
        "link": "https://medium.com/@pratik.941/mastering-the-queue-interface-in-java-6e4710036eee",
        "document": "The `Queue` interface is a part of the Java Collections Framework and represents a collection designed for holding elements prior to processing. Queues are an essential data structure in computer science, commonly used for managing tasks in a first-in, first-out (FIFO) manner. In this article, we will explore the `Queue` interface in Java, its common implementations, and how to effectively use it in your Java programs.\n\nA `Queue` is a collection that orders elements in a FIFO (first-in, first-out) sequence. This means that elements are added to the end of the queue and removed from the front. The `Queue` interface extends the `Collection` interface and provides additional methods for inserting, removing, and inspecting elements.\n\nKey Characteristics of Queues:\n\n- FIFO Ordering: The first element added is the first element removed.\n\n- Capacity Restrictions: Some queue implementations may have a fixed capacity, while others are dynamically resizable.\n\n- Specialized Subtypes: Includes `Deque` for double-ended queues, and `BlockingQueue` for thread-safe queues with blocking operations.\n\nJava provides several classes that implement the `Queue` interface, each with its own characteristics and use cases:\n\n`LinkedList` is a doubly linked list implementation that can be used as a queue.\n\nCharacteristics:\n\n- Unbounded: Can grow dynamically as needed.\n\n- FIFO Ordering: Maintains the order of elements as they are inserted.\n\n- Not Synchronized: Not thread-safe, must be synchronized externally if used in a concurrent environment.\n\n`PriorityQueue` is a queue that orders elements based on their natural ordering or by a comparator provided at queue construction time.\n\nCharacteristics:\n\n- Unbounded: Grows dynamically as needed.\n\n- Ordering: Orders elements according to their natural ordering or a provided comparator.\n\n- Not Synchronized: Not thread-safe, must be synchronized externally if used in a concurrent environment.\n\n`ArrayDeque` is a resizable array implementation of the `Deque` interface, which extends `Queue`.\n\nCharacteristics:\n\n- Unbounded: Can grow dynamically as needed.\n\n- Double-ended: Can be used as both a queue and a stack.\n\n- Not Synchronized: Not thread-safe, must be synchronized externally if used in a concurrent environment.\n\n`BlockingQueue` is an interface that represents a thread-safe queue supporting operations that wait for the queue to become non-empty when retrieving an element and wait for space to become available in the queue when storing an element.\n\nCommon Implementations:\n\n- ArrayBlockingQueue: A bounded blocking queue backed by an array.\n\n- LinkedBlockingQueue: An optionally bounded blocking queue backed by linked nodes.\n\n- PriorityBlockingQueue: An unbounded blocking queue that uses the same ordering rules as `PriorityQueue`.\n\nAdding Elements:\n\n- `add(E e)`: Inserts the specified element into the queue if it is possible to do so immediately without violating capacity restrictions.\n\n- `offer(E e)`: Inserts the specified element into the queue if it is possible to do so immediately without violating capacity restrictions. Returns `false` if the element cannot be added.\n\nRemoving Elements:\n\n- `remove()`: Retrieves and removes the head of the queue. Throws an exception if the queue is empty.\n\n- `poll()`: Retrieves and removes the head of the queue, or returns `null` if the queue is empty.\n\nAccessing Elements:\n\n- `element()`: Retrieves, but does not remove, the head of the queue. Throws an exception if the queue is empty.\n\n- `peek()`: Retrieves, but does not remove, the head of the queue, or returns `null` if the queue is empty.\n\nIterating Over Elements:\n\n- `forEach(Consumer<? super E> action)`: Performs the given action for each element of the queue.\n\n- `iterator()`: Returns an iterator over the elements in the queue.\n\nExample of Iterating Over Elements Using `forEach`:\n\nExample of Iterating Over Elements Using `iterator`:\n\nChoosing the right queue implementation depends on your specific needs:\n\n- Use `LinkedList` when you need a basic, unbounded FIFO queue.\n\n- Use `PriorityQueue` when you need to process elements based on their natural ordering or a custom comparator.\n\n- Use `ArrayDeque` when you need a double-ended queue that can be used as both a stack and a queue.\n\n- Use `BlockingQueue` (e.g., `ArrayBlockingQueue`, `LinkedBlockingQueue`, `PriorityBlockingQueue`) for thread-safe, blocking operations, typically in concurrent programming.\n\nUnderstanding these different queue implementations and their use cases will help you write more efficient and effective Java code. The Java Collections Framework provides a powerful set of tools that can handle most of your data manipulation needs."
    }
]