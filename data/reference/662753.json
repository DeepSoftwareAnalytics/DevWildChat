[
    {
        "link": "https://reddit.com/r/Database/comments/oaffk2/best_practices_for_storing_passwords_in_database",
        "document": "I am volunteering on a project to overhaul a very poorly-designed database. There were many problems but one of the more alarming is that currently administrator passwords are being stored in decryptable hashes. If breached, it would be trivial to crack these. We are using MariaDB currently.\n\nThis got me wondering what the current best method is. In this use case, we have an e-mail account associated with each student that is their official e-mail. We considered a system that would generate a one-time code to set up their profile but this isn't very reusable.\n\nIf we need to store passwords in the database, what is the best way to achieve this safely? I have read a bit about the \"salt\" approach and this particular article seems promising: https://www.mssqltips.com/sqlservertip/4037/storing-passwords-in-a-secure-way-in-a-sql-server-database/\n\nThe goal is to have persistent profiles for students to edit as well as persistent profiles for organizations that they could edit. I know there is some salt implementation built into MariaDB but for the most part it appears to be only for accessing the the DB as an admin itself.\n\nThis is one of those subjects that comes up often but I've seen a lot of conflicting opinions on it. I am curious what people think is the best solution to keep passwords protected without completely destroying performance (I know some suggest bcrypt).\n\nAs always, I appreciate the opinions, insights, and expertise of this community and thank everyone who reads this."
    },
    {
        "link": "https://netwrix.com/sql-server-security-best-practices.html",
        "document": ""
    },
    {
        "link": "https://satoricyber.com/sql-server-security/sql-server-security-best-practices",
        "document": "What are SQL Server Security Best Practices? SQL Server is Microsoft’s popular relational database. It comes with a rich set of features, including capabilities you can use to secure your information. There is a wide range of SQL Server security best practices you can implement to protect your database and maintain compliance as needed. This article explains six notable best practices, including a few tips to help you get started. In this article, you will learn about the following SQL Server security best practices:\n\nTo prevent potential attacks and help support forensic analysis efforts, you should perform regular audits of server security, permissions, and logins. These audits do not only contribute to improving your security posture, but are also often required by regulations like the General Data Protection Regulation (GDPR) and the Health Insurance Portability and Accountability Act (HIPAA). Ensure you keep track of the information most relevant for auditors. For example, you can choose to monitor common compliance criteria, as well as user logins and login auditing. You can also monitor C2 auditing, server configuration, schema changes, etc. The key is to perform audits on a regular basis, to learn about issues that need to be remediated and act on them. Auditing is, of course, only valuable if you invest resources to remediate security weaknesses found. Learn more in our detailed guide to SQL Server Audit functionality\n\nSQL Server services are each configured to run under a predefined Active Directory (AD) or Windows account. When specifying privileges for each account, you should use the principle of least privilege to ensure that each account works with the minimum system rights and permission it needs. Ideally, you should assign a separate account for each service. The account should be a member of a security group. This configuration can prevent issues if an account for one service is damaged or compromised, ensuring that other services continue normal operations. You can set this up in the Server Configuration Manager. Here are the common types of accounts you can configure for your SQL Server services:\n• AD-managed service account—an account that cannot log on to a server, and is therefore considered more secure than domain-user accounts. Additionally, there is no need to manually manage password resets for accounts.\n• Domain user account—an account that runs services. It does not come with administrator privileges, and is therefore considered secure in a domain environment.\n• Local system account—a highly privileged account which should not be used to run services.\n• Network service account—comes with fewer privileges than system accounts, but it still enables a service to gain access to network resources.\n\nHere are several user authentication options you can use in SQL Server:\n• SQL Server Authentication mode—allows only AD or Windows users to connect to your SQL Server. If you use this mode, it is recommended to disable the system administrator (sa) account.\n• Windows Authentication mode—allows only AD or Windows users to connect to your SQL Server. In this case, SQL Server does not directly authenticate users. Instead, it permits access according to an access token that was previously issued to the logged in user.\n• SQL Server and Windows Authentication mode—also called mixed authentication, this mode allows SQL and Windows logins, like sa accounts, to gain access to SQL Server. When managing SQL Server authentication, it is preferable to use Windows Authentication, which can take advantage of features like AD accounts, groups, and password policies.\n\nSQL monitoring tools can help scan the processes of your database application as well as monitor all changes that occur to database server settings. These tools can promptly detect session anomalies and errors, as well as SQL statements that grant access to sensitive data. Keep in mind that since monitoring tools are integrated into the ecosystem, the tools themselves can represent a security risk. Ensure that they comply with your security and compliance requirements."
    },
    {
        "link": "https://security.stackexchange.com/questions/278509/whats-the-safest-way-to-store-a-password-in-database",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://stackoverflow.com/questions/615704/preferred-method-of-storing-passwords-in-database",
        "document": "You can use multiple hashes in your database, it just requires a little bit of extra effort. It's well worth it though if you think there's the remotest chance you'll need to support additional formats in the future. I'll often use password entries like\n\nwhere \"hashId\" is just some number I use internally to recognize that, e.g., I'm using SHA1 with a specific hash pattern; \"salt\" is a base64-encoded random salt; and \"hashed password\" is a base64-encoded hash. If you need to migrate hashes you can intercept people with an old password format and make them change their password the next time they log in.\n\nAs others have mentioned you want to be careful with your hashes since it's easy to do something that's not really secure, e.g., H(salt,password) is far weaker than H(password,salt), but at the same time you want to balance the effort put into this with the value of the site content. I'll often use H(H(password,salt),password).\n\nFinally, the cost of using base64-encoded passwords is modest when compared to the benefits of being able to use various tools that expect text data. Yeah, they should be more flexible, but are you ready to tell your boss that he can't use his favorite third party tool because you want to save a few bytes per record? :-)\n\nEdited to add one other comment: if I suggested deliberately using an algorithm that burned even a 1/10th of a second hashing each password I would be lucky to just be laughed out of my boss's office. (Not so lucky? He would jot something down to discuss at my next annual review.) Burning that time isn't a problem when you have dozens, or even hundreds, of users. If you're pushing 100k users you'll usually have multiple people logging in at the same time. You need something fast and strong, not slow and strong. The \"but what about the credit card information?\" is disingenuous at best since stored credit card information shouldn't be anywhere near your regular database, and would be encrypted by the application anyway, not individual users."
    },
    {
        "link": "https://learn.microsoft.com/en-us/sql/relational-databases/security/sql-injection?view=sql-server-ver16",
        "document": "SQL injection is an attack in which malicious code is inserted into strings that are later passed to an instance of the SQL Server Database Engine for parsing and execution. Any procedure that constructs SQL statements should be reviewed for injection vulnerabilities, because the Database Engine executes all syntactically valid queries that it receives. Even parameterized data can be manipulated by a skilled and determined attacker.\n\nThe primary form of SQL injection consists of direct insertion of code into user-input variables that are concatenated with SQL commands and executed. A less direct attack injects malicious code into strings that are destined for storage in a table or as metadata. When the stored strings are then concatenated into a dynamic SQL command, the malicious code is executed.\n\nThe injection process works by prematurely terminating a text string and appending a new command. Because the inserted command might have extra strings appended to it before it executes, the malefactor terminates the injected string with a comment mark . Subsequent text is ignored at execution time.\n\nThe following script shows a simple SQL injection. The script builds a SQL query by concatenating hard-coded strings together with a string entered by the user:\n\nThe user is prompted to enter the name of a city. If they enter , the query assembled by the script looks similar to the following example:\n\nHowever, assume that the user enters the following text:\n\nIn this case, the script assembles the following query:\n\nThe semicolon ( ) denotes the end of one query and the start of another. The double hyphen ( ) indicates that the rest of the current line is a comment and should be ignored. If the modified code is syntactically correct, it's executed by the server. When the Database Engine processes this statement, it first selects all records in where is . Then, the Database Engine drops .\n\nAs long as injected SQL code is syntactically correct, tampering can't be detected programmatically. Therefore, you must validate all user input and carefully review code that executes constructed SQL commands in the server that you use. Coding best practices are described in the following sections in this article.\n\nAlways validate user input by testing type, length, format, and range. When you implement precautions against malicious input, consider the architecture and deployment scenarios of your application. Remember that programs designed to run in a secure environment can be copied to a nonsecure environment. The following suggestions should be considered best practices:\n• None Make no assumptions about the size, type, or content of the data that is received by your application. For example, you should make the following evaluation:\n• None How does your application behave if an errant or malicious user enters a 2-GB video file where your application expects a postal code?\n• None How does your application behave if a statement is embedded in a text field?\n• None Test the size and data type of input and enforce appropriate limits. This can help prevent deliberate buffer overruns.\n• None Test the content of string variables and accept only expected values. Reject entries that contain binary data, escape sequences, and comment characters. This can help prevent script injection and can protect against some buffer overrun exploits.\n• None When you work with XML documents, validate all data against its schema as it is entered.\n• None In multitiered environments, all data should be validated before admission to the trusted zone. Data that doesn't pass the validation process should be rejected and an error should be returned to the previous tier.\n• None Implement multiple layers of validation. Precautions you take against casually malicious users might be ineffective against determined attackers. A better practice is to validate input in the user interface and at all subsequent points where it crosses a trust boundary. For example, data validation in a client-side application can prevent simple script injection. However, if the next tier assumes that its input is already validated, any malicious user who can bypass a client can have unrestricted access to a system.\n• None Never concatenate user input that isn't validated. String concatenation is the primary point of entry for script injection.\n• None Don't accept the following strings in fields from which file names can be constructed: , , through , , , through , , and .\n\nWhen you can, reject input that contains the following characters.\n\nThe collection in the Database Engine provides type checking and length validation. If you use the collection, input is treated as a literal value instead of as executable code. Another benefit of using the collection is that you can enforce type and length checks. Values outside the range trigger an exception. The following code fragment shows using the collection:\n\nIn this example, the parameter is treated as a literal value instead of as executable code. This value is checked for type and length. If the value of doesn't comply with the specified type and length constraints, an exception is thrown.\n\nStored procedures might be susceptible to SQL injection if they use unfiltered input. For example, the following code is vulnerable:\n\nIf you use stored procedures, you should use parameters as their input.\n\nUse the Parameters collection with dynamic SQL\n\nIf you can't use stored procedures, you can still use parameters, as shown in the following code example.\n\nFiltering input might also be helpful in protecting against SQL injection by removing escape characters. However, because of the large number of characters that might pose problems, filtering isn't a reliable defense. The following example searches for the character string delimiter.\n\nIf you use a clause, wildcard characters still must be escaped:\n\nYou should review all code that calls , , or . You can use queries similar to the following to help you identify procedures that contain these statements. This query checks for 1, 2, 3, or 4 spaces after the words or .\n\nIn each selected stored procedure, verify that all variables that are used in dynamic Transact-SQL are handled correctly. Data that comes from the input parameters of the stored procedure or that is read from a table should be wrapped in or . Remember that the value of @variable that is passed to is of sysname, and has a maximum length of 128 characters.\n\nWhen you use this technique, a statement can be revised as follows:\n\nAny dynamic Transact-SQL that is assigned to a variable, is truncated if it's larger than the buffer allocated for that variable. An attacker who is able to force statement truncation by passing unexpectedly long strings to a stored procedure can manipulate the result. For example, the following example stored procedure is vulnerable to injection enabled by truncation.\n\nIn this example, we have a buffer with a maximum length of 200 characters. We need a total of 154 characters to set the password of : 26 for the statement, 16 for the clause, 4 for , and 2 for quotation marks surrounded by : 200 - 26 - 16 - 4 - 2 = 154. But, because is declared as sysname, this variable can only hold 128 characters. We can overcome this by passing some single quotation marks in .\n\nIf an attacker passes 154 characters into a 128-character buffer, they can set a new password for without knowing the old password.\n\nFor this reason, you should use a large buffer for a command variable or directly execute the dynamic Transact-SQL inside the statement.\n\nTruncation when QUOTENAME(@variable, '''') and REPLACE() are used\n\nStrings returned by and are silently truncated if they exceed the space that is allocated. The stored procedure that is created in the following example shows what can happen.\n\nIn this example, the data stored in temporary variables is truncated, because the buffer size of , , and is only 128 characters, but can return up to 258 characters. If contains 128 characters, then can be , where is the 127th character. Because the string returned by is truncated, it can be made to look like the following statement:\n\nUPDATE Users SET password ='1234...[127] WHERE username=' -- other stuff here\n\nTherefore, the following statement sets the passwords of all users to the value that was passed in the previous code.\n\nYou can force string truncation by exceeding the allocated buffer space when you use . The stored procedure that is created in the following example shows what can happen.\n\nIn this example, data is truncated because the buffers allocated for , and can hold only 128 characters, but can return up to 258 characters. If contains 128 characters, can be , where is the 127th character. Because the string returned by is truncated, it can be made to look like the following statement:\n\nUPDATE Users SET password='1234...[127] WHERE username=' -- other stuff here\n\nAs with , string truncation by can be avoided by declaring temporary variables that are large enough for all cases. When possible, you should call or directly inside the dynamic Transact-SQL. Otherwise, you can calculate the required buffer size as follows. For , the size of should be . When you use and doubling quotation marks, as in the previous example, a buffer of is enough.\n\nThe following calculation covers all cases:\n\nTruncation when QUOTENAME(@variable, ']') is used\n\nTruncation can occur when the name of a Database Engine securable is passed to statements that use the form . The following example demonstrates this scenario.\n\nIn this example, must allow for 2 * 258 + 1 characters.\n\nWhen you concatenate values of type sysname, you should use temporary variables large enough to hold the maximum 128 characters per value. If possible, call directly inside the dynamic Transact-SQL. Otherwise, you can calculate the required buffer size as explained in the previous section."
    },
    {
        "link": "https://acunetix.com/websitesecurity/sql-injection",
        "document": "What is SQL Injection (SQLi) and How to Prevent It\n\nSQL Injection (SQLi) is a type of an injection attack that makes it possible to execute malicious SQL statements. These statements control a database server behind a web application. Attackers can use SQL Injection vulnerabilities to bypass application security measures. They can go around authentication and authorization of a web page or web application and retrieve the content of the entire SQL database. They can also use SQL Injection to add, modify, and delete records in the database.\n\nAn SQL Injection vulnerability may affect any website or web application that uses an SQL database such as MySQL, Oracle, SQL Server, or others. Criminals may use it to gain unauthorized access to your sensitive data: customer information, personal data, trade secrets, intellectual property, and more. SQL Injection attacks are one of the oldest, most prevalent, and most dangerous web application vulnerabilities. The OWASP organization (Open Web Application Security Project) lists injections in their OWASP Top 10 2017 document as the number one threat to web application security.\n\nSQL is a query language that was designed to manage data stored in relational databases. You can use it to access, modify, and delete data. SQL queries are usually commands that request a specific set of results from the database using the statement, though other statements also exist to perform database operations, like , , or .\n\nApplications incorporate user inputs into SQL queries to fetch the required data from their backend database. At its simplest, a SELECT statement to check user login credentials against the users table could be:\n\nThis will return a user ID if the specified username and password combination exists and (an empty result) otherwise. If the application code directly inserts raw user inputs into the query, it is most likely vulnerable to SQL injection.\n\nHow and Why Is an SQL Injection Attack Performed\n\nTo make an SQL Injection attack, an attacker must first find vulnerable user inputs within the web page or web application. A web page or web application that has an SQL Injection vulnerability uses such user input directly in an SQL query. The attacker can create input content. Such content is often called a malicious payload and is the key part of the attack. After the attacker sends this content, malicious SQL commands are executed in the database.\n\nWhat is the Impact of a Successful SQL Injection Attack?\n\nMany web applications and websites store all the data in SQL databases. In some cases, you can also use SQL commands to run operating system commands. Therefore, a successful SQL Injection attack can have very serious consequences.\n• Attackers can use SQL Injections to find the credentials of other users in the database. They can then impersonate these users. The impersonated user may be a database administrator with all database privileges.\n• SQL lets you select and output data from the database. An SQL Injection vulnerability could allow the attacker to gain complete access to all data in a database server.\n• SQL also lets you alter data in a database and add new data. For example, in a financial application, an attacker could use SQL Injection to alter balances, void transactions, or transfer money to their account.\n• You can use SQL to delete records from a database, even drop tables. Even if the administrator makes database backups, deletion of data could affect application availability until the database is restored. Also, backups may not cover the most recent data.\n• In some database servers, you can access the operating system using the database server. This may be intentional or accidental. In such case, an attacker could use an SQL Injection as the initial vector and then attack the internal network behind a firewall.\n\nThere are several types of SQL Injection attacks: in-band SQLi (using database errors or UNION commands), blind SQLi, and out-of-band SQLi. You can read more about them in the following articles: Types of SQL Injection (SQLi), Blind SQL Injection: What is it.\n\n“Regular” SQL injection is also called in-band SQLi because the attacker is able to receive results in the same way they performed the attack itself. A typical example would be to submit a web form with an SQLi payload and then see the returned database records on the same page.\n\nWhen an SQLi attack and its results use different channels, you have out-of-band (OOB) SQL injection. OOB attacks are used when the attacker can send a request but cannot see the response. Common OOB techniques include sending attack results to an attacker-controlled server and hiding them in DNS queries.\n\nBlind SQL injection is an advanced technique for indirectly reconstructing small chunks of data. The main two types of inferential SQLi are timing-based and Boolean. Timing-based attacks rely on the database taking longer to respond to some queries than others, while Boolean attacks use a large number of yes/no questions to eventually home in on a specific value.\n\nSimilar to stored XSS, second-order SQL injection payloads can also be stored in an external system and only executed when loaded by a user. While not as common as direct SQL injections, a single second-order attack could potentially affect a large number of users.\n\nThe first SQL Injection example is very simple. It shows, how an attacker can use an SQL Injection vulnerability to go around application security and authenticate as the administrator.\n\nThe following script is pseudocode executed on a web server. It is a simple example of authenticating with a username and a password. The example database has a table named with the following columns: and .\n\nThese input fields are vulnerable to SQL Injection. An attacker could use SQL commands in the input in a way that would alter the SQL statement executed by the database server. For example, they could use a trick involving a single quote and set the field to:\n\nAs a result, the database server runs the following SQL query:\n\nBecause of the statement, the clause returns the first from the table no matter what the and are. The first user in a database is very often the administrator. In this way, the attacker not only bypasses authentication but also gains administrator privileges. They can also comment out the rest of the SQL statement to control the execution of the SQL query further:\n\nOne of the most common types of SQL Injection uses the UNION operator. It allows the attacker to combine the results of two or more SELECT statements into a single result. The technique is called union-based SQL Injection.\n\nThe following is an example of this technique. It uses the web page testphp.vulnweb.com, an intentionally vulnerable website hosted by Acunetix.\n\nThe following HTTP request is a normal request that a legitimate user would send:\n\nThe parameter is vulnerable to SQL Injection. The following payload modifies the query to look for an inexistent record. It sets the value in the URL query string to . Of course, it could be any other value that does not exist in the database. However, a negative value is a good guess because an identifier in a database is rarely a negative number.\n\nIn SQL Injection, the operator is commonly used to attach a malicious SQL query to the original query intended to be run by the web application. The result of the injected query will be joined with the result of the original query. This allows the attacker to obtain column values from other tables.\n\nThe following example shows how an SQL Injection payload could be used to obtain more meaningful data from this intentionally vulnerable site:\n\nTo follow step-by-step how an SQL Injection attack is performed and what serious consequences it may have, see: Exploiting SQL Injection: a Hands-on Example.\n\nThe only sure way to prevent SQL Injection attacks is input validation and parametrized queries including prepared statements. The application code should never use the input directly. The developer must sanitize all input, not only web form inputs such as login forms. They must remove potential malicious code elements such as single quotes. It is also a good idea to turn off the visibility of database errors on your production sites. Database errors can be used with SQL Injection to gain information about your database.\n\nIf you discover an SQL Injection vulnerability, for example using an Acunetix scan, you may be unable to fix it immediately. For example, the vulnerability may be in open source code. In such cases, you can use a web application firewall to sanitize your input temporarily.\n\nTo learn how to prevent SQL Injection attacks in the PHP language, see: Preventing SQL Injection Vulnerabilities in PHP Applications and Fixing Them. To find out how to do it in many other different programming languages, refer to the Bobby Tables guide to preventing SQL Injection.\n\nPreventing SQL Injection vulnerabilities is not easy. Specific prevention techniques depend on the subtype of SQLi vulnerability, on the SQL database engine, and on the programming language. However, there are certain general strategic principles that you should follow to keep your web application safe. To keep your web application safe, everyone involved in building the web application must be aware of the risks associated with SQL Injections. You should provide suitable security training to all your developers, QA staff, DevOps, and SysAdmins. You can start by referring them to this page. Treat all user input as untrusted. Any user input that is used in an SQL query introduces a risk of an SQL Injection. Treat input from authenticated and/or internal users the same way that you treat public input. Don’t filter user input based on blacklists. A clever attacker will almost always find a way to circumvent your blacklist. If possible, verify and filter user input using strict whitelists only. Older web development technologies don’t have SQLi protection. Use the latest version of the development environment and language and the latest technologies associated with that environment/language. For example, in PHP use PDO instead of MySQLi. Don’t try to build SQLi protection from scratch. Most modern development technologies can offer you mechanisms to protect against SQLi. Use such mechanisms instead of trying to reinvent the wheel. For example, use parameterized queries or stored procedures. SQL Injections may be introduced by your developers or through external libraries/modules/software. You should regularly scan your web applications using a web vulnerability scanner such as Acunetix. If you use Jenkins, you should install the Acunetix plugin to automatically scan every build."
    },
    {
        "link": "https://imperva.com/learn/application-security/sql-injection-sqli",
        "document": "SQL injection, also known as SQLI, is a common attack vector that uses malicious SQL code for backend database manipulation to access information that was not intended to be displayed. This information may include any number of items, including sensitive company data, user lists or private customer details.\n\nThe impact SQL injection can have on a business is far-reaching. A successful attack may result in the unauthorized viewing of user lists, the deletion of entire tables and, in certain cases, the attacker gaining administrative rights to a database, all of which are highly detrimental to a business.\n\nWhen calculating the potential cost of an SQLi, it’s important to consider the loss of customer trust should personal information such as phone numbers, addresses, and credit card details be stolen.\n\nWhile this vector can be used to attack any SQL database, websites are the most frequent targets.\n\nSQL is a standardized language used to access and manipulate databases to build customizable data views for each user. SQL queries are used to execute commands, such as data retrieval, updates, and record removal. Different SQL elements implement these tasks, e.g., queries using the SELECT statement to retrieve data, based on user-provided parameters.\n\nA typical eStore’s SQL database query may look like the following:\n\nFrom this, the web application builds a string query that is sent to the database as a single SQL statement:\n\nA user-provided input http://www.estore.com/items/items.asp?itemid=999 can then generates the following SQL query:\n\nAs you can gather from the syntax, this query provides the name and description for item number 999.\n\nSQL injections typically fall under three categories: In-band SQLi (Classic), Inferential SQLi (Blind) and Out-of-band SQLi. You can classify SQL injections types based on the methods they use to access backend data and their damage potential.\n\nThe attacker uses the same channel of communication to launch their attacks and to gather their results. In-band SQLi’s simplicity and efficiency make it one of the most common types of SQLi attack. There are two sub-variations of this method:\n• Error-based SQLi—the attacker performs actions that cause the database to produce error messages. The attacker can potentially use the data provided by these error messages to gather information about the structure of the database.\n• Union-based SQLi—this technique takes advantage of the UNION SQL operator, which fuses multiple select statements generated by the database to get a single HTTP response. This response may contain data that can be leveraged by the attacker.\n\nThe attacker sends data payloads to the server and observes the response and behavior of the server to learn more about its structure. This method is called blind SQLi because the data is not transferred from the website database to the attacker, thus the attacker cannot see information about the attack in-band.\n\nBlind SQL injections rely on the response and behavioral patterns of the server so they are typically slower to execute but may be just as harmful. Blind SQL injections can be classified as follows:\n• Boolean—that attacker sends a SQL query to the database prompting the application to return a result. The result will vary depending on whether the query is true or false. Based on the result, the information within the HTTP response will modify or stay unchanged. The attacker can then work out if the message generated a true or false result.\n• Time-based—attacker sends a SQL query to the database, which makes the database wait (for a period in seconds) before it can react. The attacker can see from the time the database takes to respond, whether a query is true or false. Based on the result, an HTTP response will be generated instantly or after a waiting period. The attacker can thus work out if the message they used returned true or false, without relying on data from the database.\n\nThe attacker can only carry out this form of attack when certain features are enabled on the database server used by the web application. This form of attack is primarily used as an alternative to the in-band and inferential SQLi techniques.\n\nOut-of-band SQLi is performed when the attacker can’t use the same channel to launch the attack and gather information, or when a server is too slow or unstable for these actions to be performed. These techniques count on the capacity of the server to create DNS or HTTP requests to transfer data to an attacker.\n\nAn attacker wishing to execute SQL injection manipulates a standard SQL query to exploit non-validated input vulnerabilities in a database. There are many ways that this attack vector can be executed, several of which will be shown here to provide you with a general idea about how SQLI works.\n\nFor example, the above-mentioned input, which pulls information for a specific product, can be altered to read http://www.estore.com/items/items.asp?itemid=999 or 1=1.\n\nAs a result, the corresponding SQL query looks like this:\n\nAnd since the statement 1 = 1 is always true, the query returns all of the product names and descriptions in the database, even those that you may not be eligible to access.\n\nAttackers are also able to take advantage of incorrectly filtered characters to alter SQL commands, including using a semicolon to separate two fields.\n\nFor example, this input http://www.estore.com/items/iteams.asp?itemid=999; DROP TABLE Users would generate the following SQL query:\n\nAs a result, the entire user database could be deleted.\n\nAnother way SQL queries can be manipulated is with a UNION SELECT statement. This combines two unrelated SELECT queries to retrieve data from different database tables.\n\nFor example, the input http://www.estore.com/items/items.asp?itemid=999 UNION SELECT user-name, password FROM USERS produces the following SQL query:\n\nUsing the UNION SELECT statement, this query combines the request for item 999’s name and description with another that pulls names and passwords for every user in the database.\n\nAccellion, maker of File Transfer Appliance (FTA), a network device widely deployed in organizations around the world, and used to move large, sensitive files. The product is over 20 years old and is now at end of life.\n\nFTA was the subject of a unique, highly sophisticated attack combining SQL injection with operating system command execution. Experts speculate the Accellion attack was carried out by hackers with connections to the financial crimes group FIN11, and ransomware group Clop.\n\nThe attack demonstrates that SQL injection is not just an attack that affects web applications or web services, but can also be used to compromise back-end systems and exfiltrate data.\n\nWho was affected by the attack?\n\nThe Accellion exploit is a supply chain attack, affecting numerous organizations that had deployed the FTA device. These included the Reserve Bank of New Zealand, the State of Washington, the Australian Securities and Investments Commission, telecommunication giant Singtel, and security software maker Qualys, as well as numerous others.\n\nAccording to a report commissioned by Accellion, the combination SQLi and command execution attack worked as follows:\n• Attackers performed SQL Injection to gain access to document_root.html, and retrieved encryption keys from the Accellion FTA database.\n• Attackers used the keys to generate valid tokens, and used these tokens to gain access to additional files\n• Attackers exploited an operating system command execution flaw in the sftp_account_edit.php file, allowing them to execute their own commands\n• Using this web shell, they uploaded a custom, full-featured web shell to disk, which included highly customized tooling for exfiltration of data from the Accellion system. The researchers named this shell DEWMODE.\n• Using DEWMODE, the attackers extracted a list of available files from a MySQL database on the Accellion FTA system, and listed files and their metadata on an HTML page\n• The attackers performed file download requests, which contained requests to the DEWMODE component, with encrypted and encoded URL parameters.\n• DEWMODE is able to accept these requests and then delete the download requests from the FTA web logs.\n\nThis raises the profile of SQL injection attacks, showing how they can be used as a gateway for a much more damaging attack on critical corporate infrastructure.\n\nThere are several effective ways to prevent SQLI attacks from taking place, as well as protecting against them, should they occur.\n\nThe first step is input validation (a.k.a. sanitization), which is the practice of writing code that can identify illegitimate user inputs.\n\nWhile input validation should always be considered best practice, it is rarely a foolproof solution. The reality is that, in most cases, it is simply not feasible to map out all legal and illegal inputs—at least not without causing a large number of false positives, which interfere with user experience and an application’s functionality.\n\nFor this reason, a web application firewall (WAF) is commonly employed to filter out SQLI, as well as other online threats. To do so, a WAF typically relies on a large, and constantly updated, list of meticulously crafted signatures that allow it to surgically weed out malicious SQL queries. Usually, such a list holds signatures to address specific attack vectors and is regularly patched to introduce blocking rules for newly discovered vulnerabilities.\n\nModern web application firewalls are also often integrated with other security solutions. From these, a WAF can receive additional information that further augments its security capabilities.\n\nFor example, a web application firewall that encounters a suspicious, but not outright malicious input may cross-verify it with IP data before deciding to block the request. It only blocks the input if the IP itself has a bad reputational history.\n\nImperva cloud-based WAF uses signature recognition, IP reputation, and other security methodologies to identify and block SQL injections, with a minimal amount of false positives. The WAF’s capabilities are augmented by IncapRules—a custom security rule engine that enables granular customization of default security settings and the creation of additional case-specific security policies.\n\nOur WAF also employs crowdsourcing techniques that ensure that new threats targeting any user are immediately propagated across the entire user-base. This enables rapid response to newly disclosed vulnerability and zero-day threats.\n\nThe optimal defense is a layered approach that includes data-centric strategies that focus on protecting the data itself, as well as the network and applications around it. Imperva Database Security continuously discovers and classifies sensitive data to identify how much sensitive data there is, where it is stored, and whether it’s protected.\n\nIn addition, Imperva Database Security actively monitors data access activity to identify any data access behavior that is a risk or violates policy, regardless of whether it originates with a network SQL query, a compromised user account, or a malicious insider. Receive automatic notification of a security event so you can respond quickly with security analytics that provides a clear explanation of the threat and enables immediate initiation of the response process, all from a single platform.\n\nDatabase security is a critical last line of defense to preventing hacks like SQLi. Imperva’s unique approach to protecting data encompasses a complete view of both the web application and data layer."
    },
    {
        "link": "https://invicti.com/blog/web-security/sql-injection-cheat-sheet",
        "document": "Use the Invicti SQL Injection Cheat Sheet to learn about exploiting different variants of the SQL injection vulnerability. The cheat sheet includes technical information and payloads for SQL injection attacks against MySQL, Microsoft SQL Server, Oracle and PostgreSQL database servers.\n\nWhat is an SQL injection cheat sheet?\n\nThis SQL injection cheat sheet is a cybersecurity resource with detailed technical information and attack payloads to test for different types of SQL injection (SQLi) vulnerabilities caused by insufficient user input validation and sanitization. This cheat sheet can be used as a reference for penetration testers but also as a general guide for anyone interested in web application security and all the unexpected things you can do with SQL commands.\n\nThis cheat sheet has been the web’s leading reference for SQL injection payloads ever since it was first published in 2015 on Netsparker. It is a living document in constant development and currently contains payloads and tips for MySQL, Microsoft SQL Server, Oracle, PostgreSQL, and SQLite. As with any cheat sheet, some examples might not work in every situation because injection in real live environments will vary depending on the server configuration, structured query language dialect, usage of parentheses, application framework, and unexpected, strange, and complex SQL statements.\n\nSuccessful SQL injection often requires a payload tailored to a specific SQL database system. Payload usability is indicated as follows:\n\nWhen a payloads works on several database systems, you will see multiple symbols:\n• (PO+) = works on PostgreSQL, Oracle, and possibly other databases\n• Union injections\n• Bypassing login screens that use hashed passwords\n• Example of bypassing an MD5 hash check\n• Error-based ways to discover column information\n• Finding column names using HAVING and GROUP BY (error-based)\n• Finding the number of columns in a SELECT query using ORDER BY\n• SQL Server stored procedures\n• Other useful stored procedures for SQL Server\n• Finding and manipulating the database structure in SQL Server\n• Error-based SQL injections in SQL Server: A fast way to extract data\n• Blind SQL injections\n• Real-life example of an automatable blind SQL injection attack\n• Ways of making databases wait or sleep for blind SQL injection attacks\n• How SQL injection attacks can be hidden from logs\n• Tests to check if SQL injection is possible\n• Tips and tricks for working with MySQL\n\nPut a line comment at the end to comment out the rest of the query. Line comments are typically used to ignore the rest of the original query so you don’t need to worry about ensuring valid syntax after the injection point.\n\nA common example is logging in as admin:\n• Injection into the parameter with a single quote:\n• None SELECT * FROM members WHERE username = 'admin'--' AND password = 'password' \n\nIf successful, this will log you as the admin user because the rest of the SQL query after will be ignored.\n\nYou can use inline comments to comment out the rest of a query as with line comments (by simply not closing the comment). They are also useful for manipulating characters to bypass filtering/blacklisting, remove spaces, and obfuscate queries. In MySQL, you can use its special comment syntax to detect the database and version.\n\nFor MySQL only, you can use special comment syntax:\n\nThis special comment syntax is perfect for detecting that MySQL is being used because any instructions you put in this comment will only execute in MySQL. You can even use this to detect the version. The following example will execute and generate an error only is the server uses MySQL in the specified version or later:\n• ID value: \n\nSimply get rid of other stuff at the end the of query. Same as\n• Will throw an division by 0 error if MySQL version is higher than 8.0.27\n• ID value: \n\nYou will get the same response if MySQL version is higher than 8.0.27\n• Will throw a division by 0 error if MySQL version is higher than 8.0.27\n\nStacking means executing more than one query in one transaction. This technique can be very useful but only works for some combinations of database server and access method:\n\nWhen successful, this will end one query and start another one.\n\nNote that results from the second query (and any additional queries) are not returned to the application. You need to use blind SQL injection methods to confirm that the second query is working, such as a delay, DNS query, etc.\n\nThis will run DROP members SQL sentence after normal SQL Query.\n\nGet response based on an statement. This is one of the key techniques for Blind SQL Injection. Also very useful to test simpler things blindly yet accurately.\n• None BEGIN\n\nIF condition THEN true-part; ELSE false-part; END IF; END; (O) \n\n IF (1=1) THEN dbms_lock.sleep(3); ELSE dbms_lock.sleep(0); END IF; END;\n• None SELECT CASE WHEN condition THEN true-part ELSE false-part END; (P) \n\n SELECT CASE WHEN (1=1) THEN 'A' ELSE 'B' END;\n\nif ((select user) = 'sa' OR (select user) = 'dbo') select 1 else select 1/0 (S) \n\nThis will throw a divide by zero error if the user currently logged in is not or .\n\nVery useful for bypassing and similar filtering/escaping techniques, including web application firewall (WAF) filters.\n\nYou can use hex values in queries like this:\n• (M) (… but this is now an integer!) \n\nYou can use this technique in comparisons, for example:\n\nString-related operations can be useful for building up injections that do not use any quotes, bypassing blacklisting, or determining the type of back-end database.\n\nNote that for MySQL, the above example will only work if MySQL is running in ANSI mode. Otherwise, MySQL will treat as a logical operator and return 0. A better way it to use the function in MySQL:\n\nApart from a few direct ways of specifying strings, you can always use (MS) and (M) to generate a string without quotes.\n• (M): Return a string based on the hex representation \n\n \n\nThis will be selected as a string in MySQL.\n• Here’s an easy trick to generate hex representations of strings in MySQL: \n\n\n\nAll these examples return the string :\n• (M) \n\nThis will show the content of c:\\boot.ini\n• (SMPO) \n\nReturns the ASCII character value of the leftmost character, which is especially useful for blind SQL injections.\n• (SM) \n\nReturns a character based on its ASCII value.\n• (P) \n\nReturns a character based on its ASCII value.\n\nWith the statement, you can run cross-table SQL queries. Basically, by injecting , you can poison a query to return records from another table.\n\nSELECT header, txt FROM news UNION ALL SELECT name, pass FROM members \n\nThis query will combine results from the and tables and return all of them.\n\nOne sample payload might be: \n\n\n\nWhile exploiting injections, you can sometimes get errors because of different language settings (different locales in table settings, field settings, or combined table and database settings). It’s not a common problem, but you can run into it when dealing with applications that store data in different encodings. Here are a few tricks to deal with it:\n• SQL Server (S) \n\nUse (or another valid collation method, check the SQL Server documentation for details)\n\nExample: SELECT header FROM news UNION ALL SELECT name COLLATE SQL_Latin1_General_Cp1254_CS_AS FROM members\n• MySQL (M) \n\nUse to deal with any encoding issues\n\nSQL injection 101—here are some typical login tricks that you can use with form fields and parameters:\n\nAnother trick is to log in as a different user (SM*):\n\n\n\nVery few applications still store passwords in plain text. If you want to bypass authentication by supplying your own password with a query, you will need to hash the password before replacing it. Many hashing algorithms exist, but for simplicity, the examples below use the mostly obsolete MD5 algorithm.\n\nAn application may verify login credentials by first getting the user record based on the username and then checking if the hash of the input password value is correct. You can results with a known password and the MD5 hash of this password. The application will then compare your password and your supplied MD5 hash instead of the hash value from the database.\n\nExample of bypassing an MD5 hash check (MSP)\n\nFinding column names using HAVING and GROUP BY (error-based) (S)\n\nTry the following payloads in the specified order:\n\nOnce you are not getting any more errors, you are done.\n\nFinding the number of columns in a SELECT query using ORDER BY (MSO+)\n\nFinding the number of columns using can speed up the SQL injection process. Try the following payloads:\n\nKeep going until you get an error, which means you have found the number of columns being selected.\n• Always use with because you can have similar non-distinct field types. By default, tries to get distinct records.\n• To get rid of unwanted records from the left-side table in a join, you can use or any non-existent record search at the beginning of your query (only when injecting into the clause). This can be necessary if you are only getting one result at a time.\n• For most data types, you can use in injections instead of trying to guess if the column is a string, date, integer etc.\n\nUse the function to provoke errors from non-numeric types:\n• (S) \n\n Microsoft OLE DB Provider for ODBC Drivers error '80040e07' \n\n[Microsoft][ODBC SQL Server Driver][SQL Server]The sum or average aggregate operation cannot take a varchar data type as an argument.\n\nIf you are not getting an error, it means the column is numeric.\n\nYou can also use or in a similar way, for example:\n• None SELECT * FROM Table1 WHERE id = -1 UNION ALL SELECT null, null, NULL, NULL, convert(image,1), null, null,NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULl, NULL--\n• No error—the syntax is correct and MS SQL Server is used. Proceeding.\n• No error—we now know the first column is an integer.\n• Microsoft OLE DB Provider for SQL Server error '80040e07' \n\nExplicit conversion from data type int to image is not allowed. Error! The second column is not an integer.\n• Error! The third column is not an integer…\n\nRinse and repeat until you have all the column types mapped out.\n\nWhile statements are normally preferred for testing as non-destructive, an injection into a user table can allow you to add a new user, hopefully with elevated permissions:\n• (MS) \n\nGives you the database version and other information for SQL Server. This is a constant, so you can just select it like any other column (you don’t need to supply the table name). You can also use in and statements as well as in functions:\n• table (O)\n\n SELECT version FROM PRODUCT_COMPONENT_VERSION WHERE product LIKE 'Oracle Database%';\n\nInserting the content of a file into a table lets you browse local files when you only have database access. If you are dealing with a particularly old version of IIS (up to and including IIS6), if you don’t know the internal path of a web application, you can read the IIS metabase file at %systemroot%\\system32\\inetsrv\\MetaBase.xml, load it into a table, and then search in it to identify the application path.\n\nTo browse the content of a file, you can use:\n\nYou can then drop the temp table and repeat for another file.\n\nUsing bcp, you can load files into a table or write table data to a file. Login credentials are required to use this utility.\n\nActiveX support in SQL Server lets you use Visual Basic Script (VBS) and Windows Script Host (WSH) scripting. Take this sample shell script:\n\nTo inject this into a username field, use a payload like:\n\nThis is a well-known trick for command injection, but it has two crucial requirements:\n• It’s disabled by default in SQL Server 2005, so you need to enable it first (see below).\n• You need to have admin access to enable it.\n\nTypical payload to get the command prompt:\n\nA simple ping check can be useful to see if you’re in (you’ll first need to set up a firewall or sniffer to identify the request):\n\nNote that you can’t directly read the results of this from an error, query, or similar.\n\nBy default, and several other potentially dangerous stored procedures are disabled in SQL Server 2005. Once you have admin access, you can enable these procedures as follows:\n\nStored procedures are available to perform various registry operations. Some of these are undocumented and may change over time:\n\nOther useful stored procedures for SQL Server (S)\n• Process termination (you need to know the PID):\n• Writing an HTML file to a UNC or internal path:\n\nYou can also use to add a new procedure, which basically lets you execute arbitrary code:\n• Logins and passwords (note that SQL Server 2000 and 2005 both use a similar and crackable algorithm for hashing passwords)\n• Get detailed information about the currently running process:\n• Check if a command was successful by triggering an error condition depending on the return code:\n• Get the host name of the SQL server:\n• Check if a user is member of a specific group:\n\n (Transact-SQL)\n\nIf injecting into the second limit value, you can comment it out or use it in your injection.\n\nThis can occasionally be useful. To shut down the database server, inject:\n\nFinding and manipulating the database structure in SQL Server (S)\n\nUse the system table (older versions) or view (newer versions):\n\nUse the and system tables (older versions) or and views (newer versions):\n\nA very effective technique is to modify and use the or clause:\n\nOr you can resort to some dirty tricks for column enumeration:\n\nError-based SQL injections in SQL Server: A fast way to extract data (S)\n\nHere’s a sample payload that combines variables and system table queries to extract data into a temporary table (use and for older version and and for newer versions):\n\nIn any decent production application, you generally cannot see any error responses on the page. This rules out extracting data directly through error-based attacks. In these cases, you have to use blind SQL injections to extract the data. There are two basic kinds of blind SQL injections:\n• Normal blind injections: You cannot see the response directly on the page, but you can still determine the result of a query based on a response or HTTP status code.\n• Totally blind injections: You cannot see the effects of your injection in any kind of output. This is less common, for example when you’re injecting into a logging function or similar.\n\nIn normal blind injections, you can use statements or abuse clauses in queries, which is generally the easier route. For totally blind injections, you need to use some kind of wait function and then analyze the response times.\n\nFor Oracle, there are some PL/SQL tricks you can use for the same effect.\n\nReal-life example of an automatable blind SQL injection attack\n\nThis output is taken from a real private blind SQL injection tool while exploiting SQL Server back-ended application and enumerating table names. These requests are done for first character of the first table name. The SQL queries are a bit more complex then necessary to allow for automation. Through this series of injections, we are trying to determine the ASCII value of a character using a binary search algorithm. In effect, we’re asking a series of yes/no questions about value ranges.\n\nThe following series of queries was executed to track down the first character (where TRUE and FALSE flags indicate the logical result of each query):\n\nSince the last two queries both failed, we now know that 80 is the ASCII value of the first character of the table name, so the table name starts with the letter P. In this way, you can exploit blind SQL injections using a binary search algorithm. Another well-known way is to read data one bit at a time. Both methods can be effective in different conditions. If you can get direct feedback, it’s enough to go through a fixed list of possible characters. If your only indication of success are differing response times or if the application is slow, you can use an algorithm like the one above.\n\nWays of making databases wait or sleep for blind SQL injection attacks\n\nYou should only use time-based payloads for totally blind injections. For normal blind injections, it’s better to just use boolean-based methods (like error-based true/false tests) to identify the difference in responses.\n\nBe careful if using times longer than 20–30 seconds because the database API connection or script can time out.\n\nThis is just like a sleep command—a CPU-safe way to make the database wait for a specified time.\n\nYou can also use fractional time values, though in general, longer waiting times are less sensitive to variations in server load or available bandwidth:\n• Different ways of injecting a delay into something like . Instead of just the expected integer, we can try injecting:\n\nThe BENCHMARK() function is intended for timing performance when executing some expression a specified number of times. We can abuse it for time-based attacks to make MySQL wait a bit. Because this function consumes CPU cycles, be careful you don’t use up the entire web server resource limit. It’s best to start with lower values and increase them gradually just until you get stable results.\n• Are we root? Woot! Let’s celebrate with a billion hashes:\n\n IF EXISTS (SELECT * FROM users WHERE username = 'root') BENCHMARK(1000000000,MD5(1))\n\nSleep for the specified time in seconds:\n\nSleep for the specified time in seconds:\n\nSleep for the specified time in seconds:\n• If the condition is true, the response will arrive after 10 seconds. If it is false, the delay will be only one second.\n\nHow SQL injection attacks can be hidden from logs\n\nFor security reasons, SQL Server doesn’t log queries that include the function (used for changing passwords). This can be abused to prevent certain queries from being logged by the database server—simply appending to an SQL query is enough to bypass logging. Note that the request will still appear in web server logs if injecting into a parameter (but not ).\n\nTests to check if SQL injection is possible\n\nHere are some quick checks to determine if blind SQL injections are possible:\n• Trying to inject into (SMO):\n• Trying to inject into :\n\nTips and tricks for working with MySQL\n• Getting the first byte of the admin password hash:\n• Populating a table from a file using (not available in a default config, you first need to enable the setting ):\n• : Useful for compressing data, especially when reading large binaries via blind SQL injections.\n\nWith a second-order SQL injection, your injected payload is stored somewhere by the application and then used somewhere, hopefully unfiltered because SQL injection wasn’t expected in that place. This is a common hidden layer problem.\n\nSay you have an application that lets you create some kind of user account. You can try this injection into the name field:\n\nWith this payload, if the application uses the name field value in an unsafe stored procedure, function, or process, it will store the first user’s password as your name.\n\nThis attack can help you get the SQL Server user’s Windows password for the target server when your inbound connection is firewalled. This can be very useful during internal penetration tests.\n\nThe trick is to force SQL Server to connect to your Windows UNC share and then capture NTLM session data with a tool like Cain & Abel.\n\nYou can bulk insert data not only from a file but also from a UNC share, which is useful here:\n\nAn out-of-band (OOB) SQL injection is done when you need to exfiltrate data through a different channel than you used for the injection. DNS is one of the most common out-of-band channels because DNS requests are rarely blocked.\n\nBoth examples will send a DNS resolution request to YOUR-INJECTION-HERE.example.com:\n\nThe next two payloads attempt to reach UNC shares, so they can only work on Windows operating systems (Linux does not natively support or resolve these). Additionally, this only works if the setting is set to an empty string.\n• Writes data to your shared folder or file:\n• Two ways of sending results in DNS resolution requests (that you can log) to yourhost.com:"
    },
    {
        "link": "https://cisa.gov/sites/default/files/publications/Practical-SQLi-Identification.pdf",
        "document": ""
    }
]