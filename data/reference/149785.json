[
    {
        "link": "https://developer.chrome.com/docs/extensions/mv2/background-pages",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nExtensions are event based programs used to modify or enhance the Chrome browsing experience. Events are browser triggers, such as navigating to a new page, removing a bookmark, or closing a tab. Extensions monitor these events in their background script, then react with specified instructions.\n\nA background page is loaded when it is needed, and unloaded when it goes idle. Some examples of events include:\n• The extension is first installed or updated to a new version.\n• The background page was listening for an event, and the event is dispatched.\n• Another view in the extension, such as a popup, calls .\n\nOnce it has been loaded, a background page will stay running as long as it is performing an action, such as calling a Chrome API or issuing a network request. Additionally, the background page will not unload until all visible views and all message ports are closed. Note that opening a view does not cause the event page to load, but only prevents it from closing once loaded.\n\nEffective background scripts stay dormant until an event they are listening for fires, react with specified instructions, then unload.\n\nBackground scripts are registered in the manifest under the field. They are listed in an array after the key, and should be specified as false.\n\nMultiple background scripts can be registered for modularized code.\n\nIf an extension currently uses a persistent background page, refer to Background Migration Guide for instruction on how to switch to a non-persistent model.\n\nListen to the event to initialize an extension on installation. Use this event to set a state or for one-time initialization, such as a context menu.\n\nStructure background scripts around events the extension depends on. Defining functionally relevant events allows background scripts to lie dormant until those events are fired and prevents the extension from missing important triggers.\n\nListeners must be registered synchronously from the start of the page.\n\nDo not register listeners asynchronously, as they will not be properly triggered.\n\nExtensions can remove listeners from their background scripts by calling . If all listeners for an event are removed, Chrome will no longer load the extension's background script for that event.\n\nUse APIs that support event filters to restrict listeners to the cases the extension cares about. If an extension is listening for the event, try using the event with filters instead, as the tabs API does not support filters.\n\nListeners exist to trigger functionality once an event has fired. To react to an event, structure the desired reaction inside of the listener event.\n\nData should be persisted periodically so that important information is not lost if an extension crashes without receiving . Use the storage API to assist with this.\n\nIf an extension uses message passing, ensure all ports are closed. The background script will not unload until all message ports have shut. Listening to the runtime.Port.onDisconnect event will give insight to when open ports are closing. Manually close them with runtime.Port.disconnect.\n\nThe lifetime of a background script is observable by monitoring when an entry for the extension appears and disappears from Chrome's task manager.\n\nOpen the task manager by clicking the Chrome Menu, hovering over more tools and selecting \"Task Manager\".\n\nBackground scripts unload on their own after a few seconds of inactivity. If any last minute cleanup is required, listen to the event.\n\nHowever, persisting data should be preferred over relying on . It doesn't allow for as much cleanup as may be needed and will not help in case of a crash."
    },
    {
        "link": "https://developer.chrome.com/docs/extensions/develop/concepts/declare-permissions",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nTo use most extension APIs and features, you must declare your extension's intent in the manifest's permissions fields. Extensions can request the following categories of permissions, specified using the respective manifest keys:\n\nPermissions help to limit damage if your extension is compromised by malware. Some permission warning are displayed to users for their consent before installation or at runtime, as detailed in Permission with warnings.\n\nConsider using optional permissions wherever the functionality of your extension permits, to provide users with informed control over access to resources and data.\n\nIf an API requires a permission, its documentation explains how to declare it. For an example, see Storage API.\n\nThe following is an example of the permissions section of a manifest file:\n\nHost permissions allow extensions to interact with the URL's matching patterns. Some Chrome APIs require host permissions in addition to their own API permissions, which are documented on each reference page. Here are some examples:\n• Make requests from the extension service worker and extension pages.\n• Read and query the sensitive tab properties (url, title, and favIconUrl) using the API.\n• Monitor and control the network requests with the API.\n• Redirect and modify requests and response headers using API.\n\nWhen an extension requests multiple permissions, and many of them display warnings on installation, the user will see a list of warnings, like in the following example:\n\nUsers are more likely to trust an extension with limited warnings or when permissions are explained to them. Consider implementing optional permissions or a less powerful API to avoid alarming warnings. For best practices for warnings, see Permission warnings guidelines. Specific warnings are listed with the permissions to which they apply in the Permissions reference list.\n\nAdding or changing match patterns in the and fields of the manifest filewill also trigger a warning. To learn more, see Updating permissions.\n\nIf your extension needs to run on URLs or operate in incognito mode, users must give the extension access on its details page. You can find instructions for opening the details page under Manage your extensions.\n\nAllow access to file URLs and incognito pages\n• None Scroll down to enable access to file URLs or incognito mode.\n\nTo detect whether the user has allowed access, you can call or ."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Background_scripts",
        "document": "Background scripts or a background page enable you to monitor and react to events in the browser, such as navigating to a new page, removing a bookmark, or closing a tab.\n• Persistent – loaded when the extension starts and unloaded when the extension is disabled or uninstalled.\n• Non-persistent (which are also known as event pages) – loaded only when needed to respond to an event and unloaded when they become idle. However, a background page does not unload until all visible views and message ports are closed. Opening a view does not cause the background page to load but does prevent it from closing. Note: In Firefox, if the extension process crashes:\n• persistent background scripts running at the time of the crash are reloaded automatically.\n• non-persistent background scripts (also known as \"Event Pages\") running at the time of the crash are not reloaded. However, they are restarted automatically when Firefox calls one of their WebExtensions API events listeners.\n• extension pages loaded in tabs at the time of the crash are not automatically restored. A warning message in each tab informs the user the page has crashed and enables the user to close or restore the tab. You can test this condition by opening a new tab and navigating to , which silently triggers a crash of the extension process. In Manifest V2, background scripts or a page can be persistent or non-persistent. Non-persistent background scripts are recommended as they reduce the resource cost of your extension. In Manifest V3, only non-persistent background scripts or a page are supported. If you have persistent background scripts or a page in Manifest V2 and want to prepare your extension for migration to Manifest V3, Convert to non-persistent provides advice on transitioning the scripts or page to the non-persistent model.\n\nIn your extension, you include a background script or scripts, if you need them, using the key in . For Manifest V2 extensions, the property must be to create a non-persistent script. It can be omitted for Manifest V3 extensions or must be set to , as script are always non-persistent in Manifest V3. Including loads the background scripts as ES modules. These scripts execute in the extension's background page, so they run in the same context, like scripts loaded into a web page. However, if you need certain content in the background page, you can specify one. You then specify your script from the page rather than using the property. Before the introduction of the property to the key, this was the only option to include ES modules. You specify a background page like this: You cannot specify background scripts and a background page.\n\nListen to to initialize an extension on installation. Use this event to set a state or for one-time initialization. For extensions with event pages, this is where stateful APIs, such as a context menu created using , should be used. This is because stateful APIs don't need to be run each time the event page reloads; they only need to run when the extension is installed.\n\nStructure background scripts around events the extension depends on. Defining relevant events enables background scripts to lie dormant until those events are fired and prevents the extension from missing essential triggers. Listeners must be registered synchronously from the start of the page. browser.runtime.onInstalled.addListener(() => { browser.contextMenus.create({ id: \"sampleContextMenu\", title: \"Sample Context Menu\", contexts: [\"selection\"], }); }); // This will run when a bookmark is created. browser.bookmarks.onCreated.addListener(() => { // do something }); Do not register listeners asynchronously, as they will not be properly triggered. So, rather than: window.onload = () => { // WARNING! This event is not persisted, and will not restart the event page. browser.bookmarks.onCreated.addListener(() => { // do something }); }; browser.tabs.onUpdated.addListener(() => { // This event is run in the top level scope of the event page, and will persist, allowing // it to restart the event page if necessary. }); Extensions can remove listeners from their background scripts by calling , such as with . If all listeners for an event are removed, the browser no longer loads the extension's background script for that event.\n\nData should be persisted periodically to not lose important information if an extension crashes without receiving . Use the storage API to assist with this. // Or storage.session if the variable does not need to persist pass browser shutdown. browser.storage.local.set({ variable: variableInformation }); Message ports cannot prevent an event page from shutting down. If an extension uses message passing, the ports are closed when the event page idles. Listening to the lets you discover when open ports are closing, however the listener is under the same time constraints as . browser.runtime.onConnect.addListener((port) => { port.onMessage.addListener((message) => { if (message === \"hello\") { let response = { greeting: \"welcome!\" }; port.postMessage(response); } else if (message === \"goodbye\") { console.log(\"Disconnecting port from this end\"); port.disconnect(); } }); port.onDisconnect.addListener(() => { console.log(\"Port was disconnected from the other end\"); }); }); Background scripts unload after a few seconds of inactivity. However, if during the suspension of a background script another event wakes the background script, is called and the background script continues running. If any cleanup is required, listen to . However, persisting data should be preferred rather than relying on . It doesn't allow for as much cleanup as may be needed and does not help in case of a crash.\n\nExtensions commonly host their primary functionality in the background script. Some extensions access functions and variables defined in the background page through the returned by . The method returns when:\n• extension pages are isolated, such as extension pages in Private Browsing mode or container tabs.\n• the background page is not running. This is uncommon with persistent background pages but very likely when using an Event Page, as an Event Page can be suspended. Note: The recommended way to invoke functionality in the background script is to communicate with it through or . The methods discussed in this section cannot be used in a cross-browser extension, because Manifest Version 3 extensions in Chrome cannot use background or event pages. If your extension requires a reference to the of the background page, use to ensure the event page is running. If the call is optional (that is, only needed if the event page is alive) then use . document.getElementById(\"target\").addEventListener(\"click\", async () => { let backgroundPage = browser.extension.getBackgroundPage(); // Warning: backgroundPage is likely null. backgroundPage.backgroundFunction(); }); document.getElementById(\"target\").addEventListener(\"click\", async () => { // runtime.getBackgroundPage() wakes up the event page if it was not running. let backgroundPage = await browser.runtime.getBackgroundPage(); backgroundPage.backgroundFunction(); });"
    },
    {
        "link": "https://stackoverflow.com/questions/76396921/manifest-v2-is-being-deprecated-while-google-ask-google-identity-services-to-be",
        "document": "First thanks to all SO members for growing the coder inside me that I am able to articulate my thoughts only after doing some homework on my own.\n\nQuery: This seems like a contradictory statement from Google. In Identity Platform related Documentation, Google asks you to use Manifest V2 as V3 does not support Identity Services. So I decided to use switch to V2 to my Chrome Extension which I was earlier build and published as V3. But then got error when tried to run Unpacked Extension:\n\nand this is what official documentation asking to degrade to V2:"
    },
    {
        "link": "https://voicewriter.io/blog/the-architecture-of-chrome-extension-permissions-a-deep-dive",
        "document": "Chrome extensions are incredibly popular tools that enhance your browser's functionality. You probably have a bunch of them installed - these extensions can do things like store passwords, manage tabs, change words on a webpage as you type, block ads, and more and go beyond what the usual website security model allows. Given how much sensitive and personal data your browser stores (browsing history, passwords, and banking credentials, etc) how does a browser ensure the security of extensions? That’s what this post will cover: The Chrome Extension Permission System.\n\nIn this post, I’ll focus on Manifest V3 (MV3), the current system for Chrome extension permissions. While Manifest V2 (MV2) was simpler, it is being deprecated and will no longer be supported in the future.\n\nEvery Chrome extension has a manifest file (manifest.json) that contains the extension's basic information, such as its name, version, and required permissions. For example, an extension can request permission to read your cookies, access your bookmarks, manage your downloads, play audio, use the printer, and a lot more.\n\nHere is a sample of what a manifest file may look like:\n\nA particularly important type of permissions (in the content_scripts block) is host permissions, which allows a Chrome extension to inject content scripts into specific websites matching a set of URLs. This may be executed on all websites or only certain ones (eg: if you’re developing an extension only for YouTube, then you probably only need to inject content scripts on the YouTube website). When installing an extension, users are presented with a warning dialog explaining what the extension can do with these permissions.\n\nFor example, an extension might request permission to “read and change all your data on websites you visit.” While this sounds alarming, it’s necessary because if an extension injects JavaScript into websites, it could theoretically read or write any content on any page you’re visiting. The browser doesn’t really know what the script is doing, so it can only assume the worst-case scenario.\n\nA Chrome extension is not just one unified entity—it is composed of several parts, and each part has different permissions. The three most important components are the content scripts, popup pages, and background service workers.\n\nThere are additional components, such as the DevTools page, the options page, the Omnibox, etc, but this post will focus on the three main components. These parts communicate with each other using message passing through the WebExtensions API. Let’s break down each component.\n\nContent scripts are the only part of a Chrome extension that can interact with the DOM of a webpage. For example, a content script could change the background color of a page to blue. However, it cannot access higher-privileged Chrome APIs, even if permissions are granted in the manifest file. Instead, content scripts must send messages to other parts of the extension, usually the background service worker, to perform tasks requiring elevated privileges.\n\nContent scripts are essentially a lower-privilege system. They can access the page DOM, display UI directly on the page, and send messages to other components.\n\nHowever, they cannot access Chrome APIs or fetch data freely (restricted by CORS and CSP policies).\n\nService workers run in the background and are allowed to access all Chrome APIs the extension has permissions for, such as tabs or bookmarks.\n\nThey cannot interact with the DOM of any web page or display any UI. They can only respond to events from other parts of the extension and run for a limited amount of time before shutting down.\n\nTheir primary role is to relay messages between other components, Chrome APIs, and any backend servers.\n\nPopup pages provide a user interface for the extension when triggered by clicking the browser toolbar icon. They can only be triggered by the user clicking the toolbar button and cannot be opened any other way (eg: programmatically or in response to a user action on the page).\n\nThese pages have permissions to access Chrome APIs but, like service workers, also cannot interact with the DOM of the web page.\n\nEach component of a Chrome extension has its own set of permissions and limitations. Here’s a quick summary:\n\nChrome extensions must coordinate these parts through message passing, which ensures data is transferred securely and tasks are performed in the correct component.\n\nLet’s walk through an example of a Chrome extension that summarizes the current page using AI. Here’s how you might architect this extension:\n• None The user triggers the action through the popup window.\n• None The popup window sends a message to the content script injected into the page.\n• None The content script reads the page DOM but cannot make a backend request, so it sends a message to the service worker.\n• None The service worker fetches data from the backend AI model and returns the summary to the content script.\n• None Finally, the content script updates the page DOM to display the AI-generated summary.\n\nThis multi-step process is a typical example of how a Chrome extension developer needs to use message passing to work around permission constraints.\n\nOne common restriction Chrome extensions face is the Content Security Policy (CSP). CSP is a security feature enforced by websites via response headers to control which resources and operations are allowed. Some common examples of CSP are:\n• None script-src: Restricts where JavaScript can be loaded from.\n• None img-src: Restricts where images can be loaded from.\n• None frame-src: Restricts which URLs can be embedded in <iframe> elements.\n• None connect-src: Restricts where the browser can send requests using fetch().\n\nSince content scripts execute in the same environment as the web page, they are subject to the page’s CSP restrictions. This means that on some websites (e.g., GitHub), fetch requests initiated by a content script will fail due to CSP, even though the same requests might work on other websites (e.g., Wikipedia).\n\nFor extensions that need to work across all websites, you may assume that whenever an action may be blocked by CSP, it will be blocked at least on some websites. A common operation for an extension is communication with a backend through a fetch() request, therefore proxying fetch requests through the service worker is necessary to bypass these restrictions. The service worker operates independently of the page's CSP and can make unrestricted fetch requests.\n\nAnother significant restriction introduced in Manifest V3 is the complete ban on using eval() or any equivalent constructs, such as:\n• None Using certain patterns in regular expressions.\n• None Loading scripts dynamically from CDNs with the script tag.\n\nWhile eval() isn’t commonly used in modern JavaScript, its equivalents appear more frequently, especially in third-party dependencies. To address this limitation, Chrome introduced a special sandbox page. This sandbox has no permissions to use Chrome APIs and cannot access the DOM of any other page, but it can execute eval.\n\nHow the sandbox works is that libraries or code that use eval or similar constructs must be placed inside the special sandbox page. Inputs and outputs must be transferred between the sandbox page and the rest of the extension using (you guessed it) more message passing.\n\nYou can probably see why this is problematic. Any library that invokes eval or similar constructs—even indirectly through dependencies—must be isolated into the sandbox page. Refactoring this can be extremely challenging, especially if the eval usage is deeply embedded within a framework.\n\nDue to these challenges, many popular libraries have taken steps to avoid using eval-like constructs to ensure compatibility with Chrome extensions, but not always. When this happens, raising an issue on the package’s GitHub repo might honestly be the best solution.\n\nWhy is Chrome Extension Security So Complex?\n\nIf you're wondering how Chrome extensions arrived at their current security architecture, the reasoning might surprise you. The rationale is outlined in . The security model for Chrome extensions does not aim to protect users against malicious extensions. If an extension is malicious, there’s little anyone can do about it. Users receive warnings before installation but often proceed regardless.\n\nInstead, Chrome’s security model assumes that extensions are not malicious but may have security vulnerabilities. This assumption is reasonable since most extensions are created by average developers who may not be security experts. These insecure extensions can become prime targets for malicious websites, which aim to exploit vulnerabilities in content scripts to gain access to privileged APIs.\n\nFor example, a malicious website might attempt to trick the extension into running malicious scripts. There are many potential attack vectors like replacing functions on the window object, with its own functions, so when the extension calls them, the attacker’s arbitrary code is executed.\n\nTo mitigate these risks, Chrome extensions are split into two distinct privilege levels:\n• None Content Scripts (Lower Privilege): These share the same environment as the webpage's DOM and process. They interact with untrusted website code but have limited permissions and access.\n• None Extension Core (Higher Privilege): These include the popup page and background service workers and hold access to powerful Chrome APIs, such as storage, tabs, and bookmarks. They are process-isolated from the content scripts, and communication is restricted to message passing (strings only, no shared objects).\n\nBy isolating privileges, an attacker must first exploit a vulnerability in the content script and then trick it into sending a malicious message to the higher-privilege background script. But even if this happens, eval() is disabled entirely within the extension, making arbitrary code execution much harder to achieve.\n\nIf you enjoyed this post, check out my ! You can dictate your thoughts freely and it automatically corrects grammar in real time, working on any website. I use it to write a lot faster and never have to worry about the wording of my sentences.\n\nVoice Writer can also be used as a web app. When I developed the Chrome extension, I had some trouble getting the permissions to work, which inspired this blog post to share what I learned in the process.\n\nThis blog post was written using Voice Writer. Try it for free today! If this post was helpful please let me know at bai@voicewriter.io!"
    },
    {
        "link": "https://developer.chrome.com/docs/extensions/develop/concepts/messaging",
        "document": "Because content scripts run in the context of a web page, not the extension that runs them, they often need ways to communicate with the rest of the extension. For example, an RSS reader extension might use content scripts to detect the presence of an RSS feed on a page, then notify the service worker to display an action icon for that page.\n\nThis communication uses message passing, which allows both extensions and content scripts to listen for each other's messages and respond on the same channel. A message can contain any valid JSON object (null, boolean, number, string, array, or object). There are two message passing APIs: one for one-time requests, and a more complex one for long-lived connections that allow multiple messages to be sent. For information about sending messages between extensions, see the cross-extension messages section.\n\nTo send a single message to another part of your extension, and optionally get a response, call or . These methods let you send a one-time JSON-serializable message from a content script to the extension, or from the extension to a content script. To handle the response, use the returned promise. For backward compatibility with older extensions, you can instead pass a callback as the last argument. You can't use a promise and a callback in the same call.\n\nWhen you send a message, the event listener that handles the message is passed an optional third argument, . This is a function that takes a JSON-serializable object that is used as the return value to the function that sent the message. By default, the callback must be called synchronously. If you want to do asynchronous work to get the value passed to , you must return a literal (not just a truthy value) from the event listener. Doing so will keep the message channel open to the other end until is called.\n\nFor information on converting callbacks to promises and for using them in extensions, see the Manifest V3 migration guide.\n\nSending a request from a content script looks like this:\n\nIf you want to respond synchronously to a message, just call once you have the response, and return to indicate it's done. To respond asynchronously, return to keep the callback active until you are ready to use it. Async functions are not supported because they return a Promise, which is not supported.\n\nTo send a request to a content script, specify which tab the request applies to as shown in the following. This example works in service workers, popups, and chrome-extension:// pages opened as a tab.\n\nTo receive the message, set up a event listener. These use the same code in both extensions and content scripts:\n\nIn the previous example, was called synchronously. To use asynchronously, add to the event handler.\n\nIf multiple pages are listening for events, only the first to call for a particular event will succeed in sending the response. All other responses to that event will be ignored.\n\nTo create a reusable long-lived message passing channel, call to pass messages from a content script to an extension page, or to pass messages from an extension page to a content script. You can name your channel to distinguish between different types of connections.\n\nOne potential use case for a long-lived connection is an automatic form-filling extension. The content script might open a channel to the extension page for a specific login, and send a message to the extension for each input element on the page to request the form data to fill in. The shared connection allows the extension to share state between extension components.\n\nWhen establishing a connection, each end is assigned a object for sending and receiving messages through that connection.\n\nUse the following code to open a channel from a content script, and send and listen for messages:\n\nTo send a request from the extension to a content script, replace the call to in the previous example with .\n\nTo handle incoming connections for either a content script or an extension page, set up a event listener. When another part of your extension calls , it activates this event and the object. The code for responding to incoming connections looks like this:\n\nPorts are designed as a two-way communication method between different parts of the extension. A top-level frame is the smallest part of an extension that can use a port. When part of an extension calls , or , it creates a Port that can immediately send messages using .\n\nIf there are multiple frames in a tab, calling invokes the event once for each frame in the tab. Similarly, if is called, then the event can fire once for every frame in the extension process.\n\nYou might want to find out when a connection is closed, for example if you're maintaining separate states for each open port. To do this, listen to the event. This event fires when there are no valid ports at the other end of the channel, which can have any of the following causes:\n• There are no listeners for at the other end.\n• The tab containing the port is unloaded (for example, if the tab is navigated).\n• The frame where was called has unloaded.\n• All frames that received the port (via ) have unloaded.\n• is called by the other end. If a call results in multiple ports at the receiver's end, and is called on any of these ports, then the event only fires at the sending port, not at the other ports.\n\nIn addition to sending messages between different components in your extension, you can use the messaging API to communicate with other extensions. This lets you expose a public API for other extensions to use.\n\nTo listen for incoming requests and connections from other extensions, use the or methods. Here's an example of each:\n\nTo send a message to another extension, pass the ID of the extension you want to communicate with as follows:\n\nExtensions can also receive and respond to messages from other web pages, but can't send messages to web pages. To send messages from a web page to an extension, specify in your which websites you want to communicate with using the manifest key. For example:\n\nThis exposes the messaging API to any page that matches the URL patterns you specify. The URL pattern must contain at least a second-level domain; that is, hostname patterns such as \"*\", \"*.com\", \"*.co.uk\", and \"*.appspot.com\" are not supported. Starting in Chrome 107, you can use to access all domains. Note that because it affects all hosts, Chrome web store reviews for extensions that use it may take longer.\n\nUse the or APIs to send a message to a specific app or extension. For example:\n\nFrom your extension, listen to messages from web pages using the or APIs as in cross-extension messaging. Here's an example:\n\nExtensions can exchange messages with native applications that are registered as a native messaging host. To learn more about this feature, see Native messaging.\n\nHere are a few security considerations related to messaging.\n\nContent scripts are less trustworthy than the extension service worker. For example, a malicious web page might be able to compromise the rendering process that runs the content scripts. Assume that messages from a content script might have been crafted by an attacker and make sure to validate and sanitize all input. Assume any data sent to the content script might leak to the web page. Limit the scope of privileged actions that can be triggered by messages received from content scripts.\n\nMake sure to protect your scripts against cross-site scripting. When receiving data from an untrusted source such as user input, other websites through a content script, or an API, take care to avoid interpreting this as HTML or using it in a way which could allow unexpected code to run."
    },
    {
        "link": "https://stackoverflow.com/questions/20019958/chrome-extension-how-to-send-data-from-content-script-to-popup-html",
        "document": "I know this this has been asked in numerous posts but honestly I don't get them. I am new to JavaScript, Chrome Extensions and everything and I have this class assignment. So I need to make a plugin that would count DOM objects on any given page using Cross Domain Requests. I've been able to achieve this so far using Chrome Extension API's. Now the problem is I need to show the data on my popup.html page from the contentScript.js file. I don't know how to do that I've tried reading the documentation but messaging in chrome I just can't understand what to do.\n\nfollowing is the code so far.\n\nAny help would be appreciated and please avoid any noobness I did :)"
    },
    {
        "link": "https://developer.chrome.com/docs/extensions/reference/api/runtime",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nMost members of this API do not require any permissions. This permission is needed for , and .\n\nThe following example shows how to declare the permission in the manifest:\n\nThe Runtime API provides methods to support a number of areas that your extensions can use:\n\nWhen an unpacked extension is reloaded, this is treated as an update. This means that the event will fire with the reason. This includes when the extension is reloaded with .\n\nFor a web page to access an asset hosted on another domain, it must specify the resource's full URL (e.g. ). The same is true to include an extension asset on a web page. The two differences are that the extension's assets must be exposed as web accessible resources and that typically content scripts are responsible for injecting extension assets.\n\nIn this example, the extension will add to the page that the content script is being injected into by using to create a fully-qualified URL. But first, the asset must be declared as a web accessible resource in the manifest.\n\nSend data from a content script to the service worker\n\nIts common for an extension's content scripts to need data managed by another part of the extension, like the service worker. Much like two browser windows opened to the same web page, these two contexts cannot directly access each other's values. Instead, the extension can use message passing to coordinate across these different contexts.\n\nIn this example, the content script needs some data from the extension's service worker to initialize its UI. To get this data, it passes the developer-defined message to the service worker, and it responds with a copy of the user's information.\n\nMany extensions use post-uninstall surveys to understand how the extension could better serve its users and improve retention. The following example shows how to add this functionality.\n\nSee the Manifest V3 - Web Accessible Resources demo for more Runtime API examples.\n\nA filter to match against certain extension contexts. Matching contexts must match all specified filters; any filter that is not specified matches all available contexts. Thus, a filter of `{}` will match all available contexts. \"POPUP\" \n\n Specifies the context type as an extension popup window \"OFFSCREEN_DOCUMENT\" \n\n Specifies the context type as an offscreen document.\n• The type of context this corresponds to.\n• A UUID for the document associated with this context, or undefined if this context is hosted not in a document.\n• The origin of the document associated with this context, or undefined if the context is not hosted in a document.\n• The URL of the document associated with this context, or undefined if the context is not hosted in a document.\n• The ID of the frame for this context, or -1 if this context is not hosted in a frame.\n• Whether the context is associated with an incognito profile.\n• The ID of the tab for this context, or -1 if this context is not hosted in a tab.\n• The ID of the window for this context, or -1 if this context is not hosted in a window. An object containing information about the script context that sent a message or request.\n• A UUID of the document that opened the connection.\n• The lifecycle the document that opened the connection is in at the time the port was created. Note that the lifecycle state of the document may have changed since port creation.\n• The frame that opened the connection. 0 for top-level frames, positive for child frames. This will only be set when is set.\n• The ID of the extension that opened the connection, if any.\n• The name of the native application that opened the connection, if any.\n• The origin of the page or frame that opened the connection. It can vary from the url property (e.g., about:blank) or can be opaque (e.g., sandboxed iframes). This is useful for identifying if the origin can be trusted if we can't immediately tell from the URL.\n• The which opened the connection, if any. This property will only be present when the connection was opened from a tab (including content scripts), and only if the receiver is an extension, not an app.\n• The TLS channel ID of the page or frame that opened the connection, if requested by the extension, and if available.\n• The URL of the page or frame that opened the connection. If the sender is in an iframe, it will be iframe's URL not the URL of the page which hosts it. The reason that this event is being dispatched. \"install\" \n\n Specifies the event reason as an installation. \"update\" \n\n Specifies the event reason as an extension update. \"shared_module_update\" \n\n Specifies the event reason as an update to a shared module. The reason that the event is being dispatched. 'app_update' is used when the restart is needed because the application is updated to a newer version. 'os_update' is used when the restart is needed because the browser/OS is updated to a newer version. 'periodic' is used when the system runs for more than the permitted uptime set in the enterprise policy. \"app_update\" \n\n Specifies the event reason as an update to the app. \"os_update\" \n\n Specifies the event reason as an update to the operating system. \"periodic\" \n\n Specifies the event reason as a periodic restart of the app. An object containing information about the current platform.\n• The native client architecture. This may be different from arch on some platforms.\n• The operating system Chrome is running on. The native client architecture. This may be different from arch on some platforms. The operating system Chrome is running on. An object which allows two way communication with other pages. See Long-lived connections for more information.\n• The name of the port, as specified in the call to .\n• Fired when the port is disconnected from the other end(s). may be set if the port was disconnected by an error. If the port is closed via disconnect, then this event is only fired on the other end. This event is fired at most once (see also Port lifetime). The function looks like:\n• The parameter looks like:\n• This event is fired when postMessage is called by the other end of the port. The function looks like:\n• The parameter looks like:\n• This property will only be present on ports passed to onConnect / onConnectExternal / onConnectNative listeners.\n• Immediately disconnect the port. Calling on an already-disconnected port has no effect. When a port is disconnected, no new events will be dispatched to this port. The function looks like:\n• Send a message to the other end of the port. If the port is disconnected, an error is thrown. The function looks like:\n• The message to send. This object should be JSON-ifiable. \"throttled\" \n\n Specifies that the status check has been throttled. This can occur after repeated checks within a short amount of time. \"no_update\" \n\n Specifies that there are no available updates to install. \"update_available\" \n\n Specifies that there is an available update to install. The ID of the extension/app. Populated with an error message if calling an API function fails; otherwise undefined. This is only defined within the scope of that function's callback. If an error is produced, but is not accessed within the callback, a message is logged to the console listing the API function that produced the error. API functions that return promises do not set this property.\n• Details about the error which occurred. Attempts to connect listeners within an extension (such as the background page), or other extensions/apps. This is useful for content scripts connecting to their extension processes, inter-app/extension communication, and web messaging. Note that this does not connect to any listeners in a content script. Extensions may connect to content scripts embedded in tabs via .\n• The ID of the extension to connect to. If omitted, a connection will be attempted with your own extension. Required if sending messages from a web page for web messaging.\n• \n• Whether the TLS channel ID will be passed into onConnectExternal for processes that are listening for the connection event.\n• Will be passed into onConnect for processes that are listening for the connection event.\n• Port through which messages can be sent and received. The port's onDisconnect event is fired if the extension does not exist. Connects to a native application in the host machine. This method requires the permission. See Native Messaging for more information.\n• The name of the registered application to connect to.\n• Port through which messages can be sent and received with the application Background pages do not exist in MV3 extensions. Retrieves the JavaScript 'window' object for the background page running inside the current extension/app. If the background page is an event page, the system will ensure it is loaded before calling the callback. If there is no background page, an error is set.\n• The parameter looks like:\n• The JavaScript 'window' object for the background page.\n• Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback. Fetches information about active contexts associated with this extension\n• A filter to find matching contexts. A context matches if it matches all specified fields in the filter. Any unspecified field in the filter matches all contexts.\n• The parameter looks like:\n• The matching contexts, if any.\n• Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback. Returns details about the app or extension from the manifest. The object returned is a serialization of the full manifest file.\n• The parameter looks like:\n• Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n• The parameter looks like:\n• Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback. Converts a relative path within an app/extension install directory to a fully-qualified URL.\n• A path to a resource within an app/extension expressed relative to its install directory.\n• The fully-qualified URL to the resource. Open your Extension's options page, if possible. The precise behavior may depend on your manifest's or key, or what Chrome happens to support at the time. For example, the page may be opened in a new tab, within chrome://extensions, within an App, or it may just focus an open options page. It will never cause the caller page to reload. If your Extension does not declare an options page, or Chrome failed to create one for some other reason, the callback will set .\n• The parameter looks like:\n• Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback. Reloads the app or extension. This method is not supported in kiosk mode. For kiosk mode, use chrome.runtime.restart() method. Requests an immediate update check be done for this app/extension. Important: Most extensions/apps should not use this method, since Chrome already does automatic checks every few hours, and you can listen for the event without needing to call requestUpdateCheck. This method is only appropriate to call in very limited circumstances, such as if your extension talks to a backend service, and the backend service has determined that the client extension version is very far out of date and you'd like to prompt a user to update. Most other uses of requestUpdateCheck, such as calling it unconditionally based on a repeating timer, probably only serve to waste client, network, and server resources. Note: When called with a callback, instead of returning an object this function will return the two properties as separate arguments passed to the callback.\n• The parameter looks like:\n• RequestUpdateCheckResult object that holds the status of the update check and any details of the result if there is an update available\n• If an update is available, this contains the version of the available update.\n• Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback. Restart the ChromeOS device when the app runs in kiosk mode. Otherwise, it's no-op. Restart the ChromeOS device when the app runs in kiosk mode after the given seconds. If called again before the time ends, the reboot will be delayed. If called with a value of -1, the reboot will be cancelled. It's a no-op in non-kiosk mode. It's only allowed to be called repeatedly by the first extension to invoke this API.\n• Time to wait in seconds before rebooting the device, or -1 to cancel a scheduled reboot.\n• The parameter looks like:\n• Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback. Sends a single message to event listeners within your extension or a different extension/app. Similar to but only sends a single message, with an optional response. If sending to your extension, the event will be fired in every frame of your extension (except for the sender's frame), or , if a different extension. Note that extensions cannot send messages to content scripts using this method. To send messages to content scripts, use .\n• The ID of the extension to send the message to. If omitted, the message will be sent to your own extension/app. Required if sending messages from a web page for web messaging.\n• The message to send. This message should be a JSON-ifiable object.\n• \n• Whether the TLS channel ID will be passed into onMessageExternal for processes that are listening for the connection event.\n• The parameter looks like:\n• The JSON response object sent by the handler of the message. If an error occurs while connecting to the extension, the callback will be called with no arguments and will be set to the error message.\n• Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback. Send a single message to a native application. This method requires the permission.\n• The name of the native messaging host.\n• The message that will be passed to the native messaging host.\n• The parameter looks like:\n• The response message sent by the native messaging host. If an error occurs while connecting to the native messaging host, the callback will be called with no arguments and will be set to the error message.\n• Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback. Sets the URL to be visited upon uninstallation. This may be used to clean up server-side data, do analytics, and implement surveys. Maximum 1023 characters.\n• URL to be opened after the extension is uninstalled. This URL must have an http: or https: scheme. Set an empty string to not open a new tab upon uninstallation.\n• The parameter looks like:\n• Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback. Fired when a Chrome update is available, but isn't installed immediately because a browser restart is required.\n• The parameter looks like: Fired when a connection is made from either an extension process or a content script (by ).\n• The parameter looks like: Fired when a connection is made from another extension (by ), or from an externally connectable web site.\n• The parameter looks like: Fired when a connection is made from a native application. This event requires the permission. It is only supported on Chrome OS.\n• The parameter looks like: Fired when the extension is first installed, when the extension is updated to a new version, and when Chrome is updated to a new version.\n• The parameter looks like:\n• \n• Indicates the ID of the imported shared module extension which updated. This is present only if 'reason' is 'shared_module_update'.\n• Indicates the previous version of the extension, which has just been updated. This is present only if 'reason' is 'update'.\n• The reason that this event is being dispatched. Fired when a message is sent from either an extension process (by ) or a content script (by ).\n• The parameter looks like:\n• The parameter looks like: Fired when a message is sent from another extension (by ). Cannot be used in a content script.\n• The parameter looks like:\n• The parameter looks like: Fired when an app or the device that it runs on needs to be restarted. The app should close all its windows at its earliest convenient time to let the restart to happen. If the app does nothing, a restart will be enforced after a 24-hour grace period has passed. Currently, this event is only fired for Chrome OS kiosk apps.\n• The parameter looks like: Fired when a profile that has this extension installed first starts up. This event is not fired when an incognito profile is started, even if this extension is operating in 'split' incognito mode.\n• The parameter looks like: Sent to the event page just before it is unloaded. This gives the extension opportunity to do some clean up. Note that since the page is unloading, any asynchronous operations started while handling this event are not guaranteed to complete. If more activity for the event page occurs before it gets unloaded the onSuspendCanceled event will be sent and the page won't be unloaded.\n• The parameter looks like: Sent after onSuspend to indicate that the app won't be unloaded after all.\n• The parameter looks like: Fired when an update is available, but isn't installed immediately because the app is currently running. If you do nothing, the update will be installed the next time the background page gets unloaded, if you want it to be installed sooner you can explicitly call chrome.runtime.reload(). If your extension is using a persistent background page, the background page of course never gets unloaded, so unless you call chrome.runtime.reload() manually in response to this event the update will not get installed until the next time Chrome itself restarts. If no handlers are listening for this event, and your extension has a persistent background page, it behaves as if chrome.runtime.reload() is called in response to this event.\n• The parameter looks like:\n• \n• The version number of the available update. Fired when a connection is made from a user script from this extension.\n• The parameter looks like: Fired when a message is sent from a user script associated with the same extension.\n• The parameter looks like:\n• The parameter looks like:"
    },
    {
        "link": "https://stackoverflow.com/questions/21766990/message-passing-example-from-chrome-extensions",
        "document": "First, I wouldn't message pass between your popup and your content script. I would message pass between your Background page and your content scripts. Your popup page should only be used to show some ui to interact with your app.\n\nWith that being said, I will show you the way to pass messages between your background and your content script.\n\nIn your background page(possibly your popup? but I don't recommend it)\n\nHere is the sequence of events that will take place:\n• Your application will inject your content script into the page\n• Your content script will open up a port to communicate with the background script.\n• Your background script will be notified that a port was open, allowing it to send a message to it, or attach a message listener to it.\n\nIn the background script or the content script, you can listen for messages by using . provided that port is in scope. Using ports is much easier to grasp and allows for simple, two way communication!\n\nIf you would like to pass messages to your background page from your popup script, use the exact same method:\n\nTo navigate your user to a new page, do this:\n\nWhat this function does is, it checks to see if there is a tab with the url you want to go to, if there is, switch to it, else, create a tab with that url and navigate to it."
    },
    {
        "link": "https://m2kdevelopments.medium.com/5-understanding-chrome-extensions-communication-0b76b3c7958f",
        "document": "The flow of data within our browser extensions is a vital part in creating any incredible and useful tool. In this article we hope to show you how data can moves within the different parts of the extension.\n\nSo far, in the articles we’ve written prior, we’ve covered that there are 3 major parts of a chrome extensions. Popup, content scripts and background scripts. All these parts can work independently, moreover, you can have a fully functioning chrome extension with just one of these.\n\nTo communicate to the different parts of the extensions we will use the chrome.runtime API and/or chrome.tabs.sendMessage.\n\nThe API retrieves the service worker, returns details about the manifest, and listens for and responds to events in the extension lifecycle. You can also use this API to convert the relative path of URLs to fully-qualified URLs (we’ll look at that in the article for web accessibility). No permissions are need for this API. (We will cover permissions in our next article).\n\nAs for the API will look at it in length in a future article but for now there are 2 main function/methods will use for communication and\n\nIf you already have a chrome extension project, great! If not, then create a folder/director and have the following files in there;\n\n, and are going to be used for the UI and functionality of the popup of the extension respectively. and will be used as the content script and background script respectively.\n\nYou’ll notice that there is a new field . We’ll cover this at length in the next article, but briefly, it just tells chrome browser that the extension will be using functions from the chrome.tabs API and , to get the tabs info and to send data to those tabs where the content scripts are running.\n\nWhen you install your extension locally it should look something like this.\n\nNow we are going to code the popup’s functionality. The idea is that the extension should automatically detect background color of the current webpage and change the input color accordingly. In addition, when a user clicks the Change Color button it should change the background color of the website to the color selected by the input color.\n\nThat is where chrome.runtime API because useful. The API has two major function/methods for handline in-app communication\n\nboth of which you are look at the official documentation by Google on it here. A sender and listener, respectively.\n\nIf you want to implement the same in React JS you would do something like this in your file for example.\n\nHere is where the website’s background color changing is happening. The content script listens for messages coming from the popup or background script and send a message back after perform an action.\n\nWhen the content script sends a message, the popup and background script receive the data simultaneously. If the popup is NOT open then only background script will receive the message.\n\nFor this extension, we are just logging the message sent in the background scripts\n\nIf you’ve gotten to this point then we are done! You have yourself a amazing, incredible, awesome, fantabulous, game-changing background-color-changer chrome browser extension. Change the colors of any website to your liking.\n\nChrome extension are able to communicate with other chrome extensions."
    }
]