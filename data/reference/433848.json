[
    {
        "link": "https://niceone-keypad.com/arduino-button-matrix-4x4-a-comprehensive-guide",
        "document": "If you’re looking for a way to control multiple buttons with your Arduino, a button matrix might be just what you need. A button matrix allows you to connect multiple buttons to a single set of pins on your Arduino, saving valuable pins for other uses. One of the most common button matrix configurations is the 4×4 matrix, which allows you to connect up to 16 buttons using only 8 pins on your Arduino.\n\nTo use a 4×4 button matrix with your Arduino, you’ll need to connect the matrix to your Arduino’s digital pins and use a library to read the button presses. There are several libraries available for this purpose, including the Keypad library, which is included with the Arduino IDE. Once you’ve connected the matrix and installed the library, you can use the library’s functions to detect which button has been pressed.\n\nUsing a 4×4 button matrix with your Arduino opens up a wide range of possibilities for controlling your projects. Whether you’re building a game controller, a musical instrument, or a custom input device, a button matrix can help you save valuable pins on your Arduino and simplify your circuit design. With the right library and a little bit of programming, you can easily add a versatile and powerful input system to your Arduino projects.\n\nA button matrix is a grid of buttons arranged in rows and columns. The 4×4 button matrix is a common configuration that can be used with an Arduino microcontroller for various projects. Understanding how the button matrix works is essential for designing and implementing an effective system.\n\nThe 4×4 button matrix consists of sixteen buttons arranged in a 4×4 grid. The matrix has four rows and four columns. Each button is connected to a unique combination of one row and one column. The rows and columns are connected to the microcontroller’s digital input/output pins.\n\nThe UK post code matrix layout and design are crucial to ensure that each button is uniquely identified. The rows and columns are arranged in a way that no two buttons share the same combination of row and column. The layout can be optimized to minimize the number of pins used to connect the matrix to the microcontroller.\n\nThe button matrix operation is based on the principle of scanning. The microcontroller scans the rows and columns of the matrix to detect which button is pressed. The scanning process involves setting each row’s digital output pin to HIGH and reading the column’s digital input pins. When a button is pressed, the corresponding row and column are shorted, and the microcontroller detects a logic LOW on the column’s digital input pin.\n\nThe scanning process is repeated for each row, and the microcontroller detects which button is pressed based on the combination of row and column that produces a logic LOW. The microcontroller can then execute the appropriate code based on the button pressed.\n\nIn conclusion, understanding the layout and operation principles of the 4×4 button matrix is essential for designing and implementing an effective system. By using the scanning principle, the microcontroller can detect which button is pressed and execute the appropriate code.\n\nBefore you start integrating the 4×4 button matrix with Arduino, you need to gather the following components:\n\nOnce you have all the components, you can start connecting the 4×4 button matrix with the Arduino board. Here’s a step-by-step guide:\n• Connect one side of the button matrix to the Arduino’s digital pins (D2-D5) and the other side to the ground (GND) using jumper wires.\n• Connect the other side of the button matrix to the Arduino’s digital pins (D6-D9) using jumper wires.\n• Connect the power supply (5V) to the button matrix.\n• Connect the Arduino board to your computer using a USB cable.\n• Open the Arduino IDE and create a new sketch.\n• Copy and paste the following code into the sketch:\n• Upload the sketch to the Arduino board.\n• Open the Serial Monitor in the Arduino IDE to see the output.\n\nThat’s it! You have successfully integrated the 4×4 button matrix with Arduino. You can now use the keypad to input data and control your Arduino projects.\n\nBefore you can start programming your Arduino for a button matrix, you need to set up the Arduino IDE. The UK post code Arduino IDE is a software platform that allows you to write and upload code to your Arduino board. You can download the Arduino IDE from the official Arduino website.\n\nOnce you have downloaded and installed the Arduino IDE, you need to select the correct board and port. To do this, go to the menu and select and then choose your Arduino board. Next, go to the menu again and select and then choose the port that your Arduino board is connected to.\n\nTo program your Arduino for a button matrix, you need to write code that scans the matrix and detects when a button is pressed. You can use the library to simplify this process. The library allows you to define the size and layout of your button matrix and provides functions for scanning the matrix and detecting button presses.\n\nHere is an example code snippet that scans a 4×4 button matrix:\n\nIn this example, we define a 4×4 button matrix and specify the pin connections for the rows and columns of the matrix. We then create a object and pass in the matrix layout and pin connections. Finally, we use the function to scan the matrix and detect button presses.\n\nOne common issue with button matrices is that they can produce multiple button presses when a button is pressed or released. This is known as “bouncing” and can be caused by the physical properties of the button or the electrical properties of the matrix.\n\nTo prevent bouncing, you can use a technique called “debouncing”. Debouncing involves adding a delay between button presses to allow the electrical signals to stabilize. You can use the library to simplify this process. The library provides functions for debouncing button presses and releases.\n\nHere is an example code snippet that uses the library to debounce button presses:\n\nIn this example, we use the library to debounce button presses. We create a object and attach it to the pin that the button is connected to. We then use the function to detect when the button is pressed and debounce the signal using the function."
    },
    {
        "link": "https://forum.arduino.cc/t/creating-a-keyboard-scan-matrix-with-a-74ls42/971092",
        "document": "Arduino and Port Manipulation: In this article we are going to examine Arduino I/O pins in more detail by using “Port Manipulation” to control them in a much faster manner than using digitalWrite()/digitalRead(). Why? Speed! Using this method allows..."
    },
    {
        "link": "https://forum.arduino.cc/t/8x16-button-matrix-leo-midi-controller-input-expanding-help/555820",
        "document": "I'm building an 8x16 button matrix MIDI controller with a Leonardo, and was wondering what I should use to expand the amount of inputs. I'll be needing 24 inputs, right? It will be used for playing midi notes, so seems like the buttons should be scanned relatively fast. I found tttapa's MIDI controller library which seems like the way to go. Not yet sure how to implement the expanders/shift registers (?), but I'll be studying the library and it should be clearer once I get an idea of the hardware needed. I'm not very experienced with coding yet, so apologies in advance. Any help is appreciated.\n\nemaj:\n\n It will be used for playing midi notes, so seems like the buttons should be scanned relatively fast. \"Relatively fast\" in human terms means a resolution of perhaps one twentieth of a second. In that time, the microcontroller has executed some 500,000 instructions. You can scan your 8 by 16 matrix with a 74HC4017 and read the inputs with a pair of PCF8574s\n\n \n\n or a single PCF8575 module.\n\n Actually, I cannot see a cheap module to mount the 74HC4017, so you may be best to use one PCF8574 as the scanner and one PCF8575 as the reader, using the modules, your button matrix is already built - at least the electronics. Note you need to use a series diode on each button.\n\nIf you are using this key matrix to play chords, rather than strictly one note at a time, you will run into the problem of \"ghosting\". To avoid this, you will need to connect a diode in series with every switch. You can get 74hc4067 modules. To use them you will need 4 digital outputs. Plus 8 digital inputs to read the matrix, so you should have enough pins on Leonardo for your key matrix.\n\nWell, you use the libraries to manage the chips/ modules, which should allow you to simply write the scan byte to the eight rows and read two bytes for the corresponding column inputs. Note the nature of these port expanders - when you write a value to the single register, it pulls down pins you have set to 0 but only transiently pulls up the pins you set to 1, otherwise leaving them with weak pull-ups. A read of the register will then read pins set to 0 as 0, and pins set to 1 as 1 unless something - a button - is pulling the pin down. This means each button must have a diode in series with cathode going to the \"scan\" module which selectively pulls down rows, and anode toward the \"reading\" module. If you were seeking only one button press, you would pull down all rows to start with and read the columns until one was pulled low, at which point you would do a complete scan. If however you expect multiple buttons to be coincidentally pressed, you will pull down one row at a time and take note of which column or columns are then pulled down for that row. Also note the need for debouncing.\n\nPaulRB:\n\n You can get 74hc4017 modules. Oh, you can? I looked on eBay (my usual source) and Adafruit (not really available for me here in Australia) and could not find them. With the 74hc4017 it is not just \"ghosting\" but without the diodes the buttons can connect two scan lines together. PaulRB:\n\n To use them you will need 4 digital outputs. Plus 8 digital inputs to read the matrix, so you should have enough pins on Leonardo for your key matrix. I thought the OP said an 8 by 16 matrix ...\n\nYup! I've made a few mechanical keyboards so the diodes are routine. Just have to pay attention to polarity if it differs in this application, as soon as I wrap my head around this. Paul__B:\n\n This means each button must have a diode in series with cathode going to the \"scan\" module which selectively pulls down rows, and anode toward the \"reading\" module. Seems like this is the opposite of the polarity I've done before, have to keep that in mind. \n\n Nevermind, it's the same way I've done it before.\n\nas soon as I wrap my head around this It's not too difficult. You can think of the 74hc4067 as being like a 16-position rotary switch. The \"com\" pin is like the wiper contact, connecting to one of the 16 other contacts, while the other 15 are not connected to anything. The 4 \"address\" pins a, b, c & d control the position of the rotary switch. They will be made high or low by an Arduino output pin. That gives 2^4 = 16 combinations to control the switch position. Your sketch will need to scan the matrix one row at a time, by setting the a, b, c & d pins to select the matrix row to be read. Because the com pin (the \"wiper\") is connected to ground, this will ground one row of the matrix, while all the other rows are \"floating\", being connected to neither ground or 5V. Once the row had been selected, the sketch can then read the 8 Arduino inputs. If the corresponding button in the column is not pressed, the input will read high because the Arduino's internal pull-up resistors. But if the button is pressed, the Arduino input will read low because it is connected to ground through the diode, button and the 4067.\n\nPaulRB:\n\n It's not too difficult. You can think of the... That makes sense to me, thanks! I made a schematic, not sure if 100% correct. (See attachment) I also tried to slap together a sketch using the examples provided with the library as reference, not exactly sure if it's in any way correct, though. Seems \"too easy\". No thought given to debouncing yet. But it compiles which I'm happy about. //#include <frequencyToNote.h> #include <MIDIUSB.h> //#include <pitchToFrequency.h> //#include <pitchToNote.h> #include <MIDI_Controller.h> // Create an instance of 'AnalogMultiplex' with the output pin of the multiplexer connected to // pin 2 and the address pins connected to pins 3, 4 and 5. // AnalogMultiplex(pin_t analogPin, { pin_t addressPin1, addressPin2, ... addressPinN } ) AnalogMultiplex multiplexer(2, { 3, 4, 5 } ); const uint8_t velocity = 0b1111111; // Maximum velocity (0b1111111 = 0x7F = 127) const uint8_t addresses[8][8] = { { 1, 2, 3, 4, 5, 6, 7, 8 }, { 9, 10, 11, 12, 13, 14, 15, 16 }, { 17, 18, 19, 20, 21, 22, 23, 24 }, { 25, 26, 27, 28, 29, 30, 31, 32 }, { 33, 34, 35, 36, 37, 38, 39, 40 }, { 41, 42, 43, 44, 45, 46, 47, 48 }, { 49, 50, 51, 52, 53, 54, 55, 56 }, { 57, 58, 59, 60, 61, 62, 63, 64 } }; // Create a new instance of the class 'ButtonMatrix', called 'buttonmatrix', with dimensions 8 rows and 8 columns, with the rows connected to pins 6..13 // and the columns connected to multiplexer pins 0..7, that sends MIDI messages with the notes specified in 'addresses' on MIDI channel 1, with velocity 127 ButtonMatrix<8, 8> buttonmatrix({6, 7, 8, 9, 10, 11, 12, 13}, {multiplexer.pin(0), multiplexer.pin(1), multiplexer.pin(2), multiplexer.pin(3), multiplexer.pin(4), multiplexer.pin(5), multiplexer.pin(6), multiplexer.pin(7),}, addresses, 1, velocity); void setup() {} void loop() { // Refresh the buttons and send changes over MIDI MIDI_Controller.refresh(); }"
    },
    {
        "link": "https://circuitbasics.com/how-to-set-up-a-keypad-on-an-arduino",
        "document": "Keypads are a great way to let users interact with your project. You can use them to navigate menus, enter passwords, and control games and robots.\n\nIn this tutorial, I’ll show you how to setup a keypad on the Arduino. First I’ll explain how the Arduino detects key presses, then I’ll show you how to find the pinout of any keypad. As a simple example, I’ll show you how to print out the key presses on the serial monitor and an LCD. Finally, I’ll show you how to activate a 5V relay when a password is entered correctly.\n\nWatch the video for this tutorial here:\n\nI’ll be using a 4X4 matrix membrane keypad in this article, but there’s also code and wiring diagrams for 3X4 matrix keypads as well. I like membrane style keypads because they’re thin and they also have adhesive backing so you can stick them to most flat surfaces. You can also get telephone style keypads that have thicker buttons if you like that style better. Even salvaged keypads from old telephones will work with the Arduino.\n\nThe buttons on a keypad are arranged in rows and columns. A 3X4 keypad has 4 rows and 3 columns, and a 4X4 keypad has 4 rows and 4 columns:\n\nBeneath each key is a membrane switch. Each switch in a row is connected to the other switches in the row by a conductive trace underneath the pad. Each switch in a column is connected the same way – one side of the switch is connected to all of the other switches in that column by a conductive trace. Each row and column is brought out to a single pin, for a total of 8 pins on a 4X4 keypad:\n\nPressing a button closes the switch between a column and a row trace, allowing current to flow between a column pin and a row pin.\n\nThe schematic for a 4X4 keypad shows how the rows and columns are connected:\n\nThe Arduino detects which button is pressed by detecting the row and column pin that’s connected to the button.\n\nThis happens in four steps:\n\n1. First, when no buttons are pressed, all of the column pins are held HIGH, and all of the row pins are held LOW:\n\n2. When a button is pressed, the column pin is pulled LOW since the current from the HIGH column flows to the LOW row pin:\n\n3. The Arduino now knows which column the button is in, so now it just needs to find the row the button is in. It does this by switching each one of the row pins HIGH, and at the same time reading all of the column pins to detect which column pin returns to HIGH:\n\n4. When the column pin goes HIGH again, the Arduino has found the row pin that is connected to the button:\n\nFrom the diagram above, you can see that the combination of row 2 and column 2 could only mean that the number 5 button was pressed.\n\nConnect the Keypad to the Arduino\n\nThe pin layout for most membrane keypads will look like this:\n\nFollow the diagrams below to connect the keypad to an Arduino Uno, depending on whether you have a 3X4 or 4X4 keypad:\n\nHow to Find the Pinout of Your Keypad\n\nIf your keypad’s pin layout doesn’t match the ones above, you can probe the pins to figure it out. You’ll need to build a test circuit by connecting an LED and a current limiting resistor to the Arduino (or any 5V power source) like this:\n\nFirst, find out which keypad pins are connected to the button rows. Insert the ground (black) wire into the first pin on the left. Press any button in row 1 and hold it down. Now insert the positive (red) wire into each one of the other pins. If the LED lights up at one of the pins, press and hold another button in row 1, then insert the positive wire into each one of the other pins again. If the LED lights up on a different pin, it means the ground wire is inserted into the row 1 pin. If none of the buttons in row 1 make the LED light up, the ground wire is not connected to row 1. Now move the ground wire over to the next pin, press a button in a different row, and repeat the process above until you’ve found the pin for each row.\n\nTo figure out which pins the columns are connected to, insert the ground wire into the pin you know is row 1. Now press and hold any one of the buttons in that row. Now insert the positive wire into each one of the remaining pins. The pin that makes the LED light up is the pin that’s connected to that button’s column. Now press down another button in the same row, and insert the positive wire into each one of the other pins. Repeat this process for each one of the other columns until you have each one mapped out.\n\nFor a basic demonstration of how to setup the keypad, I’ll show you how to print each key press to the serial monitor.\n\nWe’ll use the Keypad library by Mark Stanley and Alexander Brevig. This library takes care of setting up the pins and polling the different columns and rows. To install the Keypad library, go to Sketch > Include Library > Manage Libraries and search for “keypad”. Click on the library, then click install.\n\nOnce the Keypad library is installed, you can upload this code to the Arduino if you’re using a 4X4 keypad:\n\nIf you’re using a 3X4 keypad, you can use this code:\n\nLines 3 and 4 in the code above set the number of rows and columns on the keypad.\n\nLines 6-11 define which characters are printed when a particular button is pressed on the keypad. The characters are laid out just as they appear on the keypad. If your keypad has a different layout, you can define which characters are printed when you press a button. For example, say your keypad has a column of letters on the left instead of the right. You would just change it to this:\n\nAfter you upload the code, open the serial monitor. When you press a key, the value will be printed out:\n\nUsing an LCD with the Keypad\n\nNow let’s see how to print the key presses on an LCD. 4X4 keypads use 8 pins and 3X4 keypads use 7 pins. That takes up a lot of pins, so I’m going to use an I2C enabled LCD because it only needs 4 wires to connect to the Arduino.\n\nTo use an I2C enabled LCD on the Arduino, you’ll need to install the LiquidCrystal I2C library by Marco Schwartz. This library is nice because it includes most of the functions available in the standard LiquidCrystal library. To install it, download the ZIP file below, then go to Sketch > Include Library > Add .ZIP Library:\n\nThe Wire library is needed to add support for I2C communication. It comes packaged with the Arduino IDE, so there’s no need to install it. But if for some reason it’s not installed on your system, go to Sketch > Include Library > Manage Libraries and search for “wire” to install it.\n\nOnce the libraries are installed, connect the ground and Vcc pins of the LCD to the Arduino, then connect the LCD’s SDA and SCL pins according to the table below for the different Arduino boards:\n\nThen connect the keypad to the Arduino. It should look something like this (for an Arduino Uno):\n\nCode for Output to an LCD\n\nOnce everything is connected, upload this code to the Arduino:\n\nYou’ll need to add the I2C address of your LCD on line 20:\n\nThe I2C address of my LCD is 0x21, but your’s will probably be different. The I2C address of your LCD should be provided in the datasheet, but if not, you can find it by running this I2C_Scanner sketch.\n\nOne of the most useful applications of a keypad is to use it for keyed entry. You can set up a password and have the Arduino activate a relay or some other module if the password is correct. The following code will activate a 5V relay when the password is entered correctly:\n\nYou can change the password on line 10 by replacing the text with your own password:\n\nThe length of the password needs to be set on line 5:\n\nThe password in the example above is only 7 characters long, but the password length is actually one greater than 7 because there is a null character added to the end of the string. For example, if your password is 5 characters long, you would enter 6 for the password length.\n\nThe output pin that activates the relay is defined on line 7:\n\nAfter connecting everything to the Arduino, you should have something that looks like this:\n\nWell that’s about it. It’s not hard to set up a keypad at all. I think with a little trial and error you should be able to modify the code above to work with most of the projects you’d want to use a keypad for. But if you run into problems, just let us know in the comments and we’ll try to help you out."
    },
    {
        "link": "https://dronebotworkshop.com/keypads-arduino",
        "document": "A keypad is a useful feature to add to a project that requires data input. Today we will see how easy it is to use an inexpensive matrix membrane keypad with an Arduino.\n\nWe’ll see how the keypad works, check out a library that makes using the keypad very easy, and we’ll even construct an electronic combination lock.\n\nOne of the simplest interfaces for an Arduino project is a push button switch. It can easily be added by connecting one side of the switch to ground and the other side to one of the Arduino’s digital input pins. Hold the input pin HIGH, either by using a resistor or the microcontroller’s internal pullup, and that’s all you need. Pressing the button will send the input pin LOW, and you can detect this change within your sketch to provide functionality for the push button.\n\nExpanding the number of push buttons just requires you to repeat this process using different input pins. Simple, but it does present some design problems:\n• None One wire, plus a ground connection, for every push button can add up to a lot of wiring.\n• None It adds to the complexity of your sketch. Well perhaps “complexity” is an exaggeration, but it does require more code!\n• None Eventually, you’ll run out of input pins on your Arduino, especially if you are not using a Mega 2560.\n\nThere are a couple of better ways to add a number of push button switches to your project.\n\nThis is the ultimate solution. You can add a full 101-key keyboard to your project using the serial input connection. This will allow for very complex data entry, while using a minimal number of inputs on the Arduino. You can even respond to events that require two (or three) keys to be pressed simultaneously.\n\nBut doing this is usually overkill if all you need is a numeric input, such as for a combination lock or a settings panel.\n\nThis is a really elegant solution, and it only takes one analog input.\n\nWith this arrangement, a group of push buttons are connected to different points within a resistor array, that itself is connected between the reference voltage and ground.\n\nWhen a push button is activated it causes a voltage to be sent to the analog input. As each push button is on a different leg of the array it will have a unique corresponding voltage. Your sketch can read the value of the A/D converter and use it to determine which button was activated.\n\nThis is a good solution for applications that only require a few push buttons, add too many buttons and you run the risk of inaccuracies due to reference voltage fluctuations or resistor tolerances.\n\nBut it certainly is a viable choice, and we have used it before in the article about using LCD displays. The LCD display shield has a group of push buttons wired up in this exact fashion.\n\nThis is the solution we will look at today.\n\nA matrix keypad is a group of switches connected in an X-Y, or row-column, matrix arrangement. Pressing a button will connect a row with a column, and we can then scan the array to determine which button was pressed.\n\nBy arranging the push buttons in a matrix as opposed to connecting them directly to input pins we can usually reduce the amount of wiring. Commercial matrix keypads are inexpensive and readily available, which simplifies the wiring even more.\n\nThis is a great solution, with the following caveats:\n• None You need at least six pushbuttons. Fewer than six defeats the wiring advantages, as six pushbuttons will require a 2 x 3 matrix for a total of five wires. A larger number of keys will increase the advantage of using a matrix.\n• None You don’t require users to press two buttons simultaneously. The keypad solution will only accept one input at a time.\n• None You’ll need to use a software routine to determine which button was pressed, this is in addition to the code you’ll need to write to actually do something once the keypress is received.\n• None You’ll still need a lot of inputs, not as many as discrete switches (providing you stay over five) but more than the resistive keypad or ASCII keyboard solutions. Once you exceed 25 push buttons you’re better off choosing the ASCII Keyboard solution.\n\nIn many cases, the matrix keypad still has a lot of advantages. And that’s what we will be using in our experiments today.\n\nThe type of keypad we will be using today is a “Matrix Membrane Keypad”. This is an X-Y matrix of switches created using layers of plastic and conductive surfaces. These devices are inexpensive and can be styled to match your project, reducing the mechanical work of mounting all of those push buttons.\n\nTwo extremely common membrane matrix keypads are the 4 x 3 keypad (12 switches) and the 4 x 4 keypad (16 switches). They are laid out in the same fashion as a telephone keypad, which is a common user interface that most people are familiar with.\n\nAlthough I’ll be using the 4 X 4 matrix keypad in today’s experiments you can easily substitute the 4 x 3 unit with minor wiring and code changes.\n\nTo understand how matrix keypads work we’ll examine the operation of a basic 4 x 4 keypad.\n\nAs you can see from the above illustration the keypad consists of four rows and four columns, overlaid by 16 push button switches (represented by circles). Pressing a switch will connect its corresponding row and column lines.\n\nIn order to use the keypad we will make all of the column connections inputs and hold them HIGH, so they all have a value of digital one. The rows are configured as outputs, each with a value of zero or LOW.\n\nWhen a key is pressed, as illustrated above, it will connect its column input to one of the row outputs. This will bring that input LOW, and in doing so it reveals which column the switch belongs to. It also serves as an indication that a switch was pressed.\n\nNow we need to determine which row the switch is connected to. To do this we will pull all of the column inputs LOW (technically we really only need to keep our detected column LOW, but it is simpler to control them all).\n\nAfter doing this we begin scanning the rows by raising them HIGH, one-by-one. In the above illustration, we test the top row, which produces no results.\n\nScanning the second row by bringing it HIGH also produces no results.\n\nThe third row, however, is the correct row. Bringing it HIGH will cause the column output to go HIGH, revealing the location of the switch.\n\nWhile the above steps may at first appear complex they actually are not. We will be using a common library to do all of the work for us.\n\nThe keypad we will be using in our experiments is very inexpensive and easily available. It consists of four rows and four columns, each connected to a film ribbon cable.\n\nThe film ribbon cables both terminate with an 8-pin female Dupont connector. The pinouts are as follows:\n\nIf you obtain a 4 x 3 keypad you can use it in the experiments, the only difference is that it will have a 7-pin connector and will be missing the Column 4 connection.\n\nNow that you understand how the keypad works let’s see how to use it with an Arduino.\n\nThe first experiment we’ll perform with the keypad is to simply connect it up to the Arduino and use the serial monitor to verify that we can read all of the keys. This is a good way to get to know how to work with the keypad, and can also be used to verify that all of the keys are indeed working.\n\nThe hookup of the keypad and the Arduino is shown below:\n\nThe easiest way to get everything connected is to use a multi-conductor male-to-male Dupont ribbon cable with 8 conductors. The hookup is quite simple, as the Arduino connections are all made in the same order as they are on the keypad connector.\n\nOnce everything is hooked up you can proceed to the sketch that we’ll use to test our keypad.\n\nThe sketch we’ll be using is simplified by the use of a special library, the Keypad Library by Mark Stanley and Alexander Brevig. With this library using matrix keypads is very easy.\n\nYou can install this library directly from your Library Manager.\n• None . This will open the Library Manager dialog box.\n• None From the results scroll down until you find the\n\nOnce you have this library installed you can enter the following sketch:\n\nThe code for this sketch is very simple. The main thing to note is how the keypad library requires its input parameters in an array format.\n\nAfter including the Keypad library we define a couple of constants for the number of rows and columns in our keypad. If you are using a different keypad then modify these parameters accordingly.\n\nNext, we create an array that represents the rows and columns of the keypad. The elements of the array define the values of each key.\n\nFinally, we define a couple more arrays. These arrays specify the Arduino connections to the row and column pins on the keypad.\n\nWe use all of the above arrays with the Keypad library to create an object that represents our keypad.\n\nIn the Setup, we just need to start the serial monitor.\n\nThe Loop is very simple. We use the getKey method of the keypad library to get a key value when it detects a keypress. Then we simply print that to the serial monitor.\n\nLoad the sketch and open your serial monitor, making sure to observe the baud rate (it should be 9600 baud). Now press some keys on the keypad. You should observe the key values displayed on the serial monitor.\n\nOur next experiment is just an extension of the first one. This time we will use an LCD display instead of the serial monitor to read keypress values.\n\nUsing a display such as an LCD or OLED display with the keypad is a very common application, as it can give you feedback when you are entering data.\n\nTo reduce the number of connections required we will be using an LCD display with an I2C backpack. This makes the hookup extremely simple, as illustrated below:\n\nOnce you have it all connected we can modify our sketch to use the LCD.\n\nOnce again we will be making use of a library to simplify our coding. Unlike the previous library, however, this one is not available in the Library Manager.\n\nThe LiquidCrystal_I2C Library is specifically meant for driving LCD displays that use the I2C backpack. You can download this from GitHub as a ZIP file.\n\nOnce you have the ZIP file downloaded you’ll need to install the library.\n• None Use the dialog box to navigate to the ZIP file you downloaded and select it.\n\nNow that you have the library let’s take a look at our modified sketch.\n\nA quick look at the code confirms what you probably already suspected – this sketch is virtually identical to the last sketch!\n\nOne difference, of course, is that we are including both the Wire Library for I2C and the new LiquidCrystal_I2C library that we just installed. Both of these libraries are required to use the LCD display with the I2C backpack.\n\nIn line 39 we create an object to represent our LCD display. The first parameter in the object is “0x3F”, which is the hexadecimal I2C address of the display. If you are using a display that has a different I2C address you will need to modify this parameter accordingly.\n\nIn the Setup we initialize the LCD display and also enable its backlight.\n\nThe Loop is almost identical to the previous sketch. Once again we get the value of the keypress and hold it in a character variable. Then we clear the LCD display and print the character to the display. It will remain on the display until the next key is pressed.\n\nLoad the sketch and observe the display while you press keys. If you don’t see anything try adjusting the brightness control on the I2C backpack.\n\nNow that we have the basics down let’s build something practical with our keypad.\n\nA great use for a matrix keypad is to build a combination lock. You can use this to lock a door or a drawer or to regulate access to an electronic device.\n\nOur lock project will drive a relay, which in turn could be used to activate a standard locking solenoid. These devices stay in the locked position and will only release the lock when voltage is applied to them. Typically these devices use 12-volts to operate.\n\nIn most cases you’ll only want to apply voltage for a few seconds, just enough time to unlock the solenoid to open the guarded area. Applying voltage to the solenoid for too long a period can burn it out, you should read the specifications on your locking mechanism for more details.\n\nOur lock will operate as follows:\n• None The LCD display will prompt the user to enter a password\n• None As the password is entered it will be printed on the display\n• None When the correct number of characters have been entered the code will check the data against the stored combination.\n• None If the code is correct it will activate the relay for five seconds.\n• None If the code is incorrect it will display an error message.\n• None It will then clear the display.\n\nLet’s get working on it!\n\nAll that we need to do to create our lock is to add a relay module to the existing LCD hookup, as shown here.\n\nThe output of the relay is labeled as follows:\n\nTypically you would connect one side of your solenoid (or other activated device) to one side of the power supply (i.e. 12-volts). The other side would be routed between the Common and NO connections of the relay. This way the relay will switch the solenoid on when it is activated.\n\nIn my experiment I just used a lamp, as it was easier to see in the video!\n\nAfter wiring it up it’s time to turn our attention to the sketch that will run our combination lock.\n\nHere is the code for our combination lock:\n\nYou’ll note that it uses the same libraries as the LCD sketch, which of course makes perfect sense.\n\nWe define the length of the password on line 23. Note that this also includes a null character, so the value here is actually one more than the actual password length. You can change this to make an easier or harder password.\n\nTwo character variable arrays are defined. The Data array holds the key entries, and the Master arry has the actual password. You should edit the password to be something harder to guess than just the first seven digits on the keypad!\n\nWe also define the lock output pin. I used pin 13, as the Arduino has a built-in LED on that pin, so it can be used for troubleshooting if the relay fails to activate.\n\nThe byte_count variable counts the number of keypresses entered.\n\nIn the Setup we define pin 13 as an OUTPUT.\n\nWe start the Loop by placing the LCD cursor in the top left corner and printing “Enter Password:”. Then we look for a keypress, as we did in the previous sketches.\n\nIf we get a keypress we record the value in an element of the Data array. We then increment the counter for the next keypress.\n\nAfter that we check to see if we have enough characters. If we don’t we end the Loop and repeat until we do.\n\nOnce we have enough characters we compare the Data array to the Master array. If the arrays are identical then we have the correct password and we activate the relay for 5 seconds. If it is incorrect we print “Incorrect” on the display and hold it there for a second.\n\nIn both cases we then clear the display and call the clearData function to clean out the Data array.\n\nLoad the sketch and give it a try. If you’re successful you should now have a working combination lock. You can experiment changing the password length if you wish.\n\nMatrix keypads are an easy-to-use input device that can add a lot of functionality to your Arduino projects. They are inexpensive and they can give your project a professional look and feel.\n\nOne of these keypads would be a great addition to your next Arduino project."
    },
    {
        "link": "https://embedjournal.com/interface-4x4-matrix-keypad-with-microcontroller",
        "document": "In this post we will discuss logic and interface of a matrix keypad (4x4 for this post) with microcontroller to reduce the number of port pins required to read a certain number of inputs (digital). The same logic applies to any matrix keypad of order NxN. Where, N is the order of the matrix.\n\nTypically one port pin is required to read a digital input into the controller. When there are a lot of digital inputs that have to be read, it is not feasible to allocate one pin for each of them. This is when a matrix keypad arrangement is used to reduce the pin count.\n\nTherefore, the number of pins that are required to interface a given number of inputs decreases with increase in the order of the matrix.\n\nExample: If the matrix is 2x2, you will need 2 pins for the rows and 2 pins for the columns. In such a case there is no difference in the cost of reading that many inputs. But if you consider a 10x10 matrix you will just need 20 pins (10 for the rows and 10 for the columns) to read 100 digital inputs.\n\nHow is it wired up internally?\n\nHere is how the matrix keypad is wired internally.\n\nFrom the circuit you can see that when one of the 16 buttons are pressed, a pair of pins are connected together. We will use this feature to detect the button that was pressed in the following sections.\n\nInitially all switches are assumed to be released. So there is no connection between the rows and columns. When any one of the switches are pressed, the corresponding row and column are connected (short circuited). This will drive that column pin (initially high) low. Using this logic, the button press can be detected. The colors red and black is for logic high and low respectively. Here are the steps involved in determining the key that was pressed.\n\nThe first step involved in interfacing the matrix keypad is to write all logic 0’s to the rows and all logic 1’s to the columns. In the image, black line symbolizes logic 0 and red line symbolizes logic 1.\n\nFor now let us assume that, the circled key is pressed and see how the key press can be detected by a software routine.\n\nNow the software has to scan the pins connected to columns of the keypad. If it detects a logic 0 in any one of the columns, then a key press was made in that column. This is because the event of the switch press shorts the C2 line with R2. Hence C2 is driven low.\n\nNote: color of the lines indicate the logic values they return.\n\nOnce the column corresponding to the key pressed is located, the next thing that the software has to do is to start writing logic 1’s to the rows sequentially (one after the other) and check if C2 becomes high. The logic is that if a button in that row was pressed, then the value written to that row will be reflected in the corresponding column (C2) as they are short circuited. Note: color of the lines indicate the logic values they return.\n\nThe procedure is followed till C2 goes high when logic high is written to a row. In this case, a logic high to the second row will be reflected in the second column.\n\nNote: color of the lines indicate the logic values they return.\n\nWe already know that the key press happened at column 2. Now we have detected that the key is in row 2. So, the position of the key in the matrix is (2,2)\n\nOnce this is detected, its up to us to name it or provide it with a task on the event of the key press.\n\nNow lets see how the above logic can be implemented in embedded C. Here is the program I wrote to test it. This code is for PIC microcontrollers with c18 lite version compiler. I as usual, used a lot of macros so if you are an Arduino user you could easily make some alterations to the code and use it. The basic concept for keypad scan is inside the while(1) loop.\n\nHere is a video demonstration for the interface of the 4x4 matrix keypad using the above code.\n\nThe above program is done with polling and utilizes the entire time of the controller to scan the keypad and display the data on the 7 segment displays. There is a cool feature on Microcontrollers called as the Interrupt on Change (IOC). As the name suggests, the controller will interrupt if it finds any change in a port. In PIC the whole of PORT B has this feature. By using the feature without any change in the hardware setup we can scan the keypad in the ISR and have more of the controller’s time to do something useful.\n\nIn my upcoming posts I will use the IOC feature to interface the keypad."
    },
    {
        "link": "https://embedded-lab.com/blog/lab-18-matrix-keypad-interfacing",
        "document": "Matrix keypads are very common input devices in embedded systems. They have simple architecture and are easy to interface. One good thing about them is that they allow you to interface a large number of input keys to a microcontroller with minimum usage of I/O resources. This tutorial describes two different approaches of reading input data from a 4×4 (16 keys) matrix keypad interfaced to a PIC microcontroller. The pressed key information is displayed on a character LCD. The microcontroller used in this experiment is PIC16F1827.\n\nMatrix keypads are simply an extension to the simple tact switch inputs. They consists of keys interconnected in the shape of a matrix. Each key is a simple mechanical switch located at the crossing between the matrix rows and columns. When a key is pressed, its row and column form an electrical contact. The rows and columns can be connected to the pins of microcontroller ports. The big advantage of using a matrix keypad is that it allows to interface a large number of keys with a relatively small number of microcontroller pins. For example, a 16-key keypad requires only 8 (instead of 16, if interfaced individually) I/O pins of the microcontroller if organized into a 4 rows and 4 columns matrix. The circuit diagram for this experimental tutorial is shown below. It interconnects a 4×4 matrix keypad to PORTB of the PIC16F1827 microcontroller. The microcontroller runs at 500 KHz using the internal clock source. The PORTA pins drive a character LCD that displays the pressed key information.\n\nNow lets talk about the different approaches of keypad scanning, which is required to identify which key has been pressed.\n\n Sequential exploration of rows: In this method, the I/O pins connecting the rows are all configured as output and those connecting the columns are defined as input, or vice-versa. The column lines, which are inputs to the microcontroller, are pulled-high using the internal pull-up resistors. Therefore, the default input to these lines is 1. The state for the matrix keypad can be explored by turning the rows low sequentially, one at a time, and reading the columns. For example, set the first row to 0 and read all the columns. If any key has been pressed in that row, the corresponding column line must read as 0. Otherwise, go to the next row and set it to 0, and read the columns again. This process is repeated until a 0 is found in a column. This determines the row and column for the pressed key, thus giving the exploration code for that key.\n\n Simultaneous exploration of rows and columns: In this method, all rows and columns are explored simultaneously in two phases. First, the rows are configured as output and the columns as input. Internal pull-ups are enabled on the column lines. Then all rows are set to 0 and the columns are read. In any key has been pressed, the corresponding column will be read as 0. This detects the column but not its row. The whole process is reversed next. The rows are configured as input and the columns as output. Internal weak pull-ups are now enabled on row lines. All columns are set to 0, and the rows are read. The row that reads 0 contains the pressed key. This gives both the row and column for the pressed key. This approach of exploring the keypad is relatively faster than sequential exploration approach.\n\nIn case the microcontroller does not have the internal pull-up feature on its I/O port, the pull-up resistors on the input lines must be connected externally.\n\nI am using my PIC16F1827 development board to demonstrate both the techniques of keypad scanning. The setup for this experiment is shown below.\n\nI wrote the keypad scanning subroutine in mikroC Pro for PIC compiler, for both the techniques described in the theory section. In order to enable the weak pull-up on PORTB pins, the Weak Pull-up Enable (WPUEN) bit of OPTION_REG must be cleared and the corresponding bits of Weak Pull-Up on PORTB (WPUB) register must be set. The two programs (source code and HEX files) can be downloaded from the links provided below. Note that the mikroC Pro for PIC compiler also provides built-in library for Matrix Keypad, but that is not used here.\n\nmikroC Project files for simultaneous exploration of rows and columns\n\nWe discussed two basic approaches of keypad scanning and implemented it with a 16-key keypad interfaced to PIC16F1827 microcontroller. Both the techniques have one drawback, which is the microcontroller must continuously scan the rows and columns to make sure that it will not miss any key hit. This is a waste of time and CPU cycles, and it could burden the microprocessor’s resources and consume excessive amounts of power. There’s an alternative approach for overcoming this drawback: Interrupt driven keypad scanning. Using an interrupt frees the microcontroller to perform other tasks or to switch into a power-down mode while awaiting the next key closure. It also reduce electromagnetic interference produced by continuously scanning the rows and columns of the keypad. With PIC microcontroller’s Interrupt-on-change feature, this is easy to implement. I will describe this technique in another section very soon."
    },
    {
        "link": "https://jameco.com/Jameco/workshop/JamecoBuilds/working-with-matrix-keypads.html?srsltid=AfmBOopXklBLCbOD5HT9RXrWNothbxO7-3DU29aNjqRba1cjtIfiJHko",
        "document": ""
    },
    {
        "link": "https://summivox.wordpress.com/2016/06/03/keyboard-matrix-scanning-and-debouncing",
        "document": "Without diving into the “why” part, I wanted to make yet another keyboard with Cherry MX keyswitches (just like everyone else these days), and I ended up deciding to make my own keyboard controller (again like everyone else). After all…\n\nApparently, scanning a keyboard matrix is a solved problem. There are two main challenges:\n• Detect arbitrary simultaneous key presses. This is usually referred to as NKRO or N-Key Roll-Over (excluding protocol limits, e.g. old USB keyboard drivers). The article already covered the solution: simply add a series diode to each switch.\n• Filter out mechanical and electrical transients during a single key-down or key-up event. This is usually referred to as debouncing. There are many sources online that cover this, and equally many solutions — firmware, hardware, and more commonly a combination of the two. See this Wikipedia entry on Switches, and this must-read tutorial by Ganssle.\n\nWhile guys at Cherry (the company that makes the MX switches) believes otherwise, most other keyboards using MX switches achieve NKRO using the “outdated digital technology” just fine. So I confidently drew my 1st prototype PCB as a 10×10 Cherry MX switch matrix with per-key series diodes, sent it to fab, and started writing my own controller.\n\nA keyboard controller reads a key matrix (assuming it has per-switch series diodes) in the same way it reads a multiplexed bus:\n\n\n\n Timing diagram created with WaveDrom. See this gist for source and SVG.\n• drive only 1st row line to high (the rest hi-z or low)\n• drive only last (10th) row line to high\n\nIgnoring the “TIM1” for now (will cover later), the diagram illustrates the sequencing of the row lines (output), the response of the column lines (input), and a possible “strobe” signal, which indicates the exact moments when column lines should be sampled.\n\nOn an AVR, this might be done in a idle-spin loop or through interval timer interrupts. If you don’t have enough pins you can always use 2 ‘s (8-bit serial-in parallel-out shift registers), but you still need to manually clock them, either through bit-banging or by feeding bytes to a SPI master peripheral. Sounds like a trivial task burning lots of CPU cycles!\n\nI am a big fan of the series, mostly owing to its well-designed timer peripheral blocks, which are not only very flexible, but also available in even the cheapest variant (e.g. which retails for USD \\$1.69 each on Digi-Key). Common applications include generating complex PWM output signals or reading incremental/quadrature encoders. While the PWM function cannot directly produce our desired row pins driving pattern, it is only a side-effect of the timer’s underlying “output compare” mechanism: An internal event is fired when the timer counter reaches the value stored in a register. This event can be programmed to trigger a variety of behaviors including:\n• an output change, which produces a PWM signal on a single pin\n• an interrupt request, which we try to avoid so that the CPU is not tied up doing boring I/O\n\nThe DMA request option is interesting. All s feature a simple DMA controller with multiple independent “channels” or “streams”; each channel transfers one word (1/2/4 Bytes) of data between a pair of pre-programmed source/destination addresses upon request from a peripheral (it does more but this is what we care about for now). The addresses can be anywhere in the flat 32-bit Cortex-M address space (again greatly simplified; actually depending on bus architecture and address space mapping). Expressed in C it does roughly one of the following (without burning CPU cycles; only consuming memory bandwidth):\n\nWe need to access many I/O pins at once. By accessing GPIO port registers, the following can be done:\n• atomically changing several output pins in a GPIO port without affecting others (in : write to (bit set/reset register))\n• sampling the value of all (16) pins in a GPIO port (in : read from (input data register))\n\nIn many cases, one or more timers can actually have multiple DMA request lines connected to different channels. e.g. for , has both its update event (happens when the up-counter overflows and resets to 0) and its output compare channel 4 event connected. This allows us to configure said timer alongside with 2 DMA channels and 2 GPIO ports to completely automate the desired I/O sequence:\n• Allocate all row output pins on one GPIO port (e.g. , and all column input pins on another GPIO port (e.g. (note that pin numbers do not have to be consecutive).\n• Configure the timer as a PWM timer; the PWM output pin does not need to be connected\n• The update event is responsible for sequencing the row outputs; configure its corresponding DMA channel to transfer a 32-bit word from an array (see below) to the row GPIO port\n• The output compare event after an update event is responsible for reading the column inputs; configure its corresponding DMA channel to transfer a 32-bit word from the column GPIO port to another array (see below)\n• Generate an update event (which resets the counter and triggers initial row output DMA request)\n\nWithout considering deadband generation (which by the way can be done although with more effort and memory waste), the two arrays mentioned above can be set up in the following way:\n• stores the register value to be written to the row GPIO port at each “step” in order to output low on all row pins but the indexed row, and output high on this row. This is set as a circular buffer input of the row output DMA channel.\n• is a double buffer; each half then stores value of all pins in the column GPIO port sampled when each row is active.\n\nWith all the pieces in place, let’s see how they fit together. Here is the timing diagram again:\n\nThe line shows its counter value. For illustration purposes, suppose the period is 5 (really long) ticks, and the output compare register is set to 4. The following happen during one full period:\n• Update event occurs and timer counter becomes 0. This triggers DMA transfer from to of row GPIO port, which outputs the correct row output pattern for this period.\n• After some delay (DMA, GPIO, signal propagation, capacitance, …), the column lines now read which keys in current row is pressed.\n• When counter reaches 4 (== output compare register), column input DMA is triggered, and dumps the column GPIO port pin values from to (as shown in line).\n\nNotice that the out/in arrays are transferred from/to in lock-step (modulo double buffering). The timer and DMA automatically populates with the latest scan of the key matrix. While it contains all pins in the column GPIO port, it is trivial to pluck out only the column input pins using some bitwise ops. Other than this, we spend zero CPU cycles during the actual scanning. The hardware worked together to do all the heavy lifting as if we’re using an ASIC. This allows us to use a high scanning rate (e.g. 20us per row, 200us per full scan) while leaving the CPU free to handle other tasks. Amazing.\n\nThe scanning module above effectively samples each key as a discrete-time binary signal. However, this signal does not always reflect the pressed/released binary state of the key switch itself:\n• EMI (electromagnetic interference) might cause spikes which could be picked up when the switch is being sampled; this may happen all the time.\n• When the switch is being pressed or released and the contacts within the switch is at the boundary of making/breaking, a short burst of oscillating transients almost always occurs as the mechanical system formed by the contacts oscillates. They eventually settle down and come into stable and unambiguous contact or separation as mechanical damping kills the oscillation. This is the “contact bounce” phenomenon. For Cherry MX switches, the transients can last 5 milliseconds after initial edge according to official datasheets.\n\nHere are some typical oscilloscope traces of contact bouncing:\n\nIf a keyboard controller does not take into account of these issues, it would generate spurious key press/release events without corresponding actual key presses/releases. Clearly this is undesirable. “Debouncing”, as the name suggests, refers to producing a signal that is free of above issues and faithfully represent the true state of whether a key switch is pressed or not.\n\nThis may sound a lot of hand-waving, so instead let’s start from first principles:\n\nThe moving part of a switch is referred to as its “actuator”, and in the case of Cherry MX more commonly as “plunger” or “stem”. We define the vertical position of the plunger to be 0 when it is released and supported entirely by the spring; grows positive as the plunger is pressed further down. This position alone provides a ground truth of whether the switch is pressed or not (binary signal): a schmitt trigger on . Notice that the ground truth has nothing to do with the electrical parts of the switch, and therefore is subject to neither EMI nor contact bouncing. The task of debouncing can then be defined as online (causal) reconstruction or estimation of the ground truth using only the sampled (noisy) electronic signal. Objective of a good debouncer is to minimize both spurious events and delay in its output compared to ground truth, while trying to be modest on computational resources.\n\nStrictly speaking this is not really a part of the “debouncer” proper, but rather a simple EMI countermeasure. A 1st order low pass RC filter on each column line effectively attenuates the electrical noise.\n\n\n\n RC filtered bouncing analog waveform captured from one of my own Cherry MX clear switches\n\nThere is a catch, though: while the time constant of this filter is straightforward to choose if only one switch is connected, the key matrix case is much more complex due to scanning. The time constant must be much smaller (say, 1/4) than the total duration a particular row is active (i.e. the period of in the scanning timing diagram), so that the transients caused by scanning can die off.\n\nAnother detail applies to SPST switches with pull-up/-down resistors: You need a bypass diode to ensure symmetrical time constants when the switch makes vs. breaks. See Ganssle’s article for details.\n\nMany debouncers make decisions by counting consecutive 1’s or 0’s in the sampled input. Here is a sophisticated example which is an improved version of someone else’s counting code.. The core idea is we can be reasonably sure that a switch is not bouncing — that is, in steady state instead of transient — when the reading from it remains the same for long enough.\n\nMain disadvantage of this approach: since it effectively waits for the contact bounce to completely die out before it can make a decision, the delay can be too long. While this is generally okay for typing, it is unacceptable in real-time applications such as gaming.\n\nAnother way is to consider the scan input as as opposed to , then use a saturated integration/accumulation of this signal across time. In the continuous-time form:\n\n $$\n\n y = \\int_0^T \\mathbf{1}_{\\,0 < y < 1}\\cdot\\frac{x(t)}{\\tau}\\,dt\n\n $$\n\n where $\\tau$ is a time constant that determines how fast $y$ can swing from one end (e.g. 0) to the other (e.g. 1). Higher values lead to more delay but also more robustness. When $y$ reaches $0$, output of the debouncer is set to low; similarly $1$ sets output to high.\n\nThe continuous time equation can be converted to discrete time integer accumulation by scaling $y$ by $\\tau/\\Delta t$, so that at every time-step $y$ can be simply incremented or decremented by 1 then compared to a larger integer boundary.\n\nWhile this approach could be less robust than the consecutive run approach, its delay is no longer than the consecutive run approach even when the same time constant is used. This is because the counter may still make progress during contact bounce.\n\n(I made up the name).\n\nThis approach puts minimal delay far in front of robustness. Due to causality (i.e. you cannot predict the future), the earliest moment a debouncer can claim a transition is the first time its input changes. This is exactly what The Quick Draw approach does, with a single twist: After this transition, since we know that more bouncing is coming, the algorithm waits for a certain duration before it reads this key again, so that it does not misfire on the subsequent bouncing transients, and hopefully arrive directly at steady state.\n\nMain disadvantage is of course robustness. It is extremely susceptible to EMI that escapes the hardware filter, as well as temporary breaking caused by aged metal contacts (which behaves in similar ways as EMI but is somehow coupled to the mechanism).\n\nIt is worth noting that some custom keyboard controllers (forgot source) selectively apply this method on demand, e.g. during gaming sessions. Also, it might work surprisingly well enough when the plunger goes from released to pressed (making contact), because we are certain that the bouncing cannot occur if the button is not pressed in this case.\n\nSo we're starting to see a trade-off here: delay vs. robustness. As an attempt to make this tunable and achieve a compromise between the two, I conceived a slightly more complex counter and state-machine based algorithm.\n\nBefore diving into the algorithm, though, notice that all above algorithms are symmetric, meaning that they do not distinguish between making and breaking of contacts. A reason against asymmetric algorithm is that doing so would require physical modeling of contact dynamics, which can be prohibitively hard. Even if we could come up with a model for one particular switch, an algorithm that takes advantages of it would likely not work as well on other switches. Therefore, the practical choice is to accept any asymmetry present in the physical system as unmodeled dynamics and create an algorithm that works anyway.\n\nThe general idea is to have 2 classes of states: steady-state and transient. We keep a counter for each key that increments/decrements when input is high/low respectively, similar to the purely counter-based approach mentioned above, with a notational difference for convenience: the counter is clipped between to .\n\nThe (symmetric) state machine is as follows:\n• A key starts in steady-state low, with counter saturated at . In this state we are confident that the key is not pressed until we start to see a few 's at input, which likely indicates a low-to-high transient. This \"transient detection\" is done by comparing the counter against a threshold , where is the number of consecutive 's it takes for the algorithm to confirm a transient.\n• Once the transient is confirmed, we immediately switch the output to high. At this time the contacts are likely to be still bouncing, and we wish to ignore that until they settle down. This is the opposite problem from last: we are trying to detect steady-state. Note that the key might end up in either low or high when it settles down — the algorithm was convinced that the key is pressed, but however unlikely it might appear, this could have been a false alarm. A way to find out is to reset the counter to (neutral between low and high), and wait until it reaches either or . If it reaches then we know for sure that the key has ended up being pressed (and is now steady-state high); would mean the algorithm made a mistake and we need to switch the output back to low.\n\nThe high-to-low cases are identical except for flipped signs.\n\nWhile I have yet to sample any real bouncing on my brand-new Cherry MX clear (they are surprisingly clean — 2 to 4 bounces that last less than 100us in total), I would imagine such an algorithm robust enough to match just about any switches out there if and thresholds are picked according to the characteristics of the particular switch. It is flexible: you can trade delay for robustness by increasing the thresholds and vice versa.\n\nI packed this algorithm into a class and tested it on my complete keyboard system and it worked perfectly so far with negligible delay ( was set to confirm transient in 600us, or 3 scan cycles, if no bouncing; more if bouncing gets sampled). Code as follows:\n\nAfter formulating the debouncing problem like above, I realized that it is in essence a simplified variant of my 10-701 Machine Learning final project. That project aims to detect from motion capture data of human walking (on a treadmill) whether each foot is bearing weight or not (stance or swing) at any given time. We approached the problem using — you don't even need to guess — deep recurrent neural network, specifically LSTM. It doesn't matter what the inputs are — it matters that the network basically (causally) recovers a low-frequency binary time-series from a number of other real-valued time-series. If you replace the input with what we get from the matrix scanning, the network becomes a debouncer!\n\nWhile I have not proceeded with this idea, since both input and output are exactly 1D, I would estimate that a small network will probably do just fine (say, 5 LSTM cells), and evaluation should not take too much computational power — might even be possible on an MCU if optimized properly. Fixed point math and crazy approximations should be used to speed things up further.\n\nMain disadvantage: Supervised learning. Large amount of labeled data is required. This data can be automatically generated though: a viable approach is to use a hobby servo to repeatedly press the key and record both the servo position and the switch response. The position can be used to derive a ground truth signal.\n\nI know these switches have been basically the same as when they were first invented in 1980. Honestly I like the force profile of the tactile and click switches (not so much of linear switches because nothing is special about Hooke's Law). With my mechanical/automation background I very well know the importance of these human-machine interfaces — even in factories with large levers, buttons, footswitches, overtravel bumpers, etc. However, instead of mechanical contacts, switches intended to control small signals have a better option than mechanical contacts: optical, Hall effect, both of which already intensively used in industrial automation and even used in some keyboards: this one made by Bloody and some obsolete stuff made by Honeywell which somehow became part of the history thanks to the Lisp Machine's Space Cadet Keyboard.\n\nSo instead of \"patented golden cross-point technology\", how about replacing only the metal contacts with a hall effect sensor? This way we can directly and reliably measure the plunger position and totally avoid the bouncing problem. Better still, we can also get the velocity of key presses, which is useful in musical applications. All this can be done without changing the \"feel\" of the switch itself…\n\nSounds perfect, although this is way out of my scope. Modifying a single Cherry MX might be marginally doable for me due to precision work on injection-molded plastics; scaling this to a whole keyboard would be outright impossible at the moment."
    },
    {
        "link": "https://reddit.com/r/embedded/comments/j20ttp/implementing_control_theory_with_embedded_systems",
        "document": "Hi please pardon me if I don’t make sense, I have practiced control systems using matlab, I would like to do a project with the knowledge I learnt from control systems in a real board, but I can’t make neither head nor tails. I want to implement using GNU tool chain(well that’s one of the term I have learnt so far), being as less dependent on Matlab as possible for implementing code aside from simulation. I have ordered a beagle board with the 9 cents knowledge I have about a embedded systems. Now my humble heart asks the Embedded gurus of reddit to please help me pave the way for my embedded desire:"
    }
]