[
    {
        "link": "https://docs.spring.io/spring-boot/docs/2.5.x/reference/htmlsingle",
        "document": ""
    },
    {
        "link": "https://docs.spring.io/spring-boot/docs/2.5.5/reference/htmlsingle",
        "document": ""
    },
    {
        "link": "https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.5-Release-Notes",
        "document": "The underlying method used to support and scripts has been redesigned in Spring Boot 2.5. properties related to initialization have been deprecated in favor of new properties. These properties can also be used to initialize an SQL database accessed via R2DBC. With Spring Boot 2.5.1 and above, the new SQL initialization properties support detection of embedded datasources for JDBC and R2DBC. By default, SQL database initialization is only performed when using an embedded in-memory database. To always initialize a SQL database, irrespective of its type, set to . Similarly, to disable initialization, set to . The new script-based SQL database initialization does not support using separate credentials for schema (DDL) and data (DML) changes. This reduces complexity and aligns its capabilities with Flyway and Liquibase. If you require separate credentials for schema and data initialization, define your own beans. By default, scripts are now run before Hibernate is initialized. This aligns the behavior of basic script-based initialization with that of Flyway and Liquibase. If you want to use to populate a schema created by Hibernate, set to . While mixing database initialization technologies is not recommended, this will also allow you to use a script to build upon a Hibernate-created schema before it’s populated via . Beans of certain well-known types, such as , will be ordered so that they are initialized after the database has been initialized. If you have a bean that works with the directly, annotate its class or method with to ensure that it too is initialized after the database has been initialized. If you currently define a or you may need to provide additional and properties. In earlier versions of Spring Boot, these settings were derived from properties but this turned out to be problematic for people that provided their own DataSource beans. Spring Data JPA introduces a new method which replaces . If you find your application is now throwing a please rename any existing method to (where is an arbitrary string). For more details, please read the updated Spring Data JPA reference documentation. Following its removal from Spring Data in 2021.0.0, auto-configuration for Spring Data Solr has been removed in this release. The actuator endpoint is no longer exposed over the web by default. Additionally, if Spring Security is on the classpath and your application doesn’t have a custom security configuration, the endpoint requires authenticated access by default. Refer to the documentation on exposing and securing actuator endpoints to change these new defaults. Spring Integration now reuses an available rather that configuring its own. In a typical application setup relying on the auto-configuration, this means that Spring Integration uses the auto-configured task scheduler that has a pool size of 1. To restore Spring Integration’s default of 10 threads, use the property. The EL implementation that is included in Spring Boot’s web and validation starters has changed. Tomcat’s implementation ( ) is now used in place of the reference implementation from Glassfish ( ). The attribute in the default error view is now removed rather than blanked when it is not shown. If you parse the error response JSON, you may need to deal with the missing item. You can still use the property if you want messages to be included. We now register a logging shutdown hook by default for jar based applications to ensure that logging resources are released when the JVM exits. If your application is deployed as a war then the shutdown hook is not registered since the servlet container usually handles logging concerns. Most applications will want the shutdown hook. However, if your application has complex context hierarchies, then you may need to disable it. You can use the property to do that. The Spring Boot Gradle Plugin no longer automatically disables the standard Gradle and tasks. Instead we now apply a to those tasks. If you prefer to disable those tasks, the reference documentation includes updated examples. Spring Boot no longer provides default values for properties. If you rely on , , or you should set values that make sense for your application. To streamline the customization of jOOQ’s , a bean that implements can now be defined. This customiser callback should be used in favour of defining one or more beans, the support for which has now been deprecated. The default version of Groovy has been upgraded to 3.x. If you are using Groovy and also using Spock, you should also upgrade to the latest Groovy 3.0-compatible release of Spock 2.0. Alternatively, use the to downgrade back to Groovy 2.5. Projects built with Gradle now require Gradle 6.8 or later. The default version of Hibernate Validate has been upgraded to 6.2.x. Hibernate Validator 6.2 changes how the expression language is used to interpolate constraint messages. Please see this blog post from the Hibernate Validator team for further details. Reflecting the Spring Boot release compatibility policy, code deprecated in Spring Boot 2.3 has been removed in Spring Boot 2.5. Code deprecated in Spring Boot 2.4 remains in place, and is scheduled for removal in Spring Boot 2.6."
    },
    {
        "link": "https://docs.spring.io/spring-boot/index.html",
        "document": "Spring Boot helps you to create stand-alone, production-grade Spring-based applications that you can run. We take an opinionated view of the Spring platform and third-party libraries, so that you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration.\n\nYou can use Spring Boot to create Java applications that can be started by using or more traditional war deployments.\n• Provide a radically faster and widely accessible getting-started experience for all Spring development.\n• Be opinionated out of the box but get out of the way quickly as requirements start to diverge from the defaults.\n• Provide a range of non-functional features that are common to large classes of projects (such as embedded servers, security, metrics, health checks, and externalized configuration).\n• Absolutely no code generation (when not targeting native image) and no requirement for XML configuration."
    },
    {
        "link": "https://docs.redhat.com/en/documentation/red_hat_support_for_spring_boot/2.5/html-single/release_notes_for_spring_boot_2.5/index",
        "document": "We appreciate your feedback on our documentation. To provide feedback, you can highlight the text in a document and add comments. This section explains how to submit feedback.\n• You are logged in to the Red Hat Customer Portal.\n• In the Red Hat Customer Portal, view the document in format. To provide your feedback, perform the following steps:\n• None Click the Feedback button in the top-right corner of the document to see existing feedback. The feedback feature is enabled only in the Multi-page HTML format.\n• Highlight the section of the document where you want to provide feedback.\n• None Click the Add Feedback pop-up that appears near the highlighted text. A text box appears in the feedback section on the right side of the page.\n• None Enter your feedback in the text box and click Submit.\n• To view the issue, click the issue tracker link in the feedback view.\n\nNo supported features or functionalities are introduced or upgraded in this release. 3.2.1. Deploy Spring Boot applications to OpenShift using the Dekorate Maven dependency Use the Dekorate Maven dependency to deploy your Spring Boot applications to OpenShift. The Fabric8 Maven plugin is no longer supported. For information about deploying your application to OpenShift, see Deploying Spring Boot application to OpenShift. OpenJ9 images for IBM Z and IBM Power Systems have been deprecated. The following OpenJDK11 image has been updated to support multiple architectures: You can use the OpenJDK11 image with the following architectures: If you want to use the OpenJ9 Java Virtual Machine (JVM) with the OpenJDK11 images, see Java Change in Power and Z OpenShift Images. Spring Boot 2.5 introduces support for building and deploying Spring Boot applications to OpenShift with OCI-compliant Universal Base Images for Red Hat OpenJDK 8 and Red Hat OpenJDK 11 on RHEL 8. The RHEL 8 OpenJDK Universal Base Images replace the RHEL 8 OpenJDK builder images supported by Red Hat for use with earlier releases of Red Hat Build of Spring Boot. The previously supported RHEL 8 OpenJDK base images are no longer supported for use with Red Hat Build of Spring Boot. You can add metering labels to your Spring Boot pods and check Red Hat subscription details with the OpenShift Metering Operator. Do not add metering labels to any pods that an operator deploys and manages. Spring Boot should use the following metering labels: See Metering documentation for more information. For more information on labels, see Understanding how to update labels on nodes. No features or functionalities are marked as deprecated in this release. You can use Dekorate to configure a Source-to-image build of your application that starts automatically after you compile your application with Maven. This functionality is provided as Technology Preview in Dekorate version 1.0.0 and later. Red Hat does not provide support for using this functionality in a production environment.\n\nFor a complete list of release components included in this release, and for information about the current support status of these components, see the Spring Boot 2.5.12 component details overview.\n\nThe text of and illustrations in this document are licensed by Red Hat under a Creative Commons Attribution–Share Alike 3.0 Unported license (\"CC-BY-SA\"). An explanation of CC-BY-SA is available at http://creativecommons.org/licenses/by-sa/3.0/ . In accordance with CC-BY-SA, if you distribute this document or an adaptation of it, you must provide the URL for the original version. Red Hat, as the licensor of this document, waives the right to enforce, and agrees not to assert, Section 4d of CC-BY-SA to the fullest extent permitted by applicable law. Red Hat, Red Hat Enterprise Linux, the Shadowman logo, the Red Hat logo, JBoss, OpenShift, Fedora, the Infinity logo, and RHCE are trademarks of Red Hat, Inc., registered in the United States and other countries. ® is the registered trademark of Linus Torvalds in the United States and other countries. ® is a registered trademark of Oracle and/or its affiliates. ® is a trademark of Silicon Graphics International Corp. or its subsidiaries in the United States and/or other countries. ® is a registered trademark of MySQL AB in the United States, the European Union and other countries. ® is an official trademark of Joyent. Red Hat is not formally related to or endorsed by the official Joyent Node.js open source or commercial project. The ® Word Mark and OpenStack logo are either registered trademarks/service marks or trademarks/service marks of the OpenStack Foundation, in the United States and other countries and are used with the OpenStack Foundation's permission. We are not affiliated with, endorsed or sponsored by the OpenStack Foundation, or the OpenStack community. All other trademarks are the property of their respective owners."
    },
    {
        "link": "https://wiredcraft.com/blog/wechat-for-dummies-user-data-and-authorization",
        "document": "Our “WeChat for Dummies” series tries to answer some of the most frequently asked questions we receive about WeChat from our clients and partners. We focus on topics such as User Data, Customer Service, CRM, Payment, Data Security, Data Analytics, and Personalization.\n\nHave another topic or question you’d like us to write about? Get in touch.\n\nWeChat currently has four platforms to connect its 1 billion users with its business, app, or website:\n• The Official Account platform 微信公众平台 allows users to push marketing campaigns and service related content to followers on WeChat.\n• The Hardware Platform 微信硬件平台 allows users to connect WeChat to devices like smart watches, smart toys etc.\n• The Smart Platform 微信智能开放平台 enables developers to utilize WeChat’s articial intelligence tools, such as image, video, or voice recognition.\n• The Open Platform 微信开放平台 connects your app or website to WeChat’s mobile services including user authentication and payment.\n\nWeChat Open Platform is a hub for mobile applications, website applications, Mini Programs, Official Accounts (OA) and third-party platforms.\n\nWhat are OpenID and UnionID?\n\nThese are two important parameters mentioned all the time by product people and developers.\n\nOpenID is an unique encrypted WeChat ID for each user of an OA (including Mini Program). Users have separate OpenIDs corresponding to different OAs. In Developer Mode, when subscribed users interact with an OA, the developer can obtain their OpenIDs and use it to get basic user information (gender, photo, location etc.)\n\nUnionID is an unique ID to identify a single user under the same WeChat open platform account. If a developer possesses multiple mobile applications, website applications, and OAs (including Mini Programs), they can use a UnionID to differentiate the uniqueness of users. In other words, UnionID offers a mechanism for developers to acquire a user’s data from multiple platforms and attribute actions back to the specific user.\n\nHow to get OpenID and UnionID?\n• You’ll need OpenID and to obtain UnionID (OA, Mini Program, PC or WeChat browser)\n\nNote: To get access to a user’s UnionID, you first need to complete developer qualification verification and bind your accounts (OA, Mini Program and Applications) on WeChat open platform.\n\nThe value of OpenID\n\nWith an OpenID, you have access to the following user info:\n\nNote: Once a user has unsubscribed from your OA, you can’t pull their basic info anymore. To keep your user database up to date, you can set up automatic data synchronization with a certain frequency.\n\nHow can individuals and brands benefit from UnionID mechanism?\n\nFor individuals, the UnionID mechanism provides a seamless user experience across channels and devices, along with real-time communication and personalized offers:\n• Diversified membership benefits and rewards (users can redeem points across brands)\n• Enriched user experience (users can collect/transfer points from one platform to another)\n• Security (users get notified of any unusual activities associated with his UnionID through multiple channels).\n\nFor brands, unionID mechanism provides a closed-loop opportunity to understand, approach, convert and retain consumers.\n• A better way to acquire and manage user data\n• Accurate customer segmentation and targeted advertising (when a user authorizes WeChat login on a cosmetics app, WeChat can push beauty related ads accordingly)\n• Data security (users don’t need to log in with account and password)\n\nWeChat login for third-party apps is based on the OAuth 2.0 standard (OAuth 2.0 is the industry-standard protocol for authorization).\n\nAfter a user has given permission, the OA will receive a special API calling certificate (authorization ). Based on this access token, the OA may call APIs and obtain the user’s basic information.\n• Step 3: Based on the code, OA gets from server.\n\nSilent authorization means users will be automatically redirected to the configured business page without an authorization prompt. When the scope is set to snsapi_base, developers can obtain the user’s OpenID under silent authorization mode.\n\nWhen scope is set to ‘snsapi_userinfo’, the user must first confirm their authorization. After receiving permission, developer can obtain the user’s basic information.\n• Before implementing WeChat login in your app, you’ll need to register a developer account on the developer portal, have your app approved, and obtain the corresponding and . Login functionality will be available after your application has been approved.\n• When users have followed an OA and enter the authorization webpage of this OA via its chat window or custom menu, silent authorization will prevail over manual authorization even when the authorization scope is set to snsapi_userinfo.\n\nHow to grant the access to third party vendors in grace?\n\nIs it possible to outsource your MP to other vendors without granting your and ?\n\nAsk them to create a third-party platform on WeChat Open Platform. Here is how.\n\nNote: If an OA authorizes a third-party to manage its web-based authentication, the OA does not need to change any settings."
    },
    {
        "link": "https://casdoor.github.io/docs/integration/javascript/wechat_miniprogram",
        "document": "Since WeChat Mini Program does not support standardized OAuth, it cannot redirect to the self-hosted Casdoor webpage for login. Therefore, the process of using Casdoor for WeChat Mini Program is different from that of regular programs.\n\nThis document will explain how to integrate Casdoor into WeChat Mini Program. You can find an example for this integration on GitHub here: casdoor-wechat-miniprogram-example. For more detailed information, please refer to the WeChat Mini Program login document.\n\nFirstly, the Casdoor server should be deployed.\n\nAfter successfully deploying Casdoor, you need to ensure:\n• Casdoor can be accessed and used normally.\n• Create a WeChat IDP in Casdoor and provide the and given to you by the WeChat Mini Program development platform.\n• Create a new Casdoor application or use an existing one.\n• Add the IDP created in the previous step to the application you want to use.\n\nWeChat Mini Program provides an API to internally log in and obtain the code. The code should then be sent to Casdoor. Casdoor will use this code to retrieve information (such as OpenID and SessionKey) from the WeChat server.\n\nThe following code demonstrates how to accomplish the above process:\n\nIt is important to note that the parameter is mandatory to inform Casdoor that this is a request from the WeChat Mini Program.\n\nThe above code includes the username and avatar URI of the WeChat Mini Program user during login. You can choose to pass these two parameters separately and then pass them to Casdoor after a successful login and obtaining the access token:\n\nAdditionally, you can use the access token as a bearer token for any Casdoor operation you require."
    },
    {
        "link": "https://github.com/Authing/authing-wxapp-sdk",
        "document": "Authing Miniapp SDK( ) is suitable for use in wechat Miniapp environmen，baseed authing-js-sdk，adapted wechat Miniapp environment。You can use AuthenticationClient all methods，such as obtaining and modifying user data, adding user-defined fields, etc。For example: Obtain the user's mobile phone number through wechat authorization、 Log in with wechat authorization、Log in with the mobile number authorized by wechat, etc。\n\nTo use the authoring Miniapp SDK in Miniapp，you need to apply for a small program on theWeixin Official Accounts Platform，and at the same time Authing Console fill in the configuration of the Miniapp.\n\nStarting from the basic library version 2.2.1 or above and the developer tool 1.02.1808300 or above, the applet supports the installation of third-party packages using NPM. For details, please refer to: npm support.\n\nClick the menu bar in the developer tool：Tool --> building npm:\n\nThe complete parameter list is as follows:\n• : Initialize the SDK through the user's token (optional, you can cache the user's token in the front-end localstorage to realize the purpose of remembering login).\n• : Error handling function, you can use it to catch all exceptions requested by the authoring client globally. The function is defined as:\n• : Authing server。If you are using the public cloud version, please ignore the parameter. This parameter is required if you are using the version of privatized deployment. The format is as follows:: ，finally, without .\n\nAfter the user logs in, the SDK will write the user's into the storage of wechat, and subsequent requests will automatically carry the for access.\n\nSubsequently, the user opens the applet again. If the token of the user is saved in the storage of the applet, the request to access authing will automatically carry the token.\n• If the user logs in the applet for the first time, and the user has not logged in using the wechat application bound to the same subject as the applet, a new account will be created.\n• If the user logs in the applet for the first time, but the user has logged in using the wechat application of the same subject bound to the applet, the corresponding wechat account will be returned.\n• : Call wx.login() get the ，no user authorization is required. Required。\n• : is Weixin Button Component returned 。 and are required，The Authing server will attempt to encrypt user data from 'iv' and 'encrypteddata'. Manual authorization is required for the first time. Optional.\n• : is Weixin Button Component returned 。 and are required. The server will attempt to encrypt user data from 'iv' and 'encrypted data'. Manual authorization is required for the first time. Optional.\n• : is Weixin Button Component returned . Choose between 'iv' + 'encrypteddata'. If 'rawdata' is passed, the authing server will directly use the data as the user's profile. Manual authorization is required for the first time. Optional.\n\nThe nickname and avatar in the profile of the first registered user will be empty because the user's Avatar and nickname are not obtained.\n• Request user manual authorization for the first time\n• After that, you can use the auto get\n• If the mobile phone number is registered for the first time, it will bind the mobile phone number with the wechat account (it will be created if it does not exist).\n• If the mobile phone number has been registered before, the account corresponding to the mobile phone number will be returned, and the mobile phone number will be bound with the current wechat account.\n\nWe recommend that when the user uses the applet for the first time, use 'loginbycode' to obtain the authing account corresponding to the applet account. If the account has been bound with a mobile phone number before, there is no need to request the user to authorize the mobile phone number again. If the account is not bound with a mobile phone number, call the 'loginbyphone' method to request the user to authorize a mobile phone number.\n\nAfter the user logs in, will write the to the of the applet. You can call judge whether the user's token is valid, and log in again when the token is invalid.\n\nYou can use to handle errors:\n\nYou can also specify to catch all authing request exceptions, such as using and other wechat components display error prompts.\n• Commit your changes (git commit -am 'Add some feature')"
    },
    {
        "link": "https://developers.weixin.qq.com/miniprogram/dev/platform-capabilities/en/miniapp/api/diffapi/WeChatLogin.html",
        "document": ""
    },
    {
        "link": "https://market.strapi.io/plugins/strapi-wechat-miniprogram-auth",
        "document": "WeChat MiniProgram Auth helps you to easily create WeChat MiniProgram authentication available for your user.\n\nWeChat MiniProgram Auth helps you to easily create WeChat MiniProgram authentication available for your user. It uses the official USER LOGIN REQUEST to get the authorization, you can get it working in under 5 minutes in your WeChat MiniProgram application.\n\nHow to use\n\nAdd the folling lines of code in the file: config/plugins.js\n\nAfter done this, you can start the application with command:\n\nGo to the Strapi Dashboard, and change to the PLUGINS -> WeChat Mini Program Authenticator, input the AppID,AppSecret and save it.\n\nGo to the Strapi Dashboard, and change to the User Collection(PLUGINS -> Content-Type Builder -> COLLECTION TYPES -> User). Add two fields to this collection, and save. | NAME | TYPE | | ---- | ---- | | openid | Text | | wechatUserInfo | JSON |\n\nUse the getUserInfo button in your WeChat MiniProgram to get the current userinfo and use wx.login to get User login credentials\n\nInitialisation a request to STRAPI_BACKEND to get JWT token and Sanitized userinfo.\n\nThe STRAPI_BACKEND request response look like this:\n\nYou can using the JWT token in your application.\n\nAny bugs/issues you may face can be submitted as issues in the Github repo."
    }
]