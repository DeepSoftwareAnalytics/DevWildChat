[
    {
        "link": "https://phoenixnap.com/kb/lsof-command",
        "document": "(LiSt Open Files) is a Linux command that shows open files and processes accessing them. Every object in Linux (e.g., devices, directories) is treated as a file. This makes finding malicious or unwanted processes difficult, especially if a process holds a file open and prevents modification.\n\nThe command helps identify a process and allows users to manage or kill processes as needed.\n\nThis article will explain how to use the command in Linux through practical examples.\n\nWhat Is lsof Command Used For?\n\nThe command shows all open files and the processes using those files. Apart from showing which process is using which file, there are many practical uses for the command, such as:\n• Determining why a file is locked and cannot be edited.\n\nContinue reading to see the command's syntax, options, and hands-on examples that showcase these uses.\n\nWithout any options, the command lists all open files.\n\nThe command has many different options. The table below includes arguments that are used often:\n\nincorporates different arguments, allowing users to manage system and network administration activities.\n\nThe output consists of different columns. The default columns in the output are:\n• COMMAND. The command associated with the process that opened the file.\n• PID. The process identification number of the process running the file.\n• TID. The task identification number for the respective process. It is blank if a process has opened the file instead of a task.\n• TASKCMD. The command name from the first column. It can differ when a task changes its command name.\n• USER. The user executing the process. The column contains the User ID or username.\n• FD. The file descriptor the process uses to associate with the file.\n• TYPE. The file type and its identification number.\n• DEVICE. The device numbers related to the file.\n• SIZE/OFF. The value of the file taken during the runtime (size or offset).\n• NODE. The local file's node number or inode number of the directory/parent directory.\n• NAME. The path or link to the file.\n\nWhen run without any options, lists all files opened by any process:\n\nThe command outputs a lot of details. Pipe with the less command (or command) to show one page at a time:\n\nTo navigate to the bottom of the list, hit Enter or the down arrow key. Exit the list with q.\n\nSome kernel functions block the command. Run with the flag to avoid these functions:\n\nThe option runs and avoids these functions. As a result, the kernel function is ignored, and symbolic links are not resolved in the output.\n\nUse the command to show open files in a particular filesystem. For example, to see all open files in the /sys directory, run:\n\nThe command does not include open files in the filesystem's subdirectories.\n\nList all open files connected to terminal devices by targeting the /dev directory with using the following pattern:\n\nThe command lists all terminal devices that match the specified pattern.\n\nUse with the flag to display files opened by a specific user:\n\nTo print all opened files by everyone except a specific user, add the caret sign ( ) before the username:\n\nThe output shows files controlled by users other than root.\n\nThe flag opens all files used by a process whose name starts with the provided string:\n\nFor example, to list files opened by the process, run:\n\nThe option gives the same output as piping with the grep command:\n\nHowever, the command does not show the column names, and the string may be in a different column.\n\nUse the option to filter specific files by the Process ID number (PID). For example, the command below shows all files with PID 407:\n\nCombine with the flag to add the Parent Process Identification Number (PPID) to the output. To get PPID info for a specific PID, use:\n\nFor example, to get the PPID for the 407 PID, type:\n\nThe output shows the PPID column added to the header after the PID column.\n\nTo see all files that have been opened inside a specific directory, use the following command:\n\nThis option also shows files in the subdirectories recursively.\n\nUse the flag with to check which files are opened by a network connection:\n\nThe example above prints files open by a network connection, regardless of the connection type.\n\nThe flag adds a lot of versatility to , allowing users to filter files based on different networking criteria. For example:\n• Filter files based on their IP version with:\n• See files that use TCP or UDP connection by providing the protocol type:\n• Find processes running on a specific port number or name. Execute the command with the port number or service name from the name column:\n\nTo see PIDs for processes that have opened a particular file, use and provide the file name.\n\nThe command shows all PIDs of processes currently using the provided file.\n\nThe flag also kills all processes by a specific user. For example, to kill all processes run by the user:\n\nThe command finds and terminates all listed processes.\n\nThe command prints the file descriptor, which enables locating processes with memory-mapped files. To show these processes, run:\n\nThe file descriptor column shows only those with the mem type.\n\nA process sometimes keeps files locked even after they have been deleted, consuming disk space.\n\nUse to find locked and deleted files in Linux.\n\nFor example, to find deleted files starting in the root directory ( ), run:\n\nRestart the process or close the files to free up disk space.\n\nThe command allows multiple search items on the command line. Use AND and OR logical operators to combine different arguments. Below are some examples:\n• List files open by a particular user or process:\n• Display files that match both the first search term (user) and the second search term (process):\n• Find all network connections and filter the results for a specific user:\n\nThe command has many options compared to other Linux commands. To explore the command's possibilities, use the man command:\n\nThis guide showed how to use the command to troubleshoot potential security and system problems with practical examples.\n\nNext, learn how to copy files and directories in Linux and compare two files using the Linux diff command."
    },
    {
        "link": "https://man7.org/linux/man-pages/man8/lsof.8.html",
        "document": "Pages that refer to this page: fuser(1), lsfd(1), csysdig(8), sysdig(8)"
    },
    {
        "link": "https://redhat.com/en/blog/analyze-processes-lsof",
        "document": "One of the things I appreciate most about Linux is the chance to explore my operating system. Nothing is off limits in Linux. That's a huge opportunity—a very comfortable benefit—for anyone using Linux daily, whether you're a sysadmin, developer, network admin, or hobbyist eager to learn more.\n\nIt has real-world ramifications, too, because sometimes you really do need to probe into the inner workings of a system to understand a problem. Every sysadmin knows the feeling of getting a vague message like \"The server is slow\" or \"This application isn't responding.\" That lucky sysadmin gets to perform a \"treasure hunt\" to find the problem. However, Linux provides all the tools you need.\n\n[Cheat sheet: Old Linux commands and their modern replacements ]\n\nThe command, in combination with other tools like or , can be very helpful when diagnosing a potential bottleneck or similar issue.\n\nThe command is an acronym for \"list open files,\" but its potential isn't limited to just that role. It's commonly said that in Linux, everything is a file. In many ways, that's true, so a utility that lists open files is actually pretty useful. The utility is a robust interface for the information inside the virtual filesystem.\n\nFor example, suppose you need to know what process is using a particular directory:\n\nOr maybe you need the exact opposite. Perhaps you need to know what files a particular process has open. This example looks at :\n\nHere's an explanation of each column:\n• DEVICE: Device number or, in the case of a block device, character or other\n• SIZE/OFF: Dimension of the file or offset (the suffix is the offset)\n• NODE: Node description of the local file; this could be the number of the local file, TCP, UDP, or STR (stream)\n• NAME: The name of the mount point where the file resides\n\nYou can also discover what files a particular user has open:\n\nThis information is especially useful when you can't unmount an external device because a file on it is being actively accessed.\n\n[ Get the guide to installing applications on Linux. ]\n\nAs I've said, everything on Linux is a file, so isn't limited to the local filesystem. You can also use it for network debugging.\n\nFor example, suppose you need to know what process uses a particular TCP port (like 22, for example):\n\nYou can also obtain a report on all network processes associated with a particular interface:\n\n[ For more tips on Linux administration, read How to analyze a Linux process' memory map with pmap. ]\n\nDespite its seemingly humble purpose, the tool is a powerful tool on a system that can treat almost anything as a file. Read the man page to get more ideas of how this simple utility can help you perform some complex tasks."
    },
    {
        "link": "https://linux.die.net/man/8/lsof",
        "document": ""
    },
    {
        "link": "https://lsof.readthedocs.io",
        "document": "lsof is a command for . You can use lsof for example to:\n• Find files open to a process with known PID:\n\nlsof was originally developed and maintained by Vic Abell since 1994. The lsof-org team at GitHub takes over the maintainership of lsof. You can find the latest release at GitHub Release.\n\nNot maintained for lack of maintainers but pull requests are welcome:\n\nlsof is tested in ci on the following platforms:\n\nAdditionally, lsof is tested by maintainers manually on the following platforms:\n\nlsof is provided by package manager in the following repositories:"
    },
    {
        "link": "https://geeksforgeeks.org/proc-file-system-linux",
        "document": "Proc file system (procfs) is a virtual file system created on the fly when the system boots and is dissolved at the time of system shutdown. It contains useful information about the processes that are currently running, it is regarded as a control and information center for the kernel. The proc file system also provides a communication medium between kernel space and user space.\n\nTo List all the files and directories under the `/proc` directory.\n\nThis command will list all the files and directories under the `/proc` directory with detailed information like permissions, ownership, size, and time of modifications. This information is useful for understanding the current state of our system and diagnosing problems that are related to the running processes.\n\nIf we list the directories, you will find that for each PID of a process, there is a dedicated directory. You can check directories only on the terminal using.\n\nTo view the information of a specific process assigned a PID.\n\nFor a particular process of assigned PID, you can get the PID of any running process from the ps command.\n\nIf we want to check information about the process with PID 3151, we can use the following command.\n\nTo View The status of the process with PID 31154, we can use the following command.\n\nTo View The memory usage of the process with PID 1628, we can use the following command.\n\nAt this point of time there is no memory page allocated to the process at the time the command was executed.\n\nIn linux, /proc includes a directory for each running process, including kernel processes, in directories named /proc/PID, these are the directories present:\n\nSome other files in /proc file system are:\n\nFor example, the contents of /proc/crypto are.\n\nHow can we view System Uptime?\n\nHow can we view system memory information?\n\nHow can we view system processor information?\n\nIn this article we have talked about proc file system, in which we have learned that it is a way to access system information and configuration parameters in Linux. We have discussed that by using `ls` command with various options we can list all the files and directories under the `/proc` directories and view specific information about a particular process assigned with PID. We have discussed the use of `/proc`, as we can view system uptime, memory information and processor information. Overall, we can say that all this information provided by the proc file system can help diagnose problems related to running processes, monitor system performance, and tune system parameters to optimize the system resources."
    },
    {
        "link": "https://docs.kernel.org/filesystems/proc.html",
        "document": "This documentation is part of a soon (or so we hope) to be released book on the SuSE Linux distribution. As there is no complete documentation for the /proc file system and we’ve used many freely available sources to write these chapters, it seems only fair to give the work back to the Linux community. This work is based on the 2.2.* kernel version and the upcoming 2.4.*. I’m afraid it’s still far from complete, but we hope it will be useful. As far as we know, it is the first ‘all-in-one’ document about the /proc file system. It is focused on the Intel x86 hardware, so if you are looking for PPC, ARM, SPARC, AXP, etc., features, you probably won’t find what you are looking for. It also only covers IPv4 networking, not IPv6 nor other protocols - sorry. But additions and patches are welcome and will be added to this document if you mail them to Bodo. We’d like to thank Alan Cox, Rik van Riel, and Alexey Kuznetsov and a lot of other people for help compiling this documentation. We’d also like to extend a special thank you to Andi Kleen for documentation, which we relied on heavily to create this document, as well as the additional information he provided. Thanks to everybody else who contributed source or docs to the Linux kernel and helped create a great piece of software... :) If you have any comments, corrections or additions, please don’t hesitate to contact Bodo Bauer at bb@ricochet.net. We’ll be happy to add them to this document. The latest version of this document is available online at https://www.kernel.org/doc/html/latest/filesystems/proc.html If the above direction does not works for you, you could try the kernel mailing list at linux-kernel@vger.kernel.org and/or try to reach me at comandante@zaralinux.com. We don’t guarantee the correctness of this document, and if you come to us complaining about how you screwed up your system because of incorrect documentation, we won’t feel responsible...\n• None Investigating the properties of the pseudo file system /proc and its ability to provide information on the running Linux system\n• None Uncovering various information about the kernel and the processes running on the system The proc file system acts as an interface to internal data structures in the kernel. It can be used to obtain information about the system and to change certain kernel parameters at runtime (sysctl). First, we’ll take a look at the read-only parts of /proc. In Chapter 2, we show you how you can use /proc/sys to change settings. The directory /proc contains (among other things) one subdirectory for each process running on the system, which is named after the process ID (PID). The link ‘self’ points to the process reading the file system. Each process subdirectory has the entries listed in Table 1-1. Note that an open file descriptor to /proc/<pid> or to any of its contained files or subdirectories does not prevent <pid> being reused for some other process in the event that <pid> exits. Operations on open /proc/<pid> file descriptors corresponding to dead processes never act on any new process that the kernel may, through chance, have also assigned the process ID <pid>. Instead, operations on these FDs usually fail with ESRCH. Current and last cpu in which it was executed (2.4)(smp) Link to the executable of this process Directory, which contains all file descriptors Link to the root directory of this process Present with CONFIG_KALLSYMS=y: it shows the kernel function symbol the task is blocked in - or “0” if not blocked. An extension based on maps, showing the memory consumption of each mapping and flags associated with it Accumulated smaps stats for all mappings of the process. This can be derived from smaps, but is faster and more convenient An extension based on maps, showing the memory locality and binding policy as well as mem usage (in pages) of each mapping. For example, to get the status information of a process, all you have to do is read the file /proc/PID/status: This shows you nearly the same information you would get if you viewed it with the ps command. In fact, ps uses the proc file system to obtain its information. But you get a more detailed view of the process by reading the file /proc/PID/status. It fields are described in table 1-2. The statm file contains more detailed information about the process memory usage. Its seven fields are explained in Table 1-3. The stat file contains detailed information about the process itself. Its fields are explained in Table 1-4. For making accounting scalable, RSS related information are handled in an asynchronous manner and the value may not be very precise. To see a precise snapshot of a moment, you can see /proc/<pid>/smaps file and scan page table. It’s slow but very precise. Table 1-2: Contents of the status fields (as of 4.19) ¶ state (R is running, S is sleeping, D is sleeping in an uninterruptible wait, Z is zombie, T is traced or stopped) PID of process tracing this process (0 if not, or the tracer is outside of the current pid namespace) kernel thread flag, 1 is yes, 0 is no size of memory portions. It contains the three following parts (VmRSS = RssAnon + RssFile + RssShmem) size of resident shmem memory (includes SysV shm, mapping of tmpfs and shared anonymous mappings) amount of swap used by anonymous private data (shmem swap usage is not included) process’s memory is currently being dumped (killing the process may lead to a corrupted core) process is allowed to use THP (returns 0 when PR_SET_THP_DISABLE is set on the process bitmap of pending signals for the thread bitmap of shared pending signals for the process mask of CPUs on which this process may run Same as previous, but in “list format” mask of memory nodes allowed to this process Same as previous, but in “list format” Table 1-3: Contents of the statm fields (as of 2.6.8-rc3) ¶ number of pages that are shared number of pages that are ‘code’ Table 1-4: Contents of the stat fields (as of 2.6.30-rc7) ¶ state (R is running, S is sleeping, D is sleeping in an uninterruptible wait, Z is zombie, T is traced or stopped) current limit in bytes on the rss address above which program text can run address below which program text can run address of the start of the main process stack signal to send to parent thread on exit which CPU the task is scheduled on guest time of the task in jiffies guest time of the task children in jiffies address above which program data+bss is placed address below which program data+bss is placed address above which program heap can be expanded with brk() address above which program command line is placed address below which program command line is placed address above which program environment is placed address below which program environment is placed the thread’s exit_code in the form reported by the waitpid system call The /proc/PID/maps file contains the currently mapped memory regions and their access permissions. where “address” is the address space in the process that it occupies, “perms” is a set of permissions: “offset” is the offset into the mapping, “dev” is the device (major:minor), and “inode” is the inode on that device. 0 indicates that no inode is associated with the memory region, as the case would be with BSS (uninitialized data). The “pathname” shows the name associated file for this mapping. If the mapping is not associated with a file: the stack of the main process a private anonymous mapping that has been named by userspace an anonymous shared memory mapping that has been named by userspace or if empty, the mapping is anonymous. Starting with 6.11 kernel, /proc/PID/maps provides an alternative ioctl()-based API that gives ability to flexibly and efficiently query and filter individual VMAs. This interface is binary and is meant for more efficient and easy programmatic use. , defined in linux/fs.h UAPI header, serves as an input/output argument to the ioctl() command. See comments in linus/fs.h UAPI header for details on query semantics, supported flags, data returned, and general API usage information. The /proc/PID/smaps is an extension based on maps, showing the memory consumption for each of the process’s mappings. For each mapping (aka Virtual Memory Area, or VMA) there is a series of lines such as the following: The first of these lines shows the same information as is displayed for the mapping in /proc/PID/maps. Following lines show the size of the mapping (size); the size of each page allocated when backing a VMA (KernelPageSize), which is usually the same as the size in the page table entries; the page size used by the MMU when backing a VMA (in most cases, the same as KernelPageSize); the amount of the mapping that is currently resident in RAM (RSS); the process’s proportional share of this mapping (PSS); and the number of clean and dirty shared and private pages in the mapping. The “proportional set size” (PSS) of a process is the count of pages it has in memory, where each page is divided by the number of processes sharing it. So if a process has 1000 pages all to itself, and 1000 shared with one other process, its PSS will be 1500. “Pss_Dirty” is the portion of PSS which consists of dirty pages. (“Pss_Clean” is not included, but it can be calculated by subtracting “Pss_Dirty” from “Pss”.) Note that even a page which is part of a MAP_SHARED mapping, but has only a single pte mapped, i.e. is currently used by only one process, is accounted as private and not as shared. “Referenced” indicates the amount of memory currently marked as referenced or accessed. “Anonymous” shows the amount of memory that does not belong to any file. Even a mapping associated with a file may contain anonymous pages: when MAP_PRIVATE and a page is modified, the file page is replaced by a private anonymous copy. “KSM” reports how many of the pages are KSM pages. Note that KSM-placed zeropages are not included, only actual KSM pages. “LazyFree” shows the amount of memory which is marked by madvise(MADV_FREE). The memory isn’t freed immediately with madvise(). It’s freed in memory pressure if the memory is clean. Please note that the printed value might be lower than the real value due to optimizations used in the current implementation. If this is not desirable please file a bug report. “AnonHugePages” shows the amount of memory backed by transparent hugepage. “ShmemPmdMapped” shows the amount of shared (shmem/tmpfs) memory backed by huge pages. “Shared_Hugetlb” and “Private_Hugetlb” show the amounts of memory backed by hugetlbfs page which is not counted in “RSS” or “PSS” field for historical reasons. And these are not included in {Shared,Private}_{Clean,Dirty} field. “Swap” shows how much would-be-anonymous memory is also used, but out on swap. For shmem mappings, “Swap” includes also the size of the mapped (and not replaced by copy-on-write) part of the underlying shmem object out on swap. “SwapPss” shows proportional swap share of this mapping. Unlike “Swap”, this does not take into account swapped out page of underlying shmem objects. “Locked” indicates whether the mapping is locked in memory or not. “THPeligible” indicates whether the mapping is eligible for allocating naturally aligned THP pages of any currently enabled size. 1 if true, 0 otherwise. “VmFlags” field deserves a separate description. This member represents the kernel flags associated with the particular virtual memory area in two letter encoded manner. The codes are the following: do not expand area on remapping swap space is not reserved for the area do not include area into core dump Note that there is no guarantee that every flag and associated mnemonic will be present in all further kernel releases. Things get changed, the flags may be vanished or the reverse -- new added. Interpretation of their meaning might change in future as well. So each consumer of these flags has to follow each specific kernel version for the exact semantic. This file is only present if the CONFIG_MMU kernel configuration option is enabled. Note: reading /proc/PID/maps or /proc/PID/smaps is inherently racy (consistent output can be achieved only in the single read call). This typically manifests when doing partial reads of these files while the memory map is being modified. Despite the races, we do provide the following guarantees:\n• None The mapped addresses never go backwards, which implies no two regions will ever overlap.\n• None If there is something at a given vaddr during the entirety of the life of the smaps/maps walk, there will be some output for it. The /proc/PID/smaps_rollup file includes the same fields as /proc/PID/smaps, but their values are the sums of the corresponding values for all mappings of the process. Additionally, it contains these fields: They represent the proportional shares of anonymous, file, and shmem pages, as described for smaps above. These fields are omitted in smaps since each mapping identifies the type (anon, file, or shmem) of all pages it contains. Thus all information in smaps_rollup can be derived from smaps, but at a significantly higher cost. The /proc/PID/clear_refs is used to reset the PG_Referenced and ACCESSED/YOUNG bits on both physical and virtual pages associated with a process, and the soft-dirty bit on pte (see Soft-Dirty PTEs for details). To clear the bits for all the pages associated with the process: To clear the bits for the anonymous pages associated with the process: To clear the bits for the file mapped pages associated with the process: To reset the peak resident set size (“high water mark”) to the process’s current value: Any other value written to /proc/PID/clear_refs will have no effect. The /proc/pid/pagemap gives the PFN, which can be used to find the pageflags using /proc/kpageflags and number of times a page is mapped using /proc/kpagecount. For detailed explanation, see Examining Process Page Tables. The /proc/pid/numa_maps is an extension based on maps, showing the memory locality and binding policy, as well as the memory usage (in pages) of each mapping. The output follows a general format where mapping details get summarized separated by blank spaces, one mapping per each file line: “address” is the starting address for the mapping; “policy” reports the NUMA memory policy set for the mapping (see NUMA Memory Policy); “mapping details” summarizes mapping data such as mapping type, page usage counters, node locality page counters (N0 == node0, N1 == node1, ...) and the kernel page size, in KB, that is backing the mapping up. Similar to the process entries, the kernel data files give information about the running kernel. The files used to obtain this information are contained in /proc and are listed in Table 1-5. Not all of these will be present in your system. It depends on the kernel configuration and the loaded modules, which files are there, and which are missing. Kernel command line obtained from boot config, and, if there were kernel parameters from the boot loader, a “# Parameters from bootloader:” line followed by a line containing those parameters prefixed by “# “. (5.5) Kernel command line, both from bootloader and embedded in the kernel image Various drivers grouped here, currently rtc (2.4) Directory containing info about the IDE subsystem Kernel core image (can be ELF or A.OUT(deprecated in 2.4)) number of processes currently runnable (running or on ready queue); total number of processes in system; last pid created. All fields are separated by one space except “number of processes currently runnable” and “total number of processes in system”, which are separated by a slash (‘/’). Example: 0.61 0.61 0.55 3/828 22084 Table of partitions known to the system Deprecated info of PCI bus (new way -> /proc/bus/pci/, decoupled by lspci (2.4) Wall clock since boot, combined idle time of all cpus You can, for example, check which interrupts are currently in use and what they are used for by looking in the file /proc/interrupts: In 2.4.* a couple of lines where added to this file LOC & ERR (this time is the output of a SMP machine): NMI is incremented in this case because every timer interrupt generates a NMI (Non Maskable Interrupt) which is used by the NMI Watchdog to detect lockups. LOC is the local interrupt counter of the internal APIC of every CPU. ERR is incremented in the case of errors in the IO-APIC bus (the bus that connects the CPUs in a SMP system. This means that an error has been detected, the IO-APIC automatically retry the transmission, so it should not be a big problem, but you should read the SMP-FAQ. In 2.6.2* /proc/interrupts was expanded again. This time the goal was for /proc/interrupts to display every IRQ vector in use by the system, not just those considered ‘most important’. The new vectors are: interrupt raised when a machine check threshold counter (typically counting ECC corrected errors of memory or cache) exceeds a configurable threshold. Only available on some systems. a thermal event interrupt occurs when a temperature threshold has been exceeded for the CPU. This interrupt may also be generated when the temperature drops back to normal. a spurious interrupt is some interrupt that was raised then lowered by some IO device before it could be fully processed by the APIC. Hence the APIC sees the interrupt but does not know what device it came from. For this case the APIC will generate the interrupt with a IRQ vector of 0xff. This might also be generated by chipset bugs. rescheduling, call and TLB flush interrupts are sent from one CPU to another per the needs of the OS. Typically, their statistics are used by kernel developers and interested users to determine the occurrence of interrupts of the given type. The above IRQ vectors are displayed only when relevant. For example, the threshold vector does not exist on x86_64 platforms. Others are suppressed when the system is a uniprocessor. As of this writing, only i386 and x86_64 platforms support the new IRQ vector displays. Of some interest is the introduction of the /proc/irq directory to 2.4. It could be used to set IRQ to CPU affinity. This means that you can “hook” an IRQ to only one CPU, or to exclude a CPU of handling IRQs. The contents of the irq subdir is one subdir for each IRQ, and two files; default_smp_affinity and prof_cpu_mask. smp_affinity is a bitmask, in which you can specify which CPUs can handle the IRQ. You can set it by doing: This means that only the first CPU will handle the IRQ, but you can also echo 5 which means that only the first and third CPU can handle the IRQ. The contents of each smp_affinity file is the same by default: There is an alternate interface, smp_affinity_list which allows specifying a CPU range instead of a bitmask: The default_smp_affinity mask applies to all non-active IRQs, which are the IRQs which have not yet been allocated/activated, and hence which lack a /proc/irq/[0-9]* directory. The node file on an SMP system shows the node to which the device using the IRQ reports itself as being attached. This hardware locality information does not include information about any possible driver locality preference. prof_cpu_mask specifies which CPUs are to be profiled by the system wide profiler. Default value is ffffffff (all CPUs if there are only 32 of them). The way IRQs are routed is handled by the IO-APIC, and it’s Round Robin between all the CPUs which are allowed to handle it. As usual the kernel has more info than you and does a better job than you, so the defaults are the best choice for almost everyone. [Note this applies only to those IO-APIC’s that support “Round Robin” interrupt distribution.] There are three more important subdirectories in /proc: net, scsi, and sys. The general rule is that the contents, or even the existence of these directories, depend on your kernel configuration. If SCSI is not enabled, the directory scsi may not exist. The same is true with the net, which is there only when networking support is present in the running kernel. The slabinfo file gives information about memory usage at the slab level. Linux uses slab pools for memory management above page level in version 2.2. Commonly used objects have their own slab pool (such as network buffers, directory cache, and so on). External fragmentation is a problem under some workloads, and buddyinfo is a useful tool for helping diagnose these problems. Buddyinfo will give you a clue as to how big an area you can safely allocate, or why a previous allocation failed. Each column represents the number of pages of a certain order which are available. In this case, there are 0 chunks of 2^0*PAGE_SIZE available in ZONE_DMA, 4 chunks of 2^1*PAGE_SIZE in ZONE_DMA, 101 chunks of 2^4*PAGE_SIZE available in ZONE_NORMAL, etc... More information relevant to external fragmentation can be found in pagetypeinfo: > cat /proc/pagetypeinfo Page block order: 9 Pages per block: 512 Free pages count per migrate type at order 0 1 2 3 4 5 6 7 8 9 10 Node 0, zone DMA, type Unmovable 0 0 0 1 1 1 1 1 1 1 0 Node 0, zone DMA, type Reclaimable 0 0 0 0 0 0 0 0 0 0 0 Node 0, zone DMA, type Movable 1 1 2 1 2 1 1 0 1 0 2 Node 0, zone DMA, type Reserve 0 0 0 0 0 0 0 0 0 1 0 Node 0, zone DMA, type Isolate 0 0 0 0 0 0 0 0 0 0 0 Node 0, zone DMA32, type Unmovable 103 54 77 1 1 1 11 8 7 1 9 Node 0, zone DMA32, type Reclaimable 0 0 2 1 0 0 0 0 1 0 0 Node 0, zone DMA32, type Movable 169 152 113 91 77 54 39 13 6 1 452 Node 0, zone DMA32, type Reserve 1 2 2 2 2 0 1 1 1 1 0 Node 0, zone DMA32, type Isolate 0 0 0 0 0 0 0 0 0 0 0 Number of blocks type Unmovable Reclaimable Movable Reserve Isolate Node 0, zone DMA 2 0 5 1 0 Node 0, zone DMA32 41 6 967 2 0 Fragmentation avoidance in the kernel works by grouping pages of different migrate types into the same contiguous regions of memory called page blocks. A page block is typically the size of the default hugepage size, e.g. 2MB on X86-64. By keeping pages grouped based on their ability to move, the kernel can reclaim pages within a page block to satisfy a high-order allocation. The pagetypinfo begins with information on the size of a page block. It then gives the same type of information as buddyinfo except broken down by migrate-type and finishes with details on how many page blocks of each type exist. If min_free_kbytes has been tuned correctly (recommendations made by hugeadm from libhugetlbfs https://github.com/libhugetlbfs/libhugetlbfs/), one can make an estimate of the likely number of huge pages that can be allocated at a given point in time. All the “Movable” blocks should be allocatable unless memory has been mlock()’d. Some of the Reclaimable blocks should also be allocatable although a lot of filesystem metadata may have to be reclaimed to achieve this. Provides information about memory allocations at all locations in the code base. Each allocation in the code is identified by its source file, line number, module (if originates from a loadable module) and the function calling the allocation. The number of bytes allocated and number of calls at each location are reported. The first line indicates the version of the file, the second line is the header listing fields in the file. Provides information about distribution and utilization of memory. This varies by architecture and compile options. Some of the counters reported here overlap. The memory reported by the non overlapping counters may not add up to the overall memory usage and the difference for some workloads can be substantial. In many cases there are other means to find out additional memory using subsystem specific interfaces, for instance /proc/net/sockstat for TCP memory allocations. Example output. You may not have all of these fields. Total usable RAM (i.e. physical RAM minus a few reserved bits and the kernel binary code) Total free RAM. On highmem systems, the sum of LowFree+HighFree An estimate of how much memory is available for starting new applications, without swapping. Calculated from MemFree, SReclaimable, the size of the file LRU lists, and the low watermarks in each zone. The estimate takes into account that the system needs some page cache to function well, and that not all reclaimable slab will be reclaimable, due to items being in use. The impact of those factors will vary from system to system. Relatively temporary storage for raw disk blocks shouldn’t get tremendously large (20MB or so) In-memory cache for files read from the disk (the pagecache) as well as tmpfs & shmem. Doesn’t include SwapCached. Memory that once was swapped out, is swapped back in but still also is in the swapfile (if memory is needed it doesn’t need to be swapped out AGAIN because it is already in the swapfile. This saves I/O) Memory that has been used more recently and usually not reclaimed unless absolutely necessary. Memory which has been less recently used. It is more eligible to be reclaimed for other purposes Memory allocated for userspace which cannot be reclaimed, such as mlocked pages, ramfs backing pages, secret memfd pages etc. Highmem is all memory above ~860MB of physical memory. Highmem areas are for use by userspace programs, or for the pagecache. The kernel must use tricks to access this memory, making it slower to access than lowmem. Lowmem is memory which can be used for everything that highmem can be used for, but it is also available for the kernel’s use for its own data structures. Among many other things, it is where everything from the Slab is allocated. Bad things happen when you’re out of lowmem. Memory which has been evicted from RAM, and is temporarily on the disk Memory which is waiting to get written back to the disk Memory which is actively being written back to the disk files which have been mmapped, such as libraries Total memory used by shared memory (shmem) and tmpfs Kernel allocations that the kernel will attempt to reclaim under memory pressure. Includes SReclaimable (below), and other direct allocations with a shrinker. Part of Slab, that might be reclaimed, such as caches Part of Slab, that cannot be reclaimed on memory pressure Memory consumed by the kernel stacks of all tasks Memory consumed by secondary page tables, this currently includes KVM mmu and IOMMU allocations on x86 and arm64. Always zero. Previous counted pages which had been written to the server, but has not been committed to stable storage. Memory used by FUSE for temporary writeback buffers Based on the overcommit ratio (‘vm.overcommit_ratio’), this is the total amount of memory currently available to be allocated on the system. This limit is only adhered to if strict overcommit accounting is enabled (mode 2 in ‘vm.overcommit_memory’). The CommitLimit is calculated with the following formula: For example, on a system with 1G of physical RAM and 7G of swap with a of 30 it would yield a CommitLimit of 7.3G. For more details, see the memory overcommit documentation in mm/overcommit-accounting. The amount of memory presently allocated on the system. The committed memory is a sum of all of the memory which has been allocated by processes, even if it has not been “used” by them as of yet. A process which malloc()’s 1G of memory, but only touches 300M of it will show up as using 1G. This 1G is memory which has been “committed” to by the VM and can be used at any time by the allocating application. With strict overcommit enabled on the system (mode 2 in ‘vm.overcommit_memory’), allocations which would exceed the CommitLimit (detailed above) will not be permitted. This is useful if one needs to guarantee that processes will not fail due to lack of memory once that memory has been successfully allocated. amount of vmalloc area which is used largest contiguous block of vmalloc area which is free Memory allocated to the percpu allocator used to back percpu allocations. This stat excludes the cost of metadata. The amount of RAM/memory in kB, that was identified as corrupted by early memtest. If memtest was not run, this field will not be displayed at all. Size is never rounded down to 0 kB. That means if 0 kB is reported, you can safely assume there was at least one pass of memtest and none of the passes found a single faulty byte of RAM. The amount of RAM/memory in KB, the kernel identifies as corrupted. Memory used by shared memory (shmem) and tmpfs allocated with huge pages Memory used for filesystem data (page cache) allocated with huge pages Breakdown of page table sizes used in the kernel’s identity mapping of RAM Provides information about vmalloced/vmaped areas. One line per area, containing the virtual address range of the area, size in bytes, caller information of the creator, and optional information depending on the kind of area: if a physical address was specified (Only on NUMA kernels) Number of pages allocated on memory node <node> Provides counts of softirq handlers serviced since boot time, for each CPU. The subdirectory /proc/net follows the usual pattern. Table 1-8 shows the additional values you get for IP version 6 if you configure the kernel to support this. Table 1-9 lists the files and their meaning. the Layer2 multicast groups a device is listening too (interface index, label, number of references, number of bound addresses). You can use this information to see which network devices are available in your system and how much traffic was routed over those devices: In addition, each Channel Bond interface has its own directory. For example, the bond0 device will have a directory called /proc/net/bond0/. It will contain information that is specific to that bond, such as the current slaves of the bond, the link status of the slaves, and how many times the slaves link has failed. If you have a SCSI or ATA host adapter in your system, you’ll find a subdirectory named after the driver for this adapter in /proc/scsi. You’ll also see a list of all recognized SCSI devices in /proc/scsi: The directory named after the driver has one file for each adapter found in the system. These files contain information about the controller, including the used IRQ and the IO address range. The amount of information shown is dependent on the adapter you use. The example shows the output for an Adaptec AHA-2940 SCSI adapter: > cat /proc/scsi/aic7xxx/0 Adaptec AIC7xxx driver version: 5.1.19/3.2.4 Compile Options: TCQ Enabled By Default : Disabled AIC7XXX_PROC_STATS : Disabled AIC7XXX_RESET_DELAY : 5 Adapter Configuration: SCSI Adapter: Adaptec AHA-294X Ultra SCSI host adapter Ultra Wide Controller PCI MMAPed I/O Base: 0xeb001000 Adapter SEEPROM Config: SEEPROM found and used. Adaptec SCSI BIOS: Enabled IRQ: 10 SCBs: Active 0, Max Active 2, Allocated 15, HW 16, Page 255 Interrupts: 160328 BIOS Control Word: 0x18b6 Adapter Control Word: 0x005b Extended Translation: Enabled Disconnect Enable Flags: 0xffff Ultra Enable Flags: 0x0001 Tag Queue Enable Flags: 0x0000 Ordered Queue Tag Flags: 0x0000 Default Tag Queue Depth: 8 Tagged Queue By Device array for aic7xxx host instance 0: {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255} Actual queue depth per device for aic7xxx host instance 0: {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1} Statistics: (scsi0:0:0:0) Device using Wide/Sync transfers at 40.0 MByte/sec, offset 8 Transinfo settings: current(12/8/1/0), goal(12/8/1/0), user(12/15/1/0) Total transfers 160151 (74577 reads and 85574 writes) (scsi0:0:6:0) Device using Narrow/Sync transfers at 5.0 MByte/sec, offset 15 Transinfo settings: current(50/15/0/0), goal(50/15/0/0), user(50/15/0/0) Total transfers 0 (0 reads and 0 writes) The directory /proc/parport contains information about the parallel ports of your system. It has one subdirectory for each port, named after the port number (0,1,2,...). These directories contain the four files shown in Table 1-10. Any IEEE-1284 device ID information that has been acquired. list of the device drivers using that port. A + will appear by the name of the device currently using the port (it might not appear against any). IRQ that parport is using for that port. This is in a separate file to allow you to alter it by writing a new value in (IRQ number or none). Information about the available and actually used tty’s can be found in the directory /proc/tty. You’ll find entries for drivers and line disciplines in this directory, as shown in Table 1-11. list of drivers and their usage To see which tty’s are currently in use, you can simply look into the file /proc/tty/drivers: Various pieces of information about kernel activity are available in the /proc/stat file. All of the numbers reported in this file are aggregates since the system first booted. For a quick look, simply cat the file: The very first “cpu” line aggregates the numbers in all of the other “cpuN” lines. These numbers identify the amount of time the CPU has spent performing different kinds of work. Time units are in USER_HZ (typically hundredths of a second). The meanings of the columns are as follows, from left to right:\n• None iowait: In a word, iowait stands for waiting for I/O to complete. But there are several problems:\n• None CPU will not wait for I/O to complete, iowait is the time that a task is waiting for I/O to complete. When CPU goes into idle state for outstanding task I/O, another task will be scheduled on this CPU.\n• None In a multi-core CPU, the task waiting for I/O to complete is not running on any CPU, so the iowait of each CPU is difficult to calculate.\n• None The value of iowait field in /proc/stat will decrease in certain conditions. So, the iowait is not reliable by reading from /proc/stat. The “intr” line gives counts of interrupts serviced since boot time, for each of the possible system interrupts. The first column is the total of all interrupts serviced including unnumbered architecture specific interrupts; each subsequent column is the total for that particular numbered interrupt. Unnumbered interrupts are not shown, only summed into the total. The “ctxt” line gives the total number of context switches across all CPUs. The “btime” line gives the time at which the system booted, in seconds since the Unix epoch. The “processes” line gives the number of processes and threads created, which includes (but is not limited to) those created by calls to the fork() and clone() system calls. The “procs_running” line gives the total number of threads that are running or ready to run (i.e., the total number of runnable threads). The “procs_blocked” line gives the number of processes currently blocked, waiting for I/O to complete. The “softirq” line gives counts of softirqs serviced since boot time, for each of the possible system softirqs. The first column is the total of all softirqs serviced; each subsequent column is the total for that particular softirq. Information about mounted ext4 file systems can be found in /proc/fs/ext4. Each mounted filesystem will have a directory in /proc/fs/ext4 based on its device name (i.e., /proc/fs/ext4/hdc or /proc/fs/ext4/sda9 or /proc/fs/ext4/dm-0). The files in each per-device directory are shown in Table 1-12, below. To see which character device lines are currently used for the system console /dev/console, you may simply look into the file /proc/consoles:\n• None C = it is preferred console\n• None p = it is used for printk buffer\n• None b = it is not a TTY but a Braille device\n• None a = it is safe to use when cpu is offline major and minor number of the device separated by a colon The /proc file system serves information about the running system. It not only allows access to process data but also allows you to request the kernel status by reading files in the hierarchy. The directory structure of /proc reflects the types of information and makes it easy, if not obvious, where to look for specific data.\n\nThese files can be used to adjust the badness heuristic used to select which process gets killed in out of memory (oom) conditions. The badness heuristic assigns a value to each candidate task ranging from 0 (never kill) to 1000 (always kill) to determine which process is targeted. The units are roughly a proportion along that range of allowed memory the process may allocate from based on an estimation of its current memory and swap use. For example, if a task is using all allowed memory, its badness score will be 1000. If it is using half of its allowed memory, its score will be 500. The amount of “allowed” memory depends on the context in which the oom killer was called. If it is due to the memory assigned to the allocating task’s cpuset being exhausted, the allowed memory represents the set of mems assigned to that cpuset. If it is due to a mempolicy’s node(s) being exhausted, the allowed memory represents the set of mempolicy nodes. If it is due to a memory limit (or swap limit) being reached, the allowed memory is that configured limit. Finally, if it is due to the entire system being out of memory, the allowed memory represents all allocatable resources. The value of /proc/<pid>/oom_score_adj is added to the badness score before it is used to determine which task to kill. Acceptable values range from -1000 (OOM_SCORE_ADJ_MIN) to +1000 (OOM_SCORE_ADJ_MAX). This allows userspace to polarize the preference for oom killing either by always preferring a certain task or completely disabling it. The lowest possible value, -1000, is equivalent to disabling oom killing entirely for that task since it will always report a badness score of 0. Consequently, it is very simple for userspace to define the amount of memory to consider for each task. Setting a /proc/<pid>/oom_score_adj value of +500, for example, is roughly equivalent to allowing the remainder of tasks sharing the same system, cpuset, mempolicy, or memory controller resources to use at least 50% more memory. A value of -500, on the other hand, would be roughly equivalent to discounting 50% of the task’s allowed memory from being considered as scoring against the task. For backwards compatibility with previous kernels, /proc/<pid>/oom_adj may also be used to tune the badness score. Its acceptable values range from -16 (OOM_ADJUST_MIN) to +15 (OOM_ADJUST_MAX) and a special value of -17 (OOM_DISABLE) to disable oom killing entirely for that task. Its value is scaled linearly with /proc/<pid>/oom_score_adj. The value of /proc/<pid>/oom_score_adj may be reduced no lower than the last value set by a CAP_SYS_RESOURCE process. To reduce the value any lower requires CAP_SYS_RESOURCE. This file can be used to check the current score used by the oom-killer for any given <pid>. Use it together with /proc/<pid>/oom_score_adj to tune which process should be killed in an out-of-memory situation. Please note that the exported value includes oom_score_adj so it is effectively in range [0,2000]. This file contains IO statistics for each running process. I/O counter: chars read The number of bytes which this task has caused to be read from storage. This is simply the sum of bytes which this process passed to read() and pread(). It includes things like tty IO and it is unaffected by whether or not actual physical disk IO was required (the read might have been satisfied from pagecache). I/O counter: chars written The number of bytes which this task has caused, or shall cause to be written to disk. Similar caveats apply here as with rchar. I/O counter: read syscalls Attempt to count the number of read I/O operations, i.e. syscalls like read() and pread(). I/O counter: write syscalls Attempt to count the number of write I/O operations, i.e. syscalls like write() and pwrite(). I/O counter: bytes read Attempt to count the number of bytes which this process really did cause to be fetched from the storage layer. Done at the level, so it is accurate for block-backed filesystems. <please add status regarding NFS and CIFS at a later time> I/O counter: bytes written Attempt to count the number of bytes which this process caused to be sent to the storage layer. This is done at page-dirtying time. The big inaccuracy here is truncate. If a process writes 1MB to a file and then deletes the file, it will in fact perform no writeout. But it will have been accounted as having caused 1MB of write. In other words: The number of bytes which this process caused to not happen, by truncating pagecache. A task can cause “negative” IO too. If this task truncates some dirty pagecache, some IO which another task has been accounted for (in its write_bytes) will not be happening. We _could_ just subtract that from the truncating task’s write_bytes, but there is information loss in doing that. At its current implementation state, this is a bit racy on 32-bit machines: if process A reads process B’s /proc/pid/io while process B is updating one of those 64-bit counters, process A could see an intermediate result. More information about this can be found within the taskstats documentation in Documentation/accounting. When a process is dumped, all anonymous memory is written to a core file as long as the size of the core file isn’t limited. But sometimes we don’t want to dump some memory segments, for example, huge shared memory or DAX. Conversely, sometimes we want to save file-backed memory segments into a core file, not only the individual files. /proc/<pid>/coredump_filter allows you to customize which memory segments will be dumped when the <pid> process is dumped. coredump_filter is a bitmask of memory types. If a bit of the bitmask is set, memory segments of the corresponding memory type are dumped, otherwise they are not dumped. The following 9 memory types are supported: Note that MMIO pages such as frame buffer are never dumped and vDSO pages are always dumped regardless of the bitmask status. Note that bits 0-4 don’t affect hugetlb or DAX memory. hugetlb memory is only affected by bit 5-6, and DAX is only affected by bits 7-8. The default value of coredump_filter is 0x33; this means all anonymous memory segments, ELF header pages and hugetlb private memory are dumped. If you don’t want to dump all shared memory segments attached to pid 1234, write 0x31 to the process’s proc file: When a new process is created, the process inherits the bitmask status from its parent. It is useful to set up coredump_filter before the program runs. For example: This file contains lines of the form: 36 35 98:0 /mnt1 /mnt2 rw,noatime master:1 - ext3 /dev/root rw,errors=continue (1)(2)(3) (4) (5) (6) (n…m) (m+1)(m+2) (m+3) (m+4) (1) mount ID: unique identifier of the mount (may be reused after umount) (2) parent ID: ID of parent (or of self for the top of the mount tree) (3) major:minor: value of st_dev for files on filesystem (4) root: root of the mount within the filesystem (5) mount point: mount point relative to the process's root (6) mount options: per mount options (n…m) optional fields: zero or more fields of the form \"tag[:value]\" (m+1) separator: marks the end of the optional fields (m+2) filesystem type: name of filesystem of the form \"type[.subtype]\" (m+3) mount source: filesystem specific information or \"none\" (m+4) super options: per super block options Parsers should ignore all unrecognised optional fields. Currently the possible optional fields are: mount is slave and receives propagation from peer group X For more information on mount propagation see: These files provide a method to access a task’s comm value. It also allows for a task to set its own or one of its thread siblings comm value. The comm value is limited in size compared to the cmdline value, so writing anything longer then the kernel’s TASK_COMM_LEN (currently 16 chars, including the NUL terminator) will result in a truncated comm value. This file provides a fast way to retrieve first level children pids of a task pointed by <pid>/<tid> pair. The format is a space separated stream of pids. Note the “first level” here -- if a child has its own children they will not be listed here; one needs to read /proc/<children-pid>/task/<tid>/children to obtain the descendants. Since this interface is intended to be fast and cheap it doesn’t guarantee to provide precise results and some children might be skipped, especially if they’ve exited right after we printed their pids, so one needs to either stop or freeze processes being inspected if precise results are needed. This file provides information associated with an opened file. The regular files have at least four fields -- ‘pos’, ‘flags’, ‘mnt_id’ and ‘ino’. The ‘pos’ represents the current offset of the opened file in decimal form [see lseek(2) for details], ‘flags’ denotes the octal O_xxx mask the file has been created with [see open(2) for details] and ‘mnt_id’ represents mount ID of the file system containing the opened file [see 3.5 /proc/<pid>/mountinfo for details]. ‘ino’ represents the inode number of the file. All locks associated with a file descriptor are shown in its fdinfo too: The files such as eventfd, fsnotify, signalfd, epoll among the regular pos/flags pair provide additional information particular to the objects they represent. where ‘eventfd-count’ is hex value of a counter. where ‘sigmask’ is hex value of the signal mask associated with a file. where ‘tfd’ is a target file descriptor number in decimal form, ‘events’ is events mask being watched and the ‘data’ is data associated with a target [see epoll(7) for more details]. The ‘pos’ is current offset of the target file in decimal form [see lseek(2)], ‘ino’ and ‘sdev’ are inode and device numbers where target file resides, all in hex format. For inotify files the format is the following: where ‘wd’ is a watch descriptor in decimal form, i.e. a target file descriptor number, ‘ino’ and ‘sdev’ are inode and device where the target file resides and the ‘mask’ is the mask of events, all in hex form [see inotify(7) for more details]. If the kernel was built with exportfs support, the path to the target file is encoded as a file handle. The file handle is provided by three fields ‘fhandle-bytes’, ‘fhandle-type’ and ‘f_handle’, all in hex format. If the kernel is built without exportfs support the file handle won’t be printed out. If there is no inotify mark attached yet the ‘inotify’ line will be omitted. For fanotify files the format is: where fanotify ‘flags’ and ‘event-flags’ are values used in fanotify_init call, ‘mnt_id’ is the mount point identifier, ‘mflags’ is the value of flags associated with mark which are tracked separately from events mask. ‘ino’ and ‘sdev’ are target inode and device, ‘mask’ is the events mask and ‘ignored_mask’ is the mask of events which are to be ignored. All are in hex format. Incorporation of ‘mflags’, ‘mask’ and ‘ignored_mask’ provide information about flags and mask used in fanotify_mark call [see fsnotify manpage for details]. While the first three lines are mandatory and always printed, the rest is optional and may be omitted if no marks created yet. where ‘clockid’ is the clock type and ‘ticks’ is the number of the timer expirations that have occurred [see timerfd_create(2) for details]. ‘settime flags’ are flags in octal form been used to setup the timer [see timerfd_settime(2) for details]. ‘it_value’ is remaining time until the timer expiration. ‘it_interval’ is the interval for the timer. Note the timer might be set up with TIMER_ABSTIME option which will be shown in ‘settime flags’, but ‘it_value’ still exhibits timer’s remaining time. where ‘size’ is the size of the DMA buffer in bytes. ‘count’ is the file count of the DMA buffer file. ‘exp_name’ is the name of the DMA buffer exporter. This directory contains symbolic links which represent memory mapped files the process is maintaining. Example output: The name of a link represents the virtual memory bounds of a mapping, i.e. vm_area_struct::vm_start-vm_area_struct::vm_end. The main purpose of the map_files is to retrieve a set of memory mapped files in a fast way instead of parsing /proc/<pid>/maps or /proc/<pid>/smaps, both of which contain many more records. At the same time one can open(2) mappings from the listings of two processes and comparing their inode numbers to figure out which anonymous memory areas are actually shared. This file provides the value of the task’s timerslack value in nanoseconds. This value specifies an amount of time that normal timers may be deferred in order to coalesce timers and avoid unnecessary wakeups. This allows a task’s interactivity vs power consumption tradeoff to be adjusted. Writing 0 to the file will set the task’s timerslack to the default value. An application setting the value must have PTRACE_MODE_ATTACH_FSCREDS level permissions on the task specified to change its timerslack_ns value. When CONFIG_LIVEPATCH is enabled, this file displays the value of the patch state for the task. A value of ‘-1’ indicates that no patch is in transition. A value of ‘0’ indicates that a patch is in transition and the task is unpatched. If the patch is being enabled, then the task hasn’t been patched yet. If the patch is being disabled, then the task has already been unpatched. A value of ‘1’ indicates that a patch is in transition and the task is patched. If the patch is being enabled, then the task has already been patched. If the patch is being disabled, then the task hasn’t been unpatched yet. When CONFIG_PROC_PID_ARCH_STATUS is enabled, this file displays the architecture specific status of the task. If AVX512 is supported on the machine, this entry shows the milliseconds elapsed since the last time AVX512 usage was recorded. The recording happens on a best effort basis when a task is scheduled out. This means that the value depends on two factors:\n• None The time which the task spent on the CPU without being scheduled out. With CPU isolation and a single runnable task this can take several seconds.\n• None The time since the task was scheduled out last. Depending on the reason for being scheduled out (time slice exhausted, syscall ...) this can be arbitrary long time. As a consequence the value cannot be considered precise and authoritative information. The application which uses this information has to be aware of the overall scenario on the system in order to determine whether a task is a real AVX512 user or not. Precise information can be obtained with performance counters. A special value of ‘-1’ indicates that no AVX512 usage was recorded, thus the task is unlikely an AVX512 user, but depends on the workload and the scheduling scenario, it also could be a false negative mentioned above. This directory contains symbolic links which represent open files the process is maintaining. Example output: The number of open files for the process is stored in ‘size’ member of stat() output for /proc/<pid>/fd for fast access. ------------------------------------------------------- When CONFIG_KSM is enabled, each process has this file which displays the information of ksm merging status. The number of ksm_rmap_item structures in use. The structure ksm_rmap_item stores the reverse mapping information for virtual addresses. KSM will generate a ksm_rmap_item for each ksm-scanned page of the process. When /sys/kernel/mm/ksm/use_zero_pages is enabled, it represent how many empty pages are merged with kernel zero pages by KSM. It represents how many pages of this process are involved in KSM merging (not including ksm_zero_pages). It is the same with what /proc/<pid>/ksm_merging_pages shows. The profit that KSM brings (Saved bytes). KSM can save memory by merging identical pages, but also can consume additional memory, because it needs to generate a number of rmap_items to save each scanned page’s brief rmap information. Some of these pages may be merged, but some may not be abled to be merged after being checked several times, which are unprofitable memory consumed. It specifies whether the process’s ‘mm is added by prctl() into the candidate list of KSM or not, and if KSM scanning is fully enabled at process level. It specifies whether any VMAs of the process’’s mms are currently applicable to KSM. More information about KSM can be found in Kernel Samepage Merging."
    },
    {
        "link": "https://redhat.com/en/blog/important-proc-files",
        "document": "As you read in my first article, Exploring the /proc filesystem, the filesystem contains a lot of files that system administrators can use to discover the hardware makeup, the configuration parameters, and the complement of processes on a running system. Not all of the files have the same value to a sysadmin. In this article, I'm covering the text files (not directories/processes) with the highest value to sysadmins. That said, please realize that my definition of value means value to me and to my discovery on inherited systems and on systems with which I have little familiarity.\n\nThe following is a list of directory common text files on Red Hat-based systems:\n\nIf you issue a long listing command ( ), you'll notice that all files but the (not shown) file have a zero size. However, these files are not empty. They contain valuable information.\n\nThe files I find most valuable, especially for inherited system discovery, are:\n\nAnd the most valuable of those are and .\n\nAgain, I'm not stating that other files don't have value, but these are the ones I've found that have the most value to me. For example, the file gives you the system's uptime in seconds. For me, that's not particularly valuable. However, if I want that information, I use the command that also gives me a more readable version of as well.\n\nI think you get the idea.\n\nThis file shows the parameters passed to the kernel at the time it is started.\n\nThe value of this information is in how the kernel was booted because any switches or special parameters will be listed here, too. And like all information under , it can be found elsewhere and usually with better formatting, but files are very handy when you can't remember the command or don't want to for something.\n\nThe file is the first file I check when connecting to a new system. I want to know the CPU make-up of a system and this file tells me everything I need to know.\n\nThis is a virtual machine and only has one vCPU. If your system contains more than one CPU, the CPU numbering begins at 0 for the first CPU.\n\nThe file is the second file I check on a new system. It gives me a general and a specific look at a system's memory allocation and usage.\n\nI think most sysadmins either use the or the command to pull some of the data contained here. The file gives me a quick memory overview that I like and can redirect to another file as a snapshot.\n\nThe command provides more information than the related command does. Here are the two compared:\n\nUsually, the command is sufficient to give you kernel version info but for those of you who are developers or who are ultra-concerned with details, the file is there for you.\n\nThe filesystem has a ton of valuable information available to system administrators who want a convenient, non-command way of getting at raw system info. As I stated earlier, there are other ways to display the information in . Additionally, some of the info isn't what you'd want to use for system assessment. For example, use commands such as or to get a better picture of system performance rather than reading one of the available files.\n\n[ Need to learn more about Linux system administration? Take a Red Hat system administration course. ]"
    },
    {
        "link": "https://tecmint.com/exploring-proc-file-system-in-linux",
        "document": "Today, we will delve into the contents of the /proc directory to develop a better understanding of its functionalities. It’s important to note that the /proc directory is a common feature across all Linux distributions, irrespective of their flavor or architecture.\n\nOne misconception that we must immediately clarify is that the /proc directory is NOT a conventional file system in the traditional sense of the term.\n\nIt is a virtual file system that contains information about processes and other system-related data within the procfs. This file system is mapped to the /proc directory and is mounted during the system’s boot process.\n\n\n\nWhat is /proc in Linux\n\nThe /proc file system serves as an interface to kernel data structures and runtime information, which provides a way for both users and applications to access detailed information about processes, system configuration, hardware, and more, by exposing this data through a hierarchy of virtual files.\n\nTo view a complete list of files and directories in the /proc file system, you can use the ls command as shown.\n\nWhen you navigate to the /proc directory, you will notice that there are some familiar-sounding files, and then a whole bunch of numbered directories, each corresponding to a running process on the system.\n\nThese numbered directories represent the processes, better known as process IDs (PIDs), and within them, a command that occupies them. The files contain system information such as memory (meminfo), CPU information (cpuinfo), and available filesystems.\n\nHere are a few key files and directories you’ll encounter:\n• – List information about the CPU(s) on the system, such as the model, speed, and number of cores..\n• – List details about memory usage and statistics that contain the total amount of memory, free memory, and the memory used by each process.\n• – Contains a list of all the filesystems that are supported by the kernel.\n• – List configuration and runtime parameters for the kernel.\n• – Show system load average over different time intervals such as 1, 5, and 15 minutes.\n• – A symbolic link to the process’s own directory.\n• – Contains a variety of statistics about the system, such as the number of processes running, the number of interrupts, and the amount of time spent in each CPU state.\n• – Contains the amount of time the system has been running.\n• – Contains information about a specific process, where PID is the process ID.\n\nThe /proc/meminfo is used to show information about the memory usage and statistics of a Linux system, which contains a snapshot of various memory-related metrics, which can be useful for monitoring system performance and resource utilization.\n\nAs you can see, /proc/meminfo contains a bunch of information about your system’s memory, including the total amount available (in kb) and the amount free on the top two lines.\n\nRunning the cat command on any of the files in /proc will output their contents. Information about any files is available in the man page by running:\n\nI will give you a quick rundown on /proc’s files:\n• /proc/devices – Device drivers currently configured for the running kernel.\n• /proc/ioports – Registered port regions for input-output communication with the device.\n• /proc/meminfo – Info about system memory (see above example).\n• /proc/mounts – List of all mounts in use by the system.\n• /proc/partitions – Detailed info about partitions available to the system.\n• /proc/stat – Record or various statistics kept from the last reboot.\n\nWithin /proc’s numbered directories you will find a few files and links. Remember that these directories’ numbers correlate to the PID of the command being run within them.\n\nFor example, navigating to provides details such as:\n• – Command-line arguments used to start the process.\n• – Symbolic links to files opened by the process.\n\nLet’s use an example to view a folder called /proc/12.\n\nI get the following:\n\nSo, what does this mean? Well, the important part is at the top. We can see from the status file that this process belongs to rcu_tasks_rude_kthread. Its current state is idle, and its process ID is 12, obviously.\n\nWe also can see who is running this, as UID and GID are 0, indicating that this process belongs to the root user.\n\nIn any numbered directory, you will have a similar file structure, and the most important ones with their descriptions, are as follows:\n• limits – contains information about the limits of the process\n\nYou will also notice several links in the numbered directory:\n• cwd – a link to the current working directory of the process\n• exe – link to the executable of the process\n• root – link to the work directory of the process\n\nThis should get you started with familiarizing yourself with the /proc directory. It should also provide insight into how a number of commands obtain their info, such as uptime, lsof, mount, and ps, just to name a few."
    },
    {
        "link": "https://unix.stackexchange.com/questions/577386/how-to-query-information-from-the-proc-filesystem",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    }
]