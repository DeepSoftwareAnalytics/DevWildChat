[
    {
        "link": "https://mpv.io/manual/stable",
        "document": "Specify a prioritized list of audio languages to use, as IETF language tags. Equivalent ISO 639-1 two-letter and ISO 639-2 three-letter codes are treated the same. The first tag in the list that matches track's language in the file will be used. A track that matches more subtags will be preferred over one that matches fewer. See also . This is a string list option. See List Options for details.\n• chooses the Hungarian language track on a DVD and falls back on English if Hungarian is not available. This is a string list option. See List Options for details.\n• chooses the Hungarian subtitle track on a DVD and falls back on English if Hungarian is not available.\n• plays a Matroska file with Brazilian Portuguese subtitles if available, and otherwise any Portuguese subtitles. Equivalent to and , for video tracks. This is a string list option. See List Options for details. Select audio track. selects the default, disables audio. See also . mpv normally prints available audio tracks on the terminal when starting playback of a file. is an alias for . or disables audio playback. (The latter variant does not work with the client API.) The track selection options ( but also and the others) sometimes expose behavior that may appear strange. Also, the behavior tends to change around with each mpv release. The track selection properties will return the option value outside of playback (as expected), but during playback, the affective track selection is returned. For example, with , the property will suddenly return after playback initialization (assuming the file has at least 2 audio tracks, and the second is the default). At mpv 0.32.0 (and some releases before), if you passed a track value for which a corresponding track didn't exist (e.g. and there was only 1 audio track), the property returned . However if another audio track was added during playback, and you tried to set the property to , nothing happened, because the option still had the value , and writing the same value has no effect. With mpv 0.33.0, the behavior was changed. Now track selection options are reset to at playback initialization, if the option had tries to select a track that does not exist. The same is done if the track exists, but fails to initialize. The consequence is that unlike before mpv 0.33.0, the user's track selection parameters are clobbered in certain situations. Also since mpv 0.33.0, trying to select a track by number will strictly select this track. Before this change, trying to select a track which did not exist would fall back to track default selection at playback initialization. The new behavior is more consistent. Setting a track selection property at runtime, and then playing a new file might reset the track selection to defaults, if the fingerprint of the track list of the new file is different. Be aware of tricky combinations of all of all of the above: for example, would first play the correct track, and the second file without audio. If you then go back the first file, its first audio track will be played, and the second file is played with audio. If you do the same thing again but instead of using you run while the file is playing, then changing to the second file will play its audio track. This is because runtime selection enables the fingerprint heuristic. Most likely this is not the end. Display the subtitle stream specified by . selects the default, disables subtitles. is an alias for . or disables subtitle decoding. (The latter variant does not work with the client API.) is an alias for . or disables video playback. (The latter variant does not work with the client API.) If video is disabled, mpv will try to download the audio only if media is streamed with youtube-dl, because it saves bandwidth. This is done by setting the ytdl_format to \"bestaudio/best\" in the ytdl_hook.lua script. (Matroska files only) Specify the edition (set of chapters) to use, where 0 is the first. If set to (the default), mpv will choose the first edition declared as a default, or if there is no default, the first edition defined. Enable the default track auto-selection (default: yes). Enabling this will make the player select streams according to , , and others. If it is disabled, no tracks are selected. In addition, the player will not exit if no tracks are selected, and wait instead (this wait mode is similar to pausing, but the pause option is not set). This is useful with : you can start playback in this mode, and then set select tracks at runtime by setting the filter graph. Note that if is set before playback is started, the referenced tracks are always selected. When autoselecting a subtitle track, select it even if the selected audio stream matches you preferred subtitle language (default: yes). If this option is set to , then no subtitle track that matches the audio language will ever be autoselected by mpv regardless of or . If set to , then only forced subtitles will be selected. When autoselecting a subtitle track, select the track that matches the language of your OS if the audio stream is in a different language if suitable (default track or a forced track under the right conditions). Note that if is set, this will be completely ignored (default: yes). When autoselecting a subtitle track, if no tracks match your preferred languages, select a full track even if it doesn't match your preferred subtitle language (default: default). Setting this to means that only streams flagged as will be selected. When autoselecting a subtitle track, the default value of will prefer using a forced subtitle track if the subtitle language matches the audio language and matches your list of preferred languages. The special value will only select forced subtitle tracks and never fallback on a non-forced track. Conversely, will never select a forced subtitle track. The general format for times is . If the time is prefixed with , the time is considered relative from the end of the file (as signaled by the demuxer/the file). A is usually ignored (but see below). The following alternative time specifications are recognized: seeks to chapter number c. (Chapters start from 1.) resets any previously set option (useful for libmpv). If is given, then prefixing times with makes the time relative to the start of the file. A timestamp without prefix is considered an absolute time, i.e. should seek to a frame with a timestamp as the file contains it. As a bug, but also a hidden feature, putting 1 or more spaces before the or always interprets the time as absolute, which can be used to seek to negative timestamps (useful for debugging at most). Seeks to the middle of the file. Seeks to 3 minutes and 20 seconds before the end of the file, plays 10 seconds, and exits. Stop at given time. Use if the time should be relative to . See for valid option values and examples. Stop after a given time relative to the start time. See for valid option values and examples. If both and are provided, playback will stop when it reaches either of the two endpoints. Obscurity note: this does not work correctly if , and the specified time is not an \"absolute\" time, as defined in the option description. Whether to move the file start time to (default: yes). This is less awkward for files which start at a random timestamp, such as transport streams. On the other hand, if there are timestamp resets, the resulting behavior can be rather weird. For this reason, and in case you are actually interested in the real timestamps, this behavior can be disabled with . Slow down or speed up playback by the factor given as parameter. If (on by default) is used, playing with a speed higher than normal automatically inserts the audio filter. Raise or lower the audio's pitch by the factor given as parameter. Does not affect playback speed. Playing with an altered pitch automatically inserts the audio filter. Since pitch change is achieved by combining pitch-preserving speed change and resampling, the range of pitch change is effectively limited by the and parameters of : for example, a of 0.25 limits the highest pitch factor to 4 (1/0.25). In a standard 12-tone scale system, octaves are separated by a factor of 2 whereas semitones are represented by a factor of 2^(1/12). This means pitches can easily be shifted up or down with a simple multiplier. Shifts the pitch down an octave. Shifts the pitch up a perfect fifth. Shifts the pitch down a perfect fifth. Set which file on the internal playlist to start playback with. The index is an integer, with 0 meaning the first file. The value means that the selection of the entry to play is left to the playback resume mechanism (default). If an entry with the given index doesn't exist, the behavior is unspecified and might change in future mpv versions. The same applies if the playlist contains further playlists (don't expect any reasonable behavior). Passing a playlist file to mpv should work with this option, though. E.g. will work as expected, as long as does not link to further playlists. The value is a deprecated alias for . Play files according to a playlist file. Supports some common formats. If no format is detected, it will be treated as list of files, separated by newline characters. You may need this option to load plaintext files as a playlist. Note that XML playlist formats are not supported. This option forces to interpret the playlist file. Some playlist formats, notably CUE and optical disc formats, need to use different demuxers and will not work with this option. They still can be played directly, without using this option. You can play playlists directly, without this option. Before mpv version 0.31.0, this option disabled any security mechanisms that might be in place, but since 0.31.0 it uses the same security mechanisms as playing a playlist file directly. If you trust the playlist file, you can disable any security checks with . Because playlists can load other playlist entries, consider applying this option only to the playlist itself and not its entries, using something along these lines: The way older versions of mpv played playlist files via was not safe against maliciously constructed files. Such files may trigger harmful actions. This has been the case for all versions of mpv prior to 0.31.0, and all MPlayer versions, but unfortunately this fact was not well documented earlier, and some people have even misguidedly recommended the use of with untrusted sources. Do NOT use with random internet sources or files you do not trust if you are not sure your mpv is at least 0.31.0. In particular, playlists can contain entries using protocols other than local files, such as special protocols like (which are inherently unsafe). Threshold for merging almost consecutive ordered chapter parts in milliseconds (default: 100). Some Matroska files with ordered chapters have inaccurate chapter end timestamps, causing a small gap between the end of one chapter and the start of the next one when they should match. If the end of one playback part is less than the given threshold away from the start of the next one then keep playing video normally over the chapter change instead of doing a seek. Distance in seconds from the beginning of a chapter within which a backward chapter seek will go to the previous chapter (default: 5.0). Past this threshold, a backward chapter seek will go to the beginning of the current chapter instead. A negative value means always go back to the previous chapter. Select when to use precise seeks that are not limited to keyframes. Such seeks require decoding video from the previous keyframe up to the target position and so can take some time depending on decoding performance. For some video formats, precise seeks are disabled. This option selects the default choice to use for seeks; it is possible to explicitly override that default in the definition of key bindings and in input commands. Use precise seeks if the seek is to an absolute position in the file, such as a chapter seek, but not for relative seeks like the default behavior of arrow keys. Like , but enable hr-seeks in audio-only cases. The exact behavior is implementation specific and may change with new releases (default). Use precise seeks whenever possible. Same as (for compatibility). This option exists to work around failures to do precise seeks (as in ) caused by bugs or limitations in the demuxers for some file formats. Some demuxers fail to seek to a keyframe before the given target position, going to a later position instead. The value of this option is subtracted from the time stamp given to the demuxer. Thus, if you set this option to 1.5 and try to do a precise seek to 60 seconds, the demuxer is told to seek to time 58.5, which hopefully reduces the chance that it erroneously goes to some time later than 60 seconds. The downside of setting this option is that precise seeks become slower, as video between the earlier demuxer position and the real target may be unnecessarily decoded. Allow the video decoder to drop frames during seek, if these frames are before the seek target. If this is enabled, precise seeking can be faster, but if you're using video filters which modify timestamps or add new frames, it can lead to precise seeking skipping the target frame. This e.g. can break frame backstepping when deinterlacing is enabled. Controls how to seek in files. Note that if the index is missing from a file, it will be built on the fly by default, so you don't need to change this. But it might help with some broken files. use an index if the file has one, or build it if missing don't read or use the file's index This option only works if the underlying media supports seeking (i.e. not with stdin, pipe, etc). Load URLs from playlists which are considered unsafe (default: no). This includes special protocols and anything that doesn't refer to normal files. Local files and HTTP links on the other hand are always considered safe. In addition, if a playlist is loaded while this is set, the added playlist entries are not marked as originating from network or potentially unsafe location. (Instead, the behavior is as if the playlist entries were provided directly to mpv command line or command.) Follow any references in the file being opened (default: yes). Disabling this is helpful if the file is automatically scanned (e.g. thumbnail generation). If the thumbnail scanner for example encounters a playlist file, which contains network URLs, and the scanner should not open these, enabling this option will prevent it. This option also disables ordered chapters, mov reference files, opening of archives, and a number of other features. On older FFmpeg versions, this will not work in some cases. Some FFmpeg demuxers might not respect this option. This option does not prevent opening of paired subtitle files and such. Use to prevent this. This option does not always work if you open non-files (for example using would open a whole bunch of files in the given directory). Prefixing the filename with if it doesn't start with a will avoid this. Loops playback times. A value of plays it one time (default), two times, etc. means forever. is the same as and disables looping. If several files are specified on command line, the entire playlist is looped. is the same as . The mode is like , but does not skip playlist entries which have been marked as failing. This means the player might waste CPU time trying to loop a file that doesn't exist. But it might be useful for playing webradios under very bad network conditions. Loop a single file N times. means forever, means normal playback. For compatibility, and are also accepted, and are the same as . The difference to is that this doesn't loop the playlist, just the file itself. If the playlist contains only a single file, the difference between the two option is that this option performs a seek on loop, instead of reloading the file. counts the number of times it causes the player to seek to the beginning of the file, not the number of full playthroughs. This means will end up playing the file twice. Contrast with , which counts the number of full playthroughs. is an alias for this option. Set loop points. If playback passes the timestamp, it will seek to the timestamp. Seeking past the point doesn't loop (this is intentional). If is after , the behavior is as if the points were given in the right order, and the player will seek to after crossing through . This is different from old behavior, where looping was disabled (and as a bug, looped back to on the end of the file). If either options are set to (or unset), looping is disabled. This is different from old behavior, where an unset implied the start of the file, and an unset the end of the file. The loop-points can be adjusted at runtime with the corresponding properties. See also command. Run A-B loops only N times, then ignore the A-B loop points (default: inf). means that looping goes on forever. If this option is set to 0, A-B looping is ignored, and even the command will not enable looping again (the command will show on the OSD message if both loop points are set, but is 0). Enable support for Matroska ordered chapters. mpv will load and search for video segments from other files, and will also respect any chapter order specified for the main file (default: yes). Loads the given file as playlist, and tries to use the files contained in it as reference files when opening a Matroska file that uses ordered chapters. This overrides the normal mechanism for loading referenced files by scanning the same directory the main file is located in. Useful for loading ordered chapter files that are not located on the local filesystem, or if the referenced files are in different directories. Note: a playlist can be as simple as a text file containing filenames separated by newlines. Load chapters from this file, instead of using the chapter metadata found in the main file. This accepts a media file (like mkv) or even a pseudo-format like ffmetadata and uses its chapters to replace the current file's chapters. This doesn't work with OGM or XML chapters directly. Without , skipping will snap to keyframes. Stop playback if either audio or video fails to initialize (default: no). With , playback will continue in video-only or audio-only mode if one of them fails. This doesn't affect playback of audio-only or video-only files. Control the playback direction (default: forward). Setting will attempt to play the file in reverse direction, with decreasing playback time. If this is set on playback starts, playback will start from the end of the file. If this is changed at during playback, a hr-seek will be issued to change the direction. and are aliases for and . The rest of this option description pertains to the mode. Backward playback is extremely fragile. It may not always work, is much slower than forward playback, and breaks certain other features. How well it works depends mainly on the file being played. Generally, it will show good results (or results at all) only if the stars align. mpv, as well as most media formats, were designed for forward playback only. Backward playback is bolted on top of mpv, and tries to make a medium effort to make backward playback work. Depending on your use-case, another tool may work much better. Backward playback is not exactly a 1st class feature. Implementation tradeoffs were made, that are bad for backward playback, but in turn do not cause disadvantages for normal playback. Various possible optimizations are not implemented in order to keep the complexity down. Normally, a media player is highly pipelined (future data is prepared in separate threads, so it is available in realtime when the next stage needs it), but backward playback will essentially stall the pipeline at various random points. For example, for intra-only codecs are trivially backward playable, and tools built around them may make efficient use of them (consider video editors or camera viewers). mpv won't be efficient in this case, because it uses its generic backward playback algorithm, that on top of it is not very optimized. If you just want to quickly go backward through the video and just show \"keyframes\", just use forward playback, and hold down the left cursor key (which on CLI with default config sends many small relative seek commands). The implementation consists of mostly 3 parts:\n• Backward demuxing. This relies on the demuxer cache, so the demuxer cache should (or must, didn't test it) be enabled, and its size will affect performance. If the cache is too small or too large, quadratic runtime behavior may result.\n• Backward decoding. The decoder library used (libavcodec) does not support this. It is emulated by feeding bits of data in forward, putting the result in a queue, returning the queue data to the VO in reverse, and then starting over at an earlier position. This can require buffering an extreme amount of decoded data, and also completely breaks pipelining.\n• Backward output. This is relatively simple, because the decoder returns the frames in the needed order. However, this may cause various problems because filters see audio and video going backward.\n• It's fragile. If anything doesn't work, random non-useful behavior may occur. In simple cases, the player will just play nonsense and artifacts. In other cases, it may get stuck or heat the CPU. (Exceeding memory usage significantly beyond the user-set limits would be a bug, though.)\n• Performance and resource usage isn't good. In part this is inherent to backward playback of normal media formats, and in parts due to implementation choices and tradeoffs.\n• This is extremely reliant on good demuxer behavior. Although backward demuxing requires no special demuxer support, it is required that the demuxer performs seeks reliably, fulfills some specific requirements about packet metadata, and has deterministic behavior.\n• Starting playback exactly from the end may or may not work, depending on seeking behavior and file duration detection.\n• Some container formats, audio, and video codecs are not supported due to their behavior. There is no list, and the player usually does not detect them. Certain live streams (including TV captures) may exhibit problems in particular, as well as some lossy audio codecs. h264 intra-refresh is known not to work due to problems with libavcodec. WAV and some other raw audio formats tend to have problems - there are hacks for dealing with them, which may or may not work.\n• Backward demuxing of subtitles is not supported. Subtitle display still works for some external text subtitle formats. (These are fully read into memory, and only backward display is needed.) Text subtitles that are cached in the subtitle renderer also have a chance to be displayed correctly.\n• Some features dealing with playback of broken or hard to deal with files will not work fully (such as timestamp correction).\n• If demuxer low level seeks (i.e. seeking the actual demuxer instead of just within the demuxer cache) are performed by backward playback, the created seek ranges may not join, because not enough overlap is achieved.\n• Trying to use this with hardware video decoding will probably exhaust all your GPU memory and then crash a thing or two. Or it will fail because will certainly be set too low.\n• Stream recording is broken. may keep working if you backward play within a cached region only.\n• Relative seeks may behave weird. Small seeks backward (towards smaller time, i.e. ) may not really seek properly, and audio will remain muted for a while. Using hr-seek is recommended, which should have none of these problems.\n• Some things are just weird. For example, while seek commands manipulate playback time in the expected way (provided they work correctly), the framestep commands are transposed. Backstepping will perform very expensive work to step forward by 1 frame.\n• Remove all / filters you have set. Disable hardware decoding. Disable functions like SPDIF passthrough.\n• Increasing might help if reversal queue overflow is reported, which may happen in high bitrate video, or video with large GOP. Hardware decoding mostly ignores this, and you need to increase instead (until you get playback without logged errors).\n• The demuxer cache is essential for backward demuxing. Make sure to set . The cache size might matter. If it's too small, a queue overflow will be logged, and backward playback cannot continue, or it performs too many low level seeks. If it's too large, implementation tradeoffs may cause general performance issues. Use to potentially increase the amount of packets the demuxer layer can queue for reverse demuxing (basically it's the equivalent for the demuxer layer).\n• Setting can help a lot to make playback smooth (once it works).\n• also factors into how many seeks may be performed, and whether backward demuxing could break due to queue overflow. If it's set too high, the backstep operation needs to search through more packets all the time, even if the cache is large enough.\n• Setting may be useful to cache the entire file into the demuxer cache. Set to a large size to make sure it can read the entire cache; should also be set to a large size to prevent that tries to trim the cache.\n• If audio artifacts are audible, even though the AO does not underrun, increasing might help in some cases. For backward decoding. Backward decoding decodes forward in steps, and then reverses the decoder output. These options control the approximate maximum amount of bytes that can be buffered. The main use of this is to avoid unbounded resource usage; during normal backward playback, it's not supposed to hit the limit, and if it does, it will drop frames and complain about it. Use this option if you get reversal queue overflow errors during backward playback. Increase the size until the warning disappears. Usually, the video buffer will overflow first, especially if it's high resolution video. This does not work correctly if video hardware decoding is used. The video frame size will not include the referenced GPU and driver memory. Some hardware decoders may also be limited by . How large the queue size needs to be depends entirely on the way the media was encoded. Audio typically requires a very small buffer, while video can require excessively large buffers. This does not affect demuxer cache behavior at all. See for defaults and value range. options accept suffixes such as and . Number of overlapping keyframe ranges to use for backward decoding (default: auto) (\"keyframe\" to be understood as in the mpv/ffmpeg specific meaning). Backward decoding works by forward decoding in small steps. Some codecs cannot restart decoding from any packet (even if it's marked as seek point), which becomes noticeable with backward decoding (in theory this is a problem with seeking too, but can fix it for seeking). In particular, MDCT based audio codecs are affected. The solution is to feed a previous packet to the decoder each time, and then discard the output. This option controls how many packets to feed. The choice is currently hardcoded to 0 for video, and uses 1 for lossy audio, 0 for lossless audio. For some specific lossy audio codecs, this is set to 2. can potentially handle intra-refresh video, depending on the exact conditions. You may have to use the option as well. Number of keyframe ranges to decode at once when backward decoding (default: 1 for video, 10 for audio). Another pointless tuning parameter nobody should use. This should affect performance only. In theory, setting a number higher than 1 for audio will reduce overhead due to less frequent backstep operations and less redundant decoding work due to fewer decoded overlap frames (see ). On the other hand, it requires a larger reversal buffer, and could make playback less smooth due to breaking pipelining (e.g. by decoding a lot, and then doing nothing for a while). It probably never makes sense to set . But in theory, it could help with intra-only video codecs by reducing backstep operations. Number of seconds the demuxer should seek back to get new packets during backward playback (default: 60). This is useful for tuning backward playback, see for details. Setting this to a very low value or 0 may make the player think seeking is broken, or may make it perform multiple seeks. Setting this to a high value may lead to quadratic runtime behavior. You can also pass a string to this option, which will list all top-level options which contain the string in the name, e.g. for all options that contain the word . The special string lists all top-level options. Increment verbosity level, one level for each found on the command line. Do not load default configuration or any user files. This prevents loading of both the user-level and system-wide and files. Other user files are blocked as well, such as resume playback files and cache files. This option only takes effect when used as a command line flag. Files explicitly requested by command line options, like or , will still be loaded. Print a list of the available properties. Opens the given path for writing, and print log messages to it. Existing files will be truncated. The log level is at least , but can be raised via (the option cannot lower it below the forced minimum log level). A special case is the macOS bundle, it will create a log file at by default. Force a different configuration directory. If this is set, the given directory is used to load configuration files, and all other configuration directories are ignored. This means the global mpv configuration directory as well as per-user directories are ignored, and overrides through environment variables ( ) are also ignored. Note that the cache and state paths ( , ) are not considered \"configuration\" and keep their auto-detection logic. Note that the option takes precedence over this option. Write certain statistics to the given file. The file is truncated on opening. The file will contain raw samples, each with a timestamp. To make this file into a readable, the script can be used (which currently displays it as a graph). This option is useful for debugging only. Makes mpv wait idly instead of quitting when there is no file to play. Mostly useful in input mode, where mpv can be controlled through input commands. (Default: ) will only idle at start and let the player close once the first playlist has finished playing back. Specify configuration file to be parsed after the default ones. If set to , don't auto-load scripts from the configuration subdirectory (usually ). (Default: ) Load a Lua script. The second option allows you to load multiple scripts by separating them with the path separator ( on Unix, on Windows). is a path list option. See List Options for details. Set options for scripts. A script can query an option by key. If an option is used and what semantics the option value has depends entirely on the loaded scripts. Values not claimed by any scripts are ignored. This is a key/value list option. See List Options for details. Pretend that all files passed to mpv are concatenated into a single, big file. This uses timeline/EDL support internally. Use the given profile(s), displays a list of the defined profiles. Normally, mpv will try to keep all settings when playing the next file on the playlist, even if they were changed by the user during playback. (This behavior is the opposite of MPlayer's, which tries to reset all settings when starting next file.) Default: Do not reset anything. This can be changed with this option. It accepts a list of options, and mpv will reset the value of these options on playback start to the initial value. The initial value is either the default value, or as set by the config file or command line. The special name resets as many options as possible. This is a string list option. See List Options for details.\n• Reset pause mode when switching to the next file.\n• Reset fullscreen and playback speed settings if they were changed during playback.\n• Try to reset all settings that were changed during playback. Show the description and content of a profile. Lists all profiles if no parameter is provided. Look for a file-specific configuration file in the same directory as the file that is being played. See File-specific Configuration Files. May be dangerous if playing from untrusted media. Enable the youtube-dl hook-script. It will look at the input URL, and will play the video located on the website. This works with many streaming sites, not just the one that the script is named after. This requires a recent version of youtube-dl to be installed on the system (default: yes). If the script can't do anything with an URL, it will do nothing. This accepts a set of options, which can be passed to it with the option (using as prefix): If 'yes' will try parsing the URL with youtube-dl first, instead of the default where it's only after mpv failed to open it. This mostly depends on whether most of your URLs need youtube-dl parsing. A -separated list of URL patterns which mpv should not use with youtube-dl. The patterns are matched after the part of the URL. matches the beginning of the URL, matches its end, and you should use before any of the characters to match that character.\n• will exclude any URL that starts with or .\n• will exclude any URL that ends with or . See more lua patterns here: https://www.lua.org/manual/5.1/manual.html#5.4.1 If 'yes' will attempt to add all formats found reported by youtube-dl (default: no). Each format is added as a separate track. In addition, they are delay-loaded, and actually opened only when a track is selected (this should keep load times as low as without this option). It adds average bitrate metadata, if available, which means you can use to decide which track to select. (HLS used to be the only format whose alternative quality streams were exposed in a similar way, thus the option name.) Tracks which represent formats that were selected by youtube-dl as default will have the default flag set. This means mpv should generally still select formats chosen with by default. Although this mechanism makes it possible to switch streams at runtime, it's not suitable for this purpose for various technical reasons. (It's slow, which can't be really fixed.) In general, this option is not useful, and was only added to show that it's possible. There are two cases that must be considered when doing quality/bandwidth selection:\n• None Completely separate audio and video streams (DASH-like). Each of these streams contain either only audio or video, so you can mix and combine audio/video bandwidths without restriction. This intuitively matches best with the concept of selecting quality by track (what is supposed to do).\n• None Separate sets of muxed audio and video streams. Each version of the media contains both an audio and video stream, and they are interleaved. In order not to waste bandwidth, you should only select one of these versions (if, for example, you select an audio stream, then video will be downloaded, even if you selected video from a different stream). mpv will still represent them as separate tracks, but will set the title of each track to , where is replaced with the youtube-dl format ID of the originating stream. Some sites will mix 1. and 2., but we assume that they do so for compatibility reasons, and there is no reason to use them at all. If set to 'yes', and is also set to 'yes', this will try to represent all youtube-dl reported formats as tracks, even if mpv would normally use the direct URL reported by it (default: yes). It appears this normally makes a difference if youtube-dl works on a master HLS playlist. If this is set to 'no', this specific kind of stream is treated like is set to 'no', and the stream selection as done by youtube-dl (via ) is used. Thumbnails get downloaded when they are added as tracks, so 'all' can have a noticable impact on how long it takes to open the video when there are a lot of thumbnails. Make mpv use the master manifest URL for formats like HLS and DASH, if available, allowing for video/audio selection in runtime (default: no). It's disabled (\"no\") by default for performance reasons. Configure paths to youtube-dl's executable or a compatible fork's. The paths should be separated by : on Unix and ; on Windows. mpv looks in order for the configured paths in PATH and in mpv's config directory. The defaults are \"yt-dlp\", \"yt-dlp_x86\" and \"youtube-dl\". On Windows the suffix extension is not necessary, but only \".exe\" is acceptable. Why do the option names mix and ? Video format/quality that is directly passed to youtube-dl. The possible values are specific to the website and the video, for a given url the available formats can be found with the command . See youtube-dl's documentation for available aliases. (Default: ) The value does not pass a option to youtube-dl at all, and thus does not override its default. Note that sometimes youtube-dl returns a format that mpv cannot use, and in these cases the mpv default may work better. Pass arbitrary options to youtube-dl. Parameter and argument should be passed as a key-value pair. Options without argument must include . There is no sanity checking so it's possible to break things (i.e. passing invalid parameters to youtube-dl). A proxy URL can be passed for youtube-dl to use it in parsing the website. This is useful for geo-restricted URLs. After youtube-dl parsing, some URLs also require a proxy for playback, so this can pass that proxy information to mpv. Take note that SOCKS proxies aren't supported and https URLs also bypass the proxy. This is a limitation in FFmpeg. This is a key/value list option. See List Options for details. Enable memory reporting for javascript scripts in the stats overlay. This is disabled by default because it has an overhead and increases memory usage. This option will only work if it is enabled before mpv is started. Enable the builtin script that shows useful playback information on a key binding (default: yes). By default, the key is used ( to make the overlay permanent). Enable the built-in script that shows a console on a key binding and lets you enter commands (default: yes). The key is used to show the console by default, and to hide it again. Enable the builtin script that does auto profiles (default: auto). See Conditional auto profiles for details. will load the script, but immediately unload it if there are no conditional profiles. Enable the builtin script that lets you select from lists of items (default: yes). By default, its keybindings start with the key. For enabling \"pseudo GUI mode\", which means that the defaults for some options are changed. This option should not normally be used directly, but only by mpv internally, or mpv-provided scripts, config files, or .desktop files. See PSEUDO GUI MODE for details. Always save the current playback position on quit. When this file is played again later, the player will seek to the old playback position on start. This does not happen if playback of a file is stopped in any other way than quitting. For example, going to the next file in the playlist will not save the position, and start playback at beginning the next time the file is played. This behavior is disabled by default, but is always available when quitting the player with Shift+Q. The directory in which to store the \"watch later\" temporary files. is an alias for . If this option is unset, the files will be stored in a subdirectory named \"watch_later\" underneath the local state directory (usually ). Restore playback position from the configuration subdirectory, usually (default: yes). Only restore the playback position from the configuration subdirectory (usually ) if the file's modification time is the same as at the time of saving. This may prevent skipping forward in files with the same name which have different content. (Default: ) The options that are saved in \"watch later\" files if they have been changed since when mpv started. These values will be restored the next time the files are played. Note that the playback position is saved via the option. When removing options, existing watch later data won't be modified and will still be applied fully, but new watch later data won't contain these options. See for the list of the properties that are restored by default. This is a string list option. See List Options for details.\n• The subtitle track selection will not be restored.\n• The volume and mute state won't be saved to watch later files.\n• No option will be saved to watch later files, except the playback position. Prepend the watch later config files with the name of the file they refer to. This is simply written as comment on the top of the file. This option may expose privacy-sensitive information and is thus disabled by default. Ignore path (i.e. use filename only) when using watch later feature. (Default: disabled) Specify the video output backend to be used. See VIDEO OUTPUT DRIVERS for details and descriptions of available drivers. Specify a priority list of video decoders to be used, according to their family and name. See for further details. Both of these options use the same syntax and semantics; the only difference is that they operate on different codec lists. See for a full list of available decoders. Specify a list of video filters to apply to the video stream. See VIDEO FILTERS for details and descriptions of the available filters. The option variants , , and exist to modify a previously specified list, but you should not need these for typical use. Do not sleep when outputting video frames. Useful for benchmarks when used with . Skip displaying some frames to maintain A/V sync on slow systems, or playing high framerate video on video outputs that have an upper framerate limit. The argument selects the drop methods, and can be one of the following: Disable any frame dropping. Not recommended, for testing only. Drop late frames on video output (default). This still decodes and filters all frames, but doesn't render them on the VO. Drops are indicated in the terminal status line as field. In audio sync. mode, this drops frames that are outdated at the time of display. If the decoder is too slow, in theory all frames would have to be dropped (because all frames are too late) - to avoid this, frame dropping stops if the effective framerate is below 10 FPS. In display-sync. modes (see ), this affects only how A/V drops or repeats frames. If this mode is disabled, A/V desync will in theory not affect video scheduling anymore (much like the mode). However, even if disabled, frames will still be skipped (i.e. dropped) according to the ratio between video and display frequencies. This is the recommended mode, and the default. Old, decoder-based framedrop mode. (This is the same as in mpv 0.5.x and before.) This tells the decoder to skip frames (unless they are needed to decode future frames). May help with slow systems, but can produce unwatchable choppy output, or even freeze the display completely. This uses a heuristic which may not make sense, and in general cannot achieve good results, because the decoder's frame dropping cannot be controlled in a predictable manner. Not recommended. Even if you want to use this, prefer for better results. The option controls what frames to drop. Enable both modes. Not recommended. Better than just mode. has its own code for the framedrop mode. Slight differences to other VOs are possible. Enable some things which tend to reduce video latency by 1 or 2 frames (default: no). Note that this option might be removed without notice once the player's timing code does not inherently need to do these things anymore. Using this option is known to break other options such as interpolation, so it is not recommended to enable this.\n• Use the demuxer reported FPS for frame dropping. This avoids the player needing to decode 1 frame in advance, lowering total latency in effect. This also means that if the demuxer reported FPS is wrong, or the video filter chain changes FPS (e.g. deinterlacing), then it could drop too many or not enough frames.\n• Disable waiting for the first video frame. Normally the player waits for the first video frame to be fully rendered before starting playback properly. Some VOs will lazily initialize stuff when rendering the first frame, so if this is not done, there is some likeliness that the VO has to drop some frames if rendering the first frame takes longer than needed. Set the display FPS used with the modes. By default, a detected value is used. Keep in mind that setting an incorrect value (even if slightly incorrect) can ruin video playback. On multi-monitor systems, there is a chance that the detected value is from the wrong monitor. Set this option only if you have reason to believe the automatically determined value is wrong. Specify the hardware video decoding API that should be used if possible. Whether hardware decoding is actually done depends on the video codec. If hardware decoding is not possible, mpv will fall back on software decoding. Hardware decoding is not enabled by default, to keep the out-of-the-box configuration as reliable as possible. However, when using modern hardware, hardware video decoding should work correctly, offering reduced CPU usage, and possibly lower power consumption. On older systems, it may be necessary to use hardware decoding due to insufficient CPU resources; and even on modern systems, sufficiently complex content (eg: 4K60 AV1) may require it. Use the shortcut to toggle hardware decoding at runtime. It toggles this option between and . If you decide you want to use hardware decoding by default, the general recommendation is to try out decoding with the command line option, and prove to yourself that it works as desired for the content you care about. After that, you can add it to your config file. When testing, you should start by using as it will limit itself to choosing from hwdecs that are actively supported by the development team. If that doesn't result in working hardware decoding, you can try to have it attempt to load every possible hwdec, but if didn't work, you will probably need to know exactly which hwdec matches your hardware and read up on that entry below. If or produced the desired results, we recommend just sticking with that and only setting a specific hwdec in your config file if it is really necessary. If you use the Ubuntu package, keep in mind that their contains , which is less than ideal as it may not be the right choice for your system, and it may end up using an inefficient wrapper library under the covers. We recommend removing this line or deleting the file altogether. Even if enabled, hardware decoding is still only white-listed for some codecs. See to enable hardware decoding in more cases.\n• If you only want to enable hardware decoding at runtime, don't set the parameter, or put into your (relevant on distros which force-enable it by default, such as on Ubuntu). Use the default binding to enable it at runtime.\n• If you're not sure, but want hardware decoding always enabled by default, put into your , and acknowledge that this may cause problems.\n• If you want to test available hardware decoding methods, pass and look at the terminal output.\n• If you're a developer, or want to perform elaborate tests, you may need any of the other possible option values. This option accepts a comma delimited list of types, along with certain special values: enable any whitelisted hw decoder (see below) forcibly enable any hw decoder found (see below) exactly the same as enable best hw decoder with copy-back (see below) Special values can be mixed with api names. eg: will try and use the hwdec, and if that fails, will run through the normal logic. requires with or (Windows 8+ only) requires (macOS 10.8 and up), or (iOS 9.0 and up) copies video back into system RAM (macOS 10.8 or iOS 9.0 and up) copies video back into system RAM (Linux with some GPUs or Windows) requires (Any platform CUDA is available) copies video back to system RAM (Any platform CUDA is available) copies video back to system RAM (Any platform with Vulkan Video Decoding) Other hwdecs (only use if you know you have to): requires with , or (Windows only) requires with , or (Linux only) copies video back into system RAM (Linux with some GPUs only) requires (Any platform CUDA is available) copies video back to system RAM (Any platform CUDA is available) copies video back to system RAM (Any platform supported by hardware) tries to automatically enable hardware decoding using the first available method. This still depends what VO you are using. See the list above, for which and is required for a given hwdec. It will go down the list of available hwdecs until one is successfully initialised. If all of them fail, it will fallback to software decoding. is similar to , but allows only whitelisted methods that are considered \"safe\". This is supposed to be a reasonable way to enable hardware decdoding by default in a config file (even though you shouldn't do that anyway; prefer runtime enabling with ). Unlike , this will not try to enable unknown or known-to-be-bad methods. In addition, this may disable hardware decoding in other situations when it's known to cause problems, but currently this mechanism is quite primitive. (As an example for something that still causes problems: certain combinations of HEVC and Intel chips on Windows tend to cause mpv to crash, most likely due to driver bugs.) selects the union of methods selected with and . selects only modes that copy the video data back to system memory after decoding. This selects modes like (and so on). If none of these work, hardware decoding is disabled. This mode is usually guaranteed to incur no additional quality loss compared to software decoding (assuming modern codecs and an error free video stream), and will allow CPU processing with video filters. This mode works with all video filters and VOs. Because these copy the decoded video back to system RAM, they're often less efficient than the direct modes, and may not help too much over software decoding if you are short on CPU resources. Most non-copy methods only work with the OpenGL GPU backend. Currently, only the , , and methods work with Vulkan. The mode, if used with , requires Mesa 11, and most likely works with Intel and AMD GPUs only. It also requires the opengl EGL backend. and are the newest, and recommended method to do hardware decoding on Nvidia GPUs. and are an older implementation of hardware decoding on Nvidia GPUs that uses Nvidia's bitstream parsers rather than FFmpeg's. This can lead to feature deficiencies, such as incorrect playback of HDR content, and / should always be preferred unless you specifically need Nvidia's deinterlacing algorithms. To use this deinterlacing you must pass the option: . Pass (or leave the option unset) to not attempt any deinterlacing. In theory, hardware decoding does not reduce video quality (at least for the codecs h264 and HEVC). However, due to restrictions in video output APIs, as well as bugs in the actual hardware decoders, there can be some loss, or even blatantly incorrect results. This has largely ceased to be a problem with modern hardware, but there is a lot of hardware out there, so caveat emptor. Known problems are discussed below, but the list cannot be considered exhaustive, as even hwdecs that work well on certain hardware generations may be problematic on other ones. In some cases, RGB conversion is forced, which means the RGB conversion is performed by the hardware decoding API, instead of the shaders used by . This means certain colorspaces may not display correctly, and certain filtering (such as debanding) cannot be applied in an ideal way. This will also usually force the use of low quality chroma scalers instead of the one specified by . In other cases, hardware decoding can also reduce the bit depth of the decoded image, which can introduce banding or precision loss for 10-bit files. always does RGB conversion in hardware, which does not support newer colorspaces like BT.2020 correctly. However, doesn't support 10 bit or HDR encodings, so these limitations are unlikely to be relevant. is not safe. It appears to always use BT.601 for forced RGB conversion, but actual behavior depends on the GPU drivers. Some drivers appear to convert to limited range RGB, which gives a faded appearance. In addition to driver-specific behavior, global system settings might affect this additionally. This can give incorrect results even with completely ordinary video sources. is not safe. It forces RGB conversion (not with ) and how well it handles non-standard colorspaces is not known. In the rare cases where 10-bit is supported the bit depth of the output will be reduced to 8. should usually be safe, but depending on how a file/stream has been mixed, it has been reported to corrupt the timestamps causing glitched, flashing frames. It can also sometimes cause massive framedrops for unknown reasons. Caution is advised, and should always be preferred. is not safe. It always converts to 4:2:2 YUV, which may be lossy, depending on how chroma sub-sampling is done during conversion. It also discards the top left pixel of each frame for some reason. If you run into any weird decoding issues, frame glitches or discoloration, and you have turned on, the first thing you should try is disabling it. This option is for troubleshooting hwdec interop issues. Since it's a debugging option, its semantics may change at any time. This is useful for the and VOs for selecting which hwdec interop context to use exactly. Effectively it also can be used to block loading of certain backends. If set to (default), the behavior depends on the VO: for , it does nothing, and the interop context is loaded on demand (when the decoder probes for support). For , which has has no on-demand loading, this is equivalent to . The empty string is equivalent to . If set to , it attempts to load all interop contexts at GL context creation time. Other than that, a specific backend can be set, and the list of them can be queried with (mpv CLI only). Runtime changes to this are ignored (the current option value is used whenever the renderer is created). Number of GPU frames hardware decoding should preallocate (default: see output). If this is too low, frame allocation may fail during decoding, and video frames might get dropped and/or corrupted. Setting it too high simply wastes GPU memory and has no advantages. This value is used only for hardware decoding APIs which require preallocating surfaces (known examples include and ). For other APIs, frames are allocated as needed. The details depend on the libavcodec implementations of the hardware decoders. The required number of surfaces depends on dynamic runtime situations. The default is a fixed value that is thought to be sufficient for most uses. But in certain situations, it may not be enough. Set the internal pixel format used by hardware decoding via (default ). The special value selects an implementation specific standard format. Most decoder implementations support only one format, and will fail to initialize if the format is not supported. Some implementations might support multiple formats. In particular, videotoolbox is known to require for good performance on some older hardware. d3d11va can always use , which uses an opaque format, with likely no advantages. Choose the GPU device used for decoding when using the or hwdecs with the OpenGL GPU backend, and with the or hwdecs in all cases. For the OpenGL GPU backend, the default device used for decoding is the one being used to provide output (and in the vast majority of cases, only one GPU will be present). For the hwdecs, the default device will be the first device enumerated by the CUDA libraries - however that is done. For the Vulkan GPU backend, decoding must always happen on the display device, and this option has no effect. Choose the DRM device for . This should be the path to a DRM device file. (Default: ) On Windows this takes adapter name as an input. Will pick the default adapter if unset. Alternatives are listed when the name \"help\" is given. Enables pan-and-scan functionality (cropping the sides of e.g. a 16:9 video to make it fit a 4:3 display without black bands). The range controls how much of the image is cropped. May not work with all video output drivers. This option has no effect if option is used. Override video aspect ratio, in case aspect information is incorrect or missing in the file being played. use the video stream or container aspect (default) But note that handling of these special values might change in the future. This sets the default video aspect determination method (if the aspect is _not_ overridden by the user with or others). Strictly prefer the container aspect ratio. This is apparently the default behavior with VLC, at least with Matroska. Note that if the container has no aspect ratio set, the behavior is the same as with bitstream. Strictly prefer the bitstream aspect ratio, unless the bitstream aspect ratio is not set. This is apparently the default behavior with XBMC/kodi, at least with Matroska. The current default for mpv is . Normally you should not set this. Try the various choices if you encounter video that has the wrong aspect ratio in mpv, but seems to be correct in other players. Disable scaling of the video. If the window is larger than the video, black bars are added. Otherwise, the video is cropped, unless the option is set to , in which case the video is fit to window. The video still can be influenced by the other options. This option disables the effect of . Note that the scaler algorithm may still be used, even if the video isn't scaled. For example, this can influence chroma conversion. The video will also still be scaled in one dimension if the source uses non-square pixels (e.g. anamorphic widescreen DVDs). This option is disabled if is used. Moves the displayed video rectangle by the given value in the X or Y direction. The unit is in fractions of the size of the scaled video (the full size, even if parts of the video are not visible due to panscan or other options). For example, displaying a video fullscreen on a 1920x1080 screen with would move the video 192 pixels to the left and would move the video 108 pixels up. This option is disabled if is used. Rotate the video clockwise, in degrees. If is given, the video is never rotated, even if the file has rotation metadata. (The rotation value is added to the rotation metadata, which means the value would rotate the video according to the rotation metadata.) When using hardware decoding without copy-back, only 90° steps work, while software decoding and hardware decoding methods that copy the video back to system memory support all values between 0 and 359. Crop the video by starting at the x, y offset for w, h pixels. The crop is applied to the source video rectangle (before anamorphic stretch) by the VO. A crop rectangle that is not within the video rectangle will be ignored. This works with hwdec, unlike the equivalent 'lavfi-crop'. When offset is omitted, the central area will be cropped. Setting the crop to empty one overrides container crop and disables cropping. Setting the crop to disables manual cropping and restores the container crop if it's specified. Adjust the video display scale factor by the given value. The parameter is given log 2. For example, is unscaled, is twice the size, is one fourth of the size, and so on. This option is disabled if is used. Multiply the video display size with the given value (default: 1.0). If a non-default value is used, this will be different from the window size, so video will be either cut off, or black bars are added. This value is multiplied with the value derived from and the normal video aspect ratio. This option is disabled if is used. Moves the video rectangle within the black borders, which are usually added to pad the video to screen if video and screen aspect ratios are different. would move the video to the top of the screen (leaving a border only on the bottom), a value of centers it (default), and a value of would put the video at the bottom of the screen. If video and screen aspect match perfectly, these options do nothing. This option is disabled if is used. Set extra video margins on each border (default: 0). Each value is a ratio of the window size, using a range 0.0-1.0. For example, setting the option at a window size of 1000 pixels will add a 200 pixels border on the right side of the window. The video is \"boxed\" by these margins. The window size is not changed. In particular it does not enlarge the window, and the margins will cause the video to be downscaled by default. This may or may not change in the future. The margins are applied after 90° video rotation, but before any other video transformations. This option is disabled if is used. Subtitles still may use the margins, depending on and similar options. These options were created for the OSC. Some odd decisions, such as making the margin values a ratio (instead of pixels), were made for the sake of the OSC. It's possible that these options may be replaced by ones that are more generally useful. The behavior of these options may change to fit OSC requirements better, too. switches mpv to a mode where video timing is determined using a fixed framerate value (either using the option, or using file information). Sometimes, files with very broken timestamps can be played somewhat well in this mode. Note that video filters, subtitle rendering, seeking (including hr-seeks and backstepping), and audio synchronization can be completely broken in this mode. Override video framerate. Useful if the original value is wrong or missing. Enable or disable deinterlacing (default: no). Interlaced video shows ugly comb-like artifacts, which are visible on fast movement. Enabling this typically inserts the bwdif video filter in order to deinterlace the video, or lets the video output apply deinterlacing if supported. When using , mpv will insert a deinterlacing filter if ffmpeg detects that the video frame is interlaced. Be aware that there can be false positives in certain cases, such as when files are encoded as interlaced despite the video not actually being so. This is why is not the default value. Keep in mind that using this filter will conflict with any manually inserted deinterlacing filters, and that this will make video look worse if it's not actually interlaced. Specify the field parity/order when deinterlacing (default: auto). Each frame of an interlaced video is divided into two fields, which are then separately transmitted. Top field represents even lines while bottom field represents odd lines. When deinterlacing the deinterlacer needs to know the correct temporal order of the fields else the video will appear jittery. will automatically try to detect the field order of the video, forces top field first while forces bottom field first. Play/convert only first video frames, then quit. loads the file, but immediately quits before initializing playback. (Might be useful for scripts which just want to determine some file properties.) For audio-only playback, any value greater than 0 will quit playback immediately after initialization. The value 0 works as with video. RGB color levels used with YUV to RGB conversion. Normally, output devices such as PC monitors use full range color levels. However, some TVs and video monitors expect studio RGB levels. Providing full range output to a device expecting studio level input results in crushed blacks and whites, the reverse in dim gray blacks and dim whites. Not all VOs support this option. Some will silently ignore it. It is advisable to use your graphics driver's color range option instead, if available. Allow hardware decoding for a given list of codecs only. The special value always allows all codecs. You can get the list of allowed codecs with . Remove the prefix, e.g. instead of use . By default, this is set to . Note that the hardware acceleration special codecs like are not relevant anymore, and in fact have been removed from FFmpeg in this form. This is usually only needed with broken GPUs, where a codec is reported as supported, but decoding causes more problems than it solves. On some broken drivers (e.g. NVIDIA on Linux), probing for codecs which the GPU does not support can unnecessarily slow down video playback initialization. To alleviate this, explicitly specify a list which only includes the codecs supported on the setup. Enable vdpau decoding for h264 and mpeg2 only. Check hardware decoder profile (default: yes). If is set, the highest profile of the hardware decoder is unconditionally selected, and decoding is forced even if the profile of the video is higher than that. The result is most likely broken decoding, but may also help if the detected or reported profiles are somehow incorrect. Fallback to software decoding if the hardware-accelerated decoder fails (default: 3). If this is a number, then fallback will be triggered if N frames fail to decode in a row. 1 is equivalent to . Setting this to a higher number might break the playback start fallback: if a fallback happens, parts of the file will be skipped, approximately by to the number of packets that could not be decoded. Values below an unspecified count will not have this problem, because mpv retains the packets. Enables film grain application on the GPU. If video decoding is done on the CPU, doing film grain application on the GPU can speed up decoding. This option can also help hardware decoding, as it can reduce the number of frame copies done. By default, it's set to , so if the VO supports film grain application, then it will be treated as . If the VO does not support this, then it will be treated as , regardless of the setting. Currently, only supports film grain application. Enable direct rendering (default: auto). If this is set to , the video will be decoded directly to GPU video memory (or staging buffers). This can speed up video upload, and may help with large resolutions or slow hardware. This works only with the following VOs:\n• : requires at least OpenGL 4.4 or Vulkan. The option will try to guess whether DR can improve performance on your particular hardware. Currently this enables it on AMD or NVIDIA if using OpenGL or unconditionally if using Vulkan. Using video filters of any kind that write to the image data (or output newly allocated frames) will silently disable the DR code path. Only use bit-exact algorithms in all decoding steps (for codec testing). Enable optimizations which do not comply with the format specification and potentially cause problems, like simpler dequantization, simpler motion compensation, assuming use of the default quantization matrix, assuming YUV 4:2:0 and skipping a few checks to detect damaged bitstreams. Pass AVOptions to libavcodec decoder. Note, a patch to make the unneeded and pass all unknown options through the AVOption system is welcome. A full list of AVOptions can be found in the FFmpeg manual. Some options which used to be direct options can be set with this mechanism, like , , , , , (was ), (was ), . This is a key/value list option. See List Options for details. Show even broken/corrupt frames (default: no). If this option is set to no, libavcodec won't output frames that were either decoded before an initial keyframe was decoded, or frames that are recognized as corrupted. Skips the loop filter (AKA deblocking) during decoding. Since the filtered frame is supposed to be used as reference for decoding dependent frames, this has a worse effect on quality than not doing deblocking on e.g. MPEG-2 video. But at least for high bitrate HDTV, this provides a big speedup with little visible quality loss. Codecs other than H.264 or HEVC may have partial support for this option (often only and ). can be one of the following: Skip frames that are not referenced (i.e. not used for decoding other frames, the error cannot \"build up\"). Skips the IDCT step. This degrades quality a lot in almost all cases (see skiploopfilter for available skip values). Skips decoding of frames completely. Big speedup, but jerky motion and sometimes bad artifacts (see skiploopfilter for available skip values). Set framedropping mode used with (see skiploopfilter for available skip values). Number of threads to use for decoding. Whether threading is actually supported depends on codec (default: 0). 0 means autodetect number of cores on the machine and use that, up to the maximum of 16. You can set more than 16 threads manually. Assume the video was encoded by an old, buggy x264 version (default: no). Normally, this is autodetected by libavcodec. But if the bitstream contains no x264 version info (or it was somehow skipped), and the stream was in fact encoded by an old x264 version (build 150 or earlier), and if the stream uses 4:4:4 chroma, then libavcodec will by default show corrupted video. This option sets the libavcodec option to , which means that if the stream contains no version info, or was not encoded by x264 at all, it assumes it was encoded by the old version. Enabling this option is pretty safe if you want your broken files to work, but in theory this can break on streams not encoded by x264, or if a stream encoded by a newer x264 version contains no version info. Certain video codecs support cropping, meaning that only a sub-rectangle of the decoded frame is intended for display. This option controls how cropping is handled by libavcodec. Cropping during decoding has certain limitations with regards to alignment and hardware decoding. If this option is enabled, decoder will apply the crop, else VO will handle it. Enabled by default. Allow up to N in-flight frames. This essentially controls the frame latency. Increasing the swapchain depth can improve pipelining and prevent missed vsyncs, but increases visible latency. This option only mandates an upper limit, the implementation can use a lower latency than requested internally. A setting of 1 means that the VO will wait for every frame to become visible before starting to render the next frame. (Default: 3) If this is enabled (default), playing with a speed different from normal automatically inserts the audio filter. You can insert filters besides and modify their params using : Filters set this way replace the default, instead of overlapping with it. If there are multiple audio filters inserted that can do pitch correction, then only the last one in the filter chain is used. For details on the specifics of each available filter, see the audio filter section. Use the given audio device. This consists of the audio output name, e.g. , followed by , followed by the audio output specific device name. The default value for this option is , which tries every audio output in preference order with the default device. You can list audio devices with . This outputs the device name in quotes, followed by a description. The device name is what you have to pass to the option. The list of audio devices can be retrieved by API by using the property. While the option normally takes one of the strings as indicated by the methods above, you can also force the device for most AOs by building it manually. For example forces the AO to use the device . However, the option will strictly force a specific AO. To avoid confusion, don't use and together. MPlayer and mplayer2 required you to replace any ',' with '.' and any ':' with '=' in the ALSA device name. For example, to use the device named , you had to do: In mpv you could instead use: Enable exclusive output mode. In this mode, the system is usually locked out, and only mpv will be able to output audio. This only works for some audio outputs, such as , and . Other audio outputs silently ignore this option. They either have no concept of exclusive mode, or the mpv side of the implementation is missing. If no audio device can be opened, behave as if was given. This is useful in combination with : instead of causing an error if the selected device does not exist, the client API user (or a Lua script) could let playback continue normally, and check the and properties to make high-level decisions about how to continue. Specify the audio output drivers to be used. See AUDIO OUTPUT DRIVERS for details and descriptions of available drivers. Specify a list of audio filters to apply to the audio stream. See AUDIO FILTERS for details and descriptions of the available filters. The option variants , , and exist to modify a previously specified list, but you should not need these for typical use. List of codecs for which compressed audio passthrough should be used. This works for both classic S/PDIF and HDMI. Possible codecs are , , , , . Multiple codecs can be specified by separating them with . refers to low bitrate DTS core, while refers to DTS MA (receiver and OS support varies). If both and are specified, it behaves equivalent to specifying only. In earlier mpv versions you could use to force the spdif wrapper. This does not work anymore. There is not much reason to use this. HDMI supports uncompressed multichannel PCM, and mpv supports lossless DTS-HD decoding via FFmpeg's new DCA decoder (based on libdcadec). Specify a priority list of audio decoders to be used, according to their decoder name. When determining which decoder to use, the first decoder that matches the audio format is selected. If that is unavailable, the next decoder is used. Finally, it tries all other decoders that are not explicitly selected or rejected by the option. at the end of the list suppresses fallback on other available decoders not on the list. in front of an entry forces the decoder. Both of these should not normally be used, because they break normal decoder auto-selection! Both of these methods are deprecated. Prefer the FFmpeg decoder over all other MP3 decoders. Enabling compressed audio passthrough (AC3 and DTS via SPDIF/HDMI) with this option is not possible. Use instead. Set the startup volume. 0 means silence, 100 means no volume reduction or amplification. Negative values can be passed for compatibility, but are treated as 0. Since mpv 0.18.1, this always controls the internal mixer (aka software volume). Set the maximum amplification level in percent (default: 130). A value of 130 will allow you to adjust the volume up to about double the normal level. Set the volume gain in dB. This is applied on top of other volume and gain settings. Adjust volume gain according to replaygain values stored in the file metadata. With (the default), perform no adjustment. With , apply track gain. With , apply album gain if present and fall back to track gain otherwise. Pre-amplification gain in dB to apply to the selected replaygain gain (default: 0). Allow the volume gain to clip (default: no). If this option is not enabled, mpv automatically will prevent clipping by lowering the gain. Gain in dB to apply if the file has no replay gain tags. This option is always applied if the replaygain logic is somehow inactive. If this is applied, no other replaygain options are applied. Audio delay in seconds (positive or negative float value). Positive values delay the audio, and negative values delay the video. Use this audio demuxer type when using . Use a '+' before the name to force it; this will skip some checks. Give the demuxer name as printed by . Select the Dynamic Range Compression level for AC-3 audio streams. is a float value ranging from 0 to 1, where 0 means no compression (which is the default) and 1 means full compression (make loud passages more silent and vice versa). Values up to 6 are also accepted, but are purely experimental. This option only shows an effect if the AC-3 stream contains the required range compression information. The standard mandates that DRC is enabled by default, but mpv (and some other players) ignore this for the sake of better audio quality. Whether to request audio channel downmixing from the decoder (default: no). Some decoders, like AC-3, AAC and DTS, can remix audio on decoding. The requested number of output channels is set with the option. Useful for playing surround audio on a stereo system. Number of threads to use for decoding. Whether threading is actually supported depends on codec. As of this writing, it's supported for some lossless codecs only. 0 means autodetect number of cores on the machine and use that, up to the maximum of 16 (default: 1). Pass AVOptions to libavcodec decoder. Note, a patch to make the o= unneeded and pass all unknown options through the AVOption system is welcome. A full list of AVOptions can be found in the FFmpeg manual. This is a key/value list option. See List Options for details. If DTS is passed through, use DTS-HD. This and enabling passthrough via are deprecated in favor of using . Control which audio channels are output (e.g. surround vs. stereo). There are the following possibilities:\n• None Use the system's preferred channel layout. If there is none (such as when accessing a hardware device instead of the system mixer), force stereo. Some audio outputs might simply accept any layout and do downmixing on their own.\n• None Send the audio device whatever it accepts, preferring the audio's original channel layout. Can cause issues with HDMI (see the warning below).\n• None List of -separated channel layouts which should be allowed. Technically, this only adjusts the filter chain output to the best matching layout in the list, and passes the result to the audio API. It's possible that the audio API will select a different channel layout. Using this mode is recommended for direct hardware output, especially over HDMI (see HDMI warning below).\n• None Force a downmix to stereo or mono. These are special-cases of the previous item. (See paragraphs below for implications.) If a list of layouts is given, each item can be either an explicit channel layout name (like ), or a channel number. Channel numbers refer to default layouts, e.g. 2 channels refer to stereo, 6 refers to 5.1. See output for defined default layouts. This also lists speaker names, which can be used to express arbitrary channel layouts (e.g. is 2.1). If the list of channel layouts has only 1 item, the decoder is asked to produce according output. This sometimes triggers decoder-downmix, which might be different from the normal mpv downmix. (Only some decoders support remixing audio, like AC-3, AAC or DTS. You can use to make the decoder always output its native layout.) One consequence is that triggers decoder downmix, while or never will, even if they end up selecting stereo. This happens because the decision whether to use decoder downmix happens long before the audio device is opened. If the channel layout of the media file (i.e. the decoder) and the AO's channel layout don't match, mpv will attempt to insert a conversion filter. You may need to change the channel layout of the system mixer to achieve your desired output as mpv does not have control over it. Another work-around for this on some AOs is to use to circumvent the system mixer entirely. Using can cause issues when using audio over HDMI. The OS will typically report all channel layouts that _can_ go over HDMI, even if the receiver does not support them. If a receiver gets an unsupported channel layout, random things can happen, such as dropping the additional channels, or adding noise. You are recommended to set an explicit whitelist of the layouts you want. For example, most A/V receivers connected via HDMI and that can do 7.1 would be served by: Determines whether to display cover art when playing audio files and with what priority. It will display the first image found, and additional images are available as video tracks. Disable display of video entirely when playing audio files. This option has no influence on files with normal video tracks. Play audio from an external file while viewing a video. This is a path list option. See List Options for details. CLI/config file only alias for . Each use of this option will add a new audio track. The details are similar to how works. Select the sample format used for output from the audio filter layer to the sound card. The values that can adopt are listed below in the description of the audio filter. Select the output sample rate to be used (of course sound cards have limits on this). If the sample frequency selected is different from that of the current media, the internal swresample audio filter will be inserted into the audio filter layer to compensate for the difference. Try to play consecutive audio files with no silence or disruption at the point of file change. Default: . The audio device is opened using parameters chosen for the first file played and is then kept open for gapless playback. This means that if the first file for example has a low sample rate, then the following files may get resampled to the same low sample rate, resulting in reduced sound quality. If you play files with different parameters, consider using options such as and to explicitly select what the shared output format will be. Normally, the audio device is kept open (using the format it was first initialized with). If the audio format the decoder output changes, the audio device is closed and reopened. This means that you will normally get gapless audio with files that were encoded using the same settings, but might not be gapless in other cases. The exact conditions under which the audio device is kept open is an implementation detail, and can change from version to version. Currently, the device is kept even if the sample format changes, but the sample formats are convertible. If video is still going on when there is still audio, trying to use gapless is also explicitly given up. This feature is implemented in a simple manner and relies on audio output device buffering to continue playback while moving from one file to another. If playback of the new file starts slowly, for example because it is played from a remote network location or because you have specified cache settings that require time for the initial cache fill, then the buffered audio may run out before playback of the new file can start. When starting a video file or after events such as seeking, mpv will by default modify the audio stream to make it start from the same timestamp as video, by either inserting silence at the start or cutting away the first samples. Disabling this option makes the player behave like older mpv versions did: video and audio are both started immediately even if their start timestamps differ, and then video timing is gradually adjusted if necessary to reach correct synchronization later. Load additional audio files matching the video filename. The parameter specifies how external audio files are matched. Load all audio files containing the media filename. Load all audio files in the current and directories. Audio file extentions to try to match when using , or . This is a string list option. See List Options for details. Use to see default extensions. Equivalent to option, but for auto-loaded audio files. This is a path list option. See List Options for details. The application name the player reports to the audio API. Can be useful if you want to force a different audio profile (e.g. with PulseAudio), or to set your own application name when using libmpv. Set the audio output minimum buffer. The audio device might actually create a larger buffer if it pleases. If the device creates a smaller buffer, additional audio is buffered in an additional software buffer. Making this larger may make soft-volume and other filters react slower, introduce additional issues on playback speed change, and block the player on audio format changes. A smaller buffer might lead to audio dropouts. This option should be used for testing only. If a non-default value helps significantly, the mpv developers should be contacted. Cash-grab consumer audio hardware (such as A/V receivers) often ignore initial audio sent over HDMI. This can happen every time audio over HDMI is stopped and resumed. In order to compensate for this, you can enable this option to not to stop and restart audio on seeks, and fill the gaps with silence. Likewise, when pausing playback, audio is not stopped, and silence is played while paused. Note that if no audio track is selected, the audio device will still be closed immediately. Not all AOs support this. This modifies certain subtle player behavior, like A/V-sync and underrun handling. Enabling this option is strongly discouraged. This makes sense for use with . If this option is given, the player will wait for the given amount of seconds after opening the audio device before sending actual audio data to it. Useful if your expensive hardware discards the first 1 or 2 seconds of audio data sent to it. If is not set, this option will likely just waste time. Changing styling and position does not work with all subtitles. Image-based subtitles (DVD, Bluray/PGS, DVB) cannot changed for fundamental reasons. Subtitles in ASS format are normally not changed intentionally, but overriding them can be controlled with . Force subtitle demuxer type for . Give the demuxer name as printed by . Pass AVOptions to libavcodec decoder. Note, a patch to make the o= unneeded and pass all unknown options through the AVOption system is welcome. A full list of AVOptions can be found in the FFmpeg manual. This is a key/value list option. See List Options for details. Delays primary subtitles by seconds. Can be negative. Delays secondary subtitles by seconds. Can be negative. Add a subtitle file to the list of external subtitles. If you use only once, this subtitle file is displayed by default. If is used multiple times, the subtitle to use can be switched at runtime by cycling subtitle tracks. It's possible to show two subtitles at once: use to select the first subtitle index, and to select the second index. (The index is printed on the terminal output after the in the list of streams.) is a path list option (see List Options for details), and can take multiple file names separated by (Unix) or (Windows), while takes a single filename, but can be used multiple times to add multiple files. Technically, is a CLI/config file only alias for . Select a secondary subtitle stream. This is similar to . If a secondary subtitle is selected, it will be rendered as toptitle (i.e. on the top of the screen) alongside the normal subtitle by default, and provides a way to render two subtitles at once. There are some caveats associated with this feature. For example, bitmap subtitles will always be rendered in their usual position, so selecting a bitmap subtitle as secondary subtitle will result in overlapping subtitles. Secondary subtitles are never shown on the terminal if video is disabled. Styling and interpretation of any formatting tags is disabled for the secondary subtitle. Internally, the same mechanism as is used to strip the styling. If the main subtitle stream contains formatting tags which display the subtitle at the top of the screen, it will overlap with the secondary subtitle. To prevent this, you could use to disable styling in the main subtitle stream. This affects ASS subtitles as well, and may lead to incorrect subtitle rendering. Use with care, or use instead. Whether to scale subtitles with the window size (default: yes). If this is disabled while is set to yes, changing the window size won't change the subtitle font size. Affects plain text subtitles only (or ASS if is set high enough). Make the subtitle font size relative to the window (default: yes). If this is disabled while is set to yes, the subtitle font size is scaled relative to the video size instead. Affects plain text subtitles only (or ASS if is set high enough). By default, the subtitle font size is scaled with the window size. To make the font size constant, set only to no. To make the font size scale with video size instead, set only to no. It's not meaningful to set both options to no. Like , but affects subtitles in ASS format only. Like , this can break ASS subtitles. Use fonts embedded in Matroska container files and ASS scripts (default: yes). These fonts can be used for SSA/ASS subtitle rendering. Specify the position of subtitles on the screen. The value is the vertical position of the subtitle in % of the screen height. 100 is the original position, which is often not the absolute bottom of the screen, but with some margin between the bottom and the subtitle. Values above 100 move the subtitle further down. Text subtitles (as opposed to image subtitles) may be cut off if the value of the option is above 100. This is a libass restriction. This affects ASS subtitles as well, and may lead to incorrect subtitle rendering in addition to the problem above. Using can achieve this in a better way. Specify the position of secondary subtitles on the screen. This is similar to but for secondary subtitles. Multiply the subtitle event timestamps with the given value. Can be used to fix the playback speed for frame-based subtitle formats. Affects text subtitles only. plays frame based subtitles which have been loaded assuming a framerate of 23.976 at 25 FPS. This is a string list option. See List Options for details. Using this option may lead to incorrect subtitle rendering. Enabling hinting can lead to mispositioned text (in situations it's supposed to match up video background), or reduce the smoothness of animations with some badly authored ASS scripts. It is recommended to not use this option, unless really needed. Set the text layout engine used by libass. uses Fribidi only, fast, doesn't render some languages correctly is the default. If libass hasn't been compiled against HarfBuzz, libass silently reverts to . Load all SSA/ASS styles found in the specified file and use them for rendering text subtitles. The syntax of the file is exactly like the / section of SSA/ASS. Using this option may lead to incorrect subtitle rendering. Control whether user style overrides should be applied. Note that all of these overrides try to be somewhat smart about figuring out whether or not a subtitle is considered a \"sign\". Render subtitles as specified by the subtitle scripts, without overrides. Apply all the style override options. Changing the default for any of these options can lead to incorrect subtitle rendering. Like , but also apply (default). Like , but also force all options. Can break rendering easily. Radically strip all ASS tags and styles from the subtitle. This is equivalent to the old / options. This also controls some bitmap subtitle overrides, as well as HTML tags in formats like SRT, despite the name of the option. Control whether user secondary substyle overrides should be applied. This works exactly like . Enables placing toptitles and subtitles in black borders when they are available, if the subtitles are in the ASS format. Enables placing toptitles and subtitles in black borders when they are available, if the subtitles are in a plain text format (or ASS if is set high enough). Controls which information about the video stream is passed to libass. Any option but is incompatible with standard ASS as defined by VSFilter, whose behavior most subtitle scripts and renderers target, including libass. Video stream properties are needed to accurately emulate VSFilter semantics and withholding them will likely result in broken subtitle rendering for most files. It's thus recommended to only change this selectively if required on a per-file basis. Only forward aspect ratio; fallbacks are used for other properties. This makes behaviour consistent across different video resolutions. For certain kinds of broken ASS files which got repurposed across several video resolutions without either setting headers or adjusting affected effects, it may be desirable to withhold storage resolution information from libass to ensure consistent rendering across resolutions. Among others this affects 3D rotations and blurs. When encountering such files, try setting . Even more broken files on anamorphic video might also exhibit stretching unless aspect ratio information is also faked, in this case you can try using . This has never an effect on non-anamorphic video. Allows passing any arbitrary aspect ratio to libass instead of the video’s actual aspect ratio. Zero or negative aspect ratios are identical to . This has no effect if is set to . Set implicit bidi detection to instead of to match ASS' default. This also disables libass' incompatible extensions. This currently includes bracket pair matching according to the revised Unicode Bidirectional Algorithm introduced in Unicode 6.3, and also affects how BiDi runs are split and processed, as well as soft linewrapping of unicode text. This affects plaintext (non-ASS) subtitles only. Default: no. Mangle colors like (xy-)vsfilter do (default: basic). Historically, VSFilter was not color space aware. This was no problem as long as the color space used for SD video (BT.601) was used. But when everything switched to HD (BT.709), VSFilter was still converting RGB colors to BT.601, rendered them into the video frame, and handled the frame to the video output, which would use BT.709 for conversion to RGB. The result were mangled subtitle colors. Later on, bad hacks were added on top of the ASS format to control how colors are to be mangled. Handle only BT.601->BT.709 mangling, if the subtitles seem to indicate that this is required (default). Handle the full header with all video color spaces supported by libass and mpv. This might lead to bad breakages in corner cases and is not strictly needed for compatibility (hopefully), which is why this is not default. Force BT.601->BT.709 mangling, regardless of subtitle headers or video color space. Choosing anything other than will make the subtitle color depend on the video color space, and it's for example in theory not possible to reuse a subtitle script with another video file. The option doesn't affect how this option is interpreted. Stretch DVD subtitles when playing anamorphic videos for better looking fonts on badly mastered DVDs. This switch has no effect when the video is stored with square pixels - which for DVD input cannot be the case though. Many studios tend to use bitmap fonts designed for square pixels when authoring DVDs, causing the fonts to look stretched on playback on DVD players. This option fixes them, however at the price of possibly misaligning some subtitles (e.g. sign translations). Stretch DVD and other image subtitles to the screen, ignoring the video margins. This has a similar effect as for text subtitles, except that the text itself will be stretched, not only just repositioned. (At least in general it is unavoidable, as an image bitmap can in theory consist of a single bitmap covering the whole screen, and the player won't know where exactly the text parts are located.) This option does not display subtitles correctly. Use with care. Override the image subtitle resolution with the video resolution (default: no). Normally, the subtitle canvas is fit into the video canvas (e.g. letterboxed). Setting this option uses the video size as subtitle canvas size. Can be useful to test broken subtitles, which often happen when the video was trancoded, while attempting to keep the old subtitles. This has been deprecated by . You also may need to get the same behavior. Also, using should give better results without breaking subtitles too much. If is specified, all tags and style declarations are stripped and ignored on display. The subtitle renderer uses the font style as specified by the options instead. Using may lead to incorrect or completely broken rendering of ASS/SSA subtitles. It can sometimes be useful to forcibly override the styling of ASS subtitles, but should be avoided in general. Load additional subtitle files matching the video filename. The parameter specifies how external subtitle files are matched. is enabled by default. Load the media filename with subtitle file extension and possibly language suffixes (default). Load all subs containing the media filename. Load all subs in the current and directories. Subtitle extentions to try and match when using . Note that modifying this list will also affect what mpv recognizes as subtitles when using drag and drop. This is a string list option. See List Options for details. You can use this option to specify the subtitle codepage. uchardet will be used to guess the charset. (If mpv was not compiled with uchardet, then is the effective default.) The default value for this option is , which enables autodetection. The following steps are taken to determine the final codepage, in order:\n• if the specific codepage has a , use that codepage\n• if the data looks like UTF-8, assume it is UTF-8\n• if is set to a specific codepage, use that\n• run uchardet, and if successful, use that\n• Use Latin 2 if input is not UTF-8. The pseudo codepage is used internally. If it's set, subtitles are interpreted as UTF-8 with \"Latin 1\" as fallback for bytes which are not valid UTF-8 sequences. iconv is never involved in this mode. This works for text subtitle files only. Other types of subtitles (in particular subtitles in mkv files) are always assumed to be UTF-8. Stretch a subtitle duration so it ends when the next one starts. Should help with subtitles which erroneously have zero durations. Adjust subtitle timing is to remove minor gaps or overlaps between subtitles (if the difference is smaller than 210 ms, the gap or overlap is removed). Enabling this displays only forced events within subtitle streams. Only some bitmap subtitle formats (such as DVD or PGS) are capable of having a mixture of forced and unforced events within the stream. Enabling this on text subtitles will cause no subtitles to be displayed (default: ). Specify the framerate of the subtitle file (default: video fps). Affects text subtitles only. > video fps speeds the subtitles up for frame-based subtitle files and slows them down for time-based ones. Apply Gaussian blur to image subtitles (default: 0). This can help to make pixelated DVD/Vobsubs look nicer. A value other than 0 also switches to software subtitle scaling. Might be slow. Convert image subtitles to grayscale. Can help to make yellow DVD/Vobsubs look nicer. Specify extra directories to search for subtitles matching the video. Multiple directories can be separated by \":\" (\";\" on Windows). Paths can be relative or absolute. Relative paths are interpreted relative to video file directory. If the file is a URL, only absolute paths and configuration subdirectory will be scanned. Assuming that is played and is specified, mpv searches for subtitle files in these directories: This is a path list option. See List Options for details. Can be used to disable display of subtitles, but still select and decode them. Can be used to disable display of secondary subtitles, but still select and decode them. (Obscure, rarely useful.) Can be used to play broken mkv files with duplicate ReadOrder fields. ReadOrder is the first field in a Matroska-style ASS subtitle packets. It should be unique, and libass uses it for fast elimination of duplicates. This option disables caching of subtitles across seeks, so after a seek libass can't eliminate subtitle packets with the same ReadOrder as earlier packets. Note that enabling this option can result in broken subtitle behavior if you are not actually playing one of the aforementioned broken mkv files. This works for subtitle streams, and if FFmpeg has been compiled with support for it. Values are for individual pages. Special value (default) matches all subtitle pages. Special value matches all pages. Note that page is the default start page of actual teletext. It is also the former default value of this option. See the section in FFmpeg documentation for details. After the last frame of video, if this option is enabled, subtitles will continue to update based on audio timestamps. Otherwise, the subtitles for the last video frame will stay onscreen. Specify font to use for subtitles that do not themselves specify a particular font. The default is . The option (and many other style related options) are ignored when ASS-subtitles are rendered, unless is specified. This used to support fontconfig patterns. Starting with libass 0.13.0, this stopped working. Specify the sub font size. The unit is the size in scaled pixels at a window height of 720. The actual pixel size is scaled with the window height: if the window height is larger or smaller than 720, the actual size of the text increases or decreases as well. Gaussian blur factor applied to the sub font border. 0 means no blur applied (default). See . Color used for the sub font outline. is an alias for . See . Color used for sub text background. is an alias for . Size of the sub font outline in scaled pixels (see for details). A value of 0 disables outlines. is an alias for .\n• : draw outline and shadow. The size of the outline is determined by , and the offset of the shadow is determined by . The outline is colored by , and the shadow is colored by . This corresponds to in the ASS spec.\n• : draw outline and shadow as opaque boxes that tightly wrap each lines of text. The margin of the outline opaque box is determined by , and the offset of the shadow opaque box is determined by . The outline opaque box is colored by , and the shadow opaque box is colored by . Despite its name, the opaque box can be semi-transparent. This corresponds to in the ASS spec.\n• : draw a background box that bounds all lines of text. The background box is colored by , and the margin of the background box is determined by . The behavior of the outline is the same as the style. This corresponds to , which is a libass-specific extension. Specify the color used for unstyled text subtitles. The color is specified in the form , where each color component is specified as number in the range 0.0 to 1.0. It's also possible to specify the transparency by using , where the alpha value 0 means fully transparent, and 1.0 means opaque. If the alpha component is not given, the color is 100% opaque. Passing a single number to the option sets the sub to gray, and the form lets you specify alpha additionally.\n• set sub to opaque red with 75% alpha\n• set sub to 50% gray with 75% alpha Alternatively, the color can be specified as a RGB hex triplet in the form , where each 2-digit group expresses a color value in the range 0 ( ) to 255 ( ). For example, is red. Alpha is given with .\n• set sub to 50% gray with 75% alpha Left and right screen margin for the subs in scaled pixels (see for details). This option specifies the distance of the sub to the left, as well as at which distance from the right border long sub text will be broken. Top and bottom screen margin for the subs in scaled pixels (see for details). This option specifies the vertical margins of unstyled text subtitles. If you just want to raise the vertical subtitle position, use . Control to which corner of the screen text subtitles should be aligned to (default: ). Never applied to ASS subtitles, except in mode. Likewise, this does not apply to image subtitles. Control how multi line subs are justified irrespective of where they are aligned (default: which justifies as defined by ). Left justification is recommended to make the subs easier to read as it is easier for the eyes. Applies justification as defined by on ASS subtitles if is not set to . Default: . Displacement of the sub text shadow in scaled pixels (see for details). A value of 0 disables shadows. Horizontal sub font spacing in scaled pixels (see for details). This value is added to the normal letter spacing. Negative values are allowed. Applies filter removing subtitle additions for the deaf or hard-of-hearing (SDH). This is intended for English, but may in part work for other languages too. The intention is that it can be always enabled so may not remove all parts added. It removes speaker labels (like MAN:) and any text enclosed within symbols like parentheses or brackets as specified by the option. Note that parenthesis (full width parenthesis and the normal variant) are a special case and only upper case text is removed. For more filtering, you can use the option. Do harder SDH filtering (if enabled by ). Will also remove speaker labels and text within parentheses using both lower and upper case letters. Specify a string of characters that will use to potentially remove text. Text that is enclosed within characters specified by this string will be removed. Note that bracket characters with known pairs (such as or ) will be mapped internally to their matching right hand character, so you only need to specify left hand characters. Set a list of regular expressions to match on text subtitles, and remove any lines that match (default: empty). This is a string list option. See List Options for details. Normally, you should use , where each option use will append a new regular expression, without having to fight escaping problems. List items are matched in order. If a regular expression matches, the process is stopped, and the subtitle line is discarded. The text matched against is, by default, the field of ASS events (if the subtitle format is different, it is always converted). This may include formatting tags. Matching is case-insensitive, but how this is done depends on the libc, and most likely works in ASCII only. It does not work on bitmap/image subtitles. Unavailable on inferior OSes (requires POSIX regex support). Technically, using a list for matching is redundant, since you could just use a single combined regular expression. But it helps with diagnosis, ease of use, and temporarily disabling or enabling individual filters. This is experimental. The semantics most likely will change, and if you use this, you should be prepared to update the option later. Ideas include replacing the regexes with a very primitive and small subset of sed, or some method to control case-sensitivity. Same as but with JavaScript regular expressions. Shares/affected-by all control options (see below), and also experimental. Requires only JavaScript support. Whether to first convert the ASS \"Text\" field to plain-text (default: no). This strips ASS tags and applies ASS directives, like to new-line. If the result is multi-line then the regexp anchors and match each line, but still any match discards all lines. Log dropped lines with warning log level, instead of verbose (default: no). Helpful for testing. Whether to enable regex filtering (default: yes). Note that if no regexes are added to the list, setting this option to has no effect. It's meant to easily disable or enable filtering temporarily. For every video stream, create a closed captions track (default: no). The only purpose is to make the track available for selection at the start of playback, instead of creating it lazily. This applies only to (displayed by mpv as subtitle tracks using the codec ). The CC track is marked \"default\" and selected according to the normal subtitle track selection rules. You can then use to explicitly select the correct track too. If the video stream contains no closed captions, or if no video is being decoded, the CC track will remain empty and will not show any text. Which libass font provider backend to use (default: auto). will attempt to use the native font provider: fontconfig on Linux, CoreText on macOS, DirectWrite on Windows. forces fontconfig, if libass was built with support (if not, it behaves like ). The font provider effectively disables system fonts. It will still attempt to use embedded fonts (unless is set; this is the same behavior as with all other font providers), if provided, and fonts in the sub-directory if provided. (The fallback is more strict than that of other font providers, and if a font name does not match, it may prefer not to render any text that uses the missing font.) Font files in this directory are used by mpv/libass for subtitles. Useful if you do not want to install fonts to your system. Note that files in this directory are loaded into memory before being used by mpv. If you have a lot of fonts, consider using fonts.conf (see FILES section) to include additional mpv user settings. If this option is not specified, will be used by default. Set the window title. This is used for the video window, and if possible, also sets the audio stream title. There is a danger of this causing significant CPU usage, depending on the properties used. Changing the window title is often a slow operation, and if the title changes every frame, playback can be ruined. In multi-monitor configurations (i.e. a single desktop that spans across multiple displays), this option tells mpv which screen to display the video on. This option does not work properly with all window managers. In these cases, you can try to use to position the window explicitly. It's also possible that the window manager provides native features to control which screens application windows should use. This option does not actually work on wayland since window placement is not allowed. However setting this option does influence mpv's initial guess at finding an output which may be useful for options like or which depend on the monitor resolution. In multi-monitor configurations, this option tells mpv which screen to display the video on based on the screen name from the video backend. The same caveats in the option also apply here. This option is ignored and does nothing if is explicitly set. In multi-monitor configurations (i.e. a single desktop that spans across multiple displays), this option tells mpv which screen to go fullscreen to. If is used mpv will fallback on what the user provided with the option. This option works properly only with window managers which understand the EWMH hint. does not work on macOS and will behave like . In multi-monitor configurations, this option tells mpv which screen to go fullscreen to based on the screen name from the video backend. The same caveats in the option also apply here. This option is ignored and does nothing if is explicitly set. Do not terminate when playing or seeking beyond the end of the file, and there is no next file to be played (and is not used). Instead, pause the player. When trying to seek beyond end of the file, the player will attempt to seek to the last frame. Normally, this will act like on EOF, unless the option is set. The following arguments can be given: If the current file ends, go to the next file or terminate. (Default.) Don't terminate if the current file is the last playlist entry. Equivalent to without arguments. Like , but also applies to files before the last playlist entry. This means playback will never automatically advance to the next file. This option is not respected when using . Explicitly skipping to the next file if the binding uses will terminate playback as well. Also, if errors or unusual circumstances happen, the player can quit anyway. Since mpv 0.6.0, this doesn't pause if there is a next file in the playlist, or the playlist is looped. Approximately, this will pause when the player would normally exit, but in practice there are corner cases in which this is not the case (e.g. will play file.mkv normally, then fail to open , then exit). (In mpv 0.8.0, was introduced, which restores the old behavior.) If set to , instead of pausing when is active, just stop at end of file and continue playing forward when you seek backwards until end where it stops again. Default: . If the current file is an image, play the image for the given amount of seconds (default: 1). means the file is kept open forever (until the user stops playback manually). Unlike , the player is not paused, but simply continues playback until the time has elapsed. (It should not use any resources during \"playback\".) This affects image files, which are defined as having only 1 video frame and no audio. The player may recognize certain non-images as images, for example if is used to reduce the length to 1 frame, or if you seek to the last frame. This option does not affect the framerate used for or . For that, use instead. When viewing images, the playback time is not tracked on the command line output, and the image frame is not duplicated when encoding. To force the player into \"dumb mode\" and actually count out seconds, or to duplicate the image when encoding, you need to use , and use or to stop after a particular time. Create a video output window even if there is no video. This can be useful when pretending that mpv is a GUI application. Currently, the window always has the size 960x540, and is subject to , , and similar options. The window is created only after initialization (to make sure default window placement still works if the video size is different from the default window size). This can be a problem if initialization doesn't work perfectly, such as when opening URLs with bad network connection, or opening broken video files. The mode can be used to create the window always on program start, but this may cause other issues. (Windows only) Enable/disable playback progress rendering in taskbar (Windows 7 and above). (Windows only) Snap the player window to screen edges. Controls the default behavior of drag and drop on platforms that support this. will obey what the underlying os/platform gives mpv. Typically, holding shift during the drag and drop will append the item to the playlist. Otherwise, it will completely replace it. , , and always force replacing, appending to, and inserting next into the playlist respectively. disables all drag and drop behavior. Makes the player window stay on top of other windows. On Windows, if combined with fullscreen mode, this causes mpv to be treated as exclusive fullscreen window that bypasses the Desktop Window Manager. (macOS only) Sets the level of an ontop window (default: window). On top of all other windows. On top of system elements like Taskbar, Menubar and Dock. On top of the Desktop behind windows and Desktop icons. (macOS only) Focus the video window and make it the front most window on specific events (default: open). Never focus the window on open or new file load events. Focus the window on creation, eg when a vo is initialised. Focus the window on open and new file load event. (Windows only) Set the preference for window corner rounding. Let the system decide whether or not to round window corners Round the corners if appropriate Round the corners if appropriate, with a small radius Play video with window border and decorations. Since this is on by default, use to disable the standard window decorations. (Windows and X11 only) Play video with the window title bar. Since this is on by default, use to hide the title bar. The option takes precedence. (X11 and macOS only) Show the video window on all virtual desktops. Adjust the initial window position or size. and set the window size in pixels. and set the window position, measured in pixels from the top-left corner of the screen to the top-left corner of the image being displayed. If a percentage sign ( ) is given after the argument, it turns the value into a percentage of the screen size in that direction. Positions are specified similar to the standard X11 option format, in which e.g. +10-50 means \"place 10 pixels from the left border and 50 pixels from the lower border\" and \"--20+-10\" means \"place 20 pixels beyond the right and 10 pixels beyond the top border\". A trailing followed by an integer denotes on which workspace (virtual desktop) the window should appear (X11 only). If an external window is specified using the option, this option is ignored. The coordinates are relative to the screen given with for the video output drivers that fully support . Generally only supported by GUI VOs. Ignored for encoding. On macOS, the origin of the screen coordinate system is located on the bottom-left corner. For instance, will place the window at the bottom-left of the screen. This option does not work properly with all window managers. Wayland does not allow a client to position itself so this option will only affect the window size. Places the window in the middle of the screen. Places the window at the bottom right corner of the screen. Sets the window width to half the screen width. Window height is set so that the window has the video aspect ratio. Forces the window width and height to half the screen width and height. Will show black borders to compensate for the video aspect ratio (with most VOs and with ). Sets the window to half the screen widths, and positions it 10 pixels below/left of the top left corner of the screen, on the second workspace. See also and for fitting the window into a given size without changing aspect ratio. Set the initial window size to a maximum size specified by , without changing the window's aspect ratio. The size is measured in pixels, or if a number is followed by a percentage sign ( ), in percents of the screen size. This option never changes the aspect ratio of the window. If the aspect ratio mismatches, the window's size is reduced until it fits into the specified size. Window position is not taken into account, nor is it modified by this option (the window manager still may place the window differently depending on size). Use to change the window position. Its effects are applied after this option. See for details how this is handled with multi-monitor setups. Use instead if you just want to limit the maximum size of the window, rather than always forcing a window size. Use if you want to force both window width and height to a specific size. Generally only supported by GUI VOs. Ignored for encoding. Make the window width 70% of the screen size, keeping aspect ratio. Make the window as large as possible, without being wider than 70% of the screen width, or higher than 60% of the screen height. This option behaves exactly like , except that it sets the maximum size of the window. If the video is larger than 90% of the screen width or 80% of the screen height, make the window smaller until either its width is 90% of the screen, or its height is 80% of the screen. This option behaves exactly like , except that it sets the minimum size of the window (just as sets the maximum). Make the window at least 500 pixels wide and 500 pixels high (depending on the video aspect ratio, the width or height will be larger than 500 in order to keep the aspect ratio the same). Resize the video window to a multiple (or fraction) of the video size. This option is applied before and other options are applied (so they override this option). Changing this option while the window is maximized can unmaximize the window depending on the OS and window manager. If the window does not unmaximize, the multiplier will be applied if the user unmaximizes the window later. For example, would show the window at half the video size. Whether the video window is minimized or not. Setting this will minimize, or unminimize, the video window if the current VO supports it. Note that some VOs may support minimization while not supporting unminimization (eg: Wayland). Whether this option and work on program start or at runtime, and whether they're (at runtime) updated to reflect the actual window state, heavily depends on the VO and the windowing system. Some VOs simply do not implement them or parts of them, while other VOs may be restricted by the windowing systems (especially Wayland). Whether the video window is maximized or not. Setting this will maximize, or unmaximize, the video window if the current VO supports it. See for further remarks. Make mouse cursor automatically hide after given number of milliseconds (default: 1000 ms). will disable cursor autohide. means the cursor will stay hidden. If this option is given, the cursor is always visible in windowed mode. In fullscreen mode, the cursor is shown or hidden according to . Change how some video outputs render the OSD and text subtitles. This does not change appearance of the subtitles and only has performance implications. For VOs which support native ASS rendering (like , , ), this can be slightly faster or slower, depending on GPU drivers and hardware. For other VOs, this just makes rendering slower. Forces mpv to always render frames regardless of the visibility of the window. Currently only affects X11 and Wayland VOs since they are the only ones that have this optimization (i.e. everything else always renders regardless of visibility). Forcefully move mpv's video output window to default location whenever there is a change in video parameters, video stream or file. This used to be the default behavior. Currently only affects X11 and SDL VOs. By default, mpv will automatically resize itself if the video's size changes (i.e. advancing forward in a playlist). Setting this to disables this behavior so the window size never changes automatically. This option does not have any impact on the or options. will always stretch the video to window size, and will disable the window manager hints that force the window aspect ratio. (Ignored in fullscreen mode.) Set the aspect ratio of your monitor or TV screen. A value of 0 disables a previous setting (e.g. in the config file). Overrides the setting if enabled. See also and . Scale the window size according to the backing DPI scale factor from the OS (default: no). For example, if the OS DPI scaling is set to 200%, mpv's window size will be multiplied by 2. (macOS only) Uses the native fullscreen mechanism of the OS (default: yes). (Windows and X11 only) Show mpv in the taskbar (default: yes). If set to no, mpv will no longer appear in taskbars and tasklists in supported window managers, and may be excluded from Alt+Tab window switching. Set the aspect of a single pixel of your monitor or TV screen (default: 1). A value of 1 means square pixels (correct for (almost?) all LCDs). See also and . Turns off the screensaver (or screen blanker and similar mechanisms) at startup and turns it on again on exit (default: yes). When using , the screensaver will re-enable when playback is not active. will always disable the screensaver. Note that stopping the screensaver is only possible if a video output is available (i.e. there is an open mpv window). This is not supported on all video outputs, platforms, or desktop environments. Before mpv 0.33.0, the X11 backend ran in 10 second intervals when not paused in order to support screensaver inhibition in some environments. This functionality was removed in 0.33.0, but it is possible to call the command line program from a user script instead. This tells mpv to attach to an existing window. If a VO is selected that supports this option, it will use that window for video output. mpv will scale the video to the size of this window, and will add black bars to compensate if the aspect ratio of the video is different. On X11, the ID is interpreted as a on X11. Unlike MPlayer/mplayer2, mpv always creates its own window, and sets the wid window as parent. The window will always be resized to cover the parent window fully. The value is interpreted specially, and mpv will draw directly on the root window. On win32, the ID is interpreted as . Pass it as value cast to (all Windows handles are 32-bit), this is important as mpv will not accept negative values. mpv will create its own window and set the wid window as parent, like with X11. On macOS/Cocoa, the ID is interpreted as . Pass it as value cast to . mpv will create its own sub-view. Because macOS does not support window embedding of foreign processes, this works only with libmpv, and will crash when used from the command line. On Android, the ID is interpreted as . Pass it as a value cast to . Use with and for direct rendering using MediaCodec, or with (with or without ). Move the window when clicking on it and moving the mouse pointer (default: yes). Set the window instance name for X11-based video output methods. (X11 only) Control the use of NetWM protocol features. This may or may not help with broken window managers. This provides some functionality that was implemented by the now removed option. Actually, it is not known to the developers to which degree this option was needed, so feedback is welcome. Specifically, will force use of NetWM fullscreen support, even if not advertised by the WM. This can be useful for WMs that are broken on purpose, like XMonad. (XMonad supposedly doesn't advertise fullscreen support, because Flash uses it. Apparently, applications which want to use fullscreen anyway are supposed to either ignore the NetWM support hints, or provide a workaround. Shame on XMonad for deliberately breaking X protocols (as if X isn't bad enough already). This option might be removed in the future. If set to , then ask the compositor to unredirect the mpv window (default: ). This uses the hint. asks the window manager to disable the compositor only in fullscreen mode. sets to 0, which is the default value as declared by the EWMH specification, i.e. no change is done. asks the window manager to never disable the compositor. Whether or not to use presentation statistics from X11's presentation extension (default: ). mpv asks X11 for present events which it then may use for more accurate frame presentation. This only has an effect if is being used. The auto option enumerates XRandr providers for autodetection. If amd, radeon, intel, or nouveau (the standard x86 Mesa drivers) is found and nvidia is NOT found, presentation feedback is enabled. Other drivers are not assumed to work, so they are not enabled automatically. or can still be passed regardless to enable/disable this mechanism in case there is good/bad behavior with whatever your combination of hardware/drivers/etc. happens to be. Whether or not to set the window title when mpv is embedded on X11 (default: ). Specify the CD device for CDDA playback (default: ). Specify the DVD device or .iso filename (default: ). You can also specify a directory that contains files previously copied directly from a DVD (with e.g. vobcopy). (Blu-ray only) Specify the Blu-ray disc location. Must be a directory with Blu-ray structure. These options can be used to tune the CD Audio reading feature of mpv. Set paranoia level. Values other than 0 seem to break playback of anything but the first track. Force minimum overlap search during verification to <value> sectors. Add sectors to the values reported when addressing tracks. May be negative. Print CD text. This is disabled by default, because it ruins performance with CD-ROM drives for unknown reasons. Try to limit DVD speed (default: 0, no change). DVD base speed is 1385 kB/s, so an 8x drive can read at speeds up to 11080 kB/s. Slower speeds make the drive more quiet. For watching DVDs, 2700 kB/s should be quiet and fast enough. mpv resets the speed to the drive default value on close. Values of at least 100 mean speed in kB/s. Values less than 100 mean multiples of 1385 kB/s, i.e. selects 11080 kB/s. You need write access to the DVD device to change the speed. Some DVDs contain scenes that can be viewed from multiple angles. This option tells mpv which angle to use (default: 1). Adjust the brightness of the video signal (default: 0). Not supported by all video output drivers. Adjust the contrast of the video signal (default: 0). Not supported by all video output drivers. Adjust the saturation of the video signal (default: 0). You can get grayscale output with this option. Not supported by all video output drivers. Adjust the gamma of the video signal (default: 0). Not supported by all video output drivers. Adjust the hue of the video signal (default: 0). You can get a colored negative of the image with this option. Not supported by all video output drivers. Force demuxer type. Use a '+' before the name to force it; this will skip some checks. Give the demuxer name as printed by . Maximum length in seconds to analyze the stream properties. Whether to probe stream information (default: auto). Technically, this controls whether libavformat's function is called. Usually it's safer to call it, but it can also make startup slower. The choice (the default) tries to skip this for a few know-safe whitelisted formats, while calling it for everything else. The choice only calls it if and only if the file seems to contain no streams after opening (helpful in cases when calling the function is needed to detect streams at all, such as with FLV files). Minimum required libavformat probe score. Lower values will require less data to be loaded (makes streams start faster), but makes file format detection less reliable. Can be used to force auto-detected libavformat demuxers, even if libavformat considers the detection not reliable enough. (Default: 26.) Allow deriving the format from the HTTP MIME type (default: yes). Set this to no in case playing things from HTTP mysteriously fails, even though the same files work from local disk. This is default in order to reduce latency when opening HTTP streams. By default, some formats will be handled differently from other formats by explicitly checking for them. Most of these compensate for weird or imperfect behavior from libavformat demuxers. Passing disables these. For debugging and testing only. Note, a patch to make the o= unneeded and pass all unknown options through the AVOption system is welcome. A full list of AVOptions can be found in the FFmpeg manual. Note that some options may conflict with mpv options. This is a key/value list option. See List Options for details. Maximum amount of data to probe during the detection phase. In the case of MPEG-TS this value identifies the maximum number of TS packets to scan. Size of the stream read buffer allocated for libavformat in bytes (default: 32768). Lowering the size could lower latency. Note that libavformat might reallocate the buffer internally, or not fully use all of it. Attempt to linearize timestamp resets in demuxed streams (default: auto). This was tested only for single audio streams. It's unknown whether it works correctly for video (but likely won't). Note that the implementation is slightly incorrect either way, and will introduce a discontinuity by about 1 codec frame size. The mode enables this for OGG audio stream. This covers the common and annoying case of OGG web radio streams. Some of these will reset timestamps to 0 every time a new song begins. This breaks the mpv seekable cache, which can't deal with timestamp resets. Note that FFmpeg/libavformat's seeking API can't deal with this either; it's likely that if this option breaks this even more, while if it's disabled, you can at least seek within the first song in the stream. Well, you won't get anything useful either way if the seek is outside of mpv's cache. Propagate FFmpeg-level options to recursively opened connections (default: yes). This is needed because FFmpeg will apply these settings to nested AVIO contexts automatically. On the other hand, this could break in certain situations - it's the FFmpeg API, you just can't win. This affects in particular the option and anything passed with . If this option is deemed unnecessary at some point in the future, it will be removed without notice. Try harder to show embedded soft subtitles when seeking somewhere. Normally, it can happen that the subtitle at the seek target is not shown due to how some container file formats are designed. The subtitles appear only if seeking before or exactly to the position a subtitle first appears. To make this worse, subtitles are often timed to appear a very small amount before the associated video frame, so that seeking to the video frame typically does not demux the subtitle at that position. Enabling this option makes the demuxer start reading data a bit before the seek target, so that subtitles appear correctly. Note that this makes seeking slower, and is not guaranteed to always work. It only works if the subtitle is close enough to the seek target. Works with the internal Matroska demuxer only. Always enabled for absolute and hr-seeks, and this option changes behavior with relative or imprecise seeks only. You can use the option to specify how much data the demuxer should pre-read at most in order to find subtitle packets that may overlap. Setting this to 0 will effectively disable this preroll mechanism. Setting a very large value can make seeking very slow, and an extremely large value would completely reread the entire file from start to seek target on every seek - seeking can become slower towards the end of the file. The details are messy, and the value is actually rounded down to the cluster with the previous video keyframe. Some files, especially files muxed with newer mkvmerge versions, have information embedded that can be used to determine what subtitle packets overlap with a seek target. In these cases, mpv will reduce the amount of data read to a minimum. (Although it will still read all data between the cluster that contains the first wanted subtitle packet, and the seek target.) If the choice (which is the default) is specified, then prerolling will be done only if this information is actually available. If this method is used, the maximum amount of data to skip can be additionally controlled by (it still uses the value of the option without if that is higher). See also option. This option can achieve a similar effect, but only if hr-seek is active. It works with any demuxer, but makes seeking much slower, as it has to decode audio and video data instead of just skipping over it. Check the start time of Matroska files (default: yes). This simply reads the first cluster timestamps and assumes it is the start time. Technically, this also reads the first timestamp, which may increase latency by one frame (which may be relevant for live streams). When opening the file, seek to the end of it, and check what timestamp the last video packet has, and report that as file duration. This is strictly for compatibility with Haali only. In this mode, it's possible that opening will be slower (especially when playing over http), or that behavior with broken files is much worse. So don't use this option. The mode merely uses the index and reads a small number of blocks from the end of the file. The mode actually traverses the entire file and can make a reliable estimate even without an index present (such as partial files). Number of channels (or channel layout) if is used (default: stereo). Sample format for (default: s16le). Use to get a list of all formats. Rate in frames per second for (default: 25.0). Color space (fourcc) in hex or string for (default: ). Color space by internal video format for . Use for a list of possible formats. Set the video codec instead of selecting the rawvideo codec when using . This uses the same values as codec names in (but it does not accept decoder names). Frame size in bytes when using . This controls how much the demuxer is allowed to buffer ahead. The demuxer will normally try to read ahead as much as necessary, or as much is requested with . The option can be used to restrict the maximum readahead. This limits excessive readahead in case of broken files or desynced playback. The demuxer will stop reading additional packets as soon as one of the limits is reached. (The limits still can be slightly overstepped due to technical reasons.) Set these limits higher if you get a packet queue overflow warning, and you think normal playback would be possible with a larger packet queue. See for defaults and value range. options accept suffixes such as and . This controls how much past data the demuxer is allowed to preserve. This is useful only if the cache is enabled. Unlike the forward cache, there is no control how many seconds are actually cached - it will simply use as much memory this option allows. Setting this option to 0 will strictly disable any back buffer, but this will lead to the situation that the forward seek range starts after the current playback position (as it removes past packets that are seek points). If the end of the file is reached, the remaining unused forward buffer space is \"donated\" to the backbuffer (unless the backbuffer size is set to 0, or is set to ). This still limits the total cache usage to the sum of the forward and backward cache, and effectively makes better use of the total allowed memory budget. (The opposite does not happen: free backward buffer is never \"donated\" to the forward buffer.) Keep in mind that other buffers in the player (like decoders) will cause the demuxer to cache \"future\" frames in the back buffer, which can skew the impression about how much data the backbuffer contains. See for defaults and value range. Whether to let the back buffer use part of the forward buffer (default: yes). If set to , the \"donation\" behavior described in the option description for is enabled. This means the back buffer may use up memory up to the sum of the forward and back buffer options, minus the active size of the forward buffer. If set to , the options strictly limit the forward and back buffer sizes separately. Note that if the end of the file is reached, the buffered data stays the same, even if you seek back within the cache. This is because the back buffer is only reduced when new data is read. Debugging option to control whether seeking can use the demuxer cache (default: auto). Normally you don't ever need to set this; the default does the right thing and enables cache seeking it if is set to (or is implied if ). If enabled, short seek offsets will not trigger a low level demuxer seek (which means for example that slow network round trips or FFmpeg seek bugs can be avoided). If a seek cannot happen within the cached range, a low level seek will be triggered. Seeking outside of the cache will start a new cached range, but can discard the old cache range if the demuxer exhibits certain unsupported behavior. The special value means in the same situation as is used (i.e. when the stream appears to be a network stream or the stream cache is enabled). Run the demuxer in a separate thread, and let it prefetch a certain amount of packets (default: yes). Having this enabled leads to smoother playback, enables features like prefetching, and prevents that stuck network freezes the player. On the other hand, it can add overhead, or the background prefetching can hog CPU resources. Disabling this option is not recommended. Use it for debugging only. Number of seconds the player should wait to shutdown the demuxer (default: 0.1). The player will wait up to this much time before it closes the stream layer forcefully. Forceful closing usually means the network I/O is given no chance to close its connections gracefully (of course the OS can still close TCP connections properly), and might result in annoying messages being logged, and in some cases, confused remote servers. This timeout is usually only applied when loading has finished properly. If loading is aborted by the user, or in some corner cases like removing external tracks sourced from network during playback, forceful closing is always used. If is enabled, this controls how much the demuxer should buffer ahead in seconds (default: 1). As long as no packet has a timestamp difference higher than the readahead amount relative to the last packet returned to the decoder, the demuxer keeps reading. Note that enabling the cache (such as , or if the input is considered a network stream, and is used), this option is mostly ignored. ( will override this. Technically, the maximum of both options is used.) The main purpose of this option is to limit the readhead for local playback, since a large readahead value is not overly useful in this case. Once the demuxer limit is reached ( , or ), this value can be used to specify a hysteresis before the demuxer will buffer ahead again. This specifies the maximum number of seconds from the current playback position that needs to be remaining in the cache before the demuxer will continue buffering ahead. For example, with a value of 10 seconds specified, the demuxer will buffer ahead up to the demuxer limit and won't start buffering ahead again until there is only 10 seconds of content left in the cache. This can provide significant power savings and reduce load by making the demuxer only buffer ahead in chunks at a time rather than buffering ahead nonstop to keep the cache filled. If you want to save power and reduce load, configure this to a small number that's much lower than or . If it takes a long time to buffer anything at all for a given stream (like when reading from a very slow disk is involved), then the hysteresis value should be larger to compensate. The default value is 0 seconds, which disables the caching hysteresis. A value of 10 seconds probably works well for most usecases. Prefetch next playlist entry while playback of the current entry is ending (default: no). This does not prefill the cache with the video data of the next URL. Prefetching video data is supported only for the current playlist entry, and depends on the demuxer cache settings (on by default). This merely opens the URL of the next playlist entry as soon the current URL is fully read. This does not work with URLs resolved by the wrapper, and it won't. This can give subtly wrong results if per-file options are used, or if options are changed in the time window between prefetching start and next file played. This can occasionally make wrong prefetching decisions. For example, it can't predict whether you go backwards in the playlist, and assumes you won't edit the playlist. If the player thinks that the media is not seekable (e.g. playing from a pipe, or it's an http stream with a server that doesn't support range requests), seeking will be disabled. This option can forcibly enable it. For seeks within the cache, there's a good chance of success. Before starting playback, read data until either the end of the file was reached, or the demuxer cache has reached maximum capacity. Only once this is done, playback starts. This intentionally happens before the initial seek triggered with . This does not change any runtime behavior after the initial caching. This option is useless if the file cannot be cached completely. When opening multi-volume rar files, open all volumes to create a full list of contained files (default: no). If disabled, only the archive entries whose headers are located within the first volume are listed (and thus played when opening a .rar file with mpv). Doing so speeds up opening, and the typical idiotic use-case of playing uncompressed multi-volume rar files that contain a single media file is made faster. Opening is still slow, because for unknown, idiotic, and unnecessary reasons libarchive opens all volumes anyway when playing the main file, even though mpv iterated no archive entries yet. When opening a directory, open subdirectories lazily, recursively or not at all. The default is , which behaves like with , and like otherwise. Media file types to filter when opening directory. If the list is empty, all files are added to the playlist. (Default: ) This is a string list option. See List Options for details. When opening a local file, act as if the parent directory is opened and create a playlist automatically. Create a playlist from the parent directory with files matching . Create a playlist from the parent directory with files matching the same category as the currently loaded file. One of the is selected based on the input file and only files with matching extensions are added to the playlist. If the input file itself is not matched to any extension list, the playlist is not autogenerated. Use system settings for keyrepeat delay and rate, instead of and (default: no). Whether this applies depends on the VO backend and how it handles keyboard input. Does not apply to terminal input. (Windows only) For platforms which send emulated mouse inputs for touch-unaware clients, such as Windows, use system native touch events, instead of receiving them as emulated mouse events (default: no). This is required for multi-touch support for these platforms. Note that this option has no effect on other platforms: either native touch is not supported by mpv, or the platform does not give an option to receive emulated mouse inputs (so native touch is always enabled, e.g. Wayland). Delay in milliseconds before we start to autorepeat a key (default: 200). Set it to 0 to disable. Number of key presses to generate per second on autorepeat (default: 40). Specify input configuration file other than the default location in the mpv configuration directory (usually ). Enable default-level (\"weak\") key bindings (default: yes). These are bindings which config files like can override. It currently affects the builtin key bindings, and keys which scripts bind using (but not because this overrides ). Enable loading of built-in key bindings during start-up (default: yes). This option is applied only during (lib)mpv initialization, and if disabled then it will not be not possible to enable them later. May be useful to libmpv clients. Enable the built-in window-dragging behavior (default: yes). Setting it to no disables the built-in dragging behavior. Note that unlike the option, this option only affects VOs which support the command, and does not disable window dragging initialized with the command. Prints all commands that can be bound to keys. Define a list of commands for mpv to run. The syntax is the same as format as but without the key binding argument at the beginning. When this option is set at startup, the commands will run after audio and video playback are about to begin if applicable (in idle mode with no file, it will run immediately). When changing values at runtime, the commands will also run as soon as possible. This is a string list option. See List Options for details. sets the playlist index to 1 and the ao-volume to 40 Time in milliseconds to recognize two consecutive button presses as a double-click (default: 300). Prints all keys that can be bound to commands. Specify the size of the FIFO that buffers key events (default: 7). If it is too small, some events may be lost. The main disadvantage of setting it to a very large value is that if you hold down a key triggering some particularly slow command then the player may be unresponsive while it processes all the queued commands. Input test mode. Instead of executing commands on key presses, mpv will show the keys and the bound commands on the OSD. Has to be used with a dummy video, and the normal ways to quit the player will not work (key bindings that normally quit will be shown on OSD only, just like any other binding). See INPUT.CONF. prevents the player from reading key events from standard input. Useful when reading data from standard input. This is automatically enabled when is found on the command line. There are situations where you have to set it manually, e.g. if you open (or the equivalent on your system), use stdin in a playlist or intend to read from stdin later on via the loadfile or loadlist input commands. Enable the IPC support and create the listening socket at the given path. On Linux and Unix, the given path is a regular filesystem path. On Windows, named pipes are used, so the path refers to the pipe namespace ( ). If the prefix is missing, mpv will add it automatically before creating the pipe, so and are equivalent for IPC on Windows. Connect a single IPC client to the given FD. This is somewhat similar to , except no socket is created, and instead the passed FD is treated like a socket connection received from . In practice, you could pass either a FD created by , or a pipe. In both cases, you must make sure that the FD is actually inherited by mpv (do not set the POSIX flag). The player quits when the connection is closed. This is somewhat similar to the removed option, except it supports only integer FDs, and cannot open actual paths. To use this option on Windows, the fd must refer to a wrapped (created by ) named pipe server handle with a client already connected. The named pipe must be created duplex with overlapped IO and inheritable handles. The program communicates with mpv through the client handle. Writing to the option at runtime will start another instance of an IPC client handler for the option, because initialization is bundled, and this thing is stupid. This is a bug. Writing to at runtime will start another IPC client handler for the new value, without stopping the old one, even if the FD value is the same (but the string is different e.g. due to whitespace). This is not a bug. Permit mpv to receive pointer events reported by the video output driver. Necessary to use the OSC. Support depends on the VO in use. Tell the backend windowing system to allow pointer events to passthrough the mpv window. This allows windows under mpv to instead receive pointer events as if the mpv window was never there. On systems where mpv can choose between receiving media keys or letting the system handle them - this option controls whether mpv should receive them. Default: yes (except for libmpv). macOS and Windows only, because elsewhere mpv doesn't have a choice - the system decides whether to send media keys to mpv. For instance, on X11 or Wayland, system-wide media keys are not implemented. Whether media keys work when the mpv window is focused is implementation-defined. Preprocess events so that while scrolling on the horizontal or vertical direction, the events aren't generated for another direction even when the two directions are scrolled together (default: yes). This preprocessing can be beneficial for preventing accidentally seeking while changing the volume by scrolling on a touchpad with the default keybind. Due to the deadzone mechanism used, disabling the preprocessing allows for diagonal scrolling (such as panning) and potentially reduces input latency. Note that disabling the preprocessing does not affect any filtering done by the OS/driver before these events are delivered to mpv, if any. (macOS and Windows only) Use the right Alt key as Alt Gr to produce special characters. If disabled, count the right Alt as an Alt modifier key. Enabled by default. Disable all keyboard input on for VOs which can't participate in proper keyboard input dispatching. May not affect all VOs. Generally useful for embedding only. On X11, a sub-window with input enabled grabs all keyboard input as long as it is 1. a child of a focused window, and 2. the mouse is inside of the sub-window. It can steal away all keyboard input from the application embedding the mpv window, and on the other hand, the mpv window will receive no input if the mouse is outside of the mpv window, even though mpv has focus. Modern toolkits work around this weird X11 behavior, but naively embedding foreign windows breaks it. The only way to handle this reasonably is using the XEmbed protocol, which was designed to solve these problems. GTK provides , which supports XEmbed. Qt doesn't seem to provide anything working in newer versions. If the embedder supports XEmbed, input should work with default settings and with this option disabled. Note that is disabled by default in libmpv as well - it should be enabled if you want the mpv default key bindings. When multi-touch support is enabled (either required by the platform, or enabled by ), emulate mouse move and button presses for the touch events (default: yes). This is useful for compatibility for mouse key bindings and scripts which read mouse positions for platforms which do not support (e.g. Wayland). Begin the built-in window dragging when the mouse moves outside a deadzone of pixels while the mouse button is being held down (default: 3). This only affects VOs which support the command. Whether to load the on-screen-controller (default: yes). Enable display of the OSD bar (default: yes). You can configure this on a per-command basis in input.conf using prefixes, see . If you want to disable the OSD completely, use . Set what is displayed on the OSD during seeks. The default is . You can configure this on a per-command basis in input.conf using prefixes, see . Set the duration of the OSD messages in ms (default: 1000). Specify font to use for OSD. The default is . Specify the OSD font size. See for details. Show this string as message on OSD with OSD level 1 (visible by default). The message will be visible by default, and as long as no other message covers it, and the OSD level isn't changed (see ). Expands properties; see Property Expansion. Similar to , but for OSD level 2. If this is an empty string (default), then the playback time is shown. Similar to , but for OSD level 3. If this is an empty string (default), then the playback time, duration, and some more information is shown. This is used for the command (by default mapped to ), and when seeking if enabled with or by prefixes in input.conf (see ). is a legacy equivalent (but with a minor difference). Show a custom string during playback instead of the standard status text. This overrides the status text used for , when using the command (by default mapped to ), and when seeking if enabled with or prefixes in input.conf (see ). Expands properties. See Property Expansion. This option has been replaced with . The only difference is that this option implicitly includes . This option is ignored if is not empty. Show a message on OSD when playback starts. The string is expanded for properties, e.g. will show the message followed by a space and the currently played filename. Set the duration of in ms. If this is unset, stays on screen for the duration of . Whether to display the media title, filename, or both. If the is not available, it will display only the . Position of the OSD bar. -1 is far left, 0 is centered, 1 is far right. Fractional values (like 0.5) are allowed. Position of the OSD bar. -1 is top, 0 is centered, 1 is bottom. Fractional values (like 0.5) are allowed. Width of the OSD bar, in percentage of the screen width (default: 75). A value of 50 means the bar is half the screen wide. Height of the OSD bar, in percentage of the screen height (default: 3.125). Size of the outline of the OSD bar in scaled pixels (see for details). is an alias for . Gaussian blur factor applied to the OSD font border. 0 means no blur applied (default). See . Color used for the OSD font outline. is an alias for . See . Color used for OSD text background. is an alias for . Size of the OSD font outline in scaled pixels (see for details). A value of 0 disables outlines. is an alias for . See . Style used for OSD text border. Specify the color used for OSD. See for details. Show OSD times with fractions of seconds (in millisecond precision). Useful to see the exact timestamp of a video frame. Specifies which mode the OSD should start in. enabled (shows up only on user interaction) Left and right screen margin for the OSD in scaled pixels (see for details). This option specifies the distance of the OSD to the left, as well as at which distance from the right border long OSD text will be broken. Top and bottom screen margin for the OSD in scaled pixels (see for details). This option specifies the vertical margins of the OSD. Control to which corner of the screen OSD should be aligned to (default: ). Whether to scale the OSD with the window size (default: yes). If this is disabled, and other OSD options that use scaled pixels are always in actual pixels. The effect is that changing the window size won't change the OSD font size. For scripts which draw user interface elements, it is recommended to respect the value of this option when deciding whether the elements are scaled with window size or not. Displacement of the OSD shadow in scaled pixels (see for details). A value of 0 disables shadows. Horizontal OSD/sub font spacing in scaled pixels (see for details). This value is added to the normal letter spacing. Negative values are allowed. Enabled OSD rendering on the video window (default: yes). This can be used in situations where terminal OSD is preferred. If you just want to disable all OSD rendering, use . It does not affect subtitles or overlays created by scripts (in particular, the OSC needs to be disabled with ). This option is somewhat experimental and could be replaced by another mechanism in the future. See for details and accepted values. Note that unlike subtitles, OSD never uses embedded fonts from media files. See for details. Defaults to . Set the image file type used for saving screenshots. Tag screenshots with the appropriate colorspace (default: yes). Note that not all formats support this. When it is unsupported, or when this option is disabled, screenshots will be converted to sRGB before being written. If possible, write screenshots with a bit depth similar to the source video (default: yes). This is interesting in particular for PNG, as this sometimes triggers writing 16 bit PNGs with huge file sizes. This will also include an unused alpha channel in the resulting files if 16 bit is used. Specify the filename template used to save screenshots. The template specifies the filename without file extension, and can contain format specifiers, which will be substituted when taking a screenshot. By default, the template is , which results in filenames like for example. The template can start with a relative or absolute path, in order to specify a directory location where screenshots should be saved. If the final screenshot filename points to an already existing file, the file will not be overwritten. The screenshot will either not be saved, or if the template contains , saved using different, newly generated filename. A sequence number, padded with zeros to length X (default: 04). E.g. passing the format will yield on the 12th screenshot. The number is incremented every time a screenshot is taken or if the file already exists. The length must be in the range 0-9. With the optional # sign, mpv will use the lowest available number. For example, if you take three screenshots--0001, 0002, 0003--and delete the first two, the next two screenshots will not be 0004 and 0005, but 0001 and 0002 again. Filename of the currently played video. Same as , but strip the file extension, including the dot. Directory path of the currently played video. If the video is not on the filesystem (but e.g. ), this expand to an empty string. Same as , but if the video file is not on the filesystem, return the fallback string inside the . Current playback time, in the same format as used in the OSD. The result is a string of the form \"HH:MM:SS\". For example, if the video is at the time position 5 minutes and 34 seconds, will be replaced with \"00:05:34\". Similar to , but extended with the playback time in milliseconds. It is formatted as \"HH:MM:SS.mmm\", with \"mmm\" being the millisecond part of the playback time. This is a simple way for getting unique per-frame timestamps. (Frame numbers would be more intuitive, but are not easily implementable because container formats usually use time stamps for identifying frames.) Specify the current playback time using the format string . is like , and is like . hour (padded with 0 to two digits) like , but as float Specify the current local date/time using the format . This format specifier uses the UNIX function internally, and inserts the result of passing \"%X\" to . For example, will insert the number of the current month as number. You have to use multiple specifiers to build a full date/time string. Insert the value of the input property 'prop'. E.g. is the same as . If the property does not exist or is not available, an error text is inserted, unless a fallback is specified. Replaced with the character itself. Store screenshots in this directory. This path is joined with the filename generated by . If the template filename is already absolute, the directory is ignored. is an alias for . If the directory does not exist, it is created on the first screenshot. If it is not a directory, an error is generated when trying to write a screenshot. This option is not set by default, and thus will write screenshots to the directory from which mpv was started. In pseudo-gui mode (see PSEUDO GUI MODE), this is set to the desktop. Set the JPEG quality level. Higher means better quality. The default is 90. Write JPEG files with the same chroma subsampling as the video (default: yes). If disabled, the libjpeg default is used. Set the PNG compression level. Higher means better compression. This will affect the file size of the written screenshot file and the time it takes to write a screenshot. Too high compression might occupy enough CPU time to interrupt playback. The default is 7. Set the filter applied prior to PNG compression. 0 is none, 1 is \"sub\", 2 is \"up\", 3 is \"average\", 4 is \"Paeth\", and 5 is \"mixed\". This affects the level of compression that can be achieved. For most images, \"mixed\" achieves the best compression ratio, hence it is the default. Write lossless WebP files. is ignored if this is set. The default is no. Set the WebP quality level. Higher means better quality. The default is 75. Set the WebP compression level. Higher means better compression, but takes more CPU time. Note that this also affects the screenshot quality when used with lossy WebP files. The default is 4. Set the JPEG XL Butteraugli distance. Lower means better quality. Lossless is 0.0, and 1.0 is approximately equivalent to JPEG quality 90 for photographic content. Use 0.1 for \"visually lossless\" screenshots. The default is 1.0. Set the JPEG XL compression effort. Higher effort (usually) means better compression, but takes more CPU time. The default is 4. Specify the AV1 encoder to be used by libavcodec for encoding avif screenshots. Specify the pixel format for the libavcodec encoder. Defaults to empty, which lets mpv pick one close to the source format. Specifies libavcodec options for selected encoder. For more information, consult the FFmpeg documentation. Note: the default is only guaranteed to work with the libaom-av1 encoder. Above options may not be valid and or optimal for other encoders. This is a key/value list option. See List Options for details. sets the crf to 23 and quantization (aq-mode) to complexity based. Whether to use software rendering for screenshots (default: no). If set to no, the screenshot will be rendered by the current VO (only vo_gpu or vo_gpu_next currently). The advantage is that this will (probably) always show up as in the video window, because the same code is used for rendering. But since the renderer needs to be reinitialized, this can be slow and interrupt playback. If set to yes, the software scaler is used to convert the video to RGB (or whatever the target screenshot requires). In this case, conversion will run in a separate thread and will probably not interrupt playback. The software renderer may lack some capabilities, such as HDR rendering. If mode is used, the image will also be scaled in software which may not accurately reflect the actual visible result. Specify the software scaler algorithm to be used with . This also affects video output drivers which lack hardware acceleration, e.g. . See also . To get a list of available scalers, run . Unknown functionality (default: no). Consult libswscale source code. The primary purpose of this, as far as libswscale API goes), is to produce exactly the same output for the same input on all platforms (output has the same \"bits\" everywhere, thus \"bitexact\"). Typically disables optimizations. Allow optimizations that help with performance, but reduce quality (default: no). VOs like and will benefit a lot from using . You may need to set other options, like . The builtin profile sets this option and some others to gain performance for reduced quality. Also see . Allow using zimg (if the component using the internal swscale wrapper explicitly allows so) (default: yes). In this case, zimg may be used, if the internal zimg wrapper supports the input and output formats. It will silently or noisily fall back to libswscale if one of these conditions does not apply. If zimg is used, the other options are ignored, and the options are used instead. If the internal component using the swscale wrapper hooks up logging correctly, a verbose priority log message will indicate whether zimg is being used. Most things which need software conversion can make use of this. Do note that zimg may be slower than libswscale. Usually, it's faster on x86 platforms, but slower on ARM (due to lack of ARM specific optimizations). The mpv zimg wrapper uses unoptimized repacking for some formats, for which zimg cannot be blamed. Set scaler parameters. By default, these are set to the special string , which maps to a scaler-specific default value. Ignored if the scaler is not tunable. is the number of taps. a and b are the bicubic b and c parameters. Same as , for for chroma interpolation (default: bilinear). Same as / , for chroma. Set the maximum number of threads to use for scaling (default: auto). uses the number of logical cores on the current machine. Note that the scaler may use less threads (or even just 1 thread) depending on stuff. Passing a value of 1 disables threading and always scales the image in a single operation. Higher thread counts waste resources, but make it typically faster. Note that some zimg git versions had bugs that will corrupt the output if threads are used. Allow optimizations that help with performance, but reduce quality (default: yes). Currently, this may simplify gamma conversion operations. This controls the default options of any resampling done by mpv (but not within libavfilter, within the system audio API resampler, or any other places). Length of the filter with respect to the lower sampling rate. (default: 16) Log2 of the number of polyphase entries. (..., 10->1024, 11->2048, 12->4096, ...) (default: 10->1024) If set then filters will be linearly interpolated between polyphase entries. (default: no) Enable/disable normalization if surround audio is downmixed to stereo (default: no). If this is disabled, downmix can cause clipping. If it's enabled, the output might be too quiet. It depends on the source audio. If downmix happens outside of mpv for some reason, or in the decoder (decoder downmixing), or in the audio output (system mixer), this has no effect. Limit maximum size of audio frames filtered at once, in ms (default: 40). The output size size is limited in order to make resample speed changes react faster. This is necessary especially if decoders or filters output very large frame sizes (like some lossless codecs or some DRC filters). This option does not affect the resampling algorithm in any way. For testing/debugging only. Can be removed or changed any time. Set AVOptions on the SwrContext or AVAudioResampleContext. These should be documented by FFmpeg. This is a key/value list option. See List Options for details. Make console output less verbose; in particular, prevents the status line (i.e. AV: 3.4 (00:00:03.37) / 5320.6 ...) from being displayed. Particularly useful on slow terminals or broken ones which do not properly handle carriage return (i.e. ). See also: and . Display even less output and status messages than with . disables any use of the terminal and stdin/stdout/stderr. This completely silences any message output. Unlike , this disables input and terminal initialization as well. Control verbosity directly for each module. The module changes the verbosity of all the modules. The verbosity changes from this option are applied in order from left to right, and each item can override a previous one. Run mpv with to see all messages mpv outputs. You can use the module names printed in the output (prefixed to each line in ) to limit the output to interesting modules. This also affects , and in certain cases libmpv API logging. Some messages are printed before the command line is parsed and are therefore not affected by . To control these messages, you have to use the environment variable; see ENVIRONMENT VARIABLES for details. Completely silences the output of ao_sndio, which uses the log prefix . Only show warnings or worse, and let the ao_alsa output show errors only. Control whether OSD messages are shown on the console when no video output is available (default: auto). use terminal OSD if no video output active use terminal OSD even if video output active The mode also enables terminal OSD if was set. Enable printing a progress bar under the status line on the terminal. (Disabled by default.) Customize the feature. The string is expected to consist of 5 characters (start, left space, position indicator, right space, end). You can use Unicode characters, but note that double- width characters will not be treated correctly. Print out a string after starting playback. The string is expanded for properties, e.g. will print the string followed by a space and the currently played filename. Print out a custom string during playback instead of the standard status line. Expands properties. See Property Expansion. Set the terminal title. Currently, this simply concatenates the escape sequence setting the window title with the provided (property expanded) string. This will mess up if the expanded string contain bytes that end the escape sequence, or if the terminal does not understand the sequence. The latter probably includes the regrettable win32. Prepend module name to each console message. Prepend timing information to each console message. The time is in seconds since the player process was started (technically, slightly later actually), using a monotonic time source depending on the OS. This is on sane UNIX variants. Decide whether to use network cache settings (default: auto). If enabled, use up to for the cache size (but still limited to ), and make the cached data seekable (if possible). If disabled, and related are implicitly disabled. The choice enables this depending on whether the stream is thought to involve network accesses or other slow media (this is an imperfect heuristic). Before mpv 0.30.0, this used to accept a number, which specified the size of the cache in kilobytes. Use e.g. instead. How many seconds of audio/video to prefetch if the cache is active. This overrides the option if and only if the cache is enabled and the value is larger. The default value is set to something very high, so the actually achieved readahead will usually be limited by the value of the option. Setting this option is usually only useful for limiting readahead. Write packet data to a temporary file, instead of keeping them in memory. This makes sense only with . If the normal cache is disabled, this option is ignored. The cache file is append-only. Even if the player appears to prune data, the file space freed by it is not reused. The cache file is deleted when playback is closed. Note that packet metadata is still kept in memory. and related options are applied to metadata only. The size of this metadata varies, but 50 MB per hour of media is typical. The cache statistics will report this metadats size, instead of the size of the cache file. If the metadata hits the size limits, the metadata is pruned (but not the cache file). When the media is closed, the cache file is deleted. A cache file is generally worthless after the media is closed, and it's hard to retrieve any media data from it (it's not supported by design). If the option is enabled at runtime, the cache file is created, but old data will remain in the memory cache. If the option is disabled at runtime, old data remains in the disk cache, and the cache file is not closed until the media is closed. If the option is disabled and enabled again, it will continue to use the cache file that was opened first. Directory where to create temporary files. Cache is stored in the system's cache directory (usually ) if this is unset. Currently, this is used for only. Whether the player should automatically pause when the cache runs out of data and stalls decoding/playback (default: yes). If enabled, it will pause and unpause once more data is available, aka \"buffering\". Number of seconds the packet cache should have buffered before starting playback again if \"buffering\" was entered (default: 1). This can be used to control how long the player rebuffers if is enabled, and the demuxer underruns. If the given time is higher than the maximum set with or , or prefetching ends before that for some other reason (like file end or maximum configured cache size reached), playback resumes earlier. Enter \"buffering\" mode before starting playback (default: no). This can be used to ensure playback starts smoothly, in exchange for waiting some time to prefetch network data (as controlled by ). For example, some common behavior is that playback starts, but network caches immediately underrun when trying to decode more data as playback progresses. Another thing that can happen is that the network prefetching is so CPU demanding (due to demuxing in the background) that playback drops frames at first. In these cases, it helps enabling this option, and setting and to roughly the same value. This option also triggers when playback is restarted after seeking. Whether or when to unlink cache files (default: immediate). This affects cache files which are inherently temporary, and which make no sense to remain on disk after the player terminates. This is a debugging option. Unlink cache file after they were created. The cache files won't be visible anymore, even though they're in use. This ensures they are guaranteed to be removed from disk when the player terminates, even if it crashes. Delete cache files after they are closed. Don't delete cache files. They will consume disk space without having a use. Currently, this is used for only. Size of the low level stream byte buffer (default: 128KB). This is used as buffer between demuxer and low level I/O (e.g. sockets). Generally, this can be very small, and the main purpose is similar to the internal buffer FILE in the C standard library will have. Half of the buffer is always used for guaranteed seek back, which is important for unseekable input. There are known cases where this can help performance to set a large buffer:\n• mp4 files. libavformat may trigger many small seeks in both directions, depending on how the file was muxed.\n• Certain network filesystems, which do not have a cache, and where small reads can be inefficient. In other cases, setting this to a large value can reduce performance. Usually, read accesses are at half the buffer size, but it may happen that accesses are done alternating with smaller and larger sizes (this is due to the internal ring buffer wrap-around). See for defaults and value range. options accept suffixes such as and . Enable running the video/audio decoder on a separate thread (default: no). If enabled, the decoder is run on a separate thread, and a frame queue is put between decoder and higher level playback logic. The size of the frame queue is defined by the other options below. This is probably quite pointless. libavcodec already has multithreaded decoding (enabled by default), which makes this largely unnecessary. It might help in some corner cases with high bandwidth video that is slow to decode (in these cases libavcodec would block the playback logic, while using a decoding thread would distribute the decoding time evenly without affecting the playback logic). In other situations, it will simply make seeking slower and use significantly more memory. The queue size is restricted by the other options. The final queue size is the minimum as indicated by the option with the lowest limit. Each decoder/track has its own queue that may use the full configured queue size. Most queue options can be changed at runtime. itself (and the audio equivalent) update only if decoding is completely reinitialized. However, setting should almost lead to the same behavior as , so that value can be used for effectively runtime enabling/disabling the queue. This should not be used with hardware decoding. It is possible to enable this for audio, but it makes even less sense. Maximum approximate allowed size of the queue. If exceeded, decoding will be stopped. The maximum size can be exceeded by about 1 frame. See for defaults and value range. options accept suffixes such as and . Maximum number of frames (video) or samples (audio) of the queue. The audio size may be exceeded by about 1 frame. See for defaults and value range. Maximum number of seconds of media in the queue. The special value 0 means no limit is set. The queue size may be exceeded by about 2 frames. Timestamp resets may lead to random queue size usage. See for defaults and value range. Use as user agent for HTTP streaming. Read HTTP cookies from <filename>. The file is assumed to be in Netscape format. This is a string list option. See List Options for details. URL of the HTTP/HTTPS proxy. If this is set, the environment is ignored. The environment variable is still respected. This option is silently ignored if it does not start with . Proxies are not used for https URLs. Setting this option does not try to make the ytdl script use the proxy. Certificate authority database file for use with TLS. (Silently fails with older FFmpeg versions.) Verify peer certificates when using TLS (e.g. with ). (Silently fails with older FFmpeg versions.) A file containing a certificate to use in the handshake with the peer. A file containing the private key for the certificate. Specify a referrer path or URL for HTTP requests. Specify the network timeout in seconds (default: 60 seconds). This affects at least HTTP. The special value 0 uses the FFmpeg defaults. If a protocol is used which does not support timeouts, this option is silently ignored. This breaks the RTSP protocol, because of inconsistent FFmpeg API regarding its internal timeout option. Not only does the RTSP timeout option accept different units (seconds instead of microseconds, causing mpv to pass it huge values), it will also overflow FFmpeg internal calculations. The worst is that merely setting the option will put RTSP into listening mode, which breaks any client uses. At time of this writing, the fix was not made effective yet. For this reason, this option is ignored (or should be ignored) on RTSP URLs. You can still set the timeout option directly with . Select RTSP transport method (default: tcp). This selects the underlying network transport when playing URLs. The value leaves the decision to libavformat. If HLS streams are played, this option controls what streams are selected by default. The option allows the following parameters: Don't do anything special. Typically, this will simply pick the first audio/video streams it can find. Pick the streams with the lowest bitrate. Additionally, if the option is a number, the stream with the highest rate equal or below the option value is selected. The bitrate as used is sent by the server, and there's no guarantee it's actually meaningful. This defines the program to tune to. Usually, you may specify this by using a stream URI like , but you can tune to a different channel by writing to this property at runtime. Also see for more useful channel switching functionality. Instructs mpv to read the channels list from . The default is in the mpv configuration directory (usually ) with the filename (based on your card type) or as a last resort. Please note that using specific file name with card type is recommended, since the legacy channel format is not fully standardized so autodetection of the delivery system may fail otherwise. For DVB-S/2 cards, a VDR 1.7.x format channel list is recommended as it allows tuning to DVB-S2 channels, enabling subtitles and decoding the PMT (which largely improves the demuxing). Classic mplayer format channel lists are still supported (without these improvements), and for other card types, only limited VDR format channel list support is implemented (patches welcome). For channels with dynamic PID switching or incomplete , or the magic PID are recommended. Maximum number of seconds to wait when trying to tune a frequency before giving up (default: 30). Apply no filters on program PIDs, only tune to frequency and pass full transponder to demuxer. The player frontend selects the streams from the full TS in this case, so the program which is shown initially may not match the chosen channel. Switching between the programs is possible by cycling the property. This is useful to record multiple programs on a single transponder, or to work around issues in the . It is also recommended to use this for channels which switch PIDs on-the-fly, e.g. for regional news. This value is not meant for setting via configuration, but used in channel switching. An can this value and to perform channel switching. This number effectively gives the offset to the initially tuned to channel in the channel list. An example could contain: , The following video options are currently all specific to , and , which are the only VOs that implement them. The filter function to use when upscaling video. Bilinear hardware texture filtering (fastest, very low quality). This is the default when using the profile. Lanczos scaling. Provides good balance between quality and performance. This is the default for . The number of taps can be controlled with , but is best left unchanged. Elliptic weighted average Lanczos scaling. Also known as Jinc. Relatively slow, but very good quality. The radius can be controlled with . Increasing the radius makes the filter sharper but adds more ringing. A slightly sharpened version of . This is the default when using the profile. Very sharp scaler, but also slightly slower than . Prone to ringing, so it's recommended to combine this with an anti-ringing shader. On , setting this filter enables built-in anti-ringing, so no extra action needs to be taken. Mitchell-Netravali. Piecewise cubic filter with a support of radius 2.0. Provides a balanced compromise of all scaling artifacts. This filter has both and set to . The and parameters can be controlled with and . Hermite spline. Similar to but with set to . This filter has the special property of having a support of radius 1.0, making it very fast in comparison, but prone to blocking. This is the default for . Catmull-Rom spline. Similar to , but with and set to and respectively. This filter is sharper than , but prone to ringing. A version of nearest neighbour that (naively) oversamples pixels, so that pixels overlapping edges get linearly interpolated instead of rounded. This essentially removes the small imperfections and judder artifacts caused by nearest-neighbour interpolation, in exchange for adding some blur. This can also be used for frame mixing, where it is commonly known as \"smoothmotion\" (see ). There are some more filters, but most are not as useful. For a complete list, pass as value, e.g.: As , but for interpolating chroma information. If the image is not subsampled, this option is ignored entirely. If this option is unset, the filter implied by will be applied. Like , but apply these filters on downscaling instead. The filter used for interpolating the temporal axis (frames). This is only used if is enabled. The only valid choices for are separable convolution filters (use to get a list). The default is . Common choices include , , , , , or . These are listed in increasing order of smoothness/blurriness, with being the smoothest/blurriest and being the sharpest/least smooth. Set filter parameters. By default, these are set to the special string , which maps to a scaler-specific default value. Ignored if the filter is not tunable. Currently, this affects the following filter parameters: Spline parameters ( and ). Defaults to B=1 and C=0. Scale parameter ( ). Increasing this makes the result blurrier. Defaults to 1. Minimum distance to an edge before interpolation is used. Setting this to 0 will always interpolate edges, whereas setting it to 0.5 will never interpolate, thus behaving as if the regular nearest neighbour algorithm was used. Defaults to 0.0. Kernel scaling factor (also known as a blur factor). Decreasing this makes the result sharper, increasing it makes it blurrier (default 0). If set to 0, the kernel's preferred blur factor is used. Note that setting this too low (eg. 0.5) leads to bad results. It's generally recommended to stick to values between 0.8 and 1.2. Specifies a weight bias to multiply into negative coefficients. Specifying has the effect of removing negative weights completely, thus effectively clamping the value range to [0-1]. Values between 0.0 and 1.0 can be specified to apply only a moderate diminishment of negative weights. This is especially useful for , where it reduces excessive ringing artifacts in the temporal domain (which typically manifest themselves as short flashes or fringes of black, mostly around moving edges) in exchange for potentially adding more blur. The default for is 1.0, the others default to 0.0. Kernel/window taper factor. Increasing this flattens the filter function. Value range is 0 to 1. A value of 0 (the default) means no flattening, a value of 1 makes the filter completely flat (equivalent to a box function). Values in between mean that some portion will be flat and the actual filter function will be squeezed into the space in between. Set radius for tunable filters, must be a float number between 0.5 and 16.0. Defaults to the filter's preferred radius if not specified. Doesn't work for every scaler and VO combination. Note that depending on filter implementation details and video scaling ratio, the radius that actually being used might be different (most likely being increased a bit). Set the antiringing strength. This tries to eliminate ringing, but can introduce other artifacts in the process. Must be a float number between 0.0 and 1.0. The default value of 0.0 disables antiringing entirely. Note that this doesn't affect the special filters and , nor does it affect any polar (EWA) scalers. (Advanced users only) Choose a custom windowing function for the kernel. Defaults to the filter's preferred window if unset. Use to get a list of supported windowing functions. (Advanced users only) Configure the parameter for the window function given by etc. By default, these are set to the special string , which maps to a window-specific default value. Ignored if the window is not tunable. Currently, this affects the following window parameters: Scale parameter (t). Increasing this makes the window wider. Defaults to 1. Disable the scaler if the video image is not resized. In that case, is used instead of whatever is set with . Bilinear will reproduce the source image perfectly if no scaling is performed. Enabled by default. Note that this option never affects . When using convolution based filters, extend the filter size when downscaling. Increases quality, but reduces performance while downscaling. Enabled by default. This will perform slightly sub-optimally for anamorphic video (but still better than without it) since it will extend the size to match only the milder of the scale factors between the axes. Note: this option is ignored when using bilinear downscaling with . Scale in linear light when downscaling. It should only be used with a that has at least 16 bit precision. This option has no effect on HDR content. Enabled by default. Scale in linear light when upscaling. Like , it should only be used with a that has at least 16 bits precisions. This is not usually recommended except for testing/specific purposes. Users are advised to either enable or keep both options disabled (i.e. scaling in gamma light). When upscaling, use a sigmoidal color transform to avoid emphasizing ringing artifacts. Enabled by default. This is incompatible with and replaces . (Note that sigmoidization also requires linearization, so the rendering step fires in both cases) The center of the sigmoid curve used for , must be a float between 0.0 and 1.0. Defaults to 0.75 if not specified. The slope of the sigmoid curve used for , must be a float between 1.0 and 20.0. Defaults to 6.5 if not specified. Reduce stuttering caused by mismatches in the video fps and display refresh rate (also known as judder). This requires setting the option to one of the modes, or it will be silently disabled. This was not required before mpv 0.14.0. This essentially attempts to interpolate the missing frames by convoluting the video along the temporal axis. The filter used can be controlled using the setting. Threshold below which frame ratio interpolation gets disabled (default: ). This is calculated as , where is the speed-adjusted video FPS, and the display refresh rate. (The speed-adjusted video FPS is roughly equal to the normal video FPS, but with slowdown and speedup applied. This matters if you use to make video run synchronously to the display FPS, or if you change the property.) The default is intended to enable interpolation in scenarios where retiming with the cannot adjust the speed of the video sufficiently for smooth playback. For example if a video is 60.00 FPS and your display refresh rate is 59.94 Hz, interpolation will never be activated, since the mismatch is within 1% of the refresh rate. The default also handles the scenario when mpv cannot determine the container FPS, such as during certain live streams, and may dynamically toggle interpolation on and off. In this scenario, the default would be to not use interpolation but rather to allow to retime the video to match display refresh rate. See for more information about how mpv will retime video. Also note that if you use e.g. , small deviations in the rate can disable interpolation and introduce a discontinuity every other minute. Set this to to disable this logic. Preserve the previous frames' interpolated results even when renderer parameters are changed - with the exception of options related to cropping and video placement, which always invalidate the cache. Enabling this option makes dynamic updates of renderer settings slightly smoother at the cost of slightly higher latency in response to such changes. Defaults to on. (Only affects , note that always invalidates interpolated frames) Enable use of PBOs. On some drivers this can be faster, especially if the source video size is huge (e.g. so called \"4K\" video). On other drivers it might be slower or cause latency issues. Disable any dithering done by mpv. Automatic selection. On : detected depth or 8 bpc otherwise On : detected depth or 8 bpc (for SDR target) Note that the on-the-wire bit depth cannot be detected except when using . Explicitly setting the value to your display's bit depth is recommended, as dithering performed by some LCD panels can be of low quality. Set the size of the dither matrix (default: 6). The actual size of the matrix is for an option value of , so a value of 6 gives a size of 64x64. The matrix is generated at startup time, and a large matrix can take rather long to compute (seconds). Used in mode only. Select dithering algorithm (default: fruit). (Normally, the option controls whether dithering is enabled.) The option requires compute shader support. It also requires large amount of shared memory to run, the size of which depends on both the kernel (see option below) and the height of video window. It will fallback to dithering if there is no enough shared memory to run the shader. Enable temporal dithering. (Only active if dithering is enabled in general.) This changes between 8 different dithering patterns on each frame by changing the orientation of the tiled dithering matrix. Unfortunately, this can lead to flicker on LCD displays, since these have a high reaction time. Determines how often the dithering pattern is updated when is in use. 1 (the default) will update on every video frame, 2 on every other frame, etc. The error diffusion kernel to use when is set. Propagate error to only two adjacent pixels. Fastest but low quality. Fast with reasonable quality. This is the default. Looks different from other kernels because only fraction of errors will be propagated during dithering. A typical use case of this kernel is saving dithered screenshot (in window mode). This kernel produces slightly smaller file, with still reasonable dithering quality. There are other kernels (use to list) but most of them are much slower and demanding even larger amount of shared memory. Among these kernels, achieves a good balance between performance and quality, and probably is the one you want to try first. Enables GPU debugging. What this means depends on the API type. For OpenGL, it calls , and requests a debug context. For Vulkan, it enables validation layers. Interval in displayed frames between two buffer swaps. 1 is equivalent to enable VSYNC, 0 to disable VSYNC. Defaults to 1 if not specified. Note that this depends on proper OpenGL vsync support. On some platforms and drivers, this only works reliably when in fullscreen mode. It may also require driver-specific hacks if using multiple monitors, to ensure mpv syncs to the right one. Compositing window managers can also lead to bad results, as can missing or incorrect display FPS information (see ). (EGL only) Select EGLConfig with specific EGL_CONFIG_ID. Rendering surfaces and contexts will be created using this EGLConfig. You can use to obtain a list of available configs. (EGL only) Select a specific EGL output format to utilize for OpenGL rendering. This option is mutually exclusive with . \"auto\" is the default, which will pick the first usable config based on the order given by the driver. All formats are not available. A fatal error is caused if an unavailable format is selected. There is no reliable API to query desktop bit depth in EGL. You can manually set this option according to the bit depth of your display. This option also affects the auto-detection of . Unlike , this option also takes effect with . The name or UUID of the Vulkan device to use for rendering and presentation. Use to see the list of available devices and their names and UUIDs. If left unspecified, the first enumerated hardware Vulkan device will be used. Controls the presentation mode of the vulkan swapchain. This is similar to the option. Use the preferred swapchain mode for the vulkan context. (Default) Tearing, vsync blocked. Late frames will tear instead of stuttering. Tearing, not vsync blocked. Similar to \"VSync off\". Controls the number of VkQueues used for rendering (limited by how many your device supports). In theory, using more queues could enable some parallelism between frames (when using a higher than 1), but it can also slow things down on hardware where there's no true parallelism between queues. (Default: 1) Enables the use of async transfer queues on supported vulkan devices. Using them allows transfer operations like texture uploads and blits to happen concurrently with the actual rendering, thus improving overall throughput and power consumption. Enabled by default, and should be relatively safe. Enables the use of async compute queues on supported vulkan devices. Using this, in theory, allows out-of-order scheduling of compute shaders with graphics shaders, thus enabling the hardware to do more effective work while waiting for pipeline bubbles and memory operations. Not beneficial on all GPUs. It's worth noting that if async compute is enabled, and the device supports more compute queues than graphics queues (bound by the restrictions set by ), mpv will internally try and prefer the use of compute shaders over fragment shaders wherever possible. Enabled by default, although Nvidia users may want to disable it. The index of the display, on the selected Vulkan device, to present on when using the GPU context. Use to see the list of available displays. If left unspecified, the first enumerated display will be used. The index of the display mode, of the selected Vulkan display, to use when using the GPU context. Use to see the list of available modes. If left unspecified, the first enumerated mode will be used. The index of the plane, on the selected Vulkan device, to present on when using the GPU context. Use to see the list of available planes. If left unspecified, the first enumerated plane will be used. Switches the D3D11 swap chain fullscreen state to 'fullscreen' when fullscreen video is requested. Also known as \"exclusive fullscreen\" or \"D3D fullscreen\" in other applications. Gives mpv full control of rendering on the swap chain's screen. Off by default. Use WARP (Windows Advanced Rasterization Platform) with the D3D11 GPU backend (default: auto). This is a high performance software renderer. By default, it is only used when the system has no hardware adapters that support D3D11. While the extended GPU features will work with WARP, they can be very slow. Select a specific feature level when using the D3D11 GPU backend. By default, the highest available feature level is used. This option can be used to select a lower feature level, which is mainly useful for debugging. Most extended GPU features will not work at 9_x feature levels. Enable flip-model presentation, which avoids unnecessarily copying the backbuffer by sharing surfaces with the DWM (default: yes). This may cause performance issues with older drivers. If flip-model presentation is not supported (for example, on Windows 7 without the platform update), mpv will automatically fall back to the older bitblt presentation model. Schedule each frame to be presented for this number of VBlank intervals. (default: 1) Setting to 1 will enable VSync, setting to 0 will disable it. Select a specific D3D11 adapter to utilize for D3D11 rendering. Will pick the default adapter if unset. Alternatives are listed when the name \"help\" is given. Checks for matches based on the start of the string, case insensitive. Thus, if the description of the adapter starts with the vendor name, that can be utilized as the selection parameter. Hardware decoders utilizing the D3D11 rendering abstraction's helper functionality to receive a device, such as D3D11VA or DXVA2's DXGI mode, will be affected by this choice. Select a specific D3D11 output format to utilize for D3D11 rendering. \"auto\" is the default, which will pick either rgba8 or rgb10_a2 depending on the configured desktop bit depth. rgba16f and bgra8 are left out of the autodetection logic, and are available for manual testing. Desktop bit depth querying is only available from an API available from Windows 10. Thus on older systems it will only automatically utilize the rgba8 output format. For , this is used as a best-effort hint and libplacebo has the last say on which format is utilized. Select a specific D3D11 output color space to utilize for D3D11 rendering. \"auto\" is the default, which will select the color space of the desktop on which the swap chain is located. Values other than \"srgb\" and \"pq\" have had issues in testing, so they are mostly available for manual testing. Swap chain color space configuration is only available from an API available from Windows 10. Thus on older systems it will not work. By default, when using hardware decoding with , the video image will be copied (GPU-to-GPU) from the decoder surface to a shader resource. Set this option to avoid that copy by sampling directly from the decoder image. This may increase performance and reduce power usage, but can cause the image to be sampled incorrectly on the bottom and right edges due to padding, and may invoke driver bugs, since Direct3D 11 technically does not allow sampling from a decoder surface (though most drivers support it.) Currently only relevant for . Controls whether or not mpv opts into the configure bounds event if sent by the compositor (default: auto). This restricts the initial size of the mpv window to a certain maximum size intended by the compositor. In most cases, this simply just prevents the mpv window from being larger than the size of the monitor when it first renders. With the default value of , configure-bounds will silently be ignored if any or type option is also set. If supported by the compositor, mpv will send a hint using the content-type protocol telling the compositor what type of content is being displayed. (default) will automatically switch between telling the compositor the content is a photo, video or possibly none depending on internal heuristics. Disable mpv's internal vsync for Wayland-based video output (default: no). This is mainly useful for benchmarking wayland VOs when combined with , , and . Defines the size of an edge border (default: 16) to initiate client side resize events in the wayland contexts with the mouse. This is only active if there are no server side decorations from the compositor. Defines the size of an edge border (default: 32) to initiate client side resizes events in the wayland contexts with touch events. Enable the use of wayland's presentation time protocol for more accurate frame presentation if it is supported by the compositor (default: ). This only has an effect if is being used. Controls which compiler is used to translate GLSL to SPIR-V. This is only relevant for with . The possible choices are currently: Use the first available compiler. (Default) Use libshaderc, which is an API wrapper around glslang. This is generally the most preferred, if available. This option is deprecated, since there is only one usable value. It may be removed in the future. Custom GLSL hooks. These are a flexible way to add custom fragment shaders, which can be injected at almost arbitrary points in the rendering pipeline, and access all previous intermediate textures. Each use of the option will add another file to the internal list of shaders, while takes a list of files, and overwrites the internal list with it. The latter is a path list option (see List Options for details). The syntax is not stable yet and may change any time. The general syntax of a user shader looks like this: Each section of metadata, along with the non-metadata lines after it, defines a single block. There are currently two types of blocks, HOOKs and TEXTUREs. A block can set the following options: The name of this texture. Hooks can then bind the texture under this name using BIND. This must be the first option of the texture block. The dimensions of the texture. The height and depth are optional. The type of texture (1D, 2D or 3D) depends on the number of components specified. The texture format for the samples. Supported texture formats are listed in debug logging when the VO is initialized (look for ). Usually, this follows OpenGL naming conventions. For example, provides 3 channels with normalized 16 bit components. One oddity are float formats: for example, has 16 bit internal precision, but the texture data is provided as 32 bit floats, and the driver converts the data on texture upload. Although format names follow a common naming convention, not all of them are available on all hardware, drivers, GL versions, and so on. The min/magnification filter used when sampling from this texture. The border wrapping mode used when sampling from this texture. Following the metadata is a string of bytes in hexadecimal notation that define the raw texture data, corresponding to the format specified by , on a single line with no extra whitespace. A block can set the following options: The texture which to hook into. May occur multiple times within a metadata block, up to a predetermined limit. See below for a list of hookable textures. User-friendly description of the pass. This is the name used when representing this shader in the list of passes for property . Loads a texture (either coming from mpv or from a block) and makes it available to the pass. When binding textures from mpv, this will also set up macros to facilitate accessing it properly. See below for a list. By default, no textures are bound. The special name HOOKED can be used to refer to the texture that triggered this pass. Gives the name of the texture to save the result of this pass into. By default, this is set to the special name HOOKED which has the effect of overwriting the hooked texture. Specifies the size of the resulting texture for this pass. refers to an expression in RPN (reverse polish notation), using the operators + - * / > < !, floating point literals, and references to sizes of existing texture (such as MAIN.width or CHROMA.height), OUTPUT, or NATIVE_CROPPED (size of an input texture cropped after pan-and-scan, video-align-x/y, video-pan-x/y, etc. and possibly prescaled). By default, these are set to HOOKED.w and HOOKED.h, espectively. Specifies a condition that needs to be true (non-zero) for the shader stage to be evaluated. If it fails, it will silently be omitted. (Note that a shader stage like this which has a dependency on an optional hook point can still cause that hook point to be saved, which has some minor overhead) Indicates a pixel shift (offset) introduced by this pass. These pixel offsets will be accumulated and corrected during the next scaling pass ( or ). The default values are 0 0 which correspond to no shift. Note that offsets are ignored when not overwriting the hooked texture. A special value of will attempt to fix existing offset of HOOKED by align it with reference. It requires HOOKED to be resizable (see below). It works transparently with fragment shader. For compute shader, the predefined macro is required to handle coordinate mapping. Specifies how many components of this pass's output are relevant and should be stored in the texture, up to 4 (rgba). By default, this value is equal to the number of components in HOOKED. Specifies that this shader should be treated as a compute shader, with the block size bw and bh. The compute shader will be dispatched with however many blocks are necessary to completely tile over the output. Within each block, there will be tw*th threads, forming a single work group. In other words: tw and th specify the work group size, which can be different from the block size. So for example, a compute shader with bw, bh = 32 and tw, th = 8 running on a 500x500 texture would dispatch 16x16 blocks (rounded up), each with 8x8 threads. Compute shaders in mpv are treated a bit different from fragment shaders. Instead of defining a that produces an output sample, you directly define which writes to a fixed writeonly image unit named (this is bound by mpv) using . To help translate texture coordinates in the absence of vertices, mpv provides a special function to map from the texel space of the output image to the texture coordinates for all bound textures. In particular, is equivalent to , although using this only really makes sense if (tw,th) == (bw,bh). Each bound mpv texture (via ) will make available the following definitions to that shader pass, where NAME is the name of the bound texture: The sampling function to use to access the texture at a certain spot (in texture coordinate space, range [0,1]). This takes care of any necessary normalization conversions. Sample the texture at a certain offset in pixels. This works like NAME_tex but additionally takes care of necessary rotations, so that sampling at e.g. vec2(-1,0) is always one pixel to the left. The local texture coordinate of that texture, range [0,1]. The (rotated) size in pixels of the texture. The rotation matrix associated with this texture. (Rotates pixel space to texture coordinates) The coefficient that needs to be multiplied into the texture contents in order to normalize it to the range [0,1]. The raw bound texture itself. The use of this should be avoided unless absolutely necessary. Normally, users should use either NAME_tex or NAME_texOff to read from the texture. For some shaders however , it can be better for performance to do custom sampling from NAME_raw, in which case care needs to be taken to respect NAME_mul and NAME_rot. In addition to these parameters, the following uniforms are also globally available: A random number in the range [0-1], different per frame. A simple count of frames rendered, increases by one per frame and never resets (regardless of seeks). The size in pixels of the input image (possibly cropped and prescaled). The size in pixels of the visible part of the scaled (and possibly cropped) image. Texture offset introduced by user shaders or options like panscan, video-align-x/y, video-pan-x/y. Internally, vo_gpu may generate any number of the following textures. Whenever a texture is rendered and saved by vo_gpu, all of the passes that have hooked into it will run, in the order they were added by the user. This is a list of the legal hook points: Source planes (raw). Which of these fire depends on the image format of the source. Source planes (upscaled). These only fire on subsampled content. The combined image, in the source colorspace, before conversion to RGB. The image, after conversion to RGB, but before is applied. The main image, after conversion to RGB but before upscaling. Linear light image, before scaling. This only fires when , or is in effect. Sigmoidized light, before scaling. This only fires when is in effect. The image immediately before the scaler kernel runs. The image immediately after the scaler kernel runs. The final output image, after color management but before dithering and drawing to screen. Only the textures labelled with may be transformed by the pass. When overwriting a texture marked , the WIDTH, HEIGHT and OFFSET must be left at their default values. Specifies the options to use for tunable shader parameters. You can target specific named shaders by prefixing the shader name with a , e.g. . Without a prefix, parameters affect all shaders. The shader name is the base part of the shader filename, without the extension. ( only) Enable the debanding algorithm. This greatly reduces the amount of visible banding, blocking and other quantization artifacts, at the expense of very slightly blurring some of the finest details. In practice, it's virtually always an improvement - the only reason to disable it would be for performance. The number of debanding steps to perform per sample. Each step reduces a bit more banding, but takes time to compute. Note that the strength of each step falls off very quickly, so high numbers (>4) are practically useless. (Default 1) The debanding filter's cut-off threshold. Higher numbers increase the debanding strength dramatically but progressively diminish image details. (Default 48) The debanding filter's initial radius. The radius increases linearly for each iteration. A higher radius will find more gradients, but a lower radius will smooth more aggressively. (Default 16) If you increase the , you should probably decrease this to compensate. Add some extra noise to the image. This significantly helps cover up remaining quantization artifacts. Higher numbers add more noise. (Default 32) If set to a value above 0.0, the output will be rendered with rounded corners, as if an alpha transparency mask had been applied. The value indicates the relative fraction of the side length to round - a value of 1.0 rounds the corners as much as possible. ( only) If set to a value other than 0, enable an unsharp masking filter. Positive values will sharpen the image (but add more ringing and aliasing). Negative values will blur the image. If your GPU is powerful enough, consider alternatives like the scale filter, or the option. (Only for ) Call before swapping buffers (default: disabled). Slower, but might improve results when doing framedropping. Can completely ruin performance. The details depend entirely on the OpenGL driver. Call after each buffer swap (default: disabled). This may or may not help with video timing accuracy and frame drop. It's possible that this makes video output slower, or has no effect at all. (Windows only) Calls after swapping buffers on Windows (default: auto). It also sets to ignore the OpenGL timing. Values are: no (disabled), windowed (only in windowed mode), yes (also in full screen). The value will try to determine whether the compositor is active, and calls only if it seems to be. This may help to get more consistent frame intervals, especially with high-fps clips - which might also reduce dropped frames. Typically, a value of should be enough, since full screen may bypass the DWM. Selects a specific feature level when using the ANGLE backend with D3D11. By default, the highest available feature level is used. This option can be used to select a lower feature level, which is mainly useful for debugging. Note that OpenGL ES 3.0 is only supported at feature level 10_1 or higher. Most extended OpenGL features will not work at lower feature levels (similar to ). Use WARP (Windows Advanced Rasterization Platform) when using the ANGLE backend with D3D11 (default: auto). This is a high performance software renderer. By default, it is used when the Direct3D hardware does not support Direct3D 11 feature level 9_3. While the extended OpenGL features will work with WARP, they can be very slow. Use ANGLE's built in EGL windowing functions to create a swap chain (default: auto). If this is set to and the D3D11 renderer is in use, ANGLE's built in swap chain will not be used and a custom swap chain that is optimized for video rendering will be created instead. If set to , a custom swap chain will be used for D3D11 and the built in swap chain will be used for D3D9. This option is mainly for debugging purposes, in case the custom swap chain has poor performance or does not work. If set to , the option will have no effect. Enable flip-model presentation, which avoids unnecessarily copying the backbuffer by sharing surfaces with the DWM (default: yes). This may cause performance issues with older drivers. If flip-model presentation is not supported (for example, on Windows 7 without the platform update), mpv will automatically fall back to the older bitblt presentation model. If set to , the option will have no effect. Forces a specific renderer when using the ANGLE backend (default: auto). In auto mode this will pick D3D11 for systems that support Direct3D 11 feature level 9_3 or higher, and D3D9 otherwise. This option is mainly for debugging purposes. Normally there is no reason to force a specific renderer, though may give slightly better performance on old hardware. Note that the D3D9 renderer only supports OpenGL ES 2.0, so most extended OpenGL features will not work if this renderer is selected (similar to ). Deactivates the automatic graphics switching and forces the dedicated GPU. (default: no) Use the Apple Software Renderer when using cocoa-cb (default: auto). If set to the software renderer is never used and instead fails when a the usual pixel format could not be created, will always only use the software renderer, and only falls back to the software renderer when the usual pixel format couldn't be created. Creates a 10bit capable pixel format for the context creation (default: yes). Instead of 8bit integer framebuffer a 16bit half-float framebuffer is requested. This sets the color space of the layer to activate the macOS color transformation. Depending on the color space used the system's EDR (HDR) support will be activated. To get correct results, this needs to be set to the color primaries/transfer characteristics of the VO target. It is recommended to use this switch together with and . can be one of the following: Sets the color space to the icc profile of the screen (default). Same as sRGB but linear transfer function. Sets the appearance of the title bar (default: auto). Not all combinations of appearances and materials make sense or are unique. Appearances that are not supported by you current macOS version fall back to the default value. macOS only can be one of the following: Detects the system settings and sets the title bar appearance appropriately. On macOS 10.14 it also detects run time changes. Sets the material of the title bar (default: titlebar). All deprecated materials should not be used on macOS 10.14+ because their functionality is not guaranteed. Not all combinations of materials and appearances make sense or are unique. Materials that are not supported by you current macOS version fall back to the default value. macOS only can be one of the following: The standard macOS under page background material. (deprecated in macOS 10.14+) Sets the color of the title bar (default: completely transparent). Is influenced by and . See for color syntax. Sets the fullscreen resize animation duration in ms (default: default). The default value is slightly less than the system's animation duration (500ms) to prevent some problems when the end of an async animation happens at the same time as the end of the system wide fullscreen animation. Setting anything higher than 500ms will only prematurely cancel the resize animation after the system wide animation ended. The upper limit is still set at 1000ms since it's possible that Apple or the user changes the system defaults. Anything higher than 1000ms though seems too long and shouldn't be set anyway. (macOS) Changes the App activation policy. With accessory the mpv icon in the Dock can be hidden. (default: regular) This changes the rectangle which is used to calculate the screen position and size of the window (default: visible). takes the the menu bar and Dock into account and the window is only positioned/sized within the visible screen frame rectangle, takes the whole screen frame rectangle and ignores the menu bar and Dock. Other previous restrictions still apply, like the window can't be placed on top of the menu bar etc. Sets the mode (default: callback) for syncing the rendering of frames to the display's vertical refresh rate. macOS and Vulkan (macvk) only. can be one of the following: Syncs to the time of the next vertical display refresh reported by the CVDisplayLink callback provided information No manual syncing, depend on the layer mechanic and the next drawable Same as precise but uses the presentation feedback core mechanism Enables the default menu bar shortcuts (default: yes). The menu bar shortcuts always take precedence over any other shortcuts, they are not propagated to the mpv core and they can't be used in config files like or script bindings. Set dimensions of the rendering surface used by the Android gpu context. Needs to be set by the embedding application if the dimensions change during runtime (i.e. if the device is rotated), via the surfaceChanged callback. Continue even if a software renderer is detected. Specify a priority list of the GPU contexts to be used. The value (the default) selects the GPU context with the default autoprobe order. You can also pass to get a complete list of compiled in backends (sorted by the default autoprobe order). Note that the default GPU context is subject to change, and must not be relied upon. If a certain GPU context needs to be used, it must be explicitly specified. auto-select (default). Note that this context must be used alone and does not participate in the priority list. Direct3D11 through the OpenGL ES translation layer ANGLE. This supports almost everything the backend does (if the ANGLE build is new enough). Win32, using WGL for rendering and Direct3D 9Ex for presentation. Works on Nvidia and AMD. Newer Intel chips with the latest drivers may also work. VK_KHR_display. This backend is roughly the Vulkan equivalent of DRM/EGL, allowing for direct rendering via Vulkan without a display manager. Android/EGL. Requires be set to an . Vulkan on macOS with a metal surface through a translation layer (experimental) Use any available API (default). Note that the default GPU API used for this value is subject to change, and must not be relied upon. If a certain GPU API needs to be used, it must be explicitly specified. Allow only OpenGL (requires OpenGL 2.1+ or GLES 2.0+) Controls which type of OpenGL context will be accepted: Allow all types of OpenGL (default) Selects the internal format of textures used for FBOs. The format can influence performance and quality of the video output. can be one of: rgb8, rgb10, rgb10_a2, rgb16, rgb16f, rgb32f, rgba12, rgba16, rgba16f, rgba16hf, rgba32f. Default: , which first attempts to utilize 16bit float (rgba16f, rgba16hf), and falls back to rgba16 if those are not available. Finally, attempts to utilize rgb10_a2 or rgba8 if all of the previous formats are not available. Set an additional raw gamma factor (default: 1.0). If gamma is adjusted in other ways (like with the option or key bindings and the property), the value is multiplied with the other gamma value. This option is deprecated and may be removed in the future. Automatically corrects the gamma value depending on ambient lighting conditions (adding a gamma boost for bright rooms). This option is deprecated and may be removed in the future. Specifies a custom LUT file (in Adobe .cube format) to apply to the colors during image decoding. The exact interpretation of the LUT depends on the value of . (Only for ) Controls the interpretation of color values fed to and from the LUT specified as . Valid values are: Chooses the interpretation of the LUT automatically from tagged metadata, and otherwise falls back to . (Default) Applied to the raw image contents in its native colorspace, before decoding to RGB. For example, for a HDR10 image, this would be fed PQ-encoded YCbCr values in the range 0.0 - 1.0. Applied to the normalized RGB image contents, after decoding from its native color encoding, but before linearization. Fully replaces the color decoding. A LUT of this type should ingest the image's native colorspace and output normalized non-linear RGB. Automatically configure the output colorspace of the display to pass through the input values of the stream (e.g. for HDR passthrough), if possible. Requires a supporting driver and . Specifies the primaries of the display. Video colors will be adapted to this colorspace when ICC color management is not being used. Valid values are: Disable any adaptation, except for atypical color spaces. Specifically, wide/unusual gamuts get automatically adapted to BT.709, while standard gamut (i.e. BT.601 and BT.709) content is not touched. (default) CIE 1931 RGB (not to be confused with CIE XYZ) Specifies the transfer characteristics (gamma) of the display. Video colors will be adjusted to this curve when ICC color management is not being used. Valid values are: Disable any adaptation, except for atypical transfers. Specifically, HDR or linear light source material gets automatically converted to gamma 2.2, while SDR content is not touched. (default) Pure power curve (gamma 1.8), also used for Apple RGB Pure power curve (gamma 2.8), also used for BT.470-BG When using HDR output formats, mpv will encode to the specified curve but it will not set any HDMI flags or other signalling that might be required for the target device to correctly display the HDR signal. The user should independently guarantee this before using these signal formats for display. Specifies the measured peak brightness of the output display, in cd/m^2 (AKA nits). The interpretation of this brightness depends on the configured . In all cases, it imposes a limit on the signal values that will be sent to the display. If the source exceeds this brightness level, a tone mapping filter will be inserted. For HLG, it has the additional effect of parametrizing the inverse OOTF, in order to get colorimetrically consistent results with the mastering display. For SDR, or when using an ICC (profile ( ), setting this to a value above 203 essentially causes the display to be treated as if it were an HDR display in disguise. (See the note below) In mode (the default), the chosen peak is an appropriate value based on the TRC in use. For SDR curves, it uses 203. For HDR curves, it uses 203 * the transfer function's nominal peak. When using an SDR transfer function, this is normally not needed, and setting it may lead to very unexpected results. The one time it is useful is if you want to calibrate a HDR display using traditional transfer functions and calibration equipment. In such cases, you can set your HDR display to a high brightness such as 800 cd/m^2, and then calibrate it to a standard curve like gamma2.8. Setting this value to 800 would then instruct mpv to essentially treat it as an HDR display with the given peak. This may be a good alternative in environments where PQ or HLG input to the display is not possible, and makes it possible to use HDR displays with mpv regardless of operating system support for HDMI HDR metadata. In such a configuration, we highly recommend setting to or even . Specifies the measured contrast of the output display. in conjunction with value is used to calculate display black point. Used in black point compensation during HDR tone-mapping. is the default and assumes 1000:1 contrast as a typical SDR display would have or an infinite contrast when HDR is used. contrast specifies display with perfect black level, in practice OLED. (Only for ) Constrains the gamut of the display. You can use this option to output e.g. DCIP3-in-BT.2020. Set to the primaries of the containing colorspace (into which values will be encoded), and to the gamut you want to limit colors to. Takes the same values as . (Only for ) Specifies a custom LUT file (in Adobe .cube format) to apply to the colors before display on-screen. This LUT is fed values in normalized RGB, after encoding into the target colorspace, so after the application of . (Only for ) Specifies the algorithm used for tone-mapping images onto the target display. This is relevant for both HDR->SDR conversion as well as gamut reduction (e.g. playing back BT.2020 content on a standard gamut display). Valid values are: Choose the best curve according to internal heuristics. (Default) Hard-clip any out-of-range values. Use this when you care about perfect color accuracy for in-range values at the cost of completely distorting out-of-range values. Not generally recommended. Generalization of Reinhard to a Möbius transform with linear section. Smoothly maps out-of-range values while retaining contrast and colors for in-range material as much as possible. Use this when you care about color accuracy more than detail preservation. This is somewhere in between and , depending on the value of . Reinhard tone mapping algorithm. Very simple continuous curve. Preserves overall image brightness but uses nonlinear contrast, which results in flattening of details and degradation in color accuracy. Similar to but preserves both dark and bright details better (slightly sigmoidal), at the cost of slightly darkening / desaturating everything. Developed by John Hable for use in video games. Use this when you care about detail preservation more than color/brightness accuracy. This is roughly equivalent to . If possible, you should also enable for the best results. Linearly stretches the entire reference gamut to (a linear multiple of) the display. HDR<->SDR mapping specified in ITU-R Report BT.2446, method A. This is the recommended curve for well-mastered content. ( only) Dynamic HDR10+ tone-mapping method specified in SMPTE ST2094-40 Annex B. In the absence of metadata, falls back to a fixed spline matched to the input/output average brightness characteristics. ( only) Dynamic tone-mapping method specified in SMPTE ST2094-10 Annex B.2. Conceptually simpler than ST2094-40, and generally produces worse results. Set tone mapping parameters. By default, this is set to the special string , which maps to an algorithm-specific default value. Ignored if the tone mapping algorithm is not tunable. This affects the following tone mapping algorithms: Specifies an extra linear coefficient to multiply into the signal before clipping. Defaults to 1.0. Specifies the transition point from linear to mobius transform. Every value below this point is guaranteed to be mapped 1:1. The higher the value, the more accurate the result will be, at the cost of losing bright details. Defaults to 0.3, which due to the steep initial slope still preserves in-range colors fairly accurately. Specifies the local contrast coefficient at the display peak. Defaults to 0.5, which means that in-gamut values will be about half as bright as when clipping. Specifies the offset for the knee point. Defaults to 1.0, which is higher than the value from the original ITU-R specification (0.5). ( only) Specifies the exponent of the function. Defaults to 1.8. Specifies the scale factor to use while stretching. Defaults to 1.0. Specifies the knee point (in PQ space). Defaults to 0.30. Specifies the contrast (slope) at the knee point. Defaults to 1.0. If set, allows inverse tone mapping (expanding SDR to HDR). Not supported by all tone mapping curves. Use with caution. ( only) Upper limit for how much the tone mapping algorithm is allowed to boost the average brightness by over-exposing the image. The default value of 1.0 allows no additional brightness boost. A value of 2.0 would allow over-exposing by a factor of 2, and so on. Raising this setting can help reveal details that would otherwise be hidden in dark scenes, but raising it too high will make dark scenes appear unnaturally bright. ( only) Display a (PQ-PQ) graph of the active tone-mapping LUT. Intended only for debugging purposes. The X axis shows PQ input values, the Y axis shows PQ output values. The tone-mapping curve is shown in green/yellow. Yellow means the brightness has been boosted from the source, dark blue regions show where the brightness has been reduced. The extra colored regions and lines indicate various monitor limits, as well a reference diagonal (neutral tone-mapping) and source scene average brightness information (if available). ( only) Specifies the algorithm used for reducing the gamut of images for the target display, after any tone mapping is done. Hard-clip to the gamut (per-channel). Very low quality, but free. Performs a perceptually balanced gamut mapping using a soft knee function to roll-off clipped regions, and a hue shifting function to preserve saturation. ( only) Performs relative colorimetric clipping, while maintaining an exponential relationship between brightness and chromaticity. ( only) Performs simple RGB->RGB saturation mapping. The input R/G/B channels are mapped directly onto the output R/G/B channels. Will never clip, but will distort all hues and/or result in a faded look. ( only) Performs absolute colorimetric clipping. Like , but does not adapt the white point. ( only) Uniformly darkens the input slightly to prevent clipping on blown-out highlights, then clamps colorimetrically to the input gamut boundary, biased slightly to preserve chromaticity over luminance. ( only) Linearly/uniformly desaturates the image in order to bring the entire image into the target gamut. ( only) Compute the HDR peak and frame average brightness per-frame instead of relying on tagged metadata. These values are averaged over local regions as well as over several frames to prevent the value from jittering around too much. This option basically gives you dynamic, per-scene tone mapping. Requires compute shaders, which is a fairly recent OpenGL feature, and will probably also perform horribly on some drivers, so enable at your own risk. The special value (default) will enable HDR peak computation automatically if compute shaders and SSBOs are supported. When using , allow delaying the detected peak by a frame when beneficial for performance. In particular, this is required to avoid an unnecessary FBO indirection when no advanced rendering is required otherwise. Has no effect if there already is an indirect pass, such as when advanced scaling is enabled. Defaults to no. (Only affects , note that always delays the peak.) Which percentile of the input image brightness histogram to consider as the true peak of the scene. If this is set to 100 (default), the brightest pixel is measured. Otherwise, the top of the frequency distribution is progressively cut off. Setting this too low will cause clipping of very bright details, but can improve the dynamic brightness range of scenes with very bright isolated highlights. Values other than 100 come with a small performance penalty. (Only for ) The decay rate used for the HDR peak detection algorithm (default: 20.0). This is only relevant when is enabled. Higher values make the peak decay more slowly, leading to more stable values at the cost of more \"eye adaptation\"-like effects (although this is mitigated somewhat by ). A value of 0.0 (the lowest possible) disables all averaging, meaning each frame's value is used directly as measured, but doing this is not recommended for \"noisy\" sources since it may lead to excessive flicker. (In signal theory terms, this controls the time constant \"tau\" of an IIR low pass filter) The lower and upper thresholds (in dB) for a brightness difference to be considered a scene change (default: 1.0 low, 3.0 high). This is only relevant when is enabled. Normally, small fluctuations in the frame brightness are compensated for by the peak averaging mechanism, but for large jumps in the brightness this can result in the frame remaining too bright or too dark for up to several seconds, depending on the value of . To counteract this, when the brightness between the running average and the current frame exceeds the low threshold, mpv will make the averaging filter more aggressive, up to the limit of the high threshold (at which point the filter becomes instant). Enables the HDR contrast recovery algorithm, which is to designed to enhance contrast of HDR video after tone mapping. The strength (default: 0.0) indicates the degree of contrast recovery, with 0.0 being completely disabled and 1.0 being 100% strength. Values higher than 1.0 are allowed, but may result in excessive sharpening. The smoothness (default: 3.5) indicates the degree to which the HDR source is low-passed in order to obtain contrast information - a value of 2.0 corresponds to 2x downscaling. Users on low DPI displays (<= 100) may want to lower this value, while users on very high DPI displays (\"retina\") may want to increase it. (Only for ) Load the embedded ICC profile contained in media files such as PNG images. (Default: yes). Note that this option only works when also using a display ICC profile ( or ), and also requires LittleCMS 2 support. Load an ICC profile and use it to transform video RGB to screen output. Needs LittleCMS 2 support compiled in. This option overrides the , and options. Automatically select the ICC display profile currently specified by the display settings of the operating system. NOTE: On Windows, the default profile must be an ICC profile. WCS profiles are not supported. Applications using libmpv with the render API need to provide the ICC profile via . Store and load 3DLUTs created from the ICC profile on disk in the cache directory (Default: ). This can be used to speed up loading, since LittleCMS 2 can take a while to create a 3D LUT. Note that these files contain uncompressed LUTs. Their size depends on the , and can be very big. On , files that have not been accessed in the last 24 hours may be cleared if the cache limit (1.5 GiB) is exceeded. On , this is not cleaned automatically, so old, unused cache files may stick around indefinitely. The directory where icc cache is stored. Cache is stored in the system's cache directory (usually ) if this is unset. Specifies the ICC intent used for the color transformation (when using ). Size of the 3D LUT generated from the ICC profile in each dimension. The default of means to pick the size automatically based on the profile characteristics. Sizes may range from 2 to 512. NOTE: Setting this option to anything other than is strongly discouraged, except for testing. Override the target device's detected contrast ratio by a specific value. This is detected automatically from the profile if possible, but for some profiles it might be missing, causing the contrast to be assumed as infinite. As a result, video may appear darker than intended. If this is the case, setting this option might help. This only affects BT.1886 content. The default of means to use the profile values. The special value causes the BT.1886 curve to be treated as a pure power gamma 2.4 function. Use ICC profile luminance value. (Only for ) Specifies a custom LUT (in Adobe .cube format) to apply to the colors as part of color conversion. The exact interpretation depends on the value of . (Only for ) Controls the interpretation of color values fed to and from the LUT specified as . Valid values are: Chooses the interpretation of the LUT automatically from tagged metadata, and otherwise falls back to . (Default) Applied to raw image contents in its native RGB colorspace (non-linear light), before conversion to the output color space. Applied to the normalized RGB image contents, in linear light, before conversion to the output color space. Fully replaces the conversion from the image color space to the output color space. If such a LUT is present, it has the highest priority, and overrides any ICC profiles, as well as options related to tone mapping and output colorimetry ( , etc.). Blend subtitles directly onto upscaled video frames, before interpolation and/or color management (default: no). Enabling this causes subtitles to be affected by , , , , and . It also increases subtitle performance when using . The downside of enabling this is that it restricts subtitles to the visible portion of the video, so you can't have subtitles exist in the black margins below a video (for example). If is selected, the behavior is similar to , but subs are drawn at the video's native resolution, and scaled along with the video. This changes the way subtitle colors are handled. Normally, subtitle colors are assumed to be in sRGB and color managed as such. Enabling this makes them treated as being in the video's color space instead. This is good if you want things like softsubbed ASS signs to match the video colors, but may cause SRT subtitles or similar to look slightly off. If the frame has an alpha component, decide what kind of background, if any, to blend it with. This does nothing if there is no alpha component. Blend the frame against the background color ( , normally black). Do not blend the frame and leave the alpha as is. Before mpv 0.38.0, this option used to accept a color value specifying the background color. This is now done by the option. Use that instead. Color used to draw parts of the mpv window not covered by video. See the option for how colors are defined. Same as but only applies to the black bar/border area of the window. only. Defaults to . Force use of rectangle textures (default: no). Normally this shouldn't have any advantages over normal textures. Note that hardware decoding overrides this flag. Could be removed any time. Enlarge the video source textures by this many pixels. For debugging only (normally textures are sized exactly, but due to hardware decoding interop we may have to deal with additional padding, which can be tested with these options). Could be removed any time. Call after rendering a frame and before attempting to display it (default: auto). Can fix stuttering in some cases, in other cases probably causes it. The mode will call only if the renderer is going to wait for a while after rendering, instead of flipping GL front and backbuffers immediately (i.e. it doesn't call it in display-sync mode). On macOS this is always deactivated because it only causes performance problems and other regressions. This mode is extremely restricted, and will disable most extended features. That includes high quality scalers and custom shaders! It is intended for hardware that does not support FBOs (including GLES, which supports it insufficiently), or to get some more performance out of bad or old hardware. This mode is forced automatically if needed, and this option is mostly useful for debugging. The default of will enable it automatically if nothing uses features which require FBOs. This option might be silently removed in the future. Store and load compiled GLSL shaders in the cache directory (Default: ). Normally, shader compilation is very fast, so this is not usually needed. It mostly matters for anything involving GLSL to SPIR-V conversion, that is: D3D11, ANGLE or Vulkan, as well as on some other proprietary drivers. Enabling this can improve startup performance on these platforms. On , files that have not been accessed in the last 24 hours may be cleared if the cache limit (128 MiB) is exceeded. On , this is not cleaned automatically, so old, unused cache files may stick around indefinitely. The directory where gpu shader cache is stored. Cache is stored in the system's cache directory (usually ) if this is unset. Passes extra raw option to the libplacebo rendering backend (used by ). May override the effects of any other options set using the normal options system. Requires libplacebo v6.309 or higher. Included for debugging purposes only. For more information, see: Set the list of tags that should be displayed on the terminal and stats. Tags that are in the list, but are not present in the played file, will not be shown. If a value ends with , all tags are matched by prefix (though there is no general globbing). Just passing essentially filtering. The default includes a common list of tags, call mpv with to see it. This is a string list option. See List Options for details. Gradually adjusts the A/V sync based on audio delay measurements. Specifying , the default, will cause frame timing to be based entirely on audio delay measurements. Specifying will do the same, but will subtly change the A/V correction algorithm. An uneven video framerate in a video which plays fine with can often be helped by setting this to an integer value greater than 1. The higher the value, the closer the timing will be to . Try to smooth out problems with sound drivers which do not implement a perfect audio delay measurement. With this value, if large A/V sync offsets occur, they will only take about 1 or 2 seconds to settle out. This delay in reaction time to sudden A/V offsets should be the only side effect of turning this option on, for all sound drivers. Control how long before video display target time the frame should be rendered (default: 0.050). If a video frame should be displayed at a certain time, the VO will start rendering the frame earlier, and then will perform a blocking wait until the display time, and only then \"swap\" the frame to display. The rendering cannot start before the previous frame is displayed, so this value is implicitly limited by the video framerate. With normal video frame rates, the default value will ensure that rendering is always immediately started after the previous frame was displayed. On the other hand, setting a too high value can reduce responsiveness with low FPS value. This option is interesting for client API users using the render API because you can stop it from limiting your FPS (see documentation). This applies only to audio timing modes (e.g. ). In other modes ( ), video timing relies on vsync blocking, and this option is not used. How the player synchronizes audio and video. If you use this option, you usually want to set it to to enable a timing mode that tries to not skip or repeat frames when for example playing 24fps video on a 24Hz screen. The modes starting with try to output video frames completely synchronously to the display, using the detected display vertical refresh rate as a hint how fast frames will be displayed on average. These modes change video speed slightly to match the display. See options for fine tuning. The robustness of this mode is further reduced by making a some idealized assumptions, which may not always apply in reality. Behavior can depend on the VO and the system's video and audio drivers. Media files must use constant framerate. Section-wise VFR might work as well with some container formats (but not e.g. mkv). Under some circumstances, the player automatically reverts to mode for some time or permanently. This can happen on very low framerate video, or if the framerate cannot be detected. Also in display-sync modes it can happen that interruptions to video playback (such as toggling fullscreen mode, or simply resizing the window) will skip the video frames that should have been displayed, while mode will display them after the renderer has resumed (typically resulting in a short A/V desync and the video \"catching up\"). Before mpv 0.30.0, there was a fallback to mode on severe A/V desync. This was changed for the sake of not sporadically stopping. Now, does what it promises and may desync with audio by an arbitrary amount, until it is manually fixed with a seek. These modes also require a vsync blocked presentation mode. For OpenGL, this translates to . For Vulkan, it translates to (or ). The modes with in their names do not attempt to keep audio/video in sync. They will slowly (or quickly) desync, until e.g. the next seek happens. These modes are meant for testing, not serious use. Time video frames to audio. This is the most robust mode, because the player doesn't have to assume anything about how the display behaves. The disadvantage is that it can lead to occasional frame drops or repeats. If audio is disabled, this uses the system clock. This is the default mode. Resample audio to match the video. This mode will also try to adjust audio speed to compensate for other drift. (This means it will play the audio at a different speed every once in a while to reduce the A/V difference.) Resample audio to match the video. Drop video frames to compensate for drift. Like the previous mode, but no A/V compensation. Same as , but apply audio speed changes to audio filters instead of resampling to avoid the change in pitch. Beware that some audio filters don't do well with a speed close to 1. It is recommend to use a conditional profile to automatically switch to when speed gets too close to 1 for your filter setup. Use (speed * video_speed_correction) to get the actual playback speed in the condition. See Conditional auto profiles for details. Drop or repeat video frames to compensate desyncing video. (Although it should have the same effects as , the implementation is very different.) Drop or repeat audio data to compensate desyncing video. This mode will cause severe audio artifacts if the real monitor refresh rate is too different from the reported or forced rate. Since mpv 0.33.0, this acts on entire audio frames, instead of single samples. Sync video to display, and let audio play on its own. Sync video according to system clock, and let audio play on its own. Maximum multiple for which to try to fit the video's FPS to the display's FPS (default: 5). For example, if this is set to 1, the video FPS is forced to an integer multiple of the display FPS, as long as the speed change does not exceed the value set by . See for how this option affects interpolation. Maximum speed difference in percent that is applied to video with (default: 1). Display sync mode will be disabled if the monitor and video refresh way do not match within the given range. It tries multiples as well: playing 30 fps video on a 60 Hz screen will duplicate every second frame. Playing 24 fps video on a 60 Hz screen will play video in a 2-3-2-3-... pattern. The default settings are not loose enough to speed up 23.976 fps video to 25 fps. We consider the pitch change too extreme to allow this behavior by default. Set this option to a value of to enable it. Also note that in the or mode, audio speed will additionally be changed by a small amount if necessary for A/V sync. See . Maximum additional speed difference in percent that is applied to audio with (default: 0.125). Normally, the player plays the audio at the speed of the video. But if the difference between audio and video position is too high, e.g. due to drift or other timing errors, it will attempt to speed up or slow down audio by this additional factor. Too low values could lead to video frame dropping or repeating if the A/V desync cannot be compensated, too high values could lead to chaotic frame dropping due to the audio \"overshooting\" and skipping multiple video frames before the sync logic can react. Framerate used when decoding from multiple PNG or JPEG files with (default: 1). Input file type for (available: jpeg, png, tga, sgi). By default, this is guessed from the file extension. Instead of playing a file, read its byte stream and write it to the given destination file. The destination is overwritten. Can be useful to test network-related behavior. Set AVOptions on streams opened with libavformat. Unknown or misspelled options are silently ignored. (They are mentioned in the terminal output in verbose mode, i.e. . In general we can't print errors, because other options such as e.g. user agent are not available with all protocols, and printing errors for unknown options would end up being too noisy.) This is a key/value list option. See List Options for details. The backdrop will be black or white depending on the system's theme settings. Enables the Mica style, which is the default on Windows 11. Same as Mica, except reversed. (Windows only) Controls the window affinity behavior of mpv. mpv's window will be completely excluded from capture by external applications or screen recording software. (Windows only) Set the MMCSS profile for the video renderer thread (default: ). (Windows only) Set process priority for mpv according to the predefined priorities available under Windows. Using realtime priority can cause system lockup. Force the contents of the property to this value. Useful for scripts which want to set a title, without overriding the user's setting in . Load a file and add all of its tracks. This is useful to play different files together (for example audio from one file, video from another), or for advanced used (like playing two video files at the same time). Unlike and , this includes all tracks, and does not cause default stream selection over the \"proper\" file. This makes it slightly less intrusive. (In mpv 0.28.0 and before, this was not quite strictly enforced.) This is a path list option. See List Options for details. CLI/config file only alias for . Each use of this option will add a new external file. Use an external file as cover art while playing audio. This makes it appear on the track list and subject to automatic track selection. Options like control whether such tracks are supposed to be selected. This is a path list option. See List Options for details. CLI/config file only alias for . Each use of this option will add a new external file. Whether to load _external_ cover art automatically. Similar to and . If a video already has tracks (which are not marked as cover art), external cover art will not be loaded. Load the media filename with an image file extension (default). Load all cover art containing the media filename. Load all images in the current directory. See for details about what constitutes cover art. See how to control display of cover art (this can be used to disable cover art that is part of the file). Image file extentions to try to match when using , or . This is a string list option. See List Options for details. Use to see default extensions. Filenames to load as cover art, sorted by descending priority. They are combined with the extensions in . This has no effect if is . This is a string list option. See List Options for details. Video file extentions to try to match when using or . This is a string list option. See List Options for details. Use to see default extensions. If set to , then do not automatically load external files as specified by , and . If external files are forcibly added (like with ), they will not be auto-selected. This does not affect playlist expansion, redirection, or other loading of referenced files like with ordered chapters. Write received/read data from the demuxer to the given output file. The output file will always be overwritten without asking. The output format is determined by the extension of the output file. Switching streams or seeking during recording might result in recording being stopped and/or broken files. Use with care. Seeking outside of the demuxer cache will result in \"skips\" in the output file, but seeking within the demuxer cache should not affect recording. One exception is when you seek back far enough to exceed the forward buffering size, in which case the cache stops actively reading. This will return in dropped data if it's a live stream. If this is set at runtime, the old file is closed, and the new file is opened. Note that this will write only data that is appended at the end of the cache, and the already cached data cannot be written. You can try the command as an alternative. External files ( etc.) are ignored by this, it works on the \"main\" file only. Using this with files using ordered chapters or EDL files will also not work correctly in general. There are some glitches with this because it uses FFmpeg's libavformat for writing the output file. For example, it's typical that it will only work if the output format is the same as the input format. This is the case even if it works with the tool. One reason for this is that and its libraries contain certain hacks and workarounds for these issues, that are unavailable to outside users. Set a \"complex\" libavfilter filter, which means a single filter graph can take input from multiple source audio and video tracks. The graph can result in a single audio or video output (or both). Currently, the filter graph labels are used to select the participating input tracks and audio/video output. The following rules apply:\n• A label of the form selects audio track N as input (e.g. ).\n• A label of the form selects video track N as input.\n• A label named will be connected to the audio output.\n• A label named will be connected to the video output. Each label can be used only once. If you want to use e.g. an audio stream for multiple filters, you need to use the filter. Multiple video or audio outputs are not possible, but you can use filters to merge them into one. It's not possible to change the tracks connected to the filter at runtime, unless you explicitly change the property and set new track assignments. When the graph is changed, the track selection is changed according to the used labels as well. Other tracks, as long as they're not connected to the filter, and the corresponding output is not connected to the filter, can still be freely changed with the normal methods. Note that the normal filter chains ( , ) are applied between the complex graphs (e.g. label) and the actual output.\n• Play audio track 1 and 2 at the same time.\n• Stack video track 1 and 2 and play them at the same time. Note that both tracks need to have the same width, or filter initialization will fail (you can add filters before the filter to fix the size). To load a video track from another file, you can use .\n• Use the inputs option to stack more than 2 tracks.\n• Play audio track 1, and overlay the measured volume for each speaker over video track 1. See the FFmpeg libavfilter documentation for details on the available filters. Codepage for various input metadata (default: ). This affects how file tags, chapter titles, etc. are interpreted. In most cases, this merely evaluates to UTF-8 as non-UTF-8 codepages are obscure. See option on how codepages are specified and further details regarding autodetection and codepage conversion. (The underlying code is the same.) Conversion is not applied to metadata that is updated at runtime.\n\nThe mpv core can be controlled with commands and properties. A number of ways to interact with the player use them: key bindings ( ), OSD (showing information with properties), JSON IPC, the client API ( ), and the classic slave mode. The input.conf file consists of a list of key bindings, for example: s screenshot # take a screenshot with the s key LEFT seek 15 # map the left-arrow key to seeking forward by 15 seconds Each line maps a key to an input command. Keys are specified with their literal value (upper case if combined with ), or a name for special keys. For example, maps to the key without shift, and maps to with shift. The file is located in the mpv configuration directory (normally at depending on platform). The default bindings are defined here: A list of special keys can be obtained with In general, keys can be combined with , and : mpv can be started in input test mode, which displays key bindings and the commands they're bound to on the OSD, instead of executing the commands: Note that by default, the right Alt key can be used to create special characters, and thus does not register as a modifier. This can be changed with option. Newlines always start a new binding. starts a comment (outside of quoted string arguments). To bind commands to the key, can be used. is either the literal character the key produces (ASCII or Unicode character), or a symbolic name (as printed by ). (braced with and ) is the input section for this command. is the command itself. It consists of the command name and multiple (or none) arguments, all separated by whitespace. String arguments should be quoted, typically with . See . You can bind multiple commands to one key. For example: It's also possible to bind a command to a sequence of keys: a-b-c show-text \"command run after a, b, c have been pressed\" If or or are already bound, this will run the first command that matches, and the multi-key command will never be called. Intermediate keys can be remapped to in order to avoid this issue. The maximum number of (non-modifier) keys for combinations is currently 4. All mouse and keyboard input is to converted to mpv-specific key names. Key names are either special symbolic identifiers representing a physical key, or a text key names, which are unicode code points encoded as UTF-8. These are what keyboard input would normally produce, for example for the A key. As a consequence, mpv uses input translated by the current OS keyboard layout, rather than physical scan codes. Currently there is the hardcoded assumption that every text key can be represented as a single unicode code point (in NFKC form). All key names can be combined with the modifiers , , , . They must be prefixed to the actual key name, where each modifier is followed by a (for example ). The modifier requires some attention. For instance should usually be specified as key-name at , and similarly the combination is usually , etc. Special key names like work as expected. If in doubt - use to check how a key/combination is seen by mpv. Symbolic key names and modifier names are case-insensitive. Unicode key names are case-sensitive because input bindings typically respect the shift key. Another type of key names are hexadecimal key names, that serve as fallback for special keys that are neither unicode, nor have a special mpv defined name. They will break as soon as mpv adds proper names for them, but can enable you to use a key at all if that does not happen. All symbolic names are listed by . is a special mode that prints all input on the OSD. Keypad names. Behavior varies by backend (whether they implement this, and on how they treat numlock), but typically, mpv tries to map keys on the keypad to separate names, even if they produce the same text as normal keys. Depending on backend, the mouse wheel might also be represented as a button. In addition, to are deprecated aliases for , , , . Emitted by mouse move events. Enter/leave happens when the mouse enters or leave the mpv window (or the current mouse region, using the deprecated mouse region input section mechanism). Pseudo key emitted when closing the mpv window using the OS window manager (for example, by clicking the close button in the window title bar). Pseudo-key that matches any unmapped key. (You should probably avoid this if possible, because it might change behavior or get removed in the future.) Pseudo-key that matches any key that produces text. (You should probably avoid this if possible, because it might change behavior or get removed in the future.) This is the syntax used in input.conf, and referred to \"input.conf syntax\" in a number of other places. is an unquoted string with the command name itself. See List of Input Commands for a list. Arguments are separated by whitespaces even if the command expects only one argument. Arguments with whitespaces or other special characters must be quoted, or the command cannot be parsed correctly. Double quotes interpret JSON/C-style escaping, like or or . JSON escapes according to RFC 8259, minus surrogate pair escapes. This is the only form which allows newlines at the value - as . Single quotes take the content literally, and cannot include the single-quote character at the value. Custom quotes also take the content literally, but are more flexible than single quotes. They start with (back-quote) followed by any ASCII character, and end at the first occurrence of the same pair in reverse order, e.g. or . The final pair sequence is not allowed at the value - in these examples and respectively. In the second example the last character of the value also can't be a back-quote. Mixed quoting at the same argument, like , is not supported. Note that argument parsing and property expansion happen at different stages. First, arguments are determined as described above, and then, where applicable, properties are expanded - regardless of argument quoting. However, expansion can still be prevented with the prefix or . See Input Command Prefixes and Property Expansion. This applies to certain APIs, such as or (with array parameters) in Lua scripting, or or (with MPV_FORMAT_NODE_ARRAY) in the C libmpv client API. The command as well as all arguments are passed as a single array. Similar to the Flat command syntax, you can first pass prefixes as strings (each as separate array item), then the command name as string, and then each argument as string or a native value. Since these APIs pass arguments as separate strings or native values, they do not expect quotes, and do support escaping. Technically, there is the input.conf parser, which first splits the command string into arguments, and then invokes argument parsers for each argument. The input.conf parser normally handles quotes and escaping. The array command APIs mentioned above pass strings directly to the argument parsers, or can sidestep them by the ability to pass non-string values. Property expansion is disabled by default for these APIs. This can be changed with the prefix. See Input Command Prefixes. Sometimes commands have string arguments, that in turn are actually parsed by other components (e.g. filter strings with ) - in these cases, you you would have to double-escape in input.conf, but not with the array APIs. For complex commands, consider using Named arguments instead, which should give slightly more compatibility. Some commands do not support named arguments and inherently take an array, though. This applies to certain APIs, such as (with tables that have string keys) in Lua scripting, or (with MPV_FORMAT_NODE_MAP) in the C libmpv client API. The name of the command is provided with a string field. The name of each command is defined in each command description in the List of Input Commands. also lists them. See the command for an example. Some commands do not support named arguments (e.g. command). You need to use APIs that pass arguments as arrays. Named arguments are not supported in the \"flat\" input.conf syntax, which means you cannot use them for key bindings in input.conf at all. Property expansion is disabled by default for these APIs. This can be changed with the prefix. See Input Command Prefixes. Commands with parameters have the parameter name enclosed in / . Don't add those to the actual command. Optional arguments are enclosed in / . If you don't pass them, they will be set to a default value. Remember to quote string arguments in input.conf (see Flat command syntax). Use this to \"block\" keys that should be unbound, and do nothing. Useful for disabling default bindings, without disabling all bindings with . Change the playback position. By default, seeks by a relative amount of seconds. The second argument consists of flags controlling the seek mode: Seek to a given time (a negative value starts from the end of the file). By default, is used for , , and seeks, while is used for seeks. Before mpv 0.9, the and flags had to be passed as 3rd parameter (essentially using a space instead of ). The 3rd parameter is still parsed, but is considered deprecated. Undoes the command, and some other commands that seek (but not necessarily all of them). Calling this command once will jump to the playback position before the seek. Calling it a second time undoes the command itself. This only works within a single file. The first argument is optional, and can change the behavior: Mark the current time position. The next normal command will seek back to this point, no matter how many seeks happened since last time. If set, mark the current position, and do not change the mark position before the next command that has or set (or playback of the current file ends). Until this happens, will always seek to the marked point. This flag cannot be combined with . Using it without any arguments gives you the default behavior. Play one frame, then pause. Does nothing with audio-only playback. Go back by one frame, then pause. Note that this can be very slow (it tries to be precise, not fast), and sometimes fails to behave as expected. How well this works depends on whether precise seeking works correctly (e.g. see the option). Video filters or other video post-processing that modifies timing of frames (e.g. deinterlacing) should usually work, but might make backstepping silently behave incorrectly in corner cases. Using should help, although it might make precise seeking slower. This does not work with audio-only playback. Set the given property or option to the given value. Delete the given property. Most properties cannot be deleted. Add the given value to the property or option. On overflow or underflow, clamp the property to the maximum. If is omitted, assume . Cycle the given property or option. The second argument can be or to set the cycle direction. On overflow, set the property back to the minimum, on underflow set it to the maximum. If or is omitted, assume . Whether or not key-repeat is enabled by default depends on the property. Currently properties with continuous values are repeatable by default (like ), while discrete values are not (like ). Similar to , but multiplies the property or option with the numeric value. Multiple flags are available (some can be combined with ): Save the video image, in its original resolution, and with subtitles. Some video outputs may still include the OSD in the output under certain circumstances. Like , but typically without OSD or subtitles. The exact behavior depends on the selected video output. Save the contents of the mpv window. Typically scaled, with OSD and subtitles. The exact behavior depends on the selected video output. Take a screenshot each frame. Issue this command again to stop taking screenshots. Note that you should disable frame-dropping when using this mode - or you might receive duplicate images in cases when a frame was dropped. This flag can be combined with the other flags, e.g. . Older mpv versions required passing and as second argument (and did not have flags). This syntax is still understood, but deprecated and might be removed in the future. If you combine this command with another one using , you can use the flag to make encoding/writing the image file asynchronous. For normal standalone commands, this is always asynchronous, and the flag has no effect. (This behavior changed with mpv 0.29.0.) On success, returns a with a field set to the saved screenshot location. Take a screenshot and save it to a given file. The format of the file will be guessed by the extension (and is ignored - the behavior when the extension is missing or unknown is arbitrary). The second argument is like the first argument to and supports , , . If the file already exists, it's overwritten. Like all input command parameters, the filename is subject to property expansion as described in Property Expansion. Go to the next entry on the playlist. If the last file on the playlist is currently played, do nothing. Terminate playback if there are no more files on the playlist. Go to the previous entry on the playlist. If the first file on the playlist is currently played, do nothing. Terminate playback if the first file is being played. Go to the next entry on the playlist with a different . Go to the first of the previous entries on the playlist with a different . Start (or restart) playback of the given playlist index. In addition to the 0-based playlist entry index, it supports the following values: The current playlist entry (as in ) will be played again (unload and reload). If none is set, playback is stopped. (In corner cases, can point to a playlist entry even if playback is currently inactive, Playback is stopped. If idle mode ( ) is enabled, the player will enter idle mode, otherwise it will exit. This command is similar to in that it only manipulates the state of what to play next, without waiting until the current file is unloaded, and the next one is loaded. Setting or similar properties can have a similar effect to this command. However, it's more explicit, and guarantees that playback is restarted if for example the new playlist entry is the same as the previous one. Load the given file or URL and play it. Technically, this is just a playlist manipulation command (which either replaces the playlist or adds an entry to it). Actual file loading happens independently. For example, a command that replaces the current file with a new one returns before the current file is stopped, and the new file even begins loading. Stop playback of the current file, and play the new file immediately. Append the file to the playlist. Append the file, and if nothing is currently playing, start playback. (Always starts with the added file, even if the playlist was not empty before running this command.) Insert the file into the playlist, directly after the current entry. Insert the file next, and if nothing is currently playing, start playback. (Always starts with the added file, even if the playlist was not empty before running this command.) Insert the file into the playlist, at the index given in the third argument. Insert the file at the index given in the third argument, and if nothing is currently playing, start playback. (Always starts with the added file, even if the playlist was not empty before running this command.) The third argument is an insertion index, used only by the and actions. When used with those actions, the new item will be inserted at the index position in the playlist, or appended to the end if index is less than 0 or greater than the size of the playlist. This argument will be ignored for all other actions. This argument is added in mpv 0.38.0. The fourth argument is a list of options and values which should be set while the file is playing. It is of the form . When using the client API, this can be a (or a Lua table), however the values themselves must be strings currently. These options are set during playback, and restored to the previous value at end of playback (see Per-File Options). Since mpv 0.38.0, an insertion index argument is added as the third argument. This breaks all existing uses of this command which make use of the argument to include the list of options to be set while the file is playing. To address this problem, the third argument now needs to be set to -1 if the fourth argument needs to be used. Load the given playlist file or URL (like ). Stop playback and replace the internal playlist with the new one. Append the new playlist at the end of the current internal playlist. Append the new playlist, and if nothing is currently playing, start playback. (Always starts with the new playlist, even if the internal playlist was not empty before running this command.) Insert the new playlist into the current internal playlist, directly after the current entry. Insert the new playlist, and if nothing is currently playing, start playback. (Always starts with the new playlist, even if the internal playlist was not empty before running this command.) Insert the new playlist at the index given in the third argument. Insert the new playlist at the index given in the third argument, and if nothing is currently playing, start playback. (Always starts with the new playlist, even if the internal playlist was not empty before running this command.) The third argument is an insertion index, used only by the and actions. When used with those actions, the new playlist will be inserted at the index position in the internal playlist, or appended to the end if index is less than 0 or greater than the size of the internal playlist. This argument will be ignored for all other actions. Clear the playlist, except the currently played file. Remove the playlist entry at the given index. Index values start counting with 0. The special value removes the current entry. Note that removing the current entry also stops playback and starts playing the next entry. Move the playlist entry at index1, so that it takes the place of the entry index2. (Paradoxically, the moved playlist entry will not have the index value index2 after moving if index1 was lower than index2, because index2 refers to the target entry, not the index the entry will have after moving.) Shuffle the playlist. This is similar to what is done on start if the option is used. Attempt to revert the previous command. This works only once (multiple successive commands do nothing). May not work correctly if new recursive playlists have been opened since a command. Run the given command. Unlike in MPlayer/mplayer2 and earlier versions of mpv (0.2.x and older), this doesn't call the shell. Instead, the command is run directly, with each argument passed separately. Each argument is expanded like in Property Expansion. This command has a variable number of arguments, and cannot be used with named arguments. The program is run in a detached way. mpv doesn't wait until the command is completed, but continues playback right after spawning it. To get the old behavior, use and as the first two arguments. This is not a particularly good example, because it doesn't handle escaping, and a specially prepared file might allow an attacker to execute arbitrary shell commands. It is recommended to write a small shell script, and call that with . Similar to , but gives more control about process execution to the caller, and does not detach the process. You can avoid blocking until the process terminates by running this command asynchronously. (For example in Lua scripting.) This has the following named arguments. The order of them is not guaranteed, so you should always call them with named arguments, see Named arguments. Array of strings with the command as first argument, and subsequent command line arguments following. This is just like the command argument list. The first array entry is either an absolute path to the executable, or a filename with no path components, in which case the executable is searched in the directories in the environment variable. On Unix, this is equivalent to and behavior. Boolean indicating whether the process should be killed when playback of the current playlist entry terminates (optional, default: true). If enabled, stopping playback will automatically kill the process, and you can't start it outside of playback. Integer setting the maximum number of stdout plus stderr bytes that can be captured (optional, default: 64MB). If the number of bytes exceeds this, capturing is stopped. The limit is per captured stream. Capture all data the process outputs to stdout and return it once the process ends (optional, default: no). Same as , but for stderr. Whether to run the process in detached mode (optional, default: no). In this mode, the process is run in a new process session, and the command does not wait for the process to terminate. If neither nor have been set to true, the command returns immediately after the new process has been started, otherwise the command will read as long as the pipes are open. Set a list of environment variables for the new process (default: empty). If an empty list is passed, the environment of the mpv process is used instead. (Unlike the underlying OS mechanisms, the mpv command cannot start a process with empty environment. Fortunately, that is completely useless.) The format of the list is as in the syscall. Each string item defines an environment variable as in . On Lua, you may use to retrieve the current environment if you e.g. simply want to add a new variable. Feed the given string to the new process' stdin. Since this is a string, you cannot pass arbitrary binary data. If the process terminates or closes the pipe before all data is written, the remaining data is silently discarded. Probably does not work on win32. If enabled, wire the new process' stdin to mpv's stdin (default: no). Before mpv 0.33.0, this argument did not exist, but the behavior was as if this was set to true. The command returns the following result (as ): Typically this is the process exit code (0 or positive) if the process terminates normally, or negative for other errors (failed to start, terminated by mpv, and others). The meaning of negative values is undefined, other than meaning error (and does not correspond to OS low level exit status values). On Windows, it can happen that a negative return value is returned even if the process terminates normally, because the win32 exit code is assigned to an variable before being set as field in the result map. This might be fixed later. Same as , but for stderr. Empty string if the process terminated normally. The string if the process was terminated in an unusual way. The string if the process could not be started. On Windows, is only returned when the process has been killed by mpv as a result of being set to true. Whether the process has been killed by mpv, for example as a result of being set to true, aborting the command (e.g. by ), or if the player is about to exit. Note that the command itself will always return success as long as the parameters are correct. Whether the process could be spawned or whether it was somehow killed or returned an error status has to be queried from the result value. This command can be asynchronously aborted via API. Also see Asynchronous command details. Only the command can start processes in a truly detached way. The subprocess will always be terminated on player exit if it wasn't started in detached mode, even if is false. Don't forget to set the field to false if you want the command to run while the player is in idle mode, or if you don't want the end of playback to kill the command. local r = mp.command_native({ name = \"subprocess\", playback_only = false, capture_stdout = true, args = {\"cat\", \"/proc/cpuinfo\"}, }) if r.status == 0 then print(\"result: \" .. r.stdout) end This is a fairly useless Lua example, which demonstrates how to run a process in a blocking manner, and retrieving its stdout output. Exit the player. If an argument is given, it's used as process exit code. Exit player, and store current playback position. Playing that file later will seek to the previous position on start. The (optional) argument is exactly as in the command. See RESUMING PLAYBACK. Load the given subtitle file or stream. By default, it is selected as current subtitle after loading. The argument is one of the following values: Don't select the subtitle. (Or in some special situations, let the default stream selection mechanism decide.) Select the subtitle. If a subtitle with the same filename was already added, that one is selected, instead of loading a duplicate entry. (In this case, title/language are ignored, and if the was changed since it was loaded, these changes won't be reflected.) The argument sets the track title in the UI. The argument sets the track language, and can also influence stream selection with set to . Remove the given subtitle track. If the argument is missing, remove the current track. (Works on external subtitle files only.) Reload the given subtitle tracks. If the argument is missing, reload the current track. (Works on external subtitle files only.) This works by unloading and re-adding the subtitle track. Change subtitle timing such, that the subtitle event after the next subtitle events is displayed. can be negative to step backwards. Change video and audio position such that the subtitle event after subtitle events is displayed. For example, skips to the next subtitle, skips to the previous subtitles, and seeks to the beginning of the current subtitle. This is similar to , except that it seeks video and audio instead of adjusting the subtitle delay. For embedded subtitles (like with Matroska), this works only with subtitle events that have already been displayed, or are within a short prefetch range. See Cache for details on how to control the available prefetch range. Print text to stdout. The string can contain properties (see Property Expansion). Take care to put the argument in quotes. Show text on the OSD. The string can contain properties, which are expanded as described in Property Expansion. This can be used to show playback time, filename, and so on. has no effect on this command. The time in ms to show the message for. By default, it uses the same value as . The minimum OSD level to show the text at (see ). Property-expand the argument and return the expanded string. This can be used only through the client API or from a script using . (see Property Expansion). Expand a path's double-tilde placeholders into a platform-specific path. As , this can only be used through the client API or from a script using . This line of Lua would show the location of the user's mpv configuration directory on the OSD. Return a canonical representation of the path by converting it to an absolute path, removing consecutive slashes, removing components, resolving components, and converting slashes to backslashes on Windows. Symlinks are not resolved unless the platform is Unix-like and one of the path components is . If is a URL, it is returned unchanged. This can only be used through the client API or from a script using . This line of Lua prints \"/foo/bar\" on the OSD. Modify so that commands and functions that interpret ASS tags, such as and , will display it verbatim, and return it. This can only be used through the client API or from a script using . This line of Lua prints \"foo \\{bar}\" on the OSD. Show the progress bar, the elapsed time and the total duration of the file on the OSD. has no effect on this command. Write the resume config file that the command writes, but continue playback normally. Delete any existing resume config file that was written by or . If a filename is specified, then the deleted config is for that file; otherwise, it is the same one as would be written by or in the current circumstance. Stop playback and clear playlist. With default settings, this is essentially like . Useful for the client API: playback can be stopped without terminating the player. The first argument is optional, and supports the following flags: Do not clear the playlist. The button number of clicked mouse button. This should be one of 0-19. If is omitted, only the position will be updated. Send a key event through mpv's input handler, triggering whatever behavior is configured to that key. uses the naming scheme for keys and modifiers. is used to scale numerical change effected by the bound command (same mechanism as precise scrolling). Useful for the client API: key events can be sent to libmpv to handle internally. Similar to , but sets the flag so that if the key is bound to a repeatable command, it will be run repeatedly with mpv's key repeat timing until the command is called. Set the flag, stopping any repeated behavior that had been triggered. is optional. If is not given or is an empty string, will be set on all keys. Otherwise, will only be set on the key specified by . Binds a key to an input command. must be a complete command containing all the desired arguments and flags. Both and use the naming scheme. This is primarily useful for the client API. Load the given audio file. See command. Remove the given audio track. See command. Reload the given audio tracks. See command. Load the given video file. See command for common options. If enabled, mpv will load the given video as album art. Remove the given video track. See command. Reload the given video tracks. See command. Rescan external files according to the current , and settings. This can be used to auto-load external files after the file was loaded. The argument is one of the following: Select the default audio and subtitle streams, which typically selects external files with the highest preference. (The implementation is not perfect, and could be improved on request.) Show context menu on the video window. See Context Menu section for details. Input Commands that are Possibly Subject to Change The semantics are exactly the same as with option parsing (see VIDEO FILTERS). As such the text below is a redundant and incomplete summary. The first argument decides what happens: Overwrite the previous filter chain with the new one. Append the new filter chain to the previous one. Check if the given filter (with the exact parameters) is already in the video chain. If it is, remove the filter. If it isn't, add the filter. (If several filters are passed to the command, this is done for each filter.) A special variant is combining this with labels, and using without filter name and parameters as filter entry. This toggles the enable/disable flag. Like , but always remove the given filter from the chain. Remove all filters. Note that like the other sub-commands, this does not control automatically inserted filters. The argument is always needed. E.g. in case of use . You can assign labels to filter by prefixing them with (where is a user-chosen arbitrary identifier). Labels can be used to refer to filters by name in all of the filter chain modification commands. For , using an already used label will replace the existing filter. The command shows the list of requested filters on the OSD after changing the filter chain. This is roughly equivalent to . Note that auto-inserted filters for format conversion are not shown on the list, only what was requested by the user. Normally, the commands will check whether the video chain is recreated successfully, and will undo the operation on failure. If the command is run before video is configured (can happen if the command is run immediately after opening a file and before a video frame is decoded), this check can't be run. Then it can happen that creating the video chain fails.\n• turn the video upside-down on the key Example how to toggle disabled filters at runtime\n• Add something like to . The is the label, an arbitrary, user-given name for this filter entry. The before the filter name disables the filter by default. Everything after this is the normal filter name and possibly filter parameters, like in the normal syntax.\n• Add to . This toggles the \"disabled\" flag for the filter with the label when the key is hit. Cycle through a list of values. Each invocation of the command will set the given property to the next value in the list. The command will use the current value of the property/option, and use it to determine the current position in the list of values. Once it has found it, it will set the next value in the list (wrapping around to the first item if needed). This command has a variable number of arguments, and cannot be used with named arguments. The special argument can be used to cycle the value list in reverse. The only advantage is that you don't need to reverse the value list yourself when adding a second key binding for cycling backwards. This command is deprecated, except for mpv-internal uses. Enable all key bindings in the named input section. The enabled input sections form a stack. Bindings in sections on the top of the stack are preferred to lower sections. This command puts the section on top of the stack. If the section was already on the stack, it is implicitly removed beforehand. (A section cannot be on the stack more than once.) The parameter can be a combination (separated by ) of the following flags: All sections enabled before the newly enabled section are disabled. They will be re-enabled as soon as all exclusive sections above them are removed. In other words, the new section shadows all previous sections. This feature can't be used through the public API. This command is deprecated, except for mpv-internal uses. This command is deprecated, except for mpv-internal uses. Create a named input section, or replace the contents of an already existing input section. The parameter uses the same syntax as the file (except that using the section syntax in it is not allowed), including the need to separate bindings with a newline character. If the parameter is an empty string, the section is removed. The section with the name is the normal input section. In general, input sections have to be enabled with the command, or they are ignored. The last parameter has the following meaning: <default> (also used if parameter omitted) Use a key binding defined by this section only if the user hasn't already bound this key to a command. Always bind a key. (The input section that was made active most recently wins if there are ambiguities.) This command can be used to dispatch arbitrary keys to a script or a client API user. If the input section defines commands, it is also possible to get separate events on key up/down, and relatively detailed information about the key state. The special key name can be used to match any unmapped key. Add an OSD overlay sourced from raw data. This might be useful for scripts and applications controlling mpv, and which want to display things on top of the video window. Overlays are usually displayed in screen resolution, but with some VOs, the resolution is reduced to that of the video's. You can read the and properties. At least with and anamorphic video (such as DVD), should be read as well, and the overlay should be aspect-compensated. This has the following named arguments. The order of them is not guaranteed, so you should always call them with named arguments, see Named arguments. is an integer between 0 and 63 identifying the overlay element. The ID can be used to add multiple overlay parts, update a part by using this command with an already existing ID, or to remove a part with . Using a previously unused ID will add a new overlay, while reusing an ID will update it. and specify the position where the OSD should be displayed. specifies the file the raw image data is read from. It can be either a numeric UNIX file descriptor prefixed with (e.g. ), or a filename. The file will be mapped into memory with , copied, and unmapped before the command returns (changed in mpv 0.18.1). It is also possible to pass a raw memory address for use as bitmap memory by passing a memory address as integer prefixed with an character. Passing the wrong thing here will crash the player. This mode might be useful for use with libmpv. The parameter is simply added to the memory address (since mpv 0.8.0, ignored before). is the byte offset of the first pixel in the source file. (The current implementation always mmap's the whole file from position 0 to the end of the image, so large offsets should be avoided. Before mpv 0.8.0, the offset was actually passed directly to , but it was changed to make using it easier.) is a string identifying the image format. Currently, only is defined. This format has 4 bytes per pixels, with 8 bits per component. The least significant 8 bits are blue, and the most significant 8 bits are alpha (in little endian, the components are B-G-R-A, with B as first byte). This uses premultiplied alpha: every color component is already multiplied with the alpha component. This means the numeric value of each component is equal to or smaller than the alpha component. (Violating this rule will lead to different results with different VOs: numeric overflows resulting from blending broken alpha values is considered something that shouldn't happen, and consequently implementations don't ensure that you get predictable behavior in this case.) , , and specify the size of the overlay. is the visible width of the overlay, while gives the width in bytes in memory. In the simple case, and with the format, . In general, the total amount of memory accessed is . (Technically, the minimum size would be , but for simplicity, the player will access all bytes.) and specify the (optional) display size of the overlay. The overlay visible portion of the overlay ( and ) is scaled to in display to and . If parameters are not present, the values for and are used. Before mpv 0.18.1, you had to do manual \"double buffering\" when updating an overlay by replacing it with a different memory buffer. Since mpv 0.18.1, the memory is simply copied and doesn't reference any of the memory indicated by the command's arguments after the command returns. If you want to use this command before mpv 0.18.1, reads the old docs to see how to handle this correctly. Remove an overlay added with and the same ID. Does nothing if no overlay with this ID exists. You can use this to add text overlays in ASS format. ASS has advanced positioning and rendering tags, which can be used to render almost any kind of vector graphics. This command accepts the following parameters: Arbitrary integer that identifies the overlay. Multiple overlays can be added by calling this command with different parameters. Calling this command with the same replaces the previously set overlay. There is a separate namespace for each libmpv client (i.e. IPC connection, script), so IDs can be made up and assigned by the API user without conflicting with other API users. If the libmpv client is destroyed, all overlays associated with it are also deleted. In particular, connecting via , adding an overlay, and disconnecting will remove the overlay immediately again. String that gives the type of the overlay. Accepts the following values (HTML rendering of this is broken, view the generated manpage instead, or the raw RST source): The parameter is a string. The string is split on the newline character. Every line is turned into the part of a ASS event. Timing is unused (but behavior of timing dependent ASS tags may change in future mpv versions). Note that it's better to put multiple lines into , instead of adding multiple OSD overlays. This provides 2 ASS . contains the text style as defined by the current options. is similar, and contains style that would have if all options were set to the default. In addition, the and options specify the value of the ASS and header fields. If is set to 0, is initialized to an arbitrary default value (but note that the default for this command is 720, not 0). If is set to 0, is set based on such that a virtual ASS pixel has a square pixel aspect ratio. Special value that causes the overlay to be removed. Most parameters other than and are mostly ignored. String defining the overlay contents according to the parameter. Used if is set to (see description there). Optional, defaults to 0/720. The Z order of the overlay. Optional, defaults to 0. Note that Z order between different overlays of different formats is static, and cannot be changed (currently, this means that bitmap overlays added by are always on top of the ASS overlays added by ). In addition, the builtin OSD components are always below any of the custom OSD. (This includes subtitles of any kind as well as text rendered by .) It's possible that future mpv versions will randomly change how Z order between different OSD formats and builtin OSD is handled. If set to true, do not display this (default: false). If set to true, attempt to determine bounds and write them to the command's result value as , , , rectangle (default: false). If the rectangle is empty, not known, or somehow degenerate, it is not set. / is the coordinate of the bottom exclusive corner of the rectangle. The result value may depend on the VO window size, and is based on the last known window size at the time of the call. This means the results may be different from what is actually rendered. For , the result rectangle is recomputed to coordinates ( / ). If window size is not known, a fallback is chosen. You should be aware that this mechanism is very inefficient, as it renders the full result, and then uses the bounding box of the rendered bitmap list (even if is set). It will flush various caches. Its results also depend on the used libass version. This feature is experimental, and may change in some way again. Always use named arguments ( ). Lua scripts should use the helper instead of invoking this command directly. Send a message to all clients, and pass it the following list of arguments. What this message means, how many arguments it takes, and what the arguments mean is fully up to the receiver and the sender. Every client receives the message, so be careful about name clashes (or use ). This command has a variable number of arguments, and cannot be used with named arguments. Same as , but send it only to the client named . Each client (scripts etc.) has a unique name. For example, Lua scripts can get their name via . Note that client names only consist of alphanumeric characters and . This command has a variable number of arguments, and cannot be used with named arguments. Invoke a script-provided key binding. This can be used to remap key bindings provided by external Lua scripts. The argument is the name of the binding. It can optionally be prefixed with the name of the script, using as separator, e.g. . Note that script names only consist of alphanumeric characters and . For completeness, here is how this command works internally. The details could change any time. On any matching key event, or is called (depending on whether the script name is included), with the following arguments:\n• The name of the binding (as established above).\n• The key state as string (see below).\n• The key name (since mpv 0.15.0).\n• The text the key would produce, or empty string if not applicable. The 5th argument is only set if no modifiers are present (using the shift key with a letter is normally not emitted as having a modifier, and results in upper case text instead, but some backends may mess up).\n• One of (key was pressed down), (was released), (key is still down, and was repeated; only if key repeat is enabled for this binding), (key was pressed; happens if up/down can't be tracked).\n• Whether the event originates from the mouse, either (mouse button) or (something else).\n• Whether the event results from a cancellation (e.g. the key is logically released but not physically released), either (canceled) or (something else). Not all types of cancellations set this flag. Future versions can add more arguments and more key state characters to support more input peculiarities. Cycle through A-B loop states. The first command will set the point (the property); the second the point, and the third will clear both points. Drop audio/video/demuxer buffers, and restart from fresh. Might help with unseekable streams that are going out of sync. This command might be changed or removed in the future. Return a screenshot in memory. This can be used only through the client API. The MPV_FORMAT_NODE_MAP returned by this command has the , , fields set to obvious contents. The field is set to by default. This format is organized as (where is the LSB). The contents of the padding are undefined. The field is of type MPV_FORMAT_BYTE_ARRAY with the actual image data. The image is freed as soon as the result mpv_node is freed. As usual with client API semantics, you are not allowed to write to the image data. The is the number of bytes from a pixel at to the pixel at . This can be larger than if the image was cropped, or if there is padding. This number can be negative as well. You access a pixel with (assuming the format). The argument is like the first argument to and supports , , . Send a command to the filter. Note that currently, this only works with the filter. Refer to the libavfilter documentation for the list of supported commands for each filter. is a mpv filter label, use to send it to all filters at once. is a filter or filter instance name and defaults to . Note that the target is an additional specifier for filters that support them, such as complex filter chains. Same as , but for audio filters. Apply the contents of a named profile. This is like using in a config file, except you can map it to a key binding to change it at runtime. Apply the profile. Default if the argument is omitted. Restore options set by a previous command for this profile. Only works if the profile has set to a relevant mode. Prints a warning if nothing could be done. See Runtime profiles for details. Load a configuration file, similar to the option. If the file was already included, its previous options are not reset before it is reparsed. Load an input configuration file, similar to the option. If the file was already included, its previous bindings are not reset before it is reparsed. Load a script, similar to the option. Whether this waits for the script to finish initialization or not changed multiple times, and the future behavior is left undefined. On success, returns a with a field set to the return value of the API call of the newly created script handle. This command changes list options as described in List Options. The parameter is the normal option name, while is the suffix or action used on the option. Some operations take no value, but the command still requires the value parameter. In these cases, the value must be an empty string. Add a filename to the list. The command line equivalent is or alternatively . Dump the current cache to the given filename. The file is overwritten if it already exists. and give the time range of what to dump. If no data is cached at the given time range, nothing may be dumped (creating a file with no packets). Dumping a larger part of the cache will freeze the player. No effort was made to fix this, as this feature was meant mostly for creating small excerpts. See for various caveats that mostly apply to this command too, as both use the same underlying code for writing the output file. If is an empty string, an ongoing is stopped. If is , then continuous dumping is enabled. Then, after dumping the existing parts of the cache, anything read from network is appended to the cache as well. This behaves similar to (although it does not conflict with that option, and they can be both active at the same time). If the time is after the cache, the command will _not_ wait and write newly received data to it. The end of the resulting file may be slightly damaged or incomplete at the end. (Not enough effort was made to ensure that the end lines up properly.) Note that this command will finish only once dumping ends. That means it works similar to the command, just that it can block much longer. If continuous dumping is used, the command will not finish until playback is stopped, an error happens, another command is run, or an API like was called to explicitly stop the command. See Synchronous vs. Asynchronous. This was mostly created for network streams. For local files, there may be much better methods to create excerpts and such. There are tons of much more user-friendly Lua scripts, that will re-encode parts of a file by spawning a separate instance of . With network streams, this is not that easily possible, as the stream would have to be downloaded again. Even if is used to record the stream to the local filesystem, there may be problems, because the recorded file is still written to. This command is experimental, and all details about it may change in the future. Essentially calls with the current AB-loop points as arguments. Like , this will overwrite the file at . Likewise, if the B point is set to , it will enter continuous dumping after the existing cache was dumped. The author reserves the right to remove this command if enough motivation is found to move this functionality to a trivial Lua script. Re-adjust the A/B loop points to the start and end within the cache the command will (probably) dump. Basically, it aligns the times on keyframes. The guess might be off especially at the end (due to granularity issues due to remuxing). If the cache shrinks in the meantime, the points set by the command will not be the effective parameters either. This command has an even more uncertain future than and might disappear without replacement if the author decides it's useless. Begin window dragging if supported by the current VO. This command should only be called while a mouse button is being pressed, otherwise it will be ignored. The exact effect of this command depends on the VO implementation of window dragging. For example, on Windows only the left mouse button can begin window dragging, while X11 and Wayland allow other mouse buttons. This is a partial list of events. This section describes what returns, and which is what scripting APIs and the JSON IPC sees. Note that the C API has separate C-level declarations with , which may be slightly different. Note that events are asynchronous: the player core continues running while events are delivered to scripts and other clients. In some cases, you can use hooks to enforce synchronous execution. All events can have the following fields: Name as the event (as returned by ). The field (opaque user value). If is 0, the field is not added. Set to an error string (as returned by ). This field is missing if no error happened, or the event type does not report error. Most events leave this unset. This list uses the event name field value, and the C API symbol in brackets: Happens right before a new file is loaded. When you receive this, the player is loading the file (or possibly already done with it). This has the following fields: Playlist entry ID of the file being loaded now. Happens after a file was unloaded. Typically, the player will load the next file right away, or quit if this was the last file. The event has the following fields: The file has ended. This can (but doesn't have to) include incomplete files or broken network connections under circumstances. Playback was ended by sending the quit command. An error happened. In this case, an field is present with the error string. Happens with playlists and similar. Details see in the C API. Unknown. Normally doesn't happen, unless the Lua API is out of sync with the C API. (Likewise, it could happen that your script gets reason strings that did not exist yet at the time your script was written.) Playlist entry ID of the file that was being played or attempted to be played. This has the same value as the field in the corresponding event. Set to mpv error string describing the approximate reason why playback failed. Unset if no error known. (In Lua scripting, this value was set on the field directly. This is deprecated since mpv 0.33.0. In the future, this field will be unset for this specific event.) If loading ended, because the playlist entry to be played was for example a playlist, and the current playlist entry is replaced with a number of other entries. This may happen at least with MPV_END_FILE_REASON_REDIRECT (other event types may use this for similar but different purposes in the future). In this case, playlist_insert_id will be set to the playlist entry ID of the first inserted entry, and playlist_insert_num_entries to the total number of inserted playlist entries. Note this in this specific case, the ID of the last inserted entry is playlist_insert_id+num-1. Beware that depending on circumstances, you may observe the new playlist entries before seeing the event (e.g. reading the \"playlist\" property or getting a property change notification before receiving the event). If this is 0 in the C API, this field isn't added. See playlist_insert_id. Only present if playlist_insert_id is present. Happens after a file was loaded and begins playback. Happens on seeking. (This might include cases when the player seeks internally, even without user interaction. This includes e.g. segment changes when playing ordered chapters Matroska files.) Start of playback after seek or after file was loaded. Sent when the player quits, and the script should terminate. Normally handled automatically. See Details on the script initialization and lifecycle. This contains, in addition to the default event fields, the following fields: The module prefix, identifies the sender of the message. This is what the terminal player puts in front of the message text when using the option, and is also what is used for . The log level as string. See for possible log level names. Note that later versions of mpv might add new levels or remove (undocumented) existing ones. The log message. The text will end with a newline character. Sometimes it can contain multiple lines. Keep in mind that these messages are meant to be hints for humans. You should not parse them, and prefix/level/text of messages might change any time. The event has the following fields: ID to pass to . The Lua scripting wrapper provides a better API around this with . This is one of the commands for which the field is meaningful. JSON IPC and Lua and possibly other backends treat this specially and may not pass the actual event to the user. See C API. The event has the following fields: The result (on success) of any type, if any. Lua and possibly other backends treat this specially and may not pass the actual event to the user. The event has the following fields: Array of strings with the message data. Happens on video output or filter reconfig. Happens on audio output or filter reconfig. Happens when a property that is being observed changes value. The event has the following fields: The name of the property. The new value of the property. The following events also happen, but are deprecated: , Use (Lua: ) instead. Hooks are synchronous events between player core and a script or similar. This applies to client API (including the Lua scripting interface). Normally, events are supposed to be asynchronous, and the hook API provides an awkward and obscure way to handle events that require stricter coordination. There are no API stability guarantees made. Not following the protocol exactly can make the player freeze randomly. Basically, nobody should use this API. The C API is described in the header files. The Lua API is described in the Lua section. Before a hook is actually invoked on an API clients, it will attempt to return new values for all observed properties that were changed before the hook. This may make it easier for an application to set defined \"barriers\" between property change notifications by registering hooks. (That means these hooks will have an effect, even if you do nothing and make them continue immediately.) The following hooks are currently defined: Called when a file is to be opened, before anything is actually done. For example, you could read and write the property to redirect an URL to something else (consider support for streaming sites which rarely give the user a direct media URL), or you could set per-file options with by setting the property . The player will wait until all hooks are run. Ordered after and before . Called after after a file has been opened, but failed to. This can be used to provide a fallback in case native demuxers failed to recognize the file, instead of always running before the native demuxers like . Demux will only be retried if was changed. If it fails again, this hook is _not_ called again, and loading definitely fails. Ordered after , and before and . Called after a file has been opened, and before tracks are selected and decoders are created. This has some usefulness if an API users wants to select tracks manually, based on the set of available tracks. It's also useful to initialize in a specific way by API, without having to \"probe\" the available streams at first. Note that this does not yet apply default track selection. Which operations exactly can be done and not be done, and what information is available and what is not yet available yet, is all subject to change. Ordered after etc. and before . Run before closing a file, and before actually uninitializing everything. It's not possible to resume playback in this state. Ordered before . Will also happen in the error case (then after ). Run before a event is sent. (If any client changes the current playlist entry, or sends a quit command to the player, the corresponding event will not actually happen after the hook returns.) Useful to drain property changes before a new file is loaded. Run after an event. Useful to drain property changes after a file has finished. These prefixes are placed between key name and the actual command. Multiple prefixes can be specified. They are separated by whitespace. Use the default behavior for this command. This is the default for commands. Some libmpv/scripting/IPC APIs do not use this as default, but use instead. Do not use any OSD for this command. If possible, show a bar with this command. Seek commands will show the progress bar, property changing commands may show the newly set value. If possible, show an OSD message with this command. Seek command show the current playback time, property changing commands show the newly set value as text. Do not expand properties in string arguments. (Like .) This is the default for some libmpv/scripting/IPC APIs. All string arguments are expanded as described in Property Expansion. This is the default for commands. For some commands, keeping a key pressed doesn't run the command repeatedly. This prefix forces enabling key repeat in any case. For a list of commands: the first command determines the repeatability of the whole list (up to and including version 0.33 - a list was always repeatable). For some commands, keeping a key pressed runs the command repeatedly. This prefix forces disabling key repeat in any case. Allow asynchronous execution (if possible). Note that only a few commands will support this (usually this is explicitly documented). Some commands are asynchronous by default (or rather, their effects might manifest after completion of the command). The semantics of this flag might change in the future. Set it only if you don't rely on the effects of this command being fully realized when it returns. See Synchronous vs. Asynchronous. Allow synchronous execution (if possible). Normally, all commands are synchronous by default, but some are asynchronous by default for compatibility with older behavior. All of the osd prefixes are still overridden by the global settings. The and prefix matter only for how the issuer of the command waits on the completion of the command. Normally it does not affect how the command behaves by itself. There are the following cases:\n• Normal input.conf commands are always run asynchronously. Slow running commands are queued up or run in parallel.\n• \"Multi\" input.conf commands (1 key binding, concatenated with ) will be executed in order, except for commands that are async (either prefixed with , or async by default for some commands). The async commands are run in a detached manner, possibly in parallel to the remaining sync commands in the list.\n• Normal Lua and libmpv commands (e.g. ) are run in a blocking manner, unless the prefix is used, or the command is async by default. This means in the sync case the caller will block, even if the core continues playback. Async mode runs the command in a detached manner.\n• Async libmpv command API (e.g. ) never blocks the caller, and always notify their completion with a message. The and prefixes make no difference.\n• Lua also provides APIs for running async commands, which behave similar to the C counterparts.\n• In all cases, async mode can still run commands in a synchronous manner, even in detached mode. This can for example happen in cases when a command does not have an asynchronous implementation. The async libmpv API still never blocks the caller in these cases. Before mpv 0.29.0, the prefix was only used by screenshot commands, and made them run the file saving code in a detached manner. This is the default now, and changes behavior only in the ways mentioned above. Currently the following commands have different waiting characteristics with sync vs. async: sub-add, audio-add, sub-reload, audio-reload, rescan-external-files, screenshot, screenshot-to-file, dump-cache, ab-loop-dump-cache. On the API level, every asynchronous command is bound to the context which started it. For example, an asynchronous command started by is bound to the passed to the function. Only this receives the completion notification ( ), and only this handle can abort a still running command directly. If the is destroyed, any still running async. commands started by it are terminated. The scripting APIs and JSON IPC give each script/connection its own implicit . If the player is closed, the core may abort all pending async. commands on its own (like a forced call for each pending command on behalf of the API user). This happens at the same time is sent, and there is no way to prevent this. Input sections group a set of bindings, and enable or disable them at once. In , each key binding is assigned to an input section, rather than actually having explicit text sections. See also: and commands. Bindings without input section are implicitly assigned to this section. It is enabled by default during normal playback. Section which is active in encoding mode. It is enabled exclusively, so that bindings in the sections are ignored. Properties are used to set mpv options during runtime, or to query arbitrary information. They can be manipulated with the / / commands, and retrieved with , or anything else that uses property expansion. (See Property Expansion.) The property name is annotated with RW to indicate whether the property is generally writable. If an option is referenced, the property will normally take/return exactly the same values as the option. In these cases, properties are merely a way to change an option at runtime. Most options can be set at runtime via properties as well. Just remove the leading from the option name. These are not documented below, see OPTIONS instead. Only properties which do not exist as option with the same name, or which have very different behavior from the options are documented below. Properties marked as (RW) are writeable, while those that aren't are read-only. Factor multiplied with at which the player attempts to play the file. Usually it's exactly 1. (Display sync mode will make this useful.) OSD formatting will display it in the form of , with the number being for the given raw property value. Whether is actually active. Currently played file, with path stripped. If this is an URL, try to undo percent encoding as well. (The result is not necessarily correct, but looks better for display purposes. Use the property to get an unmodified filename.) Like the property, but if the text contains a , strip all text after the last . Usually this removes the file extension. Length in bytes of the source file/stream. (This is the same as . For segmented/multi-part files, this will return the size of the main or manifest file, whatever it is.) This is only an estimate. (It's computed from two unreliable quantities: fps and stream length.) This is only an estimate. (It's computed from two unreliable quantities: fps and possibly rounded timestamps.) Full path of the currently played file. Usually this is exactly the same string you pass on the mpv command line or the command, even if it's a relative path. If you expect an absolute path, you will have to determine it yourself, for example by using the property. The full path to the currently played media. This is different from only in special cases. In particular, if is used, and the URL is detected by , then the script will set this property to the actual media URL. This property should be set only during the or hooks, otherwise it will have no effect (or may do something implementation defined in the future). The property is reset if playback of the current media ends. If the currently played file has a tag, use that. Symbolic name of the file format. In some cases, this is a comma-separated list of format names, e.g. mp4 is (the list may grow in the future for any format). Name of the current demuxer. (This is useless.) Filename (full path) of the stream layer filename. (This is probably useless and is almost never different from .) Raw byte position in source stream. Technically, this returns the position of the most recent packet passed to a decoder. Duration of the current file in seconds. If the duration is unknown, the property is unavailable. Note that the file duration is not always exactly known, so this is an estimate. This replaces the property, which was deprecated after the mpv 0.9 release. (The semantics are the same.) Last A/V synchronization difference. Unavailable if audio or video is disabled. Total A-V sync correction done. Unavailable if audio or video is disabled. Video frames dropped by decoder, because video is too far behind audio (when using ). Sometimes, this may be incremented in other situations, e.g. when video packets are damaged, or the decoder doesn't follow the usual rules. Unavailable if video is disabled. Frames dropped by VO (when using ). Number of video frames that were not timed correctly in display-sync mode for the sake of keeping A/V sync. This does not include external circumstances, such as video rendering being too slow or the graphics driver somehow skipping a vsync. It does not include rounding errors either (which can happen especially with bad source timestamps). For example, using the mode should never change this value from 0. For how many vsyncs a frame is displayed on average. This is available if display-sync is active only. For 30 FPS video on a 60 Hz screen, this will be 2. This is the moving average of what actually has been scheduled, so 24 FPS on 60 Hz will never remain exactly on 2.5, but jitter depending on the last frame displayed. Estimated number of frames delayed due to external circumstances in display-sync mode. Note that in general, mpv has to guess that this is happening, and the guess can be inaccurate. Position in current file (0-100). The advantage over using this instead of calculating it out of other properties is that it properly falls back to estimating the playback position from the byte position, if the file duration is not known. Deprecated. Always returns 0. Before mpv 0.14, this used to return the start time of the file (could affect e.g. transport streams). See option. Remaining length of the file in seconds. Note that the file duration is not always exactly known, so this is an estimate. Current audio playback position in current file in seconds. Unlike , this updates more often than once per frame. This is mostly equivalent to for audio-only files however it also takes into account the audio driver delay. This can lead to negative values in certain cases, so in general you probably want to simply use . Prior to mpv 0.39.0, and could report different values in certain edge cases. How many more times the current file is going to be looped. This is initialized from the value of . This counts the number of times it causes the player to seek to the beginning of the file, so it is 0 the last the time is played. -1 corresponds to infinity. How many more times the current A-B loop is going to be looped, if one is active. This is initialized from the value of . This counts the number of times it causes the player to seek to , so it is 0 the last the time the loop is played. -1 corresponds to infinity. Current chapter number. The number of the first chapter is 0. Current MKV edition number. Setting this property to a different value will restart playback. The number of the first edition is 0. Before mpv 0.31.0, this showed the actual edition selected at runtime, if you didn't set the option or property manually. With mpv 0.31.0 and later, this strictly returns the user-set option or property value, and the property was added to return the runtime selected edition (this matters with , the default). Currently selected edition. This property is unavailable if no file is loaded, or the file has no editions. (Matroska files make a difference between having no editions and a single edition, which will be reflected by the property, although in practice it does not matter.) List of editions, current entry marked. Currently, the raw property value is useless. This has a number of sub-properties. Replace with the 0-based edition index. Number of editions. If there are no editions, this can be 0 or 1 (1 if there's a useless dummy edition). Edition ID as integer. Use this to set the property. Currently, this is the same as the edition index. Whether this is the default edition. Edition title as stored in the file. Not always available. When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: If the property is accessed with Lua's , this returns a table with metadata keys mapping to metadata values. If it is accessed with the client API, this returns a , with tag keys mapping to tag values. For OSD, it returns a formatted list. Trying to retrieve this property as a raw string doesn't work. This has a number of sub-properties: Key name of the Nth metadata entry. (The first entry is ). Value of the Nth metadata entry. Old version of . Use is discouraged, because the metadata key string could conflict with other sub-properties. The layout of this property might be subject to change. Suggestions are welcome how exactly this property should work. When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: MPV_FORMAT_NODE_MAP (key and string value for each metadata entry) Like , but includes only fields listed in the option. This is the same set of tags that is printed to the terminal. Metadata of current chapter. Works similar to property. It also allows the same access methods (using sub-properties). Per-chapter metadata is very rare. Usually, only the chapter name ( ) is set. For accessing other information, like chapter start, see the property. Metadata added by video filters. Accessed by the filter label, which, if not explicitly specified using the syntax, will be . Works similar to property. It allows the same access methods (using sub-properties). An example of this kind of metadata are the cropping parameters added by . Equivalent to , but for audio filters. Returns /true if mpv's deinterlacing filter is active. Note that it will not detect any manually inserted deinterlacing filters done via . Returns /true if no file is loaded, but the player is staying around because of the option. Whether the playback core is paused. This can differ from in special situations, such as when the player pauses itself due to low network cache. This also returns /true if playback is restarting or if nothing is playing at all. In other words, it's only /false if there's actually video playing. (Behavior since mpv 0.7.0.) Current I/O read speed between the cache and the lower layer (like network). This gives the number bytes per seconds over a 1 second window (using the type for the client API). This is the same as . Approximate duration of video buffered in the demuxer, in seconds. The guess is very unreliable, and often the property will not be available at all, even if data is buffered. Approximate time of video buffered in the demuxer, in seconds. Same as but returns the last timestamp of buffered data in demuxer. Whether the demuxer is idle, which means that the demuxer cache is filled to the requested amount, and is currently not reading more data. Each entry in represents a region in the demuxer cache that can be seeked to, with a and fields containing the respective timestamps. If there are multiple demuxers active, this only returns information about the \"main\" demuxer, but might be changed in future to return unified information about all demuxers. The ranges are in arbitrary order. Often, ranges will overlap for a bit, before being joined. In broken corner cases, ranges may overlap all over the place. The end of a seek range is usually smaller than the value returned by the property, because that property returns the guessed buffering amount, while the seek ranges represent the buffered data that can actually be used for cached seeking. indicates whether the seek range with the lowest timestamp points to the beginning of the stream (BOF). This implies you cannot seek before this position at all. indicates whether the seek range with the highest timestamp points to the end of the stream (EOF). If both and are true, and there's only 1 cache range, the entire stream is cached. is the number of bytes of packets buffered in the range starting from the current decoding position. This is a rough estimate (may not account correctly for various overhead), and stops at the demuxer position (it ignores seek ranges after it). is the number of bytes stored in the file cache. This includes all overhead, and possibly unused data (like pruned data). This member is missing if the file cache wasn't enabled with . is the approximate timestamp of the start of the buffered range. Missing if unavailable. is the estimated input rate of the network layer (or any other byte-oriented input layer) in bytes per second. May be inaccurate or missing. is an array containing an entry for each stream type: video, audio, and subtitle. For each stream type, the details for the demuxer cache for that stream type are available as , and . When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: Other fields (might be changed or removed in the future): Whether the reader thread has hit the end of the file. Whether the reader thread could not satisfy a decoder's request for a new packet. Whether the thread is currently not reading. Sum of packet bytes (plus some overhead estimation) of the entire packet queue, including cached seekable ranges. Whether the stream demuxed via the main demuxer is most likely played via network. What constitutes \"network\" is not always clear, might be used for other types of untrusted streams, could be wrong in certain cases, and its definition might be changing. Also, external files (like separate audio files or streams) do not influence the value of this property (currently). The start time reported by the demuxer in fractional seconds. Whether playback is paused because of waiting for the cache. The percentage (0-100) of the cache fill status until the player will unpause (related to ). Whether the end of playback was reached. Note that this is usually interesting only if is enabled, since otherwise the player will immediately play the next file (or exit or enter idle mode), and in these cases the property will logically be cleared immediately after it's set. Whether the player is currently seeking, or otherwise trying to restart playback. (It's possible that it returns /true while a file is loaded. This is because the same underlying code is used for seeking and resyncing.) Whether the audio mixer is active. This option is relatively useless. Before mpv 0.18.1, it could be used to infer behavior of the property. System volume. This property is available only if mpv audio output is currently active, and only if the underlying implementation supports volume control. What this option does depends on the API. For example, on ALSA this usually changes system-wide audio, while with PulseAudio this controls per-application volume. Similar to , but controls the mute state. May be unimplemented even if works. Audio format as output by the audio decoder. This has a number of sub-properties: The sample format as string. This uses the same names as used in other places of mpv. The channel layout as a string. This is similar to what the accepts. As , but instead of the possibly cryptic actual layout sent to the audio device, return a hopefully more human readable form. (Usually only makes sense.) Number of audio channels. This is redundant to the field described above. When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: Same as , but the format of the data written to the audio API. Redirects to . This parameter (as well as similar ones) can be overridden with the video filter. Writing to it may change the currently used hardware decoder, if possible. (Internally, the player may reinitialize the decoder, and will perform a seek to refresh the video properly.) You can watch the other hwdec properties to see whether this was successful. Unlike in mpv 0.9.x and before, this does not return the currently active hardware decoder. Since mpv 0.18.0, is available for this purpose. The current hardware decoding in use. If decoding is active, return one of the values used by the option/property. /false indicates software decoding. If no decoder is loaded, the property is unavailable. This returns the currently loaded hardware decoding/output interop driver. This is known only once the VO has opened (and possibly later). With some VOs (like ), this might be never known in advance, but only when the decoder attempted to create the hw decoder successfully. (Using can load it eagerly.) If there are multiple drivers loaded, they will be separated by . If no VO is active or no interop driver is known, this property is unavailable. This does not necessarily use the same values as . There can be multiple interop drivers for the same hardware decoder, depending on platform and VO. Video size. This uses the size of the video as decoded, or if no video frame has been decoded yet, the (possibly incorrect) container indicated size. Video parameters, as output by the decoder (with overrides like aspect etc. applied). This has a number of sub-properties: The pixel format as string. This uses the same names as used in other places of mpv. The underlying pixel format as string. This is relevant for some cases of hardware decoding and unavailable otherwise. Average bits-per-pixel as integer. Subsampled planar formats use a different resolution, which is the reason this value can sometimes be odd or confusing. Can be unavailable with some formats. Video size as integers, with no aspect correction applied. Display aspect ratio name as string. The name corresponds to motion picture film format that introduced given aspect ratio in film. The colormatrix in use as string. (Exact values subject to change.) The colorlevels as string. (Exact values subject to change.) The primaries in use as string. (Exact values subject to change.) The gamma function in use as string. (Exact values subject to change.) The light type in use as a string. (Exact values subject to change.) Alpha type. If the format has no alpha channel, this will be unavailable (but in future releases, it could change to ). If alpha is present, this is set to or . Minimum luminance, as reported by HDR10 metadata (in cd/m²) Maximum luminance, as reported by HDR10 metadata (in cd/m²) Maximum content light level, as reported by HDR10 metadata (in cd/m²) Maximum frame average light level, as reported by HDR10 metadata (in cd/m²) MaxRGB of a scene for R component, as reported by HDR10+ metadata (in cd/m²) MaxRGB of a scene for G component, as reported by HDR10+ metadata (in cd/m²) MaxRGB of a scene for B component, as reported by HDR10+ metadata (in cd/m²) Maximum PQ luminance of a frame, as reported by peak detection (in PQ, 0-1) Average PQ luminance of a frame, as reported by peak detection (in PQ, 0-1) When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: Video display size. This is the video size after filters and aspect scaling have been applied. The actual video window size can still be different from this, e.g. if the user resized the video window manually. These have the same values as and . Exactly like , but no overrides applied. Same as , but after video filters have been applied. If there are no video filters in use, this will contain the same values as . Note that this is still not necessarily what the video window uses, since the user can change the window size, and all real VOs do their own scaling independently from the filter chain. Has the same sub-properties as . Same as , but with the target properties that VO outputs to. Has the same sub-properties as . Approximate information of the current frame. Note that if any of these are used on OSD, the information might be off by a few frames due to OSD redrawing and frame display being somewhat disconnected, and you might have to pause and force a redraw. This has a number of sub-properties: The type of the picture. It can be \"I\" (intra), \"P\" (predicted), \"B\" (bi-dir predicted) or unavailable. Whether the content of the frame is interlaced. If the content is interlaced, whether the top field is displayed first. Whether the frame must be delayed when decoding. Container FPS. This can easily contain bogus values. For videos that use modern container formats or video codecs, this will often be incorrect. Estimated/measured FPS of the video filter chain output. (If no filters are used, this corresponds to decoder output.) This uses the average of the 10 past frame durations to calculate the FPS. It will be inaccurate if frame-dropping is involved (such as when framedrop is explicitly enabled, or after precise seeking). Files with imprecise timestamps (such as Matroska) might lead to unstable results. The value calculated from the current window size. This has the same value as if the window size was not changed since setting the option, and the window size was not restricted in other ways. If the window is fullscreened, this will return the scale value calculated from the last non-fullscreen size of the window. The property is unavailable if no video is active. It is also possible to write to this property. This has the same behavior as writing . Note that writing to will not affect the value of . Whether the window has focus. Might not be supported by all VOs. Names of the displays that the mpv window covers. On X11, these are the xrandr names (LVDS1, HDMI1, DP1, VGA1, etc.). On Windows, these are the GDI names (\\.DISPLAY1, \\.DISPLAY2, etc.) and the first display in the list will be the one that Windows considers associated with the window (as determined by the MonitorFromWindow API.) On macOS these are the Display Product Names as used in the System Information with a serial number in brackets and only one display name is returned since a window can only be on one screen. On Wayland, these are the wl_output names if protocol version >= 4 is used (LVDS-1, HDMI-A-1, X11-1, etc.), or the wl_output model reported by the geometry event if protocol version < 4 is used. The refresh rate of the current display. Currently, this is the lowest FPS of any display covered by the video, as retrieved by the underlying system APIs (e.g. xrandr on X11). It is not the measured FPS. It's not necessarily available on all platforms. Note that any of the listed facts may change any time without a warning. The actual rate at which display refreshes seem to occur, measured by system time. Only available if display-sync mode (as selected by ) is active. The current display's horizontal and vertical resolution in pixels. Whether or not these values update as the mpv window changes displays depends on the windowing backend. It may not be available on all platforms. The HiDPI scale factor as reported by the windowing backend. If no VO is active, or if the VO does not report a value, this property is unavailable. It may be saner to report an absolute DPI, however, this is the way HiDPI support is implemented on most OS APIs. See also . Last known OSD width (can be 0). This is needed if you want to use the command. It gives you the actual OSD/window size (not including decorations drawn by the OS window manager). Last known OSD display pixel aspect (can be 0). Has the following sub-properties (which can be read as or Lua table with ): Size of the VO window in OSD render units (usually pixels, but may be scaled pixels with VOs like ). Size of the VO window in OSD render units, Pixel aspect ratio of the OSD (usually 1). Display aspect ratio of the VO window. (Computing from the properties above.) OSD to video margins (top, bottom, left, right). This describes the area into which the video is rendered. Any of these properties may be unavailable or set to dummy values if the VO window is not created or visible. This has two sub-properties. width of the terminal in cells height of the terminal in cells This property is not observable. Reacting to size changes requires polling. Read-only - mpv's window id. May not always be available, i.e due to window not being opened yet or not being supported by the VO. Read-only - last known mouse position, normalized to OSD dimensions. Has the following sub-properties (which can be read as or Lua table with ): Last known coordinates of the mouse pointer. Boolean - whether the mouse pointer hovers the video window. The coordinates should be ignored when this value is false, because the video backends update them only when the pointer hovers the window. Read-only - last known touch point positions, normalized to OSD dimensions. This has a number of sub-properties. Replace with the 0-based touch point index. Whenever a new finger touches the screen, a new touch point is added to the list of touch points with the smallest unused available. Unique identifier of the touch point. This can be used to identify individual touch points when their indexes change. When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: The current ASS subtitle track's extradata. There is no formatting done. The extradata is returned as a string as-is. This property is not available for non-ASS subtitle tracks. The current subtitle text regardless of sub visibility. Formatting is stripped. If the subtitle is not text-based (i.e. DVD/BD subtitles), an empty string is returned. This has sub-properties for different formats: Like , but return the text in ASS format. Text subtitles in other formats are converted. For native ASS subtitles, events that do not contain any text (but vector drawings etc.) are not filtered out. If multiple events match with the current playback time, they are concatenated with line breaks. Contains only the \"Text\" part of the events. This property is not enough to render ASS subtitles correctly, because ASS header and per-event metadata are not returned. Use for that. Like , but return the full event with all fields, formatted as lines in a .ass text file. Use with for style information. Same as (with the same sub-properties), but for the secondary subtitles. The current subtitle start time (in seconds). If there's multiple current subtitles, returns the first start time. If no current subtitle is present null is returned instead. Same as , but for the secondary subtitles. The current subtitle end time (in seconds). If there's multiple current subtitles, return the last end time. If no current subtitle is present, or if it's present but has unknown or incorrect duration, null is returned instead. Same as , but for the secondary subtitles. Current position on playlist. The first entry is on position 0. Writing to this property may start playback at the new position. In some cases, this is not necessarily the currently playing file. See explanation of and flags in . If there the playlist is empty, or if it's non-empty, but no entry is \"current\", this property returns -1. Likewise, writing -1 will put the player into idle mode (or exit playback if idle mode is not enabled). If an out of range index is written to the property, this behaves as if writing -1. (Before mpv 0.33.0, instead of returning -1, this property was unavailable if no playlist entry was current.) Writing the current value back to the property will have no effect. Use to restart the playback of the current entry if desired. Same as , but 1-based. Index of the \"current\" item on playlist. This usually, but not necessarily, the currently playing item (see ). Depending on the exact internal state of the player, it may refer to the playlist item to play next, or the playlist item used to determine what to play next. For reading, this is exactly the same as . For writing, this only sets the position of the \"current\" item, without stopping playback of the current file (or starting playback, if this is done in idle mode). Use -1 to remove the current flag. This property is only vaguely useful. If set during playback, it will typically cause the playlist entry after it to be played next. Another possibly odd observable state is that if is run during playback, this property is set to the playlist entry to play next (unlike the previous case). There is an internal flag that decides whether the current playlist entry or the next one should be played, and this flag is currently inaccessible for API users. (Whether this behavior will kept is possibly subject to change.) Index of the \"playing\" item on playlist. A playlist item is \"playing\" if it's being loaded, actually playing, or being unloaded. This property is set during the ( ) and the ( ) events. Outside of that, it returns -1. If the playlist entry was somehow removed during playback, but playback hasn't stopped yet, or is in progress of being stopped, it also returns -1. (This can happen at least during state transitions.) In the \"playing\" state, this is usually the same as , except during state changes, or if was written explicitly. The original path of the playlist for the current entry before mpv expanded the entries. Unavailable if the file was not originally associated with a playlist in some way. Playlist, current entry marked. Currently, the raw property value is useless. This has a number of sub-properties. Replace with the 0-based playlist entry index. Number of playlist entries (same as ). /true if the property points to this entry, /false or unavailable otherwise. /true if the property points to this entry, /false or unavailable otherwise. Name of the Nth entry. Available if the playlist file contains such fields and mpv's parser supports it for the given playlist format, or if the playlist entry has been opened before and a media-title other than filename has been acquired. Unique ID for this entry. This is an automatically assigned integer ID that is unique for the entire life time of the current mpv core instance. Other commands, events, etc. use this as fields. The original path of the playlist for this entry before mpv expanded it. Unavailable if the file was not originally associated with a playlist in some way. When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: MPV_FORMAT_NODE_ARRAY MPV_FORMAT_NODE_MAP (for each playlist entry) \"filename\" MPV_FORMAT_STRING \"current\" MPV_FORMAT_FLAG (might be missing; since mpv 0.7.0) \"playing\" MPV_FORMAT_FLAG (same) \"title\" MPV_FORMAT_STRING (optional) \"id\" MPV_FORMAT_INT64 List of audio/video/sub tracks, current entry marked. Currently, the raw property value is useless. This has a number of sub-properties. Replace with the 0-based track index. The ID as it's used for / / . This is unique within tracks of the same type (sub/audio/video), but otherwise not. String describing the media type. One of , , . Track ID as used in the source file. Not always available. (It is missing if the format has no native ID, if the track is a pseudo-track that does not exist in this way in the actual file, or if the format is handled by libavformat, and the format was not whitelisted as having track IDs.) Track title as it is stored in the file. Not always available. Track language as identified by the file. Not always available. /true if this is a video track that consists of a single picture, /false or unavailable otherwise. The heuristic used to determine if a stream is an image doesn't attempt to detect images in codecs normally used for videos. Otherwise, it is reliable. /true if this is an image embedded in an audio file or external cover art, /false or unavailable otherwise. /true if the track has the default flag set in the file, /false or unavailable otherwise. /true if the track has the forced flag set in the file, /false or unavailable otherwise. /true if the track has the dependent flag set in the file, /false or unavailable otherwise. /true if the track has the visual impaired flag set in the file, /false or unavailable otherwise. /true if the track has the hearing impaired flag set in the file, /false or unavailable otherwise. The bitrate of the HLS stream, if available. The program ID of the HLS stream, if available. The codec name used by this track, for example . Unavailable in some rare cases. The codec descriptive name used by this track. The codec profile used by this track. Available only if the track has been already decoded. /true if the track is an external file, /false or unavailable otherwise. This is set for separate subtitle files. The filename if the track is from an external file, unavailable otherwise. /true if the track is currently decoded, /false or unavailable otherwise. It indicates the selection order of tracks for the same type. If a track is not selected, or is selected by the , it is not available. For subtitle tracks, represents the , and represents the . The stream index as usually used by the FFmpeg utilities. Note that this can be potentially wrong if a demuxer other than libavformat ( ) is used. For mkv files, the index will usually match even if the default (builtin) demuxer is used, but there is no hard guarantee. If this track is being decoded, the short decoder name, If this track is being decoded, the human-readable decoder name, Video size hint as indicated by the container. (Not always accurate.) Number of audio channels as indicated by the container. (Not always accurate - in particular, the track could be decoded as a different number of channels.) Channel layout as indicated by the container. (Not always accurate.) Audio sample rate as indicated by the container. (Not always accurate.) Video FPS as indicated by the container. (Not always accurate.) Audio average bitrate, in bits per second. (Not always accurate.) Short name for format from ffmpeg. If the track is audio, this will be the name of the sample format. If the track is video, this will be the name of the pixel format. Per-track replaygain values. Only available for audio tracks with corresponding information stored in the source file. Per-album replaygain values. If the file has per-track but no per-album information, the per-album values will be copied from the per-track values currently. It's possible that future mpv versions will make these properties unavailable instead in this case. Dolby Vision profile and level. May not be available if the container does not provide this information. When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: This gives access to currently selected tracks. It redirects to the correct entry in . The following sub-entries are defined: , , , For example, returns the current audio track's language field (the same value as ). If tracks of the requested type are selected via , the first one is returned. List of chapters, current entry marked. Currently, the raw property value is useless. This has a number of sub-properties. Replace with the 0-based chapter index. Chapter title as stored in the file. Not always available. When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: See / and the / command. When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: MPV_FORMAT_NODE_ARRAY MPV_FORMAT_NODE_MAP (for each filter entry) \"name\" MPV_FORMAT_STRING \"label\" MPV_FORMAT_STRING [optional] \"enabled\" MPV_FORMAT_FLAG [optional] \"params\" MPV_FORMAT_NODE_MAP [optional] \"key\" MPV_FORMAT_STRING \"value\" MPV_FORMAT_STRING It's also possible to write the property using this format. Whether it's generally possible to seek in the current file. Whether the current file is considered seekable, but only because the cache is active. This means small relative seeks may be fine, but larger seeks may fail anyway. Whether a seek will succeed or not is generally not known in advance. If this property returns /true, so will . Whether playback is stopped or is to be stopped. (Useful in obscure situations like during hook processing, when the user can stop playback, but the script has to explicitly end processing.) See . Setting this to a new value will always update the cursor, and reset the internal timer. Inserts the current OSD symbol as opaque OSD control code (cc). This makes sense only with the command or options which set OSD messages. The control code is implementation specific and is useless for anything else. disables escaping ASS sequences of text in OSD, enables it again. By default, ASS sequences are escaped to avoid accidental formatting, and this property can disable this behavior. Note that the properties return an opaque OSD control code, which only makes sense for the command or options which set OSD messages. Any ASS override tags as understood by libass can be used. Note that you need to escape the character, because the string is processed for C escape sequences before passing it to the OSD code. See Flat command syntax for details. A list of tags can be found here: https://aegisub.org/docs/latest/ass_tags/ Whether the VO is configured right now. Usually this corresponds to whether the video window is visible. If the option is used, this usually always returns /true. Contains introspection about the VO's active render passes and their execution times. Not implemented by all VOs. This is further subdivided into two frame types, for fresh frames (which have to be uploaded, scaled, etc.) and for redrawn frames (which only have to be re-painted). The number of passes for any given subtype can change from frame to frame, and should not be relied upon. Each frame type has a number of further sub-properties. Replace with the frame type, with the 0-based pass index, and with the 0-based sample index. Average execution time of this pass, in nanoseconds. The exact timeframe varies, but it should generally be a handful of seconds. The peak execution time (highest value) within this averaging range, in nanoseconds. The number of samples for this pass. The raw execution time of a specific sample for this pass, in nanoseconds. When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: Note that directly accessing this structure via subkeys is not supported, the only access is through aforementioned . Further performance data. Querying this property triggers internal collection of some data, and may slow down the player. Each query will reset some internal state. Property change notification doesn't and won't work. All of this may change in the future, so don't use this. The builtin script is supposed to be the only user; since it's bundled and built with the source code, it can use knowledge of mpv internal to render the information properly. See script description for some details. Bitrate values calculated on the packet level. This works by dividing the bit size of all packets between two keyframes by their presentation timestamp distance. (This uses the timestamps are stored in the file, so e.g. playback speed does not influence the returned values.) In particular, the video bitrate will update only per keyframe, and show the \"past\" bitrate. To make the property more UI friendly, updates to these properties are throttled in a certain way. The unit is bits per second. OSD formatting turns these values in kilobits (or megabits, if appropriate), which can be prevented by using the raw property value, e.g. with . Note that the accuracy of these properties is influenced by a few factors. If the underlying demuxer rewrites the packets on demuxing (done for some file formats), the bitrate might be slightly off. If timestamps are bad or jittery (like in Matroska), even constant bitrate streams might show fluctuating bitrate. How exactly these values are calculated might change in the future. In earlier versions of mpv, these properties returned a static (but bad) guess using a completely different method. The list of discovered audio devices. This is mostly for use with the client API, and reflects what with the command line player returns. When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: MPV_FORMAT_NODE_ARRAY MPV_FORMAT_NODE_MAP (for each device entry) \"name\" MPV_FORMAT_STRING \"description\" MPV_FORMAT_STRING The is what is to be passed to the option (and often a rather cryptic audio API-specific ID), while is human readable free form text. The description is set to the device name (minus mpv-specific prefix) if no description is available or the description would have been an empty string. The special entry with the name set to selects the default audio output driver and the default device. The property can be watched with the property observation mechanism in the client API and in Lua scripts. (Technically, change notification is enabled the first time this property is read.) Set the audio device. This directly reads/writes the option, but on write accesses, the audio output will be scheduled for reloading. Writing this property while no audio output is active will not automatically enable audio. (This is also true in the case when audio was disabled due to reinitialization failure after a previous write access to .) This property also doesn't tell you which audio device is actually in use. How these details are handled may change in the future. Current video output driver (name as used with ). Current GPU context of video output driver (name as used with ). Valid for and . Current audio output driver (name as used with ). This is a recursive key/value map of arbitrary nodes shared between clients for general use (i.e. scripts, IPC clients, host applications, etc). The player itself does not use any data in it (although some builtin scripts may). The property is not preserved across player restarts. The following sub-paths are reserved for internal uses or have special semantics: , . Unless noted otherwise, the semantics of any properties under these sub-paths can change at any time and may not be relied upon, and writing to these properties may prevent builtin scripts from working properly. Currently, the following properties have defined special semantics: This property is written by an OSC implementation to indicate the margins that it occupies. Its sub-properties , , , and should all be set to the left, right, top, and bottom margins respectively. Values are between 0.0 and 1.0, normalized to window width/height. Sub-paths can be accessed directly; e.g. can be read, written, or observed. The top-level object itself cannot be written directly; write to sub-paths instead. Converting this property or its sub-properties to strings will give a JSON representation. If converting a leaf-level object (i.e. not a map or array) and not using raw mode, the underlying content will be given (e.g. strings will be printed directly, rather than quoted and JSON-escaped). Path to the ytdl executable, if found, or an empty string otherwise. The property is not set until the script attempts to find the ytdl executable, i.e. until an URL is being loaded by the script. Result of executing ytdl to retrieve the JSON data of the URL being loaded. The format is the same as 's result, capturing stdout and stderr. This property stores the raw menu definition. See Context Menu section for details. Menu item type. Can be: , , or empty. Menu item title. Required if type is not . Command to execute when the menu item is clicked. Menu item shortcut key which appears to the right of the menu item. A shortcut key does not have to be functional; it's just a visual hint. Menu item state. Can be: , , , or empty. Submenu items, which is required if type is . When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: Writing to this property with the client API using or with Lua will trigger an immediate update of the menu if mpv video output is currently active. You may observe the property to check if this is the case. The working directory of the mpv process. Can be useful for JSON IPC users, because the command line player usually works with relative paths. List of protocol prefixes potentially recognized by the player. They are returned without trailing suffix (which is still always required). In some cases, the protocol will not actually be supported (consider if ffmpeg is not compiled with TLS support). List of decoders supported. This lists decoders which can be passed to and . Canonical codec name, which identifies the format the decoder can handle. The name of the decoder itself. Often, this is the same as . Sometimes it can be different. It is used to distinguish multiple decoders for the same codec. Human readable description of the decoder and codec. When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: List of libavcodec encoders. This has the same format as . The encoder names ( entries) can be passed to and (without the prefix required by and ). List of available libavformat demuxers' names. This can be used to check for support for a specific format or use with . List of Key names, same as output by . The mpv version/copyright string. Depending on how the binary was built, it might contain either a release version, or just a git hash. The configuration arguments that were passed to the build system. If the meson version used to compile mpv is older than 1.1.0, then a hardcoded string of a few, arbitrary options is displayed instead. The contents of the API call. This is a string which identifies the build in some way, either through a release version number, or a git hash. This property is unavailable if mpv is linked against older FFmpeg versions. The value of . This is an integer, encoded in a somewhat weird form (apparently \"hex BCD\"), indicating the release version of the libass library linked to mpv. Returns a string describing what target platform mpv was built for. The value of this is dependent on what the underlying build system detects. Some of the most common values are: , (macos or ios), , , and . Note that this is not a complete listing. The value of option . Most options can be changed at runtime by writing to this property. Note that many options require reloading the file for changes to take effect. If there is an equivalent property, prefer setting the property instead. There shouldn't be any reason to access instead of , except in situations in which the properties have different behavior or conflicting semantics. Similar to , but when setting an option through this property, the option is reset to its old value once the current file has stopped playing. Trying to write an option while no file is playing (or is being loaded) results in an error. This has a number of sub-properties. Replace with the name of a top-level option. No guarantee of stability is given to any of these sub-properties - they may change radically in the feature. The name of the option. The name of the option type, like or . For many complex types, this isn't very accurate. Whether the option was set from the mpv command line. What this is set to if the option is e.g. changed at runtime is left undefined (meaning it could change in the future). Whether the option was set per-file. This is the case with automatically loaded profiles, file-dir configs, and other cases. It means the option value will be restored to the value before playback start when playback ends. Whether the option takes file paths as arguments. The default value of the option. May not always be available. Integer minimum and maximum values allowed for the option. Only available if the options are numeric, and the minimum/maximum has been set internally. It's also possible that only one of these is set. If the option is a choice option, the possible choices. Choices that are integers may or may not be included (they can be implied by and ). Note that options which behave like choice options, but are not actual choice options internally, may not have this info available. The list of profiles and their contents. This is highly implementation-specific, and may change any time. Currently, it returns an array of options for each profile. Each option has a name and a value, with the value currently always being a string. Note that the options array is not a map, as order matters and duplicate entries are possible. Recursive profiles are not expanded, and show up as special options. The field is currently missing if it holds the default value (either because it was not set, or set explicitly to ), but in the future it might hold the value . The list of input commands. This returns an array of maps, where each map node represents a command. This map currently only has a single entry: for the name of the command. (This property is supposed to be a replacement for . The option dumps some more information, but it's a valid feature request to extend this property if needed.) The list of current input key bindings. This returns an array of maps, where each map node represents a binding for a single key/command. This map has the following entries: The key name. This is normalized and may look slightly different from how it was specified in the source (e.g. in input.conf). The command mapped to the key. (Currently, this is exactly the same string as specified in the source, other than stripping whitespace and comments. It's possible that it will be normalized in the future.) If set to true, any existing and active user bindings will take priority. If this entry exists, the name of the script (or similar) which added this binding. Name of the section this binding is part of. This is a rarely used mechanism. This entry may be removed or change meaning in the future. A number. Bindings with a higher value are preferred over bindings with a lower value. If the value is negative, this binding is inactive and will not be triggered by input. Note that mpv does not use this value internally, and matching of bindings may work slightly differently in some cases. In addition, this value is dynamic and can change around at runtime. If available, the comment following the command on the same line. (For example, the input.conf entry would result in an entry with .) This property is read-only, and change notification is not supported. Currently, there is no mechanism to change key bindings at runtime, other than scripts adding or removing their own bindings. You can access (almost) all options as properties, though there are some caveats with some properties (due to historical reasons): While playback is active, these return the actually active tracks. For example, if you set , and the currently played file contains no audio track with ID 5, the property will return . Before mpv 0.31.0, you could set existing tracks at runtime only. This inconsistent behavior is deprecated. Post-deprecation, the reported value and the option value are cleanly separated ( for the option value). If you set the properties during playback, and the filter chain fails to reinitialize, the option will be set, but the runtime filter chain does not change. On the other hand, the next video to be played will fail, because the initial filter chain cannot be created. This behavior changed in mpv 0.31.0. Before this, the new value was rejected iff a video (for ) or an audio (for ) track was active. If playback was not active, the behavior was the same as the current one. The property is read-only and returns the current internal playlist. The option is for loading playlist during command line parsing. For client API uses, you should use the command instead. These are write-only, and will perform actions as they are written to, exactly as if they were used on the mpv CLI commandline. Their only use is when using libmpv before , which in turn is probably only useful in encoding mode. Normal libmpv users should use other mechanisms, such as the command, and the API function. Avoid these properties. All string arguments to input commands as well as certain options (like ) are subject to property expansion. Note that property expansion does not work in places where e.g. numeric parameters are expected. (For example, the command does not do property expansion. The command is an exception and not a general rule.) shows the filename of the current file when pressing the key Whether property expansion is enabled by default depends on which API is used (see Flat command syntax, Commands specified as arrays and Named arguments), but it can always be enabled with the prefix or disabled with the prefix, as described in Input Command Prefixes. The following expansions are supported: Expands to the value of the property . If retrieving the property fails, expand to an error string. (Use with a trailing to expand to an empty string instead.) If is prefixed with , expand to the raw value of the property (see section below). Expands to the value of the property , or if the property cannot be retrieved. is expanded recursively. Expands to (recursively) if the property is available. Expands to (recursively) if the property cannot be retrieved. Expands to (recursively) if the property expands to a string equal to . You can prefix with in order to compare the raw value of a property (see section below). If the property is unavailable, or other errors happen when retrieving it, the value is never considered equal. Note that can't contain any of the characters or . Also, it is possible that escaping with or might be added in the future, should the need arise. Same as with the variant, but is expanded if the value is not equal. (Using the same semantics as with .) Expands to . (To produce this character inside recursive expansion.) Disable property expansion and special handling of for the rest of the string. In places where property expansion is allowed, C-style escapes are often accepted as well. Example: Normally, properties are formatted as human-readable text, meant to be displayed on OSD or on the terminal. It is possible to retrieve an unformatted (raw) value from a property by prefixing its name with . These raw values can be parsed by other programs and follow the same conventions as the options associated with the properties. Additionally, there is a prefix to format human-readable text, with fixed precision for floating-point values. This is useful for printing values where a constant width is important.\n• expands to (if playback position is at 14 minutes 23 seconds)\n• expands to (same time, plus 400 milliseconds - milliseconds are normally not shown in the formatted case) Sometimes, the difference in amount of information carried by raw and formatted property values can be rather big. In some cases, raw values have more information, like higher precision than seconds with . Sometimes it is the other way around, e.g. shows track title and language in the formatted case, but only the track number if it is raw.\n\nmpv provides the built-in module , which contains functions to send commands to the mpv core and to retrieve information about playback state, user settings, file information, and so on. These scripts can be used to control mpv in a similar way to slave mode. Technically, the Lua code uses the client API internally. A script which leaves fullscreen mode when the player is paused: function on_pause_change(name, value) if value == true then mp.set_property(\"fullscreen\", \"no\") end end mp.observe_property(\"pause\", \"bool\", on_pause_change) Scripts can be passed to the option, and are automatically loaded from the subdirectory of the mpv configuration directory (usually ). A script can be a single file. The file extension is used to select the scripting backend to use for it. For Lua, it is . If the extension is not recognized, an error is printed. (If an error happens, the extension is either mistyped, or the backend was not compiled into your mpv binary.) mpv internally loads the script's name by stripping the extension and replacing all nonalphanumeric characters with . E.g., becomes . If there are several scripts with the same name, it is made unique by appending a number. This is the name returned by . Entries with extension are always ignored. If a script is a directory (either if a directory is passed to , or any sub-directories in the script directory, such as for example ), then the directory represents a single script. The player will try to load a file named , where is replaced with the file extension. For example, if exists, it is loaded with the Lua scripting backend. You must not put any other files or directories that start with into the script's top level directory. If the script directory contains for example both and , only one of them will be loaded (and which one depends on mpv internals that may change any time). Likewise, if there is for example , your script will break as soon as mpv adds a backend that uses the file extension. mpv also appends the top level directory of the script to the start of Lua's package path so you can import scripts from there too. Be aware that this will shadow Lua libraries that use the same package path. (Single file scripts do not include mpv specific directories in the Lua package path. This was silently changed in mpv 0.32.0.) Using a script directory is the recommended way to package a script that consists of multiple source files, or requires other files (you can use to get the location and e.g. load data files). Making a script a git repository, basically a repository which contains a file in the root directory, makes scripts easily updateable (without the dangers of auto-updates). Another suggestion is to use git submodules to share common files or libraries. Details on the script initialization and lifecycle Your script will be loaded by the player at program start from the configuration subdirectory, or from a path specified with the option. Some scripts are loaded internally (like ). Each script runs in its own thread. Your script is first run \"as is\", and once that is done, the event loop is entered. This event loop will dispatch events received by mpv and call your own event handlers which you have registered with , or timers added with or similar. Note that since the script starts execution concurrently with player initialization, some properties may not be populated with meaningful values until the relevant subsystems have initialized. When the player quits, all scripts will be asked to terminate. This happens via a event, which by default will make the event loop return. If your script got into an endless loop, mpv will probably behave fine during playback, but it won't terminate when quitting, because it's waiting on your script. Internally, the C code will call the Lua function after loading a Lua script. This function is normally defined by the default prelude loaded before your script (see in the mpv sources). The event loop will wait for events and dispatch events registered with . It will also handle timers added with and similar (by waiting with a timeout). Since mpv 0.6.0, the player will wait until the script is fully loaded before continuing normal operation. The player considers a script as fully loaded as soon as it starts waiting for mpv events (or it exits). In practice this means the player will more or less hang until the script returns from the main chunk (and is called), or the script calls or directly. This is done to make it possible for a script to fully setup event handlers etc. before playback actually starts. In older mpv versions, this happened asynchronously. With mpv 0.29.0, this changes slightly, and it merely waits for scripts to be loaded in this manner before starting playback as part of the player initialization phase. Scripts run though initialization in parallel. This might change again. The module is preloaded, although it can be loaded manually with . It provides the core client API. Run the given command. This is similar to the commands used in input.conf. See List of Input Commands. By default, this will show something on the OSD (depending on the command), as if it was used in . See Input Command Prefixes how to influence OSD usage per command. Returns on success, or on error. Similar to , but pass each command argument as separate parameter. This has the advantage that you don't have to care about quoting and escaping in some cases. These two commands are equivalent, except that the first version breaks if the filename contains spaces or certain special characters. Note that properties are not expanded. You can use either , the prefix, or the family of functions. Unlike , this will not use OSD by default either (except for some OSD-specific commands). Similar to , but pass the argument list as table. This has the advantage that in at least some cases, arguments can be passed as native types. It also allows you to use named argument. If the table is an array, each array item is like an argument in (but can be a native type instead of a string). If the table contains string keys, it's interpreted as command with named arguments. This requires at least an entry with the key to be present, which must be a string, and contains the command name. The special entry is optional, and if present, must be an array of Input Command Prefixes to apply. All other entries are interpreted as arguments. Returns a result table on success (usually empty), or on error. is the second parameter provided to the function, and is nil if it's missing. Like , but the command is ran asynchronously (as far as possible), and upon completion, fn is called. fn has three arguments: : Always a Boolean and is true if the command was successful, otherwise false. The result value (can be nil) in case of success, nil otherwise (as returned by ). The error string in case of an error, nil otherwise. Returns a table with undefined contents, which can be used as argument for . If starting the command failed for some reason, is returned, and is called indicating failure, using the same error value. is always called asynchronously, even if the command failed to start. Abort a call. The argument is the return value of that command (which starts asynchronous execution of the command). Whether this works and how long it takes depends on the command and the situation. The abort call itself is asynchronous. Does not return anything. Delete the given property. See and Properties for more information about properties. Most properties cannot be deleted. Returns true on success, or on error. Return the value of the given property as string. These are the same properties as used in input.conf. See Properties for a list of properties. The returned string is formatted similar to (see Property Expansion). Returns the string on success, or on error. is the second parameter provided to the function, and is nil if it's missing. Similar to , but return the property value formatted for OSD. This is the same string as printed with when used in input.conf. Returns the string on success, or on error. is the second parameter provided to the function, and is an empty string if it's missing. Unlike , assigning the return value to a variable will always result in a string. Similar to , but return the property value as Boolean. Returns a Boolean on success, or on error. Similar to , but return the property value as number. Note that while Lua does not distinguish between integers and floats, mpv internals do. This function simply request a double float from mpv, and mpv will usually convert integer property values to float. Returns a number on success, or on error. Similar to , but return the property value using the best Lua type for the property. Most time, this will return a string, Boolean, or number. Some properties (for example ) are returned as tables. Returns a value on success, or on error. Note that might be a possible, valid value too in some corner cases. Set the given property to the given string value. See and Properties for more information about properties. Returns true on success, or on error. Similar to , but set the given property to the given Boolean value. Similar to , but set the given property to the given numeric value. Note that while Lua does not distinguish between integers and floats, mpv internals do. This function will test whether the number can be represented as integer, and if so, it will pass an integer value to mpv, otherwise a double float. Similar to , but set the given property using its native type. Since there are several data types which cannot represented natively in Lua, this might not always work as expected. For example, while the Lua wrapper can do some guesswork to decide whether a Lua table is an array or a map, this would fail with empty tables. Also, there are not many properties for which it makes sense to use this, instead of , , . For these reasons, this function should probably be avoided for now, except for properties that use tables natively. Return the current mpv internal time in seconds as a number. This is basically the system time, with an arbitrary offset. Register callback to be run on a key binding. The binding will be mapped to the given , which is a string describing the physical key. This uses the same key names as in input.conf, and also allows combinations (e.g. ). If the key is empty or , no physical key is registered, but the user still can create own bindings (see below). After calling this function, key presses will cause the function to be called (unless the user remapped the key with another binding). However, if the key binding is canceled , the function will not be called, unless flag is set to , where the function will be called with the entry set to . For example, a canceled key binding can happen in the following situations:\n• If key A is pressed while key B is being held down, key B is logically released (\"canceled\" by key A), which stops the current autorepeat action key B has.\n• If key A is pressed while a mouse button is being held down, the mouse button is logically released, but the mouse button's action will not be called, unless flag is set to . The argument should be a short symbolic string. It allows the user to remap the key binding via input.conf using the command, and the name of the key binding (see below for an example). The name should be unique across other bindings in the same script - if not, the previous binding with the same name will be overwritten. You can omit the name, in which case a random name is generated internally. (Omitting works as follows: either pass for , or pass the argument in place of the name. The latter is not recommended and is handled for compatibility only.) The last argument is used for optional flags. This is a table, which can have the following entries: If set to , enables key repeat for this specific binding. This option only makes sense when is not set to . If set to , then is called on key down, repeat and up events, with the first argument being a table. This table has the following entries (and may contain undocumented ones): Set to one of the strings , , or (the latter if key up/down/repeat can't be tracked), which indicates the key's logical state. Boolean: Whether the event was caused by a mouse button. Boolean: Whether the event was canceled. Not all types of cancellations set this flag. The name of they key that triggered this, or if invoked artificially. If the key name is unknown, it's an empty string. Text if triggered by a text key, otherwise . See description of command for details (this field is equivalent to the 5th argument). Internally, key bindings are dispatched via the or input commands and . Trying to map multiple commands to a key will essentially prefer a random binding, while the other bindings are not called. It is guaranteed that user defined bindings in the central input.conf are preferred over bindings added with this function (but see ). This will print the message when was pressed. The user can remap these key bindings. Then the user has to put the following into their input.conf to remap the command to the key: This will print the message when the key is pressed. ( will still work, unless the user remaps it.) You can also explicitly send a message to a named script only. Assume the above script was using the filename : This works almost the same as , but registers the key binding in a way that will overwrite the user's custom bindings in their input.conf. ( overwrites default key bindings only, but not those by the user's input.conf.) Remove a key binding added with or . Use the same name as you used when adding the bindings. It's not possible to remove bindings for which you omitted the name. Call a specific function when an event happens. The event name is a string, and the function fn is a Lua function value. Some events have associated data. This is put into a Lua table and passed as argument to fn. The Lua table by default contains a field, which is a string containing the event name. If the event has an error associated, the field is set to a string describing the error, on success it's not set. If multiple functions are registered for the same event, they are run in registration order, which the first registered function running before all the other ones. Returns true if such an event exists, false otherwise. See Events and List of events for details. Undo . This removes all event handlers that are equal to the parameter. This uses normal Lua comparison, so be careful when dealing with closures. Watch a property for changes. If the property is changed, then the function will be called. can be , or be set to one of , , , , or . is the same as . For all other values, the new value of the property will be passed as second argument to , using to retrieve it. This means if is for example , is roughly called as in . If possible, change events are coalesced. If a property is changed a bunch of times in a row, only the last change triggers the change function. (The exact behavior depends on timing and other things.) If a property is unavailable, or on error, the value argument to is . (The call always succeeds, even if a property does not exist.) In some cases the function is not called even if the property changes. This depends on the property, and it's a valid feature request to ask for better update handling of a specific property. If the is or , the change function will be called sporadically even if the property doesn't actually change. You should therefore avoid using these types. You always get an initial change notification. This is meant to initialize the user's state to the current value of the property. Undo . This removes all property handlers that are equal to the parameter. This uses normal Lua comparison, so be careful when dealing with closures. Call the given function fn when the given number of seconds has elapsed. Note that the number of seconds can be fractional. For now, the timer's resolution may be as low as 50 ms, although this will be improved in the future. If the argument is set to or a truthy value, the timer will wait to be manually started with a call to its method. This is a one-shot timer: it will be removed when it's fired. Call the given function periodically. This is like , but the timer is re-added after the function fn is run. Returns a timer object. The timer object provides the following methods: Disable the timer. Does nothing if the timer is already disabled. This will remember the current elapsed time when stopping, so that essentially unpauses the timer. Disable the timer. Resets the elapsed time. will restart the timer. Restart the timer. If the timer was disabled with , this will resume at the time it was stopped. If the timer was disabled with , or if it's a previously fired one-shot timer (added with ), this starts the timer from the beginning, using the initially configured timeout. Whether the timer is currently enabled or was previously disabled (e.g. by or ). This field contains the current timeout period. This value is not updated as time progresses. It's only used to calculate when the timer should fire next when the timer expires. If you write this, you can call to reset the current timeout to the new one. ( won't use the new timeout.) Whether the timer is periodic ( ) or fires just once ( ). This value is used when the timer expires (but before the timer callback function fn is run). Note that these are methods, and you have to call them using instead of (Refer to https://www.lua.org/manual/5.2/manual.html#3.4.9 .) seconds = 0 timer = mp.add_periodic_timer(1, function() print(\"called every second\") # stop it after 10 seconds seconds = seconds + 1 if seconds >= 10 then timer:kill() end end) Return a setting from the option. It's up to the user and the script how this mechanism is used. Currently, all scripts can access this equally, so you should be careful about collisions. Return the name of the current script. The name is usually made of the filename of the script, with directory and file extension removed. If there are several scripts which would have the same name, it's made unique by appending a number. Any nonalphanumeric characters are replaced with . Return the directory if this is a script packaged as directory (see Script location for a description). Return nothing if this is a single file script. Show an OSD message on the screen. is in seconds, and is optional (uses by default). These also live in the module, but are documented separately as they are useful only in special situations. Calls and returns the read end of the wakeup pipe. This is deprecated, but still works. (See for details.) Return the relative time in seconds when the next timer ( and similar) expires. If there is no timer, return . This can be used to run custom event loops. If you want to have direct control what the Lua script does (instead of being called by the default event loop), you can set the global variable to your own function running the event loop. From your event loop, you should call to dequeue and dispatch mpv events. If the parameter is set to , the function will block until the next event is received or the next timer expires. Otherwise (and this is the default behavior), it returns as soon as the event loop is emptied. It's strongly recommended to use and if you're interested in properly working notification of new events and working timers. Register an event loop idle handler. Idle handlers are called before the script goes to sleep after handling all new events. This can be used for example to delay processing of property change events: if you're observing multiple properties at once, you might not want to act on each property change, but only when all change notifications have been received. Undo . This removes all idle handlers that are equal to the parameter. This uses normal Lua comparison, so be careful when dealing with closures. Set the minimum log level of which mpv message output to receive. These messages are normally printed to the terminal. By calling this function, you can set the minimum log level of messages which should be received with the event. See the description of this event for details. The level is a string, see for allowed log levels. This is a helper to dispatch or invocations to Lua functions. is called if or (with this script as destination) is run with as first parameter. The other parameters are passed to . If a message with the given name is already registered, it's overwritten. Used by , so be careful about name collisions. Undo a previous registration with . Does nothing if the wasn't registered. Create an OSD overlay. This is a very thin wrapper around the command. The function returns a table, which mostly contains fields that will be passed to . The parameter is used to initialize the field. The field contains the text to be used as overlay. For details, see the command. In addition, it provides the following methods: Commit the OSD overlay to the screen, or in other words, run the command with the current fields of the overlay table. Returns the result of the command itself. Remove the overlay from the screen. A call will add it again. The advantage of using this wrapper (as opposed to running directly) is that the field is allocated automatically. Returns a tuple of . The first two give the size of the OSD in pixels (for video outputs like , this may be \"scaled\" pixels). The third is the display pixel aspect ratio. May return invalid/nonsense values if OSD is not initialized yet. This module allows outputting messages to the terminal, and can be loaded with . The level parameter is the message priority. It's a string and one of , , , , , , . The user's settings will determine which of these messages will be visible. Normally, all messages are visible, except , and . The parameters after that are all converted to strings. Spaces are inserted to separate multiple parameters. You don't need to add newlines. All of these are shortcuts and equivalent to the corresponding call. mpv comes with a built-in module to manage options from config-files and the command-line. All you have to do is to supply a table with default options to the read_options function. The function will overwrite the default values with values found in the config-file and the command-line (in that order). A with key-value pairs. The type of the default values is important for converting the values read from the config file or command-line back. Do not use as a default value! The is used to identify the config-file and the command-line options. These needs to unique to avoid collisions with other scripts. Defaults to if the parameter is or missing. The parameter enables run-time updates of all matching option values via the option/property. If any of the matching options changes, the values in the (which was originally passed to the function) are changed, and is called. is a table where each updated option has a entry. There is no initial call. This never re-reads the config file. is always applied on the original config file, ignoring previous values (for example, if an option is removed from at runtime, the option will have the value in the config file). entries are only written for option values whose values effectively change (this is important if the script changes entries independently). The config file will be stored in in mpv's user folder. Comment lines can be started with # and stray spaces are not removed. Boolean values will be represented with yes/no. Command-line options are read from the parameter. To avoid collisions, all keys have to be prefixed with . This built-in module provides generic helper functions for Lua, and have strictly speaking nothing to do with mpv or video/audio playback. They are provided for convenience. Most compensate for Lua's scarce standard library. Be warned that any of these functions might disappear any time. They are not strictly part of the guaranteed API. Returns the directory that mpv was launched from. On error, is returned. Enumerate all entries at the given path on the filesystem, and return them as array. Each entry is a directory entry (without the path). The list is unsorted (in whatever order the operating system returns it). If the argument is given, it must be one of the following strings: List regular files only. This excludes directories, special files (like UNIX device files or FIFOs), and dead symlinks. It includes UNIX symlinks to regular files. List directories only, or symlinks to directories. and are not included. Include the results of both and . (This is the default.) List all entries, even device files, dead symlinks, FIFOs, and the and entries. Stats the given path for information and returns a table with the following entries: protection bits (on Windows, always 755 (octal) for directories and 644 (octal) for files) and are integers. Timestamps ( , and ) are integer seconds since the Unix epoch (Unix time). The booleans and are provided as a convenience; they can be and are derived from . On error (e.g. path does not exist), is returned. Split a path into directory component and filename component, and return them. The first return value is always the directory. The second return value is the trailing part of the path, the directory entry. Return the concatenation of the 2 paths. Tries to be clever. For example, if is an absolute path, is returned without change. Runs an external process and waits until it exits. Returns process status and the captured output. This is a legacy wrapper around calling the command with . It does the following things:\n• copy to field if the string is non-empty It is recommended to use or directly, instead of calling this legacy wrapper. It is for compatibility only. See the documentation for semantics and further parameters. Runs an external process and detaches it from mpv's control. The parameter is a table. The function reads the following entries: Array of strings of the same semantics as the used in the function. This is a legacy wrapper around calling the command with and other functions. Returns the process ID of the running mpv process. This can be used to identify the calling mpv when launching (detached) subprocesses. Returns the C environment as a list of strings. (Do not confuse this with the Lua \"environment\", which is an unrelated concept.) Parses the given string argument as JSON, and returns it as a Lua table. On error, returns . (Currently, is just a string reading , because there is no fine-grained error reporting of any kind.) The returned value uses similar conventions as to distinguish empty objects and arrays. If the parameter is (or any value equal to ), then trailing non-whitespace text is tolerated by the function, and the trailing text is returned as 3rd return value. (The 3rd return value is always there, but with set, no error is raised.) Format the given Lua table (or value) as a JSON string and return it. On error, returns . (Errors usually only happen on value types incompatible with JSON.) The argument value uses similar conventions as to distinguish empty objects and arrays. Turn the given value into a string. Formats tables and their contents. This doesn't do anything special; it is only needed because Lua is terrible. This module lets scripts get textual input from the user using the console REPL. Show the console to let the user enter text. The following entries of are read: The string to be displayed before the input field. A callback invoked when the user presses Enter. The first argument is the text in the console. You can close the console from within the callback by calling . If you don't, the console stays open and the user can input more text. A callback invoked when the console is shown. This can be used to present a list of options with . A callback invoked when the text changes. The first argument is the text in the console. A callback invoked when the user presses TAB. The first argument is the text before the cursor. The callback should return a table of the string candidate completion values and the 1-based cursor position from which the completion starts. console.lua will filter the suggestions beginning with the the text between this position and the cursor, sort them alphabetically, insert their longest common prefix, and show them when there are multiple ones. A callback invoked when the console is hidden, either because was invoked from the other callbacks, or because the user closed it with a key binding. The first argument is the text in the console, and the second argument is the cursor position. A string to pre-fill the input field with. An identifier that determines which input history and log buffer to use among the ones stored for calls. The input histories and logs are stored in memory and do not persist across different mpv invocations. Defaults to the calling script name with appended. Add a line to the log buffer. can contain additional ASS tags to apply to , and can contain escape sequences that are used when the console is displayed in the terminal. Helper to add a line to the log buffer with the same color as the one the console uses for errors. Useful when the user submits invalid input. is a table of strings, or tables with , and keys. Specify a list of items that are presented to the user for selection. The user can type part of the desired item and/or navigate them with keybindings: and go down, and go up, and scroll down one page, and and scroll up one page. The following entries of are read: The string to be displayed before the input field. The table of the entries to choose from. The 1-based integer index of the preselected item. The callback invoked when the user presses Enter. The first argument is the 1-based index of the selected item. Unlike with , the console is automatically closed on submit without having to call . Events are notifications from player core to scripts. You can register an event handler with . Note that all scripts (and other parts of the player) receive events equally, and there's no such thing as blocking other scripts from receiving events. For the existing event types, see List of events. This documents experimental features, or features that are \"too special\" to guarantee a stable interface. Add a hook callback for (a string identifying a certain kind of hook). These hooks allow the player to call script functions and wait for their result (normally, the Lua scripting interface is asynchronous from the point of view of the player core). is an arbitrary integer that allows ordering among hooks of the same kind. Using the value 50 is recommended as neutral default value. is the function that will be called during execution of the hook. The parameter passed to it ( ) is a Lua object that can control further aspects about the currently invoked hook. It provides the following methods: Returning from the hook function should not automatically continue the hook. Instead, the API user wants to call on its own at a later point in time (before or after the function has returned). Continue the hook. Doesn't need to be called unless was called. See Hooks for currently existing hooks and what they do - only the hook list is interesting; handling hook execution is done by the Lua script function automatically."
    },
    {
        "link": "https://mpv.io/manual/master",
        "document": "Specify a prioritized list of audio languages to use, as IETF language tags. Equivalent ISO 639-1 two-letter and ISO 639-2 three-letter codes are treated the same. The first tag in the list that matches track's language in the file will be used. A track that matches more subtags will be preferred over one that matches fewer. See also . This is a string list option. See List Options for details.\n• chooses the Hungarian language track on a DVD and falls back on English if Hungarian is not available. This is a string list option. See List Options for details.\n• chooses the Hungarian subtitle track on a DVD and falls back on English if Hungarian is not available.\n• plays a Matroska file with Brazilian Portuguese subtitles if available, and otherwise any Portuguese subtitles. Equivalent to and , for video tracks. This is a string list option. See List Options for details. Select audio track. selects the default, disables audio. See also . mpv normally prints available audio tracks on the terminal when starting playback of a file. is an alias for . or disables audio playback. (The latter variant does not work with the client API.) The track selection options ( but also and the others) sometimes expose behavior that may appear strange. Also, the behavior tends to change around with each mpv release. The track selection properties will return the option value outside of playback (as expected), but during playback, the affective track selection is returned. For example, with , the property will suddenly return after playback initialization (assuming the file has at least 2 audio tracks, and the second is the default). At mpv 0.32.0 (and some releases before), if you passed a track value for which a corresponding track didn't exist (e.g. and there was only 1 audio track), the property returned . However if another audio track was added during playback, and you tried to set the property to , nothing happened, because the option still had the value , and writing the same value has no effect. With mpv 0.33.0, the behavior was changed. Now track selection options are reset to at playback initialization, if the option had tries to select a track that does not exist. The same is done if the track exists, but fails to initialize. The consequence is that unlike before mpv 0.33.0, the user's track selection parameters are clobbered in certain situations. Also since mpv 0.33.0, trying to select a track by number will strictly select this track. Before this change, trying to select a track which did not exist would fall back to track default selection at playback initialization. The new behavior is more consistent. Setting a track selection property at runtime, and then playing a new file might reset the track selection to defaults, if the fingerprint of the track list of the new file is different. Be aware of tricky combinations of all of all of the above: for example, would first play the correct track, and the second file without audio. If you then go back the first file, its first audio track will be played, and the second file is played with audio. If you do the same thing again but instead of using you run while the file is playing, then changing to the second file will play its audio track. This is because runtime selection enables the fingerprint heuristic. Most likely this is not the end. Display the subtitle stream specified by . selects the default, disables subtitles. is an alias for . or disables subtitle decoding. (The latter variant does not work with the client API.) is an alias for . or disables video playback. (The latter variant does not work with the client API.) If video is disabled, mpv will try to download the audio only if media is streamed with youtube-dl, because it saves bandwidth. This is done by setting the ytdl_format to \"bestaudio/best\" in the ytdl_hook.lua script. (Matroska files only) Specify the edition (set of chapters) to use, where 0 is the first. If set to (the default), mpv will choose the first edition declared as a default, or if there is no default, the first edition defined. Enable the default track auto-selection (default: yes). Enabling this will make the player select streams according to , , and others. If it is disabled, no tracks are selected. In addition, the player will not exit if no tracks are selected, and wait instead (this wait mode is similar to pausing, but the pause option is not set). This is useful with : you can start playback in this mode, and then set select tracks at runtime by setting the filter graph. Note that if is set before playback is started, the referenced tracks are always selected. When autoselecting a subtitle track, select it even if the selected audio stream matches you preferred subtitle language (default: yes). If this option is set to , then no subtitle track that matches the audio language will ever be autoselected by mpv regardless of or . If set to , then only forced subtitles will be selected. When autoselecting a subtitle track, select the track that matches the language of your OS if the audio stream is in a different language if suitable (default track or a forced track under the right conditions). Note that if is set, this will be completely ignored (default: yes). When autoselecting a subtitle track, if no tracks match your preferred languages, select a full track even if it doesn't match your preferred subtitle language (default: default). Setting this to means that only streams flagged as will be selected. When autoselecting a subtitle track, the default value of will prefer using a forced subtitle track if the subtitle language matches the audio language and matches your list of preferred languages. The special value will only select forced subtitle tracks and never fallback on a non-forced track. Conversely, will never select a forced subtitle track. The general format for times is . If the time is prefixed with , the time is considered relative from the end of the file (as signaled by the demuxer/the file). A is usually ignored (but see below). The following alternative time specifications are recognized: seeks to chapter number c. (Chapters start from 1.) resets any previously set option (useful for libmpv). If is given, then prefixing times with makes the time relative to the start of the file. A timestamp without prefix is considered an absolute time, i.e. should seek to a frame with a timestamp as the file contains it. As a bug, but also a hidden feature, putting 1 or more spaces before the or always interprets the time as absolute, which can be used to seek to negative timestamps (useful for debugging at most). Seeks to the middle of the file. Seeks to 3 minutes and 20 seconds before the end of the file, plays 10 seconds, and exits. Stop at given time. Use if the time should be relative to . See for valid option values and examples. Stop after a given time relative to the start time. See for valid option values and examples. If both and are provided, playback will stop when it reaches either of the two endpoints. Obscurity note: this does not work correctly if , and the specified time is not an \"absolute\" time, as defined in the option description. Whether to move the file start time to (default: yes). This is less awkward for files which start at a random timestamp, such as transport streams. On the other hand, if there are timestamp resets, the resulting behavior can be rather weird. For this reason, and in case you are actually interested in the real timestamps, this behavior can be disabled with . Slow down or speed up playback by the factor given as parameter. If (on by default) is used, playing with a speed higher than normal automatically inserts the audio filter. Raise or lower the audio's pitch by the factor given as parameter. Does not affect playback speed. Playing with an altered pitch automatically inserts the audio filter. Since pitch change is achieved by combining pitch-preserving speed change and resampling, the range of pitch change is effectively limited by the and parameters of : for example, a of 0.25 limits the highest pitch factor to 4 (1/0.25). In a standard 12-tone scale system, octaves are separated by a factor of 2 whereas semitones are represented by a factor of 2^(1/12). This means pitches can easily be shifted up or down with a simple multiplier. Shifts the pitch down an octave. Shifts the pitch up a perfect fifth. Shifts the pitch down a perfect fifth. Set which file on the internal playlist to start playback with. The index is an integer, with 0 meaning the first file. The value means that the selection of the entry to play is left to the playback resume mechanism (default). If an entry with the given index doesn't exist, the behavior is unspecified and might change in future mpv versions. The same applies if the playlist contains further playlists (don't expect any reasonable behavior). Passing a playlist file to mpv should work with this option, though. E.g. will work as expected, as long as does not link to further playlists. The value is a deprecated alias for . Play files according to a playlist file. Supports some common formats. If no format is detected, it will be treated as list of files, separated by newline characters. You may need this option to load plaintext files as a playlist. Note that XML playlist formats are not supported. This option forces to interpret the playlist file. Some playlist formats, notably CUE and optical disc formats, need to use different demuxers and will not work with this option. They still can be played directly, without using this option. You can play playlists directly, without this option. Before mpv version 0.31.0, this option disabled any security mechanisms that might be in place, but since 0.31.0 it uses the same security mechanisms as playing a playlist file directly. If you trust the playlist file, you can disable any security checks with . Because playlists can load other playlist entries, consider applying this option only to the playlist itself and not its entries, using something along these lines: The way older versions of mpv played playlist files via was not safe against maliciously constructed files. Such files may trigger harmful actions. This has been the case for all versions of mpv prior to 0.31.0, and all MPlayer versions, but unfortunately this fact was not well documented earlier, and some people have even misguidedly recommended the use of with untrusted sources. Do NOT use with random internet sources or files you do not trust if you are not sure your mpv is at least 0.31.0. In particular, playlists can contain entries using protocols other than local files, such as special protocols like (which are inherently unsafe). Threshold for merging almost consecutive ordered chapter parts in milliseconds (default: 100). Some Matroska files with ordered chapters have inaccurate chapter end timestamps, causing a small gap between the end of one chapter and the start of the next one when they should match. If the end of one playback part is less than the given threshold away from the start of the next one then keep playing video normally over the chapter change instead of doing a seek. Distance in seconds from the beginning of a chapter within which a backward chapter seek will go to the previous chapter (default: 5.0). Past this threshold, a backward chapter seek will go to the beginning of the current chapter instead. A negative value means always go back to the previous chapter. Select when to use precise seeks that are not limited to keyframes. Such seeks require decoding video from the previous keyframe up to the target position and so can take some time depending on decoding performance. For some video formats, precise seeks are disabled. This option selects the default choice to use for seeks; it is possible to explicitly override that default in the definition of key bindings and in input commands. Use precise seeks if the seek is to an absolute position in the file, such as a chapter seek, but not for relative seeks like the default behavior of arrow keys. Like , but enable hr-seeks in audio-only cases. The exact behavior is implementation specific and may change with new releases (default). Use precise seeks whenever possible. Same as (for compatibility). This option exists to work around failures to do precise seeks (as in ) caused by bugs or limitations in the demuxers for some file formats. Some demuxers fail to seek to a keyframe before the given target position, going to a later position instead. The value of this option is subtracted from the time stamp given to the demuxer. Thus, if you set this option to 1.5 and try to do a precise seek to 60 seconds, the demuxer is told to seek to time 58.5, which hopefully reduces the chance that it erroneously goes to some time later than 60 seconds. The downside of setting this option is that precise seeks become slower, as video between the earlier demuxer position and the real target may be unnecessarily decoded. Allow the video decoder to drop frames during seek, if these frames are before the seek target. If this is enabled, precise seeking can be faster, but if you're using video filters which modify timestamps or add new frames, it can lead to precise seeking skipping the target frame. This e.g. can break frame backstepping when deinterlacing is enabled. Controls how to seek in files. Note that if the index is missing from a file, it will be built on the fly by default, so you don't need to change this. But it might help with some broken files. use an index if the file has one, or build it if missing don't read or use the file's index This option only works if the underlying media supports seeking (i.e. not with stdin, pipe, etc). Load URLs from playlists which are considered unsafe (default: no). This includes special protocols and anything that doesn't refer to normal files. Local files and HTTP links on the other hand are always considered safe. In addition, if a playlist is loaded while this is set, the added playlist entries are not marked as originating from network or potentially unsafe location. (Instead, the behavior is as if the playlist entries were provided directly to mpv command line or command.) Follow any references in the file being opened (default: yes). Disabling this is helpful if the file is automatically scanned (e.g. thumbnail generation). If the thumbnail scanner for example encounters a playlist file, which contains network URLs, and the scanner should not open these, enabling this option will prevent it. This option also disables ordered chapters, mov reference files, opening of archives, and a number of other features. On older FFmpeg versions, this will not work in some cases. Some FFmpeg demuxers might not respect this option. This option does not prevent opening of paired subtitle files and such. Use to prevent this. This option does not always work if you open non-files (for example using would open a whole bunch of files in the given directory). Prefixing the filename with if it doesn't start with a will avoid this. Loops playback times. A value of plays it one time (default), two times, etc. means forever. is the same as and disables looping. If several files are specified on command line, the entire playlist is looped. is the same as . The mode is like , but does not skip playlist entries which have been marked as failing. This means the player might waste CPU time trying to loop a file that doesn't exist. But it might be useful for playing webradios under very bad network conditions. Loop a single file N times. means forever, means normal playback. For compatibility, and are also accepted, and are the same as . The difference to is that this doesn't loop the playlist, just the file itself. If the playlist contains only a single file, the difference between the two option is that this option performs a seek on loop, instead of reloading the file. counts the number of times it causes the player to seek to the beginning of the file, not the number of full playthroughs. This means will end up playing the file twice. Contrast with , which counts the number of full playthroughs. is an alias for this option. Set loop points. If playback passes the timestamp, it will seek to the timestamp. Seeking past the point doesn't loop (this is intentional). If is after , the behavior is as if the points were given in the right order, and the player will seek to after crossing through . This is different from old behavior, where looping was disabled (and as a bug, looped back to on the end of the file). If either options are set to (or unset), looping is disabled. This is different from old behavior, where an unset implied the start of the file, and an unset the end of the file. The loop-points can be adjusted at runtime with the corresponding properties. See also command. Run A-B loops only N times, then ignore the A-B loop points (default: inf). means that looping goes on forever. If this option is set to 0, A-B looping is ignored, and even the command will not enable looping again (the command will show on the OSD message if both loop points are set, but is 0). Enable support for Matroska ordered chapters. mpv will load and search for video segments from other files, and will also respect any chapter order specified for the main file (default: yes). Loads the given file as playlist, and tries to use the files contained in it as reference files when opening a Matroska file that uses ordered chapters. This overrides the normal mechanism for loading referenced files by scanning the same directory the main file is located in. Useful for loading ordered chapter files that are not located on the local filesystem, or if the referenced files are in different directories. Note: a playlist can be as simple as a text file containing filenames separated by newlines. Load chapters from this file, instead of using the chapter metadata found in the main file. This accepts a media file (like mkv) or even a pseudo-format like ffmetadata and uses its chapters to replace the current file's chapters. This doesn't work with OGM or XML chapters directly. Without , skipping will snap to keyframes. Stop playback if either audio or video fails to initialize (default: no). With , playback will continue in video-only or audio-only mode if one of them fails. This doesn't affect playback of audio-only or video-only files. Control the playback direction (default: forward). Setting will attempt to play the file in reverse direction, with decreasing playback time. If this is set on playback starts, playback will start from the end of the file. If this is changed at during playback, a hr-seek will be issued to change the direction. and are aliases for and . The rest of this option description pertains to the mode. Backward playback is extremely fragile. It may not always work, is much slower than forward playback, and breaks certain other features. How well it works depends mainly on the file being played. Generally, it will show good results (or results at all) only if the stars align. mpv, as well as most media formats, were designed for forward playback only. Backward playback is bolted on top of mpv, and tries to make a medium effort to make backward playback work. Depending on your use-case, another tool may work much better. Backward playback is not exactly a 1st class feature. Implementation tradeoffs were made, that are bad for backward playback, but in turn do not cause disadvantages for normal playback. Various possible optimizations are not implemented in order to keep the complexity down. Normally, a media player is highly pipelined (future data is prepared in separate threads, so it is available in realtime when the next stage needs it), but backward playback will essentially stall the pipeline at various random points. For example, for intra-only codecs are trivially backward playable, and tools built around them may make efficient use of them (consider video editors or camera viewers). mpv won't be efficient in this case, because it uses its generic backward playback algorithm, that on top of it is not very optimized. If you just want to quickly go backward through the video and just show \"keyframes\", just use forward playback, and hold down the left cursor key (which on CLI with default config sends many small relative seek commands). The implementation consists of mostly 3 parts:\n• Backward demuxing. This relies on the demuxer cache, so the demuxer cache should (or must, didn't test it) be enabled, and its size will affect performance. If the cache is too small or too large, quadratic runtime behavior may result.\n• Backward decoding. The decoder library used (libavcodec) does not support this. It is emulated by feeding bits of data in forward, putting the result in a queue, returning the queue data to the VO in reverse, and then starting over at an earlier position. This can require buffering an extreme amount of decoded data, and also completely breaks pipelining.\n• Backward output. This is relatively simple, because the decoder returns the frames in the needed order. However, this may cause various problems because filters see audio and video going backward.\n• It's fragile. If anything doesn't work, random behavior may occur. In simple cases, the player will just play nonsense and artifacts. In other cases, it may get stuck or heat the CPU. (Exceeding memory usage significantly beyond the user-set limits would be a bug, though.)\n• Performance and resource usage isn't good. In part this is inherent to backward playback of normal media formats, and in parts due to implementation choices and tradeoffs.\n• This is extremely reliant on good demuxer behavior. Although backward demuxing requires no special demuxer support, it is required that the demuxer performs seeks reliably, fulfills some specific requirements about packet metadata, and has deterministic behavior.\n• Starting playback exactly from the end may or may not work, depending on seeking behavior and file duration detection.\n• Some container formats, audio, and video codecs are not supported due to their behavior. There is no list, and the player usually does not detect them. Certain live streams (including TV captures) may exhibit problems in particular, as well as some lossy audio codecs. h264 intra-refresh is known not to work due to problems with libavcodec. WAV and some other raw audio formats tend to have problems - there are hacks for dealing with them, which may or may not work.\n• Backward demuxing of subtitles is not supported. Subtitle display still works for some external text subtitle formats. (These are fully read into memory, and only backward display is needed.) Text subtitles that are cached in the subtitle renderer also have a chance to be displayed correctly.\n• Some features dealing with playback of broken or hard to deal with files will not work fully (such as timestamp correction).\n• If demuxer low level seeks (i.e. seeking the actual demuxer instead of just within the demuxer cache) are performed by backward playback, the created seek ranges may not join, because not enough overlap is achieved.\n• Trying to use this with hardware video decoding will probably exhaust all your GPU memory and then crash a thing or two. Or it will fail because will certainly be set too low.\n• Stream recording is broken. may keep working if you backward play within a cached region only.\n• Relative seeks may behave weird. Small seeks backward (towards smaller time, i.e. ) may not really seek properly, and audio will remain muted for a while. Using hr-seek is recommended, which should have none of these problems.\n• Some things are just weird. For example, while seek commands manipulate playback time in the expected way (provided they work correctly), the framestep commands are transposed. Backstepping will perform very expensive work to step forward by 1 frame.\n• Remove all / filters you have set. Disable hardware decoding. Disable functions like SPDIF passthrough.\n• Increasing might help if reversal queue overflow is reported, which may happen in high bitrate video, or video with large GOP. Hardware decoding mostly ignores this, and you need to increase instead (until you get playback without logged errors).\n• The demuxer cache is essential for backward demuxing. Make sure to set . The cache size might matter. If it's too small, a queue overflow will be logged, and backward playback cannot continue, or it performs too many low level seeks. If it's too large, implementation tradeoffs may cause general performance issues. Use to potentially increase the amount of packets the demuxer layer can queue for reverse demuxing (basically it's the equivalent for the demuxer layer).\n• Setting can help a lot to make playback smooth (once it works).\n• also factors into how many seeks may be performed, and whether backward demuxing could break due to queue overflow. If it's set too high, the backstep operation needs to search through more packets all the time, even if the cache is large enough.\n• Setting may be useful to cache the entire file into the demuxer cache. Set to a large size to make sure it can read the entire cache; should also be set to a large size to prevent that tries to trim the cache.\n• If audio artifacts are audible, even though the AO does not underrun, increasing might help in some cases. For backward decoding. Backward decoding decodes forward in steps, and then reverses the decoder output. These options control the approximate maximum amount of bytes that can be buffered. The main use of this is to avoid unbounded resource usage; during normal backward playback, it's not supposed to hit the limit, and if it does, it will drop frames and complain about it. Use this option if you get reversal queue overflow errors during backward playback. Increase the size until the warning disappears. Usually, the video buffer will overflow first, especially if it's high resolution video. This does not work correctly if video hardware decoding is used. The video frame size will not include the referenced GPU and driver memory. Some hardware decoders may also be limited by . How large the queue size needs to be depends entirely on the way the media was encoded. Audio typically requires a very small buffer, while video can require excessively large buffers. This does not affect demuxer cache behavior at all. See for defaults and value range. options accept suffixes such as and . Number of overlapping keyframe ranges to use for backward decoding (default: auto) (\"keyframe\" to be understood as in the mpv/ffmpeg specific meaning). Backward decoding works by forward decoding in small steps. Some codecs cannot restart decoding from any packet (even if it's marked as seek point), which becomes noticeable with backward decoding (in theory this is a problem with seeking too, but can fix it for seeking). In particular, MDCT based audio codecs are affected. The solution is to feed a previous packet to the decoder each time, and then discard the output. This option controls how many packets to feed. The choice is currently hardcoded to 0 for video, and uses 1 for lossy audio, 0 for lossless audio. For some specific lossy audio codecs, this is set to 2. can potentially handle intra-refresh video, depending on the exact conditions. You may have to use the option as well. Number of keyframe ranges to decode at once when backward decoding (default: 1 for video, 10 for audio). Another pointless tuning parameter nobody should use. This should affect performance only. In theory, setting a number higher than 1 for audio will reduce overhead due to less frequent backstep operations and less redundant decoding work due to fewer decoded overlap frames (see ). On the other hand, it requires a larger reversal buffer, and could make playback less smooth due to breaking pipelining (e.g. by decoding a lot, and then doing nothing for a while). It probably never makes sense to set . But in theory, it could help with intra-only video codecs by reducing backstep operations. Number of seconds the demuxer should seek back to get new packets during backward playback (default: 60). This is useful for tuning backward playback, see for details. Setting this to a very low value or 0 may make the player think seeking is broken, or may make it perform multiple seeks. Setting this to a high value may lead to quadratic runtime behavior. You can also pass a string to this option, which will list all top-level options which contain the string in the name, e.g. for all options that contain the word . The special string lists all top-level options. Increment verbosity level, one level for each found on the command line. Do not load default configuration or any user files. This prevents loading of both the user-level and system-wide and files. Other user files are blocked as well, such as resume playback files and cache files. This option only takes effect when used as a command line flag. Files explicitly requested by command line options, like or , will still be loaded. Print a list of the available properties. Opens the given path for writing, and print log messages to it. Existing files will be truncated. The log level is at least , but can be raised via (the option cannot lower it below the forced minimum log level). A special case is the macOS bundle, it will create a log file at by default. Force a different configuration directory. If this is set, the given directory is used to load configuration files, and all other configuration directories are ignored. This means the global mpv configuration directory as well as per-user directories are ignored, and overrides through environment variables ( ) are also ignored. Note that the cache and state paths ( , ) are not considered \"configuration\" and keep their auto-detection logic. Note that the option takes precedence over this option. Write certain statistics to the given file. The file is truncated on opening. The file will contain raw samples, each with a timestamp. To make this file into a readable, the script can be used (which currently displays it as a graph). This option is useful for debugging only. Makes mpv wait idly instead of quitting when there is no file to play. Mostly useful in input mode, where mpv can be controlled through input commands. (Default: ) will only idle at start and let the player close once the first playlist has finished playing back. Specify configuration file to be parsed after the default ones. If set to , don't auto-load scripts from the configuration subdirectory (usually ). (Default: ) Load a Lua script. The second option allows you to load multiple scripts by separating them with the path separator ( on Unix, on Windows). is a path list option. See List Options for details. Set options for scripts. A script can query an option by key. If an option is used and what semantics the option value has depends entirely on the loaded scripts. Values not claimed by any scripts are ignored. Each use of the option will add another option to the internal list, while takes a list of options at once, and overwrites the internal list with it. The latter is a key/value list option. See List Options for details. Pretend that all files passed to mpv are concatenated into a single, big file. This uses timeline/EDL support internally. Use the given profile(s), displays a list of the defined profiles. Normally, mpv will try to keep all settings when playing the next file on the playlist, even if they were changed by the user during playback. (This behavior is the opposite of MPlayer's, which tries to reset all settings when starting next file.) Default: Do not reset anything. This can be changed with this option. It accepts a list of options, and mpv will reset the value of these options on playback start to the initial value. The initial value is either the default value, or as set by the config file or command line. The special name resets as many options as possible. This is a string list option. See List Options for details.\n• Reset pause mode when switching to the next file.\n• Reset fullscreen and playback speed settings if they were changed during playback.\n• Try to reset all settings that were changed during playback. Show the description and content of a profile. Lists all profiles if no parameter is provided. Look for a file-specific configuration file in the same directory as the file that is being played. See File-specific Configuration Files. May be dangerous if playing from untrusted media. Enable the youtube-dl hook-script. It will look at the input URL, and will play the video located on the website. This works with many streaming sites, not just the one that the script is named after. This requires a recent version of youtube-dl to be installed on the system (default: yes). If the script can't do anything with an URL, it will do nothing. This accepts a set of options, which can be passed to it with the option (using as prefix): If 'yes' will try parsing the URL with youtube-dl first, instead of the default where it's only after mpv failed to open it. This mostly depends on whether most of your URLs need youtube-dl parsing. A -separated list of URL patterns which mpv should not use with youtube-dl. The patterns are matched after the part of the URL. matches the beginning of the URL, matches its end, and you should use before any of the characters to match that character. URLs are converted to lower case before matching.\n• will exclude any URL that starts with or .\n• will exclude any URL that ends with or . See more lua patterns here: https://www.lua.org/manual/5.1/manual.html#5.4.1 A -separated list of URL patterns which mpv should try to parse with youtube-dl first when is . The patterns are matched in the same way as . If 'yes' will attempt to add all formats found reported by youtube-dl (default: no). Each format is added as a separate track. In addition, they are delay-loaded, and actually opened only when a track is selected (this should keep load times as low as without this option). It adds average bitrate metadata, if available, which means you can use to decide which track to select. (HLS used to be the only format whose alternative quality streams were exposed in a similar way, thus the option name.) Tracks which represent formats that were selected by youtube-dl as default will have the default flag set. This means mpv should generally still select formats chosen with by default. Although this mechanism makes it possible to switch streams at runtime, it's not suitable for this purpose for various technical reasons. (It's slow, which can't be really fixed.) In general, this option is not useful, and was only added to show that it's possible. There are two cases that must be considered when doing quality/bandwidth selection:\n• None Completely separate audio and video streams (DASH-like). Each of these streams contain either only audio or video, so you can mix and combine audio/video bandwidths without restriction. This intuitively matches best with the concept of selecting quality by track (what is supposed to do).\n• None Separate sets of muxed audio and video streams. Each version of the media contains both an audio and video stream, and they are interleaved. In order not to waste bandwidth, you should only select one of these versions (if, for example, you select an audio stream, then video will be downloaded, even if you selected video from a different stream). mpv will still represent them as separate tracks, but will set the title of each track to , where is replaced with the youtube-dl format ID of the originating stream. Some sites will mix 1. and 2., but we assume that they do so for compatibility reasons, and there is no reason to use them at all. If set to 'yes', and is also set to 'yes', this will try to represent all youtube-dl reported formats as tracks, even if mpv would normally use the direct URL reported by it (default: yes). It appears this normally makes a difference if youtube-dl works on a master HLS playlist. If this is set to 'no', this specific kind of stream is treated like is set to 'no', and the stream selection as done by youtube-dl (via ) is used. Thumbnails get downloaded when they are added as tracks, so 'all' can have a noticeable impact on how long it takes to open the video when there are a lot of thumbnails. Make mpv use the master manifest URL for formats like HLS and DASH, if available, allowing for video/audio selection in runtime (default: no). It's disabled (\"no\") by default for performance reasons. Configure paths to youtube-dl's executable or a compatible fork's. The paths should be separated by : on Unix and ; on Windows. mpv looks in order for the configured paths in PATH and in mpv's config directory. The defaults are \"yt-dlp\", \"yt-dlp_x86\" and \"youtube-dl\". On Windows the suffix extension is not necessary, but only \".exe\" is acceptable. Why do the option names mix and ? Video format/quality that is directly passed to youtube-dl. The possible values are specific to the website and the video, for a given url the available formats can be found with the command . See youtube-dl's documentation for available aliases. (Default: ) The value does not pass a option to youtube-dl at all, and thus does not override its default. Note that sometimes youtube-dl returns a format that mpv cannot use, and in these cases the mpv default may work better. Pass arbitrary options to youtube-dl. Parameter and argument should be passed as a key-value pair. Options without argument must include . There is no sanity checking so it's possible to break things (i.e. passing invalid parameters to youtube-dl). A proxy URL can be passed for youtube-dl to use it in parsing the website. This is useful for geo-restricted URLs. After youtube-dl parsing, some URLs also require a proxy for playback, so this can pass that proxy information to mpv. Take note that SOCKS proxies aren't supported and https URLs also bypass the proxy. This is a limitation in FFmpeg. This is a key/value list option. See List Options for details. Enable memory reporting for javascript scripts in the stats overlay. This is disabled by default because it has an overhead and increases memory usage. This option will only work if it is enabled before mpv is started. Enable the builtin script that shows useful playback information on a key binding (default: yes). By default, the key is used ( to make the overlay permanent). Enable the built-in script to handle textual input (default: yes). Enable the built-in script to enter commands in the console (default: yes). The key is used to activate this by default. Enable the builtin script that does auto profiles (default: auto). See Conditional auto profiles for details. will load the script, but immediately unload it if there are no conditional profiles. Enable the builtin script that lets you select from lists of items (default: yes). By default, its keybindings start with the key. Enable the builtin script that provides various keybindings to pan videos and images (default: yes). For enabling \"pseudo GUI mode\", which means that the defaults for some options are changed. This option should not normally be used directly, but only by mpv internally, or mpv-provided scripts, config files, or .desktop files. See PSEUDO GUI MODE for details. Always save the current playback position on quit, and also when the command is used to replace the current playlist. When this file is played again later, the player will seek to the old playback position on start. This does not happen if playback of a file is stopped in other ways. For example, going to the next file in the playlist will not save the position, and will start playback at beginning the next time the file is played. This behavior is disabled by default, but is always available when quitting the player with Shift+Q. The directory in which to store the \"watch later\" temporary files. is an alias for . If this option is unset, the files will be stored in a subdirectory named \"watch_later\" underneath the local state directory (usually ). Restore playback position from the configuration subdirectory, usually (default: yes). Only restore the playback position from the configuration subdirectory (usually ) if the file's modification time is the same as at the time of saving. This may prevent skipping forward in files with the same name which have different content. (Default: ) The options that are saved in \"watch later\" files if they have been changed since when mpv started. These values will be restored the next time the files are played. Note that the playback position is saved via the option. When removing options, existing watch later data won't be modified and will still be applied fully, but new watch later data won't contain these options. See for the list of the properties that are restored by default. This is a string list option. See List Options for details.\n• The subtitle track selection will not be restored.\n• The volume and mute state won't be saved to watch later files.\n• No option will be saved to watch later files, except the playback position. Prepend the watch later config files with the name of the file they refer to. This is simply written as comment on the top of the file. This option may expose privacy-sensitive information and is thus disabled by default. Ignore path (i.e. use filename only) when using watch later feature. (Default: disabled) Whether to save which files are played. These can be then selected with the default key binding. This option may expose privacy-sensitive information and is thus disabled by default. The path in which to store the watch history. Default: (see PATHS). This file contains one JSON object per line. Its field is the UNIX timestamp when the file was opened, its field is the normalized path, and its field is the title when it was available. Specify the video output backend to be used. See VIDEO OUTPUT DRIVERS for details and descriptions of available drivers. Specify a priority list of video decoders to be used, according to their family and name. See for further details. Both of these options use the same syntax and semantics; the only difference is that they operate on different codec lists. See for a full list of available decoders. Specify a list of video filters to apply to the video stream. See VIDEO FILTERS for details and descriptions of the available filters. The option variants , , and exist to modify a previously specified list, but you should not need these for typical use. Do not sleep when outputting video frames. Useful for benchmarks when used with . Skip displaying some frames to maintain A/V sync on slow systems, or playing high framerate video on video outputs that have an upper framerate limit. The argument selects the drop methods, and can be one of the following: Disable any frame dropping. Not recommended, for testing only. Drop late frames on video output (default). This still decodes and filters all frames, but doesn't render them on the VO. Drops are indicated in the terminal status line as field. In audio sync. mode, this drops frames that are outdated at the time of display. If the decoder is too slow, in theory all frames would have to be dropped (because all frames are too late) - to avoid this, frame dropping stops if the effective framerate is below 10 FPS. In display-sync. modes (see ), this affects only how A/V drops or repeats frames. If this mode is disabled, A/V desync will in theory not affect video scheduling anymore (much like the mode). However, even if disabled, frames will still be skipped (i.e. dropped) according to the ratio between video and display frequencies. This is the recommended mode, and the default. Old, decoder-based framedrop mode. (This is the same as in mpv 0.5.x and before.) This tells the decoder to skip frames (unless they are needed to decode future frames). May help with slow systems, but can produce unwatchable choppy output, or even freeze the display completely. This uses a heuristic which may not make sense, and in general cannot achieve good results, because the decoder's frame dropping cannot be controlled in a predictable manner. Not recommended. Even if you want to use this, prefer for better results. The option controls what frames to drop. Enable both modes. Not recommended. Better than just mode. has its own code for the framedrop mode. Slight differences to other VOs are possible. Enable some things which tend to reduce video latency by 1 or 2 frames (default: no). Note that this option might be removed without notice once the player's timing code does not inherently need to do these things anymore. Using this option is known to break other options such as interpolation, so it is not recommended to enable this.\n• Use the demuxer reported FPS for frame dropping. This avoids the player needing to decode 1 frame in advance, lowering total latency in effect. This also means that if the demuxer reported FPS is wrong, or the video filter chain changes FPS (e.g. deinterlacing), then it could drop too many or not enough frames.\n• Disable waiting for the first video frame. Normally the player waits for the first video frame to be fully rendered before starting playback properly. Some VOs will lazily initialize stuff when rendering the first frame, so if this is not done, there is some likeliness that the VO has to drop some frames if rendering the first frame takes longer than needed. Set the display FPS used with the modes. By default, a detected value is used. Keep in mind that setting an incorrect value (even if slightly incorrect) can ruin video playback. On multi-monitor systems, there is a chance that the detected value is from the wrong monitor. Set this option only if you have reason to believe the automatically determined value is wrong. Specify the hardware video decoding API that should be used if possible. Whether hardware decoding is actually done depends on the video codec. If hardware decoding is not possible, mpv will fall back on software decoding. Hardware decoding is not enabled by default, to keep the out-of-the-box configuration as reliable as possible. However, when using modern hardware, hardware video decoding should work correctly, offering reduced CPU usage, and possibly lower power consumption. On older systems, it may be necessary to use hardware decoding due to insufficient CPU resources; and even on modern systems, sufficiently complex content (eg: 4K60 AV1) may require it. This is a string list option. See List Options for details. Use the shortcut to toggle hardware decoding at runtime. It toggles this option between and . If you decide you want to use hardware decoding by default, the general recommendation is to try out decoding with the command line option, and prove to yourself that it works as desired for the content you care about. After that, you can add it to your config file. When testing, you should start by using as it will limit itself to choosing from hwdecs that are actively supported by the development team. If that doesn't result in working hardware decoding, you can try to have it attempt to load every possible hwdec, but if didn't work, you will probably need to know exactly which hwdec matches your hardware and read up on that entry below. If produced the desired results, we recommend just sticking with that and only setting a specific hwdec in your config file if it is really necessary. If you use the Ubuntu package, keep in mind that their contains , which is less than ideal as it may not be the right choice for your system, and it may end up using an inefficient wrapper library under the covers. We recommend removing this line or deleting the file altogether. Even if enabled, hardware decoding is still only white-listed for some codecs. See to enable hardware decoding in more cases.\n• If you only want to enable hardware decoding at runtime, don't set the parameter, or put into your (relevant on distros which force-enable it by default, such as on Ubuntu). Use the default binding to enable it at runtime.\n• If you're not sure, but want hardware decoding always enabled by default, put into your , and acknowledge that this may cause problems.\n• If you want to test available hardware decoding methods, pass and look at the terminal output.\n• If you're a developer, or want to perform elaborate tests, you may need any of the other possible option values. This option accepts a comma delimited list of types, along with certain special values: enable any whitelisted hw decoder (see below) forcibly enable any hw decoder found (see below) exactly the same as exactly the same as Special values can be mixed with api names. eg: will try and use the hwdec, and if that fails, will run through the normal logic. requires with or (Windows 8+ only) requires (macOS 10.8 and up), or (iOS 9.0 and up) copies video back into system RAM (macOS 10.8 or iOS 9.0 and up) copies video back into system RAM (Linux with some GPUs or Windows) requires (Any platform CUDA is available) copies video back to system RAM (Any platform CUDA is available) copies video back to system RAM (Any platform with Vulkan Video Decoding) Other hwdecs (only use if you know you have to): requires with , or (Windows only) requires with , or (Linux only) copies video back into system RAM (Linux with some GPUs only) requires (Any platform CUDA is available) copies video back to system RAM (Any platform CUDA is available) copies video back to system RAM (Any platform supported by hardware) tries to automatically enable hardware decoding using the first available method, but allows only whitelisted methods that are considered \"safe\". This is supposed to be a reasonable way to enable hardware decoding by default in a config file (even though you shouldn't do that anyway; prefer runtime enabling with ). Unlike , this will not try to enable unknown or known-to-be-bad methods. In addition, this may disable hardware decoding in other situations when it's known to cause problems, but currently this mechanism is quite primitive. (As an example for something that still causes problems: certain combinations of HEVC and Intel chips on Windows tend to cause mpv to crash, most likely due to driver bugs.) is similar to , but without the whitelist. In general, you should never need to use this beyond debugging or development use. Any known unsafe hwdec you want to test can simply be appended to the list option such as . This still depends what VO you are using. See the list above, for which and is required for a given hwdec. It will go down the list of available hwdecs until one is successfully initialised. If all of them fail, it will fallback to software decoding. selects only modes that copy the video data back to system memory after decoding. This selects modes like (and so on), but it only allows whitelisted methods that are considered \"safe\". If none of these work, hardware decoding is disabled. This mode is usually guaranteed to incur no additional quality loss compared to software decoding (assuming modern codecs and an error free video stream), and will allow CPU processing with video filters. This mode works with all video filters and VOs. is an alias for is the same as except that it goes through all methods and not just the whitelisted ones that are considered \"safe\". Because these copy the decoded video back to system RAM, they're often less efficient than the direct modes, and may not help too much over software decoding if you are short on CPU resources. Most non-copy methods only work with the OpenGL GPU backend. Currently, only the , , and methods work with Vulkan. The mode, if used with or most likely works with Intel and AMD GPUs only. It requires the opengl EGL backend if the GPU does not support drm modifiers. and are the newest, and recommended method to do hardware decoding on Nvidia GPUs. and are an older implementation of hardware decoding on Nvidia GPUs that uses Nvidia's bitstream parsers rather than FFmpeg's. This can lead to feature deficiencies, such as incorrect playback of HDR content, and / should always be preferred unless you specifically need Nvidia's deinterlacing algorithms. To use this deinterlacing you must pass the option: . Pass (or leave the option unset) to not attempt any deinterlacing. In theory, hardware decoding does not reduce video quality (at least for the codecs h264 and HEVC). However, due to restrictions in video output APIs, as well as bugs in the actual hardware decoders, there can be some loss, or even blatantly incorrect results. This has largely ceased to be a problem with modern hardware, but there is a lot of hardware out there, so caveat emptor. Known problems are discussed below, but the list cannot be considered exhaustive, as even hwdecs that work well on certain hardware generations may be problematic on other ones. In some cases, RGB conversion is forced, which means the RGB conversion is performed by the hardware decoding API, instead of the shaders used by . This means certain colorspaces may not display correctly, and certain filtering (such as debanding) cannot be applied in an ideal way. This will also usually force the use of low quality chroma scalers instead of the one specified by . In other cases, hardware decoding can also reduce the bit depth of the decoded image, which can introduce banding or precision loss for 10-bit files. always does RGB conversion in hardware, which does not support newer colorspaces like BT.2020 correctly. However, doesn't support 10 bit or HDR encodings, so these limitations are unlikely to be relevant. is not safe. It appears to always use BT.601 for forced RGB conversion, but actual behavior depends on the GPU drivers. Some drivers appear to convert to limited range RGB, which gives a faded appearance. In addition to driver-specific behavior, global system settings might affect this additionally. This can give incorrect results even with completely ordinary video sources. is not safe. It forces RGB conversion (not with ) and how well it handles non-standard colorspaces is not known. In the rare cases where 10-bit is supported the bit depth of the output will be reduced to 8. should usually be safe, but depending on how a file/stream has been mixed, it has been reported to corrupt the timestamps causing glitched, flashing frames. It can also sometimes cause massive framedrops for unknown reasons. Caution is advised, and should always be preferred. is not safe. It always converts to 4:2:2 YUV, which may be lossy, depending on how chroma sub-sampling is done during conversion. It also discards the top left pixel of each frame for some reason. If you run into any weird decoding issues, frame glitches or discoloration, and you have turned on, the first thing you should try is disabling it. This option is for troubleshooting hwdec interop issues. Since it's a debugging option, its semantics may change at any time. This is useful for the and VOs for selecting which hwdec interop context to use exactly. Effectively it also can be used to block loading of certain backends. If set to (default), the behavior depends on the VO: for , it does nothing, and the interop context is loaded on demand (when the decoder probes for support). For , which has has no on-demand loading, this is equivalent to . The empty string is equivalent to . If set to , it attempts to load all interop contexts at GL context creation time. Other than that, a specific backend can be set, and the list of them can be queried with (mpv CLI only). Runtime changes to this are ignored (the current option value is used whenever the renderer is created). Number of GPU frames hardware decoding should preallocate (default: see output). If this is too low, frame allocation may fail during decoding, and video frames might get dropped and/or corrupted. Setting it too high simply wastes GPU memory and has no advantages. This value is used only for hardware decoding APIs which require preallocating surfaces (known examples include and ). For other APIs, frames are allocated as needed. The details depend on the libavcodec implementations of the hardware decoders. The required number of surfaces depends on dynamic runtime situations. The default is a fixed value that is thought to be sufficient for most uses. But in certain situations, it may not be enough. Set the internal pixel format used by hardware decoding via (default ). The special value selects an implementation specific standard format. Most decoder implementations support only one format, and will fail to initialize if the format is not supported. Some implementations might support multiple formats. In particular, videotoolbox is known to require for good performance on some older hardware. d3d11va can always use , which uses an opaque format, with likely no advantages. Choose the GPU device used for decoding when using the or hwdecs with the OpenGL GPU backend, and with the or hwdecs in all cases. For the OpenGL GPU backend, the default device used for decoding is the one being used to provide output (and in the vast majority of cases, only one GPU will be present). For the hwdecs, the default device will be the first device enumerated by the CUDA libraries - however that is done. For the Vulkan GPU backend, decoding must always happen on the display device, and this option has no effect. Choose the DRM device for . This should be the path to a DRM device file. (Default: ) On Windows this takes adapter name as an input. Will pick the default adapter if unset. Alternatives are listed when the name \"help\" is given. Enables pan-and-scan functionality (cropping the sides of e.g. a 16:9 video to make it fit a 4:3 display without black bands). The range controls how much of the image is cropped. May not work with all video output drivers. This option has no effect if option is used. The difference between and is that can only zoom in until either the video width or height fills the window, while can zoom in or out arbitrary amounts, and also works with . Override video aspect ratio, in case aspect information is incorrect or missing in the file being played. use the method of the option (default) disable aspect ratio handling, pretend the video has square pixels (deprecated, use instead) strictly prefer the container aspect ratio (deprecated, use instead) But note that handling of these special values might change in the future. This sets the default video aspect determination method (if the aspect is _not_ overridden by the user with or others). Strictly prefer the container aspect ratio. This is apparently the default behavior with VLC, at least with Matroska. Note that if the container has no aspect ratio set, the behavior is the same as with bitstream. Strictly prefer the bitstream aspect ratio, unless the bitstream aspect ratio is not set. This is apparently the default behavior with XBMC/kodi, at least with Matroska. The current default for mpv is . Normally you should not set this. Try the various choices if you encounter video that has the wrong aspect ratio in mpv, but seems to be correct in other players. Disable scaling of the video. If the window is larger than the video, black bars are added. Otherwise, the video is cropped, unless the option is set to , in which case the video is fit to window. The video still can be influenced by the other options. This option disables the effect of . Note that the scaler algorithm may still be used, even if the video isn't scaled. For example, this can influence chroma conversion. The video will also still be scaled in one dimension if the source uses non-square pixels (e.g. anamorphic widescreen DVDs). This option is disabled if is used. Moves the displayed video rectangle by the given value in the X or Y direction. The unit is in fractions of the size of the scaled video (the full size, even if parts of the video are not visible due to panscan or other options). For example, displaying a video fullscreen on a 1920x1080 screen with would move the video 192 pixels to the left and would move the video 108 pixels up. This option is disabled if is used. Rotate the video clockwise, in degrees. If is given, the video is never rotated, even if the file has rotation metadata. (The rotation value is added to the rotation metadata, which means the value would rotate the video according to the rotation metadata.) When using hardware decoding without copy-back, only 90° steps work, while software decoding and hardware decoding methods that copy the video back to system memory support all values between 0 and 359. Crop the video by starting at the x, y offset for w, h pixels. The crop is applied to the source video rectangle (before anamorphic stretch) by the VO. A crop rectangle that is not within the video rectangle will be ignored. This works with hwdec, unlike the equivalent 'lavfi-crop'. When offset is omitted, the central area will be cropped. Setting the crop to empty one overrides container crop and disables cropping. Setting the crop to disables manual cropping and restores the container crop if it's specified. Adjust the video display scale factor by the given value. The parameter is given log 2. For example, is unscaled, is twice the size, is one fourth of the size, and so on. This option is disabled if is used. Multiply the video display size with the given value (default: 1.0). If a non-default value is used, this will be different from the window size, so video will be either cut off, or black bars are added. This value is multiplied with the value derived from and the normal video aspect ratio. This option is disabled if is used. When the video is bigger than the window, these move the displayed rectangle to show different parts of the video. would display the top of the video, would display the center (default), and would display the bottom. When the video is smaller than the window and is disabled, these move the video rectangle within the black borders, which are usually added to pad the video to the window if video and window aspect ratios are different. would move the video to the top of the window (leaving a border only on the bottom), would center it, and would put the video at the bottom of the window. If video and screen aspect match perfectly, these options do nothing. Unlike and , these don't go beyond the video's or window's boundaries or make the displayed rectangle drift off after zooming. This option is disabled if is used. Whether to behave as if and were 0 when the video becomes smaller than the window in the respective direction After zooming in until the video is bigger the window, panning with and/or , and zooming out until the video is smaller than the window, this is useful to recenter the video in the window. Set extra video margins on each border (default: 0). Each value is a ratio of the window size, using a range 0.0-1.0. For example, setting the option at a window size of 1000 pixels will add a 200 pixels border on the right side of the window. The video is \"boxed\" by these margins. The window size is not changed. In particular it does not enlarge the window, and the margins will cause the video to be downscaled by default. This may or may not change in the future. The margins are applied after 90° video rotation, but before any other video transformations. This option is disabled if is used. Subtitles still may use the margins, depending on and similar options. These options were created for the OSC. Some odd decisions, such as making the margin values a ratio (instead of pixels), were made for the sake of the OSC. It's possible that these options may be replaced by ones that are more generally useful. The behavior of these options may change to fit OSC requirements better, too. switches mpv to a mode where video timing is determined using a fixed framerate value (either using the option, or using file information). Sometimes, files with very broken timestamps can be played somewhat well in this mode. Note that video filters, subtitle rendering, seeking (including hr-seeks and backstepping), and audio synchronization can be completely broken in this mode. Override video framerate. Useful if the original value is wrong or missing. Enable or disable deinterlacing (default: no). Interlaced video shows ugly comb-like artifacts, which are visible on fast movement. Enabling this typically inserts the bwdif video filter in order to deinterlace the video, or lets the video output apply deinterlacing if supported. When using , mpv will insert a deinterlacing filter if ffmpeg detects that the video frame is interlaced. Be aware that there can be false positives in certain cases, such as when files are encoded as interlaced despite the video not actually being so. This is why is not the default value. Keep in mind that using this filter will conflict with any manually inserted deinterlacing filters, and that this will make video look worse if it's not actually interlaced. Specify the field parity/order when deinterlacing (default: auto). Each frame of an interlaced video is divided into two fields, which are then separately transmitted. Top field represents even lines while bottom field represents odd lines. When deinterlacing the deinterlacer needs to know the correct temporal order of the fields else the video will appear jittery. will automatically try to detect the field order of the video, forces top field first while forces bottom field first. Play/convert only first video frames, then quit. loads the file, but immediately quits before initializing playback. (Might be useful for scripts which just want to determine some file properties.) For audio-only playback, any value greater than 0 will quit playback immediately after initialization. The value 0 works as with video. RGB color levels used with YUV to RGB conversion. Normally, output devices such as PC monitors use full range color levels. However, some TVs and video monitors expect studio RGB levels. Providing full range output to a device expecting studio level input results in crushed blacks and whites, the reverse in dim gray blacks and dim whites. Not all VOs support this option. Some will silently ignore it. It is advisable to use your graphics driver's color range option instead, if available. Allow hardware decoding for a given list of codecs only. The special value always allows all codecs. You can get the list of allowed codecs with . Remove the prefix, e.g. instead of use . By default, this is set to . Note that the hardware acceleration special codecs like are not relevant anymore, and in fact have been removed from FFmpeg in this form. This is usually only needed with broken GPUs, where a codec is reported as supported, but decoding causes more problems than it solves. On some broken drivers (e.g. NVIDIA on Linux), probing for codecs which the GPU does not support can unnecessarily slow down video playback initialization. To alleviate this, explicitly specify a list which only includes the codecs supported on the setup. Enable vdpau decoding for h264 and mpeg2 only. Fallback to software decoding if the hardware-accelerated decoder fails (default: 3). If this is a number, then fallback will be triggered if N frames fail to decode in a row. 1 is equivalent to . Setting this to a higher number might break the playback start fallback: if a fallback happens, parts of the file will be skipped, approximately by to the number of packets that could not be decoded. Values below an unspecified count will not have this problem, because mpv retains the packets. Check hardware decoder profile (default: yes). If is set, the highest profile of the hardware decoder is unconditionally selected, and decoding is forced even if the profile of the video is higher than that. The result is most likely broken decoding, but may also help if the detected or reported profiles are somehow incorrect. Enables film grain application on the GPU. If video decoding is done on the CPU, doing film grain application on the GPU can speed up decoding. This option can also help hardware decoding, as it can reduce the number of frame copies done. By default, it's set to , so if the VO supports film grain application, then it will be treated as . If the VO does not support this, then it will be treated as , regardless of the setting. Currently, only supports film grain application. Enable direct rendering (default: auto). If this is set to , the video will be decoded directly to GPU video memory (or staging buffers). This can speed up video upload, and may help with large resolutions or slow hardware. This works only with the following VOs:\n• : requires at least OpenGL 4.4 or Vulkan. The option will try to guess whether DR can improve performance on your particular hardware. Currently this enables it on AMD or NVIDIA if using OpenGL or unconditionally if using Vulkan. Using video filters of any kind that write to the image data (or output newly allocated frames) will silently disable the DR code path. Only use bit-exact algorithms in all decoding steps (for codec testing). Enable optimizations which do not comply with the format specification and potentially cause problems, like simpler dequantization, simpler motion compensation, assuming use of the default quantization matrix, assuming YUV 4:2:0 and skipping a few checks to detect damaged bitstreams. Pass AVOptions to libavcodec decoder. Note, a patch to make the unneeded and pass all unknown options through the AVOption system is welcome. A full list of AVOptions can be found in the FFmpeg manual. Some options which used to be direct options can be set with this mechanism, like , , , , , (was ), (was ), . This is a key/value list option. See List Options for details. Show even broken/corrupt frames (default: no). If this option is set to no, libavcodec won't output frames that were either decoded before an initial keyframe was decoded, or frames that are recognized as corrupted. Skips the loop filter (AKA deblocking) during decoding. Since the filtered frame is supposed to be used as reference for decoding dependent frames, this has a worse effect on quality than not doing deblocking on e.g. MPEG-2 video. But at least for high bitrate HDTV, this provides a big speedup with little visible quality loss. Codecs other than H.264 or HEVC may have partial support for this option (often only and ). can be one of the following: Skip frames that are not referenced (i.e. not used for decoding other frames, the error cannot \"build up\"). Skips the IDCT step. This degrades quality a lot in almost all cases (see skiploopfilter for available skip values). Skips decoding of frames completely. Big speedup, but jerky motion and sometimes bad artifacts (see skiploopfilter for available skip values). Set framedropping mode used with (see skiploopfilter for available skip values). Number of threads to use for decoding. Whether threading is actually supported depends on codec (default: 0). 0 means autodetect number of cores on the machine and use that, up to the maximum of 16. You can set more than 16 threads manually. Assume the video was encoded by an old, buggy x264 version (default: no). Normally, this is autodetected by libavcodec. But if the bitstream contains no x264 version info (or it was somehow skipped), and the stream was in fact encoded by an old x264 version (build 150 or earlier), and if the stream uses 4:4:4 chroma, then libavcodec will by default show corrupted video. This option sets the libavcodec option to , which means that if the stream contains no version info, or was not encoded by x264 at all, it assumes it was encoded by the old version. Enabling this option is pretty safe if you want your broken files to work, but in theory this can break on streams not encoded by x264, or if a stream encoded by a newer x264 version contains no version info. Certain video codecs support cropping, meaning that only a sub-rectangle of the decoded frame is intended for display. This option controls how cropping is handled by libavcodec. Cropping during decoding has certain limitations with regards to alignment and hardware decoding. If this option is enabled, decoder will apply the crop, else VO will handle it. Enabled by default. Allow up to N in-flight frames. This essentially controls the frame latency. Increasing the swapchain depth can improve pipelining and prevent missed vsyncs, but increases visible latency. This option only mandates an upper limit, the implementation can use a lower latency than requested internally. A setting of 1 means that the VO will wait for every frame to become visible before starting to render the next frame. (Default: 3) If this is enabled (default), playing with a speed different from normal automatically inserts the audio filter. You can insert filters besides and modify their params using : Filters set this way replace the default, instead of overlapping with it. If there are multiple audio filters inserted that can do pitch correction, then only the last one in the filter chain is used. For details on the specifics of each available filter, see the audio filter section. Use the given audio device. This consists of the audio output name, e.g. , followed by , followed by the audio output specific device name. The default value for this option is , which tries every audio output in preference order with the default device. You can list audio devices with . This outputs the device name in quotes, followed by a description. The device name is what you have to pass to the option. The list of audio devices can be retrieved by API by using the property. While the option normally takes one of the strings as indicated by the methods above, you can also force the device for most AOs by building it manually. For example forces the AO to use the device . However, the option will strictly force a specific AO. To avoid confusion, don't use and together. MPlayer and mplayer2 required you to replace any ',' with '.' and any ':' with '=' in the ALSA device name. For example, to use the device named , you had to do: In mpv you could instead use: Enable exclusive output mode. In this mode, the system is usually locked out, and only mpv will be able to output audio. This only works for some audio outputs, such as , , and . Other audio outputs silently ignore this option. They either have no concept of exclusive mode, or the mpv side of the implementation is missing. If no audio device can be opened, behave as if was given. This is useful in combination with : instead of causing an error if the selected device does not exist, the client API user (or a Lua script) could let playback continue normally, and check the and properties to make high-level decisions about how to continue. Specify the audio output drivers to be used. See AUDIO OUTPUT DRIVERS for details and descriptions of available drivers. Specify a list of audio filters to apply to the audio stream. See AUDIO FILTERS for details and descriptions of the available filters. The option variants , , and exist to modify a previously specified list, but you should not need these for typical use. List of codecs for which compressed audio passthrough should be used. This works for both classic S/PDIF and HDMI. Possible codecs are , , , , . Multiple codecs can be specified by separating them with . refers to low bitrate DTS core, while refers to DTS MA (receiver and OS support varies). If both and are specified, it behaves equivalent to specifying only. In earlier mpv versions you could use to force the spdif wrapper. This does not work anymore. There is not much reason to use this. HDMI supports uncompressed multichannel PCM, and mpv supports lossless DTS-HD decoding via FFmpeg's new DCA decoder (based on libdcadec). Specify a priority list of audio decoders to be used, according to their decoder name. When determining which decoder to use, the first decoder that matches the audio format is selected. If that is unavailable, the next decoder is used. Finally, it tries all other decoders that are not explicitly selected or rejected by the option. at the end of the list suppresses fallback on other available decoders not on the list. This should not normally be used, because they break normal decoder auto-selection! The mode is deprecated. Prefer the FFmpeg decoder over all other MP3 decoders. Enabling compressed audio passthrough (AC3 and DTS via SPDIF/HDMI) with this option is not possible. Use instead. Set the startup volume. 0 means silence, 100 means no volume reduction or amplification. Negative values can be passed for compatibility, but are treated as 0. Since mpv 0.18.1, this always controls the internal mixer (aka software volume). Set the maximum amplification level in percent (default: 130). A value of 130 will allow you to adjust the volume up to about double the normal level. Set the volume gain in dB. This is applied on top of other volume and gain settings. Adjust volume gain according to replaygain values stored in the file metadata. With (the default), perform no adjustment. With , apply track gain. With , apply album gain if present and fall back to track gain otherwise. Pre-amplification gain in dB to apply to the selected replaygain gain (default: 0). Allow the volume gain to clip (default: no). If this option is not enabled, mpv automatically will prevent clipping by lowering the gain. Gain in dB to apply if the file has no replay gain tags. This option is always applied if the replaygain logic is somehow inactive. If this is applied, no other replaygain options are applied. Audio delay in seconds (positive or negative float value). Positive values delay the audio, and negative values delay the video. Use this audio demuxer type when using . Use a '+' before the name to force it; this will skip some checks. Give the demuxer name as printed by . Select the Dynamic Range Compression level for AC-3 audio streams. is a float value ranging from 0 to 1, where 0 means no compression (which is the default) and 1 means full compression (make loud passages more silent and vice versa). Values up to 6 are also accepted, but are purely experimental. This option only shows an effect if the AC-3 stream contains the required range compression information. The standard mandates that DRC is enabled by default, but mpv (and some other players) ignore this for the sake of better audio quality. Whether to request audio channel downmixing from the decoder (default: no). Some decoders, like AC-3, AAC and DTS, can remix audio on decoding. The requested number of output channels is set with the option. Useful for playing surround audio on a stereo system. Number of threads to use for decoding. Whether threading is actually supported depends on codec. As of this writing, it's supported for some lossless codecs only. 0 means autodetect number of cores on the machine and use that, up to the maximum of 16 (default: 1). Pass AVOptions to libavcodec decoder. Note, a patch to make the o= unneeded and pass all unknown options through the AVOption system is welcome. A full list of AVOptions can be found in the FFmpeg manual. This is a key/value list option. See List Options for details. If DTS is passed through, use DTS-HD. This and enabling passthrough via are deprecated in favor of using . Control which audio channels are output (e.g. surround vs. stereo). There are the following possibilities:\n• None Use the system's preferred channel layout. If there is none (such as when accessing a hardware device instead of the system mixer), force stereo. Some audio outputs might simply accept any layout and do downmixing on their own.\n• None Send the audio device whatever it accepts, preferring the audio's original channel layout. Can cause issues with HDMI (see the warning below).\n• None List of -separated channel layouts which should be allowed. Technically, this only adjusts the filter chain output to the best matching layout in the list, and passes the result to the audio API. It's possible that the audio API will select a different channel layout. Using this mode is recommended for direct hardware output, especially over HDMI (see HDMI warning below).\n• None Force a downmix to stereo or mono. These are special-cases of the previous item. (See paragraphs below for implications.) If a list of layouts is given, each item can be either an explicit channel layout name (like ), or a channel number. Channel numbers refer to default layouts, e.g. 2 channels refer to stereo, 6 refers to 5.1. See output for defined default layouts. This also lists speaker names, which can be used to express arbitrary channel layouts (e.g. is 2.1). If the list of channel layouts has only 1 item, the decoder is asked to produce according output. This sometimes triggers decoder-downmix, which might be different from the normal mpv downmix. (Only some decoders support remixing audio, like AC-3, AAC or DTS. You can use to make the decoder always output its native layout.) One consequence is that triggers decoder downmix, while or never will, even if they end up selecting stereo. This happens because the decision whether to use decoder downmix happens long before the audio device is opened. If the channel layout of the media file (i.e. the decoder) and the AO's channel layout don't match, mpv will attempt to insert a conversion filter. You may need to change the channel layout of the system mixer to achieve your desired output as mpv does not have control over it. Another work-around for this on some AOs is to use to circumvent the system mixer entirely. Using can cause issues when using audio over HDMI. The OS will typically report all channel layouts that _can_ go over HDMI, even if the receiver does not support them. If a receiver gets an unsupported channel layout, random things can happen, such as dropping the additional channels, or adding noise. You are recommended to set an explicit whitelist of the layouts you want. For example, most A/V receivers connected via HDMI and that can do 7.1 would be served by: Determines whether to display cover art when playing audio files and with what priority. It will display the first image found, and additional images are available as video tracks. Disable display of video entirely when playing audio files. This option has no influence on files with normal video tracks. Play audio from an external file while viewing a video. This is a path list option. See List Options for details. CLI/config file only alias for . Each use of this option will add a new audio track. The details are similar to how works. Select the sample format used for output from the audio filter layer to the sound card. The values that can adopt are listed below in the description of the audio filter. Select the output sample rate to be used (of course sound cards have limits on this). If the sample frequency selected is different from that of the current media, the internal swresample audio filter will be inserted into the audio filter layer to compensate for the difference. Try to play consecutive audio files with no silence or disruption at the point of file change. Default: . The audio device is opened using parameters chosen for the first file played and is then kept open for gapless playback. This means that if the first file for example has a low sample rate, then the following files may get resampled to the same low sample rate, resulting in reduced sound quality. If you play files with different parameters, consider using options such as and to explicitly select what the shared output format will be. Normally, the audio device is kept open (using the format it was first initialized with). If the audio format the decoder output changes, the audio device is closed and reopened. This means that you will normally get gapless audio with files that were encoded using the same settings, but might not be gapless in other cases. The exact conditions under which the audio device is kept open is an implementation detail, and can change from version to version. Currently, the device is kept even if the sample format changes, but the sample formats are convertible. If video is still going on when there is still audio, trying to use gapless is also explicitly given up. This feature is implemented in a simple manner and relies on audio output device buffering to continue playback while moving from one file to another. If playback of the new file starts slowly, for example because it is played from a remote network location or because you have specified cache settings that require time for the initial cache fill, then the buffered audio may run out before playback of the new file can start. When starting a video file or after events such as seeking, mpv will by default modify the audio stream to make it start from the same timestamp as video, by either inserting silence at the start or cutting away the first samples. Disabling this option makes the player behave like older mpv versions did: video and audio are both started immediately even if their start timestamps differ, and then video timing is gradually adjusted if necessary to reach correct synchronization later. Load additional audio files matching the video filename. The parameter specifies how external audio files are matched. Load all audio files containing the media filename. Load all audio files in the current and directories. Audio file extensions to try to match when using , or . This is a string list option. See List Options for details. Use to see default extensions. Equivalent to option, but for auto-loaded audio files. This is a path list option. See List Options for details. The application name the player reports to the audio API. Can be useful if you want to force a different audio profile (e.g. with PulseAudio), or to set your own application name when using libmpv. Set the audio output minimum buffer. The audio device might actually create a larger buffer if it pleases. If the device creates a smaller buffer, additional audio is buffered in an additional software buffer. Making this larger may make soft-volume and other filters react slower, introduce additional issues on playback speed change, and block the player on audio format changes. A smaller buffer might lead to audio dropouts. This option should be used for testing only. If a non-default value helps significantly, the mpv developers should be contacted. Cash-grab consumer audio hardware (such as A/V receivers) often ignore initial audio sent over HDMI. This can happen every time audio over HDMI is stopped and resumed. In order to compensate for this, you can enable this option to not to stop and restart audio on seeks, and fill the gaps with silence. Likewise, when pausing playback, audio is not stopped, and silence is played while paused. Note that if no audio track is selected, the audio device will still be closed immediately. Not all AOs support this. This modifies certain subtle player behavior, like A/V-sync and underrun handling. Enabling this option is strongly discouraged. This makes sense for use with . If this option is given, the player will wait for the given amount of seconds after opening the audio device before sending actual audio data to it. Useful if your expensive hardware discards the first 1 or 2 seconds of audio data sent to it. If is not set, this option will likely just waste time. Changing styling and position does not work with all subtitles. Image-based subtitles (DVD, Bluray/PGS, DVB) cannot changed for fundamental reasons. Subtitles in ASS format are normally not changed intentionally, but overriding them can be controlled with . Force subtitle demuxer type for . Give the demuxer name as printed by . Pass AVOptions to libavcodec decoder. Note, a patch to make the o= unneeded and pass all unknown options through the AVOption system is welcome. A full list of AVOptions can be found in the FFmpeg manual. This is a key/value list option. See List Options for details. Delays primary subtitles by seconds. Can be negative. Delays secondary subtitles by seconds. Can be negative. Add a subtitle file to the list of external subtitles. If you use only once, this subtitle file is displayed by default. If is used multiple times, the subtitle to use can be switched at runtime by cycling subtitle tracks. It's possible to show two subtitles at once: use to select the first subtitle index, and to select the second index. (The index is printed on the terminal output after the in the list of streams.) is a path list option (see List Options for details), and can take multiple file names separated by (Unix) or (Windows), while takes a single filename, but can be used multiple times to add multiple files. Technically, is a CLI/config file only alias for . Select a secondary subtitle stream. This is similar to . If a secondary subtitle is selected, it will be rendered as toptitle (i.e. on the top of the screen) alongside the normal subtitle by default, and provides a way to render two subtitles at once. There are some caveats associated with this feature. For example, bitmap subtitles will always be rendered in their usual position, so selecting a bitmap subtitle as secondary subtitle will result in overlapping subtitles. Secondary subtitles are never shown on the terminal if video is disabled. Styling and interpretation of any formatting tags is disabled for the secondary subtitle. Internally, the same mechanism as is used to strip the styling. If the main subtitle stream contains formatting tags which display the subtitle at the top of the screen, it will overlap with the secondary subtitle. To prevent this, you could use to disable styling in the main subtitle stream. This affects ASS subtitles as well, and may lead to incorrect subtitle rendering. Use with care, or use instead. When set to yes, also apply to typesetting (or \"signs\"). When this is set to no, is only applied to dialogue. The distinction between dialogue and typesetting is done on a best effort basis and is not infallible (default: no). Whether to scale subtitles with the window size (default: yes). If this is disabled while is set to yes, changing the window size won't change the subtitle font size. Affects plain text subtitles only (or ASS if is set high enough). Make the subtitle font size relative to the window (default: yes). If this is disabled while is set to yes, the subtitle font size is scaled relative to the video size instead. Affects plain text subtitles only (or ASS if is set high enough). By default, the subtitle font size is scaled with the window size. To make the font size constant, set only to no. To make the font size scale with video size instead, set only to no. It's not meaningful to set both options to no. Like , but affects subtitles in ASS format only. Like , this can break ASS subtitles. Use fonts embedded in Matroska container files and ASS scripts (default: yes). These fonts can be used for SSA/ASS subtitle rendering. Specify the position of subtitles on the screen. The value is the vertical position of the subtitle in % of the screen height. 100 is the original position, which is often not the absolute bottom of the screen, but with some margin between the bottom and the subtitle. Values above 100 move the subtitle further down. Text subtitles (as opposed to image subtitles) may be cut off if the value of the option is above 100. This is a libass restriction. This affects ASS subtitles as well, and may lead to incorrect subtitle rendering in addition to the problem above. Using can achieve this in a better way. Specify the position of secondary subtitles on the screen. This is similar to but for secondary subtitles. Multiply the subtitle event timestamps with the given value. Can be used to fix the playback speed for frame-based subtitle formats. Affects text subtitles only. plays frame based subtitles which have been loaded assuming a framerate of 23.976 at 25 FPS. This is a string list option. See List Options for details. Using this option may lead to incorrect subtitle rendering. Enabling hinting can lead to mispositioned text (in situations it's supposed to match up video background), or reduce the smoothness of animations with some badly authored ASS scripts. It is recommended to not use this option, unless really needed. Set the text layout engine used by libass. uses Fribidi only, fast, doesn't render some languages correctly is the default. If libass hasn't been compiled against HarfBuzz, libass silently reverts to . Set the delay for automatic pruning of events from memory in libass. When enabled, subtitle events are removed from memory once their end timestamp is older than the specified delay. specify how many seconds after an event is no longer displayed should the pruning occur. prunes events as soon as they're off screen. This breaks sub-seek and subtitle rendering when changing play-direction from forward to backward during runtime for events that were already \"seen\" and need to be rendered again, if those events got pruned. Load all SSA/ASS styles found in the specified file and use them for rendering text subtitles. The syntax of the file is exactly like the / section of SSA/ASS. Using this option may lead to incorrect subtitle rendering. Control whether user style overrides should be applied. Note that all of these overrides try to be somewhat smart about figuring out whether or not a subtitle is considered a \"sign\" and try to be as non-destructive as possible. Render subtitles as specified by the subtitle scripts, without overrides. Apply all the style override options. Changing the default for any of these options can lead to incorrect subtitle rendering. Like , but also apply (default). Like , but also force all options. Can break rendering easily. Certain options aren't overridden if they can potentially be too destructive. Radically strip all ASS tags and styles from the subtitle. This is equivalent to the old / options. This also controls some bitmap subtitle overrides, as well as HTML tags in formats like SRT, despite the name of the option. Control whether user secondary substyle overrides should be applied. This works exactly like . Enables placing toptitles and subtitles in black borders when they are available, if the subtitles are in the ASS format. Enables placing toptitles and subtitles in black borders when they are available, if the subtitles are in a plain text format (or ASS if is set high enough). Controls which information about the video stream is passed to libass. Any option but is incompatible with standard ASS as defined by VSFilter, whose behavior most subtitle scripts and renderers target, including libass. Video stream properties are needed to accurately emulate VSFilter semantics and withholding them will likely result in broken subtitle rendering for most files. It's thus recommended to only change this selectively if required on a per-file basis. Only forward aspect ratio; fallbacks are used for other properties. This makes behavior consistent across different video resolutions. For certain kinds of broken ASS files which got repurposed across several video resolutions without either setting headers or adjusting affected effects, it may be desirable to withhold storage resolution information from libass to ensure consistent rendering across resolutions. Among others this affects 3D rotations and blurs. When encountering such files, try setting . Even more broken files on anamorphic video might also exhibit stretching unless aspect ratio information is also faked, in this case you can try using . This has never an effect on non-anamorphic video. Allows passing any arbitrary aspect ratio to libass instead of the video’s actual aspect ratio. Zero aspect ratio is identical to . This has no effect if is set to . Set implicit bidi detection to instead of to match ASS' default. This also disables libass' incompatible extensions. This currently includes bracket pair matching according to the revised Unicode Bidirectional Algorithm introduced in Unicode 6.3, and also affects how BiDi runs are split and processed, as well as soft linewrapping of Unicode text. This affects plaintext (non-ASS) subtitles only. Default: no. Mangle colors like (xy-)vsfilter do (default: basic). Historically, VSFilter was not color space aware. This was no problem as long as the color space used for SD video (BT.601) was used. But when everything switched to HD (BT.709), VSFilter was still converting RGB colors to BT.601, rendered them into the video frame, and handled the frame to the video output, which would use BT.709 for conversion to RGB. The result were mangled subtitle colors. Later on, bad hacks were added on top of the ASS format to control how colors are to be mangled. Handle only BT.601->BT.709 mangling, if the subtitles seem to indicate that this is required (default). Handle the full header with all video color spaces supported by libass and mpv. This might lead to bad breakages in corner cases and is not strictly needed for compatibility (hopefully), which is why this is not default. Force BT.601->BT.709 mangling, regardless of subtitle headers or video color space. Choosing anything other than will make the subtitle color depend on the video color space, and it's for example in theory not possible to reuse a subtitle script with another video file. The option doesn't affect how this option is interpreted. Stretch DVD subtitles when playing anamorphic videos for better looking fonts on badly mastered DVDs. This switch has no effect when the video is stored with square pixels - which for DVD input cannot be the case though. Many studios tend to use bitmap fonts designed for square pixels when authoring DVDs, causing the fonts to look stretched on playback on DVD players. This option fixes them, however at the price of possibly misaligning some subtitles (e.g. sign translations). Stretch DVD and other image subtitles to the screen, ignoring the video margins. This has a similar effect as for text subtitles, except that the text itself will be stretched, not only just repositioned. (At least in general it is unavoidable, as an image bitmap can in theory consist of a single bitmap covering the whole screen, and the player won't know where exactly the text parts are located.) This option does not display subtitles correctly. Use with care. Override the image subtitle resolution with the video resolution (default: no). Normally, the subtitle canvas is fit into the video canvas (e.g. letterboxed). Setting this option uses the video size as subtitle canvas size. Can be useful to test broken subtitles, which often happen when the video was transcoded, while attempting to keep the old subtitles. This has been deprecated by . You also may need to get the same behavior. Also, using should give better results without breaking subtitles too much. If is specified, all tags and style declarations are stripped and ignored on display. The subtitle renderer uses the font style as specified by the options instead. Using may lead to incorrect or completely broken rendering of ASS/SSA subtitles. It can sometimes be useful to forcibly override the styling of ASS subtitles, but should be avoided in general. Load additional subtitle files matching the video filename. The parameter specifies how external subtitle files are matched. is enabled by default. Load the media filename with subtitle file extension and possibly language suffixes (default). Load all subs containing the media filename. Load all subs in the current and directories. Subtitle extensions to try and match when using . Note that modifying this list will also affect what mpv recognizes as subtitles when using drag and drop. This is a string list option. See List Options for details. You can use this option to specify the subtitle codepage. uchardet will be used to guess the charset. (If mpv was not compiled with uchardet, then is the effective default.) The default value for this option is , which enables autodetection. The following steps are taken to determine the final codepage, in order:\n• if the specific codepage has a , use that codepage\n• if the data looks like UTF-8, assume it is UTF-8\n• if is set to a specific codepage, use that\n• run uchardet, and if successful, use that\n• Use Latin 2 if input is not UTF-8. The pseudo codepage is used internally. If it's set, subtitles are interpreted as UTF-8 with \"Latin 1\" as fallback for bytes which are not valid UTF-8 sequences. iconv is never involved in this mode. This works for text subtitle files only. Other types of subtitles (in particular subtitles in mkv files) are always assumed to be UTF-8. Stretch a subtitle duration so it ends when the next one starts. Should help with subtitles which erroneously have zero durations. Adjust subtitle timing is to remove minor gaps or overlaps between subtitles (if the difference is smaller than 210 ms, the gap or overlap is removed). Enabling this displays only forced events within subtitle streams. Only some bitmap subtitle formats (such as DVD or PGS) are capable of having a mixture of forced and unforced events within the stream. Enabling this on text subtitles will cause no subtitles to be displayed (default: ). Specify the framerate of the subtitle file (default: video fps). Affects text subtitles only. > video fps speeds the subtitles up for frame-based subtitle files and slows them down for time-based ones. Apply Gaussian blur to image subtitles (default: 0). This can help to make pixelated DVD/Vobsubs look nicer. A value other than 0 also switches to software subtitle scaling. Might be slow. Convert image subtitles to grayscale. Can help to make yellow DVD/Vobsubs look nicer. Specify extra directories to search for subtitles matching the video. Multiple directories can be separated by \":\" (\";\" on Windows). Paths can be relative or absolute. Relative paths are interpreted relative to video file directory. If the file is a URL, only absolute paths and configuration subdirectory will be scanned. Assuming that is played and is specified, mpv searches for subtitle files in these directories: This is a path list option. See List Options for details. Can be used to disable display of subtitles, but still select and decode them. Can be used to disable display of secondary subtitles, but still select and decode them. (Obscure, rarely useful.) Can be used to play broken mkv files with duplicate ReadOrder fields. ReadOrder is the first field in a Matroska-style ASS subtitle packets. It should be unique, and libass uses it for fast elimination of duplicates. This option disables caching of subtitles across seeks, so after a seek libass can't eliminate subtitle packets with the same ReadOrder as earlier packets. Note that enabling this option can result in broken subtitle behavior if you are not actually playing one of the aforementioned broken mkv files. This works for subtitle streams, and if FFmpeg has been compiled with support for it. Values are for individual pages. Special value (default) matches all subtitle pages. Special value matches all pages. Note that page is the default start page of actual teletext. It is also the former default value of this option. See the section in FFmpeg documentation for details. After the last frame of video, if this option is enabled, subtitles will continue to update based on audio timestamps. Otherwise, the subtitles for the last video frame will stay onscreen. Specify font to use for subtitles that do not themselves specify a particular font. The default is . The option (and many other style related options) are ignored when ASS-subtitles are rendered, unless is specified. This used to support fontconfig patterns. Starting with libass 0.13.0, this stopped working. Specify the sub font size. The unit is the size in scaled pixels at a window height of 720. The actual pixel size is scaled with the window height: if the window height is larger or smaller than 720, the actual size of the text increases or decreases as well. Gaussian blur factor applied to the sub font border. 0 means no blur applied (default). See . Color used for the sub font outline. is an alias for . See . Color used for sub text background. is an alias for . Size of the sub font outline in scaled pixels (see for details). A value of 0 disables outlines. is an alias for .\n• : draw outline and shadow. The size of the outline is determined by , and the offset of the shadow is determined by . The outline is colored by , and the shadow is colored by . This corresponds to in the ASS spec.\n• : draw outline and shadow as opaque boxes that tightly wrap each lines of text. The margin of the outline opaque box is determined by , and the offset of the shadow opaque box is determined by . The outline opaque box is colored by , and the shadow opaque box is colored by . Despite its name, the opaque box can be semi-transparent. This corresponds to in the ASS spec.\n• : draw a background box that bounds all lines of text. The background box is colored by , and the margin of the background box is determined by . The behavior of the outline is the same as the style. This corresponds to , which is a libass-specific extension. Predefined profiles are available to enable optimized style for OSD and subtitles.\n• applies the style to the OSD, including stats and console\n• applies the style to both subtitles and OSD Specify the color used for unstyled text subtitles. The color is specified in the form , where each color component is specified as number in the range 0.0 to 1.0. It's also possible to specify the transparency by using , where the alpha value 0 means fully transparent, and 1.0 means opaque. If the alpha component is not given, the color is 100% opaque. Passing a single number to the option sets the sub to gray, and the form lets you specify alpha additionally.\n• set sub to opaque red with 75% alpha\n• set sub to 50% gray with 75% alpha Alternatively, the color can be specified as a RGB hex triplet in the form , where each 2-digit group expresses a color value in the range 0 ( ) to 255 ( ). For example, is red. Alpha is given with .\n• set sub to 50% gray with 75% alpha Left and right screen margin for the subs in scaled pixels (see for details). This option specifies the distance of the sub to the left, as well as at which distance from the right border long sub text will be broken. Top and bottom screen margin for the subs in scaled pixels (see for details). This option specifies the vertical margins of unstyled text subtitles. If you just want to raise the vertical subtitle position, use . Control to which corner of the screen text subtitles should be aligned to (default: ). Never applied to ASS subtitles, except in mode. Likewise, this does not apply to image subtitles. Control how multi line subs are justified irrespective of where they are aligned (default: which justifies as defined by ). Left justification is recommended to make the subs easier to read as it is easier for the eyes. Applies justification as defined by on ASS subtitles if is not set to . Default: . Displacement of the sub text shadow in scaled pixels (see for details). A value of 0 disables shadows. Horizontal sub font spacing in scaled pixels (see for details). This value is added to the normal letter spacing. Negative values are allowed. Applies filter removing subtitle additions for the deaf or hard-of-hearing (SDH). This is intended for English, but may in part work for other languages too. The intention is that it can be always enabled so may not remove all parts added. It removes speaker labels (like MAN:) and any text enclosed within symbols like parentheses or brackets as specified by the option. Note that parenthesis (full width parenthesis and the normal variant) are a special case and only upper case text is removed. For more filtering, you can use the option. Do harder SDH filtering (if enabled by ). Will also remove speaker labels and text within parentheses using both lower and upper case letters. Specify a string of characters that will use to potentially remove text. Text that is enclosed within characters specified by this string will be removed. Note that bracket characters with known pairs (such as or ) will be mapped internally to their matching right hand character, so you only need to specify left hand characters. Set a list of regular expressions to match on text subtitles, and remove any lines that match (default: empty). This is a string list option. See List Options for details. Normally, you should use , where each option use will append a new regular expression, without having to fight escaping problems. List items are matched in order. If a regular expression matches, the process is stopped, and the subtitle line is discarded. The text matched against is, by default, the field of ASS events (if the subtitle format is different, it is always converted). This may include formatting tags. Matching is case-insensitive, but how this is done depends on the libc, and most likely works in ASCII only. It does not work on bitmap/image subtitles. Unavailable on inferior OSes (requires POSIX regex support). Technically, using a list for matching is redundant, since you could just use a single combined regular expression. But it helps with diagnosis, ease of use, and temporarily disabling or enabling individual filters. This is experimental. The semantics most likely will change, and if you use this, you should be prepared to update the option later. Ideas include replacing the regexes with a very primitive and small subset of sed, or some method to control case-sensitivity. Same as but with JavaScript regular expressions. Shares/affected-by all control options (see below), and also experimental. Requires only JavaScript support. Whether to first convert the ASS \"Text\" field to plain-text (default: no). This strips ASS tags and applies ASS directives, like to new-line. If the result is multi-line then the regexp anchors and match each line, but still any match discards all lines. Log dropped lines with warning log level, instead of verbose (default: no). Helpful for testing. Whether to enable regex filtering (default: yes). Note that if no regexes are added to the list, setting this option to has no effect. It's meant to easily disable or enable filtering temporarily. For every video stream, create a closed captions track (default: no). The only purpose is to make the track available for selection at the start of playback, instead of creating it lazily. This applies only to (displayed by mpv as subtitle tracks using the codec ). The CC track is marked \"default\" and selected according to the normal subtitle track selection rules. You can then use to explicitly select the correct track too. If the video stream contains no closed captions, or if no video is being decoded, the CC track will remain empty and will not show any text. Which libass font provider backend to use (default: auto). will attempt to use the native font provider: fontconfig on Linux, CoreText on macOS, DirectWrite on Windows. forces fontconfig, if libass was built with support (if not, it behaves like ). The font provider effectively disables system fonts. It will still attempt to use embedded fonts (unless is set; this is the same behavior as with all other font providers), if provided, and fonts in the sub-directory if provided. (The fallback is more strict than that of other font providers, and if a font name does not match, it may prefer not to render any text that uses the missing font.) Font files in this directory are used by mpv/libass for subtitles. Useful if you do not want to install fonts to your system. Note that files in this directory are loaded into memory before being used by mpv. If you have a lot of fonts, consider using fonts.conf (see FILES section) to include additional mpv user settings. If this option is not specified, will be used by default. Set the window title. This is used for the video window, and if possible, also sets the audio stream title. There is a danger of this causing significant CPU usage, depending on the properties used. Changing the window title is often a slow operation, and if the title changes every frame, playback can be ruined. In multi-monitor configurations (i.e. a single desktop that spans across multiple displays), this option tells mpv which screen to display the video on. This option does not work properly with all window managers. In these cases, you can try to use to position the window explicitly. It's also possible that the window manager provides native features to control which screens application windows should use. This option does not actually work on wayland since window placement is not allowed. However setting this option does influence mpv's initial guess at finding an output which may be useful for options like or which depend on the monitor resolution. In multi-monitor configurations, this option tells mpv which screen to display the video on based on the screen name from the video backend. The same caveats in the option also apply here. This option is ignored and does nothing if is explicitly set. In multi-monitor configurations (i.e. a single desktop that spans across multiple displays), this option tells mpv which screen to go fullscreen to. If is used mpv will fallback on what the user provided with the option. This option works properly only with window managers which understand the EWMH hint. does not work on macOS and will behave like . In multi-monitor configurations, this option tells mpv which screen to go fullscreen to based on the screen name from the video backend. The same caveats in the option also apply here. This option is ignored and does nothing if is explicitly set. Do not terminate when playing or seeking beyond the end of the file, and there is no next file to be played (and is not used). Instead, pause the player. When trying to seek beyond end of the file, the player will attempt to seek to the last frame. Normally, this will act like on EOF, unless the option is set. The following arguments can be given: If the current file ends, go to the next file or terminate. (Default.) Don't terminate if the current file is the last playlist entry. Equivalent to without arguments. Like , but also applies to files before the last playlist entry. This means playback will never automatically advance to the next file. This option is not respected when using . Explicitly skipping to the next file if the binding uses will terminate playback as well. Also, if errors or unusual circumstances happen, the player can quit anyway. Since mpv 0.6.0, this doesn't pause if there is a next file in the playlist, or the playlist is looped. Approximately, this will pause when the player would normally exit, but in practice there are corner cases in which this is not the case (e.g. will play file.mkv normally, then fail to open , then exit). (In mpv 0.8.0, was introduced, which restores the old behavior.) If set to , instead of pausing when is active, just stop at end of file and continue playing forward when you seek backwards until end where it stops again. Default: . If the current file is an image, play the image for the given amount of seconds (default: 5). means the file is kept open forever (until the user stops playback manually). Unlike , the player is not paused, but simply continues playback until the time has elapsed. (It should not use any resources during \"playback\".) This affects image files, which are defined as having only 1 video frame and no audio. The player may recognize certain non-images as images, for example if is used to reduce the length to 1 frame, or if you seek to the last frame. This option does not affect the framerate used for or . For that, use instead. When viewing images, the playback time is not tracked on the command line output, and the image frame is not duplicated when encoding. To force the player into \"dumb mode\" and actually count out seconds, or to duplicate the image when encoding, you need to use , and use or to stop after a particular time. Create a video output window even if there is no video. This can be useful when pretending that mpv is a GUI application. Currently, the window always has the size 960x540, and is subject to , , and similar options. The window is created only after initialization (to make sure default window placement still works if the video size is different from the default window size). This can be a problem if initialization doesn't work perfectly, such as when opening URLs with bad network connection, or opening broken video files. The mode can be used to create the window always on program start, but this may cause other issues. (Windows only) Enable/disable playback progress rendering in taskbar (Windows 7 and above). (Windows only) Snap the player window to screen edges. Controls the default behavior of drag and drop on platforms that support this. will obey what the underlying os/platform gives mpv. Typically, holding shift during the drag and drop will append the item to the playlist. Otherwise, it will completely replace it. , , and always force replacing, appending to, and inserting next into the playlist respectively. disables all drag and drop behavior. Makes the player window stay on top of other windows. On Windows, if combined with fullscreen mode, this causes mpv to be treated as exclusive fullscreen window that bypasses the Desktop Window Manager. (macOS only) Sets the level of an on-top window (default: window). On top of all other windows. On top of system elements like Taskbar, Menubar and Dock. On top of the Desktop behind windows and Desktop icons. (macOS only) Focus the video window and make it the front most window on specific events (default: open). Never focus the window on open or new file load events. Focus the window on creation, eg when a vo is initialised. Focus the window on open and new file load event. (Windows only) Set the preference for window corner rounding. Let the system decide whether or not to round window corners Round the corners if appropriate Round the corners if appropriate, with a small radius Play video with window border and decorations. Since this is on by default, use to disable the standard window decorations. (Windows and X11 only) Play video with the window title bar. Since this is on by default, use to hide the title bar. The option takes precedence. (X11 and macOS only) Show the video window on all virtual desktops. Adjust the initial window position or size. and set the window size in pixels. and set the window position, measured in pixels from the top-left corner of the screen to the top-left corner of the image being displayed. If a percentage sign ( ) is given after the argument, it turns the value into a percentage of the screen size in that direction. Positions are specified similar to the standard X11 option format, in which e.g. +10-50 means \"place 10 pixels from the left border and 50 pixels from the lower border\" and \"--20+-10\" means \"place 20 pixels beyond the right and 10 pixels beyond the top border\". A trailing followed by an integer denotes on which workspace (virtual desktop) the window should appear (X11 only). If an external window is specified using the option, this option is ignored. The coordinates are relative to the screen given with for the video output drivers that fully support . Generally only supported by GUI VOs. Ignored for encoding. On macOS, the origin of the screen coordinate system is located on the bottom-left corner. For instance, will place the window at the bottom-left of the screen. This option does not work properly with all window managers. Wayland does not allow a client to position itself so this option will only affect the window size. Places the window in the middle of the screen. Places the window at the bottom right corner of the screen. Sets the window width to half the screen width. Window height is set so that the window has the video aspect ratio. Forces the window width and height to half the screen width and height. Will show black borders to compensate for the video aspect ratio (with most VOs and with ). Sets the window to half the screen widths, and positions it 10 pixels below/left of the top left corner of the screen, on the second workspace. See also and for fitting the window into a given size without changing aspect ratio. Set the initial window size to a maximum size specified by , without changing the window's aspect ratio. The size is measured in pixels, or if a number is followed by a percentage sign ( ), in percents of the screen size. This option never changes the aspect ratio of the window. If the aspect ratio mismatches, the window's size is reduced until it fits into the specified size. Window position is not taken into account, nor is it modified by this option (the window manager still may place the window differently depending on size). Use to change the window position. Its effects are applied after this option. See for details how this is handled with multi-monitor setups. Use instead if you just want to limit the maximum size of the window, rather than always forcing a window size. Use if you want to force both window width and height to a specific size. Generally only supported by GUI VOs. Ignored for encoding. Make the window width 70% of the screen size, keeping aspect ratio. Make the window as large as possible, without being wider than 70% of the screen width, or higher than 60% of the screen height. This option behaves exactly like , except that it sets the maximum size of the window. If the video is larger than 90% of the screen width or 80% of the screen height, make the window smaller until either its width is 90% of the screen, or its height is 80% of the screen. This option behaves exactly like , except that it sets the minimum size of the window (just as sets the maximum). Make the window at least 500 pixels wide and 500 pixels high (depending on the video aspect ratio, the width or height will be larger than 500 in order to keep the aspect ratio the same). Resize the video window to a multiple (or fraction) of the video size. This option is applied before and other options are applied (so they override this option). Changing this option while the window is maximized can unmaximize the window depending on the OS and window manager. If the window does not unmaximize, the multiplier will be applied if the user unmaximizes the window later. For example, would show the window at half the video size. Whether the video window is minimized or not. Setting this will minimize, or unminimize, the video window if the current VO supports it. Note that some VOs may support minimization while not supporting unminimization (eg: Wayland). Whether this option and work on program start or at runtime, and whether they're (at runtime) updated to reflect the actual window state, heavily depends on the VO and the windowing system. Some VOs simply do not implement them or parts of them, while other VOs may be restricted by the windowing systems (especially Wayland). Whether the video window is maximized or not. Setting this will maximize, or unmaximize, the video window if the current VO supports it. See for further remarks. Make mouse cursor automatically hide after given number of milliseconds (default: 1000 ms). will disable cursor autohide. means the cursor will stay hidden. If this option is given, the cursor is always visible in windowed mode. In fullscreen mode, the cursor is shown or hidden according to . Change how some video outputs render the OSD and text subtitles. This does not change appearance of the subtitles and only has performance implications. For VOs which support native ASS rendering (like , , ), this can be slightly faster or slower, depending on GPU drivers and hardware. For other VOs, this just makes rendering slower. Forces mpv to always render frames regardless of the visibility of the window. Currently only affects X11 and Wayland VOs since they are the only ones that have this optimization (i.e. everything else always renders regardless of visibility). Forcefully move mpv's video output window to default location whenever there is a change in video parameters, video stream or file. This used to be the default behavior. Currently only affects X11, macvk and SDL VOs. By default, mpv will automatically resize itself if the video's size changes (i.e. advancing forward in a playlist). Setting this to disables this behavior so the window size never changes automatically. This option does not have any impact on the or options. will always stretch the video to window size, and will disable the window manager hints that force the window aspect ratio. (Ignored in fullscreen mode.) Set the aspect ratio of your monitor or TV screen. A value of 0 disables a previous setting (e.g. in the config file). Overrides the setting if enabled. See also and . Scale the window size according to the backing DPI scale factor from the OS (default: no). For example, if the OS DPI scaling is set to 200%, mpv's window size will be multiplied by 2. (macOS only) Uses the native fullscreen mechanism of the OS (default: yes). (Windows and X11 only) Show mpv in the taskbar (default: yes). If set to no, mpv will no longer appear in taskbars and tasklists in supported window managers, and may be excluded from Alt+Tab window switching. Set the aspect of a single pixel of your monitor or TV screen (default: 1). A value of 1 means square pixels (correct for (almost?) all LCDs). See also and . Turns off the screensaver (or screen blanker and similar mechanisms) at startup and turns it on again on exit (default: yes). When using , the screensaver will re-enable when playback is not active. will always disable the screensaver. Note that stopping the screensaver is only possible if a video output is available (i.e. there is an open mpv window). This is not supported on all video outputs, platforms, or desktop environments. Before mpv 0.33.0, the X11 backend ran in 10 second intervals when not paused in order to support screensaver inhibition in some environments. This functionality was removed in 0.33.0, but it is possible to call the command line program from a user script instead. This tells mpv to attach to an existing window. If a VO is selected that supports this option, it will use that window for video output. mpv will scale the video to the size of this window, and will add black bars to compensate if the aspect ratio of the video is different. On X11, the ID is interpreted as a on X11. Unlike MPlayer/mplayer2, mpv always creates its own window, and sets the wid window as parent. The window will always be resized to cover the parent window fully. The value is interpreted specially, and mpv will draw directly on the root window. On win32, the ID is interpreted as . Pass it as value cast to (all Windows handles are 32-bit), this is important as mpv will not accept negative values. mpv will create its own window and set the wid window as parent, like with X11. On Android, the ID is interpreted as . Pass it as a value cast to . Use with and for direct rendering using MediaCodec, or with (with or without ). Move the window when clicking on it and moving the mouse pointer (default: yes). Set the window instance name for X11-based video output methods. (X11 only) Control the use of NetWM protocol features. This may or may not help with broken window managers. This provides some functionality that was implemented by the now removed option. Actually, it is not known to the developers to which degree this option was needed, so feedback is welcome. Specifically, will force use of NetWM fullscreen support, even if not advertised by the WM. This can be useful for WMs that are broken on purpose, like XMonad. (XMonad supposedly doesn't advertise fullscreen support, because Flash uses it. Apparently, applications which want to use fullscreen anyway are supposed to either ignore the NetWM support hints, or provide a workaround. Shame on XMonad for deliberately breaking X protocols (as if X isn't bad enough already). This option might be removed in the future. If set to , then ask the compositor to unredirect the mpv window (default: ). This uses the hint. asks the window manager to disable the compositor only in fullscreen mode. sets to 0, which is the default value as declared by the EWMH specification, i.e. no change is done. asks the window manager to never disable the compositor. Whether or not to use presentation statistics from X11's presentation extension (default: ). mpv asks X11 for present events which it then may use for more accurate frame presentation. This only has an effect if is being used. The auto option enumerates XRandr providers for autodetection. If amd, radeon, intel, or nouveau (the standard x86 Mesa drivers) is found presentation feedback is enabled. Other drivers are not assumed to work, so they are not enabled automatically. or can still be passed regardless to enable/disable this mechanism in case there is good/bad behavior with whatever your combination of hardware/drivers/etc. happens to be. Whether or not to set the window title when mpv is embedded on X11 (default: ). Specify the CD device for CDDA playback. The default device path depends on the OS. See the OPTICAL DRIVES section. Specify the DVD device or .iso filename. You can also specify a directory that contains files previously copied directly from a DVD (with e.g. vobcopy). The default device path depends on the OS. See the OPTICAL DRIVES section. Specify the Blu-ray disc location. Must be a directory with Blu-ray structure. The default device path depends on the OS. See the OPTICAL DRIVES section. These options can be used to tune the CD Audio reading feature of mpv. Set paranoia level. Values other than 0 seem to break playback of anything but the first track. Force minimum overlap search during verification to <value> sectors. Add sectors to the values reported when addressing tracks. May be negative. Print CD text. This is disabled by default, because it ruins performance with CD-ROM drives for unknown reasons. Try to limit DVD speed (default: 0, no change). DVD base speed is 1385 kB/s, so an 8x drive can read at speeds up to 11080 kB/s. Slower speeds make the drive more quiet. For watching DVDs, 2700 kB/s should be quiet and fast enough. mpv resets the speed to the drive default value on close. Values of at least 100 mean speed in kB/s. Values less than 100 mean multiples of 1385 kB/s, i.e. selects 11080 kB/s. You need write access to the DVD device to change the speed. Some DVDs contain scenes that can be viewed from multiple angles. This option tells mpv which angle to use (default: 1). Adjust the brightness of the video signal (default: 0). Not supported by all video output drivers. Adjust the contrast of the video signal (default: 0). Not supported by all video output drivers. Adjust the saturation of the video signal (default: 0). You can get grayscale output with this option. Not supported by all video output drivers. Adjust the gamma of the video signal (default: 0). Not supported by all video output drivers. Adjust the hue of the video signal (default: 0). You can get a colored negative of the image with this option. Not supported by all video output drivers. Force demuxer type. Use a '+' before the name to force it; this will skip some checks. Give the demuxer name as printed by . Maximum length in seconds to analyze the stream properties. Whether to probe stream information (default: auto). Technically, this controls whether libavformat's function is called. Usually it's safer to call it, but it can also make startup slower. The choice (the default) tries to skip this for a few know-safe whitelisted formats, while calling it for everything else. The choice only calls it if and only if the file seems to contain no streams after opening (helpful in cases when calling the function is needed to detect streams at all, such as with FLV files). Minimum required libavformat probe score. Lower values will require less data to be loaded (makes streams start faster), but makes file format detection less reliable. Can be used to force auto-detected libavformat demuxers, even if libavformat considers the detection not reliable enough. (Default: 26.) Allow deriving the format from the HTTP MIME type (default: yes). Set this to no in case playing things from HTTP mysteriously fails, even though the same files work from local disk. This is default in order to reduce latency when opening HTTP streams. By default, some formats will be handled differently from other formats by explicitly checking for them. Most of these compensate for weird or imperfect behavior from libavformat demuxers. Passing disables these. For debugging and testing only. Note, a patch to make the o= unneeded and pass all unknown options through the AVOption system is welcome. A full list of AVOptions can be found in the FFmpeg manual. Note that some options may conflict with mpv options. This is a key/value list option. See List Options for details. Maximum amount of data to probe during the detection phase. In the case of MPEG-TS this value identifies the maximum number of TS packets to scan. Size of the stream read buffer allocated for libavformat in bytes (default: 32768). Lowering the size could lower latency. Note that libavformat might reallocate the buffer internally, or not fully use all of it. Attempt to linearize timestamp resets in demuxed streams (default: auto). This was tested only for single audio streams. It's unknown whether it works correctly for video (but likely won't). Note that the implementation is slightly incorrect either way, and will introduce a discontinuity by about 1 codec frame size. The mode enables this for OGG audio stream. This covers the common and annoying case of OGG web radio streams. Some of these will reset timestamps to 0 every time a new song begins. This breaks the mpv seekable cache, which can't deal with timestamp resets. Note that FFmpeg/libavformat's seeking API can't deal with this either; it's likely that if this option breaks this even more, while if it's disabled, you can at least seek within the first song in the stream. Well, you won't get anything useful either way if the seek is outside of mpv's cache. Propagate FFmpeg-level options to recursively opened connections (default: yes). This is needed because FFmpeg will apply these settings to nested AVIO contexts automatically. On the other hand, this could break in certain situations - it's the FFmpeg API, you just can't win. This affects in particular the option and anything passed with . If this option is deemed unnecessary at some point in the future, it will be removed without notice. Try harder to show embedded soft subtitles when seeking somewhere. Normally, it can happen that the subtitle at the seek target is not shown due to how some container file formats are designed. The subtitles appear only if seeking before or exactly to the position a subtitle first appears. To make this worse, subtitles are often timed to appear a very small amount before the associated video frame, so that seeking to the video frame typically does not demux the subtitle at that position. Enabling this option makes the demuxer start reading data a bit before the seek target, so that subtitles appear correctly. Note that this makes seeking slower, and is not guaranteed to always work. It only works if the subtitle is close enough to the seek target. Works with the internal Matroska demuxer only. Always enabled for absolute and hr-seeks, and this option changes behavior with relative or imprecise seeks only. You can use the option to specify how much data the demuxer should pre-read at most in order to find subtitle packets that may overlap. Setting this to 0 will effectively disable this preroll mechanism. Setting a very large value can make seeking very slow, and an extremely large value would completely reread the entire file from start to seek target on every seek - seeking can become slower towards the end of the file. The details are messy, and the value is actually rounded down to the cluster with the previous video keyframe. Some files, especially files muxed with newer mkvmerge versions, have information embedded that can be used to determine what subtitle packets overlap with a seek target. In these cases, mpv will reduce the amount of data read to a minimum. (Although it will still read all data between the cluster that contains the first wanted subtitle packet, and the seek target.) If the choice (which is the default) is specified, then prerolling will be done only if this information is actually available. If this method is used, the maximum amount of data to skip can be additionally controlled by (it still uses the value of the option without if that is higher). See also option. This option can achieve a similar effect, but only if hr-seek is active. It works with any demuxer, but makes seeking much slower, as it has to decode audio and video data instead of just skipping over it. Check the start time of Matroska files (default: yes). This simply reads the first cluster timestamps and assumes it is the start time. Technically, this also reads the first timestamp, which may increase latency by one frame (which may be relevant for live streams). When opening the file, seek to the end of it, and check what timestamp the last video packet has, and report that as file duration. This is strictly for compatibility with Haali only. In this mode, it's possible that opening will be slower (especially when playing over http), or that behavior with broken files is much worse. So don't use this option. The mode merely uses the index and reads a small number of blocks from the end of the file. The mode actually traverses the entire file and can make a reliable estimate even without an index present (such as partial files). Enable compatibility mode for files that do not fully comply with the Matroska specification. (default: yes) Most files containing cropping metadata require this mode to display correctly. If this option is enabled, crop metadata will be applied before calculating the video's aspect ratio, ensuring it is cropped accordingly. If this option is disabled, the image will be cropped first and then stretched to match DisplayWidth and DisplayHeight. According to the Matroska specification, the Pixel Aspect Ratio (PAR) should be calculated after cropping. However, the majority of files do not adhere to this rule, as it would cause incompatibility with crop-unaware players. Additionally, MKVToolNix does not automatically adjust DisplayWidth and DisplayHeight when cropping metadata is applied, leading to most of files created with it also failing to conform to the specification. See for more details: https://github.com/ietf-wg-cellar/matroska-specification/pull/947 https://gitlab.com/mbunkus/mkvtoolnix/-/issues/2389 https://github.com/mpv-player/mpv/pull/13446 Number of channels (or channel layout) if is used (default: stereo). Sample format for (default: s16le). Use to get a list of all formats. Rate in frames per second for (default: 25.0). Color space (fourcc) in hex or string for (default: ). Color space by internal video format for . Use for a list of possible formats. Set the video codec instead of selecting the rawvideo codec when using . This uses the same values as codec names in (but it does not accept decoder names). Frame size in bytes when using . This controls how much the demuxer is allowed to buffer ahead. The demuxer will normally try to read ahead as much as necessary, or as much is requested with . The option can be used to restrict the maximum readahead. This limits excessive readahead in case of broken files or desynced playback. The demuxer will stop reading additional packets as soon as one of the limits is reached. (The limits still can be slightly overstepped due to technical reasons.) Set these limits higher if you get a packet queue overflow warning, and you think normal playback would be possible with a larger packet queue. See for defaults and value range. options accept suffixes such as and . This controls how much past data the demuxer is allowed to preserve. This is useful only if the cache is enabled. Unlike the forward cache, there is no control how many seconds are actually cached - it will simply use as much memory this option allows. Setting this option to 0 will strictly disable any back buffer, but this will lead to the situation that the forward seek range starts after the current playback position (as it removes past packets that are seek points). If the end of the file is reached, the remaining unused forward buffer space is \"donated\" to the backbuffer (unless the backbuffer size is set to 0, or is set to ). This still limits the total cache usage to the sum of the forward and backward cache, and effectively makes better use of the total allowed memory budget. (The opposite does not happen: free backward buffer is never \"donated\" to the forward buffer.) Keep in mind that other buffers in the player (like decoders) will cause the demuxer to cache \"future\" frames in the back buffer, which can skew the impression about how much data the backbuffer contains. See for defaults and value range. Whether to let the back buffer use part of the forward buffer (default: yes). If set to , the \"donation\" behavior described in the option description for is enabled. This means the back buffer may use up memory up to the sum of the forward and back buffer options, minus the active size of the forward buffer. If set to , the options strictly limit the forward and back buffer sizes separately. Note that if the end of the file is reached, the buffered data stays the same, even if you seek back within the cache. This is because the back buffer is only reduced when new data is read. Debugging option to control whether seeking can use the demuxer cache (default: auto). Normally you don't ever need to set this; the default does the right thing and enables cache seeking it if is set to (or is implied if ). If enabled, short seek offsets will not trigger a low level demuxer seek (which means for example that slow network round trips or FFmpeg seek bugs can be avoided). If a seek cannot happen within the cached range, a low level seek will be triggered. Seeking outside of the cache will start a new cached range, but can discard the old cache range if the demuxer exhibits certain unsupported behavior. The special value means in the same situation as is used (i.e. when the stream appears to be a network stream or the stream cache is enabled). Run the demuxer in a separate thread, and let it prefetch a certain amount of packets (default: yes). Having this enabled leads to smoother playback, enables features like prefetching, and prevents that stuck network freezes the player. On the other hand, it can add overhead, or the background prefetching can hog CPU resources. Disabling this option is not recommended. Use it for debugging only. Number of seconds the player should wait to shutdown the demuxer (default: 0.1). The player will wait up to this much time before it closes the stream layer forcefully. Forceful closing usually means the network I/O is given no chance to close its connections gracefully (of course the OS can still close TCP connections properly), and might result in annoying messages being logged, and in some cases, confused remote servers. This timeout is usually only applied when loading has finished properly. If loading is aborted by the user, or in some corner cases like removing external tracks sourced from network during playback, forceful closing is always used. If is enabled, this controls how much the demuxer should buffer ahead in seconds (default: 1). As long as no packet has a timestamp difference higher than the readahead amount relative to the last packet returned to the decoder, the demuxer keeps reading. Note that enabling the cache (such as , or if the input is considered a network stream, and is used), this option is mostly ignored. ( will override this. Technically, the maximum of both options is used.) The main purpose of this option is to limit the readhead for local playback, since a large readahead value is not overly useful in this case. Once the demuxer limit is reached ( , or ), this value can be used to specify a hysteresis before the demuxer will buffer ahead again. This specifies the maximum number of seconds from the current playback position that needs to be remaining in the cache before the demuxer will continue buffering ahead. For example, with a value of 10 seconds specified, the demuxer will buffer ahead up to the demuxer limit and won't start buffering ahead again until there is only 10 seconds of content left in the cache. This can provide significant power savings and reduce load by making the demuxer only buffer ahead in chunks at a time rather than buffering ahead nonstop to keep the cache filled. If you want to save power and reduce load, configure this to a small number that's much lower than or . If it takes a long time to buffer anything at all for a given stream (like when reading from a very slow disk is involved), then the hysteresis value should be larger to compensate. The default value is 0 seconds, which disables the caching hysteresis. A value of 10 seconds probably works well for most usecases. Prefetch next playlist entry while playback of the current entry is ending (default: yes). This does not prefill the cache with the video data of the next URL. Prefetching video data is supported only for the current playlist entry, and depends on the demuxer cache settings (on by default). This merely opens the URL of the next playlist entry as soon the current URL is fully read. This does not work with URLs resolved by the wrapper, and it won't. This can occasionally make wrong prefetching decisions. For example, it can't predict whether you go backwards in the playlist, and assumes you won't edit the playlist. If the player thinks that the media is not seekable (e.g. playing from a pipe, or it's an http stream with a server that doesn't support range requests), seeking will be disabled. This option can forcibly enable it. For seeks within the cache, there's a good chance of success. Before starting playback, read data until either the end of the file was reached, or the demuxer cache has reached maximum capacity. Only once this is done, playback starts. This intentionally happens before the initial seek triggered with . This does not change any runtime behavior after the initial caching. This option is useless if the file cannot be cached completely. When opening multi-volume rar files, open all volumes to create a full list of contained files (default: no). If disabled, only the archive entries whose headers are located within the first volume are listed (and thus played when opening a .rar file with mpv). Doing so speeds up opening, and the typical idiotic use-case of playing uncompressed multi-volume rar files that contain a single media file is made faster. Opening is still slow, because for unknown, idiotic, and unnecessary reasons libarchive opens all volumes anyway when playing the main file, even though mpv iterated no archive entries yet. When opening a directory, open subdirectories lazily, recursively or not at all. The default is , which behaves like with , and like otherwise. Media file types to filter when opening directory. If the list is empty, all files are added to the playlist. (Default: ) This is a string list option. See List Options for details. When opening a local file, act as if the parent directory is opened and create a playlist automatically. Create a playlist from the parent directory with files matching . Create a playlist from the parent directory with files matching the same category as the currently loaded file. One of the is selected based on the input file and only files with matching extensions are added to the playlist. If the input file itself is not matched to any extension list, the playlist is not autogenerated. Use system settings for keyrepeat delay and rate, instead of and (default: no). Whether this applies depends on the VO backend and how it handles keyboard input. Does not apply to terminal input. (Windows only) For platforms which send emulated mouse inputs for touch-unaware clients, such as Windows, use system native touch events, instead of receiving them as emulated mouse events (default: no). This is required for multi-touch support for these platforms. Note that this option has no effect on other platforms: either native touch is not supported by mpv, or the platform does not give an option to receive emulated mouse inputs (so native touch is always enabled, e.g. Wayland). Delay in milliseconds before we start to autorepeat a key (default: 200). Set it to 0 to disable. Number of key presses to generate per second on autorepeat (default: 40). Specify input configuration file other than the default location in the mpv configuration directory (usually ). Enable default-level (\"weak\") key bindings (default: yes). These are bindings which config files like can override. It currently affects the builtin key bindings, and keys which scripts bind using (but not because this overrides ). Enable loading of built-in key bindings during start-up (default: yes). This option is applied only during (lib)mpv initialization, and if disabled then it will not be not possible to enable them later. May be useful to libmpv clients. Enable the built-in window-dragging behavior (default: yes). Setting it to no disables the built-in dragging behavior. Note that unlike the option, this option only affects VOs which support the command, and does not disable window dragging initialized with the command. Prints all commands that can be bound to keys. Define a list of commands for mpv to run. The syntax is the same as format as but without the key binding argument at the beginning. When this option is set at startup, the commands will run after audio and video playback are about to begin if applicable (in idle mode with no file, it will run immediately). When changing values at runtime, the commands will also run as soon as possible. This is a string list option. See List Options for details. sets the playlist index to 1 and the ao-volume to 40 Time in milliseconds to recognize two consecutive button presses as a double-click (default: 300). Prints all keys that can be bound to commands. Specify the size of the FIFO that buffers key events (default: 7). If it is too small, some events may be lost. The main disadvantage of setting it to a very large value is that if you hold down a key triggering some particularly slow command then the player may be unresponsive while it processes all the queued commands. Input test mode. Instead of executing commands on key presses, mpv will show the keys and the bound commands on the OSD. Has to be used with a dummy video, and the normal ways to quit the player will not work (key bindings that normally quit will be shown on OSD only, just like any other binding). See INPUT.CONF. prevents the player from reading key events from standard input. Useful when reading data from standard input. This is automatically enabled when is found on the command line. There are situations where you have to set it manually, e.g. if you open (or the equivalent on your system), use stdin in a playlist or intend to read from stdin later on via the loadfile or loadlist input commands. Enable the IPC support and create the listening socket at the given path. On Linux and Unix, the given path is a regular filesystem path. On Windows, named pipes are used, so the path refers to the pipe namespace ( ). If the prefix is missing, mpv will add it automatically before creating the pipe, so and are equivalent for IPC on Windows. Connect a single IPC client to the given FD. This is somewhat similar to , except no socket is created, and instead the passed FD is treated like a socket connection received from . In practice, you could pass either a FD created by , or a pipe. In both cases, you must make sure that the FD is actually inherited by mpv (do not set the POSIX flag). The player quits when the connection is closed. This is somewhat similar to the removed option, except it supports only integer FDs, and cannot open actual paths. To use this option on Windows, the fd must refer to a wrapped (created by ) named pipe server handle with a client already connected. The named pipe must be created duplex with overlapped IO and inheritable handles. The program communicates with mpv through the client handle. Writing to the option at runtime will start another instance of an IPC client handler for the option, because initialization is bundled, and this thing is stupid. This is a bug. Writing to at runtime will start another IPC client handler for the new value, without stopping the old one, even if the FD value is the same (but the string is different e.g. due to whitespace). This is not a bug. Permit mpv to receive pointer events reported by the video output driver. Necessary to use the OSC. Support depends on the VO in use. Tell the backend windowing system to allow pointer events to passthrough the mpv window. This allows windows under mpv to instead receive pointer events as if the mpv window was never there. On systems where mpv can choose between receiving media keys or letting the system handle them - this option controls whether mpv should receive them. Default: yes (except for libmpv). macOS and Windows only, because elsewhere mpv doesn't have a choice - the system decides whether to send media keys to mpv. For instance, on X11 or Wayland, system-wide media keys are not implemented. Whether media keys work when the mpv window is focused is implementation-defined. Preprocess events so that while scrolling on the horizontal or vertical direction, the events aren't generated for another direction even when the two directions are scrolled together (default: yes). This preprocessing can be beneficial for preventing accidentally seeking while changing the volume by scrolling on a touchpad with the default keybind. Due to the deadzone mechanism used, disabling the preprocessing allows for diagonal scrolling (such as panning) and potentially reduces input latency. Note that disabling the preprocessing does not affect any filtering done by the OS/driver before these events are delivered to mpv, if any. (macOS and Windows only) Use the right Alt key as Alt Gr to produce special characters. If disabled, count the right Alt as an Alt modifier key. Enabled by default. Disable all keyboard input on for VOs which can't participate in proper keyboard input dispatching. May not affect all VOs. Generally useful for embedding only. On X11, a sub-window with input enabled grabs all keyboard input as long as it is 1. a child of a focused window, and 2. the mouse is inside of the sub-window. It can steal away all keyboard input from the application embedding the mpv window, and on the other hand, the mpv window will receive no input if the mouse is outside of the mpv window, even though mpv has focus. Modern toolkits work around this weird X11 behavior, but naively embedding foreign windows breaks it. The only way to handle this reasonably is using the XEmbed protocol, which was designed to solve these problems. GTK provides , which supports XEmbed. Qt doesn't seem to provide anything working in newer versions. If the embedder supports XEmbed, input should work with default settings and with this option disabled. Note that is disabled by default in libmpv as well - it should be enabled if you want the mpv default key bindings. When multi-touch support is enabled (either required by the platform, or enabled by ), emulate mouse move and button presses for the touch events (default: yes). This is useful for compatibility for mouse key bindings and scripts which read mouse positions for platforms which do not support (e.g. Wayland). Begin the built-in window dragging when the mouse moves outside a deadzone of pixels while the mouse button is being held down (default: 3). This only affects VOs which support the command. Enable keyboard input via an active input method (IME) connected to the VO. (default: no). The input popup window, if there is any, is always positioned at the top left of the window. Whether pre-edit text is drawn depends on the platform. You may need to configure your IME to display the pre-edit inside of the input popup window if you cannot read the pre-edit text in the mpv window. Wayland and Windows only. This option is not applicable to terminal input. Enabling IME can cause problems with key bindings, because mpv cannot detect any key presses when they go into the IME pre-edit area. It is recommended to enable IME on demand only for the duration while text input is expected. The builtin console and input selector enable IME for the duration of accepting text input. Whether to load the on-screen-controller (default: yes). Enable display of the OSD bar (default: yes). You can configure this on a per-command basis in input.conf using prefixes, see . If you want to disable the OSD completely, use . Set what is displayed on the OSD during seeks. The default is . You can configure this on a per-command basis in input.conf using prefixes, see . Set the duration of the OSD messages in ms (default: 1000). Specify font to use for OSD. The default is . Specify the OSD font size. See for details. Show this string as message on OSD with OSD level 1 (visible by default). The message will be visible by default, and as long as no other message covers it, and the OSD level isn't changed (see ). Expands properties; see Property Expansion. Similar to , but for OSD level 2. If this is an empty string (default), then the playback time is shown. Similar to , but for OSD level 3. If this is an empty string (default), then the playback time, duration, and some more information is shown. This is used for the command (by default mapped to ), and when seeking if enabled with or by prefixes in input.conf (see ). is a legacy equivalent (but with a minor difference). Show a custom string during playback instead of the standard status text. This overrides the status text used for , when using the command (by default mapped to ), and when seeking if enabled with or prefixes in input.conf (see ). Expands properties. See Property Expansion. This option has been replaced with . The only difference is that this option implicitly includes . This option is ignored if is not empty. Show a message on OSD when playback starts. The string is expanded for properties, e.g. will show the message followed by a space and the currently played filename. Set the duration of in ms. If this is unset, stays on screen for the duration of . Whether to display the media title, filename, or both. If the is not available, it will display only the . Position of the OSD bar. -1 is far left, 0 is centered, 1 is far right. Fractional values (like 0.5) are allowed. Position of the OSD bar. -1 is top, 0 is centered, 1 is bottom. Fractional values (like 0.5) are allowed. Width of the OSD bar, in percentage of the screen width (default: 75). A value of 50 means the bar is half the screen wide. Height of the OSD bar, in percentage of the screen height (default: 3.125). Size of the outline of the OSD bar in scaled pixels (see for details). is an alias for . Factor for the OSD bar marker size relative to the OSD bar outline size. Gaussian blur factor applied to the OSD font border. 0 means no blur applied (default). See . Color used for the OSD font outline. is an alias for . See . Color used for OSD text background. is an alias for . Size of the OSD font outline in scaled pixels (see for details). A value of 0 disables outlines. is an alias for . See . Style used for OSD text border. Specify the color used for OSD. See for details. The color of the selected item in lists. See for details. The outline color of the selected item in lists. See for details. Show OSD times with fractions of seconds (in millisecond precision). Useful to see the exact timestamp of a video frame. Specifies which mode the OSD should start in. enabled (shows up only on user interaction) Left and right screen margin for the OSD in scaled pixels (see for details). This option specifies the distance of the OSD to the left, as well as at which distance from the right border long OSD text will be broken. Top and bottom screen margin for the OSD in scaled pixels (see for details). This option specifies the vertical margins of the OSD. Control to which corner of the screen OSD should be aligned to (default: ). Whether to scale the OSD with the window size (default: yes). If this is disabled, and other OSD options that use scaled pixels are always in actual pixels. The effect is that changing the window size won't change the OSD font size. For scripts which draw user interface elements, it is recommended to respect the value of this option when deciding whether the elements are scaled with window size or not. Displacement of the OSD shadow in scaled pixels (see for details). A value of 0 disables shadows. Horizontal OSD/sub font spacing in scaled pixels (see for details). This value is added to the normal letter spacing. Negative values are allowed. Enabled OSD rendering on the video window (default: yes). This can be used in situations where terminal OSD is preferred. If you just want to disable all OSD rendering, use . It does not affect subtitles or overlays created by scripts (in particular, the OSC needs to be disabled with ). This option is somewhat experimental and could be replaced by another mechanism in the future. See for details and accepted values. Note that unlike subtitles, OSD never uses embedded fonts from media files. See for details. Defaults to . Set the image file type used for saving screenshots. Tag screenshots with the appropriate colorspace (default: yes). Note that not all formats support this. When it is unsupported, or when this option is disabled, screenshots will be converted to sRGB before being written. If possible, write screenshots with a bit depth similar to the source video (default: yes). This is interesting in particular for PNG, as this sometimes triggers writing 16 bit PNGs with huge file sizes. This will also include an unused alpha channel in the resulting files if 16 bit is used. Specify the filename template used to save screenshots. The template specifies the filename without file extension, and can contain format specifiers, which will be substituted when taking a screenshot. By default, the template is , which results in filenames like for example. The template can start with a relative or absolute path, in order to specify a directory location where screenshots should be saved. If the final screenshot filename points to an already existing file, the file will not be overwritten. The screenshot will either not be saved, or if the template contains , saved using different, newly generated filename. A sequence number, padded with zeros to length X (default: 04). E.g. passing the format will yield on the 12th screenshot. The number is incremented every time a screenshot is taken or if the file already exists. The length must be in the range 0-9. With the optional # sign, mpv will use the lowest available number. For example, if you take three screenshots--0001, 0002, 0003--and delete the first two, the next two screenshots will not be 0004 and 0005, but 0001 and 0002 again. Filename of the currently played video. Same as , but strip the file extension, including the dot. Directory path of the currently played video. If the video is not on the filesystem (but e.g. ), this expand to an empty string. Same as , but if the video file is not on the filesystem, return the fallback string inside the . Current playback time, in the same format as used in the OSD. The result is a string of the form \"HH:MM:SS\". For example, if the video is at the time position 5 minutes and 34 seconds, will be replaced with \"00:05:34\". Similar to , but extended with the playback time in milliseconds. It is formatted as \"HH:MM:SS.mmm\", with \"mmm\" being the millisecond part of the playback time. This is a simple way for getting unique per-frame timestamps. (Frame numbers would be more intuitive, but are not easily implementable because container formats usually use time stamps for identifying frames.) Specify the current playback time using the format string . is like , and is like . hour (padded with 0 to two digits) like , but as float Specify the current local date/time using the format . This format specifier uses the UNIX function internally, and inserts the result of passing \"%X\" to . For example, will insert the number of the current month as number. You have to use multiple specifiers to build a full date/time string. Insert the value of the input property 'prop'. E.g. is the same as . If the property does not exist or is not available, an error text is inserted, unless a fallback is specified. Replaced with the character itself. Store screenshots in this directory. This path is joined with the filename generated by . If the template filename is already absolute, the directory is ignored. is an alias for . If the directory does not exist, it is created on the first screenshot. If it is not a directory, an error is generated when trying to write a screenshot. This option is not set by default, and thus will write screenshots to the directory from which mpv was started. In pseudo-gui mode (see PSEUDO GUI MODE), this is set to the desktop. Set the JPEG quality level. Higher means better quality. The default is 90. Write JPEG files with the same chroma subsampling as the video (default: yes). If disabled, the libjpeg default is used. Set the PNG compression level. Higher means better compression. This will affect the file size of the written screenshot file and the time it takes to write a screenshot. Too high compression might occupy enough CPU time to interrupt playback. The default is 7. Set the filter applied prior to PNG compression. 0 is none, 1 is \"sub\", 2 is \"up\", 3 is \"average\", 4 is \"Paeth\", and 5 is \"mixed\". This affects the level of compression that can be achieved. For most images, \"mixed\" achieves the best compression ratio, hence it is the default. Write lossless WebP files. is ignored if this is set. The default is no. Set the WebP quality level. Higher means better quality. The default is 75. Set the WebP compression level. Higher means better compression, but takes more CPU time. Note that this also affects the screenshot quality when used with lossy WebP files. The default is 4. Set the JPEG XL Butteraugli distance. Lower means better quality. Lossless is 0.0, and 1.0 is approximately equivalent to JPEG quality 90 for photographic content. Use 0.1 for \"visually lossless\" screenshots. The default is 1.0. Set the JPEG XL compression effort. Higher effort (usually) means better compression, but takes more CPU time. The default is 4. Specify the AV1 encoder to be used by libavcodec for encoding avif screenshots. Specify the pixel format for the libavcodec encoder. Defaults to empty, which lets mpv pick one close to the source format. Specifies libavcodec options for selected encoder. For more information, consult the FFmpeg documentation. Note: the default is only guaranteed to work with the libaom-av1 encoder. Above options may not be valid and or optimal for other encoders. This is a key/value list option. See List Options for details. sets the crf to 23 and quantization (aq-mode) to complexity based. Whether to use software rendering for screenshots (default: no). If set to no, the screenshot will be rendered by the current VO (only vo_gpu or vo_gpu_next currently). The advantage is that this will (probably) always show up as in the video window, because the same code is used for rendering. But since the renderer needs to be reinitialized, this can be slow and interrupt playback. If set to yes, the software scaler is used to convert the video to RGB (or whatever the target screenshot requires). In this case, conversion will run in a separate thread and will probably not interrupt playback. The software renderer may lack some capabilities, such as HDR rendering. If mode is used, the image will also be scaled in software which may not accurately reflect the actual visible result. Specify the software scaler algorithm to be used with . This also affects video output drivers which lack hardware acceleration, e.g. . See also . To get a list of available scalers, run . Unknown functionality (default: no). Consult libswscale source code. The primary purpose of this, as far as libswscale API goes), is to produce exactly the same output for the same input on all platforms (output has the same \"bits\" everywhere, thus \"bitexact\"). Typically disables optimizations. Allow optimizations that help with performance, but reduce quality (default: no). VOs like and will benefit a lot from using . You may need to set other options, like . The builtin profile sets this option and some others to gain performance for reduced quality. Also see . Allow using zimg (if the component using the internal swscale wrapper explicitly allows so) (default: yes). In this case, zimg may be used, if the internal zimg wrapper supports the input and output formats. It will silently or noisily fall back to libswscale if one of these conditions does not apply. If zimg is used, the other options are ignored, and the options are used instead. If the internal component using the swscale wrapper hooks up logging correctly, a verbose priority log message will indicate whether zimg is being used. Most things which need software conversion can make use of this. Do note that zimg may be slower than libswscale. Usually, it's faster on x86 platforms, but slower on ARM (due to lack of ARM specific optimizations). The mpv zimg wrapper uses unoptimized repacking for some formats, for which zimg cannot be blamed. Set scaler parameters. By default, these are set to the special string , which maps to a scaler-specific default value. Ignored if the scaler is not tunable. is the number of taps. a and b are the bicubic b and c parameters. Same as , for for chroma interpolation (default: bilinear). Same as / , for chroma. Set the maximum number of threads to use for scaling (default: auto). uses the number of logical cores on the current machine. Note that the scaler may use less threads (or even just 1 thread) depending on stuff. Passing a value of 1 disables threading and always scales the image in a single operation. Higher thread counts waste resources, but make it typically faster. Note that some zimg git versions had bugs that will corrupt the output if threads are used. Allow optimizations that help with performance, but reduce quality (default: yes). Currently, this may simplify gamma conversion operations. This controls the default options of any resampling done by mpv (but not within libavfilter, within the system audio API resampler, or any other places). Length of the filter with respect to the lower sampling rate. (default: 16) Log2 of the number of polyphase entries. (..., 10->1024, 11->2048, 12->4096, ...) (default: 10->1024) If set then filters will be linearly interpolated between polyphase entries. (default: no) Enable/disable normalization if surround audio is downmixed to stereo (default: no). If this is disabled, downmix can cause clipping. If it's enabled, the output might be too quiet. It depends on the source audio. If downmix happens outside of mpv for some reason, or in the decoder (decoder downmixing), or in the audio output (system mixer), this has no effect. Limit maximum size of audio frames filtered at once, in ms (default: 40). The output size size is limited in order to make resample speed changes react faster. This is necessary especially if decoders or filters output very large frame sizes (like some lossless codecs or some DRC filters). This option does not affect the resampling algorithm in any way. For testing/debugging only. Can be removed or changed any time. Set AVOptions on the SwrContext or AVAudioResampleContext. These should be documented by FFmpeg. This is a key/value list option. See List Options for details. Make console output less verbose; in particular, prevents the status line (i.e. AV: 3.4 (00:00:03.37) / 5320.6 ...) from being displayed. Particularly useful on slow terminals or broken ones which do not properly handle carriage return (i.e. ). See also: and . Display even less output and status messages than with . disables any use of the terminal and stdin/stdout/stderr. This completely silences any message output. Unlike , this disables input and terminal initialization as well. Control verbosity directly for each module. The module changes the verbosity of all the modules. The verbosity changes from this option are applied in order from left to right, and each item can override a previous one. Run mpv with to see all messages mpv outputs. You can use the module names printed in the output (prefixed to each line in ) to limit the output to interesting modules. This also affects , and in certain cases libmpv API logging. Some messages are printed before the command line is parsed and are therefore not affected by . To control these messages, you have to use the environment variable; see ENVIRONMENT VARIABLES for details. Completely silences the output of ao_sndio, which uses the log prefix . Only show warnings or worse, and let the ao_alsa output show errors only. Control whether OSD messages are shown on the console when no video output is available (default: auto). use terminal OSD if no video output active use terminal OSD even if video output active The mode also enables terminal OSD if was set. Enable printing a progress bar under the status line on the terminal. (Disabled by default.) Customize the feature. The string is expected to consist of 5 characters (start, left space, position indicator, right space, end). You can use Unicode characters, but note that double- width characters will not be treated correctly. Print out a string after starting playback. The string is expanded for properties, e.g. will print the string followed by a space and the currently played filename. Print out a custom string during playback instead of the standard status line. Expands properties. See Property Expansion. Set the terminal title. Currently, this simply concatenates the escape sequence setting the window title with the provided (property expanded) string. This will mess up if the expanded string contain bytes that end the escape sequence, or if the terminal does not understand the sequence. The latter probably includes the regrettable win32. Prepend module name to each console message. Prepend timing information to each console message. The time is in seconds since the player process was started (technically, slightly later actually), using a monotonic time source depending on the OS. This is on sane UNIX variants. Decide whether to use network cache settings (default: auto). If enabled, use up to for the cache size (but still limited to ), and make the cached data seekable (if possible). If disabled, and related are implicitly disabled. The choice enables this depending on whether the stream is thought to involve network accesses or other slow media (this is an imperfect heuristic). Before mpv 0.30.0, this used to accept a number, which specified the size of the cache in kilobytes. Use e.g. instead. How many seconds of audio/video to prefetch if the cache is active. This overrides the option if and only if the cache is enabled and the value is larger. The default value is set to something very high, so the actually achieved readahead will usually be limited by the value of the option. Setting this option is usually only useful for limiting readahead. Write packet data to a temporary file, instead of keeping them in memory. This makes sense only with . If the normal cache is disabled, this option is ignored. The cache file is append-only. Even if the player appears to prune data, the file space freed by it is not reused. The cache file is deleted when playback is closed. Note that packet metadata is still kept in memory. and related options are applied to metadata only. The size of this metadata varies, but 50 MB per hour of media is typical. The cache statistics will report this metadats size, instead of the size of the cache file. If the metadata hits the size limits, the metadata is pruned (but not the cache file). When the media is closed, the cache file is deleted. A cache file is generally worthless after the media is closed, and it's hard to retrieve any media data from it (it's not supported by design). If the option is enabled at runtime, the cache file is created, but old data will remain in the memory cache. If the option is disabled at runtime, old data remains in the disk cache, and the cache file is not closed until the media is closed. If the option is disabled and enabled again, it will continue to use the cache file that was opened first. Directory where to create temporary files. Cache is stored in the system's cache directory (usually ) if this is unset. Currently, this is used for only. Whether the player should automatically pause when the cache runs out of data and stalls decoding/playback (default: yes). If enabled, it will pause and unpause once more data is available, aka \"buffering\". Number of seconds the packet cache should have buffered before starting playback again if \"buffering\" was entered (default: 1). This can be used to control how long the player rebuffers if is enabled, and the demuxer underruns. If the given time is higher than the maximum set with or , or prefetching ends before that for some other reason (like file end or maximum configured cache size reached), playback resumes earlier. Enter \"buffering\" mode before starting playback (default: no). This can be used to ensure playback starts smoothly, in exchange for waiting some time to prefetch network data (as controlled by ). For example, some common behavior is that playback starts, but network caches immediately underrun when trying to decode more data as playback progresses. Another thing that can happen is that the network prefetching is so CPU demanding (due to demuxing in the background) that playback drops frames at first. In these cases, it helps enabling this option, and setting and to roughly the same value. This option also triggers when playback is restarted after seeking. Whether or when to unlink cache files (default: immediate). This affects cache files which are inherently temporary, and which make no sense to remain on disk after the player terminates. This is a debugging option. Unlink cache file after they were created. The cache files won't be visible anymore, even though they're in use. This ensures they are guaranteed to be removed from disk when the player terminates, even if it crashes. Delete cache files after they are closed. Don't delete cache files. They will consume disk space without having a use. Currently, this is used for only. Size of the low level stream byte buffer (default: 128KB). This is used as buffer between demuxer and low level I/O (e.g. sockets). Generally, this can be very small, and the main purpose is similar to the internal buffer FILE in the C standard library will have. Half of the buffer is always used for guaranteed seek back, which is important for unseekable input. There are known cases where this can help performance to set a large buffer:\n• mp4 files. libavformat may trigger many small seeks in both directions, depending on how the file was muxed.\n• Certain network filesystems, which do not have a cache, and where small reads can be inefficient. In other cases, setting this to a large value can reduce performance. Usually, read accesses are at half the buffer size, but it may happen that accesses are done alternating with smaller and larger sizes (this is due to the internal ring buffer wrap-around). See for defaults and value range. options accept suffixes such as and . Enable running the video/audio decoder on a separate thread (default: no). If enabled, the decoder is run on a separate thread, and a frame queue is put between decoder and higher level playback logic. The size of the frame queue is defined by the other options below. This is probably quite pointless. libavcodec already has multithreaded decoding (enabled by default), which makes this largely unnecessary. It might help in some corner cases with high bandwidth video that is slow to decode (in these cases libavcodec would block the playback logic, while using a decoding thread would distribute the decoding time evenly without affecting the playback logic). In other situations, it will simply make seeking slower and use significantly more memory. The queue size is restricted by the other options. The final queue size is the minimum as indicated by the option with the lowest limit. Each decoder/track has its own queue that may use the full configured queue size. Most queue options can be changed at runtime. itself (and the audio equivalent) update only if decoding is completely reinitialized. However, setting should almost lead to the same behavior as , so that value can be used for effectively runtime enabling/disabling the queue. This should not be used with hardware decoding. It is possible to enable this for audio, but it makes even less sense. Maximum approximate allowed size of the queue. If exceeded, decoding will be stopped. The maximum size can be exceeded by about 1 frame. See for defaults and value range. options accept suffixes such as and . Maximum number of frames (video) or samples (audio) of the queue. The audio size may be exceeded by about 1 frame. See for defaults and value range. Maximum number of seconds of media in the queue. The special value 0 means no limit is set. The queue size may be exceeded by about 2 frames. Timestamp resets may lead to random queue size usage. See for defaults and value range. Use as user agent for HTTP streaming. Read HTTP cookies from <filename>. The file is assumed to be in Netscape format. This is a string list option. See List Options for details. URL of the HTTP/HTTPS proxy. If this is set, the environment is ignored. The environment variable is still respected. This option is silently ignored if it does not start with . Proxies are not used for https URLs. Setting this option does not try to make the ytdl script use the proxy. Certificate authority database file for use with TLS. (Silently fails with older FFmpeg versions.) Verify peer certificates when using TLS (e.g. with ). (Silently fails with older FFmpeg versions.) A file containing a certificate to use in the handshake with the peer. A file containing the private key for the certificate. Specify a referrer path or URL for HTTP requests. Specify the network timeout in seconds (default: 60 seconds). This affects at least HTTP. The special value 0 uses the FFmpeg defaults. If a protocol is used which does not support timeouts, this option is silently ignored. This breaks the RTSP protocol, because of inconsistent FFmpeg API regarding its internal timeout option. Not only does the RTSP timeout option accept different units (seconds instead of microseconds, causing mpv to pass it huge values), it will also overflow FFmpeg internal calculations. The worst is that merely setting the option will put RTSP into listening mode, which breaks any client uses. At time of this writing, the fix was not made effective yet. For this reason, this option is ignored (or should be ignored) on RTSP URLs. You can still set the timeout option directly with . Select RTSP transport method (default: tcp). This selects the underlying network transport when playing URLs. The value leaves the decision to libavformat. If HLS streams are played, this option controls what streams are selected by default. The option allows the following parameters: Don't do anything special. Typically, this will simply pick the first audio/video streams it can find. Pick the streams with the lowest bitrate. Additionally, if the option is a number, the stream with the highest rate equal or below the option value is selected. The bitrate as used is sent by the server, and there's no guarantee it's actually meaningful. This defines the program to tune to. Usually, you may specify this by using a stream URI like , but you can tune to a different channel by writing to this property at runtime. Also see for more useful channel switching functionality. Instructs mpv to read the channels list from . The default is in the mpv configuration directory (usually ) with the filename (based on your card type) or as a last resort. Please note that using specific file name with card type is recommended, since the legacy channel format is not fully standardized so autodetection of the delivery system may fail otherwise. For DVB-S/2 cards, a VDR 1.7.x format channel list is recommended as it allows tuning to DVB-S2 channels, enabling subtitles and decoding the PMT (which largely improves the demuxing). Classic mplayer format channel lists are still supported (without these improvements), and for other card types, only limited VDR format channel list support is implemented (patches welcome). For channels with dynamic PID switching or incomplete , or the magic PID are recommended. Maximum number of seconds to wait when trying to tune a frequency before giving up (default: 30). Apply no filters on program PIDs, only tune to frequency and pass full transponder to demuxer. The player frontend selects the streams from the full TS in this case, so the program which is shown initially may not match the chosen channel. Switching between the programs is possible by cycling the property. This is useful to record multiple programs on a single transponder, or to work around issues in the . It is also recommended to use this for channels which switch PIDs on-the-fly, e.g. for regional news. This value is not meant for setting via configuration, but used in channel switching. An can this value and to perform channel switching. This number effectively gives the offset to the initially tuned to channel in the channel list. An example could contain: , The following video options are currently all specific to , and , which are the only VOs that implement them. The filter function to use when upscaling video. Bilinear hardware texture filtering (fastest, very low quality). This is the default when using the profile. Lanczos scaling. Provides good balance between quality and performance. This is the default for . The number of taps can be controlled with , but is best left unchanged. Elliptic weighted average Lanczos scaling. Also known as Jinc. Relatively slow, but very good quality. The radius can be controlled with . Increasing the radius makes the filter sharper but adds more ringing. A slightly sharpened version of . This is the default when using the profile. Blur value determined by method originally developed by Nicolas Robidoux for Image Magick, see: https://www.imagemagick.org/discourse-server/viewtopic.php?p=89068#p89068 Very sharp scaler, but also slightly slower than . Prone to ringing, so it's recommended to combine this with an anti-ringing shader. On , setting this filter enables built-in anti-ringing, so no extra action needs to be taken. For more details, see: https://www.imagemagick.org/discourse-server/viewtopic.php?p=128587#p128587 Mitchell-Netravali. Piecewise cubic filter with a support of radius 2.0. Provides a balanced compromise of all scaling artifacts. This filter has both and set to . The and parameters can be controlled with and . Hermite spline. Similar to but with set to . This filter has the special property of having a support of radius 1.0, making it very fast in comparison, but prone to blocking. This is the default for . Catmull-Rom spline. Similar to , but with and set to and respectively. This filter is sharper than , but prone to ringing. A version of nearest neighbour that (naively) oversamples pixels, so that pixels overlapping edges get linearly interpolated instead of rounded. This essentially removes the small imperfections and judder artifacts caused by nearest-neighbour interpolation, in exchange for adding some blur. This can also be used for frame mixing, where it is commonly known as \"smoothmotion\" (see ). There are some more filters, but most are not as useful. For a complete list, pass as value, e.g.: As , but for interpolating chroma information. If the image is not subsampled, this option is ignored entirely. If this option is unset, the filter implied by will be applied. Like , but apply these filters on downscaling instead. The filter used for interpolating the temporal axis (frames). This is only used if is enabled. The only valid choices for are separable convolution filters (use to get a list). The default is . Common choices include , , , , , or . These are listed in increasing order of smoothness/blurriness, with being the smoothest/blurriest and being the sharpest/least smooth. Set filter parameters. By default, these are set to the special string , which maps to a scaler-specific default value. Ignored if the filter is not tunable. Currently, this affects the following filter parameters: Spline parameters ( and ). Defaults to B=1 and C=0. Scale parameter ( ). Increasing this makes the result blurrier. Defaults to 1. Minimum distance to an edge before interpolation is used. Setting this to 0 will always interpolate edges, whereas setting it to 0.5 will never interpolate, thus behaving as if the regular nearest neighbour algorithm was used. Defaults to 0.0. Kernel scaling factor (also known as a blur factor). Decreasing this makes the result sharper, increasing it makes it blurrier (default 0). If set to 0, the kernel's preferred blur factor is used. Note that setting this too low (eg. 0.5) leads to bad results. It's generally recommended to stick to values between 0.8 and 1.2. Specifies a weight bias to multiply into negative coefficients. Specifying has the effect of removing negative weights completely, thus effectively clamping the value range to [0-1]. Values between 0.0 and 1.0 can be specified to apply only a moderate diminishment of negative weights. This is especially useful for , where it reduces excessive ringing artifacts in the temporal domain (which typically manifest themselves as short flashes or fringes of black, mostly around moving edges) in exchange for potentially adding more blur. The default for is 1.0, the others default to 0.0. Kernel/window taper factor. Increasing this flattens the filter function. Value range is 0 to 1. A value of 0 (the default) means no flattening, a value of 1 makes the filter completely flat (equivalent to a box function). Values in between mean that some portion will be flat and the actual filter function will be squeezed into the space in between. Set radius for tunable filters, must be a float number between 0.5 and 16.0. Defaults to the filter's preferred radius if not specified. Doesn't work for every scaler and VO combination. Note that depending on filter implementation details and video scaling ratio, the radius that actually being used might be different (most likely being increased a bit). Set the antiringing strength. This tries to eliminate ringing, but can introduce other artifacts in the process. Must be a float number between 0.0 and 1.0. The default value of 0.0 disables antiringing entirely. Note that this doesn't affect the special filters and , nor does it affect any polar (EWA) scalers. On , this also affects polar (EWA) scalers. Certain filter aliases may also implicitly enable antiringing, regardless of this setting (see ). When downscaling with separable (orthogonal) filters, setting to a value other than 0.0 (default) will reduce scaler quality and produce aliasing artifacts. On , is disabled for separable (orthogonal) filters. (Advanced users only) Choose a custom windowing function for the kernel. Defaults to the filter's preferred window if unset. Use to get a list of supported windowing functions. (Advanced users only) Configure the parameter for the window function given by etc. By default, these are set to the special string , which maps to a window-specific default value. Ignored if the window is not tunable. Currently, this affects the following window parameters: Scale parameter (t). Increasing this makes the window wider. Defaults to 1. Disable the scaler if the video image is not resized. In that case, is used instead of whatever is set with . Bilinear will reproduce the source image perfectly if no scaling is performed. Enabled by default. Note that this option never affects . When using convolution based filters, extend the filter size when downscaling. Increases quality, but reduces performance while downscaling. Enabled by default. This will perform slightly sub-optimally for anamorphic video (but still better than without it) since it will extend the size to match only the milder of the scale factors between the axes. Note: this option is ignored when using bilinear downscaling with . Scale in linear light when downscaling. It should only be used with a that has at least 16 bit precision. This option has no effect on HDR content. Enabled by default. Scale in linear light when upscaling. Like , it should only be used with a that has at least 16 bits precisions. This is not usually recommended except for testing/specific purposes. Users are advised to either enable or keep both options disabled (i.e. scaling in gamma light). When upscaling, use a sigmoidal color transform to avoid emphasizing ringing artifacts. Enabled by default. This is incompatible with and replaces . (Note that sigmoidization also requires linearization, so the rendering step fires in both cases) For more information about sigmoidization, see: https://imagemagick.org/Usage/resize/#resize_sigmoidal The center of the sigmoid curve used for , must be a float between 0.0 and 1.0. Defaults to 0.75 if not specified. The slope of the sigmoid curve used for , must be a float between 1.0 and 20.0. Defaults to 6.5 if not specified. Reduce stuttering caused by mismatches in the video fps and display refresh rate (also known as judder). This requires setting the option to one of the modes, or it will be silently disabled. This was not required before mpv 0.14.0. This essentially attempts to interpolate the missing frames by convoluting the video along the temporal axis. The filter used can be controlled using the setting. Threshold below which frame ratio interpolation gets disabled (default: ). This is calculated as , where is the speed-adjusted video FPS, and the display refresh rate. (The speed-adjusted video FPS is roughly equal to the normal video FPS, but with slowdown and speedup applied. This matters if you use to make video run synchronously to the display FPS, or if you change the property.) The default is intended to enable interpolation in scenarios where retiming with the cannot adjust the speed of the video sufficiently for smooth playback. For example if a video is 60.00 FPS and your display refresh rate is 59.94 Hz, interpolation will never be activated, since the mismatch is within 1% of the refresh rate. The default also handles the scenario when mpv cannot determine the container FPS, such as during certain live streams, and may dynamically toggle interpolation on and off. In this scenario, the default would be to not use interpolation but rather to allow to retime the video to match display refresh rate. See for more information about how mpv will retime video. Also note that if you use e.g. , small deviations in the rate can disable interpolation and introduce a discontinuity every other minute. Set this to to disable this logic. Preserve the previous frames' interpolated results even when renderer parameters are changed - with the exception of options related to cropping and video placement, which always invalidate the cache. Enabling this option makes dynamic updates of renderer settings slightly smoother at the cost of slightly higher latency in response to such changes. Defaults to on. (Only affects , note that always invalidates interpolated frames) Enable use of PBOs. On some drivers this can be faster, especially if the source video size is huge (e.g. so called \"4K\" video). On other drivers it might be slower or cause latency issues. Disable any dithering done by mpv. Automatic selection. On : detected depth or 8 bpc otherwise On : detected depth or 8 bpc (for SDR target) Note that the on-the-wire bit depth cannot be detected except when using . Explicitly setting the value to your display's bit depth is recommended, as dithering performed by some LCD panels can be of low quality. Set the size of the dither matrix (default: 6). The actual size of the matrix is for an option value of , so a value of 6 gives a size of 64x64. The matrix is generated at startup time, and a large matrix can take rather long to compute (seconds). Used in mode only. Select dithering algorithm (default: fruit). (Normally, the option controls whether dithering is enabled.) The option requires compute shader support. It also requires large amount of shared memory to run, the size of which depends on both the kernel (see option below) and the height of video window. It will fallback to dithering if there is no enough shared memory to run the shader. Enable temporal dithering. (Only active if dithering is enabled in general.) This changes between 8 different dithering patterns on each frame by changing the orientation of the tiled dithering matrix. Unfortunately, this can lead to flicker on LCD displays, since these have a high reaction time. Determines how often the dithering pattern is updated when is in use. 1 (the default) will update on every video frame, 2 on every other frame, etc. The error diffusion kernel to use when is set. Propagate error to only two adjacent pixels. Fastest but low quality. Fast with reasonable quality. This is the default. Looks different from other kernels because only fraction of errors will be propagated during dithering. A typical use case of this kernel is saving dithered screenshot (in window mode). This kernel produces slightly smaller file, with still reasonable dithering quality. There are other kernels (use to list) but most of them are much slower and demanding even larger amount of shared memory. Among these kernels, achieves a good balance between performance and quality, and probably is the one you want to try first. Enables GPU debugging. What this means depends on the API type. For OpenGL, it calls , and requests a debug context. For Vulkan, it enables validation layers. Interval in displayed frames between two buffer swaps. 1 is equivalent to enable VSYNC, 0 to disable VSYNC. Defaults to 1 if not specified. Note that this depends on proper OpenGL vsync support. On some platforms and drivers, this only works reliably when in fullscreen mode. It may also require driver-specific hacks if using multiple monitors, to ensure mpv syncs to the right one. Compositing window managers can also lead to bad results, as can missing or incorrect display FPS information (see ). (EGL only) Select EGLConfig with specific EGL_CONFIG_ID. Rendering surfaces and contexts will be created using this EGLConfig. You can use to obtain a list of available configs. (EGL only) Select a specific EGL output format to utilize for OpenGL rendering. This option is mutually exclusive with . \"auto\" is the default, which will pick the first usable config based on the order given by the driver. All formats are not available. A fatal error is caused if an unavailable format is selected. There is no reliable API to query desktop bit depth in EGL. You can manually set this option according to the bit depth of your display. This option also affects the auto-detection of . Unlike , this option also takes effect with . The name or UUID of the Vulkan device to use for rendering and presentation. Use to see the list of available devices and their names and UUIDs. If left unspecified, the first enumerated hardware Vulkan device will be used. Controls the presentation mode of the vulkan swapchain. This is similar to the option. Use the preferred swapchain mode for the vulkan context. (Default) Tearing, vsync blocked. Late frames will tear instead of stuttering. Tearing, not vsync blocked. Similar to \"VSync off\". Controls the number of VkQueues used for rendering (limited by how many your device supports). In theory, using more queues could enable some parallelism between frames (when using a higher than 1), but it can also slow things down on hardware where there's no true parallelism between queues. (Default: 1) Enables the use of async transfer queues on supported vulkan devices. Using them allows transfer operations like texture uploads and blits to happen concurrently with the actual rendering, thus improving overall throughput and power consumption. Enabled by default, and should be relatively safe. Enables the use of async compute queues on supported vulkan devices. Using this, in theory, allows out-of-order scheduling of compute shaders with graphics shaders, thus enabling the hardware to do more effective work while waiting for pipeline bubbles and memory operations. Not beneficial on all GPUs. It's worth noting that if async compute is enabled, and the device supports more compute queues than graphics queues (bound by the restrictions set by ), mpv will internally try and prefer the use of compute shaders over fragment shaders wherever possible. Enabled by default, although Nvidia users may want to disable it. The index of the display, on the selected Vulkan device, to present on when using the GPU context. Use to see the list of available displays. If left unspecified, the first enumerated display will be used. The index of the display mode, of the selected Vulkan display, to use when using the GPU context. Use to see the list of available modes. If left unspecified, the first enumerated mode will be used. The index of the plane, on the selected Vulkan device, to present on when using the GPU context. Use to see the list of available planes. If left unspecified, the first enumerated plane will be used. Switches the D3D11 swap chain fullscreen state to 'fullscreen' when fullscreen video is requested. Also known as \"exclusive fullscreen\" or \"D3D fullscreen\" in other applications. Gives mpv full control of rendering on the swap chain's screen. Off by default. Use WARP (Windows Advanced Rasterization Platform) with the D3D11 GPU backend (default: auto). This is a high performance software renderer. By default, it is only used when the system has no hardware adapters that support D3D11. While the extended GPU features will work with WARP, they can be very slow. Select a specific feature level when using the D3D11 GPU backend. By default, the highest available feature level is used. This option can be used to select a lower feature level, which is mainly useful for debugging. Most extended GPU features will not work at 9_x feature levels. Enable flip-model presentation, which avoids unnecessarily copying the backbuffer by sharing surfaces with the DWM (default: yes). This may cause performance issues with older drivers. If flip-model presentation is not supported (for example, on Windows 7 without the platform update), mpv will automatically fall back to the older bitblt presentation model. flip-model needs presentation needs to be disabled for background transparency to work. Schedule each frame to be presented for this number of VBlank intervals. (default: 1) Setting to 1 will enable VSync, setting to 0 will disable it. Select a specific D3D11 adapter to utilize for D3D11 rendering. Will pick the default adapter if unset. Alternatives are listed when the name \"help\" is given. Checks for matches based on the start of the string, case insensitive. Thus, if the description of the adapter starts with the vendor name, that can be utilized as the selection parameter. Hardware decoders utilizing the D3D11 rendering abstraction's helper functionality to receive a device, such as D3D11VA or DXVA2's DXGI mode, will be affected by this choice. Select a specific D3D11 output format to utilize for D3D11 rendering. \"auto\" is the default, which will pick either rgba8 or rgb10_a2 depending on the configured desktop bit depth. rgba16f and bgra8 are left out of the autodetection logic, and are available for manual testing. Desktop bit depth querying is only available from an API available from Windows 10. Thus on older systems it will only automatically utilize the rgba8 output format. For , this is used as a best-effort hint and libplacebo has the last say on which format is utilized. Select a specific D3D11 output color space to utilize for D3D11 rendering. \"auto\" is the default, which will select the color space of the desktop on which the swap chain is located. Values other than \"srgb\" and \"pq\" have had issues in testing, so they are mostly available for manual testing. Swap chain color space configuration is only available from an API available from Windows 10. Thus on older systems it will not work. By default, when using hardware decoding with , the video image will be copied (GPU-to-GPU) from the decoder surface to a shader resource. Set this option to avoid that copy by sampling directly from the decoder image. This may increase performance and reduce power usage, but can cause the image to be sampled incorrectly on the bottom and right edges due to padding, and may invoke driver bugs, since Direct3D 11 technically does not allow sampling from a decoder surface (though most drivers support it.) Currently only relevant for . Controls whether or not mpv opts into the configure bounds event if sent by the compositor (default: auto). This restricts the initial size of the mpv window to a certain maximum size intended by the compositor. In most cases, this simply just prevents the mpv window from being larger than the size of the monitor when it first renders. With the default value of , configure-bounds will silently be ignored if any or type option is also set. If supported by the compositor, mpv will send a hint using the content-type protocol telling the compositor what type of content is being displayed. (default) will automatically switch between telling the compositor the content is a photo, video or possibly none depending on internal heuristics. Defines the size of an edge border (default: 16) to initiate client side resize events in the wayland contexts with the mouse. This is only active if there are no server side decorations from the compositor. Defines the size of an edge border (default: 32) to initiate client side resizes events in the wayland contexts with touch events. Controls whether to use mpv's internal vsync for Wayland-base video outputs (default: ). This is mainly useful for benchmarking wayland VOs when combined with , , and . The special value will disable the internal vsync if the compositor supports the fifo protocol and version 2 of the presentation time protocol when using . In any other situation, it is exactly the same as . Enable the use of wayland's presentation time protocol for more accurate frame presentation if it is supported by the compositor (default: ). This only has an effect if is being used. Controls which compiler is used to translate GLSL to SPIR-V. This is only relevant for with . The possible choices are currently: Use the first available compiler. (Default) Use libshaderc, which is an API wrapper around glslang. This is generally the most preferred, if available. This option is deprecated, since there is only one usable value. It may be removed in the future. Custom GLSL hooks. These are a flexible way to add custom fragment shaders, which can be injected at almost arbitrary points in the rendering pipeline, and access all previous intermediate textures. Each use of the option will add another file to the internal list of shaders, while takes a list of files, and overwrites the internal list with it. The latter is a path list option (see List Options for details). The syntax is not stable yet and may change any time. The general syntax of a user shader looks like this: Each section of metadata, along with the non-metadata lines after it, defines a single block. There are currently two types of blocks, HOOKs and TEXTUREs. A block can set the following options: The name of this texture. Hooks can then bind the texture under this name using BIND. This must be the first option of the texture block. The dimensions of the texture. The height and depth are optional. The type of texture (1D, 2D or 3D) depends on the number of components specified. The texture format for the samples. Supported texture formats are listed in debug logging when the VO is initialized (look for ). Usually, this follows OpenGL naming conventions. For example, provides 3 channels with normalized 16 bit components. One oddity are float formats: for example, has 16 bit internal precision, but the texture data is provided as 32 bit floats, and the driver converts the data on texture upload. Although format names follow a common naming convention, not all of them are available on all hardware, drivers, GL versions, and so on. The min/magnification filter used when sampling from this texture. The border wrapping mode used when sampling from this texture. Following the metadata is a string of bytes in hexadecimal notation that define the raw texture data, corresponding to the format specified by , on a single line with no extra whitespace. A block can set the following options: The texture which to hook into. May occur multiple times within a metadata block, up to a predetermined limit. See below for a list of hookable textures. User-friendly description of the pass. This is the name used when representing this shader in the list of passes for property . Loads a texture (either coming from mpv or from a block) and makes it available to the pass. When binding textures from mpv, this will also set up macros to facilitate accessing it properly. See below for a list. By default, no textures are bound. The special name HOOKED can be used to refer to the texture that triggered this pass. Gives the name of the texture to save the result of this pass into. By default, this is set to the special name HOOKED which has the effect of overwriting the hooked texture. Specifies the size of the resulting texture for this pass. refers to an expression in RPN (reverse polish notation), using the operators + - * / > < !, floating point literals, and references to sizes of existing texture (such as MAIN.width or CHROMA.height), OUTPUT, or NATIVE_CROPPED (size of an input texture cropped after pan-and-scan, video-align-x/y, video-pan-x/y, etc. and possibly prescaled). By default, these are set to HOOKED.w and HOOKED.h, espectively. Specifies a condition that needs to be true (non-zero) for the shader stage to be evaluated. If it fails, it will silently be omitted. (Note that a shader stage like this which has a dependency on an optional hook point can still cause that hook point to be saved, which has some minor overhead) Indicates a pixel shift (offset) introduced by this pass. These pixel offsets will be accumulated and corrected during the next scaling pass ( or ). The default values are 0 0 which correspond to no shift. Note that offsets are ignored when not overwriting the hooked texture. A special value of will attempt to fix existing offset of HOOKED by align it with reference. It requires HOOKED to be resizable (see below). It works transparently with fragment shader. For compute shader, the predefined macro is required to handle coordinate mapping. Specifies how many components of this pass's output are relevant and should be stored in the texture, up to 4 (rgba). By default, this value is equal to the number of components in HOOKED. Specifies that this shader should be treated as a compute shader, with the block size bw and bh. The compute shader will be dispatched with however many blocks are necessary to completely tile over the output. Within each block, there will be tw*th threads, forming a single work group. In other words: tw and th specify the work group size, which can be different from the block size. So for example, a compute shader with bw, bh = 32 and tw, th = 8 running on a 500x500 texture would dispatch 16x16 blocks (rounded up), each with 8x8 threads. Compute shaders in mpv are treated a bit different from fragment shaders. Instead of defining a that produces an output sample, you directly define which writes to a fixed writeonly image unit named (this is bound by mpv) using . To help translate texture coordinates in the absence of vertices, mpv provides a special function to map from the texel space of the output image to the texture coordinates for all bound textures. In particular, is equivalent to , although using this only really makes sense if (tw,th) == (bw,bh). Each bound mpv texture (via ) will make available the following definitions to that shader pass, where NAME is the name of the bound texture: The sampling function to use to access the texture at a certain spot (in texture coordinate space, range [0,1]). This takes care of any necessary normalization conversions. Sample the texture at a certain offset in pixels. This works like NAME_tex but additionally takes care of necessary rotations, so that sampling at e.g. vec2(-1,0) is always one pixel to the left. The local texture coordinate of that texture, range [0,1]. The (rotated) size in pixels of the texture. The rotation matrix associated with this texture. (Rotates pixel space to texture coordinates) The coefficient that needs to be multiplied into the texture contents in order to normalize it to the range [0,1]. The raw bound texture itself. The use of this should be avoided unless absolutely necessary. Normally, users should use either NAME_tex or NAME_texOff to read from the texture. For some shaders however , it can be better for performance to do custom sampling from NAME_raw, in which case care needs to be taken to respect NAME_mul and NAME_rot. In addition to these parameters, the following uniforms are also globally available: A random number in the range [0-1], different per frame. A simple count of frames rendered, increases by one per frame and never resets (regardless of seeks). The size in pixels of the input image (possibly cropped and prescaled). The size in pixels of the visible part of the scaled (and possibly cropped) image. Texture offset introduced by user shaders or options like panscan, video-align-x/y, video-pan-x/y. Internally, vo_gpu may generate any number of the following textures. Whenever a texture is rendered and saved by vo_gpu, all of the passes that have hooked into it will run, in the order they were added by the user. This is a list of the legal hook points: Source planes (raw). Which of these fire depends on the image format of the source. Source planes (upscaled). These only fire on subsampled content. The combined image, in the source colorspace, before conversion to RGB. The image, after conversion to RGB, but before is applied. The main image, after conversion to RGB but before upscaling. Linear light image, before scaling. This only fires when , or is in effect. Sigmoidized light, before scaling. This only fires when is in effect. The image immediately before the scaler kernel runs. The image immediately after the scaler kernel runs. The final output image, after color management but before dithering and drawing to screen. Only the textures labelled with may be transformed by the pass. When overwriting a texture marked , the WIDTH, HEIGHT and OFFSET must be left at their default values. Specifies the options to use for tunable shader parameters. You can target specific named shaders by prefixing the shader name with a , e.g. . Without a prefix, parameters affect all shaders. The shader name is the base part of the shader filename, without the extension. ( only) Some parameters are filled automatically if the shader requests them. Currently following parameters are available: PTS of the current frame in seconds. chroma offset to the reference plane in x direction. chroma offset to the reference plane in y direction. Maximum scene light level of the red channel (in cd/m²). Maximum scene light level of the green channel (in cd/m²). Maximum scene light level of the blue channel (in cd/m²). Enable the debanding algorithm. This greatly reduces the amount of visible banding, blocking and other quantization artifacts, at the expense of very slightly blurring some of the finest details. In practice, it's virtually always an improvement - the only reason to disable it would be for performance. The number of debanding steps to perform per sample. Each step reduces a bit more banding, but takes time to compute. Note that the strength of each step falls off very quickly, so high numbers (>4) are practically useless. (Default 1) The debanding filter's cut-off threshold. Higher numbers increase the debanding strength dramatically but progressively diminish image details. (Default 48) The debanding filter's initial radius. The radius increases linearly for each iteration. A higher radius will find more gradients, but a lower radius will smooth more aggressively. (Default 16) If you increase the , you should probably decrease this to compensate. Add some extra noise to the image. This significantly helps cover up remaining quantization artifacts. Higher numbers add more noise. (Default 32) If set to a value above 0.0, the output will be rendered with rounded corners, as if an alpha transparency mask had been applied. The value indicates the relative fraction of the side length to round - a value of 1.0 rounds the corners as much as possible. ( only) If set to a value other than 0, enable an unsharp masking filter. Positive values will sharpen the image (but add more ringing and aliasing). Negative values will blur the image. If your GPU is powerful enough, consider alternatives like the scale filter, or the option. (Only for ) Call before swapping buffers (default: disabled). Slower, but might improve results when doing framedropping. Can completely ruin performance. The details depend entirely on the OpenGL driver. Call after each buffer swap (default: disabled). This may or may not help with video timing accuracy and frame drop. It's possible that this makes video output slower, or has no effect at all. (Windows only) Calls after swapping buffers on Windows (default: auto). It also sets to ignore the OpenGL timing. Values are: no (disabled), windowed (only in windowed mode), yes (also in full screen). The value will try to determine whether the compositor is active, and calls only if it seems to be. This may help to get more consistent frame intervals, especially with high-fps clips - which might also reduce dropped frames. Typically, a value of should be enough, since full screen may bypass the DWM. Selects a specific feature level when using the ANGLE backend with D3D11. By default, the highest available feature level is used. This option can be used to select a lower feature level, which is mainly useful for debugging. Note that OpenGL ES 3.0 is only supported at feature level 10_1 or higher. Most extended OpenGL features will not work at lower feature levels (similar to ). Use WARP (Windows Advanced Rasterization Platform) when using the ANGLE backend with D3D11 (default: auto). This is a high performance software renderer. By default, it is used when the Direct3D hardware does not support Direct3D 11 feature level 9_3. While the extended OpenGL features will work with WARP, they can be very slow. Use ANGLE's built in EGL windowing functions to create a swap chain (default: auto). If this is set to and the D3D11 renderer is in use, ANGLE's built in swap chain will not be used and a custom swap chain that is optimized for video rendering will be created instead. If set to , a custom swap chain will be used for D3D11 and the built in swap chain will be used for D3D9. This option is mainly for debugging purposes, in case the custom swap chain has poor performance or does not work. If set to , the option will have no effect. Enable flip-model presentation, which avoids unnecessarily copying the backbuffer by sharing surfaces with the DWM (default: yes). This may cause performance issues with older drivers. If flip-model presentation is not supported (for example, on Windows 7 without the platform update), mpv will automatically fall back to the older bitblt presentation model. If set to , the option will have no effect. Forces a specific renderer when using the ANGLE backend (default: auto). In auto mode this will pick D3D11 for systems that support Direct3D 11 feature level 9_3 or higher, and D3D9 otherwise. This option is mainly for debugging purposes. Normally there is no reason to force a specific renderer, though may give slightly better performance on old hardware. Note that the D3D9 renderer only supports OpenGL ES 2.0, so most extended OpenGL features will not work if this renderer is selected (similar to ). Deactivates the automatic graphics switching and forces the dedicated GPU. (default: no) Use the Apple Software Renderer when using cocoa-cb (default: auto). If set to the software renderer is never used and instead fails when a the usual pixel format could not be created, will always only use the software renderer, and only falls back to the software renderer when the usual pixel format couldn't be created. Creates a 10bit capable pixel format for the context creation (default: yes). Instead of 8bit integer framebuffer a 16bit half-float framebuffer is requested. This sets the color space of the layer to activate the macOS color transformation. Depending on the color space used the system's EDR (HDR) support will be activated. To get correct results, this needs to be set to the color primaries/transfer characteristics of the VO target. It is recommended to use this switch together with and . can be one of the following: Sets the color space to the icc profile of the screen (default). Same as sRGB but linear transfer function. Sets the appearance of the title bar (default: auto). Not all combinations of appearances and materials make sense or are unique. Appearances that are not supported by you current macOS version fall back to the default value. macOS only can be one of the following: Detects the system settings and sets the title bar appearance appropriately. On macOS 10.14 it also detects run time changes. Sets the material of the title bar (default: titlebar). All deprecated materials should not be used on macOS 10.14+ because their functionality is not guaranteed. Not all combinations of materials and appearances make sense or are unique. Materials that are not supported by you current macOS version fall back to the default value. macOS only can be one of the following: The standard macOS under page background material. (deprecated in macOS 10.14+) Sets the color of the title bar (default: completely transparent). Is influenced by and . See for color syntax. Sets the fullscreen resize animation duration in ms (default: default). The default value is slightly less than the system's animation duration (500ms) to prevent some problems when the end of an async animation happens at the same time as the end of the system wide fullscreen animation. Setting anything higher than 500ms will only prematurely cancel the resize animation after the system wide animation ended. The upper limit is still set at 1000ms since it's possible that Apple or the user changes the system defaults. Anything higher than 1000ms though seems too long and shouldn't be set anyway. (macOS) Changes the App activation policy. With accessory the mpv icon in the Dock can be hidden. (default: regular) This changes the rectangle which is used to calculate the screen position and size of the window (default: visible). takes the the menu bar and Dock into account and the window is only positioned/sized within the visible screen frame rectangle, takes the whole screen frame rectangle and ignores the menu bar and Dock. Other previous restrictions still apply, like the window can't be placed on top of the menu bar etc. Sets the mode (default: callback) for syncing the rendering of frames to the display's vertical refresh rate. macOS and Vulkan (macvk) only. can be one of the following: Syncs to the time of the next vertical display refresh reported by the CVDisplayLink callback provided information No manual syncing, depend on the layer mechanic and the next drawable Same as precise but uses the presentation feedback core mechanism Enables the default menu bar shortcuts (default: yes). The menu bar shortcuts always take precedence over any other shortcuts, they are not propagated to the mpv core and they can't be used in config files like or script bindings. App Bundles operate in their own shell environment that is different from the one in the terminal. The default PATH variable for all Bundles is . Because of that mpv can not find binaries installed by package manager that might be used in scripts for example. This option prepends all given paths to the default Bundle PATH. Default value in following order: Set dimensions of the rendering surface used by the Android gpu context. Needs to be set by the embedding application if the dimensions change during runtime (i.e. if the device is rotated), via the surfaceChanged callback. Continue even if a software renderer is detected. This only works with OpenGL/Vulkan backends. For d3d11, see . Specify a priority list of the GPU contexts to be used. The value (the default) selects the GPU context with the default autoprobe order. You can also pass to get a complete list of compiled in backends (sorted by the default autoprobe order). Note that the default GPU context is subject to change, and must not be relied upon. If a certain GPU context needs to be used, it must be explicitly specified. auto-select (default). Note that this context must be used alone and does not participate in the priority list. Direct3D11 through the OpenGL ES translation layer ANGLE. This supports almost everything the backend does (if the ANGLE build is new enough). Win32, using WGL for rendering and Direct3D 9Ex for presentation. Works on Nvidia and AMD. Newer Intel chips with the latest drivers may also work. VK_KHR_display. This backend is roughly the Vulkan equivalent of DRM/EGL, allowing for direct rendering via Vulkan without a display manager. Android/EGL. Requires be set to an . Vulkan on macOS with a metal surface through a translation layer (experimental) This is an object settings list option. See List Options for details. Use any available API (default). Note that the default GPU API used for this value is subject to change, and must not be relied upon. If a certain GPU API needs to be used, it must be explicitly specified. Allow only OpenGL (requires OpenGL 2.1+ or GLES 2.0+) This is an object settings list option. See List Options for details. Controls which type of OpenGL context will be accepted: Allow all types of OpenGL (default) Selects the internal format of textures used for FBOs. The format can influence performance and quality of the video output. can be one of: rgb8, rgb10, rgb10_a2, rgb16, rgb16f, rgb32f, rgba12, rgba16, rgba16f, rgba16hf, rgba32f. Default: , which first attempts to utilize 16bit float (rgba16f, rgba16hf), and falls back to rgba16 if those are not available. Finally, attempts to utilize rgb10_a2 or rgba8 if all of the previous formats are not available. Set an additional raw gamma factor (default: 1.0). If gamma is adjusted in other ways (like with the option or key bindings and the property), the value is multiplied with the other gamma value. Automatically corrects the gamma value depending on ambient lighting conditions (adding a gamma boost for bright rooms). This option is deprecated and may be removed in the future. NOTE: Only implemented on macOS and . Specifies a custom LUT file (in Adobe .cube format) to apply to the colors during image decoding. The exact interpretation of the LUT depends on the value of . (Only for ) Controls the interpretation of color values fed to and from the LUT specified as . Valid values are: Chooses the interpretation of the LUT automatically from tagged metadata, and otherwise falls back to . (Default) Applied to the raw image contents in its native colorspace, before decoding to RGB. For example, for a HDR10 image, this would be fed PQ-encoded YCbCr values in the range 0.0 - 1.0. Applied to the normalized RGB image contents, after decoding from its native color encoding, but before linearization. Fully replaces the color decoding. A LUT of this type should ingest the image's native colorspace and output normalized non-linear RGB. Automatically configure the output colorspace of the display to pass through the input values of the stream (e.g. for HDR passthrough), if possible. In mode, the target colorspace is only set, if the display signals support for HDR colorspace. Requires a supporting driver and . (Default: ) Specifies the primaries of the display. Video colors will be adapted to this colorspace when ICC color management is not being used. Valid values are: Disable any adaptation, except for atypical color spaces. Specifically, wide/unusual gamuts get automatically adapted to BT.709, while standard gamut (i.e. BT.601 and BT.709) content is not touched. (default) CIE 1931 RGB (not to be confused with CIE XYZ) Specifies the transfer characteristics (gamma) of the display. Video colors will be adjusted to this curve when ICC color management is not being used. Valid values are: Disable any adaptation, except for atypical transfers. Specifically, HDR or linear light source material gets automatically converted to gamma 2.2, while SDR content is not touched. (default) Pure power curve (gamma 1.8), also used for Apple RGB Pure power curve (gamma 2.8), also used for BT.470-BG When using HDR output formats, mpv will encode to the specified curve but it will not set any HDMI flags or other signalling that might be required for the target device to correctly display the HDR signal. The user should independently guarantee this before using these signal formats for display. Specifies the measured peak brightness of the output display, in cd/m^2 (AKA nits). The interpretation of this brightness depends on the configured . In all cases, it imposes a limit on the signal values that will be sent to the display. If the source exceeds this brightness level, a tone mapping filter will be inserted. For HLG, it has the additional effect of parametrizing the inverse OOTF, in order to get colorimetrically consistent results with the mastering display. For SDR, or when using an ICC (profile ( ), setting this to a value above 203 essentially causes the display to be treated as if it were an HDR display in disguise. (See the note below) In mode (the default), the chosen peak is an appropriate value based on the TRC in use. For SDR curves, it uses 203. For HDR curves, it uses 203 * the transfer function's nominal peak. If available, it will use the target display's peak brightness as reported by the display. When using an SDR transfer function, this is normally not needed, and setting it may lead to very unexpected results. The one time it is useful is if you want to calibrate a HDR display using traditional transfer functions and calibration equipment. In such cases, you can set your HDR display to a high brightness such as 800 cd/m^2, and then calibrate it to a standard curve like gamma2.8. Setting this value to 800 would then instruct mpv to essentially treat it as an HDR display with the given peak. This may be a good alternative in environments where PQ or HLG input to the display is not possible, and makes it possible to use HDR displays with mpv regardless of operating system support for HDMI HDR metadata. In such a configuration, we highly recommend setting to or even . Specifies the measured contrast of the output display. in conjunction with value is used to calculate display black point. Used in black point compensation during HDR tone-mapping. is the default and assumes 1000:1 contrast as a typical SDR display would have or an infinite contrast when HDR is used. If supported by the API, display contrast will be used as reported. contrast specifies display with perfect black level, in practice OLED. (Only for ) Constrains the gamut of the display. You can use this option to output e.g. DCIP3-in-BT.2020. Set to the primaries of the containing colorspace (into which values will be encoded), and to the gamut you want to limit colors to. Takes the same values as . (Only for ) Specifies a custom LUT file (in Adobe .cube format) to apply to the colors before display on-screen. This LUT is fed values in normalized RGB, after encoding into the target colorspace, so after the application of . (Only for ) Specifies the algorithm used for tone-mapping images onto the target display. This is relevant for both HDR->SDR conversion as well as gamut reduction (e.g. playing back BT.2020 content on a standard gamut display). Valid values are: Maps to when using , and to with . (Default) Hard-clip any out-of-range values. Use this when you care about perfect color accuracy for in-range values at the cost of completely distorting out-of-range values. Not generally recommended. Generalization of Reinhard to a Möbius transform with linear section. Smoothly maps out-of-range values while retaining contrast and colors for in-range material as much as possible. Use this when you care about color accuracy more than detail preservation. This is somewhere in between and , depending on the value of . Reinhard tone mapping algorithm. Very simple continuous curve. Preserves overall image brightness but uses nonlinear contrast, which results in flattening of details and degradation in color accuracy. Similar to but preserves both dark and bright details better (slightly sigmoidal), at the cost of slightly darkening / desaturating everything. Developed by John Hable for use in video games. Use this when you care about detail preservation more than color/brightness accuracy. This is roughly equivalent to . If possible, you should also enable for the best results. Linearly stretches the entire reference gamut to (a linear multiple of) the display. HDR<->SDR mapping specified in ITU-R Report BT.2446, method A. This is the recommended curve for well-mastered content. ( only) Dynamic HDR10+ tone-mapping method specified in SMPTE ST2094-40 Annex B. In the absence of metadata, falls back to a fixed spline matched to the input/output average brightness characteristics. ( only) Dynamic tone-mapping method specified in SMPTE ST2094-10 Annex B.2. Conceptually simpler than ST2094-40, and generally produces worse results. Set tone mapping parameters. By default, this is set to the special string , which maps to an algorithm-specific default value. Ignored if the tone mapping algorithm is not tunable. This affects the following tone mapping algorithms: Specifies an extra linear coefficient to multiply into the signal before clipping. Defaults to 1.0. Specifies the transition point from linear to mobius transform. Every value below this point is guaranteed to be mapped 1:1. The higher the value, the more accurate the result will be, at the cost of losing bright details. Defaults to 0.3, which due to the steep initial slope still preserves in-range colors fairly accurately. Specifies the local contrast coefficient at the display peak. Defaults to 0.5, which means that in-gamut values will be about half as bright as when clipping. Specifies the offset for the knee point. Defaults to 1.0, which is higher than the value from the original ITU-R specification (0.5). ( only) Specifies the exponent of the function. Defaults to 1.8. Specifies the scale factor to use while stretching. Defaults to 1.0. Specifies the knee point (in PQ space). Defaults to 0.30. Specifies the contrast (slope) at the knee point. Defaults to 1.0. If set, allows inverse tone mapping (expanding SDR to HDR). Not supported by all tone mapping curves. Use with caution. ( only) Upper limit for how much the tone mapping algorithm is allowed to boost the average brightness by over-exposing the image. The default value of 1.0 allows no additional brightness boost. A value of 2.0 would allow over-exposing by a factor of 2, and so on. Raising this setting can help reveal details that would otherwise be hidden in dark scenes, but raising it too high will make dark scenes appear unnaturally bright. ( only) Display a (PQ-PQ) graph of the active tone-mapping LUT. Intended only for debugging purposes. The X axis shows PQ input values, the Y axis shows PQ output values. The tone-mapping curve is shown in green/yellow. Yellow means the brightness has been boosted from the source, dark blue regions show where the brightness has been reduced. The extra colored regions and lines indicate various monitor limits, as well a reference diagonal (neutral tone-mapping) and source scene average brightness information (if available). ( only) Specifies the algorithm used for reducing the gamut of images for the target display, after any tone mapping is done. Hard-clip to the gamut (per-channel). Very low quality, but free. Performs a perceptually balanced gamut mapping using a soft knee function to roll-off clipped regions, and a hue shifting function to preserve saturation. ( only) Performs relative colorimetric clipping, while maintaining an exponential relationship between brightness and chromaticity. ( only) Performs simple RGB->RGB saturation mapping. The input R/G/B channels are mapped directly onto the output R/G/B channels. Will never clip, but will distort all hues and/or result in a faded look. ( only) Performs absolute colorimetric clipping. Like , but does not adapt the white point. ( only) Uniformly darkens the input slightly to prevent clipping on blown-out highlights, then clamps colorimetrically to the input gamut boundary, biased slightly to preserve chromaticity over luminance. ( only) Linearly/uniformly desaturates the image in order to bring the entire image into the target gamut. ( only) Compute the HDR peak and frame average brightness per-frame instead of relying on tagged metadata. These values are averaged over local regions as well as over several frames to prevent the value from jittering around too much. This option basically gives you dynamic, per-scene tone mapping. Requires compute shaders, which is a fairly recent OpenGL feature, and will probably also perform horribly on some drivers, so enable at your own risk. The special value (default) will enable HDR peak computation automatically if compute shaders and SSBOs are supported. When using , allow delaying the detected peak by a frame when beneficial for performance. In particular, this is required to avoid an unnecessary FBO indirection when no advanced rendering is required otherwise. Has no effect if there already is an indirect pass, such as when advanced scaling is enabled. Defaults to no. (Only affects , note that always delays the peak.) Which percentile of the input image brightness histogram to consider as the true peak of the scene. If this is set to 100 (default), the brightest pixel is measured. Otherwise, the top of the frequency distribution is progressively cut off. Setting this too low will cause clipping of very bright details, but can improve the dynamic brightness range of scenes with very bright isolated highlights. Values other than 100 come with a small performance penalty. (Only for ) The decay rate used for the HDR peak detection algorithm (default: 20.0). This is only relevant when is enabled. Higher values make the peak decay more slowly, leading to more stable values at the cost of more \"eye adaptation\"-like effects (although this is mitigated somewhat by ). A value of 0.0 (the lowest possible) disables all averaging, meaning each frame's value is used directly as measured, but doing this is not recommended for \"noisy\" sources since it may lead to excessive flicker. (In signal theory terms, this controls the time constant \"tau\" of an IIR low pass filter) The lower and upper thresholds (in dB) for a brightness difference to be considered a scene change (default: 1.0 low, 3.0 high). This is only relevant when is enabled. Normally, small fluctuations in the frame brightness are compensated for by the peak averaging mechanism, but for large jumps in the brightness this can result in the frame remaining too bright or too dark for up to several seconds, depending on the value of . To counteract this, when the brightness between the running average and the current frame exceeds the low threshold, mpv will make the averaging filter more aggressive, up to the limit of the high threshold (at which point the filter becomes instant). Enables the HDR contrast recovery algorithm, which is to designed to enhance contrast of HDR video after tone mapping. The strength (default: 0.0) indicates the degree of contrast recovery, with 0.0 being completely disabled and 1.0 being 100% strength. Values higher than 1.0 are allowed, but may result in excessive sharpening. The smoothness (default: 3.5) indicates the degree to which the HDR source is low-passed in order to obtain contrast information - a value of 2.0 corresponds to 2x downscaling. Users on low DPI displays (<= 100) may want to lower this value, while users on very high DPI displays (\"retina\") may want to increase it. (Only for ) Load the embedded ICC profile contained in media files such as PNG images. (Default: yes). Note that this option only works when also using a display ICC profile ( or ), and also requires LittleCMS 2 support. Load an ICC profile and use it to transform video RGB to screen output. Needs LittleCMS 2 support compiled in. This option overrides the , and options. Automatically select the ICC display profile currently specified by the display settings of the operating system. NOTE: On Windows, the default profile must be an ICC profile. WCS profiles are not supported. Applications using libmpv with the render API need to provide the ICC profile via . Store and load 3DLUTs created from the ICC profile on disk in the cache directory (Default: ). This can be used to speed up loading, since LittleCMS 2 can take a while to create a 3D LUT. Note that these files contain uncompressed LUTs. Their size depends on the , and can be very big. On , files that have not been accessed in the last 24 hours may be cleared if the cache limit (1.5 GiB) is exceeded. On , this is not cleaned automatically, so old, unused cache files may stick around indefinitely. The directory where icc cache is stored. Cache is stored in the system's cache directory (usually ) if this is unset. Specifies the ICC intent used for the color transformation (when using ). Size of the 3D LUT generated from the ICC profile in each dimension. The default of means to pick the size automatically based on the profile characteristics. Sizes may range from 2 to 512. NOTE: Setting this option to anything other than is strongly discouraged, except for testing. Override the target device's detected contrast ratio by a specific value. This is detected automatically from the profile if possible, but for some profiles it might be missing, causing the contrast to be assumed as infinite. As a result, video may appear darker than intended. If this is the case, setting this option might help. This only affects BT.1886 content. The default of means to use the profile values. The special value causes the BT.1886 curve to be treated as a pure power gamma 2.4 function. Use ICC profile luminance value. (Only for ) Specifies a custom LUT (in Adobe .cube format) to apply to the colors as part of color conversion. The exact interpretation depends on the value of . (Only for ) Controls the interpretation of color values fed to and from the LUT specified as . Valid values are: Chooses the interpretation of the LUT automatically from tagged metadata, and otherwise falls back to . (Default) Applied to raw image contents in its native RGB colorspace (non-linear light), before conversion to the output color space. Applied to the normalized RGB image contents, in linear light, before conversion to the output color space. Fully replaces the conversion from the image color space to the output color space. If such a LUT is present, it has the highest priority, and overrides any ICC profiles, as well as options related to tone mapping and output colorimetry ( , etc.). Blend subtitles directly onto upscaled video frames, before interpolation and/or color management (default: no). Enabling this causes subtitles to be affected by , , , , and . It also increases subtitle performance when using . The downside of enabling this is that it restricts subtitles to the visible portion of the video, so you can't have subtitles exist in the black margins below a video (for example). If is selected, the behavior is similar to , but subs are drawn at the video's native resolution, and scaled along with the video. This changes the way subtitle colors are handled. Normally, subtitle colors are assumed to be in sRGB and color managed as such. Enabling this makes them treated as being in the video's color space instead. This is good if you want things like softsubbed ASS signs to match the video colors, but may cause SRT subtitles or similar to look slightly off. If the frame has an alpha component, decide what kind of background, if any, to blend it with. This does nothing if there is no alpha component. Blend the frame against the background color ( , normally black). Do not blend the frame and leave the alpha as is. Before mpv 0.38.0, this option used to accept a color value specifying the background color. This is now done by the option. Use that instead. Color used to draw parts of the mpv window not covered by video. See the option for how colors are defined. Same as but only applies to the black bar/border area of the window. only. Defaults to . Force use of rectangle textures (default: no). Normally this shouldn't have any advantages over normal textures. Note that hardware decoding overrides this flag. Could be removed any time. Enlarge the video source textures by this many pixels. For debugging only (normally textures are sized exactly, but due to hardware decoding interop we may have to deal with additional padding, which can be tested with these options). Could be removed any time. Call after rendering a frame and before attempting to display it (default: auto). Can fix stuttering in some cases, in other cases probably causes it. The mode will call only if the renderer is going to wait for a while after rendering, instead of flipping GL front and backbuffers immediately (i.e. it doesn't call it in display-sync mode). On macOS this is always deactivated because it only causes performance problems and other regressions. This mode is extremely restricted, and will disable most extended features. That includes high quality scalers and custom shaders! It is intended for hardware that does not support FBOs (including GLES, which supports it insufficiently), or to get some more performance out of bad or old hardware. This mode is forced automatically if needed, and this option is mostly useful for debugging. The default of will enable it automatically if nothing uses features which require FBOs. This option might be silently removed in the future. Store and load compiled GLSL shaders in the cache directory (Default: ). Normally, shader compilation is very fast, so this is not usually needed. It mostly matters for anything involving GLSL to SPIR-V conversion, that is: D3D11, ANGLE or Vulkan, as well as on some other proprietary drivers. Enabling this can improve startup performance on these platforms. On , files that have not been accessed in the last 24 hours may be cleared if the cache limit (128 MiB) is exceeded. On , this is not cleaned automatically, so old, unused cache files may stick around indefinitely. The directory where gpu shader cache is stored. Cache is stored in the system's cache directory (usually ) if this is unset. Passes extra raw option to the libplacebo rendering backend (used by ). May override the effects of any other options set using the normal options system. Requires libplacebo v6.309 or higher. Included for debugging purposes only. For more information, see: Gradually adjusts the A/V sync based on audio delay measurements. Specifying , the default, will cause frame timing to be based entirely on audio delay measurements. Specifying will do the same, but will subtly change the A/V correction algorithm. An uneven video framerate in a video which plays fine with can often be helped by setting this to an integer value greater than 1. The higher the value, the closer the timing will be to . Try to smooth out problems with sound drivers which do not implement a perfect audio delay measurement. With this value, if large A/V sync offsets occur, they will only take about 1 or 2 seconds to settle out. This delay in reaction time to sudden A/V offsets should be the only side effect of turning this option on, for all sound drivers. Control how long before video display target time the frame should be rendered (default: 0.050). If a video frame should be displayed at a certain time, the VO will start rendering the frame earlier, and then will perform a blocking wait until the display time, and only then \"swap\" the frame to display. The rendering cannot start before the previous frame is displayed, so this value is implicitly limited by the video framerate. With normal video frame rates, the default value will ensure that rendering is always immediately started after the previous frame was displayed. On the other hand, setting a too high value can reduce responsiveness with low FPS value. This option is interesting for client API users using the render API because you can stop it from limiting your FPS (see documentation). This applies only to audio timing modes (e.g. ). In other modes ( ), video timing relies on vsync blocking, and this option is not used. How the player synchronizes audio and video. If you use this option, you usually want to set it to to enable a timing mode that tries to not skip or repeat frames when for example playing 24fps video on a 24Hz screen. The modes starting with try to output video frames completely synchronously to the display, using the detected display vertical refresh rate as a hint how fast frames will be displayed on average. These modes change video speed slightly to match the display. See options for fine tuning. The robustness of this mode is further reduced by making a some idealized assumptions, which may not always apply in reality. Behavior can depend on the VO and the system's video and audio drivers. Media files must use constant framerate. Section-wise VFR might work as well with some container formats (but not e.g. mkv). Under some circumstances, the player automatically reverts to mode for some time or permanently. This can happen on very low framerate video, or if the framerate cannot be detected. Also in display-sync modes it can happen that interruptions to video playback (such as toggling fullscreen mode, or simply resizing the window) will skip the video frames that should have been displayed, while mode will display them after the renderer has resumed (typically resulting in a short A/V desync and the video \"catching up\"). Before mpv 0.30.0, there was a fallback to mode on severe A/V desync. This was changed for the sake of not sporadically stopping. Now, does what it promises and may desync with audio by an arbitrary amount, until it is manually fixed with a seek. These modes also require a vsync blocked presentation mode. For OpenGL, this translates to . For Vulkan, it translates to (or ). The modes with in their names do not attempt to keep audio/video in sync. They will slowly (or quickly) desync, until e.g. the next seek happens. These modes are meant for testing, not serious use. Time video frames to audio. This is the most robust mode, because the player doesn't have to assume anything about how the display behaves. The disadvantage is that it can lead to occasional frame drops or repeats. If audio is disabled, this uses the system clock. This is the default mode. Resample audio to match the video. This mode will also try to adjust audio speed to compensate for other drift. (This means it will play the audio at a different speed every once in a while to reduce the A/V difference.) Resample audio to match the video. Drop video frames to compensate for drift. Like the previous mode, but no A/V compensation. Same as , but apply audio speed changes to audio filters instead of resampling to avoid the change in pitch. Beware that some audio filters don't do well with a speed close to 1. It is recommend to use a conditional profile to automatically switch to when speed gets too close to 1 for your filter setup. Use (speed * video_speed_correction) to get the actual playback speed in the condition. See Conditional auto profiles for details. Drop or repeat video frames to compensate desyncing video. (Although it should have the same effects as , the implementation is very different.) Drop or repeat audio data to compensate desyncing video. This mode will cause severe audio artifacts if the real monitor refresh rate is too different from the reported or forced rate. Since mpv 0.33.0, this acts on entire audio frames, instead of single samples. Sync video to display, and let audio play on its own. Sync video according to system clock, and let audio play on its own. Maximum multiple for which to try to fit the video's FPS to the display's FPS (default: 5). For example, if this is set to 1, the video FPS is forced to an integer multiple of the display FPS, as long as the speed change does not exceed the value set by . See for how this option affects interpolation. Maximum speed difference in percent that is applied to video with (default: 1). Display sync mode will be disabled if the monitor and video refresh way do not match within the given range. It tries multiples as well: playing 30 fps video on a 60 Hz screen will duplicate every second frame. Playing 24 fps video on a 60 Hz screen will play video in a 2-3-2-3-... pattern. The default settings are not loose enough to speed up 23.976 fps video to 25 fps. We consider the pitch change too extreme to allow this behavior by default. Set this option to a value of to enable it. Also note that in the or mode, audio speed will additionally be changed by a small amount if necessary for A/V sync. See . Maximum additional speed difference in percent that is applied to audio with (default: 0.125). Normally, the player plays the audio at the speed of the video. But if the difference between audio and video position is too high, e.g. due to drift or other timing errors, it will attempt to speed up or slow down audio by this additional factor. Too low values could lead to video frame dropping or repeating if the A/V desync cannot be compensated, too high values could lead to chaotic frame dropping due to the audio \"overshooting\" and skipping multiple video frames before the sync logic can react. Set the list of tags that should be displayed on the terminal and stats. Tags that are in the list, but are not present in the played file, will not be shown. If a value ends with , all tags are matched by prefix (though there is no general globbing). Just passing essentially filtering. The default includes a common list of tags, call mpv with to see it. This is a string list option. See List Options for details. Framerate used when decoding from multiple PNG or JPEG files with (default: 1). Input file type for (available: jpeg, png, tga, sgi). By default, this is guessed from the file extension. Instead of playing a file, read its byte stream and write it to the given destination file. The destination is overwritten. Can be useful to test network-related behavior. Set AVOptions on streams opened with libavformat. Unknown or misspelled options are silently ignored. (They are mentioned in the terminal output in verbose mode, i.e. . In general we can't print errors, because other options such as e.g. user agent are not available with all protocols, and printing errors for unknown options would end up being too noisy.) This is a key/value list option. See List Options for details. The backdrop will be black or white depending on the system's theme settings. Enables the Mica style, which is the default on Windows 11. Same as Mica, except reversed. (Windows only) Controls the window affinity behavior of mpv. mpv's window will be completely excluded from capture by external applications or screen recording software. (Windows only) Set the MMCSS profile for the video renderer thread (default: ). (Windows only) Set process priority for mpv according to the predefined priorities available under Windows. Using realtime priority can cause system lockup. Force the contents of the property to this value. Useful for scripts which want to set a title, without overriding the user's setting in . Load a file and add all of its tracks. This is useful to play different files together (for example audio from one file, video from another), or for advanced used (like playing two video files at the same time). Unlike and , this includes all tracks, and does not cause default stream selection over the \"proper\" file. This makes it slightly less intrusive. (In mpv 0.28.0 and before, this was not quite strictly enforced.) This is a path list option. See List Options for details. CLI/config file only alias for . Each use of this option will add a new external file. Use an external file as cover art while playing audio. This makes it appear on the track list and subject to automatic track selection. Options like control whether such tracks are supposed to be selected. This is a path list option. See List Options for details. CLI/config file only alias for . Each use of this option will add a new external file. Whether to load _external_ cover art automatically. Similar to and . If a video already has tracks (which are not marked as cover art), external cover art will not be loaded. Load the media filename with an image file extension (default). Load all cover art containing the media filename. Load all images in the current directory. See for details about what constitutes cover art. See how to control display of cover art (this can be used to disable cover art that is part of the file). Image file extensions to try to match when using , or . This is a string list option. See List Options for details. Use to see default extensions. Filenames to load as cover art, sorted by descending priority. They are combined with the extensions in . This has no effect if is . This is a string list option. See List Options for details. Video file extensions to try to match when using or . This is a string list option. See List Options for details. Use to see default extensions. Archive file extensions to try to match when using or . This is a string list option. See List Options for details. Use to see the default extensions. Playlist file extensions to try to match when using or . This is a string list option. See List Options for details. Use to see the default extensions. If set to , then do not automatically load external files as specified by , and . If external files are forcibly added (like with ), they will not be auto-selected. This does not affect playlist expansion, redirection, or other loading of referenced files like with ordered chapters. Write received/read data from the demuxer to the given output file. The output file will always be overwritten without asking. The output format is determined by the extension of the output file. Switching streams or seeking during recording might result in recording being stopped and/or broken files. Use with care. Seeking outside of the demuxer cache will result in \"skips\" in the output file, but seeking within the demuxer cache should not affect recording. One exception is when you seek back far enough to exceed the forward buffering size, in which case the cache stops actively reading. This will return in dropped data if it's a live stream. If this is set at runtime, the old file is closed, and the new file is opened. Note that this will write only data that is appended at the end of the cache, and the already cached data cannot be written. You can try the command as an alternative. External files ( etc.) are ignored by this, it works on the \"main\" file only. Using this with files using ordered chapters or EDL files will also not work correctly in general. There are some glitches with this because it uses FFmpeg's libavformat for writing the output file. For example, it's typical that it will only work if the output format is the same as the input format. This is the case even if it works with the tool. One reason for this is that and its libraries contain certain hacks and workarounds for these issues, that are unavailable to outside users. Set a \"complex\" libavfilter filter, which means a single filter graph can take input from multiple source audio and video tracks. The graph can result in a single audio or video output (or both). Currently, the filter graph labels are used to select the participating input tracks and audio/video output. The following rules apply:\n• A label of the form selects audio track N as input (e.g. ).\n• A label of the form selects video track N as input.\n• A label named will be connected to the audio output.\n• A label named will be connected to the video output. Each label can be used only once. If you want to use e.g. an audio stream for multiple filters, you need to use the filter. Multiple video or audio outputs are not possible, but you can use filters to merge them into one. It's not possible to change the tracks connected to the filter at runtime, unless you explicitly change the property and set new track assignments. When the graph is changed, the track selection is changed according to the used labels as well. Other tracks, as long as they're not connected to the filter, and the corresponding output is not connected to the filter, can still be freely changed with the normal methods. Note that the normal filter chains ( , ) are applied between the complex graphs (e.g. label) and the actual output.\n• Play audio track 1 and 2 at the same time.\n• Stack video track 1 and 2 and play them at the same time. Note that both tracks need to have the same width, or filter initialization will fail (you can add filters before the filter to fix the size). To load a video track from another file, you can use .\n• Use the inputs option to stack more than 2 tracks.\n• Play audio track 1, and overlay the measured volume for each speaker over video track 1. See the FFmpeg libavfilter documentation for details on the available filters. Codepage for various input metadata (default: ). This affects how file tags, chapter titles, etc. are interpreted. In most cases, this merely evaluates to UTF-8 as non-UTF-8 codepages are obscure. See option on how codepages are specified and further details regarding autodetection and codepage conversion. (The underlying code is the same.) Conversion is not applied to metadata that is updated at runtime. Specify a priority list of the clipboard backends to be used. You can also pass to get a complete list of compiled in backends. If the list is not empty, it enables native clipboard support for the specified backends. This allows reading and writing to the property to get and set clipboard contents. Native clipboard support is enabled by default. To disable this, remove all backends in this list with . Note that the default clipboard backends are subject to change, and must not be relied upon. The following clipboard backends are implemented: Wayland backend. This backend is only available if the compositor supports the protocol. VO backend. Requires an active VO window, and support differs across platforms. Currently, this is used as a fallback for Wayland compositors without support for the protocol, or if the backend is disabled. This is an object settings list option. See List Options for details. Enable clipboard monitoring so that the property can be observed for content changes (default: no). This only affects clipboard implementations which use polling to monitor clipboard updates. Other platforms currently ignore this option and always/never notify changes. On Wayland, this option only has effect on the backend, and not for the backend. See property for more details.\n\nThe mpv core can be controlled with commands and properties. A number of ways to interact with the player use them: key bindings ( ), OSD (showing information with properties), JSON IPC, the client API ( ), and the classic slave mode. The input.conf file consists of a list of key bindings, for example: s screenshot # take a screenshot with the s key LEFT seek 15 # map the left-arrow key to seeking forward by 15 seconds Each line maps a key to an input command. Keys are specified with their literal value (upper case if combined with ), or a name for special keys. For example, maps to the key without shift, and maps to with shift. The file is located in the mpv configuration directory (normally at depending on platform). The default bindings are defined here: A list of special keys can be obtained with In general, keys can be combined with , and : mpv can be started in input test mode, which displays key bindings and the commands they're bound to on the OSD, instead of executing the commands: Note that by default, the right Alt key can be used to create special characters, and thus does not register as a modifier. This can be changed with option. Newlines always start a new binding. starts a comment (outside of quoted string arguments). To bind commands to the key, can be used. is either the literal character the key produces (ASCII or Unicode character), or a symbolic name (as printed by ). (braced with and ) is the input section for this command. is the command itself. It consists of the command name and multiple (or none) arguments, all separated by whitespace. String arguments should be quoted, typically with . See . You can bind multiple commands to one key. For example: It's also possible to bind a command to a sequence of keys: a-b-c show-text \"command run after a, b, c have been pressed\" If or or are already bound, this will run the first command that matches, and the multi-key command will never be called. Intermediate keys can be remapped to in order to avoid this issue. The maximum number of (non-modifier) keys for combinations is currently 4. All mouse and keyboard input is to converted to mpv-specific key names. Key names are either special symbolic identifiers representing a physical key, or text key names, which are Unicode code points encoded as UTF-8. These are what keyboard input would normally produce, for example for the A key. These are influenced by keyboard modifiers which affect produced text, such as shift and caps lock. As a consequence, mpv uses input translated by the current OS keyboard layout, rather than physical scan codes. Currently there is the hardcoded assumption that every text key can be represented as a single Unicode code point (in NFKC form). All key names can be combined with the modifiers , , , . They must be prefixed to the actual key name, where each modifier is followed by a (for example ). The modifier requires some attention. In general, when the modifier is combined with a key which produces text, the actual produced text key name when shift is pressed should be used. For instance, on the US keyboard layout, should usually be specified as key-name at , and similarly the combination is usually , etc. In general, the modifier, when specified with text key names, is ignored: for instance, mpv interprets as . The only exceptions are ASCII letters, which are normalized by mpv. For example, is interpreted as . Special key names like work as expected. If in doubt - use to check how a key/combination is seen by mpv. Symbolic key names and modifier names are case-insensitive. Unicode key names are case-sensitive just like how keyboard text input would produce. Another type of key names are hexadecimal key names, which start with , followed by the hexadecimal value of the key. The hexadecimal value can be either a Unicode code point value, or can serve as fallback for special keys that do not have a special mpv defined name. They will break as soon as mpv adds proper names for them, but can enable you to use a key at all if that does not happen. All symbolic names are listed by . is a special mode that prints all input on the OSD. Keypad names. Behavior varies by backend (whether they implement this, and on how they treat numlock), but typically, mpv tries to map keys on the keypad to separate names, even if they produce the same text as normal keys. Depending on backend, the mouse wheel might also be represented as a button. In addition, to are deprecated aliases for , , , . These key are scalable when used with scalable commands if the underlying device supports high-resolution scrolling (e.g. touch pads). Emitted by mouse move events. Enter/leave happens when the mouse enters or leave the mpv window (or the current mouse region, using the deprecated mouse region input section mechanism). Pseudo key emitted when closing the mpv window using the OS window manager (for example, by clicking the close button in the window title bar). Pseudo-key that matches any unmapped key. (You should probably avoid this if possible, because it might change behavior or get removed in the future.) Pseudo-key that matches any key that produces text. (You should probably avoid this if possible, because it might change behavior or get removed in the future.) This is the syntax used in input.conf, and referred to \"input.conf syntax\" in a number of other places. is an unquoted string with the command name itself. See List of Input Commands for a list. Arguments are separated by whitespaces even if the command expects only one argument. Arguments with whitespaces or other special characters must be quoted, or the command cannot be parsed correctly. Double quotes interpret JSON/C-style escaping, like or or . JSON escapes according to RFC 8259, minus surrogate pair escapes. This is the only form which allows newlines at the value - as . Single quotes take the content literally, and cannot include the single-quote character at the value. Custom quotes also take the content literally, but are more flexible than single quotes. They start with (back-quote) followed by any ASCII character, and end at the first occurrence of the same pair in reverse order, e.g. or . The final pair sequence is not allowed at the value - in these examples and respectively. In the second example the last character of the value also can't be a back-quote. Mixed quoting at the same argument, like , is not supported. Note that argument parsing and property expansion happen at different stages. First, arguments are determined as described above, and then, where applicable, properties are expanded - regardless of argument quoting. However, expansion can still be prevented with the prefix or . See Input Command Prefixes and Property Expansion. This applies to certain APIs, such as or (with array parameters) in Lua scripting, or or (with MPV_FORMAT_NODE_ARRAY) in the C libmpv client API. The command as well as all arguments are passed as a single array. Similar to the Flat command syntax, you can first pass prefixes as strings (each as separate array item), then the command name as string, and then each argument as string or a native value. Since these APIs pass arguments as separate strings or native values, they do not expect quotes, and do support escaping. Technically, there is the input.conf parser, which first splits the command string into arguments, and then invokes argument parsers for each argument. The input.conf parser normally handles quotes and escaping. The array command APIs mentioned above pass strings directly to the argument parsers, or can sidestep them by the ability to pass non-string values. Property expansion is disabled by default for these APIs. This can be changed with the prefix. See Input Command Prefixes. Sometimes commands have string arguments, that in turn are actually parsed by other components (e.g. filter strings with ) - in these cases, you you would have to double-escape in input.conf, but not with the array APIs. For complex commands, consider using Named arguments instead, which should give slightly more compatibility. Some commands do not support named arguments and inherently take an array, though. This applies to certain APIs, such as (with tables that have string keys) in Lua scripting, or (with MPV_FORMAT_NODE_MAP) in the C libmpv client API. The name of the command is provided with a string field. The name of each command is defined in each command description in the List of Input Commands. also lists them. See the command for an example. Some commands do not support named arguments (e.g. command). You need to use APIs that pass arguments as arrays. Named arguments are not supported in the \"flat\" input.conf syntax, which means you cannot use them for key bindings in input.conf at all. Property expansion is disabled by default for these APIs. This can be changed with the prefix. See Input Command Prefixes. Commands with parameters have the parameter name enclosed in / . Don't add those to the actual command. Optional arguments are enclosed in / . If you don't pass them, they will be set to a default value. Remember to quote string arguments in input.conf (see Flat command syntax). Change the playback position. By default, seeks by a relative amount of seconds. The second argument consists of flags controlling the seek mode: Seek to a given time (a negative value starts from the end of the file). By default, is used for , , and seeks, while is used for seeks. Before mpv 0.9, the and flags had to be passed as 3rd parameter (essentially using a space instead of ). The 3rd parameter is still parsed, but is considered deprecated. This is a scalable command. See the documentation of input command prefix in Input Command Prefixes for details. Undoes the command, and some other commands that seek (but not necessarily all of them). Calling this command once will jump to the playback position before the seek. Calling it a second time undoes the command itself. This only works within a single file. The first argument is optional, and can change the behavior: Mark the current time position. The next normal command will seek back to this point, no matter how many seeks happened since last time. If set, mark the current position, and do not change the mark position before the next command that has or set (or playback of the current file ends). Until this happens, will always seek to the marked point. This flag cannot be combined with . Using it without any arguments gives you the default behavior. Change video and audio position such that the subtitle event after subtitle events is displayed. For example, skips to the next subtitle, skips to the previous subtitles, and seeks to the beginning of the current subtitle. This is similar to , except that it seeks video and audio instead of adjusting the subtitle delay. For embedded subtitles (like with Matroska), this works only with subtitle events that have already been displayed, or are within a short prefetch range. See Cache for details on how to control the available prefetch range. Go forward or backwards by a given amount of frames. If is omitted, the value is assumed to be . The second argument consists of flags controlling the frameskip mode: Play the video forward by the desired amount of frames and then pause. This only works with a positive value (i.e. frame stepping forwards). Perform a very exact seek that attempts to seek by the desired amount of frames. If is , this will go exactly to the previous frame. The same as but mutes the audio stream if there is any during the duration of the frame step. Note that the default frameskip mode, play, is more accurate but can be slow depending on how many frames you are skipping (i.e. skipping forward 100 frames will play 100 frames of video before stopping). This mode only works when going forwards. Frame stepping back always performs a seek. When using seek mode, this can still be very slow (it tries to be precise, not fast), and sometimes fails to behave as expected. How well this works depends on whether precise seeking works correctly (e.g. see the option). Video filters or other video post-processing that modifies timing of frames (e.g. deinterlacing) should usually work, but might make framestepping silently behave incorrectly in corner cases. Using should help, although it might make precise seeking slower. Also if the video is VFR, framestepping using seeks will probably not work correctly except for the case. This does not work with audio-only playback. Calls with a value of and the flag. This does not work with audio-only playback. Stop playback and clear playlist. With default settings, this is essentially like . Useful for the client API: playback can be stopped without terminating the player. The first argument is optional, and supports the following flags: Do not clear the playlist. Set the given property or option to the given value. Delete the given property. Most properties cannot be deleted. Add the given value to the property or option. On overflow or underflow, clamp the property to the maximum. If is omitted, assume . Whether or not key-repeat is enabled by default depends on the property. Currently properties with continuous values are repeatable by default (like ), while discrete values are not (like ). This is a scalable command. See the documentation of input command prefix in Input Command Prefixes for details. Similar to , but multiplies the property or option with the numeric value. Cycle the given property or option. The second argument can be or to set the cycle direction. On overflow, set the property back to the minimum, on underflow set it to the maximum. If or is omitted, assume . Whether or not key-repeat is enabled by default depends on the property. Currently properties with continuous values are repeatable by default (like ), while discrete values are not (like ). This is a scalable command. See the documentation of input command prefix in Input Command Prefixes for details. Cycle through a list of values. Each invocation of the command will set the given property to the next value in the list. The command will use the current value of the property/option, and use it to determine the current position in the list of values. Once it has found it, it will set the next value in the list (wrapping around to the first item if needed). This command has a variable number of arguments, and cannot be used with named arguments. The special argument can be used to cycle the value list in reverse. The only advantage is that you don't need to reverse the value list yourself when adding a second key binding for cycling backwards. This command changes list options as described in List Options. The parameter is the normal option name, while is the suffix or action used on the option. Some operations take no value, but the command still requires the value parameter. In these cases, the value must be an empty string. Add a filename to the list. The command line equivalent is or alternatively . Go to the next entry on the playlist. If the last file on the playlist is currently played, do nothing. Terminate playback if there are no more files on the playlist. Go to the previous entry on the playlist. If the first file on the playlist is currently played, do nothing. Terminate playback if the first file is being played. Go to the next entry on the playlist with a different . Go to the first of the previous entries on the playlist with a different . Start (or restart) playback of the given playlist index. In addition to the 0-based playlist entry index, it supports the following values: The current playlist entry (as in ) will be played again (unload and reload). If none is set, playback is stopped. (In corner cases, can point to a playlist entry even if playback is currently inactive, Playback is stopped. If idle mode ( ) is enabled, the player will enter idle mode, otherwise it will exit. This command is similar to in that it only manipulates the state of what to play next, without waiting until the current file is unloaded, and the next one is loaded. Setting or similar properties can have a similar effect to this command. However, it's more explicit, and guarantees that playback is restarted if for example the new playlist entry is the same as the previous one. Load the given file or URL and play it. Technically, this is just a playlist manipulation command (which either replaces the playlist or adds an entry to it). Actual file loading happens independently. For example, a command that replaces the current file with a new one returns before the current file is stopped, and the new file even begins loading. Stop playback of the current file, and play the new file immediately. Append the file to the playlist. Append the file, and if nothing is currently playing, start playback. (Always starts with the added file, even if the playlist was not empty before running this command.) Insert the file into the playlist, directly after the current entry. Insert the file next, and if nothing is currently playing, start playback. (Always starts with the added file, even if the playlist was not empty before running this command.) Insert the file into the playlist, at the index given in the third argument. Insert the file at the index given in the third argument, and if nothing is currently playing, start playback. (Always starts with the added file, even if the playlist was not empty before running this command.) The third argument is an insertion index, used only by the and actions. When used with those actions, the new item will be inserted at the index position in the playlist, or appended to the end if index is less than 0 or greater than the size of the playlist. This argument will be ignored for all other actions. This argument is added in mpv 0.38.0. The fourth argument is a list of options and values which should be set while the file is playing. It is of the form . When using the client API, this can be a (or a Lua table), however the values themselves must be strings currently. These options are set during playback, and restored to the previous value at end of playback (see Per-File Options). Since mpv 0.38.0, an insertion index argument is added as the third argument. This breaks all existing uses of this command which make use of the argument to include the list of options to be set while the file is playing. To address this problem, the third argument now needs to be set to -1 if the fourth argument needs to be used. Load the given playlist file or URL (like ). Stop playback and replace the internal playlist with the new one. Append the new playlist at the end of the current internal playlist. Append the new playlist, and if nothing is currently playing, start playback. (Always starts with the new playlist, even if the internal playlist was not empty before running this command.) Insert the new playlist into the current internal playlist, directly after the current entry. Insert the new playlist, and if nothing is currently playing, start playback. (Always starts with the new playlist, even if the internal playlist was not empty before running this command.) Insert the new playlist at the index given in the third argument. Insert the new playlist at the index given in the third argument, and if nothing is currently playing, start playback. (Always starts with the new playlist, even if the internal playlist was not empty before running this command.) The third argument is an insertion index, used only by the and actions. When used with those actions, the new playlist will be inserted at the index position in the internal playlist, or appended to the end if index is less than 0 or greater than the size of the internal playlist. This argument will be ignored for all other actions. Clear the playlist, except the currently played file. Remove the playlist entry at the given index. Index values start counting with 0. The special value removes the current entry. Note that removing the current entry also stops playback and starts playing the next entry. Move the playlist entry at index1, so that it takes the place of the entry index2. (Paradoxically, the moved playlist entry will not have the index value index2 after moving if index1 was lower than index2, because index2 refers to the target entry, not the index the entry will have after moving.) Shuffle the playlist. This is similar to what is done on start if the option is used. Attempt to revert the previous command. This works only once (multiple successive commands do nothing). May not work correctly if new recursive playlists have been opened since a command. Load the given subtitle file or stream. By default, it is selected as current subtitle after loading. The argument is one of the following values: Don't select the subtitle. (Or in some special situations, let the default stream selection mechanism decide.) Select the subtitle. If a subtitle with the same filename was already added, that one is selected, instead of loading a duplicate entry. (In this case, title/language are ignored, and if the was changed since it was loaded, these changes won't be reflected.) Additionally the following flags can be added with a : Marks the track as suitable for the hearing impaired. Marks the track as suitable for the visually impaired. Marks the track as an attached picture, same as argument for . The argument sets the track title in the UI. The argument sets the track language, and can also influence stream selection with set to . Remove the given subtitle track. If the argument is missing, remove the current track. (Works on external subtitle files only.) Reload the given subtitle tracks. If the argument is missing, reload the current track. (Works on external subtitle files only.) This works by unloading and re-adding the subtitle track. Change subtitle timing such, that the subtitle event after the next subtitle events is displayed. can be negative to step backwards. Load the given audio file. See command. Remove the given audio track. See command. Reload the given audio tracks. See command. Load the given video file. See command for common options. If enabled, mpv will load the given video as album art. Remove the given video track. See command. Reload the given video tracks. See command. Rescan external files according to the current , and settings. This can be used to auto-load external files after the file was loaded. The argument is one of the following: Select the default audio and subtitle streams, which typically selects external files with the highest preference. (The implementation is not perfect, and could be improved on request.) Print text to stdout. The string can contain properties (see Property Expansion). Take care to put the argument in quotes. Property-expand the argument and return the expanded string. This can be used only through the client API or from a script using . (see Property Expansion). Expand a path's double-tilde placeholders into a platform-specific path. As , this can only be used through the client API or from a script using . This line of Lua would show the location of the user's mpv configuration directory on the OSD. Return a canonical representation of the path by converting it to an absolute path, removing consecutive slashes, removing components, resolving components, and converting slashes to backslashes on Windows. Symlinks are not resolved unless the platform is Unix-like and one of the path components is . If is a URL, it is returned unchanged. This can only be used through the client API or from a script using . This line of Lua prints \"/foo/bar\" on the OSD. Modify so that commands and functions that interpret ASS tags, such as and , will display it verbatim, and return it. This can only be used through the client API or from a script using . This line of Lua prints \"foo \\{bar}\" on the OSD. Apply the contents of a named profile. This is like using in a config file, except you can map it to a key binding to change it at runtime. Apply the profile. Default if the argument is omitted. Restore options set by a previous command for this profile. Only works if the profile has set to a relevant mode. Prints a warning if nothing could be done. See Runtime profiles for details. Load a configuration file, similar to the option. If the file was already included, its previous options are not reset before it is reparsed. Write the resume config file that the command writes, but continue playback normally. Delete any existing resume config file that was written by or . If a filename is specified, then the deleted config is for that file; otherwise, it is the same one as would be written by or in the current circumstance. Show text on the OSD. The string can contain properties, which are expanded as described in Property Expansion. This can be used to show playback time, filename, and so on. has no effect on this command. The time in ms to show the message for. By default, it uses the same value as . The minimum OSD level to show the text at (see ). Show the progress bar, the elapsed time and the total duration of the file on the OSD. has no effect on this command. Add an OSD overlay sourced from raw data. This might be useful for scripts and applications controlling mpv, and which want to display things on top of the video window. Overlays are usually displayed in screen resolution, but with some VOs, the resolution is reduced to that of the video's. You can read the and properties. At least with and anamorphic video (such as DVD), should be read as well, and the overlay should be aspect-compensated. This has the following named arguments. The order of them is not guaranteed, so you should always call them with named arguments, see Named arguments. is an integer between 0 and 63 identifying the overlay element. The ID can be used to add multiple overlay parts, update a part by using this command with an already existing ID, or to remove a part with . Using a previously unused ID will add a new overlay, while reusing an ID will update it. and specify the position where the OSD should be displayed. specifies the file the raw image data is read from. It can be either a numeric UNIX file descriptor prefixed with (e.g. ), or a filename. The file will be mapped into memory with , copied, and unmapped before the command returns (changed in mpv 0.18.1). It is also possible to pass a raw memory address for use as bitmap memory by passing a memory address as integer prefixed with an character. Passing the wrong thing here will crash the player. This mode might be useful for use with libmpv. The parameter is simply added to the memory address (since mpv 0.8.0, ignored before). is the byte offset of the first pixel in the source file. (The current implementation always mmap's the whole file from position 0 to the end of the image, so large offsets should be avoided. Before mpv 0.8.0, the offset was actually passed directly to , but it was changed to make using it easier.) is a string identifying the image format. Currently, only is defined. This format has 4 bytes per pixels, with 8 bits per component. The least significant 8 bits are blue, and the most significant 8 bits are alpha (in little endian, the components are B-G-R-A, with B as first byte). This uses premultiplied alpha: every color component is already multiplied with the alpha component. This means the numeric value of each component is equal to or smaller than the alpha component. (Violating this rule will lead to different results with different VOs: numeric overflows resulting from blending broken alpha values is considered something that shouldn't happen, and consequently implementations don't ensure that you get predictable behavior in this case.) , , and specify the size of the overlay. is the visible width of the overlay, while gives the width in bytes in memory. In the simple case, and with the format, . In general, the total amount of memory accessed is . (Technically, the minimum size would be , but for simplicity, the player will access all bytes.) and specify the (optional) display size of the overlay. The overlay visible portion of the overlay ( and ) is scaled to in display to and . If parameters are not present, the values for and are used. Before mpv 0.18.1, you had to do manual \"double buffering\" when updating an overlay by replacing it with a different memory buffer. Since mpv 0.18.1, the memory is simply copied and doesn't reference any of the memory indicated by the command's arguments after the command returns. If you want to use this command before mpv 0.18.1, reads the old docs to see how to handle this correctly. Remove an overlay added with and the same ID. Does nothing if no overlay with this ID exists. You can use this to add text overlays in ASS format. ASS has advanced positioning and rendering tags, which can be used to render almost any kind of vector graphics. This command accepts the following parameters: Arbitrary integer that identifies the overlay. Multiple overlays can be added by calling this command with different parameters. Calling this command with the same replaces the previously set overlay. There is a separate namespace for each libmpv client (i.e. IPC connection, script), so IDs can be made up and assigned by the API user without conflicting with other API users. If the libmpv client is destroyed, all overlays associated with it are also deleted. In particular, connecting via , adding an overlay, and disconnecting will remove the overlay immediately again. String that gives the type of the overlay. Accepts the following values (HTML rendering of this is broken, view the generated manpage instead, or the raw RST source): The parameter is a string. The string is split on the newline character. Every line is turned into the part of a ASS event. Timing is unused (but behavior of timing dependent ASS tags may change in future mpv versions). Note that it's better to put multiple lines into , instead of adding multiple OSD overlays. This provides 2 ASS . contains the text style as defined by the current options. is similar, and contains style that would have if all options were set to the default. In addition, the and options specify the value of the ASS and header fields. If is set to 0, is initialized to an arbitrary default value (but note that the default for this command is 720, not 0). If is set to 0, is set based on such that a virtual ASS pixel has a square pixel aspect ratio. Special value that causes the overlay to be removed. Most parameters other than and are mostly ignored. String defining the overlay contents according to the parameter. Used if is set to (see description there). Optional, defaults to 0/720. The Z order of the overlay. Optional, defaults to 0. Note that Z order between different overlays of different formats is static, and cannot be changed (currently, this means that bitmap overlays added by are always on top of the ASS overlays added by ). In addition, the builtin OSD components are always below any of the custom OSD. (This includes subtitles of any kind as well as text rendered by .) It's possible that future mpv versions will randomly change how Z order between different OSD formats and builtin OSD is handled. If set to true, do not display this (default: false). If set to true, attempt to determine bounds and write them to the command's result value as , , , rectangle (default: false). If the rectangle is empty, not known, or somehow degenerate, it is not set. / is the coordinate of the bottom exclusive corner of the rectangle. The result value may depend on the VO window size, and is based on the last known window size at the time of the call. This means the results may be different from what is actually rendered. For , the result rectangle is recomputed to coordinates ( / ). If window size is not known, a fallback is chosen. You should be aware that this mechanism is very inefficient, as it renders the full result, and then uses the bounding box of the rendered bitmap list (even if is set). It will flush various caches. Its results also depend on the used libass version. This feature is experimental, and may change in some way again. Always use named arguments ( ). Lua scripts should use the helper instead of invoking this command directly. The button number of clicked mouse button. This should be one of 0-19. If is omitted, only the position will be updated. Send a key event through mpv's input handler, triggering whatever behavior is configured to that key. uses the naming scheme for keys and modifiers. is used to scale numerical change effected by the bound command (same mechanism as precise scrolling). Useful for the client API: key events can be sent to libmpv to handle internally. Similar to , but sets the flag so that if the key is bound to a repeatable command, it will be run repeatedly with mpv's key repeat timing until the command is called. Set the flag, stopping any repeated behavior that had been triggered. is optional. If is not given or is an empty string, will be set on all keys. Otherwise, will only be set on the key specified by . Binds a key to an input command. must be a complete command containing all the desired arguments and flags. Both and use the naming scheme. is an optional string which can be read as the entry of . This is primarily useful for the client API. This command is deprecated, except for mpv-internal uses. Enable all key bindings in the named input section. The enabled input sections form a stack. Bindings in sections on the top of the stack are preferred to lower sections. This command puts the section on top of the stack. If the section was already on the stack, it is implicitly removed beforehand. (A section cannot be on the stack more than once.) The parameter can be a combination (separated by ) of the following flags: All sections enabled before the newly enabled section are disabled. They will be re-enabled as soon as all exclusive sections above them are removed. In other words, the new section shadows all previous sections. This feature can't be used through the public API. This command is deprecated, except for mpv-internal uses. This command is deprecated, except for mpv-internal uses. Create a named input section, or replace the contents of an already existing input section. The parameter uses the same syntax as the file (except that using the section syntax in it is not allowed), including the need to separate bindings with a newline character. If the parameter is an empty string, the section is removed. The section with the name is the normal input section. In general, input sections have to be enabled with the command, or they are ignored. The last parameter has the following meaning: <default> (also used if parameter omitted) Use a key binding defined by this section only if the user hasn't already bound this key to a command. Always bind a key. (The input section that was made active most recently wins if there are ambiguities.) This command can be used to dispatch arbitrary keys to a script or a client API user. If the input section defines commands, it is also possible to get separate events on key up/down, and relatively detailed information about the key state. The special key name can be used to match any unmapped key. Load an input configuration file, similar to the option. If the file was already included, its previous bindings are not reset before it is reparsed. Run the given command. Unlike in MPlayer/mplayer2 and earlier versions of mpv (0.2.x and older), this doesn't call the shell. Instead, the command is run directly, with each argument passed separately. Each argument is expanded like in Property Expansion. This command has a variable number of arguments, and cannot be used with named arguments. The program is run in a detached way. mpv doesn't wait until the command is completed, but continues playback right after spawning it. To get the old behavior, use and as the first two arguments. This is not a particularly good example, because it doesn't handle escaping, and a specially prepared file might allow an attacker to execute arbitrary shell commands. It is recommended to write a small shell script, and call that with . Similar to , but gives more control about process execution to the caller, and does not detach the process. You can avoid blocking until the process terminates by running this command asynchronously. (For example in Lua scripting.) This has the following named arguments. The order of them is not guaranteed, so you should always call them with named arguments, see Named arguments. Array of strings with the command as first argument, and subsequent command line arguments following. This is just like the command argument list. The first array entry is either an absolute path to the executable, or a filename with no path components, in which case the executable is searched in the directories in the environment variable. On Unix, this is equivalent to and behavior. Boolean indicating whether the process should be killed when playback of the current playlist entry terminates (optional, default: true). If enabled, stopping playback will automatically kill the process, and you can't start it outside of playback. Integer setting the maximum number of stdout plus stderr bytes that can be captured (optional, default: 64MB). If the number of bytes exceeds this, capturing is stopped. The limit is per captured stream. Capture all data the process outputs to stdout and return it once the process ends (optional, default: no). Same as , but for stderr. Whether to run the process in detached mode (optional, default: no). In this mode, the process is run in a new process session, and the command does not wait for the process to terminate. If neither nor have been set to true, the command returns immediately after the new process has been started, otherwise the command will read as long as the pipes are open. Set a list of environment variables for the new process (default: empty). If an empty list is passed, the environment of the mpv process is used instead. (Unlike the underlying OS mechanisms, the mpv command cannot start a process with empty environment. Fortunately, that is completely useless.) The format of the list is as in the syscall. Each string item defines an environment variable as in . On Lua, you may use to retrieve the current environment if you e.g. simply want to add a new variable. Feed the given string to the new process' stdin. Since this is a string, you cannot pass arbitrary binary data. If the process terminates or closes the pipe before all data is written, the remaining data is silently discarded. Probably does not work on win32. If enabled, wire the new process' stdin to mpv's stdin (default: no). Before mpv 0.33.0, this argument did not exist, but the behavior was as if this was set to true. The command returns the following result (as ): Typically this is the process exit code (0 or positive) if the process terminates normally, or negative for other errors (failed to start, terminated by mpv, and others). The meaning of negative values is undefined, other than meaning error (and does not correspond to OS low level exit status values). On Windows, it can happen that a negative return value is returned even if the process terminates normally, because the win32 exit code is assigned to an variable before being set as field in the result map. This might be fixed later. Same as , but for stderr. Empty string if the process terminated normally. The string if the process was terminated in an unusual way. The string if the process could not be started. On Windows, is only returned when the process has been killed by mpv as a result of being set to true. Whether the process has been killed by mpv, for example as a result of being set to true, aborting the command (e.g. by ), or if the player is about to exit. Note that the command itself will always return success as long as the parameters are correct. Whether the process could be spawned or whether it was somehow killed or returned an error status has to be queried from the result value. This command can be asynchronously aborted via API. Also see Asynchronous command details. Only the command can start processes in a truly detached way. The subprocess will always be terminated on player exit if it wasn't started in detached mode, even if is false. Don't forget to set the field to false if you want the command to run while the player is in idle mode, or if you don't want the end of playback to kill the command. local r = mp.command_native({ name = \"subprocess\", playback_only = false, capture_stdout = true, args = {\"cat\", \"/proc/cpuinfo\"}, }) if r.status == 0 then print(\"result: \" .. r.stdout) end This is a fairly useless Lua example, which demonstrates how to run a process in a blocking manner, and retrieving its stdout output. Exit the player. If an argument is given, it's used as process exit code. Exit player, and store current playback position. Playing that file later will seek to the previous position on start. The (optional) argument is exactly as in the command. See RESUMING PLAYBACK. Send a message to all clients, and pass it the following list of arguments. What this message means, how many arguments it takes, and what the arguments mean is fully up to the receiver and the sender. Every client receives the message, so be careful about name clashes (or use ). This command has a variable number of arguments, and cannot be used with named arguments. Same as , but send it only to the client named . Each client (scripts etc.) has a unique name. For example, Lua scripts can get their name via . Note that client names only consist of alphanumeric characters and . This command has a variable number of arguments, and cannot be used with named arguments. Invoke a script-provided key binding. This can be used to remap key bindings provided by external Lua scripts. is the name of the binding. is a user-provided arbitrary string which can be used to provide extra information. It can optionally be prefixed with the name of the script, using as separator, e.g. . Note that script names only consist of alphanumeric characters and . For completeness, here is how this command works internally. The details could change any time. On any matching key event, or is called (depending on whether the script name is included), with the following arguments in string format:\n• The name of the binding (as established above).\n• The key state as string (see below).\n• The key name (since mpv 0.15.0).\n• The text the key would produce, or empty string if not applicable.\n• The scale of the key, such as the ones produced by keys. The scale is 1 if the key is nonscalable.\n• The user-provided string , or empty string if the argument is not used. The 5th argument is only set if no modifiers are present (using the shift key with a letter is normally not emitted as having a modifier, and results in upper case text instead, but some backends may mess up).\n• One of (key was pressed down), (was released), (key is still down, and was repeated; only if key repeat is enabled for this binding), (key was pressed; happens if up/down can't be tracked).\n• Whether the event originates from the mouse, either (mouse button) or (something else).\n• Whether the event results from a cancellation (e.g. the key is logically released but not physically released), either (canceled) or (something else). Not all types of cancellations set this flag. Future versions can add more arguments and more key state characters to support more input peculiarities. This is a scalable command. See the documentation of input command prefix in Input Command Prefixes for details. Load a script, similar to the option. Whether this waits for the script to finish initialization or not changed multiple times, and the future behavior is left undefined. On success, returns a with a field set to the return value of the API call of the newly created script handle. Multiple flags are available (some can be combined with ): Save the video image, in its original resolution, and with subtitles. Some video outputs may still include the OSD in the output under certain circumstances. Like , but typically without OSD or subtitles. The exact behavior depends on the selected video output. Save the contents of the mpv window. Typically scaled, with OSD and subtitles. The exact behavior depends on the selected video output. Take a screenshot each frame. Issue this command again to stop taking screenshots. Note that you should disable frame-dropping when using this mode - or you might receive duplicate images in cases when a frame was dropped. This flag can be combined with the other flags, e.g. . Older mpv versions required passing and as second argument (and did not have flags). This syntax is still understood, but deprecated and might be removed in the future. If you combine this command with another one using , you can use the flag to make encoding/writing the image file asynchronous. For normal standalone commands, this is always asynchronous, and the flag has no effect. (This behavior changed with mpv 0.29.0.) On success, returns a with a field set to the saved screenshot location. Take a screenshot and save it to a given file. The format of the file will be guessed by the extension (and is ignored - the behavior when the extension is missing or unknown is arbitrary). The second argument is like the first argument to and supports , , . If the file already exists, it's overwritten. Like all input command parameters, the filename is subject to property expansion as described in Property Expansion. Return a screenshot in memory. This can be used only through the client API. The MPV_FORMAT_NODE_MAP returned by this command has the , , fields set to obvious contents. The field is set to the format of the screenshot image data. This can be controlled by the argument. The format can be one of the following: This format is organized as (where is the LSB). The contents of the padding are undefined. This format is organized as (where is the LSB). This format is organized as (where is the LSB). This format is organized as (where is the LSB). Each component occupies 2 bytes per pixel. When this format is used, the image data will be high bit depth, and is ignored. The field is of type MPV_FORMAT_BYTE_ARRAY with the actual image data. The image is freed as soon as the result mpv_node is freed. As usual with client API semantics, you are not allowed to write to the image data. The is the number of bytes from a pixel at to the pixel at . This can be larger than if the image was cropped, or if there is padding. This number can be negative as well. You access a pixel with . Here, is the number of bytes per pixel, which is 8 for format and 4 for other formats. The argument is like the first argument to and supports , , . The semantics are exactly the same as with option parsing (see VIDEO FILTERS). As such the text below is a redundant and incomplete summary. The first argument decides what happens: Overwrite the previous filter chain with the new one. Append the new filter chain to the previous one. Check if the given filter (with the exact parameters) is already in the video chain. If it is, remove the filter. If it isn't, add the filter. (If several filters are passed to the command, this is done for each filter.) A special variant is combining this with labels, and using without filter name and parameters as filter entry. This toggles the enable/disable flag. Like , but always remove the given filter from the chain. Remove all filters. Note that like the other sub-commands, this does not control automatically inserted filters. The argument is always needed. E.g. in case of use . You can assign labels to filter by prefixing them with (where is a user-chosen arbitrary identifier). Labels can be used to refer to filters by name in all of the filter chain modification commands. For , using an already used label will replace the existing filter. The command shows the list of requested filters on the OSD after changing the filter chain. This is roughly equivalent to . Note that auto-inserted filters for format conversion are not shown on the list, only what was requested by the user. Normally, the commands will check whether the video chain is recreated successfully, and will undo the operation on failure. If the command is run before video is configured (can happen if the command is run immediately after opening a file and before a video frame is decoded), this check can't be run. Then it can happen that creating the video chain fails.\n• turn the video upside-down on the key Example how to toggle disabled filters at runtime\n• Add something like to . The is the label, an arbitrary, user-given name for this filter entry. The before the filter name disables the filter by default. Everything after this is the normal filter name and possibly filter parameters, like in the normal syntax.\n• Add to . This toggles the \"disabled\" flag for the filter with the label when the key is hit. Send a command to the filter. Note that currently, this only works with the filter. Refer to the libavfilter documentation for the list of supported commands for each filter. is a mpv filter label, use to send it to all filters at once. is a filter or filter instance name and defaults to . Note that the target is an additional specifier for filters that support them, such as complex filter chains. Same as , but for audio filters. Use this to \"block\" keys that should be unbound, and do nothing. Useful for disabling default bindings, without disabling all bindings with . Drop audio/video/demuxer buffers, and restart from fresh. Might help with unseekable streams that are going out of sync. This command might be changed or removed in the future. Dump the current cache to the given filename. The file is overwritten if it already exists. and give the time range of what to dump. If no data is cached at the given time range, nothing may be dumped (creating a file with no packets). Dumping a larger part of the cache will freeze the player. No effort was made to fix this, as this feature was meant mostly for creating small excerpts. See for various caveats that mostly apply to this command too, as both use the same underlying code for writing the output file. If is an empty string, an ongoing is stopped. If is , then continuous dumping is enabled. Then, after dumping the existing parts of the cache, anything read from network is appended to the cache as well. This behaves similar to (although it does not conflict with that option, and they can be both active at the same time). If the time is after the cache, the command will _not_ wait and write newly received data to it. The end of the resulting file may be slightly damaged or incomplete at the end. (Not enough effort was made to ensure that the end lines up properly.) Note that this command will finish only once dumping ends. That means it works similar to the command, just that it can block much longer. If continuous dumping is used, the command will not finish until playback is stopped, an error happens, another command is run, or an API like was called to explicitly stop the command. See Synchronous vs. Asynchronous. This was mostly created for network streams. For local files, there may be much better methods to create excerpts and such. There are tons of much more user-friendly Lua scripts, that will re-encode parts of a file by spawning a separate instance of . With network streams, this is not that easily possible, as the stream would have to be downloaded again. Even if is used to record the stream to the local filesystem, there may be problems, because the recorded file is still written to. This command is experimental, and all details about it may change in the future. Cycle through A-B loop states. The first command will set the point (the property); the second the point, and the third will clear both points. Essentially calls with the current AB-loop points as arguments. Like , this will overwrite the file at . Likewise, if the B point is set to , it will enter continuous dumping after the existing cache was dumped. The author reserves the right to remove this command if enough motivation is found to move this functionality to a trivial Lua script. Re-adjust the A/B loop points to the start and end within the cache the command will (probably) dump. Basically, it aligns the times on keyframes. The guess might be off especially at the end (due to granularity issues due to remuxing). If the cache shrinks in the meantime, the points set by the command will not be the effective parameters either. This command has an even more uncertain future than and might disappear without replacement if the author decides it's useless. Begin window dragging if supported by the current VO. This command should only be called while a mouse button is being pressed, otherwise it will be ignored. The exact effect of this command depends on the VO implementation of window dragging. For example, on Windows and macOS only the left mouse button can begin window dragging, while X11 and Wayland allow other mouse buttons. Show context menu on the video window. See Context Menu section for details. This is a partial list of events. This section describes what returns, and which is what scripting APIs and the JSON IPC sees. Note that the C API has separate C-level declarations with , which may be slightly different. Note that events are asynchronous: the player core continues running while events are delivered to scripts and other clients. In some cases, you can use hooks to enforce synchronous execution. All events can have the following fields: Name as the event (as returned by ). The field (opaque user value). If is 0, the field is not added. Set to an error string (as returned by ). This field is missing if no error happened, or the event type does not report error. Most events leave this unset. This list uses the event name field value, and the C API symbol in brackets: Happens right before a new file is loaded. When you receive this, the player is loading the file (or possibly already done with it). This has the following fields: Playlist entry ID of the file being loaded now. Happens after a file was unloaded. Typically, the player will load the next file right away, or quit if this was the last file. The event has the following fields: The file has ended. This can (but doesn't have to) include incomplete files or broken network connections under circumstances. Playback was ended by sending the quit command. An error happened. In this case, an field is present with the error string. Happens with playlists and similar. Details see in the C API. Unknown. Normally doesn't happen, unless the Lua API is out of sync with the C API. (Likewise, it could happen that your script gets reason strings that did not exist yet at the time your script was written.) Playlist entry ID of the file that was being played or attempted to be played. This has the same value as the field in the corresponding event. Set to mpv error string describing the approximate reason why playback failed. Unset if no error known. (In Lua scripting, this value was set on the field directly. This is deprecated since mpv 0.33.0. In the future, this field will be unset for this specific event.) If loading ended, because the playlist entry to be played was for example a playlist, and the current playlist entry is replaced with a number of other entries. This may happen at least with MPV_END_FILE_REASON_REDIRECT (other event types may use this for similar but different purposes in the future). In this case, playlist_insert_id will be set to the playlist entry ID of the first inserted entry, and playlist_insert_num_entries to the total number of inserted playlist entries. Note this in this specific case, the ID of the last inserted entry is playlist_insert_id+num-1. Beware that depending on circumstances, you may observe the new playlist entries before seeing the event (e.g. reading the \"playlist\" property or getting a property change notification before receiving the event). If this is 0 in the C API, this field isn't added. See playlist_insert_id. Only present if playlist_insert_id is present. Happens after a file was loaded and begins playback. Happens on seeking. (This might include cases when the player seeks internally, even without user interaction. This includes e.g. segment changes when playing ordered chapters Matroska files.) Start of playback after seek or after file was loaded. Sent when the player quits, and the script should terminate. Normally handled automatically. See Details on the script initialization and lifecycle. This contains, in addition to the default event fields, the following fields: The module prefix, identifies the sender of the message. This is what the terminal player puts in front of the message text when using the option, and is also what is used for . The log level as string. See for possible log level names. Note that later versions of mpv might add new levels or remove (undocumented) existing ones. The log message. The text will end with a newline character. Sometimes it can contain multiple lines. Keep in mind that these messages are meant to be hints for humans. You should not parse them, and prefix/level/text of messages might change any time. The event has the following fields: ID to pass to . The Lua scripting wrapper provides a better API around this with . This is one of the commands for which the field is meaningful. JSON IPC and Lua and possibly other backends treat this specially and may not pass the actual event to the user. See C API. The event has the following fields: The result (on success) of any type, if any. Lua and possibly other backends treat this specially and may not pass the actual event to the user. The event has the following fields: Array of strings with the message data. Happens on video output or filter reconfig. Happens on audio output or filter reconfig. Happens when a property that is being observed changes value. The event has the following fields: The name of the property. The new value of the property. The following events also happen, but are deprecated: , Use (Lua: ) instead. Hooks are synchronous events between player core and a script or similar. This applies to client API (including the Lua scripting interface). Normally, events are supposed to be asynchronous, and the hook API provides an awkward and obscure way to handle events that require stricter coordination. There are no API stability guarantees made. Not following the protocol exactly can make the player freeze randomly. Basically, nobody should use this API. The C API is described in the header files. The Lua API is described in the Lua section. Before a hook is actually invoked on an API clients, it will attempt to return new values for all observed properties that were changed before the hook. This may make it easier for an application to set defined \"barriers\" between property change notifications by registering hooks. (That means these hooks will have an effect, even if you do nothing and make them continue immediately.) The following hooks are currently defined: Called when a file is to be opened, before anything is actually done. For example, you could read and write the property to redirect an URL to something else (consider support for streaming sites which rarely give the user a direct media URL), or you could set per-file options with by setting the property . The player will wait until all hooks are run. Ordered after and before . Called after after a file has been opened, but failed to. This can be used to provide a fallback in case native demuxers failed to recognize the file, instead of always running before the native demuxers like . Demux will only be retried if was changed. If it fails again, this hook is _not_ called again, and loading definitely fails. Ordered after , and before and . Called after a file has been opened, and before tracks are selected and decoders are created. This has some usefulness if an API users wants to select tracks manually, based on the set of available tracks. It's also useful to initialize in a specific way by API, without having to \"probe\" the available streams at first. Note that this does not yet apply default track selection. Which operations exactly can be done and not be done, and what information is available and what is not yet available yet, is all subject to change. Ordered after etc. and before . Run before closing a file, and before actually uninitializing everything. It's not possible to resume playback in this state. Ordered before . Will also happen in the error case (then after ). Run before a event is sent. (If any client changes the current playlist entry, or sends a quit command to the player, the corresponding event will not actually happen after the hook returns.) Useful to drain property changes before a new file is loaded. Run after an event. Useful to drain property changes after a file has finished. These prefixes are placed between key name and the actual command. Multiple prefixes can be specified. They are separated by whitespace. Use the default behavior for this command. This is the default for commands. Some libmpv/scripting/IPC APIs do not use this as default, but use instead. Do not use any OSD for this command. If possible, show a bar with this command. Seek commands will show the progress bar, property changing commands may show the newly set value. If possible, show an OSD message with this command. Seek command show the current playback time, property changing commands show the newly set value as text. Do not expand properties in string arguments. (Like .) This is the default for some libmpv/scripting/IPC APIs. All string arguments are expanded as described in Property Expansion. This is the default for commands. For some commands, keeping a key pressed doesn't run the command repeatedly. This prefix forces enabling key repeat in any case. For a list of commands: the first command determines the repeatability of the whole list (up to and including version 0.33 - a list was always repeatable). For some commands, keeping a key pressed runs the command repeatedly. This prefix forces disabling key repeat in any case. When some commands (e.g. ) are bound to scalable keys associated to a high-precision input device like a touchpad (e.g. ), the value specified in the command is scaled to smaller steps based on the high resolution input data if available. This prefix forces disabling this behavior, so the value is always changed in the discrete unit specified in the key binding. Allow asynchronous execution (if possible). Note that only a few commands will support this (usually this is explicitly documented). Some commands are asynchronous by default (or rather, their effects might manifest after completion of the command). The semantics of this flag might change in the future. Set it only if you don't rely on the effects of this command being fully realized when it returns. See Synchronous vs. Asynchronous. Allow synchronous execution (if possible). Normally, all commands are synchronous by default, but some are asynchronous by default for compatibility with older behavior. All of the osd prefixes are still overridden by the global settings. The and prefix matter only for how the issuer of the command waits on the completion of the command. Normally it does not affect how the command behaves by itself. There are the following cases:\n• Normal input.conf commands are always run asynchronously. Slow running commands are queued up or run in parallel.\n• \"Multi\" input.conf commands (1 key binding, concatenated with ) will be executed in order, except for commands that are async (either prefixed with , or async by default for some commands). The async commands are run in a detached manner, possibly in parallel to the remaining sync commands in the list.\n• Normal Lua and libmpv commands (e.g. ) are run in a blocking manner, unless the prefix is used, or the command is async by default. This means in the sync case the caller will block, even if the core continues playback. Async mode runs the command in a detached manner.\n• Async libmpv command API (e.g. ) never blocks the caller, and always notify their completion with a message. The and prefixes make no difference.\n• Lua also provides APIs for running async commands, which behave similar to the C counterparts.\n• In all cases, async mode can still run commands in a synchronous manner, even in detached mode. This can for example happen in cases when a command does not have an asynchronous implementation. The async libmpv API still never blocks the caller in these cases. Before mpv 0.29.0, the prefix was only used by screenshot commands, and made them run the file saving code in a detached manner. This is the default now, and changes behavior only in the ways mentioned above. Currently the following commands have different waiting characteristics with sync vs. async: sub-add, audio-add, sub-reload, audio-reload, rescan-external-files, screenshot, screenshot-to-file, dump-cache, ab-loop-dump-cache. On the API level, every asynchronous command is bound to the context which started it. For example, an asynchronous command started by is bound to the passed to the function. Only this receives the completion notification ( ), and only this handle can abort a still running command directly. If the is destroyed, any still running async. commands started by it are terminated. The scripting APIs and JSON IPC give each script/connection its own implicit . If the player is closed, the core may abort all pending async. commands on its own (like a forced call for each pending command on behalf of the API user). This happens at the same time is sent, and there is no way to prevent this. Input sections group a set of bindings, and enable or disable them at once. In , each key binding is assigned to an input section, rather than actually having explicit text sections. See also: and commands. Bindings without input section are implicitly assigned to this section. It is enabled by default during normal playback. Section which is active in encoding mode. It is enabled exclusively, so that bindings in the sections are ignored. Properties are used to set mpv options during runtime, or to query arbitrary information. They can be manipulated with the / / commands, and retrieved with , or anything else that uses property expansion. (See Property Expansion.) If an option is referenced, the property will normally take/return exactly the same values as the option. In these cases, properties are merely a way to change an option at runtime. Note that many properties are unavailable at startup. See Details on the script initialization and lifecycle. Most options can be set at runtime via properties as well. Just remove the leading from the option name. These are not documented below, see OPTIONS instead. Only properties which do not exist as option with the same name, or which have very different behavior from the options are documented below. Properties marked as (RW) are writeable, while those that aren't are read-only. Factor multiplied with at which the player attempts to play the file. Usually it's exactly 1. (Display sync mode will make this useful.) OSD formatting will display it in the form of , with the number being for the given raw property value. Whether is actually active. Currently played file, with path stripped. If this is an URL, try to undo percent encoding as well. (The result is not necessarily correct, but looks better for display purposes. Use the property to get an unmodified filename.) Like the property, but if the text contains a , strip all text after the last . Usually this removes the file extension. Length in bytes of the source file/stream. (This is the same as . For segmented/multi-part files, this will return the size of the main or manifest file, whatever it is.) This is only an estimate. (It's computed from two unreliable quantities: fps and stream length.) This is only an estimate. (It's computed from two unreliable quantities: fps and possibly rounded timestamps.) Full absolute path of the currently played file. The full path to the currently played media. This is different from only in special cases. In particular, if is used, and the URL is detected by , then the script will set this property to the actual media URL. This property should be set only during the or hooks, otherwise it will have no effect (or may do something implementation defined in the future). The property is reset if playback of the current media ends. If the currently played file has a tag, use that. Symbolic name of the file format. In some cases, this is a comma-separated list of format names, e.g. mp4 is (the list may grow in the future for any format). Name of the current demuxer. (This is useless.) Filename (full path) of the stream layer filename. (This is probably useless and is almost never different from .) Raw byte position in source stream. Technically, this returns the position of the most recent packet passed to a decoder. Duration of the current file in seconds. If the duration is unknown, the property is unavailable. Note that the file duration is not always exactly known, so this is an estimate. This replaces the property, which was deprecated after the mpv 0.9 release. (The semantics are the same.) Last A/V synchronization difference. Unavailable if audio or video is disabled. Total A-V sync correction done. Unavailable if audio or video is disabled. Video frames dropped by decoder, because video is too far behind audio (when using ). Sometimes, this may be incremented in other situations, e.g. when video packets are damaged, or the decoder doesn't follow the usual rules. Unavailable if video is disabled. Frames dropped by VO (when using ). Number of video frames that were not timed correctly in display-sync mode for the sake of keeping A/V sync. This does not include external circumstances, such as video rendering being too slow or the graphics driver somehow skipping a vsync. It does not include rounding errors either (which can happen especially with bad source timestamps). For example, using the mode should never change this value from 0. For how many vsyncs a frame is displayed on average. This is available if display-sync is active only. For 30 FPS video on a 60 Hz screen, this will be 2. This is the moving average of what actually has been scheduled, so 24 FPS on 60 Hz will never remain exactly on 2.5, but jitter depending on the last frame displayed. Estimated number of frames delayed due to external circumstances in display-sync mode. Note that in general, mpv has to guess that this is happening, and the guess can be inaccurate. Position in current file (0-100). The advantage over using this instead of calculating it out of other properties is that it properly falls back to estimating the playback position from the byte position, if the file duration is not known. Deprecated. Always returns 0. Before mpv 0.14, this used to return the start time of the file (could affect e.g. transport streams). See option. Remaining length of the file in seconds. Note that the file duration is not always exactly known, so this is an estimate. Current audio playback position in current file in seconds. Unlike , this updates more often than once per frame. This is mostly equivalent to for audio-only files however it also takes into account the audio driver delay. This can lead to negative values in certain cases, so in general you probably want to simply use . Prior to mpv 0.39.0, and could report different values in certain edge cases. How many more times the current file is going to be looped. This is initialized from the value of . This counts the number of times it causes the player to seek to the beginning of the file, so it is 0 the last the time is played. -1 corresponds to infinity. How many more times the current A-B loop is going to be looped, if one is active. This is initialized from the value of . This counts the number of times it causes the player to seek to , so it is 0 the last the time the loop is played. -1 corresponds to infinity. Current chapter number. The number of the first chapter is 0. A value of -1 indicates that the current playback position is before the start of the first chapter, Setting this property results in an absolute seek to the start of the chapter. However, if the property is changed with or command which results in a decrement in value, it may go to the start of the current chapter instead of the previous chapter. See for details. Current edition number. Setting this property to a different value will restart playback. The number of the first edition is 0. For Matroska files, this is the edition. For DVD/Blu-ray, this is the title. Before mpv 0.31.0, this showed the actual edition selected at runtime, if you didn't set the option or property manually. With mpv 0.31.0 and later, this strictly returns the user-set option or property value, and the property was added to return the runtime selected edition (this matters with , the default). Currently selected edition. This property is unavailable if no file is loaded, or the file has no editions. (Matroska files make a difference between having no editions and a single edition, which will be reflected by the property, although in practice it does not matter.) This has a number of sub-properties. Replace with the 0-based edition index. Number of editions. If there are no editions, this can be 0 or 1 (1 if there's a useless dummy edition). Edition ID as integer. Currently, this is the same as the edition index. Whether this is the default edition. Edition title as stored in the file. Not always available. When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: If the property is accessed with Lua's , this returns a table with metadata keys mapping to metadata values. If it is accessed with the client API, this returns a , with tag keys mapping to tag values. For OSD, it returns a formatted list. Trying to retrieve this property as a raw string doesn't work. This has a number of sub-properties: Key name of the Nth metadata entry. (The first entry is ). Value of the Nth metadata entry. Old version of . Use is discouraged, because the metadata key string could conflict with other sub-properties. The layout of this property might be subject to change. Suggestions are welcome how exactly this property should work. When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: MPV_FORMAT_NODE_MAP (key and string value for each metadata entry) Like , but includes only fields listed in the option. This is the same set of tags that is printed to the terminal. Metadata of current chapter. Works similar to property. It also allows the same access methods (using sub-properties). Per-chapter metadata is very rare. Usually, only the chapter name ( ) is set. For accessing other information, like chapter start, see the property. Metadata added by video filters. Accessed by the filter label, which, if not explicitly specified using the syntax, will be . Works similar to property. It allows the same access methods (using sub-properties). An example of this kind of metadata are the cropping parameters added by . Equivalent to , but for audio filters. Returns /true if mpv's deinterlacing filter is active. Note that it will not detect any manually inserted deinterlacing filters done via . Returns /true if no file is loaded, but the player is staying around because of the option. Whether the playback core is paused. This can differ from in special situations, such as when the player pauses itself due to low network cache. This also returns /true if playback is restarting or if nothing is playing at all. In other words, it's only /false if there's actually video playing. (Behavior since mpv 0.7.0.) Current I/O read speed between the cache and the lower layer (like network). This gives the number bytes per seconds over a 1 second window (using the type for the client API). This is the same as . Approximate duration of video buffered in the demuxer, in seconds. The guess is very unreliable, and often the property will not be available at all, even if data is buffered. Approximate time of video buffered in the demuxer, in seconds. Same as but returns the last timestamp of buffered data in demuxer. Whether the demuxer is idle, which means that the demuxer cache is filled to the requested amount, and is currently not reading more data. Each entry in represents a region in the demuxer cache that can be seeked to, with a and fields containing the respective timestamps. If there are multiple demuxers active, this only returns information about the \"main\" demuxer, but might be changed in future to return unified information about all demuxers. The ranges are in arbitrary order. Often, ranges will overlap for a bit, before being joined. In broken corner cases, ranges may overlap all over the place. The end of a seek range is usually smaller than the value returned by the property, because that property returns the guessed buffering amount, while the seek ranges represent the buffered data that can actually be used for cached seeking. indicates whether the seek range with the lowest timestamp points to the beginning of the stream (BOF). This implies you cannot seek before this position at all. indicates whether the seek range with the highest timestamp points to the end of the stream (EOF). If both and are true, and there's only 1 cache range, the entire stream is cached. is the number of bytes of packets buffered in the range starting from the current decoding position. This is a rough estimate (may not account correctly for various overhead), and stops at the demuxer position (it ignores seek ranges after it). is the number of bytes stored in the file cache. This includes all overhead, and possibly unused data (like pruned data). This member is missing if the file cache wasn't enabled with . is the approximate timestamp of the start of the buffered range. Missing if unavailable. is the estimated input rate of the network layer (or any other byte-oriented input layer) in bytes per second. May be inaccurate or missing. is an array containing an entry for each stream type: video, audio, and subtitle. For each stream type, the details for the demuxer cache for that stream type are available as , and . When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: Other fields (might be changed or removed in the future): Whether the reader thread has hit the end of the file. Whether the reader thread could not satisfy a decoder's request for a new packet. Whether the thread is currently not reading. Sum of packet bytes (plus some overhead estimation) of the entire packet queue, including cached seekable ranges. Whether the stream demuxed via the main demuxer is most likely played via network. What constitutes \"network\" is not always clear, might be used for other types of untrusted streams, could be wrong in certain cases, and its definition might be changing. Also, external files (like separate audio files or streams) do not influence the value of this property (currently). The start time reported by the demuxer in fractional seconds. Whether playback is paused because of waiting for the cache. The percentage (0-100) of the cache fill status until the player will unpause (related to ). Whether the end of playback was reached. Note that this is usually interesting only if is enabled, since otherwise the player will immediately play the next file (or exit or enter idle mode), and in these cases the property will logically be cleared immediately after it's set. Whether the player is currently seeking, or otherwise trying to restart playback. (It's possible that it returns /true while a file is loaded. This is because the same underlying code is used for seeking and resyncing.) Whether the audio mixer is active. This option is relatively useless. Before mpv 0.18.1, it could be used to infer behavior of the property. System volume. This property is available only if mpv audio output is currently active, and only if the underlying implementation supports volume control. What this option does, or how the value is interpreted depends on the API. For example, on ALSA this usually changes system-wide audio volume on a linear curve, while with PulseAudio this controls per-application volume on a cubic curve. Similar to , but controls the mute state. May be unimplemented even if works. Audio format as output by the audio decoder. This has a number of sub-properties: The sample format as string. This uses the same names as used in other places of mpv. The channel layout as a string. This is similar to what the accepts. As , but instead of the possibly cryptic actual layout sent to the audio device, return a hopefully more human readable form. (Usually only makes sense.) Number of audio channels. This is redundant to the field described above. When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: Same as , but the format of the data written to the audio API. Redirects to . This parameter (as well as similar ones) can be overridden with the video filter. Writing to it may change the currently used hardware decoder, if possible. (Internally, the player may reinitialize the decoder, and will perform a seek to refresh the video properly.) You can watch the other hwdec properties to see whether this was successful. Unlike in mpv 0.9.x and before, this does not return the currently active hardware decoder. Since mpv 0.18.0, is available for this purpose. The current hardware decoding in use. If decoding is active, return one of the values used by the option/property. /false indicates software decoding. If no decoder is loaded, the property is unavailable. This returns the currently loaded hardware decoding/output interop driver. This is known only once the VO has opened (and possibly later). With some VOs (like ), this might be never known in advance, but only when the decoder attempted to create the hw decoder successfully. (Using can load it eagerly.) If there are multiple drivers loaded, they will be separated by . If no VO is active or no interop driver is known, this property is unavailable. This does not necessarily use the same values as . There can be multiple interop drivers for the same hardware decoder, depending on platform and VO. Video size. This uses the size of the video as decoded, or if no video frame has been decoded yet, the (possibly incorrect) container indicated size. Video parameters, as output by the decoder (with overrides like aspect etc. applied). This has a number of sub-properties: The pixel format as string. This uses the same names as used in other places of mpv. The underlying pixel format as string. This is relevant for some cases of hardware decoding and unavailable otherwise. Average bits-per-pixel as integer. Subsampled planar formats use a different resolution, which is the reason this value can sometimes be odd or confusing. Can be unavailable with some formats. Video size as integers, with no aspect correction applied. Display aspect ratio name as string. The name corresponds to motion picture film format that introduced given aspect ratio in film. The colormatrix in use as string. (Exact values subject to change.) The colorlevels as string. (Exact values subject to change.) The primaries in use as string. (Exact values subject to change.) The gamma function in use as string. (Exact values subject to change.) The light type in use as a string. (Exact values subject to change.) Alpha type. If the format has no alpha channel, this will be unavailable (but in future releases, it could change to ). If alpha is present, this is set to or . Minimum luminance, as reported by HDR10 metadata (in cd/m²) Maximum luminance, as reported by HDR10 metadata (in cd/m²) Maximum content light level, as reported by HDR10 metadata (in cd/m²) Maximum frame average light level, as reported by HDR10 metadata (in cd/m²) MaxRGB of a scene for R component, as reported by HDR10+ metadata (in cd/m²) MaxRGB of a scene for G component, as reported by HDR10+ metadata (in cd/m²) MaxRGB of a scene for B component, as reported by HDR10+ metadata (in cd/m²) Maximum PQ luminance of a frame, as reported by peak detection (in PQ, 0-1) Average PQ luminance of a frame, as reported by peak detection (in PQ, 0-1) When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: Video display size. This is the video size after filters and aspect scaling have been applied. The actual video window size can still be different from this, e.g. if the user resized the video window manually. These have the same values as and . Exactly like , but no overrides applied. Same as , but after video filters have been applied. If there are no video filters in use, this will contain the same values as . Note that this is still not necessarily what the video window uses, since the user can change the window size, and all real VOs do their own scaling independently from the filter chain. Has the same sub-properties as . Same as , but with the target properties that VO outputs to. Has the same sub-properties as . Approximate information of the current frame. Note that if any of these are used on OSD, the information might be off by a few frames due to OSD redrawing and frame display being somewhat disconnected, and you might have to pause and force a redraw. This has a number of sub-properties: The type of the picture. It can be \"I\" (intra), \"P\" (predicted), \"B\" (bi-dir predicted) or unavailable. Whether the content of the frame is interlaced. If the content is interlaced, whether the top field is displayed first. Whether the frame must be delayed when decoding. String with the GOP timecode encoded in the frame. String with the SMPTE timecode encoded in the frame. Estimated timecode based on the current playback position and frame count. Container FPS. This can easily contain bogus values. For videos that use modern container formats or video codecs, this will often be incorrect. Estimated/measured FPS of the video filter chain output. (If no filters are used, this corresponds to decoder output.) This uses the average of the 10 past frame durations to calculate the FPS. It will be inaccurate if frame-dropping is involved (such as when framedrop is explicitly enabled, or after precise seeking). Files with imprecise timestamps (such as Matroska) might lead to unstable results. The value calculated from the current window size. This has the same value as if the window size was not changed since setting the option, and the window size was not restricted in other ways. If the window is fullscreened, this will return the scale value calculated from the last non-fullscreen size of the window. The property is unavailable if no video is active. It is also possible to write to this property. This has the same behavior as writing . Note that writing to will not affect the value of . Whether the window has focus. Might not be supported by all VOs. Names of the displays that the mpv window covers. On X11, these are the xrandr names (LVDS1, HDMI1, DP1, VGA1, etc.). On Windows, these are the GDI names (\\.DISPLAY1, \\.DISPLAY2, etc.) and the first display in the list will be the one that Windows considers associated with the window (as determined by the MonitorFromWindow API.) On macOS these are the Display Product Names as used in the System Information with a serial number in parentheses and only one display name is returned since a window can only be on one screen. On Wayland, these are the wl_output names if protocol version >= 4 is used (LVDS-1, HDMI-A-1, X11-1, etc.), or the wl_output model reported by the geometry event if protocol version < 4 is used. The refresh rate of the current display. Currently, this is the lowest FPS of any display covered by the video, as retrieved by the underlying system APIs (e.g. xrandr on X11). It is not the measured FPS. It's not necessarily available on all platforms. Note that any of the listed facts may change any time without a warning. The actual rate at which display refreshes seem to occur, measured by system time. Only available if display-sync mode (as selected by ) is active. The current display's horizontal and vertical resolution in pixels. Whether or not these values update as the mpv window changes displays depends on the windowing backend. It may not be available on all platforms. The HiDPI scale factor as reported by the windowing backend. If no VO is active, or if the VO does not report a value, this property is unavailable. It may be saner to report an absolute DPI, however, this is the way HiDPI support is implemented on most OS APIs. See also . Last known OSD width (can be 0). This is needed if you want to use the command. It gives you the actual OSD/window size (not including decorations drawn by the OS window manager). Last known OSD display pixel aspect (can be 0). Has the following sub-properties (which can be read as or Lua table with ): Size of the VO window in OSD render units (usually pixels, but may be scaled pixels with VOs like ). Size of the VO window in OSD render units, Pixel aspect ratio of the OSD (usually 1). Display aspect ratio of the VO window. (Computing from the properties above.) OSD to video margins (top, bottom, left, right). This describes the area into which the video is rendered. Any of these properties may be unavailable or set to dummy values if the VO window is not created or visible. This has two sub-properties. width of the terminal in cells height of the terminal in cells This property is not observable. Reacting to size changes requires polling. Read-only - mpv's window id. May not always be available, i.e due to window not being opened yet or not being supported by the VO. Read-only - last known mouse position, normalized to OSD dimensions. Has the following sub-properties (which can be read as or Lua table with ): Last known coordinates of the mouse pointer. Boolean - whether the mouse pointer hovers the video window. The coordinates should be ignored when this value is false, because the video backends update them only when the pointer hovers the window. Read-only - last known touch point positions, normalized to OSD dimensions. This has a number of sub-properties. Replace with the 0-based touch point index. Whenever a new finger touches the screen, a new touch point is added to the list of touch points with the smallest unused available. Unique identifier of the touch point. This can be used to identify individual touch points when their indexes change. When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: The current ASS subtitle track's extradata. There is no formatting done. The extradata is returned as a string as-is. This property is not available for non-ASS subtitle tracks. The current subtitle text regardless of sub visibility. Formatting is stripped. If the subtitle is not text-based (i.e. DVD/BD subtitles), an empty string is returned. This has sub-properties for different formats: Like , but return the text in ASS format. Text subtitles in other formats are converted. For native ASS subtitles, events that do not contain any text (but vector drawings etc.) are not filtered out. If multiple events match with the current playback time, they are concatenated with line breaks. Contains only the \"Text\" part of the events. This property is not enough to render ASS subtitles correctly, because ASS header and per-event metadata are not returned. Use for that. Like , but return the full event with all fields, formatted as lines in a .ass text file. Use with for style information. Same as (with the same sub-properties), but for the secondary subtitles. The current subtitle start time (in seconds). If there's multiple current subtitles, returns the first start time. If no current subtitle is present null is returned instead. Same as , but for the secondary subtitles. The current subtitle end time (in seconds). If there's multiple current subtitles, return the last end time. If no current subtitle is present, or if it's present but has unknown or incorrect duration, null is returned instead. Same as , but for the secondary subtitles. Current position on playlist. The first entry is on position 0. Writing to this property may start playback at the new position. In some cases, this is not necessarily the currently playing file. See explanation of and flags in . If there the playlist is empty, or if it's non-empty, but no entry is \"current\", this property returns -1. Likewise, writing -1 will put the player into idle mode (or exit playback if idle mode is not enabled). If an out of range index is written to the property, this behaves as if writing -1. (Before mpv 0.33.0, instead of returning -1, this property was unavailable if no playlist entry was current.) Writing the current value back to the property will have no effect. Use to restart the playback of the current entry if desired. Same as , but 1-based. Index of the \"current\" item on playlist. This usually, but not necessarily, the currently playing item (see ). Depending on the exact internal state of the player, it may refer to the playlist item to play next, or the playlist item used to determine what to play next. For reading, this is exactly the same as . For writing, this only sets the position of the \"current\" item, without stopping playback of the current file (or starting playback, if this is done in idle mode). Use -1 to remove the current flag. This property is only vaguely useful. If set during playback, it will typically cause the playlist entry after it to be played next. Another possibly odd observable state is that if is run during playback, this property is set to the playlist entry to play next (unlike the previous case). There is an internal flag that decides whether the current playlist entry or the next one should be played, and this flag is currently inaccessible for API users. (Whether this behavior will kept is possibly subject to change.) Index of the \"playing\" item on playlist. A playlist item is \"playing\" if it's being loaded, actually playing, or being unloaded. This property is set during the ( ) and the ( ) events. Outside of that, it returns -1. If the playlist entry was somehow removed during playback, but playback hasn't stopped yet, or is in progress of being stopped, it also returns -1. (This can happen at least during state transitions.) In the \"playing\" state, this is usually the same as , except during state changes, or if was written explicitly. The original path of the playlist for the current entry before mpv expanded the entries. Unavailable if the file was not originally associated with a playlist in some way. Playlist, current entry marked. Currently, the raw property value is useless. This has a number of sub-properties. Replace with the 0-based playlist entry index. Number of playlist entries (same as ). /true if the property points to this entry, /false or unavailable otherwise. /true if the property points to this entry, /false or unavailable otherwise. Name of the Nth entry. Available if the playlist file contains such fields and mpv's parser supports it for the given playlist format, or if the playlist entry has been opened before and a media-title other than filename has been acquired. Unique ID for this entry. This is an automatically assigned integer ID that is unique for the entire life time of the current mpv core instance. Other commands, events, etc. use this as fields. The original path of the playlist for this entry before mpv expanded it. Unavailable if the file was not originally associated with a playlist in some way. When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: MPV_FORMAT_NODE_ARRAY MPV_FORMAT_NODE_MAP (for each playlist entry) \"filename\" MPV_FORMAT_STRING \"current\" MPV_FORMAT_FLAG (might be missing; since mpv 0.7.0) \"playing\" MPV_FORMAT_FLAG (same) \"title\" MPV_FORMAT_STRING (optional) \"id\" MPV_FORMAT_INT64 This has a number of sub-properties. Replace with the 0-based track index. The list of video tracks. This is only usable for printing and its value can't be retrieved. The list of audio tracks. This is only usable for printing and its value can't be retrieved. The list of sub tracks. This is only usable for printing and its value can't be retrieved. The ID as it's used for / / . This is unique within tracks of the same type (sub/audio/video), but otherwise not. String describing the media type. One of , , . Track ID as used in the source file. Not always available. (It is missing if the format has no native ID, if the track is a pseudo-track that does not exist in this way in the actual file, or if the format is handled by libavformat, and the format was not whitelisted as having track IDs.) Track title as it is stored in the file. Not always available. Track language as identified by the file. Not always available. /true if this is a video track that consists of a single picture, /false or unavailable otherwise. The heuristic used to determine if a stream is an image doesn't attempt to detect images in codecs normally used for videos. Otherwise, it is reliable. /true if this is an image embedded in an audio file or external cover art, /false or unavailable otherwise. /true if the track has the default flag set in the file, /false or unavailable otherwise. /true if the track has the forced flag set in the file, /false or unavailable otherwise. /true if the track has the dependent flag set in the file, /false or unavailable otherwise. /true if the track has the visual impaired flag set in the file, /false or unavailable otherwise. /true if the track has the hearing impaired flag set in the file, /false or unavailable otherwise. The bitrate of the HLS stream, if available. The program ID of the HLS stream, if available. The codec name used by this track, for example . Unavailable in some rare cases. The codec descriptive name used by this track. The codec profile used by this track. Available only if the track has been already decoded. /true if the track is an external file, /false or unavailable otherwise. This is set for separate subtitle files. The filename if the track is from an external file, unavailable otherwise. /true if the track is currently decoded, /false or unavailable otherwise. It indicates the selection order of tracks for the same type. If a track is not selected, or is selected by the , it is not available. For subtitle tracks, represents the , and represents the . The stream index as usually used by the FFmpeg utilities. Note that this can be potentially wrong if a demuxer other than libavformat ( ) is used. For mkv files, the index will usually match even if the default (builtin) demuxer is used, but there is no hard guarantee. If this track is being decoded, the short decoder name, If this track is being decoded, the human-readable decoder name, Video size hint as indicated by the container. (Not always accurate.) Number of audio channels as indicated by the container. (Not always accurate - in particular, the track could be decoded as a different number of channels.) Channel layout as indicated by the container. (Not always accurate.) Audio sample rate as indicated by the container. (Not always accurate.) Video FPS as indicated by the container. (Not always accurate.) Audio average bitrate, in bits per second. (Not always accurate.) Short name for format from ffmpeg. If the track is audio, this will be the name of the sample format. If the track is video, this will be the name of the pixel format. Per-track replaygain values. Only available for audio tracks with corresponding information stored in the source file. Per-album replaygain values. If the file has per-track but no per-album information, the per-album values will be copied from the per-track values currently. It's possible that future mpv versions will make these properties unavailable instead in this case. Dolby Vision profile and level. May not be available if the container does not provide this information. Works like the property, but it accesses metadata that is set per track/stream instead of global values for the entire file. When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: MPV_FORMAT_NODE_ARRAY MPV_FORMAT_NODE_MAP (for each track) \"id\" MPV_FORMAT_INT64 \"type\" MPV_FORMAT_STRING \"src-id\" MPV_FORMAT_INT64 \"title\" MPV_FORMAT_STRING \"lang\" MPV_FORMAT_STRING \"image\" MPV_FORMAT_FLAG \"albumart\" MPV_FORMAT_FLAG \"default\" MPV_FORMAT_FLAG \"forced\" MPV_FORMAT_FLAG \"dependent\" MPV_FORMAT_FLAG \"visual-impaired\" MPV_FORMAT_FLAG \"hearing-impaired\" MPV_FORMAT_FLAG \"hls-bitrate\" MPV_FORMAT_INT64 \"program-id\" MPV_FORMAT_INT64 \"selected\" MPV_FORMAT_FLAG \"main-selection\" MPV_FORMAT_INT64 \"external\" MPV_FORMAT_FLAG \"external-filename\" MPV_FORMAT_STRING \"codec\" MPV_FORMAT_STRING \"codec-desc\" MPV_FORMAT_STRING \"codec-profile\" MPV_FORMAT_STRING \"ff-index\" MPV_FORMAT_INT64 \"decoder\" MPV_FORMAT_STRING \"decoder-desc\" MPV_FORMAT_STRING \"demux-w\" MPV_FORMAT_INT64 \"demux-h\" MPV_FORMAT_INT64 \"demux-crop-x\" MPV_FORMAT_INT64 \"demux-crop-y\" MPV_FORMAT_INT64 \"demux-crop-w\" MPV_FORMAT_INT64 \"demux-crop-h\" MPV_FORMAT_INT64 \"demux-channel-count\" MPV_FORMAT_INT64 \"demux-channels\" MPV_FORMAT_STRING \"demux-samplerate\" MPV_FORMAT_INT64 \"demux-fps\" MPV_FORMAT_DOUBLE \"demux-bitrate\" MPV_FORMAT_INT64 \"demux-rotation\" MPV_FORMAT_INT64 \"demux-par\" MPV_FORMAT_DOUBLE \"format-name\" MPV_FORMAT_STRING \"audio-channels\" MPV_FORMAT_INT64 \"replaygain-track-peak\" MPV_FORMAT_DOUBLE \"replaygain-track-gain\" MPV_FORMAT_DOUBLE \"replaygain-album-peak\" MPV_FORMAT_DOUBLE \"replaygain-album-gain\" MPV_FORMAT_DOUBLE \"dolby-vision-profile\" MPV_FORMAT_INT64 \"dolby-vision-level\" MPV_FORMAT_INT64 \"metadata\" MPV_FORMAT_NODE_MAP (key and string value for each metadata entry) This gives access to currently selected tracks. It redirects to the correct entry in . The following sub-entries are defined: , , , For example, returns the current audio track's language field (the same value as ). If tracks of the requested type are selected via , the first one is returned. This has a number of sub-properties. Replace with the 0-based chapter index. Chapter title as stored in the file. Not always available. When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: See / and the / command. When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: MPV_FORMAT_NODE_ARRAY MPV_FORMAT_NODE_MAP (for each filter entry) \"name\" MPV_FORMAT_STRING \"label\" MPV_FORMAT_STRING [optional] \"enabled\" MPV_FORMAT_FLAG [optional] \"params\" MPV_FORMAT_NODE_MAP [optional] \"key\" MPV_FORMAT_STRING \"value\" MPV_FORMAT_STRING It's also possible to write the property using this format. Whether it's generally possible to seek in the current file. Whether the current file is considered seekable, but only because the cache is active. This means small relative seeks may be fine, but larger seeks may fail anyway. Whether a seek will succeed or not is generally not known in advance. If this property returns /true, so will . Whether playback is stopped or is to be stopped. (Useful in obscure situations like during hook processing, when the user can stop playback, but the script has to explicitly end processing.) See . Setting this to a new value will always update the cursor, and reset the internal timer. Inserts the symbol to force line truncation to the current terminal width. This can be used for and other OSD messages. It must be the first character in the line. It takes effect until the end of the line. Inserts the current OSD symbol as opaque OSD control code (cc). This makes sense only with the command or options which set OSD messages. The control code is implementation specific and is useless for anything else. disables escaping ASS sequences of text in OSD, enables it again. By default, ASS sequences are escaped to avoid accidental formatting, and this property can disable this behavior. Note that the properties return an opaque OSD control code, which only makes sense for the command or options which set OSD messages. Any ASS override tags as understood by libass can be used. Note that you need to escape the character, because the string is processed for C escape sequences before passing it to the OSD code. See Flat command syntax for details. A list of tags can be found here: https://aegisub.org/docs/latest/ass_tags/ Whether the VO is configured right now. Usually this corresponds to whether the video window is visible. If the option is used, this usually always returns /true. Contains introspection about the VO's active render passes and their execution times. Not implemented by all VOs. This is further subdivided into two frame types, for fresh frames (which have to be uploaded, scaled, etc.) and for redrawn frames (which only have to be re-painted). The number of passes for any given subtype can change from frame to frame, and should not be relied upon. Each frame type has a number of further sub-properties. Replace with the frame type, with the 0-based pass index, and with the 0-based sample index. Average execution time of this pass, in nanoseconds. The exact timeframe varies, but it should generally be a handful of seconds. The peak execution time (highest value) within this averaging range, in nanoseconds. The number of samples for this pass. The raw execution time of a specific sample for this pass, in nanoseconds. When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: Note that directly accessing this structure via subkeys is not supported, the only access is through aforementioned . Further performance data. Querying this property triggers internal collection of some data, and may slow down the player. Each query will reset some internal state. Property change notification doesn't and won't work. All of this may change in the future, so don't use this. The builtin script is supposed to be the only user; since it's bundled and built with the source code, it can use knowledge of mpv internal to render the information properly. See script description for some details. Bitrate values calculated on the packet level. This works by dividing the bit size of all packets between two keyframes by their presentation timestamp distance. (This uses the timestamps are stored in the file, so e.g. playback speed does not influence the returned values.) In particular, the video bitrate will update only per keyframe, and show the \"past\" bitrate. To make the property more UI friendly, updates to these properties are throttled in a certain way. The unit is bits per second. OSD formatting turns these values in kilobits (or megabits, if appropriate), which can be prevented by using the raw property value, e.g. with . Note that the accuracy of these properties is influenced by a few factors. If the underlying demuxer rewrites the packets on demuxing (done for some file formats), the bitrate might be slightly off. If timestamps are bad or jittery (like in Matroska), even constant bitrate streams might show fluctuating bitrate. How exactly these values are calculated might change in the future. In earlier versions of mpv, these properties returned a static (but bad) guess using a completely different method. The list of discovered audio devices. This is mostly for use with the client API, and reflects what with the command line player returns. When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: MPV_FORMAT_NODE_ARRAY MPV_FORMAT_NODE_MAP (for each device entry) \"name\" MPV_FORMAT_STRING \"description\" MPV_FORMAT_STRING The is what is to be passed to the option (and often a rather cryptic audio API-specific ID), while is human readable free form text. The description is set to the device name (minus mpv-specific prefix) if no description is available or the description would have been an empty string. The special entry with the name set to selects the default audio output driver and the default device. The property can be watched with the property observation mechanism in the client API and in Lua scripts. (Technically, change notification is enabled the first time this property is read.) Set the audio device. This directly reads/writes the option, but on write accesses, the audio output will be scheduled for reloading. Writing this property while no audio output is active will not automatically enable audio. (This is also true in the case when audio was disabled due to reinitialization failure after a previous write access to .) This property also doesn't tell you which audio device is actually in use. How these details are handled may change in the future. Current video output driver (name as used with ). Current GPU context of video output driver (name as used with ). Valid for and . Current audio output driver (name as used with ). This is a recursive key/value map of arbitrary nodes shared between clients for general use (i.e. scripts, IPC clients, host applications, etc). The player itself does not use any data in it (although some builtin scripts may). The property is not preserved across player restarts. Sub-paths can be accessed directly; e.g. can be read, written, or observed. The top-level object itself cannot be written directly; write to sub-paths instead. Converting this property or its sub-properties to strings will give a JSON representation. If converting a leaf-level object (i.e. not a map or array) and not using raw mode, the underlying content will be given (e.g. strings will be printed directly, rather than quoted and JSON-escaped). The following sub-paths are reserved for internal uses or have special semantics: , . Unless noted otherwise, the semantics of any properties under these sub-paths can change at any time and may not be relied upon, and writing to these properties may prevent builtin scripts from working properly. Currently, the following properties have defined special semantics: This property is written by an OSC implementation to indicate the margins that it occupies. Its sub-properties , , , and should all be set to the left, right, top, and bottom margins respectively. Values are between 0.0 and 1.0, normalized to window width/height. Path to the ytdl executable, if found, or an empty string otherwise. The property is not set until the script attempts to find the ytdl executable, i.e. until an URL is being loaded by the script. Result of executing ytdl to retrieve the JSON data of the URL being loaded. The format is the same as 's result, capturing stdout and stderr. Whether the console is open. This property stores the raw menu definition. See Context Menu section for details. Menu item type. Can be: , , or empty. Menu item title. Required if type is not . Command to execute when the menu item is clicked. Menu item shortcut key which appears to the right of the menu item. A shortcut key does not have to be functional; it's just a visual hint. Menu item state. Can be: , , , or empty. Submenu items, which is required if type is . When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: Writing to this property with the client API using or with Lua will trigger an immediate update of the menu if mpv video output is currently active. You may observe the property to check if this is the case. The working directory of the mpv process. Can be useful for JSON IPC users, because the command line player usually works with relative paths. The directory in which watch later config files are stored. This returns , or the default directory if has not been modified, with tilde placeholders expanded. List of protocol prefixes potentially recognized by the player. They are returned without trailing suffix (which is still always required). In some cases, the protocol will not actually be supported (consider if ffmpeg is not compiled with TLS support). List of decoders supported. This lists decoders which can be passed to and . Canonical codec name, which identifies the format the decoder can handle. The name of the decoder itself. Often, this is the same as . Sometimes it can be different. It is used to distinguish multiple decoders for the same codec. Human readable description of the decoder and codec. When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: List of libavcodec encoders. This has the same format as . The encoder names ( entries) can be passed to and (without the prefix required by and ). List of available libavformat demuxers' names. This can be used to check for support for a specific format or use with . List of Key names, same as output by . The mpv version/copyright string. Depending on how the binary was built, it might contain either a release version, or just a git hash. The configuration arguments that were passed to the build system. If the meson version used to compile mpv is older than 1.1.0, then a hardcoded string of a few, arbitrary options is displayed instead. The contents of the API call. This is a string which identifies the build in some way, either through a release version number, or a git hash. This property is unavailable if mpv is linked against older FFmpeg versions. The value of . This is an integer, encoded in a somewhat weird form (apparently \"hex BCD\"), indicating the release version of the libass library linked to mpv. Returns a string describing what target platform mpv was built for. The value of this is dependent on what the underlying build system detects. Some of the most common values are: , (macos or ios), , , and . Note that this is not a complete listing. The value of option . Most options can be changed at runtime by writing to this property. Note that many options require reloading the file for changes to take effect. If there is an equivalent property, prefer setting the property instead. There shouldn't be any reason to access instead of , except in situations in which the properties have different behavior or conflicting semantics. Similar to , but when setting an option through this property, the option is reset to its old value once the current file has stopped playing. Trying to write an option while no file is playing (or is being loaded) results in an error. This has a number of sub-properties. Replace with the name of a top-level option. No guarantee of stability is given to any of these sub-properties - they may change radically in the future. The name of the option. The name of the option type, like or . For many complex types, this isn't very accurate. Whether the option was set from the mpv command line. What this is set to if the option is e.g. changed at runtime is left undefined (meaning it could change in the future). Whether the option was set per-file. This is the case with automatically loaded profiles, file-dir configs, and other cases. It means the option value will be restored to the value before playback start when playback ends. Whether the option takes file paths as arguments. The default value of the option. May not always be available. Integer minimum and maximum values allowed for the option. Only available if the options are numeric, and the minimum/maximum has been set internally. It's also possible that only one of these is set. If the option is a choice option, the possible choices. Choices that are integers may or may not be included (they can be implied by and ). Note that options which behave like choice options, but are not actual choice options internally, may not have this info available. The list of profiles and their contents. This is highly implementation-specific, and may change any time. Currently, it returns an array of options for each profile. Each option has a name and a value, with the value currently always being a string. Note that the options array is not a map, as order matters and duplicate entries are possible. Recursive profiles are not expanded, and show up as special options. The field is currently missing if it holds the default value (either because it was not set, or set explicitly to ), but in the future it might hold the value . The list of input commands. This returns an array of maps, where each map node represents a command. This map currently only has a single entry: for the name of the command. (This property is supposed to be a replacement for . The option dumps some more information, but it's a valid feature request to extend this property if needed.) The list of current input key bindings. This returns an array of maps, where each map node represents a binding for a single key/command. This map has the following entries: The key name. This is normalized and may look slightly different from how it was specified in the source (e.g. in input.conf). The command mapped to the key. (Currently, this is exactly the same string as specified in the source, other than stripping whitespace and comments. It's possible that it will be normalized in the future.) If set to true, any existing and active user bindings will take priority. If this entry exists, the name of the script (or similar) which added this binding. Name of the section this binding is part of. This is a rarely used mechanism. This entry may be removed or change meaning in the future. A number. Bindings with a higher value are preferred over bindings with a lower value. If the value is negative, this binding is inactive and will not be triggered by input. Note that mpv does not use this value internally, and matching of bindings may work slightly differently in some cases. In addition, this value is dynamic and can change around at runtime. If available, the comment following the command on the same line. (For example, the input.conf entry would result in an entry with .) This property is read-only, and change notification is not supported. The clipboard contents, only works when native clipboard ( ) is supported on the platform. Depending on the platform, some sub-properties, writing to properties, or change notifications are not currently functional. This has a number of sub-properties: The text content in the clipboard (Windows, Wayland and macOS only). Writing to this property sets the text clipboard content (Windows only). The text content in the primary selection (Wayland only). On Wayland with the clipboard backend, the clipboard content is only updated when the compositor sends a selection data offer (typically when VO window is focused). The backend typically does not have this limitation. See property for more details. A string containing the currently active clipboard backend. See option for the list of available backends. You can access (almost) all options as properties, though there are some caveats with some properties (due to historical reasons): While playback is active, these return the actually active tracks. For example, if you set , and the currently played file contains no audio track with ID 5, the property will return . Before mpv 0.31.0, you could set existing tracks at runtime only. This inconsistent behavior is deprecated. Post-deprecation, the reported value and the option value are cleanly separated ( for the option value). If you set the properties during playback, and the filter chain fails to reinitialize, the option will be set, but the runtime filter chain does not change. On the other hand, the next video to be played will fail, because the initial filter chain cannot be created. This behavior changed in mpv 0.31.0. Before this, the new value was rejected iff a video (for ) or an audio (for ) track was active. If playback was not active, the behavior was the same as the current one. The property is read-only and returns the current internal playlist. The option is for loading playlist during command line parsing. For client API uses, you should use the command instead. These are write-only, and will perform actions as they are written to, exactly as if they were used on the mpv CLI commandline. Their only use is when using libmpv before , which in turn is probably only useful in encoding mode. Normal libmpv users should use other mechanisms, such as the command, and the API function. Avoid these properties. All string arguments to input commands as well as certain options (like ) are subject to property expansion. Note that property expansion does not work in places where e.g. numeric parameters are expected. (For example, the command does not do property expansion. The command is an exception and not a general rule.) shows the filename of the current file when pressing the key Whether property expansion is enabled by default depends on which API is used (see Flat command syntax, Commands specified as arrays and Named arguments), but it can always be enabled with the prefix or disabled with the prefix, as described in Input Command Prefixes. The following expansions are supported: Expands to the value of the property . If retrieving the property fails, expand to an error string. (Use with a trailing to expand to an empty string instead.) If is prefixed with , expand to the raw value of the property (see section below). Expands to the value of the property , or if the property cannot be retrieved. is expanded recursively. Expands to (recursively) if the property is available. Expands to (recursively) if the property cannot be retrieved. Expands to (recursively) if the property expands to a string equal to . You can prefix with in order to compare the raw value of a property (see section below). If the property is unavailable, or other errors happen when retrieving it, the value is never considered equal. Note that can't contain any of the characters or . Also, it is possible that escaping with or might be added in the future, should the need arise. Same as with the variant, but is expanded if the value is not equal. (Using the same semantics as with .) Expands to . (To produce this character inside recursive expansion.) Disable property expansion and special handling of for the rest of the string. In places where property expansion is allowed, C-style escapes are often accepted as well. Example: Normally, properties are formatted as human-readable text, meant to be displayed on OSD or on the terminal. It is possible to retrieve an unformatted (raw) value from a property by prefixing its name with . These raw values can be parsed by other programs and follow the same conventions as the options associated with the properties. Additionally, there is a prefix to format human-readable text, with fixed precision for floating-point values. This is useful for printing values where a constant width is important.\n• expands to (if playback position is at 14 minutes 23 seconds)\n• expands to (same time, plus 400 milliseconds - milliseconds are normally not shown in the formatted case) Sometimes, the difference in amount of information carried by raw and formatted property values can be rather big. In some cases, raw values have more information, like higher precision than seconds with . Sometimes it is the other way around, e.g. shows track title and language in the formatted case, but only the track number if it is raw.\n\nmpv provides the built-in module , which contains functions to send commands to the mpv core and to retrieve information about playback state, user settings, file information, and so on. These scripts can be used to control mpv in a similar way to slave mode. Technically, the Lua code uses the client API internally. A script which leaves fullscreen mode when the player is paused: function on_pause_change(name, value) if value == true then mp.set_property(\"fullscreen\", \"no\") end end mp.observe_property(\"pause\", \"bool\", on_pause_change) Scripts can be passed to the option, and are automatically loaded from the subdirectory of the mpv configuration directory (usually ). A script can be a single file. The file extension is used to select the scripting backend to use for it. For Lua, it is . If the extension is not recognized, an error is printed. (If an error happens, the extension is either mistyped, or the backend was not compiled into your mpv binary.) mpv internally loads the script's name by stripping the extension and replacing all nonalphanumeric characters with . E.g., becomes . If there are several scripts with the same name, it is made unique by appending a number. This is the name returned by . Entries with extension are always ignored. If a script is a directory (either if a directory is passed to , or any sub-directories in the script directory, such as for example ), then the directory represents a single script. The player will try to load a file named , where is replaced with the file extension. For example, if exists, it is loaded with the Lua scripting backend. You must not put any other files or directories that start with into the script's top level directory. If the script directory contains for example both and , only one of them will be loaded (and which one depends on mpv internals that may change any time). Likewise, if there is for example , your script will break as soon as mpv adds a backend that uses the file extension. mpv also appends the top level directory of the script to the start of Lua's package path so you can import scripts from there too. Be aware that this will shadow Lua libraries that use the same package path. (Single file scripts do not include mpv specific directories in the Lua package path. This was silently changed in mpv 0.32.0.) Using a script directory is the recommended way to package a script that consists of multiple source files, or requires other files (you can use to get the location and e.g. load data files). Making a script a git repository, basically a repository which contains a file in the root directory, makes scripts easily updateable (without the dangers of auto-updates). Another suggestion is to use git submodules to share common files or libraries. Details on the script initialization and lifecycle Your script will be loaded by the player at program start from the configuration subdirectory, or from a path specified with the option. Some scripts are loaded internally (like ). Each script runs in its own thread. Your script is first run \"as is\", and once that is done, the event loop is entered. This event loop will dispatch events received by mpv and call your own event handlers which you have registered with , or timers added with or similar. Note that since the script starts execution concurrently with player initialization, some properties may not be populated with meaningful values until the relevant subsystems have initialized. Rather than retrieving these properties at the top of scripts, you should use or read them within event handlers. When the player quits, all scripts will be asked to terminate. This happens via a event, which by default will make the event loop return. If your script got into an endless loop, mpv will probably behave fine during playback, but it won't terminate when quitting, because it's waiting on your script. Internally, the C code will call the Lua function after loading a Lua script. This function is normally defined by the default prelude loaded before your script (see in the mpv sources). The event loop will wait for events and dispatch events registered with . It will also handle timers added with and similar (by waiting with a timeout). Since mpv 0.6.0, the player will wait until the script is fully loaded before continuing normal operation. The player considers a script as fully loaded as soon as it starts waiting for mpv events (or it exits). In practice this means the player will more or less hang until the script returns from the main chunk (and is called), or the script calls or directly. This is done to make it possible for a script to fully setup event handlers etc. before playback actually starts. In older mpv versions, this happened asynchronously. With mpv 0.29.0, this changes slightly, and it merely waits for scripts to be loaded in this manner before starting playback as part of the player initialization phase. Scripts run though initialization in parallel. This might change again. The module is preloaded, although it can be loaded manually with . It provides the core client API. Run the given command. This is similar to the commands used in input.conf. See List of Input Commands. By default, this will show something on the OSD (depending on the command), as if it was used in . See Input Command Prefixes how to influence OSD usage per command. Returns on success, or on error. Similar to , but pass each command argument as separate parameter. This has the advantage that you don't have to care about quoting and escaping in some cases. These two commands are equivalent, except that the first version breaks if the filename contains spaces or certain special characters. Note that properties are not expanded. You can use either , the prefix, or the family of functions. Unlike , this will not use OSD by default either (except for some OSD-specific commands). Similar to , but pass the argument list as table. This has the advantage that in at least some cases, arguments can be passed as native types. It also allows you to use named argument. If the table is an array, each array item is like an argument in (but can be a native type instead of a string). If the table contains string keys, it's interpreted as command with named arguments. This requires at least an entry with the key to be present, which must be a string, and contains the command name. The special entry is optional, and if present, must be an array of Input Command Prefixes to apply. All other entries are interpreted as arguments. Returns a result table on success (usually empty), or on error. is the second parameter provided to the function, and is nil if it's missing. Like , but the command is ran asynchronously (as far as possible), and upon completion, fn is called. fn has three arguments: : Always a Boolean and is true if the command was successful, otherwise false. The result value (can be nil) in case of success, nil otherwise (as returned by ). The error string in case of an error, nil otherwise. Returns a table with undefined contents, which can be used as argument for . If starting the command failed for some reason, is returned, and is called indicating failure, using the same error value. is always called asynchronously, even if the command failed to start. Abort a call. The argument is the return value of that command (which starts asynchronous execution of the command). Whether this works and how long it takes depends on the command and the situation. The abort call itself is asynchronous. Does not return anything. Delete the given property. See and Properties for more information about properties. Most properties cannot be deleted. Returns true on success, or on error. Return the value of the given property as string. These are the same properties as used in input.conf. See Properties for a list of properties. The returned string is formatted similar to (see Property Expansion). Returns the string on success, or on error. is the second parameter provided to the function, and is nil if it's missing. Similar to , but return the property value formatted for OSD. This is the same string as printed with when used in input.conf. Returns the string on success, or on error. is the second parameter provided to the function, and is an empty string if it's missing. Unlike , assigning the return value to a variable will always result in a string. Similar to , but return the property value as Boolean. Returns a Boolean on success, or on error. Similar to , but return the property value as number. Note that while Lua does not distinguish between integers and floats, mpv internals do. This function simply request a double float from mpv, and mpv will usually convert integer property values to float. Returns a number on success, or on error. Similar to , but return the property value using the best Lua type for the property. Most time, this will return a string, Boolean, or number. Some properties (for example ) are returned as tables. Returns a value on success, or on error. Note that might be a possible, valid value too in some corner cases. Set the given property to the given string value. See and Properties for more information about properties. Returns true on success, or on error. Similar to , but set the given property to the given Boolean value. Similar to , but set the given property to the given numeric value. Note that while Lua does not distinguish between integers and floats, mpv internals do. This function will test whether the number can be represented as integer, and if so, it will pass an integer value to mpv, otherwise a double float. Similar to , but set the given property using its native type. Since there are several data types which cannot represented natively in Lua, this might not always work as expected. For example, while the Lua wrapper can do some guesswork to decide whether a Lua table is an array or a map, this would fail with empty tables. Also, there are not many properties for which it makes sense to use this, instead of , , . For these reasons, this function should probably be avoided for now, except for properties that use tables natively. Return the current mpv internal time in seconds as a number. This is basically the system time, with an arbitrary offset. Register callback to be run on a key binding. The binding will be mapped to the given , which is a string describing the physical key. This uses the same key names as in input.conf, and also allows combinations (e.g. ). If the key is empty or , no physical key is registered, but the user still can create own bindings (see below). After calling this function, key presses will cause the function to be called (unless the user remapped the key with another binding). However, if the key binding is canceled , the function will not be called, unless flag is set to , where the function will be called with the entry set to . For example, a canceled key binding can happen in the following situations:\n• If key A is pressed while key B is being held down, key B is logically released (\"canceled\" by key A), which stops the current autorepeat action key B has.\n• If key A is pressed while a mouse button is being held down, the mouse button is logically released, but the mouse button's action will not be called, unless flag is set to . The argument should be a short symbolic string. It allows the user to remap the key binding via input.conf using the command, and the name of the key binding (see below for an example). The name should be unique across other bindings in the same script - if not, the previous binding with the same name will be overwritten. You can omit the name, in which case a random name is generated internally. (Omitting works as follows: either pass for , or pass the argument in place of the name. The latter is not recommended and is handled for compatibility only.) The argument is used for optional parameters. This is a table, which can have the following entries: If set to , enables key repeat for this specific binding. This option only makes sense when is not set to . If set to , enables key scaling for this specific binding. This option only makes sense when is set to . Note that this has no effect if the key binding is invoked by command, where the scalability of the command takes precedence. If set to , then is called on key down, repeat and up events, with the first argument being a table. This table has the following entries (and may contain undocumented ones): Set to one of the strings , , or (the latter if key up/down/repeat can't be tracked), which indicates the key's logical state. Boolean: Whether the event was caused by a mouse button. Boolean: Whether the event was canceled. Not all types of cancellations set this flag. The name of they key that triggered this, or if invoked artificially. If the key name is unknown, it's an empty string. Text if triggered by a text key, otherwise . See description of command for details (this field is equivalent to the 5th argument). The scale of the key, such as the ones produced by keys. The scale is 1 if the key is nonscalable. User-provided string in the argument in the command if the key binding is invoked by that command. Internally, key bindings are dispatched via the or input commands and . Trying to map multiple commands to a key will essentially prefer a random binding, while the other bindings are not called. It is guaranteed that user defined bindings in the central input.conf are preferred over bindings added with this function (but see ). This will print the message when was pressed. The user can remap these key bindings. Then the user has to put the following into their input.conf to remap the command to the key: This will print the message when the key is pressed. ( will still work, unless the user remaps it.) You can also explicitly send a message to a named script only. Assume the above script was using the filename : This works almost the same as , but registers the key binding in a way that will overwrite the user's custom bindings in their input.conf. ( overwrites default key bindings only, but not those by the user's input.conf.) Remove a key binding added with or . Use the same name as you used when adding the bindings. It's not possible to remove bindings for which you omitted the name. Call a specific function when an event happens. The event name is a string, and the function fn is a Lua function value. Some events have associated data. This is put into a Lua table and passed as argument to fn. The Lua table by default contains a field, which is a string containing the event name. If the event has an error associated, the field is set to a string describing the error, on success it's not set. If multiple functions are registered for the same event, they are run in registration order, which the first registered function running before all the other ones. Returns true if such an event exists, false otherwise. See Events and List of events for details. Undo . This removes all event handlers that are equal to the parameter. This uses normal Lua comparison, so be careful when dealing with closures. Watch a property for changes. If the property is changed, then the function will be called. can be , or be set to one of , , , , or . is the same as . For all other values, the new value of the property will be passed as second argument to , using to retrieve it. This means if is for example , is roughly called as in . If possible, change events are coalesced. If a property is changed a bunch of times in a row, only the last change triggers the change function. (The exact behavior depends on timing and other things.) If a property is unavailable, or on error, the value argument to is . (The call always succeeds, even if a property does not exist.) In some cases the function is not called even if the property changes. This depends on the property, and it's a valid feature request to ask for better update handling of a specific property. If the is or , the change function will be called sporadically even if the property doesn't actually change. You should therefore avoid using these types. You always get an initial change notification. This is meant to initialize the user's state to the current value of the property. Undo . This removes all property handlers that are equal to the parameter. This uses normal Lua comparison, so be careful when dealing with closures. Call the given function fn when the given number of seconds has elapsed. Note that the number of seconds can be fractional. For now, the timer's resolution may be as low as 50 ms, although this will be improved in the future. If the argument is set to or a truthy value, the timer will wait to be manually started with a call to its method. This is a one-shot timer: it will be removed when it's fired. Call the given function periodically. This is like , but the timer is re-added after the function fn is run. Returns a timer object. The timer object provides the following methods: Disable the timer. Does nothing if the timer is already disabled. This will remember the current elapsed time when stopping, so that essentially unpauses the timer. Disable the timer. Resets the elapsed time. will restart the timer. Restart the timer. If the timer was disabled with , this will resume at the time it was stopped. If the timer was disabled with , or if it's a previously fired one-shot timer (added with ), this starts the timer from the beginning, using the initially configured timeout. Whether the timer is currently enabled or was previously disabled (e.g. by or ). This field contains the current timeout period. This value is not updated as time progresses. It's only used to calculate when the timer should fire next when the timer expires. If you write this, you can call to reset the current timeout to the new one. ( won't use the new timeout.) Whether the timer is periodic ( ) or fires just once ( ). This value is used when the timer expires (but before the timer callback function fn is run). Note that these are methods, and you have to call them using instead of (Refer to https://www.lua.org/manual/5.2/manual.html#3.4.9 .) seconds = 0 timer = mp.add_periodic_timer(1, function() print(\"called every second\") -- stop it after 10 seconds seconds = seconds + 1 if seconds >= 10 then timer:kill() end end) Return a setting from the option. It's up to the user and the script how this mechanism is used. Currently, all scripts can access this equally, so you should be careful about collisions. Return the name of the current script. The name is usually made of the filename of the script, with directory and file extension removed. If there are several scripts which would have the same name, it's made unique by appending a number. Any nonalphanumeric characters are replaced with . Return the directory if this is a script packaged as directory (see Script location for a description). Return nothing if this is a single file script. Show an OSD message on the screen. is in seconds, and is optional (uses by default). These also live in the module, but are documented separately as they are useful only in special situations. Calls and returns the read end of the wakeup pipe. This is deprecated, but still works. (See for details.) Return the relative time in seconds when the next timer ( and similar) expires. If there is no timer, return . This can be used to run custom event loops. If you want to have direct control what the Lua script does (instead of being called by the default event loop), you can set the global variable to your own function running the event loop. From your event loop, you should call to dequeue and dispatch mpv events. If the parameter is set to , the function will block until the next event is received or the next timer expires. Otherwise (and this is the default behavior), it returns as soon as the event loop is emptied. It's strongly recommended to use and if you're interested in properly working notification of new events and working timers. Register an event loop idle handler. Idle handlers are called before the script goes to sleep after handling all new events. This can be used for example to delay processing of property change events: if you're observing multiple properties at once, you might not want to act on each property change, but only when all change notifications have been received. Undo . This removes all idle handlers that are equal to the parameter. This uses normal Lua comparison, so be careful when dealing with closures. Set the minimum log level of which mpv message output to receive. These messages are normally printed to the terminal. By calling this function, you can set the minimum log level of messages which should be received with the event. See the description of this event for details. The level is a string, see for allowed log levels. This is a helper to dispatch or invocations to Lua functions. is called if or (with this script as destination) is run with as first parameter. The other parameters are passed to . If a message with the given name is already registered, it's overwritten. Used by , so be careful about name collisions. Undo a previous registration with . Does nothing if the wasn't registered. Create an OSD overlay. This is a very thin wrapper around the command. The function returns a table, which mostly contains fields that will be passed to . The parameter is used to initialize the field. The field contains the text to be used as overlay. For details, see the command. In addition, it provides the following methods: Commit the OSD overlay to the screen, or in other words, run the command with the current fields of the overlay table. Returns the result of the command itself. Remove the overlay from the screen. A call will add it again. The advantage of using this wrapper (as opposed to running directly) is that the field is allocated automatically. Returns a tuple of . The first two give the size of the OSD in pixels (for video outputs like , this may be \"scaled\" pixels). The third is the display pixel aspect ratio. May return invalid/nonsense values if OSD is not initialized yet. Make the script exit at the end of the current event loop iteration. This does not terminate mpv itself or other scripts. This can be polyfilled to support mpv versions older than 0.40 with: if not _G.exit then function exit() mp.keep_running = false end end This module allows outputting messages to the terminal, and can be loaded with . The level parameter is the message priority. It's a string and one of , , , , , , . The user's settings will determine which of these messages will be visible. Normally, all messages are visible, except , and . The parameters after that are all converted to strings. Spaces are inserted to separate multiple parameters. You don't need to add newlines. All of these are shortcuts and equivalent to the corresponding call. mpv comes with a built-in module to manage options from config-files and the command-line. All you have to do is to supply a table with default options to the read_options function. The function will overwrite the default values with values found in the config-file and the command-line (in that order). A with key-value pairs. The type of the default values is important for converting the values read from the config file or command-line back. Do not use as a default value! The is used to identify the config-file and the command-line options. These needs to unique to avoid collisions with other scripts. Defaults to if the parameter is or missing. The parameter enables run-time updates of all matching option values via the option/property. If any of the matching options changes, the values in the (which was originally passed to the function) are changed, and is called. is a table where each updated option has a entry. There is no initial call. This never re-reads the config file. is always applied on the original config file, ignoring previous values (for example, if an option is removed from at runtime, the option will have the value in the config file). entries are only written for option values whose values effectively change (this is important if the script changes entries independently). The config file will be stored in in mpv's user folder. Comment lines can be started with # and stray spaces are not removed. Boolean values will be represented with yes/no. Command-line options are read from the parameter. To avoid collisions, all keys have to be prefixed with . This built-in module provides generic helper functions for Lua, and have strictly speaking nothing to do with mpv or video/audio playback. They are provided for convenience. Most compensate for Lua's scarce standard library. Be warned that any of these functions might disappear any time. They are not strictly part of the guaranteed API. Returns the directory that mpv was launched from. On error, is returned. Enumerate all entries at the given path on the filesystem, and return them as array. Each entry is a directory entry (without the path). The list is unsorted (in whatever order the operating system returns it). If the argument is given, it must be one of the following strings: List regular files only. This excludes directories, special files (like UNIX device files or FIFOs), and dead symlinks. It includes UNIX symlinks to regular files. List directories only, or symlinks to directories. and are not included. Include the results of both and . (This is the default.) List all entries, even device files, dead symlinks, FIFOs, and the and entries. Stats the given path for information and returns a table with the following entries: protection bits (on Windows, always 755 (octal) for directories and 644 (octal) for files) and are integers. Timestamps ( , and ) are integer seconds since the Unix epoch (Unix time). The booleans and are provided as a convenience; they can be and are derived from . On error (e.g. path does not exist), is returned. Split a path into directory component and filename component, and return them. The first return value is always the directory. The second return value is the trailing part of the path, the directory entry. Return the concatenation of the 2 paths. Tries to be clever. For example, if is an absolute path, is returned without change. Runs an external process and waits until it exits. Returns process status and the captured output. This is a legacy wrapper around calling the command with . It does the following things:\n• copy to field if the string is non-empty It is recommended to use or directly, instead of calling this legacy wrapper. It is for compatibility only. See the documentation for semantics and further parameters. Runs an external process and detaches it from mpv's control. The parameter is a table. The function reads the following entries: Array of strings of the same semantics as the used in the function. This is a legacy wrapper around calling the command with and other functions. Returns the process ID of the running mpv process. This can be used to identify the calling mpv when launching (detached) subprocesses. Returns the C environment as a list of strings. (Do not confuse this with the Lua \"environment\", which is an unrelated concept.) Parses the given string argument as JSON, and returns it as a Lua table. On error, returns . (Currently, is just a string reading , because there is no fine-grained error reporting of any kind.) The returned value uses similar conventions as to distinguish empty objects and arrays. If the parameter is (or any value equal to ), then trailing non-whitespace text is tolerated by the function, and the trailing text is returned as 3rd return value. (The 3rd return value is always there, but with set, no error is raised.) Format the given Lua table (or value) as a JSON string and return it. On error, returns . (Errors usually only happen on value types incompatible with JSON.) The argument value uses similar conventions as to distinguish empty objects and arrays. Turn the given value into a string. Formats tables and their contents. This doesn't do anything special; it is only needed because Lua is terrible. This module lets scripts get textual input from the user using the console REPL. Show the console to let the user enter text. The following entries of are read: The string to be displayed before the input field. A callback invoked when the user presses Enter. The first argument is the text in the console. Whether to keep the console open on submit. Defaults to . A callback invoked when the console is shown. This can be used to present a list of options with . A callback invoked when the text changes. The first argument is the text in the console. A callback invoked when the user edits the text or moves the cursor. The first argument is the text before the cursor. The callback should return a table of the string candidate completion values and the 1-based cursor position from which the completion starts. console will show the completions that fuzzily match the text between this position and the cursor and allow selecting them. The third and optional return value is a string that will be appended to the input line without displaying it in the completions. Whether to automatically select the first completion on submit if one wasn't already manually selected. Defaults to . A callback invoked when the console is hidden, either because was invoked from the other callbacks, or because the user closed it with a key binding. The first argument is the text in the console, and the second argument is the cursor position. A string to pre-fill the input field with. If specified, the path to save and load the history of the entered lines. An identifier that determines which input history and log buffer to use among the ones stored for calls. Defaults to the calling script name with appended. Add a line to the log buffer. can contain additional ASS tags to apply to , and can contain escape sequences that are used when the console is displayed in the terminal. Helper to add a line to the log buffer with the same color as the one used for commands that error. Useful when the user submits invalid input. is a table of strings, or tables with , and keys. Specify a list of items that are presented to the user for selection. The following entries of are read: The string to be displayed before the input field. The table of the entries to choose from. The 1-based integer index of the preselected item. The callback invoked when the user presses Enter. The first argument is the 1-based index of the selected item. Whether to keep the console open on submit. Defaults to . Events are notifications from player core to scripts. You can register an event handler with . Note that all scripts (and other parts of the player) receive events equally, and there's no such thing as blocking other scripts from receiving events. For the existing event types, see List of events. This documents experimental features, or features that are \"too special\" to guarantee a stable interface. Add a hook callback for (a string identifying a certain kind of hook). These hooks allow the player to call script functions and wait for their result (normally, the Lua scripting interface is asynchronous from the point of view of the player core). is an arbitrary integer that allows ordering among hooks of the same kind. Using the value 50 is recommended as neutral default value. is the function that will be called during execution of the hook. The parameter passed to it ( ) is a Lua object that can control further aspects about the currently invoked hook. It provides the following methods: Returning from the hook function should not automatically continue the hook. Instead, the API user wants to call on its own at a later point in time (before or after the function has returned). Continue the hook. Doesn't need to be called unless was called. See Hooks for currently existing hooks and what they do - only the hook list is interesting; handling hook execution is done by the Lua script function automatically."
    },
    {
        "link": "https://github.com/mpv-player/mpv/issues/12887",
        "document": "Observing should result in updates any time changes, but instead it only updates with events, which is insufficient.\n\nThe script gets notified about the change."
    },
    {
        "link": "https://manpages.ubuntu.com/manpages/focal/man1/mpv.1.html",
        "document": "USING MPV FROM OTHER PROGRAMS OR SCRIPTS"
    },
    {
        "link": "https://github.com/mpv-player/mpv/issues/9841",
        "document": "\n• Source of the mpv binary or bundle: Local build\n• If known which version of mpv introduced the problem: Unknown\n• Possible screenshot or video of visual glitches: Not that kind of problem\n\nAdd an audio filter and then use the client API call to obtain the audio filters.\n\nThe filter returned by is useable in the command.\n\nThe and and commands when matching filters compare argument order. That requirement conflicts with the node structure returned by for filters which uses a to hold the filter arguments. The documentation for in client.h within the structure explicitly documents that keys are in random order.\n\nIs the documentation wrong for ? Can clients depend upon the order of keys in a map returned for a filter? If not, isn't it inappropriate for to be returning filter arguments in an unordered map given the requirements of the and commands?\n\nThis conflict is the root cause of IINA issue iina/iina#3620. When IINA is parsing the returned by into Swift objects it uses a Swift Dictionary for . The order of key-value pairs in a Swift Dictionary is unpredictable. Based on the documentation of that is a correct representation. However if the documentation for is wrong about the order of keys and the map returned by can be relied upon to match the order of arguments in a filter then IINA needs to be changed to parse a into a Swift OrderedDictionary.\n\nA quick test indicated is returning the filter argument key-value pairs in the map in the correct order. In a test changing IINA to preserve that order using an resolved the problem reported in IINA issue iina/iina#3620. However given the clear documentation that the keys in a are in random order I would expect developers to question such an IINA \"fix\".\n\nThoughts? How should library clients deal with the ordering of filter arguments?\n\nThe concerning comment regarding keys being in random order from client.h:\n\nText from the mpv manual indicating the order of filter arguments matters:\n\nThe / property definition from the mpv manual showing filter params as being returned in a :\n\nThis clip from the mpv log file merely confirms the behavior discussed above. In it you can see that IINA is not passing the filter arguments to the remove command in the same order that was used when adding the filters due to the reordering occuring when parsing the :\n\nShould not be needed. Any file with audio should suffice."
    },
    {
        "link": "https://github.com/mpv-player/mpv/issues/12379",
        "document": "I want to know if libmpv is currently playing or paused. What should I do to obtain real-time event feedback? I don't want to proactively inquire.\n\nJust like this:"
    },
    {
        "link": "https://mpv.io/manual/stable",
        "document": "Specify a prioritized list of audio languages to use, as IETF language tags. Equivalent ISO 639-1 two-letter and ISO 639-2 three-letter codes are treated the same. The first tag in the list that matches track's language in the file will be used. A track that matches more subtags will be preferred over one that matches fewer. See also . This is a string list option. See List Options for details.\n• chooses the Hungarian language track on a DVD and falls back on English if Hungarian is not available. This is a string list option. See List Options for details.\n• chooses the Hungarian subtitle track on a DVD and falls back on English if Hungarian is not available.\n• plays a Matroska file with Brazilian Portuguese subtitles if available, and otherwise any Portuguese subtitles. Equivalent to and , for video tracks. This is a string list option. See List Options for details. Select audio track. selects the default, disables audio. See also . mpv normally prints available audio tracks on the terminal when starting playback of a file. is an alias for . or disables audio playback. (The latter variant does not work with the client API.) The track selection options ( but also and the others) sometimes expose behavior that may appear strange. Also, the behavior tends to change around with each mpv release. The track selection properties will return the option value outside of playback (as expected), but during playback, the affective track selection is returned. For example, with , the property will suddenly return after playback initialization (assuming the file has at least 2 audio tracks, and the second is the default). At mpv 0.32.0 (and some releases before), if you passed a track value for which a corresponding track didn't exist (e.g. and there was only 1 audio track), the property returned . However if another audio track was added during playback, and you tried to set the property to , nothing happened, because the option still had the value , and writing the same value has no effect. With mpv 0.33.0, the behavior was changed. Now track selection options are reset to at playback initialization, if the option had tries to select a track that does not exist. The same is done if the track exists, but fails to initialize. The consequence is that unlike before mpv 0.33.0, the user's track selection parameters are clobbered in certain situations. Also since mpv 0.33.0, trying to select a track by number will strictly select this track. Before this change, trying to select a track which did not exist would fall back to track default selection at playback initialization. The new behavior is more consistent. Setting a track selection property at runtime, and then playing a new file might reset the track selection to defaults, if the fingerprint of the track list of the new file is different. Be aware of tricky combinations of all of all of the above: for example, would first play the correct track, and the second file without audio. If you then go back the first file, its first audio track will be played, and the second file is played with audio. If you do the same thing again but instead of using you run while the file is playing, then changing to the second file will play its audio track. This is because runtime selection enables the fingerprint heuristic. Most likely this is not the end. Display the subtitle stream specified by . selects the default, disables subtitles. is an alias for . or disables subtitle decoding. (The latter variant does not work with the client API.) is an alias for . or disables video playback. (The latter variant does not work with the client API.) If video is disabled, mpv will try to download the audio only if media is streamed with youtube-dl, because it saves bandwidth. This is done by setting the ytdl_format to \"bestaudio/best\" in the ytdl_hook.lua script. (Matroska files only) Specify the edition (set of chapters) to use, where 0 is the first. If set to (the default), mpv will choose the first edition declared as a default, or if there is no default, the first edition defined. Enable the default track auto-selection (default: yes). Enabling this will make the player select streams according to , , and others. If it is disabled, no tracks are selected. In addition, the player will not exit if no tracks are selected, and wait instead (this wait mode is similar to pausing, but the pause option is not set). This is useful with : you can start playback in this mode, and then set select tracks at runtime by setting the filter graph. Note that if is set before playback is started, the referenced tracks are always selected. When autoselecting a subtitle track, select it even if the selected audio stream matches you preferred subtitle language (default: yes). If this option is set to , then no subtitle track that matches the audio language will ever be autoselected by mpv regardless of or . If set to , then only forced subtitles will be selected. When autoselecting a subtitle track, select the track that matches the language of your OS if the audio stream is in a different language if suitable (default track or a forced track under the right conditions). Note that if is set, this will be completely ignored (default: yes). When autoselecting a subtitle track, if no tracks match your preferred languages, select a full track even if it doesn't match your preferred subtitle language (default: default). Setting this to means that only streams flagged as will be selected. When autoselecting a subtitle track, the default value of will prefer using a forced subtitle track if the subtitle language matches the audio language and matches your list of preferred languages. The special value will only select forced subtitle tracks and never fallback on a non-forced track. Conversely, will never select a forced subtitle track. The general format for times is . If the time is prefixed with , the time is considered relative from the end of the file (as signaled by the demuxer/the file). A is usually ignored (but see below). The following alternative time specifications are recognized: seeks to chapter number c. (Chapters start from 1.) resets any previously set option (useful for libmpv). If is given, then prefixing times with makes the time relative to the start of the file. A timestamp without prefix is considered an absolute time, i.e. should seek to a frame with a timestamp as the file contains it. As a bug, but also a hidden feature, putting 1 or more spaces before the or always interprets the time as absolute, which can be used to seek to negative timestamps (useful for debugging at most). Seeks to the middle of the file. Seeks to 3 minutes and 20 seconds before the end of the file, plays 10 seconds, and exits. Stop at given time. Use if the time should be relative to . See for valid option values and examples. Stop after a given time relative to the start time. See for valid option values and examples. If both and are provided, playback will stop when it reaches either of the two endpoints. Obscurity note: this does not work correctly if , and the specified time is not an \"absolute\" time, as defined in the option description. Whether to move the file start time to (default: yes). This is less awkward for files which start at a random timestamp, such as transport streams. On the other hand, if there are timestamp resets, the resulting behavior can be rather weird. For this reason, and in case you are actually interested in the real timestamps, this behavior can be disabled with . Slow down or speed up playback by the factor given as parameter. If (on by default) is used, playing with a speed higher than normal automatically inserts the audio filter. Raise or lower the audio's pitch by the factor given as parameter. Does not affect playback speed. Playing with an altered pitch automatically inserts the audio filter. Since pitch change is achieved by combining pitch-preserving speed change and resampling, the range of pitch change is effectively limited by the and parameters of : for example, a of 0.25 limits the highest pitch factor to 4 (1/0.25). In a standard 12-tone scale system, octaves are separated by a factor of 2 whereas semitones are represented by a factor of 2^(1/12). This means pitches can easily be shifted up or down with a simple multiplier. Shifts the pitch down an octave. Shifts the pitch up a perfect fifth. Shifts the pitch down a perfect fifth. Set which file on the internal playlist to start playback with. The index is an integer, with 0 meaning the first file. The value means that the selection of the entry to play is left to the playback resume mechanism (default). If an entry with the given index doesn't exist, the behavior is unspecified and might change in future mpv versions. The same applies if the playlist contains further playlists (don't expect any reasonable behavior). Passing a playlist file to mpv should work with this option, though. E.g. will work as expected, as long as does not link to further playlists. The value is a deprecated alias for . Play files according to a playlist file. Supports some common formats. If no format is detected, it will be treated as list of files, separated by newline characters. You may need this option to load plaintext files as a playlist. Note that XML playlist formats are not supported. This option forces to interpret the playlist file. Some playlist formats, notably CUE and optical disc formats, need to use different demuxers and will not work with this option. They still can be played directly, without using this option. You can play playlists directly, without this option. Before mpv version 0.31.0, this option disabled any security mechanisms that might be in place, but since 0.31.0 it uses the same security mechanisms as playing a playlist file directly. If you trust the playlist file, you can disable any security checks with . Because playlists can load other playlist entries, consider applying this option only to the playlist itself and not its entries, using something along these lines: The way older versions of mpv played playlist files via was not safe against maliciously constructed files. Such files may trigger harmful actions. This has been the case for all versions of mpv prior to 0.31.0, and all MPlayer versions, but unfortunately this fact was not well documented earlier, and some people have even misguidedly recommended the use of with untrusted sources. Do NOT use with random internet sources or files you do not trust if you are not sure your mpv is at least 0.31.0. In particular, playlists can contain entries using protocols other than local files, such as special protocols like (which are inherently unsafe). Threshold for merging almost consecutive ordered chapter parts in milliseconds (default: 100). Some Matroska files with ordered chapters have inaccurate chapter end timestamps, causing a small gap between the end of one chapter and the start of the next one when they should match. If the end of one playback part is less than the given threshold away from the start of the next one then keep playing video normally over the chapter change instead of doing a seek. Distance in seconds from the beginning of a chapter within which a backward chapter seek will go to the previous chapter (default: 5.0). Past this threshold, a backward chapter seek will go to the beginning of the current chapter instead. A negative value means always go back to the previous chapter. Select when to use precise seeks that are not limited to keyframes. Such seeks require decoding video from the previous keyframe up to the target position and so can take some time depending on decoding performance. For some video formats, precise seeks are disabled. This option selects the default choice to use for seeks; it is possible to explicitly override that default in the definition of key bindings and in input commands. Use precise seeks if the seek is to an absolute position in the file, such as a chapter seek, but not for relative seeks like the default behavior of arrow keys. Like , but enable hr-seeks in audio-only cases. The exact behavior is implementation specific and may change with new releases (default). Use precise seeks whenever possible. Same as (for compatibility). This option exists to work around failures to do precise seeks (as in ) caused by bugs or limitations in the demuxers for some file formats. Some demuxers fail to seek to a keyframe before the given target position, going to a later position instead. The value of this option is subtracted from the time stamp given to the demuxer. Thus, if you set this option to 1.5 and try to do a precise seek to 60 seconds, the demuxer is told to seek to time 58.5, which hopefully reduces the chance that it erroneously goes to some time later than 60 seconds. The downside of setting this option is that precise seeks become slower, as video between the earlier demuxer position and the real target may be unnecessarily decoded. Allow the video decoder to drop frames during seek, if these frames are before the seek target. If this is enabled, precise seeking can be faster, but if you're using video filters which modify timestamps or add new frames, it can lead to precise seeking skipping the target frame. This e.g. can break frame backstepping when deinterlacing is enabled. Controls how to seek in files. Note that if the index is missing from a file, it will be built on the fly by default, so you don't need to change this. But it might help with some broken files. use an index if the file has one, or build it if missing don't read or use the file's index This option only works if the underlying media supports seeking (i.e. not with stdin, pipe, etc). Load URLs from playlists which are considered unsafe (default: no). This includes special protocols and anything that doesn't refer to normal files. Local files and HTTP links on the other hand are always considered safe. In addition, if a playlist is loaded while this is set, the added playlist entries are not marked as originating from network or potentially unsafe location. (Instead, the behavior is as if the playlist entries were provided directly to mpv command line or command.) Follow any references in the file being opened (default: yes). Disabling this is helpful if the file is automatically scanned (e.g. thumbnail generation). If the thumbnail scanner for example encounters a playlist file, which contains network URLs, and the scanner should not open these, enabling this option will prevent it. This option also disables ordered chapters, mov reference files, opening of archives, and a number of other features. On older FFmpeg versions, this will not work in some cases. Some FFmpeg demuxers might not respect this option. This option does not prevent opening of paired subtitle files and such. Use to prevent this. This option does not always work if you open non-files (for example using would open a whole bunch of files in the given directory). Prefixing the filename with if it doesn't start with a will avoid this. Loops playback times. A value of plays it one time (default), two times, etc. means forever. is the same as and disables looping. If several files are specified on command line, the entire playlist is looped. is the same as . The mode is like , but does not skip playlist entries which have been marked as failing. This means the player might waste CPU time trying to loop a file that doesn't exist. But it might be useful for playing webradios under very bad network conditions. Loop a single file N times. means forever, means normal playback. For compatibility, and are also accepted, and are the same as . The difference to is that this doesn't loop the playlist, just the file itself. If the playlist contains only a single file, the difference between the two option is that this option performs a seek on loop, instead of reloading the file. counts the number of times it causes the player to seek to the beginning of the file, not the number of full playthroughs. This means will end up playing the file twice. Contrast with , which counts the number of full playthroughs. is an alias for this option. Set loop points. If playback passes the timestamp, it will seek to the timestamp. Seeking past the point doesn't loop (this is intentional). If is after , the behavior is as if the points were given in the right order, and the player will seek to after crossing through . This is different from old behavior, where looping was disabled (and as a bug, looped back to on the end of the file). If either options are set to (or unset), looping is disabled. This is different from old behavior, where an unset implied the start of the file, and an unset the end of the file. The loop-points can be adjusted at runtime with the corresponding properties. See also command. Run A-B loops only N times, then ignore the A-B loop points (default: inf). means that looping goes on forever. If this option is set to 0, A-B looping is ignored, and even the command will not enable looping again (the command will show on the OSD message if both loop points are set, but is 0). Enable support for Matroska ordered chapters. mpv will load and search for video segments from other files, and will also respect any chapter order specified for the main file (default: yes). Loads the given file as playlist, and tries to use the files contained in it as reference files when opening a Matroska file that uses ordered chapters. This overrides the normal mechanism for loading referenced files by scanning the same directory the main file is located in. Useful for loading ordered chapter files that are not located on the local filesystem, or if the referenced files are in different directories. Note: a playlist can be as simple as a text file containing filenames separated by newlines. Load chapters from this file, instead of using the chapter metadata found in the main file. This accepts a media file (like mkv) or even a pseudo-format like ffmetadata and uses its chapters to replace the current file's chapters. This doesn't work with OGM or XML chapters directly. Without , skipping will snap to keyframes. Stop playback if either audio or video fails to initialize (default: no). With , playback will continue in video-only or audio-only mode if one of them fails. This doesn't affect playback of audio-only or video-only files. Control the playback direction (default: forward). Setting will attempt to play the file in reverse direction, with decreasing playback time. If this is set on playback starts, playback will start from the end of the file. If this is changed at during playback, a hr-seek will be issued to change the direction. and are aliases for and . The rest of this option description pertains to the mode. Backward playback is extremely fragile. It may not always work, is much slower than forward playback, and breaks certain other features. How well it works depends mainly on the file being played. Generally, it will show good results (or results at all) only if the stars align. mpv, as well as most media formats, were designed for forward playback only. Backward playback is bolted on top of mpv, and tries to make a medium effort to make backward playback work. Depending on your use-case, another tool may work much better. Backward playback is not exactly a 1st class feature. Implementation tradeoffs were made, that are bad for backward playback, but in turn do not cause disadvantages for normal playback. Various possible optimizations are not implemented in order to keep the complexity down. Normally, a media player is highly pipelined (future data is prepared in separate threads, so it is available in realtime when the next stage needs it), but backward playback will essentially stall the pipeline at various random points. For example, for intra-only codecs are trivially backward playable, and tools built around them may make efficient use of them (consider video editors or camera viewers). mpv won't be efficient in this case, because it uses its generic backward playback algorithm, that on top of it is not very optimized. If you just want to quickly go backward through the video and just show \"keyframes\", just use forward playback, and hold down the left cursor key (which on CLI with default config sends many small relative seek commands). The implementation consists of mostly 3 parts:\n• Backward demuxing. This relies on the demuxer cache, so the demuxer cache should (or must, didn't test it) be enabled, and its size will affect performance. If the cache is too small or too large, quadratic runtime behavior may result.\n• Backward decoding. The decoder library used (libavcodec) does not support this. It is emulated by feeding bits of data in forward, putting the result in a queue, returning the queue data to the VO in reverse, and then starting over at an earlier position. This can require buffering an extreme amount of decoded data, and also completely breaks pipelining.\n• Backward output. This is relatively simple, because the decoder returns the frames in the needed order. However, this may cause various problems because filters see audio and video going backward.\n• It's fragile. If anything doesn't work, random non-useful behavior may occur. In simple cases, the player will just play nonsense and artifacts. In other cases, it may get stuck or heat the CPU. (Exceeding memory usage significantly beyond the user-set limits would be a bug, though.)\n• Performance and resource usage isn't good. In part this is inherent to backward playback of normal media formats, and in parts due to implementation choices and tradeoffs.\n• This is extremely reliant on good demuxer behavior. Although backward demuxing requires no special demuxer support, it is required that the demuxer performs seeks reliably, fulfills some specific requirements about packet metadata, and has deterministic behavior.\n• Starting playback exactly from the end may or may not work, depending on seeking behavior and file duration detection.\n• Some container formats, audio, and video codecs are not supported due to their behavior. There is no list, and the player usually does not detect them. Certain live streams (including TV captures) may exhibit problems in particular, as well as some lossy audio codecs. h264 intra-refresh is known not to work due to problems with libavcodec. WAV and some other raw audio formats tend to have problems - there are hacks for dealing with them, which may or may not work.\n• Backward demuxing of subtitles is not supported. Subtitle display still works for some external text subtitle formats. (These are fully read into memory, and only backward display is needed.) Text subtitles that are cached in the subtitle renderer also have a chance to be displayed correctly.\n• Some features dealing with playback of broken or hard to deal with files will not work fully (such as timestamp correction).\n• If demuxer low level seeks (i.e. seeking the actual demuxer instead of just within the demuxer cache) are performed by backward playback, the created seek ranges may not join, because not enough overlap is achieved.\n• Trying to use this with hardware video decoding will probably exhaust all your GPU memory and then crash a thing or two. Or it will fail because will certainly be set too low.\n• Stream recording is broken. may keep working if you backward play within a cached region only.\n• Relative seeks may behave weird. Small seeks backward (towards smaller time, i.e. ) may not really seek properly, and audio will remain muted for a while. Using hr-seek is recommended, which should have none of these problems.\n• Some things are just weird. For example, while seek commands manipulate playback time in the expected way (provided they work correctly), the framestep commands are transposed. Backstepping will perform very expensive work to step forward by 1 frame.\n• Remove all / filters you have set. Disable hardware decoding. Disable functions like SPDIF passthrough.\n• Increasing might help if reversal queue overflow is reported, which may happen in high bitrate video, or video with large GOP. Hardware decoding mostly ignores this, and you need to increase instead (until you get playback without logged errors).\n• The demuxer cache is essential for backward demuxing. Make sure to set . The cache size might matter. If it's too small, a queue overflow will be logged, and backward playback cannot continue, or it performs too many low level seeks. If it's too large, implementation tradeoffs may cause general performance issues. Use to potentially increase the amount of packets the demuxer layer can queue for reverse demuxing (basically it's the equivalent for the demuxer layer).\n• Setting can help a lot to make playback smooth (once it works).\n• also factors into how many seeks may be performed, and whether backward demuxing could break due to queue overflow. If it's set too high, the backstep operation needs to search through more packets all the time, even if the cache is large enough.\n• Setting may be useful to cache the entire file into the demuxer cache. Set to a large size to make sure it can read the entire cache; should also be set to a large size to prevent that tries to trim the cache.\n• If audio artifacts are audible, even though the AO does not underrun, increasing might help in some cases. For backward decoding. Backward decoding decodes forward in steps, and then reverses the decoder output. These options control the approximate maximum amount of bytes that can be buffered. The main use of this is to avoid unbounded resource usage; during normal backward playback, it's not supposed to hit the limit, and if it does, it will drop frames and complain about it. Use this option if you get reversal queue overflow errors during backward playback. Increase the size until the warning disappears. Usually, the video buffer will overflow first, especially if it's high resolution video. This does not work correctly if video hardware decoding is used. The video frame size will not include the referenced GPU and driver memory. Some hardware decoders may also be limited by . How large the queue size needs to be depends entirely on the way the media was encoded. Audio typically requires a very small buffer, while video can require excessively large buffers. This does not affect demuxer cache behavior at all. See for defaults and value range. options accept suffixes such as and . Number of overlapping keyframe ranges to use for backward decoding (default: auto) (\"keyframe\" to be understood as in the mpv/ffmpeg specific meaning). Backward decoding works by forward decoding in small steps. Some codecs cannot restart decoding from any packet (even if it's marked as seek point), which becomes noticeable with backward decoding (in theory this is a problem with seeking too, but can fix it for seeking). In particular, MDCT based audio codecs are affected. The solution is to feed a previous packet to the decoder each time, and then discard the output. This option controls how many packets to feed. The choice is currently hardcoded to 0 for video, and uses 1 for lossy audio, 0 for lossless audio. For some specific lossy audio codecs, this is set to 2. can potentially handle intra-refresh video, depending on the exact conditions. You may have to use the option as well. Number of keyframe ranges to decode at once when backward decoding (default: 1 for video, 10 for audio). Another pointless tuning parameter nobody should use. This should affect performance only. In theory, setting a number higher than 1 for audio will reduce overhead due to less frequent backstep operations and less redundant decoding work due to fewer decoded overlap frames (see ). On the other hand, it requires a larger reversal buffer, and could make playback less smooth due to breaking pipelining (e.g. by decoding a lot, and then doing nothing for a while). It probably never makes sense to set . But in theory, it could help with intra-only video codecs by reducing backstep operations. Number of seconds the demuxer should seek back to get new packets during backward playback (default: 60). This is useful for tuning backward playback, see for details. Setting this to a very low value or 0 may make the player think seeking is broken, or may make it perform multiple seeks. Setting this to a high value may lead to quadratic runtime behavior. You can also pass a string to this option, which will list all top-level options which contain the string in the name, e.g. for all options that contain the word . The special string lists all top-level options. Increment verbosity level, one level for each found on the command line. Do not load default configuration or any user files. This prevents loading of both the user-level and system-wide and files. Other user files are blocked as well, such as resume playback files and cache files. This option only takes effect when used as a command line flag. Files explicitly requested by command line options, like or , will still be loaded. Print a list of the available properties. Opens the given path for writing, and print log messages to it. Existing files will be truncated. The log level is at least , but can be raised via (the option cannot lower it below the forced minimum log level). A special case is the macOS bundle, it will create a log file at by default. Force a different configuration directory. If this is set, the given directory is used to load configuration files, and all other configuration directories are ignored. This means the global mpv configuration directory as well as per-user directories are ignored, and overrides through environment variables ( ) are also ignored. Note that the cache and state paths ( , ) are not considered \"configuration\" and keep their auto-detection logic. Note that the option takes precedence over this option. Write certain statistics to the given file. The file is truncated on opening. The file will contain raw samples, each with a timestamp. To make this file into a readable, the script can be used (which currently displays it as a graph). This option is useful for debugging only. Makes mpv wait idly instead of quitting when there is no file to play. Mostly useful in input mode, where mpv can be controlled through input commands. (Default: ) will only idle at start and let the player close once the first playlist has finished playing back. Specify configuration file to be parsed after the default ones. If set to , don't auto-load scripts from the configuration subdirectory (usually ). (Default: ) Load a Lua script. The second option allows you to load multiple scripts by separating them with the path separator ( on Unix, on Windows). is a path list option. See List Options for details. Set options for scripts. A script can query an option by key. If an option is used and what semantics the option value has depends entirely on the loaded scripts. Values not claimed by any scripts are ignored. This is a key/value list option. See List Options for details. Pretend that all files passed to mpv are concatenated into a single, big file. This uses timeline/EDL support internally. Use the given profile(s), displays a list of the defined profiles. Normally, mpv will try to keep all settings when playing the next file on the playlist, even if they were changed by the user during playback. (This behavior is the opposite of MPlayer's, which tries to reset all settings when starting next file.) Default: Do not reset anything. This can be changed with this option. It accepts a list of options, and mpv will reset the value of these options on playback start to the initial value. The initial value is either the default value, or as set by the config file or command line. The special name resets as many options as possible. This is a string list option. See List Options for details.\n• Reset pause mode when switching to the next file.\n• Reset fullscreen and playback speed settings if they were changed during playback.\n• Try to reset all settings that were changed during playback. Show the description and content of a profile. Lists all profiles if no parameter is provided. Look for a file-specific configuration file in the same directory as the file that is being played. See File-specific Configuration Files. May be dangerous if playing from untrusted media. Enable the youtube-dl hook-script. It will look at the input URL, and will play the video located on the website. This works with many streaming sites, not just the one that the script is named after. This requires a recent version of youtube-dl to be installed on the system (default: yes). If the script can't do anything with an URL, it will do nothing. This accepts a set of options, which can be passed to it with the option (using as prefix): If 'yes' will try parsing the URL with youtube-dl first, instead of the default where it's only after mpv failed to open it. This mostly depends on whether most of your URLs need youtube-dl parsing. A -separated list of URL patterns which mpv should not use with youtube-dl. The patterns are matched after the part of the URL. matches the beginning of the URL, matches its end, and you should use before any of the characters to match that character.\n• will exclude any URL that starts with or .\n• will exclude any URL that ends with or . See more lua patterns here: https://www.lua.org/manual/5.1/manual.html#5.4.1 If 'yes' will attempt to add all formats found reported by youtube-dl (default: no). Each format is added as a separate track. In addition, they are delay-loaded, and actually opened only when a track is selected (this should keep load times as low as without this option). It adds average bitrate metadata, if available, which means you can use to decide which track to select. (HLS used to be the only format whose alternative quality streams were exposed in a similar way, thus the option name.) Tracks which represent formats that were selected by youtube-dl as default will have the default flag set. This means mpv should generally still select formats chosen with by default. Although this mechanism makes it possible to switch streams at runtime, it's not suitable for this purpose for various technical reasons. (It's slow, which can't be really fixed.) In general, this option is not useful, and was only added to show that it's possible. There are two cases that must be considered when doing quality/bandwidth selection:\n• None Completely separate audio and video streams (DASH-like). Each of these streams contain either only audio or video, so you can mix and combine audio/video bandwidths without restriction. This intuitively matches best with the concept of selecting quality by track (what is supposed to do).\n• None Separate sets of muxed audio and video streams. Each version of the media contains both an audio and video stream, and they are interleaved. In order not to waste bandwidth, you should only select one of these versions (if, for example, you select an audio stream, then video will be downloaded, even if you selected video from a different stream). mpv will still represent them as separate tracks, but will set the title of each track to , where is replaced with the youtube-dl format ID of the originating stream. Some sites will mix 1. and 2., but we assume that they do so for compatibility reasons, and there is no reason to use them at all. If set to 'yes', and is also set to 'yes', this will try to represent all youtube-dl reported formats as tracks, even if mpv would normally use the direct URL reported by it (default: yes). It appears this normally makes a difference if youtube-dl works on a master HLS playlist. If this is set to 'no', this specific kind of stream is treated like is set to 'no', and the stream selection as done by youtube-dl (via ) is used. Thumbnails get downloaded when they are added as tracks, so 'all' can have a noticable impact on how long it takes to open the video when there are a lot of thumbnails. Make mpv use the master manifest URL for formats like HLS and DASH, if available, allowing for video/audio selection in runtime (default: no). It's disabled (\"no\") by default for performance reasons. Configure paths to youtube-dl's executable or a compatible fork's. The paths should be separated by : on Unix and ; on Windows. mpv looks in order for the configured paths in PATH and in mpv's config directory. The defaults are \"yt-dlp\", \"yt-dlp_x86\" and \"youtube-dl\". On Windows the suffix extension is not necessary, but only \".exe\" is acceptable. Why do the option names mix and ? Video format/quality that is directly passed to youtube-dl. The possible values are specific to the website and the video, for a given url the available formats can be found with the command . See youtube-dl's documentation for available aliases. (Default: ) The value does not pass a option to youtube-dl at all, and thus does not override its default. Note that sometimes youtube-dl returns a format that mpv cannot use, and in these cases the mpv default may work better. Pass arbitrary options to youtube-dl. Parameter and argument should be passed as a key-value pair. Options without argument must include . There is no sanity checking so it's possible to break things (i.e. passing invalid parameters to youtube-dl). A proxy URL can be passed for youtube-dl to use it in parsing the website. This is useful for geo-restricted URLs. After youtube-dl parsing, some URLs also require a proxy for playback, so this can pass that proxy information to mpv. Take note that SOCKS proxies aren't supported and https URLs also bypass the proxy. This is a limitation in FFmpeg. This is a key/value list option. See List Options for details. Enable memory reporting for javascript scripts in the stats overlay. This is disabled by default because it has an overhead and increases memory usage. This option will only work if it is enabled before mpv is started. Enable the builtin script that shows useful playback information on a key binding (default: yes). By default, the key is used ( to make the overlay permanent). Enable the built-in script that shows a console on a key binding and lets you enter commands (default: yes). The key is used to show the console by default, and to hide it again. Enable the builtin script that does auto profiles (default: auto). See Conditional auto profiles for details. will load the script, but immediately unload it if there are no conditional profiles. Enable the builtin script that lets you select from lists of items (default: yes). By default, its keybindings start with the key. For enabling \"pseudo GUI mode\", which means that the defaults for some options are changed. This option should not normally be used directly, but only by mpv internally, or mpv-provided scripts, config files, or .desktop files. See PSEUDO GUI MODE for details. Always save the current playback position on quit. When this file is played again later, the player will seek to the old playback position on start. This does not happen if playback of a file is stopped in any other way than quitting. For example, going to the next file in the playlist will not save the position, and start playback at beginning the next time the file is played. This behavior is disabled by default, but is always available when quitting the player with Shift+Q. The directory in which to store the \"watch later\" temporary files. is an alias for . If this option is unset, the files will be stored in a subdirectory named \"watch_later\" underneath the local state directory (usually ). Restore playback position from the configuration subdirectory, usually (default: yes). Only restore the playback position from the configuration subdirectory (usually ) if the file's modification time is the same as at the time of saving. This may prevent skipping forward in files with the same name which have different content. (Default: ) The options that are saved in \"watch later\" files if they have been changed since when mpv started. These values will be restored the next time the files are played. Note that the playback position is saved via the option. When removing options, existing watch later data won't be modified and will still be applied fully, but new watch later data won't contain these options. See for the list of the properties that are restored by default. This is a string list option. See List Options for details.\n• The subtitle track selection will not be restored.\n• The volume and mute state won't be saved to watch later files.\n• No option will be saved to watch later files, except the playback position. Prepend the watch later config files with the name of the file they refer to. This is simply written as comment on the top of the file. This option may expose privacy-sensitive information and is thus disabled by default. Ignore path (i.e. use filename only) when using watch later feature. (Default: disabled) Specify the video output backend to be used. See VIDEO OUTPUT DRIVERS for details and descriptions of available drivers. Specify a priority list of video decoders to be used, according to their family and name. See for further details. Both of these options use the same syntax and semantics; the only difference is that they operate on different codec lists. See for a full list of available decoders. Specify a list of video filters to apply to the video stream. See VIDEO FILTERS for details and descriptions of the available filters. The option variants , , and exist to modify a previously specified list, but you should not need these for typical use. Do not sleep when outputting video frames. Useful for benchmarks when used with . Skip displaying some frames to maintain A/V sync on slow systems, or playing high framerate video on video outputs that have an upper framerate limit. The argument selects the drop methods, and can be one of the following: Disable any frame dropping. Not recommended, for testing only. Drop late frames on video output (default). This still decodes and filters all frames, but doesn't render them on the VO. Drops are indicated in the terminal status line as field. In audio sync. mode, this drops frames that are outdated at the time of display. If the decoder is too slow, in theory all frames would have to be dropped (because all frames are too late) - to avoid this, frame dropping stops if the effective framerate is below 10 FPS. In display-sync. modes (see ), this affects only how A/V drops or repeats frames. If this mode is disabled, A/V desync will in theory not affect video scheduling anymore (much like the mode). However, even if disabled, frames will still be skipped (i.e. dropped) according to the ratio between video and display frequencies. This is the recommended mode, and the default. Old, decoder-based framedrop mode. (This is the same as in mpv 0.5.x and before.) This tells the decoder to skip frames (unless they are needed to decode future frames). May help with slow systems, but can produce unwatchable choppy output, or even freeze the display completely. This uses a heuristic which may not make sense, and in general cannot achieve good results, because the decoder's frame dropping cannot be controlled in a predictable manner. Not recommended. Even if you want to use this, prefer for better results. The option controls what frames to drop. Enable both modes. Not recommended. Better than just mode. has its own code for the framedrop mode. Slight differences to other VOs are possible. Enable some things which tend to reduce video latency by 1 or 2 frames (default: no). Note that this option might be removed without notice once the player's timing code does not inherently need to do these things anymore. Using this option is known to break other options such as interpolation, so it is not recommended to enable this.\n• Use the demuxer reported FPS for frame dropping. This avoids the player needing to decode 1 frame in advance, lowering total latency in effect. This also means that if the demuxer reported FPS is wrong, or the video filter chain changes FPS (e.g. deinterlacing), then it could drop too many or not enough frames.\n• Disable waiting for the first video frame. Normally the player waits for the first video frame to be fully rendered before starting playback properly. Some VOs will lazily initialize stuff when rendering the first frame, so if this is not done, there is some likeliness that the VO has to drop some frames if rendering the first frame takes longer than needed. Set the display FPS used with the modes. By default, a detected value is used. Keep in mind that setting an incorrect value (even if slightly incorrect) can ruin video playback. On multi-monitor systems, there is a chance that the detected value is from the wrong monitor. Set this option only if you have reason to believe the automatically determined value is wrong. Specify the hardware video decoding API that should be used if possible. Whether hardware decoding is actually done depends on the video codec. If hardware decoding is not possible, mpv will fall back on software decoding. Hardware decoding is not enabled by default, to keep the out-of-the-box configuration as reliable as possible. However, when using modern hardware, hardware video decoding should work correctly, offering reduced CPU usage, and possibly lower power consumption. On older systems, it may be necessary to use hardware decoding due to insufficient CPU resources; and even on modern systems, sufficiently complex content (eg: 4K60 AV1) may require it. Use the shortcut to toggle hardware decoding at runtime. It toggles this option between and . If you decide you want to use hardware decoding by default, the general recommendation is to try out decoding with the command line option, and prove to yourself that it works as desired for the content you care about. After that, you can add it to your config file. When testing, you should start by using as it will limit itself to choosing from hwdecs that are actively supported by the development team. If that doesn't result in working hardware decoding, you can try to have it attempt to load every possible hwdec, but if didn't work, you will probably need to know exactly which hwdec matches your hardware and read up on that entry below. If or produced the desired results, we recommend just sticking with that and only setting a specific hwdec in your config file if it is really necessary. If you use the Ubuntu package, keep in mind that their contains , which is less than ideal as it may not be the right choice for your system, and it may end up using an inefficient wrapper library under the covers. We recommend removing this line or deleting the file altogether. Even if enabled, hardware decoding is still only white-listed for some codecs. See to enable hardware decoding in more cases.\n• If you only want to enable hardware decoding at runtime, don't set the parameter, or put into your (relevant on distros which force-enable it by default, such as on Ubuntu). Use the default binding to enable it at runtime.\n• If you're not sure, but want hardware decoding always enabled by default, put into your , and acknowledge that this may cause problems.\n• If you want to test available hardware decoding methods, pass and look at the terminal output.\n• If you're a developer, or want to perform elaborate tests, you may need any of the other possible option values. This option accepts a comma delimited list of types, along with certain special values: enable any whitelisted hw decoder (see below) forcibly enable any hw decoder found (see below) exactly the same as enable best hw decoder with copy-back (see below) Special values can be mixed with api names. eg: will try and use the hwdec, and if that fails, will run through the normal logic. requires with or (Windows 8+ only) requires (macOS 10.8 and up), or (iOS 9.0 and up) copies video back into system RAM (macOS 10.8 or iOS 9.0 and up) copies video back into system RAM (Linux with some GPUs or Windows) requires (Any platform CUDA is available) copies video back to system RAM (Any platform CUDA is available) copies video back to system RAM (Any platform with Vulkan Video Decoding) Other hwdecs (only use if you know you have to): requires with , or (Windows only) requires with , or (Linux only) copies video back into system RAM (Linux with some GPUs only) requires (Any platform CUDA is available) copies video back to system RAM (Any platform CUDA is available) copies video back to system RAM (Any platform supported by hardware) tries to automatically enable hardware decoding using the first available method. This still depends what VO you are using. See the list above, for which and is required for a given hwdec. It will go down the list of available hwdecs until one is successfully initialised. If all of them fail, it will fallback to software decoding. is similar to , but allows only whitelisted methods that are considered \"safe\". This is supposed to be a reasonable way to enable hardware decdoding by default in a config file (even though you shouldn't do that anyway; prefer runtime enabling with ). Unlike , this will not try to enable unknown or known-to-be-bad methods. In addition, this may disable hardware decoding in other situations when it's known to cause problems, but currently this mechanism is quite primitive. (As an example for something that still causes problems: certain combinations of HEVC and Intel chips on Windows tend to cause mpv to crash, most likely due to driver bugs.) selects the union of methods selected with and . selects only modes that copy the video data back to system memory after decoding. This selects modes like (and so on). If none of these work, hardware decoding is disabled. This mode is usually guaranteed to incur no additional quality loss compared to software decoding (assuming modern codecs and an error free video stream), and will allow CPU processing with video filters. This mode works with all video filters and VOs. Because these copy the decoded video back to system RAM, they're often less efficient than the direct modes, and may not help too much over software decoding if you are short on CPU resources. Most non-copy methods only work with the OpenGL GPU backend. Currently, only the , , and methods work with Vulkan. The mode, if used with , requires Mesa 11, and most likely works with Intel and AMD GPUs only. It also requires the opengl EGL backend. and are the newest, and recommended method to do hardware decoding on Nvidia GPUs. and are an older implementation of hardware decoding on Nvidia GPUs that uses Nvidia's bitstream parsers rather than FFmpeg's. This can lead to feature deficiencies, such as incorrect playback of HDR content, and / should always be preferred unless you specifically need Nvidia's deinterlacing algorithms. To use this deinterlacing you must pass the option: . Pass (or leave the option unset) to not attempt any deinterlacing. In theory, hardware decoding does not reduce video quality (at least for the codecs h264 and HEVC). However, due to restrictions in video output APIs, as well as bugs in the actual hardware decoders, there can be some loss, or even blatantly incorrect results. This has largely ceased to be a problem with modern hardware, but there is a lot of hardware out there, so caveat emptor. Known problems are discussed below, but the list cannot be considered exhaustive, as even hwdecs that work well on certain hardware generations may be problematic on other ones. In some cases, RGB conversion is forced, which means the RGB conversion is performed by the hardware decoding API, instead of the shaders used by . This means certain colorspaces may not display correctly, and certain filtering (such as debanding) cannot be applied in an ideal way. This will also usually force the use of low quality chroma scalers instead of the one specified by . In other cases, hardware decoding can also reduce the bit depth of the decoded image, which can introduce banding or precision loss for 10-bit files. always does RGB conversion in hardware, which does not support newer colorspaces like BT.2020 correctly. However, doesn't support 10 bit or HDR encodings, so these limitations are unlikely to be relevant. is not safe. It appears to always use BT.601 for forced RGB conversion, but actual behavior depends on the GPU drivers. Some drivers appear to convert to limited range RGB, which gives a faded appearance. In addition to driver-specific behavior, global system settings might affect this additionally. This can give incorrect results even with completely ordinary video sources. is not safe. It forces RGB conversion (not with ) and how well it handles non-standard colorspaces is not known. In the rare cases where 10-bit is supported the bit depth of the output will be reduced to 8. should usually be safe, but depending on how a file/stream has been mixed, it has been reported to corrupt the timestamps causing glitched, flashing frames. It can also sometimes cause massive framedrops for unknown reasons. Caution is advised, and should always be preferred. is not safe. It always converts to 4:2:2 YUV, which may be lossy, depending on how chroma sub-sampling is done during conversion. It also discards the top left pixel of each frame for some reason. If you run into any weird decoding issues, frame glitches or discoloration, and you have turned on, the first thing you should try is disabling it. This option is for troubleshooting hwdec interop issues. Since it's a debugging option, its semantics may change at any time. This is useful for the and VOs for selecting which hwdec interop context to use exactly. Effectively it also can be used to block loading of certain backends. If set to (default), the behavior depends on the VO: for , it does nothing, and the interop context is loaded on demand (when the decoder probes for support). For , which has has no on-demand loading, this is equivalent to . The empty string is equivalent to . If set to , it attempts to load all interop contexts at GL context creation time. Other than that, a specific backend can be set, and the list of them can be queried with (mpv CLI only). Runtime changes to this are ignored (the current option value is used whenever the renderer is created). Number of GPU frames hardware decoding should preallocate (default: see output). If this is too low, frame allocation may fail during decoding, and video frames might get dropped and/or corrupted. Setting it too high simply wastes GPU memory and has no advantages. This value is used only for hardware decoding APIs which require preallocating surfaces (known examples include and ). For other APIs, frames are allocated as needed. The details depend on the libavcodec implementations of the hardware decoders. The required number of surfaces depends on dynamic runtime situations. The default is a fixed value that is thought to be sufficient for most uses. But in certain situations, it may not be enough. Set the internal pixel format used by hardware decoding via (default ). The special value selects an implementation specific standard format. Most decoder implementations support only one format, and will fail to initialize if the format is not supported. Some implementations might support multiple formats. In particular, videotoolbox is known to require for good performance on some older hardware. d3d11va can always use , which uses an opaque format, with likely no advantages. Choose the GPU device used for decoding when using the or hwdecs with the OpenGL GPU backend, and with the or hwdecs in all cases. For the OpenGL GPU backend, the default device used for decoding is the one being used to provide output (and in the vast majority of cases, only one GPU will be present). For the hwdecs, the default device will be the first device enumerated by the CUDA libraries - however that is done. For the Vulkan GPU backend, decoding must always happen on the display device, and this option has no effect. Choose the DRM device for . This should be the path to a DRM device file. (Default: ) On Windows this takes adapter name as an input. Will pick the default adapter if unset. Alternatives are listed when the name \"help\" is given. Enables pan-and-scan functionality (cropping the sides of e.g. a 16:9 video to make it fit a 4:3 display without black bands). The range controls how much of the image is cropped. May not work with all video output drivers. This option has no effect if option is used. Override video aspect ratio, in case aspect information is incorrect or missing in the file being played. use the video stream or container aspect (default) But note that handling of these special values might change in the future. This sets the default video aspect determination method (if the aspect is _not_ overridden by the user with or others). Strictly prefer the container aspect ratio. This is apparently the default behavior with VLC, at least with Matroska. Note that if the container has no aspect ratio set, the behavior is the same as with bitstream. Strictly prefer the bitstream aspect ratio, unless the bitstream aspect ratio is not set. This is apparently the default behavior with XBMC/kodi, at least with Matroska. The current default for mpv is . Normally you should not set this. Try the various choices if you encounter video that has the wrong aspect ratio in mpv, but seems to be correct in other players. Disable scaling of the video. If the window is larger than the video, black bars are added. Otherwise, the video is cropped, unless the option is set to , in which case the video is fit to window. The video still can be influenced by the other options. This option disables the effect of . Note that the scaler algorithm may still be used, even if the video isn't scaled. For example, this can influence chroma conversion. The video will also still be scaled in one dimension if the source uses non-square pixels (e.g. anamorphic widescreen DVDs). This option is disabled if is used. Moves the displayed video rectangle by the given value in the X or Y direction. The unit is in fractions of the size of the scaled video (the full size, even if parts of the video are not visible due to panscan or other options). For example, displaying a video fullscreen on a 1920x1080 screen with would move the video 192 pixels to the left and would move the video 108 pixels up. This option is disabled if is used. Rotate the video clockwise, in degrees. If is given, the video is never rotated, even if the file has rotation metadata. (The rotation value is added to the rotation metadata, which means the value would rotate the video according to the rotation metadata.) When using hardware decoding without copy-back, only 90° steps work, while software decoding and hardware decoding methods that copy the video back to system memory support all values between 0 and 359. Crop the video by starting at the x, y offset for w, h pixels. The crop is applied to the source video rectangle (before anamorphic stretch) by the VO. A crop rectangle that is not within the video rectangle will be ignored. This works with hwdec, unlike the equivalent 'lavfi-crop'. When offset is omitted, the central area will be cropped. Setting the crop to empty one overrides container crop and disables cropping. Setting the crop to disables manual cropping and restores the container crop if it's specified. Adjust the video display scale factor by the given value. The parameter is given log 2. For example, is unscaled, is twice the size, is one fourth of the size, and so on. This option is disabled if is used. Multiply the video display size with the given value (default: 1.0). If a non-default value is used, this will be different from the window size, so video will be either cut off, or black bars are added. This value is multiplied with the value derived from and the normal video aspect ratio. This option is disabled if is used. Moves the video rectangle within the black borders, which are usually added to pad the video to screen if video and screen aspect ratios are different. would move the video to the top of the screen (leaving a border only on the bottom), a value of centers it (default), and a value of would put the video at the bottom of the screen. If video and screen aspect match perfectly, these options do nothing. This option is disabled if is used. Set extra video margins on each border (default: 0). Each value is a ratio of the window size, using a range 0.0-1.0. For example, setting the option at a window size of 1000 pixels will add a 200 pixels border on the right side of the window. The video is \"boxed\" by these margins. The window size is not changed. In particular it does not enlarge the window, and the margins will cause the video to be downscaled by default. This may or may not change in the future. The margins are applied after 90° video rotation, but before any other video transformations. This option is disabled if is used. Subtitles still may use the margins, depending on and similar options. These options were created for the OSC. Some odd decisions, such as making the margin values a ratio (instead of pixels), were made for the sake of the OSC. It's possible that these options may be replaced by ones that are more generally useful. The behavior of these options may change to fit OSC requirements better, too. switches mpv to a mode where video timing is determined using a fixed framerate value (either using the option, or using file information). Sometimes, files with very broken timestamps can be played somewhat well in this mode. Note that video filters, subtitle rendering, seeking (including hr-seeks and backstepping), and audio synchronization can be completely broken in this mode. Override video framerate. Useful if the original value is wrong or missing. Enable or disable deinterlacing (default: no). Interlaced video shows ugly comb-like artifacts, which are visible on fast movement. Enabling this typically inserts the bwdif video filter in order to deinterlace the video, or lets the video output apply deinterlacing if supported. When using , mpv will insert a deinterlacing filter if ffmpeg detects that the video frame is interlaced. Be aware that there can be false positives in certain cases, such as when files are encoded as interlaced despite the video not actually being so. This is why is not the default value. Keep in mind that using this filter will conflict with any manually inserted deinterlacing filters, and that this will make video look worse if it's not actually interlaced. Specify the field parity/order when deinterlacing (default: auto). Each frame of an interlaced video is divided into two fields, which are then separately transmitted. Top field represents even lines while bottom field represents odd lines. When deinterlacing the deinterlacer needs to know the correct temporal order of the fields else the video will appear jittery. will automatically try to detect the field order of the video, forces top field first while forces bottom field first. Play/convert only first video frames, then quit. loads the file, but immediately quits before initializing playback. (Might be useful for scripts which just want to determine some file properties.) For audio-only playback, any value greater than 0 will quit playback immediately after initialization. The value 0 works as with video. RGB color levels used with YUV to RGB conversion. Normally, output devices such as PC monitors use full range color levels. However, some TVs and video monitors expect studio RGB levels. Providing full range output to a device expecting studio level input results in crushed blacks and whites, the reverse in dim gray blacks and dim whites. Not all VOs support this option. Some will silently ignore it. It is advisable to use your graphics driver's color range option instead, if available. Allow hardware decoding for a given list of codecs only. The special value always allows all codecs. You can get the list of allowed codecs with . Remove the prefix, e.g. instead of use . By default, this is set to . Note that the hardware acceleration special codecs like are not relevant anymore, and in fact have been removed from FFmpeg in this form. This is usually only needed with broken GPUs, where a codec is reported as supported, but decoding causes more problems than it solves. On some broken drivers (e.g. NVIDIA on Linux), probing for codecs which the GPU does not support can unnecessarily slow down video playback initialization. To alleviate this, explicitly specify a list which only includes the codecs supported on the setup. Enable vdpau decoding for h264 and mpeg2 only. Check hardware decoder profile (default: yes). If is set, the highest profile of the hardware decoder is unconditionally selected, and decoding is forced even if the profile of the video is higher than that. The result is most likely broken decoding, but may also help if the detected or reported profiles are somehow incorrect. Fallback to software decoding if the hardware-accelerated decoder fails (default: 3). If this is a number, then fallback will be triggered if N frames fail to decode in a row. 1 is equivalent to . Setting this to a higher number might break the playback start fallback: if a fallback happens, parts of the file will be skipped, approximately by to the number of packets that could not be decoded. Values below an unspecified count will not have this problem, because mpv retains the packets. Enables film grain application on the GPU. If video decoding is done on the CPU, doing film grain application on the GPU can speed up decoding. This option can also help hardware decoding, as it can reduce the number of frame copies done. By default, it's set to , so if the VO supports film grain application, then it will be treated as . If the VO does not support this, then it will be treated as , regardless of the setting. Currently, only supports film grain application. Enable direct rendering (default: auto). If this is set to , the video will be decoded directly to GPU video memory (or staging buffers). This can speed up video upload, and may help with large resolutions or slow hardware. This works only with the following VOs:\n• : requires at least OpenGL 4.4 or Vulkan. The option will try to guess whether DR can improve performance on your particular hardware. Currently this enables it on AMD or NVIDIA if using OpenGL or unconditionally if using Vulkan. Using video filters of any kind that write to the image data (or output newly allocated frames) will silently disable the DR code path. Only use bit-exact algorithms in all decoding steps (for codec testing). Enable optimizations which do not comply with the format specification and potentially cause problems, like simpler dequantization, simpler motion compensation, assuming use of the default quantization matrix, assuming YUV 4:2:0 and skipping a few checks to detect damaged bitstreams. Pass AVOptions to libavcodec decoder. Note, a patch to make the unneeded and pass all unknown options through the AVOption system is welcome. A full list of AVOptions can be found in the FFmpeg manual. Some options which used to be direct options can be set with this mechanism, like , , , , , (was ), (was ), . This is a key/value list option. See List Options for details. Show even broken/corrupt frames (default: no). If this option is set to no, libavcodec won't output frames that were either decoded before an initial keyframe was decoded, or frames that are recognized as corrupted. Skips the loop filter (AKA deblocking) during decoding. Since the filtered frame is supposed to be used as reference for decoding dependent frames, this has a worse effect on quality than not doing deblocking on e.g. MPEG-2 video. But at least for high bitrate HDTV, this provides a big speedup with little visible quality loss. Codecs other than H.264 or HEVC may have partial support for this option (often only and ). can be one of the following: Skip frames that are not referenced (i.e. not used for decoding other frames, the error cannot \"build up\"). Skips the IDCT step. This degrades quality a lot in almost all cases (see skiploopfilter for available skip values). Skips decoding of frames completely. Big speedup, but jerky motion and sometimes bad artifacts (see skiploopfilter for available skip values). Set framedropping mode used with (see skiploopfilter for available skip values). Number of threads to use for decoding. Whether threading is actually supported depends on codec (default: 0). 0 means autodetect number of cores on the machine and use that, up to the maximum of 16. You can set more than 16 threads manually. Assume the video was encoded by an old, buggy x264 version (default: no). Normally, this is autodetected by libavcodec. But if the bitstream contains no x264 version info (or it was somehow skipped), and the stream was in fact encoded by an old x264 version (build 150 or earlier), and if the stream uses 4:4:4 chroma, then libavcodec will by default show corrupted video. This option sets the libavcodec option to , which means that if the stream contains no version info, or was not encoded by x264 at all, it assumes it was encoded by the old version. Enabling this option is pretty safe if you want your broken files to work, but in theory this can break on streams not encoded by x264, or if a stream encoded by a newer x264 version contains no version info. Certain video codecs support cropping, meaning that only a sub-rectangle of the decoded frame is intended for display. This option controls how cropping is handled by libavcodec. Cropping during decoding has certain limitations with regards to alignment and hardware decoding. If this option is enabled, decoder will apply the crop, else VO will handle it. Enabled by default. Allow up to N in-flight frames. This essentially controls the frame latency. Increasing the swapchain depth can improve pipelining and prevent missed vsyncs, but increases visible latency. This option only mandates an upper limit, the implementation can use a lower latency than requested internally. A setting of 1 means that the VO will wait for every frame to become visible before starting to render the next frame. (Default: 3) If this is enabled (default), playing with a speed different from normal automatically inserts the audio filter. You can insert filters besides and modify their params using : Filters set this way replace the default, instead of overlapping with it. If there are multiple audio filters inserted that can do pitch correction, then only the last one in the filter chain is used. For details on the specifics of each available filter, see the audio filter section. Use the given audio device. This consists of the audio output name, e.g. , followed by , followed by the audio output specific device name. The default value for this option is , which tries every audio output in preference order with the default device. You can list audio devices with . This outputs the device name in quotes, followed by a description. The device name is what you have to pass to the option. The list of audio devices can be retrieved by API by using the property. While the option normally takes one of the strings as indicated by the methods above, you can also force the device for most AOs by building it manually. For example forces the AO to use the device . However, the option will strictly force a specific AO. To avoid confusion, don't use and together. MPlayer and mplayer2 required you to replace any ',' with '.' and any ':' with '=' in the ALSA device name. For example, to use the device named , you had to do: In mpv you could instead use: Enable exclusive output mode. In this mode, the system is usually locked out, and only mpv will be able to output audio. This only works for some audio outputs, such as , and . Other audio outputs silently ignore this option. They either have no concept of exclusive mode, or the mpv side of the implementation is missing. If no audio device can be opened, behave as if was given. This is useful in combination with : instead of causing an error if the selected device does not exist, the client API user (or a Lua script) could let playback continue normally, and check the and properties to make high-level decisions about how to continue. Specify the audio output drivers to be used. See AUDIO OUTPUT DRIVERS for details and descriptions of available drivers. Specify a list of audio filters to apply to the audio stream. See AUDIO FILTERS for details and descriptions of the available filters. The option variants , , and exist to modify a previously specified list, but you should not need these for typical use. List of codecs for which compressed audio passthrough should be used. This works for both classic S/PDIF and HDMI. Possible codecs are , , , , . Multiple codecs can be specified by separating them with . refers to low bitrate DTS core, while refers to DTS MA (receiver and OS support varies). If both and are specified, it behaves equivalent to specifying only. In earlier mpv versions you could use to force the spdif wrapper. This does not work anymore. There is not much reason to use this. HDMI supports uncompressed multichannel PCM, and mpv supports lossless DTS-HD decoding via FFmpeg's new DCA decoder (based on libdcadec). Specify a priority list of audio decoders to be used, according to their decoder name. When determining which decoder to use, the first decoder that matches the audio format is selected. If that is unavailable, the next decoder is used. Finally, it tries all other decoders that are not explicitly selected or rejected by the option. at the end of the list suppresses fallback on other available decoders not on the list. in front of an entry forces the decoder. Both of these should not normally be used, because they break normal decoder auto-selection! Both of these methods are deprecated. Prefer the FFmpeg decoder over all other MP3 decoders. Enabling compressed audio passthrough (AC3 and DTS via SPDIF/HDMI) with this option is not possible. Use instead. Set the startup volume. 0 means silence, 100 means no volume reduction or amplification. Negative values can be passed for compatibility, but are treated as 0. Since mpv 0.18.1, this always controls the internal mixer (aka software volume). Set the maximum amplification level in percent (default: 130). A value of 130 will allow you to adjust the volume up to about double the normal level. Set the volume gain in dB. This is applied on top of other volume and gain settings. Adjust volume gain according to replaygain values stored in the file metadata. With (the default), perform no adjustment. With , apply track gain. With , apply album gain if present and fall back to track gain otherwise. Pre-amplification gain in dB to apply to the selected replaygain gain (default: 0). Allow the volume gain to clip (default: no). If this option is not enabled, mpv automatically will prevent clipping by lowering the gain. Gain in dB to apply if the file has no replay gain tags. This option is always applied if the replaygain logic is somehow inactive. If this is applied, no other replaygain options are applied. Audio delay in seconds (positive or negative float value). Positive values delay the audio, and negative values delay the video. Use this audio demuxer type when using . Use a '+' before the name to force it; this will skip some checks. Give the demuxer name as printed by . Select the Dynamic Range Compression level for AC-3 audio streams. is a float value ranging from 0 to 1, where 0 means no compression (which is the default) and 1 means full compression (make loud passages more silent and vice versa). Values up to 6 are also accepted, but are purely experimental. This option only shows an effect if the AC-3 stream contains the required range compression information. The standard mandates that DRC is enabled by default, but mpv (and some other players) ignore this for the sake of better audio quality. Whether to request audio channel downmixing from the decoder (default: no). Some decoders, like AC-3, AAC and DTS, can remix audio on decoding. The requested number of output channels is set with the option. Useful for playing surround audio on a stereo system. Number of threads to use for decoding. Whether threading is actually supported depends on codec. As of this writing, it's supported for some lossless codecs only. 0 means autodetect number of cores on the machine and use that, up to the maximum of 16 (default: 1). Pass AVOptions to libavcodec decoder. Note, a patch to make the o= unneeded and pass all unknown options through the AVOption system is welcome. A full list of AVOptions can be found in the FFmpeg manual. This is a key/value list option. See List Options for details. If DTS is passed through, use DTS-HD. This and enabling passthrough via are deprecated in favor of using . Control which audio channels are output (e.g. surround vs. stereo). There are the following possibilities:\n• None Use the system's preferred channel layout. If there is none (such as when accessing a hardware device instead of the system mixer), force stereo. Some audio outputs might simply accept any layout and do downmixing on their own.\n• None Send the audio device whatever it accepts, preferring the audio's original channel layout. Can cause issues with HDMI (see the warning below).\n• None List of -separated channel layouts which should be allowed. Technically, this only adjusts the filter chain output to the best matching layout in the list, and passes the result to the audio API. It's possible that the audio API will select a different channel layout. Using this mode is recommended for direct hardware output, especially over HDMI (see HDMI warning below).\n• None Force a downmix to stereo or mono. These are special-cases of the previous item. (See paragraphs below for implications.) If a list of layouts is given, each item can be either an explicit channel layout name (like ), or a channel number. Channel numbers refer to default layouts, e.g. 2 channels refer to stereo, 6 refers to 5.1. See output for defined default layouts. This also lists speaker names, which can be used to express arbitrary channel layouts (e.g. is 2.1). If the list of channel layouts has only 1 item, the decoder is asked to produce according output. This sometimes triggers decoder-downmix, which might be different from the normal mpv downmix. (Only some decoders support remixing audio, like AC-3, AAC or DTS. You can use to make the decoder always output its native layout.) One consequence is that triggers decoder downmix, while or never will, even if they end up selecting stereo. This happens because the decision whether to use decoder downmix happens long before the audio device is opened. If the channel layout of the media file (i.e. the decoder) and the AO's channel layout don't match, mpv will attempt to insert a conversion filter. You may need to change the channel layout of the system mixer to achieve your desired output as mpv does not have control over it. Another work-around for this on some AOs is to use to circumvent the system mixer entirely. Using can cause issues when using audio over HDMI. The OS will typically report all channel layouts that _can_ go over HDMI, even if the receiver does not support them. If a receiver gets an unsupported channel layout, random things can happen, such as dropping the additional channels, or adding noise. You are recommended to set an explicit whitelist of the layouts you want. For example, most A/V receivers connected via HDMI and that can do 7.1 would be served by: Determines whether to display cover art when playing audio files and with what priority. It will display the first image found, and additional images are available as video tracks. Disable display of video entirely when playing audio files. This option has no influence on files with normal video tracks. Play audio from an external file while viewing a video. This is a path list option. See List Options for details. CLI/config file only alias for . Each use of this option will add a new audio track. The details are similar to how works. Select the sample format used for output from the audio filter layer to the sound card. The values that can adopt are listed below in the description of the audio filter. Select the output sample rate to be used (of course sound cards have limits on this). If the sample frequency selected is different from that of the current media, the internal swresample audio filter will be inserted into the audio filter layer to compensate for the difference. Try to play consecutive audio files with no silence or disruption at the point of file change. Default: . The audio device is opened using parameters chosen for the first file played and is then kept open for gapless playback. This means that if the first file for example has a low sample rate, then the following files may get resampled to the same low sample rate, resulting in reduced sound quality. If you play files with different parameters, consider using options such as and to explicitly select what the shared output format will be. Normally, the audio device is kept open (using the format it was first initialized with). If the audio format the decoder output changes, the audio device is closed and reopened. This means that you will normally get gapless audio with files that were encoded using the same settings, but might not be gapless in other cases. The exact conditions under which the audio device is kept open is an implementation detail, and can change from version to version. Currently, the device is kept even if the sample format changes, but the sample formats are convertible. If video is still going on when there is still audio, trying to use gapless is also explicitly given up. This feature is implemented in a simple manner and relies on audio output device buffering to continue playback while moving from one file to another. If playback of the new file starts slowly, for example because it is played from a remote network location or because you have specified cache settings that require time for the initial cache fill, then the buffered audio may run out before playback of the new file can start. When starting a video file or after events such as seeking, mpv will by default modify the audio stream to make it start from the same timestamp as video, by either inserting silence at the start or cutting away the first samples. Disabling this option makes the player behave like older mpv versions did: video and audio are both started immediately even if their start timestamps differ, and then video timing is gradually adjusted if necessary to reach correct synchronization later. Load additional audio files matching the video filename. The parameter specifies how external audio files are matched. Load all audio files containing the media filename. Load all audio files in the current and directories. Audio file extentions to try to match when using , or . This is a string list option. See List Options for details. Use to see default extensions. Equivalent to option, but for auto-loaded audio files. This is a path list option. See List Options for details. The application name the player reports to the audio API. Can be useful if you want to force a different audio profile (e.g. with PulseAudio), or to set your own application name when using libmpv. Set the audio output minimum buffer. The audio device might actually create a larger buffer if it pleases. If the device creates a smaller buffer, additional audio is buffered in an additional software buffer. Making this larger may make soft-volume and other filters react slower, introduce additional issues on playback speed change, and block the player on audio format changes. A smaller buffer might lead to audio dropouts. This option should be used for testing only. If a non-default value helps significantly, the mpv developers should be contacted. Cash-grab consumer audio hardware (such as A/V receivers) often ignore initial audio sent over HDMI. This can happen every time audio over HDMI is stopped and resumed. In order to compensate for this, you can enable this option to not to stop and restart audio on seeks, and fill the gaps with silence. Likewise, when pausing playback, audio is not stopped, and silence is played while paused. Note that if no audio track is selected, the audio device will still be closed immediately. Not all AOs support this. This modifies certain subtle player behavior, like A/V-sync and underrun handling. Enabling this option is strongly discouraged. This makes sense for use with . If this option is given, the player will wait for the given amount of seconds after opening the audio device before sending actual audio data to it. Useful if your expensive hardware discards the first 1 or 2 seconds of audio data sent to it. If is not set, this option will likely just waste time. Changing styling and position does not work with all subtitles. Image-based subtitles (DVD, Bluray/PGS, DVB) cannot changed for fundamental reasons. Subtitles in ASS format are normally not changed intentionally, but overriding them can be controlled with . Force subtitle demuxer type for . Give the demuxer name as printed by . Pass AVOptions to libavcodec decoder. Note, a patch to make the o= unneeded and pass all unknown options through the AVOption system is welcome. A full list of AVOptions can be found in the FFmpeg manual. This is a key/value list option. See List Options for details. Delays primary subtitles by seconds. Can be negative. Delays secondary subtitles by seconds. Can be negative. Add a subtitle file to the list of external subtitles. If you use only once, this subtitle file is displayed by default. If is used multiple times, the subtitle to use can be switched at runtime by cycling subtitle tracks. It's possible to show two subtitles at once: use to select the first subtitle index, and to select the second index. (The index is printed on the terminal output after the in the list of streams.) is a path list option (see List Options for details), and can take multiple file names separated by (Unix) or (Windows), while takes a single filename, but can be used multiple times to add multiple files. Technically, is a CLI/config file only alias for . Select a secondary subtitle stream. This is similar to . If a secondary subtitle is selected, it will be rendered as toptitle (i.e. on the top of the screen) alongside the normal subtitle by default, and provides a way to render two subtitles at once. There are some caveats associated with this feature. For example, bitmap subtitles will always be rendered in their usual position, so selecting a bitmap subtitle as secondary subtitle will result in overlapping subtitles. Secondary subtitles are never shown on the terminal if video is disabled. Styling and interpretation of any formatting tags is disabled for the secondary subtitle. Internally, the same mechanism as is used to strip the styling. If the main subtitle stream contains formatting tags which display the subtitle at the top of the screen, it will overlap with the secondary subtitle. To prevent this, you could use to disable styling in the main subtitle stream. This affects ASS subtitles as well, and may lead to incorrect subtitle rendering. Use with care, or use instead. Whether to scale subtitles with the window size (default: yes). If this is disabled while is set to yes, changing the window size won't change the subtitle font size. Affects plain text subtitles only (or ASS if is set high enough). Make the subtitle font size relative to the window (default: yes). If this is disabled while is set to yes, the subtitle font size is scaled relative to the video size instead. Affects plain text subtitles only (or ASS if is set high enough). By default, the subtitle font size is scaled with the window size. To make the font size constant, set only to no. To make the font size scale with video size instead, set only to no. It's not meaningful to set both options to no. Like , but affects subtitles in ASS format only. Like , this can break ASS subtitles. Use fonts embedded in Matroska container files and ASS scripts (default: yes). These fonts can be used for SSA/ASS subtitle rendering. Specify the position of subtitles on the screen. The value is the vertical position of the subtitle in % of the screen height. 100 is the original position, which is often not the absolute bottom of the screen, but with some margin between the bottom and the subtitle. Values above 100 move the subtitle further down. Text subtitles (as opposed to image subtitles) may be cut off if the value of the option is above 100. This is a libass restriction. This affects ASS subtitles as well, and may lead to incorrect subtitle rendering in addition to the problem above. Using can achieve this in a better way. Specify the position of secondary subtitles on the screen. This is similar to but for secondary subtitles. Multiply the subtitle event timestamps with the given value. Can be used to fix the playback speed for frame-based subtitle formats. Affects text subtitles only. plays frame based subtitles which have been loaded assuming a framerate of 23.976 at 25 FPS. This is a string list option. See List Options for details. Using this option may lead to incorrect subtitle rendering. Enabling hinting can lead to mispositioned text (in situations it's supposed to match up video background), or reduce the smoothness of animations with some badly authored ASS scripts. It is recommended to not use this option, unless really needed. Set the text layout engine used by libass. uses Fribidi only, fast, doesn't render some languages correctly is the default. If libass hasn't been compiled against HarfBuzz, libass silently reverts to . Load all SSA/ASS styles found in the specified file and use them for rendering text subtitles. The syntax of the file is exactly like the / section of SSA/ASS. Using this option may lead to incorrect subtitle rendering. Control whether user style overrides should be applied. Note that all of these overrides try to be somewhat smart about figuring out whether or not a subtitle is considered a \"sign\". Render subtitles as specified by the subtitle scripts, without overrides. Apply all the style override options. Changing the default for any of these options can lead to incorrect subtitle rendering. Like , but also apply (default). Like , but also force all options. Can break rendering easily. Radically strip all ASS tags and styles from the subtitle. This is equivalent to the old / options. This also controls some bitmap subtitle overrides, as well as HTML tags in formats like SRT, despite the name of the option. Control whether user secondary substyle overrides should be applied. This works exactly like . Enables placing toptitles and subtitles in black borders when they are available, if the subtitles are in the ASS format. Enables placing toptitles and subtitles in black borders when they are available, if the subtitles are in a plain text format (or ASS if is set high enough). Controls which information about the video stream is passed to libass. Any option but is incompatible with standard ASS as defined by VSFilter, whose behavior most subtitle scripts and renderers target, including libass. Video stream properties are needed to accurately emulate VSFilter semantics and withholding them will likely result in broken subtitle rendering for most files. It's thus recommended to only change this selectively if required on a per-file basis. Only forward aspect ratio; fallbacks are used for other properties. This makes behaviour consistent across different video resolutions. For certain kinds of broken ASS files which got repurposed across several video resolutions without either setting headers or adjusting affected effects, it may be desirable to withhold storage resolution information from libass to ensure consistent rendering across resolutions. Among others this affects 3D rotations and blurs. When encountering such files, try setting . Even more broken files on anamorphic video might also exhibit stretching unless aspect ratio information is also faked, in this case you can try using . This has never an effect on non-anamorphic video. Allows passing any arbitrary aspect ratio to libass instead of the video’s actual aspect ratio. Zero or negative aspect ratios are identical to . This has no effect if is set to . Set implicit bidi detection to instead of to match ASS' default. This also disables libass' incompatible extensions. This currently includes bracket pair matching according to the revised Unicode Bidirectional Algorithm introduced in Unicode 6.3, and also affects how BiDi runs are split and processed, as well as soft linewrapping of unicode text. This affects plaintext (non-ASS) subtitles only. Default: no. Mangle colors like (xy-)vsfilter do (default: basic). Historically, VSFilter was not color space aware. This was no problem as long as the color space used for SD video (BT.601) was used. But when everything switched to HD (BT.709), VSFilter was still converting RGB colors to BT.601, rendered them into the video frame, and handled the frame to the video output, which would use BT.709 for conversion to RGB. The result were mangled subtitle colors. Later on, bad hacks were added on top of the ASS format to control how colors are to be mangled. Handle only BT.601->BT.709 mangling, if the subtitles seem to indicate that this is required (default). Handle the full header with all video color spaces supported by libass and mpv. This might lead to bad breakages in corner cases and is not strictly needed for compatibility (hopefully), which is why this is not default. Force BT.601->BT.709 mangling, regardless of subtitle headers or video color space. Choosing anything other than will make the subtitle color depend on the video color space, and it's for example in theory not possible to reuse a subtitle script with another video file. The option doesn't affect how this option is interpreted. Stretch DVD subtitles when playing anamorphic videos for better looking fonts on badly mastered DVDs. This switch has no effect when the video is stored with square pixels - which for DVD input cannot be the case though. Many studios tend to use bitmap fonts designed for square pixels when authoring DVDs, causing the fonts to look stretched on playback on DVD players. This option fixes them, however at the price of possibly misaligning some subtitles (e.g. sign translations). Stretch DVD and other image subtitles to the screen, ignoring the video margins. This has a similar effect as for text subtitles, except that the text itself will be stretched, not only just repositioned. (At least in general it is unavoidable, as an image bitmap can in theory consist of a single bitmap covering the whole screen, and the player won't know where exactly the text parts are located.) This option does not display subtitles correctly. Use with care. Override the image subtitle resolution with the video resolution (default: no). Normally, the subtitle canvas is fit into the video canvas (e.g. letterboxed). Setting this option uses the video size as subtitle canvas size. Can be useful to test broken subtitles, which often happen when the video was trancoded, while attempting to keep the old subtitles. This has been deprecated by . You also may need to get the same behavior. Also, using should give better results without breaking subtitles too much. If is specified, all tags and style declarations are stripped and ignored on display. The subtitle renderer uses the font style as specified by the options instead. Using may lead to incorrect or completely broken rendering of ASS/SSA subtitles. It can sometimes be useful to forcibly override the styling of ASS subtitles, but should be avoided in general. Load additional subtitle files matching the video filename. The parameter specifies how external subtitle files are matched. is enabled by default. Load the media filename with subtitle file extension and possibly language suffixes (default). Load all subs containing the media filename. Load all subs in the current and directories. Subtitle extentions to try and match when using . Note that modifying this list will also affect what mpv recognizes as subtitles when using drag and drop. This is a string list option. See List Options for details. You can use this option to specify the subtitle codepage. uchardet will be used to guess the charset. (If mpv was not compiled with uchardet, then is the effective default.) The default value for this option is , which enables autodetection. The following steps are taken to determine the final codepage, in order:\n• if the specific codepage has a , use that codepage\n• if the data looks like UTF-8, assume it is UTF-8\n• if is set to a specific codepage, use that\n• run uchardet, and if successful, use that\n• Use Latin 2 if input is not UTF-8. The pseudo codepage is used internally. If it's set, subtitles are interpreted as UTF-8 with \"Latin 1\" as fallback for bytes which are not valid UTF-8 sequences. iconv is never involved in this mode. This works for text subtitle files only. Other types of subtitles (in particular subtitles in mkv files) are always assumed to be UTF-8. Stretch a subtitle duration so it ends when the next one starts. Should help with subtitles which erroneously have zero durations. Adjust subtitle timing is to remove minor gaps or overlaps between subtitles (if the difference is smaller than 210 ms, the gap or overlap is removed). Enabling this displays only forced events within subtitle streams. Only some bitmap subtitle formats (such as DVD or PGS) are capable of having a mixture of forced and unforced events within the stream. Enabling this on text subtitles will cause no subtitles to be displayed (default: ). Specify the framerate of the subtitle file (default: video fps). Affects text subtitles only. > video fps speeds the subtitles up for frame-based subtitle files and slows them down for time-based ones. Apply Gaussian blur to image subtitles (default: 0). This can help to make pixelated DVD/Vobsubs look nicer. A value other than 0 also switches to software subtitle scaling. Might be slow. Convert image subtitles to grayscale. Can help to make yellow DVD/Vobsubs look nicer. Specify extra directories to search for subtitles matching the video. Multiple directories can be separated by \":\" (\";\" on Windows). Paths can be relative or absolute. Relative paths are interpreted relative to video file directory. If the file is a URL, only absolute paths and configuration subdirectory will be scanned. Assuming that is played and is specified, mpv searches for subtitle files in these directories: This is a path list option. See List Options for details. Can be used to disable display of subtitles, but still select and decode them. Can be used to disable display of secondary subtitles, but still select and decode them. (Obscure, rarely useful.) Can be used to play broken mkv files with duplicate ReadOrder fields. ReadOrder is the first field in a Matroska-style ASS subtitle packets. It should be unique, and libass uses it for fast elimination of duplicates. This option disables caching of subtitles across seeks, so after a seek libass can't eliminate subtitle packets with the same ReadOrder as earlier packets. Note that enabling this option can result in broken subtitle behavior if you are not actually playing one of the aforementioned broken mkv files. This works for subtitle streams, and if FFmpeg has been compiled with support for it. Values are for individual pages. Special value (default) matches all subtitle pages. Special value matches all pages. Note that page is the default start page of actual teletext. It is also the former default value of this option. See the section in FFmpeg documentation for details. After the last frame of video, if this option is enabled, subtitles will continue to update based on audio timestamps. Otherwise, the subtitles for the last video frame will stay onscreen. Specify font to use for subtitles that do not themselves specify a particular font. The default is . The option (and many other style related options) are ignored when ASS-subtitles are rendered, unless is specified. This used to support fontconfig patterns. Starting with libass 0.13.0, this stopped working. Specify the sub font size. The unit is the size in scaled pixels at a window height of 720. The actual pixel size is scaled with the window height: if the window height is larger or smaller than 720, the actual size of the text increases or decreases as well. Gaussian blur factor applied to the sub font border. 0 means no blur applied (default). See . Color used for the sub font outline. is an alias for . See . Color used for sub text background. is an alias for . Size of the sub font outline in scaled pixels (see for details). A value of 0 disables outlines. is an alias for .\n• : draw outline and shadow. The size of the outline is determined by , and the offset of the shadow is determined by . The outline is colored by , and the shadow is colored by . This corresponds to in the ASS spec.\n• : draw outline and shadow as opaque boxes that tightly wrap each lines of text. The margin of the outline opaque box is determined by , and the offset of the shadow opaque box is determined by . The outline opaque box is colored by , and the shadow opaque box is colored by . Despite its name, the opaque box can be semi-transparent. This corresponds to in the ASS spec.\n• : draw a background box that bounds all lines of text. The background box is colored by , and the margin of the background box is determined by . The behavior of the outline is the same as the style. This corresponds to , which is a libass-specific extension. Specify the color used for unstyled text subtitles. The color is specified in the form , where each color component is specified as number in the range 0.0 to 1.0. It's also possible to specify the transparency by using , where the alpha value 0 means fully transparent, and 1.0 means opaque. If the alpha component is not given, the color is 100% opaque. Passing a single number to the option sets the sub to gray, and the form lets you specify alpha additionally.\n• set sub to opaque red with 75% alpha\n• set sub to 50% gray with 75% alpha Alternatively, the color can be specified as a RGB hex triplet in the form , where each 2-digit group expresses a color value in the range 0 ( ) to 255 ( ). For example, is red. Alpha is given with .\n• set sub to 50% gray with 75% alpha Left and right screen margin for the subs in scaled pixels (see for details). This option specifies the distance of the sub to the left, as well as at which distance from the right border long sub text will be broken. Top and bottom screen margin for the subs in scaled pixels (see for details). This option specifies the vertical margins of unstyled text subtitles. If you just want to raise the vertical subtitle position, use . Control to which corner of the screen text subtitles should be aligned to (default: ). Never applied to ASS subtitles, except in mode. Likewise, this does not apply to image subtitles. Control how multi line subs are justified irrespective of where they are aligned (default: which justifies as defined by ). Left justification is recommended to make the subs easier to read as it is easier for the eyes. Applies justification as defined by on ASS subtitles if is not set to . Default: . Displacement of the sub text shadow in scaled pixels (see for details). A value of 0 disables shadows. Horizontal sub font spacing in scaled pixels (see for details). This value is added to the normal letter spacing. Negative values are allowed. Applies filter removing subtitle additions for the deaf or hard-of-hearing (SDH). This is intended for English, but may in part work for other languages too. The intention is that it can be always enabled so may not remove all parts added. It removes speaker labels (like MAN:) and any text enclosed within symbols like parentheses or brackets as specified by the option. Note that parenthesis (full width parenthesis and the normal variant) are a special case and only upper case text is removed. For more filtering, you can use the option. Do harder SDH filtering (if enabled by ). Will also remove speaker labels and text within parentheses using both lower and upper case letters. Specify a string of characters that will use to potentially remove text. Text that is enclosed within characters specified by this string will be removed. Note that bracket characters with known pairs (such as or ) will be mapped internally to their matching right hand character, so you only need to specify left hand characters. Set a list of regular expressions to match on text subtitles, and remove any lines that match (default: empty). This is a string list option. See List Options for details. Normally, you should use , where each option use will append a new regular expression, without having to fight escaping problems. List items are matched in order. If a regular expression matches, the process is stopped, and the subtitle line is discarded. The text matched against is, by default, the field of ASS events (if the subtitle format is different, it is always converted). This may include formatting tags. Matching is case-insensitive, but how this is done depends on the libc, and most likely works in ASCII only. It does not work on bitmap/image subtitles. Unavailable on inferior OSes (requires POSIX regex support). Technically, using a list for matching is redundant, since you could just use a single combined regular expression. But it helps with diagnosis, ease of use, and temporarily disabling or enabling individual filters. This is experimental. The semantics most likely will change, and if you use this, you should be prepared to update the option later. Ideas include replacing the regexes with a very primitive and small subset of sed, or some method to control case-sensitivity. Same as but with JavaScript regular expressions. Shares/affected-by all control options (see below), and also experimental. Requires only JavaScript support. Whether to first convert the ASS \"Text\" field to plain-text (default: no). This strips ASS tags and applies ASS directives, like to new-line. If the result is multi-line then the regexp anchors and match each line, but still any match discards all lines. Log dropped lines with warning log level, instead of verbose (default: no). Helpful for testing. Whether to enable regex filtering (default: yes). Note that if no regexes are added to the list, setting this option to has no effect. It's meant to easily disable or enable filtering temporarily. For every video stream, create a closed captions track (default: no). The only purpose is to make the track available for selection at the start of playback, instead of creating it lazily. This applies only to (displayed by mpv as subtitle tracks using the codec ). The CC track is marked \"default\" and selected according to the normal subtitle track selection rules. You can then use to explicitly select the correct track too. If the video stream contains no closed captions, or if no video is being decoded, the CC track will remain empty and will not show any text. Which libass font provider backend to use (default: auto). will attempt to use the native font provider: fontconfig on Linux, CoreText on macOS, DirectWrite on Windows. forces fontconfig, if libass was built with support (if not, it behaves like ). The font provider effectively disables system fonts. It will still attempt to use embedded fonts (unless is set; this is the same behavior as with all other font providers), if provided, and fonts in the sub-directory if provided. (The fallback is more strict than that of other font providers, and if a font name does not match, it may prefer not to render any text that uses the missing font.) Font files in this directory are used by mpv/libass for subtitles. Useful if you do not want to install fonts to your system. Note that files in this directory are loaded into memory before being used by mpv. If you have a lot of fonts, consider using fonts.conf (see FILES section) to include additional mpv user settings. If this option is not specified, will be used by default. Set the window title. This is used for the video window, and if possible, also sets the audio stream title. There is a danger of this causing significant CPU usage, depending on the properties used. Changing the window title is often a slow operation, and if the title changes every frame, playback can be ruined. In multi-monitor configurations (i.e. a single desktop that spans across multiple displays), this option tells mpv which screen to display the video on. This option does not work properly with all window managers. In these cases, you can try to use to position the window explicitly. It's also possible that the window manager provides native features to control which screens application windows should use. This option does not actually work on wayland since window placement is not allowed. However setting this option does influence mpv's initial guess at finding an output which may be useful for options like or which depend on the monitor resolution. In multi-monitor configurations, this option tells mpv which screen to display the video on based on the screen name from the video backend. The same caveats in the option also apply here. This option is ignored and does nothing if is explicitly set. In multi-monitor configurations (i.e. a single desktop that spans across multiple displays), this option tells mpv which screen to go fullscreen to. If is used mpv will fallback on what the user provided with the option. This option works properly only with window managers which understand the EWMH hint. does not work on macOS and will behave like . In multi-monitor configurations, this option tells mpv which screen to go fullscreen to based on the screen name from the video backend. The same caveats in the option also apply here. This option is ignored and does nothing if is explicitly set. Do not terminate when playing or seeking beyond the end of the file, and there is no next file to be played (and is not used). Instead, pause the player. When trying to seek beyond end of the file, the player will attempt to seek to the last frame. Normally, this will act like on EOF, unless the option is set. The following arguments can be given: If the current file ends, go to the next file or terminate. (Default.) Don't terminate if the current file is the last playlist entry. Equivalent to without arguments. Like , but also applies to files before the last playlist entry. This means playback will never automatically advance to the next file. This option is not respected when using . Explicitly skipping to the next file if the binding uses will terminate playback as well. Also, if errors or unusual circumstances happen, the player can quit anyway. Since mpv 0.6.0, this doesn't pause if there is a next file in the playlist, or the playlist is looped. Approximately, this will pause when the player would normally exit, but in practice there are corner cases in which this is not the case (e.g. will play file.mkv normally, then fail to open , then exit). (In mpv 0.8.0, was introduced, which restores the old behavior.) If set to , instead of pausing when is active, just stop at end of file and continue playing forward when you seek backwards until end where it stops again. Default: . If the current file is an image, play the image for the given amount of seconds (default: 1). means the file is kept open forever (until the user stops playback manually). Unlike , the player is not paused, but simply continues playback until the time has elapsed. (It should not use any resources during \"playback\".) This affects image files, which are defined as having only 1 video frame and no audio. The player may recognize certain non-images as images, for example if is used to reduce the length to 1 frame, or if you seek to the last frame. This option does not affect the framerate used for or . For that, use instead. When viewing images, the playback time is not tracked on the command line output, and the image frame is not duplicated when encoding. To force the player into \"dumb mode\" and actually count out seconds, or to duplicate the image when encoding, you need to use , and use or to stop after a particular time. Create a video output window even if there is no video. This can be useful when pretending that mpv is a GUI application. Currently, the window always has the size 960x540, and is subject to , , and similar options. The window is created only after initialization (to make sure default window placement still works if the video size is different from the default window size). This can be a problem if initialization doesn't work perfectly, such as when opening URLs with bad network connection, or opening broken video files. The mode can be used to create the window always on program start, but this may cause other issues. (Windows only) Enable/disable playback progress rendering in taskbar (Windows 7 and above). (Windows only) Snap the player window to screen edges. Controls the default behavior of drag and drop on platforms that support this. will obey what the underlying os/platform gives mpv. Typically, holding shift during the drag and drop will append the item to the playlist. Otherwise, it will completely replace it. , , and always force replacing, appending to, and inserting next into the playlist respectively. disables all drag and drop behavior. Makes the player window stay on top of other windows. On Windows, if combined with fullscreen mode, this causes mpv to be treated as exclusive fullscreen window that bypasses the Desktop Window Manager. (macOS only) Sets the level of an ontop window (default: window). On top of all other windows. On top of system elements like Taskbar, Menubar and Dock. On top of the Desktop behind windows and Desktop icons. (macOS only) Focus the video window and make it the front most window on specific events (default: open). Never focus the window on open or new file load events. Focus the window on creation, eg when a vo is initialised. Focus the window on open and new file load event. (Windows only) Set the preference for window corner rounding. Let the system decide whether or not to round window corners Round the corners if appropriate Round the corners if appropriate, with a small radius Play video with window border and decorations. Since this is on by default, use to disable the standard window decorations. (Windows and X11 only) Play video with the window title bar. Since this is on by default, use to hide the title bar. The option takes precedence. (X11 and macOS only) Show the video window on all virtual desktops. Adjust the initial window position or size. and set the window size in pixels. and set the window position, measured in pixels from the top-left corner of the screen to the top-left corner of the image being displayed. If a percentage sign ( ) is given after the argument, it turns the value into a percentage of the screen size in that direction. Positions are specified similar to the standard X11 option format, in which e.g. +10-50 means \"place 10 pixels from the left border and 50 pixels from the lower border\" and \"--20+-10\" means \"place 20 pixels beyond the right and 10 pixels beyond the top border\". A trailing followed by an integer denotes on which workspace (virtual desktop) the window should appear (X11 only). If an external window is specified using the option, this option is ignored. The coordinates are relative to the screen given with for the video output drivers that fully support . Generally only supported by GUI VOs. Ignored for encoding. On macOS, the origin of the screen coordinate system is located on the bottom-left corner. For instance, will place the window at the bottom-left of the screen. This option does not work properly with all window managers. Wayland does not allow a client to position itself so this option will only affect the window size. Places the window in the middle of the screen. Places the window at the bottom right corner of the screen. Sets the window width to half the screen width. Window height is set so that the window has the video aspect ratio. Forces the window width and height to half the screen width and height. Will show black borders to compensate for the video aspect ratio (with most VOs and with ). Sets the window to half the screen widths, and positions it 10 pixels below/left of the top left corner of the screen, on the second workspace. See also and for fitting the window into a given size without changing aspect ratio. Set the initial window size to a maximum size specified by , without changing the window's aspect ratio. The size is measured in pixels, or if a number is followed by a percentage sign ( ), in percents of the screen size. This option never changes the aspect ratio of the window. If the aspect ratio mismatches, the window's size is reduced until it fits into the specified size. Window position is not taken into account, nor is it modified by this option (the window manager still may place the window differently depending on size). Use to change the window position. Its effects are applied after this option. See for details how this is handled with multi-monitor setups. Use instead if you just want to limit the maximum size of the window, rather than always forcing a window size. Use if you want to force both window width and height to a specific size. Generally only supported by GUI VOs. Ignored for encoding. Make the window width 70% of the screen size, keeping aspect ratio. Make the window as large as possible, without being wider than 70% of the screen width, or higher than 60% of the screen height. This option behaves exactly like , except that it sets the maximum size of the window. If the video is larger than 90% of the screen width or 80% of the screen height, make the window smaller until either its width is 90% of the screen, or its height is 80% of the screen. This option behaves exactly like , except that it sets the minimum size of the window (just as sets the maximum). Make the window at least 500 pixels wide and 500 pixels high (depending on the video aspect ratio, the width or height will be larger than 500 in order to keep the aspect ratio the same). Resize the video window to a multiple (or fraction) of the video size. This option is applied before and other options are applied (so they override this option). Changing this option while the window is maximized can unmaximize the window depending on the OS and window manager. If the window does not unmaximize, the multiplier will be applied if the user unmaximizes the window later. For example, would show the window at half the video size. Whether the video window is minimized or not. Setting this will minimize, or unminimize, the video window if the current VO supports it. Note that some VOs may support minimization while not supporting unminimization (eg: Wayland). Whether this option and work on program start or at runtime, and whether they're (at runtime) updated to reflect the actual window state, heavily depends on the VO and the windowing system. Some VOs simply do not implement them or parts of them, while other VOs may be restricted by the windowing systems (especially Wayland). Whether the video window is maximized or not. Setting this will maximize, or unmaximize, the video window if the current VO supports it. See for further remarks. Make mouse cursor automatically hide after given number of milliseconds (default: 1000 ms). will disable cursor autohide. means the cursor will stay hidden. If this option is given, the cursor is always visible in windowed mode. In fullscreen mode, the cursor is shown or hidden according to . Change how some video outputs render the OSD and text subtitles. This does not change appearance of the subtitles and only has performance implications. For VOs which support native ASS rendering (like , , ), this can be slightly faster or slower, depending on GPU drivers and hardware. For other VOs, this just makes rendering slower. Forces mpv to always render frames regardless of the visibility of the window. Currently only affects X11 and Wayland VOs since they are the only ones that have this optimization (i.e. everything else always renders regardless of visibility). Forcefully move mpv's video output window to default location whenever there is a change in video parameters, video stream or file. This used to be the default behavior. Currently only affects X11 and SDL VOs. By default, mpv will automatically resize itself if the video's size changes (i.e. advancing forward in a playlist). Setting this to disables this behavior so the window size never changes automatically. This option does not have any impact on the or options. will always stretch the video to window size, and will disable the window manager hints that force the window aspect ratio. (Ignored in fullscreen mode.) Set the aspect ratio of your monitor or TV screen. A value of 0 disables a previous setting (e.g. in the config file). Overrides the setting if enabled. See also and . Scale the window size according to the backing DPI scale factor from the OS (default: no). For example, if the OS DPI scaling is set to 200%, mpv's window size will be multiplied by 2. (macOS only) Uses the native fullscreen mechanism of the OS (default: yes). (Windows and X11 only) Show mpv in the taskbar (default: yes). If set to no, mpv will no longer appear in taskbars and tasklists in supported window managers, and may be excluded from Alt+Tab window switching. Set the aspect of a single pixel of your monitor or TV screen (default: 1). A value of 1 means square pixels (correct for (almost?) all LCDs). See also and . Turns off the screensaver (or screen blanker and similar mechanisms) at startup and turns it on again on exit (default: yes). When using , the screensaver will re-enable when playback is not active. will always disable the screensaver. Note that stopping the screensaver is only possible if a video output is available (i.e. there is an open mpv window). This is not supported on all video outputs, platforms, or desktop environments. Before mpv 0.33.0, the X11 backend ran in 10 second intervals when not paused in order to support screensaver inhibition in some environments. This functionality was removed in 0.33.0, but it is possible to call the command line program from a user script instead. This tells mpv to attach to an existing window. If a VO is selected that supports this option, it will use that window for video output. mpv will scale the video to the size of this window, and will add black bars to compensate if the aspect ratio of the video is different. On X11, the ID is interpreted as a on X11. Unlike MPlayer/mplayer2, mpv always creates its own window, and sets the wid window as parent. The window will always be resized to cover the parent window fully. The value is interpreted specially, and mpv will draw directly on the root window. On win32, the ID is interpreted as . Pass it as value cast to (all Windows handles are 32-bit), this is important as mpv will not accept negative values. mpv will create its own window and set the wid window as parent, like with X11. On macOS/Cocoa, the ID is interpreted as . Pass it as value cast to . mpv will create its own sub-view. Because macOS does not support window embedding of foreign processes, this works only with libmpv, and will crash when used from the command line. On Android, the ID is interpreted as . Pass it as a value cast to . Use with and for direct rendering using MediaCodec, or with (with or without ). Move the window when clicking on it and moving the mouse pointer (default: yes). Set the window instance name for X11-based video output methods. (X11 only) Control the use of NetWM protocol features. This may or may not help with broken window managers. This provides some functionality that was implemented by the now removed option. Actually, it is not known to the developers to which degree this option was needed, so feedback is welcome. Specifically, will force use of NetWM fullscreen support, even if not advertised by the WM. This can be useful for WMs that are broken on purpose, like XMonad. (XMonad supposedly doesn't advertise fullscreen support, because Flash uses it. Apparently, applications which want to use fullscreen anyway are supposed to either ignore the NetWM support hints, or provide a workaround. Shame on XMonad for deliberately breaking X protocols (as if X isn't bad enough already). This option might be removed in the future. If set to , then ask the compositor to unredirect the mpv window (default: ). This uses the hint. asks the window manager to disable the compositor only in fullscreen mode. sets to 0, which is the default value as declared by the EWMH specification, i.e. no change is done. asks the window manager to never disable the compositor. Whether or not to use presentation statistics from X11's presentation extension (default: ). mpv asks X11 for present events which it then may use for more accurate frame presentation. This only has an effect if is being used. The auto option enumerates XRandr providers for autodetection. If amd, radeon, intel, or nouveau (the standard x86 Mesa drivers) is found and nvidia is NOT found, presentation feedback is enabled. Other drivers are not assumed to work, so they are not enabled automatically. or can still be passed regardless to enable/disable this mechanism in case there is good/bad behavior with whatever your combination of hardware/drivers/etc. happens to be. Whether or not to set the window title when mpv is embedded on X11 (default: ). Specify the CD device for CDDA playback (default: ). Specify the DVD device or .iso filename (default: ). You can also specify a directory that contains files previously copied directly from a DVD (with e.g. vobcopy). (Blu-ray only) Specify the Blu-ray disc location. Must be a directory with Blu-ray structure. These options can be used to tune the CD Audio reading feature of mpv. Set paranoia level. Values other than 0 seem to break playback of anything but the first track. Force minimum overlap search during verification to <value> sectors. Add sectors to the values reported when addressing tracks. May be negative. Print CD text. This is disabled by default, because it ruins performance with CD-ROM drives for unknown reasons. Try to limit DVD speed (default: 0, no change). DVD base speed is 1385 kB/s, so an 8x drive can read at speeds up to 11080 kB/s. Slower speeds make the drive more quiet. For watching DVDs, 2700 kB/s should be quiet and fast enough. mpv resets the speed to the drive default value on close. Values of at least 100 mean speed in kB/s. Values less than 100 mean multiples of 1385 kB/s, i.e. selects 11080 kB/s. You need write access to the DVD device to change the speed. Some DVDs contain scenes that can be viewed from multiple angles. This option tells mpv which angle to use (default: 1). Adjust the brightness of the video signal (default: 0). Not supported by all video output drivers. Adjust the contrast of the video signal (default: 0). Not supported by all video output drivers. Adjust the saturation of the video signal (default: 0). You can get grayscale output with this option. Not supported by all video output drivers. Adjust the gamma of the video signal (default: 0). Not supported by all video output drivers. Adjust the hue of the video signal (default: 0). You can get a colored negative of the image with this option. Not supported by all video output drivers. Force demuxer type. Use a '+' before the name to force it; this will skip some checks. Give the demuxer name as printed by . Maximum length in seconds to analyze the stream properties. Whether to probe stream information (default: auto). Technically, this controls whether libavformat's function is called. Usually it's safer to call it, but it can also make startup slower. The choice (the default) tries to skip this for a few know-safe whitelisted formats, while calling it for everything else. The choice only calls it if and only if the file seems to contain no streams after opening (helpful in cases when calling the function is needed to detect streams at all, such as with FLV files). Minimum required libavformat probe score. Lower values will require less data to be loaded (makes streams start faster), but makes file format detection less reliable. Can be used to force auto-detected libavformat demuxers, even if libavformat considers the detection not reliable enough. (Default: 26.) Allow deriving the format from the HTTP MIME type (default: yes). Set this to no in case playing things from HTTP mysteriously fails, even though the same files work from local disk. This is default in order to reduce latency when opening HTTP streams. By default, some formats will be handled differently from other formats by explicitly checking for them. Most of these compensate for weird or imperfect behavior from libavformat demuxers. Passing disables these. For debugging and testing only. Note, a patch to make the o= unneeded and pass all unknown options through the AVOption system is welcome. A full list of AVOptions can be found in the FFmpeg manual. Note that some options may conflict with mpv options. This is a key/value list option. See List Options for details. Maximum amount of data to probe during the detection phase. In the case of MPEG-TS this value identifies the maximum number of TS packets to scan. Size of the stream read buffer allocated for libavformat in bytes (default: 32768). Lowering the size could lower latency. Note that libavformat might reallocate the buffer internally, or not fully use all of it. Attempt to linearize timestamp resets in demuxed streams (default: auto). This was tested only for single audio streams. It's unknown whether it works correctly for video (but likely won't). Note that the implementation is slightly incorrect either way, and will introduce a discontinuity by about 1 codec frame size. The mode enables this for OGG audio stream. This covers the common and annoying case of OGG web radio streams. Some of these will reset timestamps to 0 every time a new song begins. This breaks the mpv seekable cache, which can't deal with timestamp resets. Note that FFmpeg/libavformat's seeking API can't deal with this either; it's likely that if this option breaks this even more, while if it's disabled, you can at least seek within the first song in the stream. Well, you won't get anything useful either way if the seek is outside of mpv's cache. Propagate FFmpeg-level options to recursively opened connections (default: yes). This is needed because FFmpeg will apply these settings to nested AVIO contexts automatically. On the other hand, this could break in certain situations - it's the FFmpeg API, you just can't win. This affects in particular the option and anything passed with . If this option is deemed unnecessary at some point in the future, it will be removed without notice. Try harder to show embedded soft subtitles when seeking somewhere. Normally, it can happen that the subtitle at the seek target is not shown due to how some container file formats are designed. The subtitles appear only if seeking before or exactly to the position a subtitle first appears. To make this worse, subtitles are often timed to appear a very small amount before the associated video frame, so that seeking to the video frame typically does not demux the subtitle at that position. Enabling this option makes the demuxer start reading data a bit before the seek target, so that subtitles appear correctly. Note that this makes seeking slower, and is not guaranteed to always work. It only works if the subtitle is close enough to the seek target. Works with the internal Matroska demuxer only. Always enabled for absolute and hr-seeks, and this option changes behavior with relative or imprecise seeks only. You can use the option to specify how much data the demuxer should pre-read at most in order to find subtitle packets that may overlap. Setting this to 0 will effectively disable this preroll mechanism. Setting a very large value can make seeking very slow, and an extremely large value would completely reread the entire file from start to seek target on every seek - seeking can become slower towards the end of the file. The details are messy, and the value is actually rounded down to the cluster with the previous video keyframe. Some files, especially files muxed with newer mkvmerge versions, have information embedded that can be used to determine what subtitle packets overlap with a seek target. In these cases, mpv will reduce the amount of data read to a minimum. (Although it will still read all data between the cluster that contains the first wanted subtitle packet, and the seek target.) If the choice (which is the default) is specified, then prerolling will be done only if this information is actually available. If this method is used, the maximum amount of data to skip can be additionally controlled by (it still uses the value of the option without if that is higher). See also option. This option can achieve a similar effect, but only if hr-seek is active. It works with any demuxer, but makes seeking much slower, as it has to decode audio and video data instead of just skipping over it. Check the start time of Matroska files (default: yes). This simply reads the first cluster timestamps and assumes it is the start time. Technically, this also reads the first timestamp, which may increase latency by one frame (which may be relevant for live streams). When opening the file, seek to the end of it, and check what timestamp the last video packet has, and report that as file duration. This is strictly for compatibility with Haali only. In this mode, it's possible that opening will be slower (especially when playing over http), or that behavior with broken files is much worse. So don't use this option. The mode merely uses the index and reads a small number of blocks from the end of the file. The mode actually traverses the entire file and can make a reliable estimate even without an index present (such as partial files). Number of channels (or channel layout) if is used (default: stereo). Sample format for (default: s16le). Use to get a list of all formats. Rate in frames per second for (default: 25.0). Color space (fourcc) in hex or string for (default: ). Color space by internal video format for . Use for a list of possible formats. Set the video codec instead of selecting the rawvideo codec when using . This uses the same values as codec names in (but it does not accept decoder names). Frame size in bytes when using . This controls how much the demuxer is allowed to buffer ahead. The demuxer will normally try to read ahead as much as necessary, or as much is requested with . The option can be used to restrict the maximum readahead. This limits excessive readahead in case of broken files or desynced playback. The demuxer will stop reading additional packets as soon as one of the limits is reached. (The limits still can be slightly overstepped due to technical reasons.) Set these limits higher if you get a packet queue overflow warning, and you think normal playback would be possible with a larger packet queue. See for defaults and value range. options accept suffixes such as and . This controls how much past data the demuxer is allowed to preserve. This is useful only if the cache is enabled. Unlike the forward cache, there is no control how many seconds are actually cached - it will simply use as much memory this option allows. Setting this option to 0 will strictly disable any back buffer, but this will lead to the situation that the forward seek range starts after the current playback position (as it removes past packets that are seek points). If the end of the file is reached, the remaining unused forward buffer space is \"donated\" to the backbuffer (unless the backbuffer size is set to 0, or is set to ). This still limits the total cache usage to the sum of the forward and backward cache, and effectively makes better use of the total allowed memory budget. (The opposite does not happen: free backward buffer is never \"donated\" to the forward buffer.) Keep in mind that other buffers in the player (like decoders) will cause the demuxer to cache \"future\" frames in the back buffer, which can skew the impression about how much data the backbuffer contains. See for defaults and value range. Whether to let the back buffer use part of the forward buffer (default: yes). If set to , the \"donation\" behavior described in the option description for is enabled. This means the back buffer may use up memory up to the sum of the forward and back buffer options, minus the active size of the forward buffer. If set to , the options strictly limit the forward and back buffer sizes separately. Note that if the end of the file is reached, the buffered data stays the same, even if you seek back within the cache. This is because the back buffer is only reduced when new data is read. Debugging option to control whether seeking can use the demuxer cache (default: auto). Normally you don't ever need to set this; the default does the right thing and enables cache seeking it if is set to (or is implied if ). If enabled, short seek offsets will not trigger a low level demuxer seek (which means for example that slow network round trips or FFmpeg seek bugs can be avoided). If a seek cannot happen within the cached range, a low level seek will be triggered. Seeking outside of the cache will start a new cached range, but can discard the old cache range if the demuxer exhibits certain unsupported behavior. The special value means in the same situation as is used (i.e. when the stream appears to be a network stream or the stream cache is enabled). Run the demuxer in a separate thread, and let it prefetch a certain amount of packets (default: yes). Having this enabled leads to smoother playback, enables features like prefetching, and prevents that stuck network freezes the player. On the other hand, it can add overhead, or the background prefetching can hog CPU resources. Disabling this option is not recommended. Use it for debugging only. Number of seconds the player should wait to shutdown the demuxer (default: 0.1). The player will wait up to this much time before it closes the stream layer forcefully. Forceful closing usually means the network I/O is given no chance to close its connections gracefully (of course the OS can still close TCP connections properly), and might result in annoying messages being logged, and in some cases, confused remote servers. This timeout is usually only applied when loading has finished properly. If loading is aborted by the user, or in some corner cases like removing external tracks sourced from network during playback, forceful closing is always used. If is enabled, this controls how much the demuxer should buffer ahead in seconds (default: 1). As long as no packet has a timestamp difference higher than the readahead amount relative to the last packet returned to the decoder, the demuxer keeps reading. Note that enabling the cache (such as , or if the input is considered a network stream, and is used), this option is mostly ignored. ( will override this. Technically, the maximum of both options is used.) The main purpose of this option is to limit the readhead for local playback, since a large readahead value is not overly useful in this case. Once the demuxer limit is reached ( , or ), this value can be used to specify a hysteresis before the demuxer will buffer ahead again. This specifies the maximum number of seconds from the current playback position that needs to be remaining in the cache before the demuxer will continue buffering ahead. For example, with a value of 10 seconds specified, the demuxer will buffer ahead up to the demuxer limit and won't start buffering ahead again until there is only 10 seconds of content left in the cache. This can provide significant power savings and reduce load by making the demuxer only buffer ahead in chunks at a time rather than buffering ahead nonstop to keep the cache filled. If you want to save power and reduce load, configure this to a small number that's much lower than or . If it takes a long time to buffer anything at all for a given stream (like when reading from a very slow disk is involved), then the hysteresis value should be larger to compensate. The default value is 0 seconds, which disables the caching hysteresis. A value of 10 seconds probably works well for most usecases. Prefetch next playlist entry while playback of the current entry is ending (default: no). This does not prefill the cache with the video data of the next URL. Prefetching video data is supported only for the current playlist entry, and depends on the demuxer cache settings (on by default). This merely opens the URL of the next playlist entry as soon the current URL is fully read. This does not work with URLs resolved by the wrapper, and it won't. This can give subtly wrong results if per-file options are used, or if options are changed in the time window between prefetching start and next file played. This can occasionally make wrong prefetching decisions. For example, it can't predict whether you go backwards in the playlist, and assumes you won't edit the playlist. If the player thinks that the media is not seekable (e.g. playing from a pipe, or it's an http stream with a server that doesn't support range requests), seeking will be disabled. This option can forcibly enable it. For seeks within the cache, there's a good chance of success. Before starting playback, read data until either the end of the file was reached, or the demuxer cache has reached maximum capacity. Only once this is done, playback starts. This intentionally happens before the initial seek triggered with . This does not change any runtime behavior after the initial caching. This option is useless if the file cannot be cached completely. When opening multi-volume rar files, open all volumes to create a full list of contained files (default: no). If disabled, only the archive entries whose headers are located within the first volume are listed (and thus played when opening a .rar file with mpv). Doing so speeds up opening, and the typical idiotic use-case of playing uncompressed multi-volume rar files that contain a single media file is made faster. Opening is still slow, because for unknown, idiotic, and unnecessary reasons libarchive opens all volumes anyway when playing the main file, even though mpv iterated no archive entries yet. When opening a directory, open subdirectories lazily, recursively or not at all. The default is , which behaves like with , and like otherwise. Media file types to filter when opening directory. If the list is empty, all files are added to the playlist. (Default: ) This is a string list option. See List Options for details. When opening a local file, act as if the parent directory is opened and create a playlist automatically. Create a playlist from the parent directory with files matching . Create a playlist from the parent directory with files matching the same category as the currently loaded file. One of the is selected based on the input file and only files with matching extensions are added to the playlist. If the input file itself is not matched to any extension list, the playlist is not autogenerated. Use system settings for keyrepeat delay and rate, instead of and (default: no). Whether this applies depends on the VO backend and how it handles keyboard input. Does not apply to terminal input. (Windows only) For platforms which send emulated mouse inputs for touch-unaware clients, such as Windows, use system native touch events, instead of receiving them as emulated mouse events (default: no). This is required for multi-touch support for these platforms. Note that this option has no effect on other platforms: either native touch is not supported by mpv, or the platform does not give an option to receive emulated mouse inputs (so native touch is always enabled, e.g. Wayland). Delay in milliseconds before we start to autorepeat a key (default: 200). Set it to 0 to disable. Number of key presses to generate per second on autorepeat (default: 40). Specify input configuration file other than the default location in the mpv configuration directory (usually ). Enable default-level (\"weak\") key bindings (default: yes). These are bindings which config files like can override. It currently affects the builtin key bindings, and keys which scripts bind using (but not because this overrides ). Enable loading of built-in key bindings during start-up (default: yes). This option is applied only during (lib)mpv initialization, and if disabled then it will not be not possible to enable them later. May be useful to libmpv clients. Enable the built-in window-dragging behavior (default: yes). Setting it to no disables the built-in dragging behavior. Note that unlike the option, this option only affects VOs which support the command, and does not disable window dragging initialized with the command. Prints all commands that can be bound to keys. Define a list of commands for mpv to run. The syntax is the same as format as but without the key binding argument at the beginning. When this option is set at startup, the commands will run after audio and video playback are about to begin if applicable (in idle mode with no file, it will run immediately). When changing values at runtime, the commands will also run as soon as possible. This is a string list option. See List Options for details. sets the playlist index to 1 and the ao-volume to 40 Time in milliseconds to recognize two consecutive button presses as a double-click (default: 300). Prints all keys that can be bound to commands. Specify the size of the FIFO that buffers key events (default: 7). If it is too small, some events may be lost. The main disadvantage of setting it to a very large value is that if you hold down a key triggering some particularly slow command then the player may be unresponsive while it processes all the queued commands. Input test mode. Instead of executing commands on key presses, mpv will show the keys and the bound commands on the OSD. Has to be used with a dummy video, and the normal ways to quit the player will not work (key bindings that normally quit will be shown on OSD only, just like any other binding). See INPUT.CONF. prevents the player from reading key events from standard input. Useful when reading data from standard input. This is automatically enabled when is found on the command line. There are situations where you have to set it manually, e.g. if you open (or the equivalent on your system), use stdin in a playlist or intend to read from stdin later on via the loadfile or loadlist input commands. Enable the IPC support and create the listening socket at the given path. On Linux and Unix, the given path is a regular filesystem path. On Windows, named pipes are used, so the path refers to the pipe namespace ( ). If the prefix is missing, mpv will add it automatically before creating the pipe, so and are equivalent for IPC on Windows. Connect a single IPC client to the given FD. This is somewhat similar to , except no socket is created, and instead the passed FD is treated like a socket connection received from . In practice, you could pass either a FD created by , or a pipe. In both cases, you must make sure that the FD is actually inherited by mpv (do not set the POSIX flag). The player quits when the connection is closed. This is somewhat similar to the removed option, except it supports only integer FDs, and cannot open actual paths. To use this option on Windows, the fd must refer to a wrapped (created by ) named pipe server handle with a client already connected. The named pipe must be created duplex with overlapped IO and inheritable handles. The program communicates with mpv through the client handle. Writing to the option at runtime will start another instance of an IPC client handler for the option, because initialization is bundled, and this thing is stupid. This is a bug. Writing to at runtime will start another IPC client handler for the new value, without stopping the old one, even if the FD value is the same (but the string is different e.g. due to whitespace). This is not a bug. Permit mpv to receive pointer events reported by the video output driver. Necessary to use the OSC. Support depends on the VO in use. Tell the backend windowing system to allow pointer events to passthrough the mpv window. This allows windows under mpv to instead receive pointer events as if the mpv window was never there. On systems where mpv can choose between receiving media keys or letting the system handle them - this option controls whether mpv should receive them. Default: yes (except for libmpv). macOS and Windows only, because elsewhere mpv doesn't have a choice - the system decides whether to send media keys to mpv. For instance, on X11 or Wayland, system-wide media keys are not implemented. Whether media keys work when the mpv window is focused is implementation-defined. Preprocess events so that while scrolling on the horizontal or vertical direction, the events aren't generated for another direction even when the two directions are scrolled together (default: yes). This preprocessing can be beneficial for preventing accidentally seeking while changing the volume by scrolling on a touchpad with the default keybind. Due to the deadzone mechanism used, disabling the preprocessing allows for diagonal scrolling (such as panning) and potentially reduces input latency. Note that disabling the preprocessing does not affect any filtering done by the OS/driver before these events are delivered to mpv, if any. (macOS and Windows only) Use the right Alt key as Alt Gr to produce special characters. If disabled, count the right Alt as an Alt modifier key. Enabled by default. Disable all keyboard input on for VOs which can't participate in proper keyboard input dispatching. May not affect all VOs. Generally useful for embedding only. On X11, a sub-window with input enabled grabs all keyboard input as long as it is 1. a child of a focused window, and 2. the mouse is inside of the sub-window. It can steal away all keyboard input from the application embedding the mpv window, and on the other hand, the mpv window will receive no input if the mouse is outside of the mpv window, even though mpv has focus. Modern toolkits work around this weird X11 behavior, but naively embedding foreign windows breaks it. The only way to handle this reasonably is using the XEmbed protocol, which was designed to solve these problems. GTK provides , which supports XEmbed. Qt doesn't seem to provide anything working in newer versions. If the embedder supports XEmbed, input should work with default settings and with this option disabled. Note that is disabled by default in libmpv as well - it should be enabled if you want the mpv default key bindings. When multi-touch support is enabled (either required by the platform, or enabled by ), emulate mouse move and button presses for the touch events (default: yes). This is useful for compatibility for mouse key bindings and scripts which read mouse positions for platforms which do not support (e.g. Wayland). Begin the built-in window dragging when the mouse moves outside a deadzone of pixels while the mouse button is being held down (default: 3). This only affects VOs which support the command. Whether to load the on-screen-controller (default: yes). Enable display of the OSD bar (default: yes). You can configure this on a per-command basis in input.conf using prefixes, see . If you want to disable the OSD completely, use . Set what is displayed on the OSD during seeks. The default is . You can configure this on a per-command basis in input.conf using prefixes, see . Set the duration of the OSD messages in ms (default: 1000). Specify font to use for OSD. The default is . Specify the OSD font size. See for details. Show this string as message on OSD with OSD level 1 (visible by default). The message will be visible by default, and as long as no other message covers it, and the OSD level isn't changed (see ). Expands properties; see Property Expansion. Similar to , but for OSD level 2. If this is an empty string (default), then the playback time is shown. Similar to , but for OSD level 3. If this is an empty string (default), then the playback time, duration, and some more information is shown. This is used for the command (by default mapped to ), and when seeking if enabled with or by prefixes in input.conf (see ). is a legacy equivalent (but with a minor difference). Show a custom string during playback instead of the standard status text. This overrides the status text used for , when using the command (by default mapped to ), and when seeking if enabled with or prefixes in input.conf (see ). Expands properties. See Property Expansion. This option has been replaced with . The only difference is that this option implicitly includes . This option is ignored if is not empty. Show a message on OSD when playback starts. The string is expanded for properties, e.g. will show the message followed by a space and the currently played filename. Set the duration of in ms. If this is unset, stays on screen for the duration of . Whether to display the media title, filename, or both. If the is not available, it will display only the . Position of the OSD bar. -1 is far left, 0 is centered, 1 is far right. Fractional values (like 0.5) are allowed. Position of the OSD bar. -1 is top, 0 is centered, 1 is bottom. Fractional values (like 0.5) are allowed. Width of the OSD bar, in percentage of the screen width (default: 75). A value of 50 means the bar is half the screen wide. Height of the OSD bar, in percentage of the screen height (default: 3.125). Size of the outline of the OSD bar in scaled pixels (see for details). is an alias for . Gaussian blur factor applied to the OSD font border. 0 means no blur applied (default). See . Color used for the OSD font outline. is an alias for . See . Color used for OSD text background. is an alias for . Size of the OSD font outline in scaled pixels (see for details). A value of 0 disables outlines. is an alias for . See . Style used for OSD text border. Specify the color used for OSD. See for details. Show OSD times with fractions of seconds (in millisecond precision). Useful to see the exact timestamp of a video frame. Specifies which mode the OSD should start in. enabled (shows up only on user interaction) Left and right screen margin for the OSD in scaled pixels (see for details). This option specifies the distance of the OSD to the left, as well as at which distance from the right border long OSD text will be broken. Top and bottom screen margin for the OSD in scaled pixels (see for details). This option specifies the vertical margins of the OSD. Control to which corner of the screen OSD should be aligned to (default: ). Whether to scale the OSD with the window size (default: yes). If this is disabled, and other OSD options that use scaled pixels are always in actual pixels. The effect is that changing the window size won't change the OSD font size. For scripts which draw user interface elements, it is recommended to respect the value of this option when deciding whether the elements are scaled with window size or not. Displacement of the OSD shadow in scaled pixels (see for details). A value of 0 disables shadows. Horizontal OSD/sub font spacing in scaled pixels (see for details). This value is added to the normal letter spacing. Negative values are allowed. Enabled OSD rendering on the video window (default: yes). This can be used in situations where terminal OSD is preferred. If you just want to disable all OSD rendering, use . It does not affect subtitles or overlays created by scripts (in particular, the OSC needs to be disabled with ). This option is somewhat experimental and could be replaced by another mechanism in the future. See for details and accepted values. Note that unlike subtitles, OSD never uses embedded fonts from media files. See for details. Defaults to . Set the image file type used for saving screenshots. Tag screenshots with the appropriate colorspace (default: yes). Note that not all formats support this. When it is unsupported, or when this option is disabled, screenshots will be converted to sRGB before being written. If possible, write screenshots with a bit depth similar to the source video (default: yes). This is interesting in particular for PNG, as this sometimes triggers writing 16 bit PNGs with huge file sizes. This will also include an unused alpha channel in the resulting files if 16 bit is used. Specify the filename template used to save screenshots. The template specifies the filename without file extension, and can contain format specifiers, which will be substituted when taking a screenshot. By default, the template is , which results in filenames like for example. The template can start with a relative or absolute path, in order to specify a directory location where screenshots should be saved. If the final screenshot filename points to an already existing file, the file will not be overwritten. The screenshot will either not be saved, or if the template contains , saved using different, newly generated filename. A sequence number, padded with zeros to length X (default: 04). E.g. passing the format will yield on the 12th screenshot. The number is incremented every time a screenshot is taken or if the file already exists. The length must be in the range 0-9. With the optional # sign, mpv will use the lowest available number. For example, if you take three screenshots--0001, 0002, 0003--and delete the first two, the next two screenshots will not be 0004 and 0005, but 0001 and 0002 again. Filename of the currently played video. Same as , but strip the file extension, including the dot. Directory path of the currently played video. If the video is not on the filesystem (but e.g. ), this expand to an empty string. Same as , but if the video file is not on the filesystem, return the fallback string inside the . Current playback time, in the same format as used in the OSD. The result is a string of the form \"HH:MM:SS\". For example, if the video is at the time position 5 minutes and 34 seconds, will be replaced with \"00:05:34\". Similar to , but extended with the playback time in milliseconds. It is formatted as \"HH:MM:SS.mmm\", with \"mmm\" being the millisecond part of the playback time. This is a simple way for getting unique per-frame timestamps. (Frame numbers would be more intuitive, but are not easily implementable because container formats usually use time stamps for identifying frames.) Specify the current playback time using the format string . is like , and is like . hour (padded with 0 to two digits) like , but as float Specify the current local date/time using the format . This format specifier uses the UNIX function internally, and inserts the result of passing \"%X\" to . For example, will insert the number of the current month as number. You have to use multiple specifiers to build a full date/time string. Insert the value of the input property 'prop'. E.g. is the same as . If the property does not exist or is not available, an error text is inserted, unless a fallback is specified. Replaced with the character itself. Store screenshots in this directory. This path is joined with the filename generated by . If the template filename is already absolute, the directory is ignored. is an alias for . If the directory does not exist, it is created on the first screenshot. If it is not a directory, an error is generated when trying to write a screenshot. This option is not set by default, and thus will write screenshots to the directory from which mpv was started. In pseudo-gui mode (see PSEUDO GUI MODE), this is set to the desktop. Set the JPEG quality level. Higher means better quality. The default is 90. Write JPEG files with the same chroma subsampling as the video (default: yes). If disabled, the libjpeg default is used. Set the PNG compression level. Higher means better compression. This will affect the file size of the written screenshot file and the time it takes to write a screenshot. Too high compression might occupy enough CPU time to interrupt playback. The default is 7. Set the filter applied prior to PNG compression. 0 is none, 1 is \"sub\", 2 is \"up\", 3 is \"average\", 4 is \"Paeth\", and 5 is \"mixed\". This affects the level of compression that can be achieved. For most images, \"mixed\" achieves the best compression ratio, hence it is the default. Write lossless WebP files. is ignored if this is set. The default is no. Set the WebP quality level. Higher means better quality. The default is 75. Set the WebP compression level. Higher means better compression, but takes more CPU time. Note that this also affects the screenshot quality when used with lossy WebP files. The default is 4. Set the JPEG XL Butteraugli distance. Lower means better quality. Lossless is 0.0, and 1.0 is approximately equivalent to JPEG quality 90 for photographic content. Use 0.1 for \"visually lossless\" screenshots. The default is 1.0. Set the JPEG XL compression effort. Higher effort (usually) means better compression, but takes more CPU time. The default is 4. Specify the AV1 encoder to be used by libavcodec for encoding avif screenshots. Specify the pixel format for the libavcodec encoder. Defaults to empty, which lets mpv pick one close to the source format. Specifies libavcodec options for selected encoder. For more information, consult the FFmpeg documentation. Note: the default is only guaranteed to work with the libaom-av1 encoder. Above options may not be valid and or optimal for other encoders. This is a key/value list option. See List Options for details. sets the crf to 23 and quantization (aq-mode) to complexity based. Whether to use software rendering for screenshots (default: no). If set to no, the screenshot will be rendered by the current VO (only vo_gpu or vo_gpu_next currently). The advantage is that this will (probably) always show up as in the video window, because the same code is used for rendering. But since the renderer needs to be reinitialized, this can be slow and interrupt playback. If set to yes, the software scaler is used to convert the video to RGB (or whatever the target screenshot requires). In this case, conversion will run in a separate thread and will probably not interrupt playback. The software renderer may lack some capabilities, such as HDR rendering. If mode is used, the image will also be scaled in software which may not accurately reflect the actual visible result. Specify the software scaler algorithm to be used with . This also affects video output drivers which lack hardware acceleration, e.g. . See also . To get a list of available scalers, run . Unknown functionality (default: no). Consult libswscale source code. The primary purpose of this, as far as libswscale API goes), is to produce exactly the same output for the same input on all platforms (output has the same \"bits\" everywhere, thus \"bitexact\"). Typically disables optimizations. Allow optimizations that help with performance, but reduce quality (default: no). VOs like and will benefit a lot from using . You may need to set other options, like . The builtin profile sets this option and some others to gain performance for reduced quality. Also see . Allow using zimg (if the component using the internal swscale wrapper explicitly allows so) (default: yes). In this case, zimg may be used, if the internal zimg wrapper supports the input and output formats. It will silently or noisily fall back to libswscale if one of these conditions does not apply. If zimg is used, the other options are ignored, and the options are used instead. If the internal component using the swscale wrapper hooks up logging correctly, a verbose priority log message will indicate whether zimg is being used. Most things which need software conversion can make use of this. Do note that zimg may be slower than libswscale. Usually, it's faster on x86 platforms, but slower on ARM (due to lack of ARM specific optimizations). The mpv zimg wrapper uses unoptimized repacking for some formats, for which zimg cannot be blamed. Set scaler parameters. By default, these are set to the special string , which maps to a scaler-specific default value. Ignored if the scaler is not tunable. is the number of taps. a and b are the bicubic b and c parameters. Same as , for for chroma interpolation (default: bilinear). Same as / , for chroma. Set the maximum number of threads to use for scaling (default: auto). uses the number of logical cores on the current machine. Note that the scaler may use less threads (or even just 1 thread) depending on stuff. Passing a value of 1 disables threading and always scales the image in a single operation. Higher thread counts waste resources, but make it typically faster. Note that some zimg git versions had bugs that will corrupt the output if threads are used. Allow optimizations that help with performance, but reduce quality (default: yes). Currently, this may simplify gamma conversion operations. This controls the default options of any resampling done by mpv (but not within libavfilter, within the system audio API resampler, or any other places). Length of the filter with respect to the lower sampling rate. (default: 16) Log2 of the number of polyphase entries. (..., 10->1024, 11->2048, 12->4096, ...) (default: 10->1024) If set then filters will be linearly interpolated between polyphase entries. (default: no) Enable/disable normalization if surround audio is downmixed to stereo (default: no). If this is disabled, downmix can cause clipping. If it's enabled, the output might be too quiet. It depends on the source audio. If downmix happens outside of mpv for some reason, or in the decoder (decoder downmixing), or in the audio output (system mixer), this has no effect. Limit maximum size of audio frames filtered at once, in ms (default: 40). The output size size is limited in order to make resample speed changes react faster. This is necessary especially if decoders or filters output very large frame sizes (like some lossless codecs or some DRC filters). This option does not affect the resampling algorithm in any way. For testing/debugging only. Can be removed or changed any time. Set AVOptions on the SwrContext or AVAudioResampleContext. These should be documented by FFmpeg. This is a key/value list option. See List Options for details. Make console output less verbose; in particular, prevents the status line (i.e. AV: 3.4 (00:00:03.37) / 5320.6 ...) from being displayed. Particularly useful on slow terminals or broken ones which do not properly handle carriage return (i.e. ). See also: and . Display even less output and status messages than with . disables any use of the terminal and stdin/stdout/stderr. This completely silences any message output. Unlike , this disables input and terminal initialization as well. Control verbosity directly for each module. The module changes the verbosity of all the modules. The verbosity changes from this option are applied in order from left to right, and each item can override a previous one. Run mpv with to see all messages mpv outputs. You can use the module names printed in the output (prefixed to each line in ) to limit the output to interesting modules. This also affects , and in certain cases libmpv API logging. Some messages are printed before the command line is parsed and are therefore not affected by . To control these messages, you have to use the environment variable; see ENVIRONMENT VARIABLES for details. Completely silences the output of ao_sndio, which uses the log prefix . Only show warnings or worse, and let the ao_alsa output show errors only. Control whether OSD messages are shown on the console when no video output is available (default: auto). use terminal OSD if no video output active use terminal OSD even if video output active The mode also enables terminal OSD if was set. Enable printing a progress bar under the status line on the terminal. (Disabled by default.) Customize the feature. The string is expected to consist of 5 characters (start, left space, position indicator, right space, end). You can use Unicode characters, but note that double- width characters will not be treated correctly. Print out a string after starting playback. The string is expanded for properties, e.g. will print the string followed by a space and the currently played filename. Print out a custom string during playback instead of the standard status line. Expands properties. See Property Expansion. Set the terminal title. Currently, this simply concatenates the escape sequence setting the window title with the provided (property expanded) string. This will mess up if the expanded string contain bytes that end the escape sequence, or if the terminal does not understand the sequence. The latter probably includes the regrettable win32. Prepend module name to each console message. Prepend timing information to each console message. The time is in seconds since the player process was started (technically, slightly later actually), using a monotonic time source depending on the OS. This is on sane UNIX variants. Decide whether to use network cache settings (default: auto). If enabled, use up to for the cache size (but still limited to ), and make the cached data seekable (if possible). If disabled, and related are implicitly disabled. The choice enables this depending on whether the stream is thought to involve network accesses or other slow media (this is an imperfect heuristic). Before mpv 0.30.0, this used to accept a number, which specified the size of the cache in kilobytes. Use e.g. instead. How many seconds of audio/video to prefetch if the cache is active. This overrides the option if and only if the cache is enabled and the value is larger. The default value is set to something very high, so the actually achieved readahead will usually be limited by the value of the option. Setting this option is usually only useful for limiting readahead. Write packet data to a temporary file, instead of keeping them in memory. This makes sense only with . If the normal cache is disabled, this option is ignored. The cache file is append-only. Even if the player appears to prune data, the file space freed by it is not reused. The cache file is deleted when playback is closed. Note that packet metadata is still kept in memory. and related options are applied to metadata only. The size of this metadata varies, but 50 MB per hour of media is typical. The cache statistics will report this metadats size, instead of the size of the cache file. If the metadata hits the size limits, the metadata is pruned (but not the cache file). When the media is closed, the cache file is deleted. A cache file is generally worthless after the media is closed, and it's hard to retrieve any media data from it (it's not supported by design). If the option is enabled at runtime, the cache file is created, but old data will remain in the memory cache. If the option is disabled at runtime, old data remains in the disk cache, and the cache file is not closed until the media is closed. If the option is disabled and enabled again, it will continue to use the cache file that was opened first. Directory where to create temporary files. Cache is stored in the system's cache directory (usually ) if this is unset. Currently, this is used for only. Whether the player should automatically pause when the cache runs out of data and stalls decoding/playback (default: yes). If enabled, it will pause and unpause once more data is available, aka \"buffering\". Number of seconds the packet cache should have buffered before starting playback again if \"buffering\" was entered (default: 1). This can be used to control how long the player rebuffers if is enabled, and the demuxer underruns. If the given time is higher than the maximum set with or , or prefetching ends before that for some other reason (like file end or maximum configured cache size reached), playback resumes earlier. Enter \"buffering\" mode before starting playback (default: no). This can be used to ensure playback starts smoothly, in exchange for waiting some time to prefetch network data (as controlled by ). For example, some common behavior is that playback starts, but network caches immediately underrun when trying to decode more data as playback progresses. Another thing that can happen is that the network prefetching is so CPU demanding (due to demuxing in the background) that playback drops frames at first. In these cases, it helps enabling this option, and setting and to roughly the same value. This option also triggers when playback is restarted after seeking. Whether or when to unlink cache files (default: immediate). This affects cache files which are inherently temporary, and which make no sense to remain on disk after the player terminates. This is a debugging option. Unlink cache file after they were created. The cache files won't be visible anymore, even though they're in use. This ensures they are guaranteed to be removed from disk when the player terminates, even if it crashes. Delete cache files after they are closed. Don't delete cache files. They will consume disk space without having a use. Currently, this is used for only. Size of the low level stream byte buffer (default: 128KB). This is used as buffer between demuxer and low level I/O (e.g. sockets). Generally, this can be very small, and the main purpose is similar to the internal buffer FILE in the C standard library will have. Half of the buffer is always used for guaranteed seek back, which is important for unseekable input. There are known cases where this can help performance to set a large buffer:\n• mp4 files. libavformat may trigger many small seeks in both directions, depending on how the file was muxed.\n• Certain network filesystems, which do not have a cache, and where small reads can be inefficient. In other cases, setting this to a large value can reduce performance. Usually, read accesses are at half the buffer size, but it may happen that accesses are done alternating with smaller and larger sizes (this is due to the internal ring buffer wrap-around). See for defaults and value range. options accept suffixes such as and . Enable running the video/audio decoder on a separate thread (default: no). If enabled, the decoder is run on a separate thread, and a frame queue is put between decoder and higher level playback logic. The size of the frame queue is defined by the other options below. This is probably quite pointless. libavcodec already has multithreaded decoding (enabled by default), which makes this largely unnecessary. It might help in some corner cases with high bandwidth video that is slow to decode (in these cases libavcodec would block the playback logic, while using a decoding thread would distribute the decoding time evenly without affecting the playback logic). In other situations, it will simply make seeking slower and use significantly more memory. The queue size is restricted by the other options. The final queue size is the minimum as indicated by the option with the lowest limit. Each decoder/track has its own queue that may use the full configured queue size. Most queue options can be changed at runtime. itself (and the audio equivalent) update only if decoding is completely reinitialized. However, setting should almost lead to the same behavior as , so that value can be used for effectively runtime enabling/disabling the queue. This should not be used with hardware decoding. It is possible to enable this for audio, but it makes even less sense. Maximum approximate allowed size of the queue. If exceeded, decoding will be stopped. The maximum size can be exceeded by about 1 frame. See for defaults and value range. options accept suffixes such as and . Maximum number of frames (video) or samples (audio) of the queue. The audio size may be exceeded by about 1 frame. See for defaults and value range. Maximum number of seconds of media in the queue. The special value 0 means no limit is set. The queue size may be exceeded by about 2 frames. Timestamp resets may lead to random queue size usage. See for defaults and value range. Use as user agent for HTTP streaming. Read HTTP cookies from <filename>. The file is assumed to be in Netscape format. This is a string list option. See List Options for details. URL of the HTTP/HTTPS proxy. If this is set, the environment is ignored. The environment variable is still respected. This option is silently ignored if it does not start with . Proxies are not used for https URLs. Setting this option does not try to make the ytdl script use the proxy. Certificate authority database file for use with TLS. (Silently fails with older FFmpeg versions.) Verify peer certificates when using TLS (e.g. with ). (Silently fails with older FFmpeg versions.) A file containing a certificate to use in the handshake with the peer. A file containing the private key for the certificate. Specify a referrer path or URL for HTTP requests. Specify the network timeout in seconds (default: 60 seconds). This affects at least HTTP. The special value 0 uses the FFmpeg defaults. If a protocol is used which does not support timeouts, this option is silently ignored. This breaks the RTSP protocol, because of inconsistent FFmpeg API regarding its internal timeout option. Not only does the RTSP timeout option accept different units (seconds instead of microseconds, causing mpv to pass it huge values), it will also overflow FFmpeg internal calculations. The worst is that merely setting the option will put RTSP into listening mode, which breaks any client uses. At time of this writing, the fix was not made effective yet. For this reason, this option is ignored (or should be ignored) on RTSP URLs. You can still set the timeout option directly with . Select RTSP transport method (default: tcp). This selects the underlying network transport when playing URLs. The value leaves the decision to libavformat. If HLS streams are played, this option controls what streams are selected by default. The option allows the following parameters: Don't do anything special. Typically, this will simply pick the first audio/video streams it can find. Pick the streams with the lowest bitrate. Additionally, if the option is a number, the stream with the highest rate equal or below the option value is selected. The bitrate as used is sent by the server, and there's no guarantee it's actually meaningful. This defines the program to tune to. Usually, you may specify this by using a stream URI like , but you can tune to a different channel by writing to this property at runtime. Also see for more useful channel switching functionality. Instructs mpv to read the channels list from . The default is in the mpv configuration directory (usually ) with the filename (based on your card type) or as a last resort. Please note that using specific file name with card type is recommended, since the legacy channel format is not fully standardized so autodetection of the delivery system may fail otherwise. For DVB-S/2 cards, a VDR 1.7.x format channel list is recommended as it allows tuning to DVB-S2 channels, enabling subtitles and decoding the PMT (which largely improves the demuxing). Classic mplayer format channel lists are still supported (without these improvements), and for other card types, only limited VDR format channel list support is implemented (patches welcome). For channels with dynamic PID switching or incomplete , or the magic PID are recommended. Maximum number of seconds to wait when trying to tune a frequency before giving up (default: 30). Apply no filters on program PIDs, only tune to frequency and pass full transponder to demuxer. The player frontend selects the streams from the full TS in this case, so the program which is shown initially may not match the chosen channel. Switching between the programs is possible by cycling the property. This is useful to record multiple programs on a single transponder, or to work around issues in the . It is also recommended to use this for channels which switch PIDs on-the-fly, e.g. for regional news. This value is not meant for setting via configuration, but used in channel switching. An can this value and to perform channel switching. This number effectively gives the offset to the initially tuned to channel in the channel list. An example could contain: , The following video options are currently all specific to , and , which are the only VOs that implement them. The filter function to use when upscaling video. Bilinear hardware texture filtering (fastest, very low quality). This is the default when using the profile. Lanczos scaling. Provides good balance between quality and performance. This is the default for . The number of taps can be controlled with , but is best left unchanged. Elliptic weighted average Lanczos scaling. Also known as Jinc. Relatively slow, but very good quality. The radius can be controlled with . Increasing the radius makes the filter sharper but adds more ringing. A slightly sharpened version of . This is the default when using the profile. Very sharp scaler, but also slightly slower than . Prone to ringing, so it's recommended to combine this with an anti-ringing shader. On , setting this filter enables built-in anti-ringing, so no extra action needs to be taken. Mitchell-Netravali. Piecewise cubic filter with a support of radius 2.0. Provides a balanced compromise of all scaling artifacts. This filter has both and set to . The and parameters can be controlled with and . Hermite spline. Similar to but with set to . This filter has the special property of having a support of radius 1.0, making it very fast in comparison, but prone to blocking. This is the default for . Catmull-Rom spline. Similar to , but with and set to and respectively. This filter is sharper than , but prone to ringing. A version of nearest neighbour that (naively) oversamples pixels, so that pixels overlapping edges get linearly interpolated instead of rounded. This essentially removes the small imperfections and judder artifacts caused by nearest-neighbour interpolation, in exchange for adding some blur. This can also be used for frame mixing, where it is commonly known as \"smoothmotion\" (see ). There are some more filters, but most are not as useful. For a complete list, pass as value, e.g.: As , but for interpolating chroma information. If the image is not subsampled, this option is ignored entirely. If this option is unset, the filter implied by will be applied. Like , but apply these filters on downscaling instead. The filter used for interpolating the temporal axis (frames). This is only used if is enabled. The only valid choices for are separable convolution filters (use to get a list). The default is . Common choices include , , , , , or . These are listed in increasing order of smoothness/blurriness, with being the smoothest/blurriest and being the sharpest/least smooth. Set filter parameters. By default, these are set to the special string , which maps to a scaler-specific default value. Ignored if the filter is not tunable. Currently, this affects the following filter parameters: Spline parameters ( and ). Defaults to B=1 and C=0. Scale parameter ( ). Increasing this makes the result blurrier. Defaults to 1. Minimum distance to an edge before interpolation is used. Setting this to 0 will always interpolate edges, whereas setting it to 0.5 will never interpolate, thus behaving as if the regular nearest neighbour algorithm was used. Defaults to 0.0. Kernel scaling factor (also known as a blur factor). Decreasing this makes the result sharper, increasing it makes it blurrier (default 0). If set to 0, the kernel's preferred blur factor is used. Note that setting this too low (eg. 0.5) leads to bad results. It's generally recommended to stick to values between 0.8 and 1.2. Specifies a weight bias to multiply into negative coefficients. Specifying has the effect of removing negative weights completely, thus effectively clamping the value range to [0-1]. Values between 0.0 and 1.0 can be specified to apply only a moderate diminishment of negative weights. This is especially useful for , where it reduces excessive ringing artifacts in the temporal domain (which typically manifest themselves as short flashes or fringes of black, mostly around moving edges) in exchange for potentially adding more blur. The default for is 1.0, the others default to 0.0. Kernel/window taper factor. Increasing this flattens the filter function. Value range is 0 to 1. A value of 0 (the default) means no flattening, a value of 1 makes the filter completely flat (equivalent to a box function). Values in between mean that some portion will be flat and the actual filter function will be squeezed into the space in between. Set radius for tunable filters, must be a float number between 0.5 and 16.0. Defaults to the filter's preferred radius if not specified. Doesn't work for every scaler and VO combination. Note that depending on filter implementation details and video scaling ratio, the radius that actually being used might be different (most likely being increased a bit). Set the antiringing strength. This tries to eliminate ringing, but can introduce other artifacts in the process. Must be a float number between 0.0 and 1.0. The default value of 0.0 disables antiringing entirely. Note that this doesn't affect the special filters and , nor does it affect any polar (EWA) scalers. (Advanced users only) Choose a custom windowing function for the kernel. Defaults to the filter's preferred window if unset. Use to get a list of supported windowing functions. (Advanced users only) Configure the parameter for the window function given by etc. By default, these are set to the special string , which maps to a window-specific default value. Ignored if the window is not tunable. Currently, this affects the following window parameters: Scale parameter (t). Increasing this makes the window wider. Defaults to 1. Disable the scaler if the video image is not resized. In that case, is used instead of whatever is set with . Bilinear will reproduce the source image perfectly if no scaling is performed. Enabled by default. Note that this option never affects . When using convolution based filters, extend the filter size when downscaling. Increases quality, but reduces performance while downscaling. Enabled by default. This will perform slightly sub-optimally for anamorphic video (but still better than without it) since it will extend the size to match only the milder of the scale factors between the axes. Note: this option is ignored when using bilinear downscaling with . Scale in linear light when downscaling. It should only be used with a that has at least 16 bit precision. This option has no effect on HDR content. Enabled by default. Scale in linear light when upscaling. Like , it should only be used with a that has at least 16 bits precisions. This is not usually recommended except for testing/specific purposes. Users are advised to either enable or keep both options disabled (i.e. scaling in gamma light). When upscaling, use a sigmoidal color transform to avoid emphasizing ringing artifacts. Enabled by default. This is incompatible with and replaces . (Note that sigmoidization also requires linearization, so the rendering step fires in both cases) The center of the sigmoid curve used for , must be a float between 0.0 and 1.0. Defaults to 0.75 if not specified. The slope of the sigmoid curve used for , must be a float between 1.0 and 20.0. Defaults to 6.5 if not specified. Reduce stuttering caused by mismatches in the video fps and display refresh rate (also known as judder). This requires setting the option to one of the modes, or it will be silently disabled. This was not required before mpv 0.14.0. This essentially attempts to interpolate the missing frames by convoluting the video along the temporal axis. The filter used can be controlled using the setting. Threshold below which frame ratio interpolation gets disabled (default: ). This is calculated as , where is the speed-adjusted video FPS, and the display refresh rate. (The speed-adjusted video FPS is roughly equal to the normal video FPS, but with slowdown and speedup applied. This matters if you use to make video run synchronously to the display FPS, or if you change the property.) The default is intended to enable interpolation in scenarios where retiming with the cannot adjust the speed of the video sufficiently for smooth playback. For example if a video is 60.00 FPS and your display refresh rate is 59.94 Hz, interpolation will never be activated, since the mismatch is within 1% of the refresh rate. The default also handles the scenario when mpv cannot determine the container FPS, such as during certain live streams, and may dynamically toggle interpolation on and off. In this scenario, the default would be to not use interpolation but rather to allow to retime the video to match display refresh rate. See for more information about how mpv will retime video. Also note that if you use e.g. , small deviations in the rate can disable interpolation and introduce a discontinuity every other minute. Set this to to disable this logic. Preserve the previous frames' interpolated results even when renderer parameters are changed - with the exception of options related to cropping and video placement, which always invalidate the cache. Enabling this option makes dynamic updates of renderer settings slightly smoother at the cost of slightly higher latency in response to such changes. Defaults to on. (Only affects , note that always invalidates interpolated frames) Enable use of PBOs. On some drivers this can be faster, especially if the source video size is huge (e.g. so called \"4K\" video). On other drivers it might be slower or cause latency issues. Disable any dithering done by mpv. Automatic selection. On : detected depth or 8 bpc otherwise On : detected depth or 8 bpc (for SDR target) Note that the on-the-wire bit depth cannot be detected except when using . Explicitly setting the value to your display's bit depth is recommended, as dithering performed by some LCD panels can be of low quality. Set the size of the dither matrix (default: 6). The actual size of the matrix is for an option value of , so a value of 6 gives a size of 64x64. The matrix is generated at startup time, and a large matrix can take rather long to compute (seconds). Used in mode only. Select dithering algorithm (default: fruit). (Normally, the option controls whether dithering is enabled.) The option requires compute shader support. It also requires large amount of shared memory to run, the size of which depends on both the kernel (see option below) and the height of video window. It will fallback to dithering if there is no enough shared memory to run the shader. Enable temporal dithering. (Only active if dithering is enabled in general.) This changes between 8 different dithering patterns on each frame by changing the orientation of the tiled dithering matrix. Unfortunately, this can lead to flicker on LCD displays, since these have a high reaction time. Determines how often the dithering pattern is updated when is in use. 1 (the default) will update on every video frame, 2 on every other frame, etc. The error diffusion kernel to use when is set. Propagate error to only two adjacent pixels. Fastest but low quality. Fast with reasonable quality. This is the default. Looks different from other kernels because only fraction of errors will be propagated during dithering. A typical use case of this kernel is saving dithered screenshot (in window mode). This kernel produces slightly smaller file, with still reasonable dithering quality. There are other kernels (use to list) but most of them are much slower and demanding even larger amount of shared memory. Among these kernels, achieves a good balance between performance and quality, and probably is the one you want to try first. Enables GPU debugging. What this means depends on the API type. For OpenGL, it calls , and requests a debug context. For Vulkan, it enables validation layers. Interval in displayed frames between two buffer swaps. 1 is equivalent to enable VSYNC, 0 to disable VSYNC. Defaults to 1 if not specified. Note that this depends on proper OpenGL vsync support. On some platforms and drivers, this only works reliably when in fullscreen mode. It may also require driver-specific hacks if using multiple monitors, to ensure mpv syncs to the right one. Compositing window managers can also lead to bad results, as can missing or incorrect display FPS information (see ). (EGL only) Select EGLConfig with specific EGL_CONFIG_ID. Rendering surfaces and contexts will be created using this EGLConfig. You can use to obtain a list of available configs. (EGL only) Select a specific EGL output format to utilize for OpenGL rendering. This option is mutually exclusive with . \"auto\" is the default, which will pick the first usable config based on the order given by the driver. All formats are not available. A fatal error is caused if an unavailable format is selected. There is no reliable API to query desktop bit depth in EGL. You can manually set this option according to the bit depth of your display. This option also affects the auto-detection of . Unlike , this option also takes effect with . The name or UUID of the Vulkan device to use for rendering and presentation. Use to see the list of available devices and their names and UUIDs. If left unspecified, the first enumerated hardware Vulkan device will be used. Controls the presentation mode of the vulkan swapchain. This is similar to the option. Use the preferred swapchain mode for the vulkan context. (Default) Tearing, vsync blocked. Late frames will tear instead of stuttering. Tearing, not vsync blocked. Similar to \"VSync off\". Controls the number of VkQueues used for rendering (limited by how many your device supports). In theory, using more queues could enable some parallelism between frames (when using a higher than 1), but it can also slow things down on hardware where there's no true parallelism between queues. (Default: 1) Enables the use of async transfer queues on supported vulkan devices. Using them allows transfer operations like texture uploads and blits to happen concurrently with the actual rendering, thus improving overall throughput and power consumption. Enabled by default, and should be relatively safe. Enables the use of async compute queues on supported vulkan devices. Using this, in theory, allows out-of-order scheduling of compute shaders with graphics shaders, thus enabling the hardware to do more effective work while waiting for pipeline bubbles and memory operations. Not beneficial on all GPUs. It's worth noting that if async compute is enabled, and the device supports more compute queues than graphics queues (bound by the restrictions set by ), mpv will internally try and prefer the use of compute shaders over fragment shaders wherever possible. Enabled by default, although Nvidia users may want to disable it. The index of the display, on the selected Vulkan device, to present on when using the GPU context. Use to see the list of available displays. If left unspecified, the first enumerated display will be used. The index of the display mode, of the selected Vulkan display, to use when using the GPU context. Use to see the list of available modes. If left unspecified, the first enumerated mode will be used. The index of the plane, on the selected Vulkan device, to present on when using the GPU context. Use to see the list of available planes. If left unspecified, the first enumerated plane will be used. Switches the D3D11 swap chain fullscreen state to 'fullscreen' when fullscreen video is requested. Also known as \"exclusive fullscreen\" or \"D3D fullscreen\" in other applications. Gives mpv full control of rendering on the swap chain's screen. Off by default. Use WARP (Windows Advanced Rasterization Platform) with the D3D11 GPU backend (default: auto). This is a high performance software renderer. By default, it is only used when the system has no hardware adapters that support D3D11. While the extended GPU features will work with WARP, they can be very slow. Select a specific feature level when using the D3D11 GPU backend. By default, the highest available feature level is used. This option can be used to select a lower feature level, which is mainly useful for debugging. Most extended GPU features will not work at 9_x feature levels. Enable flip-model presentation, which avoids unnecessarily copying the backbuffer by sharing surfaces with the DWM (default: yes). This may cause performance issues with older drivers. If flip-model presentation is not supported (for example, on Windows 7 without the platform update), mpv will automatically fall back to the older bitblt presentation model. Schedule each frame to be presented for this number of VBlank intervals. (default: 1) Setting to 1 will enable VSync, setting to 0 will disable it. Select a specific D3D11 adapter to utilize for D3D11 rendering. Will pick the default adapter if unset. Alternatives are listed when the name \"help\" is given. Checks for matches based on the start of the string, case insensitive. Thus, if the description of the adapter starts with the vendor name, that can be utilized as the selection parameter. Hardware decoders utilizing the D3D11 rendering abstraction's helper functionality to receive a device, such as D3D11VA or DXVA2's DXGI mode, will be affected by this choice. Select a specific D3D11 output format to utilize for D3D11 rendering. \"auto\" is the default, which will pick either rgba8 or rgb10_a2 depending on the configured desktop bit depth. rgba16f and bgra8 are left out of the autodetection logic, and are available for manual testing. Desktop bit depth querying is only available from an API available from Windows 10. Thus on older systems it will only automatically utilize the rgba8 output format. For , this is used as a best-effort hint and libplacebo has the last say on which format is utilized. Select a specific D3D11 output color space to utilize for D3D11 rendering. \"auto\" is the default, which will select the color space of the desktop on which the swap chain is located. Values other than \"srgb\" and \"pq\" have had issues in testing, so they are mostly available for manual testing. Swap chain color space configuration is only available from an API available from Windows 10. Thus on older systems it will not work. By default, when using hardware decoding with , the video image will be copied (GPU-to-GPU) from the decoder surface to a shader resource. Set this option to avoid that copy by sampling directly from the decoder image. This may increase performance and reduce power usage, but can cause the image to be sampled incorrectly on the bottom and right edges due to padding, and may invoke driver bugs, since Direct3D 11 technically does not allow sampling from a decoder surface (though most drivers support it.) Currently only relevant for . Controls whether or not mpv opts into the configure bounds event if sent by the compositor (default: auto). This restricts the initial size of the mpv window to a certain maximum size intended by the compositor. In most cases, this simply just prevents the mpv window from being larger than the size of the monitor when it first renders. With the default value of , configure-bounds will silently be ignored if any or type option is also set. If supported by the compositor, mpv will send a hint using the content-type protocol telling the compositor what type of content is being displayed. (default) will automatically switch between telling the compositor the content is a photo, video or possibly none depending on internal heuristics. Disable mpv's internal vsync for Wayland-based video output (default: no). This is mainly useful for benchmarking wayland VOs when combined with , , and . Defines the size of an edge border (default: 16) to initiate client side resize events in the wayland contexts with the mouse. This is only active if there are no server side decorations from the compositor. Defines the size of an edge border (default: 32) to initiate client side resizes events in the wayland contexts with touch events. Enable the use of wayland's presentation time protocol for more accurate frame presentation if it is supported by the compositor (default: ). This only has an effect if is being used. Controls which compiler is used to translate GLSL to SPIR-V. This is only relevant for with . The possible choices are currently: Use the first available compiler. (Default) Use libshaderc, which is an API wrapper around glslang. This is generally the most preferred, if available. This option is deprecated, since there is only one usable value. It may be removed in the future. Custom GLSL hooks. These are a flexible way to add custom fragment shaders, which can be injected at almost arbitrary points in the rendering pipeline, and access all previous intermediate textures. Each use of the option will add another file to the internal list of shaders, while takes a list of files, and overwrites the internal list with it. The latter is a path list option (see List Options for details). The syntax is not stable yet and may change any time. The general syntax of a user shader looks like this: Each section of metadata, along with the non-metadata lines after it, defines a single block. There are currently two types of blocks, HOOKs and TEXTUREs. A block can set the following options: The name of this texture. Hooks can then bind the texture under this name using BIND. This must be the first option of the texture block. The dimensions of the texture. The height and depth are optional. The type of texture (1D, 2D or 3D) depends on the number of components specified. The texture format for the samples. Supported texture formats are listed in debug logging when the VO is initialized (look for ). Usually, this follows OpenGL naming conventions. For example, provides 3 channels with normalized 16 bit components. One oddity are float formats: for example, has 16 bit internal precision, but the texture data is provided as 32 bit floats, and the driver converts the data on texture upload. Although format names follow a common naming convention, not all of them are available on all hardware, drivers, GL versions, and so on. The min/magnification filter used when sampling from this texture. The border wrapping mode used when sampling from this texture. Following the metadata is a string of bytes in hexadecimal notation that define the raw texture data, corresponding to the format specified by , on a single line with no extra whitespace. A block can set the following options: The texture which to hook into. May occur multiple times within a metadata block, up to a predetermined limit. See below for a list of hookable textures. User-friendly description of the pass. This is the name used when representing this shader in the list of passes for property . Loads a texture (either coming from mpv or from a block) and makes it available to the pass. When binding textures from mpv, this will also set up macros to facilitate accessing it properly. See below for a list. By default, no textures are bound. The special name HOOKED can be used to refer to the texture that triggered this pass. Gives the name of the texture to save the result of this pass into. By default, this is set to the special name HOOKED which has the effect of overwriting the hooked texture. Specifies the size of the resulting texture for this pass. refers to an expression in RPN (reverse polish notation), using the operators + - * / > < !, floating point literals, and references to sizes of existing texture (such as MAIN.width or CHROMA.height), OUTPUT, or NATIVE_CROPPED (size of an input texture cropped after pan-and-scan, video-align-x/y, video-pan-x/y, etc. and possibly prescaled). By default, these are set to HOOKED.w and HOOKED.h, espectively. Specifies a condition that needs to be true (non-zero) for the shader stage to be evaluated. If it fails, it will silently be omitted. (Note that a shader stage like this which has a dependency on an optional hook point can still cause that hook point to be saved, which has some minor overhead) Indicates a pixel shift (offset) introduced by this pass. These pixel offsets will be accumulated and corrected during the next scaling pass ( or ). The default values are 0 0 which correspond to no shift. Note that offsets are ignored when not overwriting the hooked texture. A special value of will attempt to fix existing offset of HOOKED by align it with reference. It requires HOOKED to be resizable (see below). It works transparently with fragment shader. For compute shader, the predefined macro is required to handle coordinate mapping. Specifies how many components of this pass's output are relevant and should be stored in the texture, up to 4 (rgba). By default, this value is equal to the number of components in HOOKED. Specifies that this shader should be treated as a compute shader, with the block size bw and bh. The compute shader will be dispatched with however many blocks are necessary to completely tile over the output. Within each block, there will be tw*th threads, forming a single work group. In other words: tw and th specify the work group size, which can be different from the block size. So for example, a compute shader with bw, bh = 32 and tw, th = 8 running on a 500x500 texture would dispatch 16x16 blocks (rounded up), each with 8x8 threads. Compute shaders in mpv are treated a bit different from fragment shaders. Instead of defining a that produces an output sample, you directly define which writes to a fixed writeonly image unit named (this is bound by mpv) using . To help translate texture coordinates in the absence of vertices, mpv provides a special function to map from the texel space of the output image to the texture coordinates for all bound textures. In particular, is equivalent to , although using this only really makes sense if (tw,th) == (bw,bh). Each bound mpv texture (via ) will make available the following definitions to that shader pass, where NAME is the name of the bound texture: The sampling function to use to access the texture at a certain spot (in texture coordinate space, range [0,1]). This takes care of any necessary normalization conversions. Sample the texture at a certain offset in pixels. This works like NAME_tex but additionally takes care of necessary rotations, so that sampling at e.g. vec2(-1,0) is always one pixel to the left. The local texture coordinate of that texture, range [0,1]. The (rotated) size in pixels of the texture. The rotation matrix associated with this texture. (Rotates pixel space to texture coordinates) The coefficient that needs to be multiplied into the texture contents in order to normalize it to the range [0,1]. The raw bound texture itself. The use of this should be avoided unless absolutely necessary. Normally, users should use either NAME_tex or NAME_texOff to read from the texture. For some shaders however , it can be better for performance to do custom sampling from NAME_raw, in which case care needs to be taken to respect NAME_mul and NAME_rot. In addition to these parameters, the following uniforms are also globally available: A random number in the range [0-1], different per frame. A simple count of frames rendered, increases by one per frame and never resets (regardless of seeks). The size in pixels of the input image (possibly cropped and prescaled). The size in pixels of the visible part of the scaled (and possibly cropped) image. Texture offset introduced by user shaders or options like panscan, video-align-x/y, video-pan-x/y. Internally, vo_gpu may generate any number of the following textures. Whenever a texture is rendered and saved by vo_gpu, all of the passes that have hooked into it will run, in the order they were added by the user. This is a list of the legal hook points: Source planes (raw). Which of these fire depends on the image format of the source. Source planes (upscaled). These only fire on subsampled content. The combined image, in the source colorspace, before conversion to RGB. The image, after conversion to RGB, but before is applied. The main image, after conversion to RGB but before upscaling. Linear light image, before scaling. This only fires when , or is in effect. Sigmoidized light, before scaling. This only fires when is in effect. The image immediately before the scaler kernel runs. The image immediately after the scaler kernel runs. The final output image, after color management but before dithering and drawing to screen. Only the textures labelled with may be transformed by the pass. When overwriting a texture marked , the WIDTH, HEIGHT and OFFSET must be left at their default values. Specifies the options to use for tunable shader parameters. You can target specific named shaders by prefixing the shader name with a , e.g. . Without a prefix, parameters affect all shaders. The shader name is the base part of the shader filename, without the extension. ( only) Enable the debanding algorithm. This greatly reduces the amount of visible banding, blocking and other quantization artifacts, at the expense of very slightly blurring some of the finest details. In practice, it's virtually always an improvement - the only reason to disable it would be for performance. The number of debanding steps to perform per sample. Each step reduces a bit more banding, but takes time to compute. Note that the strength of each step falls off very quickly, so high numbers (>4) are practically useless. (Default 1) The debanding filter's cut-off threshold. Higher numbers increase the debanding strength dramatically but progressively diminish image details. (Default 48) The debanding filter's initial radius. The radius increases linearly for each iteration. A higher radius will find more gradients, but a lower radius will smooth more aggressively. (Default 16) If you increase the , you should probably decrease this to compensate. Add some extra noise to the image. This significantly helps cover up remaining quantization artifacts. Higher numbers add more noise. (Default 32) If set to a value above 0.0, the output will be rendered with rounded corners, as if an alpha transparency mask had been applied. The value indicates the relative fraction of the side length to round - a value of 1.0 rounds the corners as much as possible. ( only) If set to a value other than 0, enable an unsharp masking filter. Positive values will sharpen the image (but add more ringing and aliasing). Negative values will blur the image. If your GPU is powerful enough, consider alternatives like the scale filter, or the option. (Only for ) Call before swapping buffers (default: disabled). Slower, but might improve results when doing framedropping. Can completely ruin performance. The details depend entirely on the OpenGL driver. Call after each buffer swap (default: disabled). This may or may not help with video timing accuracy and frame drop. It's possible that this makes video output slower, or has no effect at all. (Windows only) Calls after swapping buffers on Windows (default: auto). It also sets to ignore the OpenGL timing. Values are: no (disabled), windowed (only in windowed mode), yes (also in full screen). The value will try to determine whether the compositor is active, and calls only if it seems to be. This may help to get more consistent frame intervals, especially with high-fps clips - which might also reduce dropped frames. Typically, a value of should be enough, since full screen may bypass the DWM. Selects a specific feature level when using the ANGLE backend with D3D11. By default, the highest available feature level is used. This option can be used to select a lower feature level, which is mainly useful for debugging. Note that OpenGL ES 3.0 is only supported at feature level 10_1 or higher. Most extended OpenGL features will not work at lower feature levels (similar to ). Use WARP (Windows Advanced Rasterization Platform) when using the ANGLE backend with D3D11 (default: auto). This is a high performance software renderer. By default, it is used when the Direct3D hardware does not support Direct3D 11 feature level 9_3. While the extended OpenGL features will work with WARP, they can be very slow. Use ANGLE's built in EGL windowing functions to create a swap chain (default: auto). If this is set to and the D3D11 renderer is in use, ANGLE's built in swap chain will not be used and a custom swap chain that is optimized for video rendering will be created instead. If set to , a custom swap chain will be used for D3D11 and the built in swap chain will be used for D3D9. This option is mainly for debugging purposes, in case the custom swap chain has poor performance or does not work. If set to , the option will have no effect. Enable flip-model presentation, which avoids unnecessarily copying the backbuffer by sharing surfaces with the DWM (default: yes). This may cause performance issues with older drivers. If flip-model presentation is not supported (for example, on Windows 7 without the platform update), mpv will automatically fall back to the older bitblt presentation model. If set to , the option will have no effect. Forces a specific renderer when using the ANGLE backend (default: auto). In auto mode this will pick D3D11 for systems that support Direct3D 11 feature level 9_3 or higher, and D3D9 otherwise. This option is mainly for debugging purposes. Normally there is no reason to force a specific renderer, though may give slightly better performance on old hardware. Note that the D3D9 renderer only supports OpenGL ES 2.0, so most extended OpenGL features will not work if this renderer is selected (similar to ). Deactivates the automatic graphics switching and forces the dedicated GPU. (default: no) Use the Apple Software Renderer when using cocoa-cb (default: auto). If set to the software renderer is never used and instead fails when a the usual pixel format could not be created, will always only use the software renderer, and only falls back to the software renderer when the usual pixel format couldn't be created. Creates a 10bit capable pixel format for the context creation (default: yes). Instead of 8bit integer framebuffer a 16bit half-float framebuffer is requested. This sets the color space of the layer to activate the macOS color transformation. Depending on the color space used the system's EDR (HDR) support will be activated. To get correct results, this needs to be set to the color primaries/transfer characteristics of the VO target. It is recommended to use this switch together with and . can be one of the following: Sets the color space to the icc profile of the screen (default). Same as sRGB but linear transfer function. Sets the appearance of the title bar (default: auto). Not all combinations of appearances and materials make sense or are unique. Appearances that are not supported by you current macOS version fall back to the default value. macOS only can be one of the following: Detects the system settings and sets the title bar appearance appropriately. On macOS 10.14 it also detects run time changes. Sets the material of the title bar (default: titlebar). All deprecated materials should not be used on macOS 10.14+ because their functionality is not guaranteed. Not all combinations of materials and appearances make sense or are unique. Materials that are not supported by you current macOS version fall back to the default value. macOS only can be one of the following: The standard macOS under page background material. (deprecated in macOS 10.14+) Sets the color of the title bar (default: completely transparent). Is influenced by and . See for color syntax. Sets the fullscreen resize animation duration in ms (default: default). The default value is slightly less than the system's animation duration (500ms) to prevent some problems when the end of an async animation happens at the same time as the end of the system wide fullscreen animation. Setting anything higher than 500ms will only prematurely cancel the resize animation after the system wide animation ended. The upper limit is still set at 1000ms since it's possible that Apple or the user changes the system defaults. Anything higher than 1000ms though seems too long and shouldn't be set anyway. (macOS) Changes the App activation policy. With accessory the mpv icon in the Dock can be hidden. (default: regular) This changes the rectangle which is used to calculate the screen position and size of the window (default: visible). takes the the menu bar and Dock into account and the window is only positioned/sized within the visible screen frame rectangle, takes the whole screen frame rectangle and ignores the menu bar and Dock. Other previous restrictions still apply, like the window can't be placed on top of the menu bar etc. Sets the mode (default: callback) for syncing the rendering of frames to the display's vertical refresh rate. macOS and Vulkan (macvk) only. can be one of the following: Syncs to the time of the next vertical display refresh reported by the CVDisplayLink callback provided information No manual syncing, depend on the layer mechanic and the next drawable Same as precise but uses the presentation feedback core mechanism Enables the default menu bar shortcuts (default: yes). The menu bar shortcuts always take precedence over any other shortcuts, they are not propagated to the mpv core and they can't be used in config files like or script bindings. Set dimensions of the rendering surface used by the Android gpu context. Needs to be set by the embedding application if the dimensions change during runtime (i.e. if the device is rotated), via the surfaceChanged callback. Continue even if a software renderer is detected. Specify a priority list of the GPU contexts to be used. The value (the default) selects the GPU context with the default autoprobe order. You can also pass to get a complete list of compiled in backends (sorted by the default autoprobe order). Note that the default GPU context is subject to change, and must not be relied upon. If a certain GPU context needs to be used, it must be explicitly specified. auto-select (default). Note that this context must be used alone and does not participate in the priority list. Direct3D11 through the OpenGL ES translation layer ANGLE. This supports almost everything the backend does (if the ANGLE build is new enough). Win32, using WGL for rendering and Direct3D 9Ex for presentation. Works on Nvidia and AMD. Newer Intel chips with the latest drivers may also work. VK_KHR_display. This backend is roughly the Vulkan equivalent of DRM/EGL, allowing for direct rendering via Vulkan without a display manager. Android/EGL. Requires be set to an . Vulkan on macOS with a metal surface through a translation layer (experimental) Use any available API (default). Note that the default GPU API used for this value is subject to change, and must not be relied upon. If a certain GPU API needs to be used, it must be explicitly specified. Allow only OpenGL (requires OpenGL 2.1+ or GLES 2.0+) Controls which type of OpenGL context will be accepted: Allow all types of OpenGL (default) Selects the internal format of textures used for FBOs. The format can influence performance and quality of the video output. can be one of: rgb8, rgb10, rgb10_a2, rgb16, rgb16f, rgb32f, rgba12, rgba16, rgba16f, rgba16hf, rgba32f. Default: , which first attempts to utilize 16bit float (rgba16f, rgba16hf), and falls back to rgba16 if those are not available. Finally, attempts to utilize rgb10_a2 or rgba8 if all of the previous formats are not available. Set an additional raw gamma factor (default: 1.0). If gamma is adjusted in other ways (like with the option or key bindings and the property), the value is multiplied with the other gamma value. This option is deprecated and may be removed in the future. Automatically corrects the gamma value depending on ambient lighting conditions (adding a gamma boost for bright rooms). This option is deprecated and may be removed in the future. Specifies a custom LUT file (in Adobe .cube format) to apply to the colors during image decoding. The exact interpretation of the LUT depends on the value of . (Only for ) Controls the interpretation of color values fed to and from the LUT specified as . Valid values are: Chooses the interpretation of the LUT automatically from tagged metadata, and otherwise falls back to . (Default) Applied to the raw image contents in its native colorspace, before decoding to RGB. For example, for a HDR10 image, this would be fed PQ-encoded YCbCr values in the range 0.0 - 1.0. Applied to the normalized RGB image contents, after decoding from its native color encoding, but before linearization. Fully replaces the color decoding. A LUT of this type should ingest the image's native colorspace and output normalized non-linear RGB. Automatically configure the output colorspace of the display to pass through the input values of the stream (e.g. for HDR passthrough), if possible. Requires a supporting driver and . Specifies the primaries of the display. Video colors will be adapted to this colorspace when ICC color management is not being used. Valid values are: Disable any adaptation, except for atypical color spaces. Specifically, wide/unusual gamuts get automatically adapted to BT.709, while standard gamut (i.e. BT.601 and BT.709) content is not touched. (default) CIE 1931 RGB (not to be confused with CIE XYZ) Specifies the transfer characteristics (gamma) of the display. Video colors will be adjusted to this curve when ICC color management is not being used. Valid values are: Disable any adaptation, except for atypical transfers. Specifically, HDR or linear light source material gets automatically converted to gamma 2.2, while SDR content is not touched. (default) Pure power curve (gamma 1.8), also used for Apple RGB Pure power curve (gamma 2.8), also used for BT.470-BG When using HDR output formats, mpv will encode to the specified curve but it will not set any HDMI flags or other signalling that might be required for the target device to correctly display the HDR signal. The user should independently guarantee this before using these signal formats for display. Specifies the measured peak brightness of the output display, in cd/m^2 (AKA nits). The interpretation of this brightness depends on the configured . In all cases, it imposes a limit on the signal values that will be sent to the display. If the source exceeds this brightness level, a tone mapping filter will be inserted. For HLG, it has the additional effect of parametrizing the inverse OOTF, in order to get colorimetrically consistent results with the mastering display. For SDR, or when using an ICC (profile ( ), setting this to a value above 203 essentially causes the display to be treated as if it were an HDR display in disguise. (See the note below) In mode (the default), the chosen peak is an appropriate value based on the TRC in use. For SDR curves, it uses 203. For HDR curves, it uses 203 * the transfer function's nominal peak. When using an SDR transfer function, this is normally not needed, and setting it may lead to very unexpected results. The one time it is useful is if you want to calibrate a HDR display using traditional transfer functions and calibration equipment. In such cases, you can set your HDR display to a high brightness such as 800 cd/m^2, and then calibrate it to a standard curve like gamma2.8. Setting this value to 800 would then instruct mpv to essentially treat it as an HDR display with the given peak. This may be a good alternative in environments where PQ or HLG input to the display is not possible, and makes it possible to use HDR displays with mpv regardless of operating system support for HDMI HDR metadata. In such a configuration, we highly recommend setting to or even . Specifies the measured contrast of the output display. in conjunction with value is used to calculate display black point. Used in black point compensation during HDR tone-mapping. is the default and assumes 1000:1 contrast as a typical SDR display would have or an infinite contrast when HDR is used. contrast specifies display with perfect black level, in practice OLED. (Only for ) Constrains the gamut of the display. You can use this option to output e.g. DCIP3-in-BT.2020. Set to the primaries of the containing colorspace (into which values will be encoded), and to the gamut you want to limit colors to. Takes the same values as . (Only for ) Specifies a custom LUT file (in Adobe .cube format) to apply to the colors before display on-screen. This LUT is fed values in normalized RGB, after encoding into the target colorspace, so after the application of . (Only for ) Specifies the algorithm used for tone-mapping images onto the target display. This is relevant for both HDR->SDR conversion as well as gamut reduction (e.g. playing back BT.2020 content on a standard gamut display). Valid values are: Choose the best curve according to internal heuristics. (Default) Hard-clip any out-of-range values. Use this when you care about perfect color accuracy for in-range values at the cost of completely distorting out-of-range values. Not generally recommended. Generalization of Reinhard to a Möbius transform with linear section. Smoothly maps out-of-range values while retaining contrast and colors for in-range material as much as possible. Use this when you care about color accuracy more than detail preservation. This is somewhere in between and , depending on the value of . Reinhard tone mapping algorithm. Very simple continuous curve. Preserves overall image brightness but uses nonlinear contrast, which results in flattening of details and degradation in color accuracy. Similar to but preserves both dark and bright details better (slightly sigmoidal), at the cost of slightly darkening / desaturating everything. Developed by John Hable for use in video games. Use this when you care about detail preservation more than color/brightness accuracy. This is roughly equivalent to . If possible, you should also enable for the best results. Linearly stretches the entire reference gamut to (a linear multiple of) the display. HDR<->SDR mapping specified in ITU-R Report BT.2446, method A. This is the recommended curve for well-mastered content. ( only) Dynamic HDR10+ tone-mapping method specified in SMPTE ST2094-40 Annex B. In the absence of metadata, falls back to a fixed spline matched to the input/output average brightness characteristics. ( only) Dynamic tone-mapping method specified in SMPTE ST2094-10 Annex B.2. Conceptually simpler than ST2094-40, and generally produces worse results. Set tone mapping parameters. By default, this is set to the special string , which maps to an algorithm-specific default value. Ignored if the tone mapping algorithm is not tunable. This affects the following tone mapping algorithms: Specifies an extra linear coefficient to multiply into the signal before clipping. Defaults to 1.0. Specifies the transition point from linear to mobius transform. Every value below this point is guaranteed to be mapped 1:1. The higher the value, the more accurate the result will be, at the cost of losing bright details. Defaults to 0.3, which due to the steep initial slope still preserves in-range colors fairly accurately. Specifies the local contrast coefficient at the display peak. Defaults to 0.5, which means that in-gamut values will be about half as bright as when clipping. Specifies the offset for the knee point. Defaults to 1.0, which is higher than the value from the original ITU-R specification (0.5). ( only) Specifies the exponent of the function. Defaults to 1.8. Specifies the scale factor to use while stretching. Defaults to 1.0. Specifies the knee point (in PQ space). Defaults to 0.30. Specifies the contrast (slope) at the knee point. Defaults to 1.0. If set, allows inverse tone mapping (expanding SDR to HDR). Not supported by all tone mapping curves. Use with caution. ( only) Upper limit for how much the tone mapping algorithm is allowed to boost the average brightness by over-exposing the image. The default value of 1.0 allows no additional brightness boost. A value of 2.0 would allow over-exposing by a factor of 2, and so on. Raising this setting can help reveal details that would otherwise be hidden in dark scenes, but raising it too high will make dark scenes appear unnaturally bright. ( only) Display a (PQ-PQ) graph of the active tone-mapping LUT. Intended only for debugging purposes. The X axis shows PQ input values, the Y axis shows PQ output values. The tone-mapping curve is shown in green/yellow. Yellow means the brightness has been boosted from the source, dark blue regions show where the brightness has been reduced. The extra colored regions and lines indicate various monitor limits, as well a reference diagonal (neutral tone-mapping) and source scene average brightness information (if available). ( only) Specifies the algorithm used for reducing the gamut of images for the target display, after any tone mapping is done. Hard-clip to the gamut (per-channel). Very low quality, but free. Performs a perceptually balanced gamut mapping using a soft knee function to roll-off clipped regions, and a hue shifting function to preserve saturation. ( only) Performs relative colorimetric clipping, while maintaining an exponential relationship between brightness and chromaticity. ( only) Performs simple RGB->RGB saturation mapping. The input R/G/B channels are mapped directly onto the output R/G/B channels. Will never clip, but will distort all hues and/or result in a faded look. ( only) Performs absolute colorimetric clipping. Like , but does not adapt the white point. ( only) Uniformly darkens the input slightly to prevent clipping on blown-out highlights, then clamps colorimetrically to the input gamut boundary, biased slightly to preserve chromaticity over luminance. ( only) Linearly/uniformly desaturates the image in order to bring the entire image into the target gamut. ( only) Compute the HDR peak and frame average brightness per-frame instead of relying on tagged metadata. These values are averaged over local regions as well as over several frames to prevent the value from jittering around too much. This option basically gives you dynamic, per-scene tone mapping. Requires compute shaders, which is a fairly recent OpenGL feature, and will probably also perform horribly on some drivers, so enable at your own risk. The special value (default) will enable HDR peak computation automatically if compute shaders and SSBOs are supported. When using , allow delaying the detected peak by a frame when beneficial for performance. In particular, this is required to avoid an unnecessary FBO indirection when no advanced rendering is required otherwise. Has no effect if there already is an indirect pass, such as when advanced scaling is enabled. Defaults to no. (Only affects , note that always delays the peak.) Which percentile of the input image brightness histogram to consider as the true peak of the scene. If this is set to 100 (default), the brightest pixel is measured. Otherwise, the top of the frequency distribution is progressively cut off. Setting this too low will cause clipping of very bright details, but can improve the dynamic brightness range of scenes with very bright isolated highlights. Values other than 100 come with a small performance penalty. (Only for ) The decay rate used for the HDR peak detection algorithm (default: 20.0). This is only relevant when is enabled. Higher values make the peak decay more slowly, leading to more stable values at the cost of more \"eye adaptation\"-like effects (although this is mitigated somewhat by ). A value of 0.0 (the lowest possible) disables all averaging, meaning each frame's value is used directly as measured, but doing this is not recommended for \"noisy\" sources since it may lead to excessive flicker. (In signal theory terms, this controls the time constant \"tau\" of an IIR low pass filter) The lower and upper thresholds (in dB) for a brightness difference to be considered a scene change (default: 1.0 low, 3.0 high). This is only relevant when is enabled. Normally, small fluctuations in the frame brightness are compensated for by the peak averaging mechanism, but for large jumps in the brightness this can result in the frame remaining too bright or too dark for up to several seconds, depending on the value of . To counteract this, when the brightness between the running average and the current frame exceeds the low threshold, mpv will make the averaging filter more aggressive, up to the limit of the high threshold (at which point the filter becomes instant). Enables the HDR contrast recovery algorithm, which is to designed to enhance contrast of HDR video after tone mapping. The strength (default: 0.0) indicates the degree of contrast recovery, with 0.0 being completely disabled and 1.0 being 100% strength. Values higher than 1.0 are allowed, but may result in excessive sharpening. The smoothness (default: 3.5) indicates the degree to which the HDR source is low-passed in order to obtain contrast information - a value of 2.0 corresponds to 2x downscaling. Users on low DPI displays (<= 100) may want to lower this value, while users on very high DPI displays (\"retina\") may want to increase it. (Only for ) Load the embedded ICC profile contained in media files such as PNG images. (Default: yes). Note that this option only works when also using a display ICC profile ( or ), and also requires LittleCMS 2 support. Load an ICC profile and use it to transform video RGB to screen output. Needs LittleCMS 2 support compiled in. This option overrides the , and options. Automatically select the ICC display profile currently specified by the display settings of the operating system. NOTE: On Windows, the default profile must be an ICC profile. WCS profiles are not supported. Applications using libmpv with the render API need to provide the ICC profile via . Store and load 3DLUTs created from the ICC profile on disk in the cache directory (Default: ). This can be used to speed up loading, since LittleCMS 2 can take a while to create a 3D LUT. Note that these files contain uncompressed LUTs. Their size depends on the , and can be very big. On , files that have not been accessed in the last 24 hours may be cleared if the cache limit (1.5 GiB) is exceeded. On , this is not cleaned automatically, so old, unused cache files may stick around indefinitely. The directory where icc cache is stored. Cache is stored in the system's cache directory (usually ) if this is unset. Specifies the ICC intent used for the color transformation (when using ). Size of the 3D LUT generated from the ICC profile in each dimension. The default of means to pick the size automatically based on the profile characteristics. Sizes may range from 2 to 512. NOTE: Setting this option to anything other than is strongly discouraged, except for testing. Override the target device's detected contrast ratio by a specific value. This is detected automatically from the profile if possible, but for some profiles it might be missing, causing the contrast to be assumed as infinite. As a result, video may appear darker than intended. If this is the case, setting this option might help. This only affects BT.1886 content. The default of means to use the profile values. The special value causes the BT.1886 curve to be treated as a pure power gamma 2.4 function. Use ICC profile luminance value. (Only for ) Specifies a custom LUT (in Adobe .cube format) to apply to the colors as part of color conversion. The exact interpretation depends on the value of . (Only for ) Controls the interpretation of color values fed to and from the LUT specified as . Valid values are: Chooses the interpretation of the LUT automatically from tagged metadata, and otherwise falls back to . (Default) Applied to raw image contents in its native RGB colorspace (non-linear light), before conversion to the output color space. Applied to the normalized RGB image contents, in linear light, before conversion to the output color space. Fully replaces the conversion from the image color space to the output color space. If such a LUT is present, it has the highest priority, and overrides any ICC profiles, as well as options related to tone mapping and output colorimetry ( , etc.). Blend subtitles directly onto upscaled video frames, before interpolation and/or color management (default: no). Enabling this causes subtitles to be affected by , , , , and . It also increases subtitle performance when using . The downside of enabling this is that it restricts subtitles to the visible portion of the video, so you can't have subtitles exist in the black margins below a video (for example). If is selected, the behavior is similar to , but subs are drawn at the video's native resolution, and scaled along with the video. This changes the way subtitle colors are handled. Normally, subtitle colors are assumed to be in sRGB and color managed as such. Enabling this makes them treated as being in the video's color space instead. This is good if you want things like softsubbed ASS signs to match the video colors, but may cause SRT subtitles or similar to look slightly off. If the frame has an alpha component, decide what kind of background, if any, to blend it with. This does nothing if there is no alpha component. Blend the frame against the background color ( , normally black). Do not blend the frame and leave the alpha as is. Before mpv 0.38.0, this option used to accept a color value specifying the background color. This is now done by the option. Use that instead. Color used to draw parts of the mpv window not covered by video. See the option for how colors are defined. Same as but only applies to the black bar/border area of the window. only. Defaults to . Force use of rectangle textures (default: no). Normally this shouldn't have any advantages over normal textures. Note that hardware decoding overrides this flag. Could be removed any time. Enlarge the video source textures by this many pixels. For debugging only (normally textures are sized exactly, but due to hardware decoding interop we may have to deal with additional padding, which can be tested with these options). Could be removed any time. Call after rendering a frame and before attempting to display it (default: auto). Can fix stuttering in some cases, in other cases probably causes it. The mode will call only if the renderer is going to wait for a while after rendering, instead of flipping GL front and backbuffers immediately (i.e. it doesn't call it in display-sync mode). On macOS this is always deactivated because it only causes performance problems and other regressions. This mode is extremely restricted, and will disable most extended features. That includes high quality scalers and custom shaders! It is intended for hardware that does not support FBOs (including GLES, which supports it insufficiently), or to get some more performance out of bad or old hardware. This mode is forced automatically if needed, and this option is mostly useful for debugging. The default of will enable it automatically if nothing uses features which require FBOs. This option might be silently removed in the future. Store and load compiled GLSL shaders in the cache directory (Default: ). Normally, shader compilation is very fast, so this is not usually needed. It mostly matters for anything involving GLSL to SPIR-V conversion, that is: D3D11, ANGLE or Vulkan, as well as on some other proprietary drivers. Enabling this can improve startup performance on these platforms. On , files that have not been accessed in the last 24 hours may be cleared if the cache limit (128 MiB) is exceeded. On , this is not cleaned automatically, so old, unused cache files may stick around indefinitely. The directory where gpu shader cache is stored. Cache is stored in the system's cache directory (usually ) if this is unset. Passes extra raw option to the libplacebo rendering backend (used by ). May override the effects of any other options set using the normal options system. Requires libplacebo v6.309 or higher. Included for debugging purposes only. For more information, see: Set the list of tags that should be displayed on the terminal and stats. Tags that are in the list, but are not present in the played file, will not be shown. If a value ends with , all tags are matched by prefix (though there is no general globbing). Just passing essentially filtering. The default includes a common list of tags, call mpv with to see it. This is a string list option. See List Options for details. Gradually adjusts the A/V sync based on audio delay measurements. Specifying , the default, will cause frame timing to be based entirely on audio delay measurements. Specifying will do the same, but will subtly change the A/V correction algorithm. An uneven video framerate in a video which plays fine with can often be helped by setting this to an integer value greater than 1. The higher the value, the closer the timing will be to . Try to smooth out problems with sound drivers which do not implement a perfect audio delay measurement. With this value, if large A/V sync offsets occur, they will only take about 1 or 2 seconds to settle out. This delay in reaction time to sudden A/V offsets should be the only side effect of turning this option on, for all sound drivers. Control how long before video display target time the frame should be rendered (default: 0.050). If a video frame should be displayed at a certain time, the VO will start rendering the frame earlier, and then will perform a blocking wait until the display time, and only then \"swap\" the frame to display. The rendering cannot start before the previous frame is displayed, so this value is implicitly limited by the video framerate. With normal video frame rates, the default value will ensure that rendering is always immediately started after the previous frame was displayed. On the other hand, setting a too high value can reduce responsiveness with low FPS value. This option is interesting for client API users using the render API because you can stop it from limiting your FPS (see documentation). This applies only to audio timing modes (e.g. ). In other modes ( ), video timing relies on vsync blocking, and this option is not used. How the player synchronizes audio and video. If you use this option, you usually want to set it to to enable a timing mode that tries to not skip or repeat frames when for example playing 24fps video on a 24Hz screen. The modes starting with try to output video frames completely synchronously to the display, using the detected display vertical refresh rate as a hint how fast frames will be displayed on average. These modes change video speed slightly to match the display. See options for fine tuning. The robustness of this mode is further reduced by making a some idealized assumptions, which may not always apply in reality. Behavior can depend on the VO and the system's video and audio drivers. Media files must use constant framerate. Section-wise VFR might work as well with some container formats (but not e.g. mkv). Under some circumstances, the player automatically reverts to mode for some time or permanently. This can happen on very low framerate video, or if the framerate cannot be detected. Also in display-sync modes it can happen that interruptions to video playback (such as toggling fullscreen mode, or simply resizing the window) will skip the video frames that should have been displayed, while mode will display them after the renderer has resumed (typically resulting in a short A/V desync and the video \"catching up\"). Before mpv 0.30.0, there was a fallback to mode on severe A/V desync. This was changed for the sake of not sporadically stopping. Now, does what it promises and may desync with audio by an arbitrary amount, until it is manually fixed with a seek. These modes also require a vsync blocked presentation mode. For OpenGL, this translates to . For Vulkan, it translates to (or ). The modes with in their names do not attempt to keep audio/video in sync. They will slowly (or quickly) desync, until e.g. the next seek happens. These modes are meant for testing, not serious use. Time video frames to audio. This is the most robust mode, because the player doesn't have to assume anything about how the display behaves. The disadvantage is that it can lead to occasional frame drops or repeats. If audio is disabled, this uses the system clock. This is the default mode. Resample audio to match the video. This mode will also try to adjust audio speed to compensate for other drift. (This means it will play the audio at a different speed every once in a while to reduce the A/V difference.) Resample audio to match the video. Drop video frames to compensate for drift. Like the previous mode, but no A/V compensation. Same as , but apply audio speed changes to audio filters instead of resampling to avoid the change in pitch. Beware that some audio filters don't do well with a speed close to 1. It is recommend to use a conditional profile to automatically switch to when speed gets too close to 1 for your filter setup. Use (speed * video_speed_correction) to get the actual playback speed in the condition. See Conditional auto profiles for details. Drop or repeat video frames to compensate desyncing video. (Although it should have the same effects as , the implementation is very different.) Drop or repeat audio data to compensate desyncing video. This mode will cause severe audio artifacts if the real monitor refresh rate is too different from the reported or forced rate. Since mpv 0.33.0, this acts on entire audio frames, instead of single samples. Sync video to display, and let audio play on its own. Sync video according to system clock, and let audio play on its own. Maximum multiple for which to try to fit the video's FPS to the display's FPS (default: 5). For example, if this is set to 1, the video FPS is forced to an integer multiple of the display FPS, as long as the speed change does not exceed the value set by . See for how this option affects interpolation. Maximum speed difference in percent that is applied to video with (default: 1). Display sync mode will be disabled if the monitor and video refresh way do not match within the given range. It tries multiples as well: playing 30 fps video on a 60 Hz screen will duplicate every second frame. Playing 24 fps video on a 60 Hz screen will play video in a 2-3-2-3-... pattern. The default settings are not loose enough to speed up 23.976 fps video to 25 fps. We consider the pitch change too extreme to allow this behavior by default. Set this option to a value of to enable it. Also note that in the or mode, audio speed will additionally be changed by a small amount if necessary for A/V sync. See . Maximum additional speed difference in percent that is applied to audio with (default: 0.125). Normally, the player plays the audio at the speed of the video. But if the difference between audio and video position is too high, e.g. due to drift or other timing errors, it will attempt to speed up or slow down audio by this additional factor. Too low values could lead to video frame dropping or repeating if the A/V desync cannot be compensated, too high values could lead to chaotic frame dropping due to the audio \"overshooting\" and skipping multiple video frames before the sync logic can react. Framerate used when decoding from multiple PNG or JPEG files with (default: 1). Input file type for (available: jpeg, png, tga, sgi). By default, this is guessed from the file extension. Instead of playing a file, read its byte stream and write it to the given destination file. The destination is overwritten. Can be useful to test network-related behavior. Set AVOptions on streams opened with libavformat. Unknown or misspelled options are silently ignored. (They are mentioned in the terminal output in verbose mode, i.e. . In general we can't print errors, because other options such as e.g. user agent are not available with all protocols, and printing errors for unknown options would end up being too noisy.) This is a key/value list option. See List Options for details. The backdrop will be black or white depending on the system's theme settings. Enables the Mica style, which is the default on Windows 11. Same as Mica, except reversed. (Windows only) Controls the window affinity behavior of mpv. mpv's window will be completely excluded from capture by external applications or screen recording software. (Windows only) Set the MMCSS profile for the video renderer thread (default: ). (Windows only) Set process priority for mpv according to the predefined priorities available under Windows. Using realtime priority can cause system lockup. Force the contents of the property to this value. Useful for scripts which want to set a title, without overriding the user's setting in . Load a file and add all of its tracks. This is useful to play different files together (for example audio from one file, video from another), or for advanced used (like playing two video files at the same time). Unlike and , this includes all tracks, and does not cause default stream selection over the \"proper\" file. This makes it slightly less intrusive. (In mpv 0.28.0 and before, this was not quite strictly enforced.) This is a path list option. See List Options for details. CLI/config file only alias for . Each use of this option will add a new external file. Use an external file as cover art while playing audio. This makes it appear on the track list and subject to automatic track selection. Options like control whether such tracks are supposed to be selected. This is a path list option. See List Options for details. CLI/config file only alias for . Each use of this option will add a new external file. Whether to load _external_ cover art automatically. Similar to and . If a video already has tracks (which are not marked as cover art), external cover art will not be loaded. Load the media filename with an image file extension (default). Load all cover art containing the media filename. Load all images in the current directory. See for details about what constitutes cover art. See how to control display of cover art (this can be used to disable cover art that is part of the file). Image file extentions to try to match when using , or . This is a string list option. See List Options for details. Use to see default extensions. Filenames to load as cover art, sorted by descending priority. They are combined with the extensions in . This has no effect if is . This is a string list option. See List Options for details. Video file extentions to try to match when using or . This is a string list option. See List Options for details. Use to see default extensions. If set to , then do not automatically load external files as specified by , and . If external files are forcibly added (like with ), they will not be auto-selected. This does not affect playlist expansion, redirection, or other loading of referenced files like with ordered chapters. Write received/read data from the demuxer to the given output file. The output file will always be overwritten without asking. The output format is determined by the extension of the output file. Switching streams or seeking during recording might result in recording being stopped and/or broken files. Use with care. Seeking outside of the demuxer cache will result in \"skips\" in the output file, but seeking within the demuxer cache should not affect recording. One exception is when you seek back far enough to exceed the forward buffering size, in which case the cache stops actively reading. This will return in dropped data if it's a live stream. If this is set at runtime, the old file is closed, and the new file is opened. Note that this will write only data that is appended at the end of the cache, and the already cached data cannot be written. You can try the command as an alternative. External files ( etc.) are ignored by this, it works on the \"main\" file only. Using this with files using ordered chapters or EDL files will also not work correctly in general. There are some glitches with this because it uses FFmpeg's libavformat for writing the output file. For example, it's typical that it will only work if the output format is the same as the input format. This is the case even if it works with the tool. One reason for this is that and its libraries contain certain hacks and workarounds for these issues, that are unavailable to outside users. Set a \"complex\" libavfilter filter, which means a single filter graph can take input from multiple source audio and video tracks. The graph can result in a single audio or video output (or both). Currently, the filter graph labels are used to select the participating input tracks and audio/video output. The following rules apply:\n• A label of the form selects audio track N as input (e.g. ).\n• A label of the form selects video track N as input.\n• A label named will be connected to the audio output.\n• A label named will be connected to the video output. Each label can be used only once. If you want to use e.g. an audio stream for multiple filters, you need to use the filter. Multiple video or audio outputs are not possible, but you can use filters to merge them into one. It's not possible to change the tracks connected to the filter at runtime, unless you explicitly change the property and set new track assignments. When the graph is changed, the track selection is changed according to the used labels as well. Other tracks, as long as they're not connected to the filter, and the corresponding output is not connected to the filter, can still be freely changed with the normal methods. Note that the normal filter chains ( , ) are applied between the complex graphs (e.g. label) and the actual output.\n• Play audio track 1 and 2 at the same time.\n• Stack video track 1 and 2 and play them at the same time. Note that both tracks need to have the same width, or filter initialization will fail (you can add filters before the filter to fix the size). To load a video track from another file, you can use .\n• Use the inputs option to stack more than 2 tracks.\n• Play audio track 1, and overlay the measured volume for each speaker over video track 1. See the FFmpeg libavfilter documentation for details on the available filters. Codepage for various input metadata (default: ). This affects how file tags, chapter titles, etc. are interpreted. In most cases, this merely evaluates to UTF-8 as non-UTF-8 codepages are obscure. See option on how codepages are specified and further details regarding autodetection and codepage conversion. (The underlying code is the same.) Conversion is not applied to metadata that is updated at runtime.\n\nThe mpv core can be controlled with commands and properties. A number of ways to interact with the player use them: key bindings ( ), OSD (showing information with properties), JSON IPC, the client API ( ), and the classic slave mode. The input.conf file consists of a list of key bindings, for example: s screenshot # take a screenshot with the s key LEFT seek 15 # map the left-arrow key to seeking forward by 15 seconds Each line maps a key to an input command. Keys are specified with their literal value (upper case if combined with ), or a name for special keys. For example, maps to the key without shift, and maps to with shift. The file is located in the mpv configuration directory (normally at depending on platform). The default bindings are defined here: A list of special keys can be obtained with In general, keys can be combined with , and : mpv can be started in input test mode, which displays key bindings and the commands they're bound to on the OSD, instead of executing the commands: Note that by default, the right Alt key can be used to create special characters, and thus does not register as a modifier. This can be changed with option. Newlines always start a new binding. starts a comment (outside of quoted string arguments). To bind commands to the key, can be used. is either the literal character the key produces (ASCII or Unicode character), or a symbolic name (as printed by ). (braced with and ) is the input section for this command. is the command itself. It consists of the command name and multiple (or none) arguments, all separated by whitespace. String arguments should be quoted, typically with . See . You can bind multiple commands to one key. For example: It's also possible to bind a command to a sequence of keys: a-b-c show-text \"command run after a, b, c have been pressed\" If or or are already bound, this will run the first command that matches, and the multi-key command will never be called. Intermediate keys can be remapped to in order to avoid this issue. The maximum number of (non-modifier) keys for combinations is currently 4. All mouse and keyboard input is to converted to mpv-specific key names. Key names are either special symbolic identifiers representing a physical key, or a text key names, which are unicode code points encoded as UTF-8. These are what keyboard input would normally produce, for example for the A key. As a consequence, mpv uses input translated by the current OS keyboard layout, rather than physical scan codes. Currently there is the hardcoded assumption that every text key can be represented as a single unicode code point (in NFKC form). All key names can be combined with the modifiers , , , . They must be prefixed to the actual key name, where each modifier is followed by a (for example ). The modifier requires some attention. For instance should usually be specified as key-name at , and similarly the combination is usually , etc. Special key names like work as expected. If in doubt - use to check how a key/combination is seen by mpv. Symbolic key names and modifier names are case-insensitive. Unicode key names are case-sensitive because input bindings typically respect the shift key. Another type of key names are hexadecimal key names, that serve as fallback for special keys that are neither unicode, nor have a special mpv defined name. They will break as soon as mpv adds proper names for them, but can enable you to use a key at all if that does not happen. All symbolic names are listed by . is a special mode that prints all input on the OSD. Keypad names. Behavior varies by backend (whether they implement this, and on how they treat numlock), but typically, mpv tries to map keys on the keypad to separate names, even if they produce the same text as normal keys. Depending on backend, the mouse wheel might also be represented as a button. In addition, to are deprecated aliases for , , , . Emitted by mouse move events. Enter/leave happens when the mouse enters or leave the mpv window (or the current mouse region, using the deprecated mouse region input section mechanism). Pseudo key emitted when closing the mpv window using the OS window manager (for example, by clicking the close button in the window title bar). Pseudo-key that matches any unmapped key. (You should probably avoid this if possible, because it might change behavior or get removed in the future.) Pseudo-key that matches any key that produces text. (You should probably avoid this if possible, because it might change behavior or get removed in the future.) This is the syntax used in input.conf, and referred to \"input.conf syntax\" in a number of other places. is an unquoted string with the command name itself. See List of Input Commands for a list. Arguments are separated by whitespaces even if the command expects only one argument. Arguments with whitespaces or other special characters must be quoted, or the command cannot be parsed correctly. Double quotes interpret JSON/C-style escaping, like or or . JSON escapes according to RFC 8259, minus surrogate pair escapes. This is the only form which allows newlines at the value - as . Single quotes take the content literally, and cannot include the single-quote character at the value. Custom quotes also take the content literally, but are more flexible than single quotes. They start with (back-quote) followed by any ASCII character, and end at the first occurrence of the same pair in reverse order, e.g. or . The final pair sequence is not allowed at the value - in these examples and respectively. In the second example the last character of the value also can't be a back-quote. Mixed quoting at the same argument, like , is not supported. Note that argument parsing and property expansion happen at different stages. First, arguments are determined as described above, and then, where applicable, properties are expanded - regardless of argument quoting. However, expansion can still be prevented with the prefix or . See Input Command Prefixes and Property Expansion. This applies to certain APIs, such as or (with array parameters) in Lua scripting, or or (with MPV_FORMAT_NODE_ARRAY) in the C libmpv client API. The command as well as all arguments are passed as a single array. Similar to the Flat command syntax, you can first pass prefixes as strings (each as separate array item), then the command name as string, and then each argument as string or a native value. Since these APIs pass arguments as separate strings or native values, they do not expect quotes, and do support escaping. Technically, there is the input.conf parser, which first splits the command string into arguments, and then invokes argument parsers for each argument. The input.conf parser normally handles quotes and escaping. The array command APIs mentioned above pass strings directly to the argument parsers, or can sidestep them by the ability to pass non-string values. Property expansion is disabled by default for these APIs. This can be changed with the prefix. See Input Command Prefixes. Sometimes commands have string arguments, that in turn are actually parsed by other components (e.g. filter strings with ) - in these cases, you you would have to double-escape in input.conf, but not with the array APIs. For complex commands, consider using Named arguments instead, which should give slightly more compatibility. Some commands do not support named arguments and inherently take an array, though. This applies to certain APIs, such as (with tables that have string keys) in Lua scripting, or (with MPV_FORMAT_NODE_MAP) in the C libmpv client API. The name of the command is provided with a string field. The name of each command is defined in each command description in the List of Input Commands. also lists them. See the command for an example. Some commands do not support named arguments (e.g. command). You need to use APIs that pass arguments as arrays. Named arguments are not supported in the \"flat\" input.conf syntax, which means you cannot use them for key bindings in input.conf at all. Property expansion is disabled by default for these APIs. This can be changed with the prefix. See Input Command Prefixes. Commands with parameters have the parameter name enclosed in / . Don't add those to the actual command. Optional arguments are enclosed in / . If you don't pass them, they will be set to a default value. Remember to quote string arguments in input.conf (see Flat command syntax). Use this to \"block\" keys that should be unbound, and do nothing. Useful for disabling default bindings, without disabling all bindings with . Change the playback position. By default, seeks by a relative amount of seconds. The second argument consists of flags controlling the seek mode: Seek to a given time (a negative value starts from the end of the file). By default, is used for , , and seeks, while is used for seeks. Before mpv 0.9, the and flags had to be passed as 3rd parameter (essentially using a space instead of ). The 3rd parameter is still parsed, but is considered deprecated. Undoes the command, and some other commands that seek (but not necessarily all of them). Calling this command once will jump to the playback position before the seek. Calling it a second time undoes the command itself. This only works within a single file. The first argument is optional, and can change the behavior: Mark the current time position. The next normal command will seek back to this point, no matter how many seeks happened since last time. If set, mark the current position, and do not change the mark position before the next command that has or set (or playback of the current file ends). Until this happens, will always seek to the marked point. This flag cannot be combined with . Using it without any arguments gives you the default behavior. Play one frame, then pause. Does nothing with audio-only playback. Go back by one frame, then pause. Note that this can be very slow (it tries to be precise, not fast), and sometimes fails to behave as expected. How well this works depends on whether precise seeking works correctly (e.g. see the option). Video filters or other video post-processing that modifies timing of frames (e.g. deinterlacing) should usually work, but might make backstepping silently behave incorrectly in corner cases. Using should help, although it might make precise seeking slower. This does not work with audio-only playback. Set the given property or option to the given value. Delete the given property. Most properties cannot be deleted. Add the given value to the property or option. On overflow or underflow, clamp the property to the maximum. If is omitted, assume . Cycle the given property or option. The second argument can be or to set the cycle direction. On overflow, set the property back to the minimum, on underflow set it to the maximum. If or is omitted, assume . Whether or not key-repeat is enabled by default depends on the property. Currently properties with continuous values are repeatable by default (like ), while discrete values are not (like ). Similar to , but multiplies the property or option with the numeric value. Multiple flags are available (some can be combined with ): Save the video image, in its original resolution, and with subtitles. Some video outputs may still include the OSD in the output under certain circumstances. Like , but typically without OSD or subtitles. The exact behavior depends on the selected video output. Save the contents of the mpv window. Typically scaled, with OSD and subtitles. The exact behavior depends on the selected video output. Take a screenshot each frame. Issue this command again to stop taking screenshots. Note that you should disable frame-dropping when using this mode - or you might receive duplicate images in cases when a frame was dropped. This flag can be combined with the other flags, e.g. . Older mpv versions required passing and as second argument (and did not have flags). This syntax is still understood, but deprecated and might be removed in the future. If you combine this command with another one using , you can use the flag to make encoding/writing the image file asynchronous. For normal standalone commands, this is always asynchronous, and the flag has no effect. (This behavior changed with mpv 0.29.0.) On success, returns a with a field set to the saved screenshot location. Take a screenshot and save it to a given file. The format of the file will be guessed by the extension (and is ignored - the behavior when the extension is missing or unknown is arbitrary). The second argument is like the first argument to and supports , , . If the file already exists, it's overwritten. Like all input command parameters, the filename is subject to property expansion as described in Property Expansion. Go to the next entry on the playlist. If the last file on the playlist is currently played, do nothing. Terminate playback if there are no more files on the playlist. Go to the previous entry on the playlist. If the first file on the playlist is currently played, do nothing. Terminate playback if the first file is being played. Go to the next entry on the playlist with a different . Go to the first of the previous entries on the playlist with a different . Start (or restart) playback of the given playlist index. In addition to the 0-based playlist entry index, it supports the following values: The current playlist entry (as in ) will be played again (unload and reload). If none is set, playback is stopped. (In corner cases, can point to a playlist entry even if playback is currently inactive, Playback is stopped. If idle mode ( ) is enabled, the player will enter idle mode, otherwise it will exit. This command is similar to in that it only manipulates the state of what to play next, without waiting until the current file is unloaded, and the next one is loaded. Setting or similar properties can have a similar effect to this command. However, it's more explicit, and guarantees that playback is restarted if for example the new playlist entry is the same as the previous one. Load the given file or URL and play it. Technically, this is just a playlist manipulation command (which either replaces the playlist or adds an entry to it). Actual file loading happens independently. For example, a command that replaces the current file with a new one returns before the current file is stopped, and the new file even begins loading. Stop playback of the current file, and play the new file immediately. Append the file to the playlist. Append the file, and if nothing is currently playing, start playback. (Always starts with the added file, even if the playlist was not empty before running this command.) Insert the file into the playlist, directly after the current entry. Insert the file next, and if nothing is currently playing, start playback. (Always starts with the added file, even if the playlist was not empty before running this command.) Insert the file into the playlist, at the index given in the third argument. Insert the file at the index given in the third argument, and if nothing is currently playing, start playback. (Always starts with the added file, even if the playlist was not empty before running this command.) The third argument is an insertion index, used only by the and actions. When used with those actions, the new item will be inserted at the index position in the playlist, or appended to the end if index is less than 0 or greater than the size of the playlist. This argument will be ignored for all other actions. This argument is added in mpv 0.38.0. The fourth argument is a list of options and values which should be set while the file is playing. It is of the form . When using the client API, this can be a (or a Lua table), however the values themselves must be strings currently. These options are set during playback, and restored to the previous value at end of playback (see Per-File Options). Since mpv 0.38.0, an insertion index argument is added as the third argument. This breaks all existing uses of this command which make use of the argument to include the list of options to be set while the file is playing. To address this problem, the third argument now needs to be set to -1 if the fourth argument needs to be used. Load the given playlist file or URL (like ). Stop playback and replace the internal playlist with the new one. Append the new playlist at the end of the current internal playlist. Append the new playlist, and if nothing is currently playing, start playback. (Always starts with the new playlist, even if the internal playlist was not empty before running this command.) Insert the new playlist into the current internal playlist, directly after the current entry. Insert the new playlist, and if nothing is currently playing, start playback. (Always starts with the new playlist, even if the internal playlist was not empty before running this command.) Insert the new playlist at the index given in the third argument. Insert the new playlist at the index given in the third argument, and if nothing is currently playing, start playback. (Always starts with the new playlist, even if the internal playlist was not empty before running this command.) The third argument is an insertion index, used only by the and actions. When used with those actions, the new playlist will be inserted at the index position in the internal playlist, or appended to the end if index is less than 0 or greater than the size of the internal playlist. This argument will be ignored for all other actions. Clear the playlist, except the currently played file. Remove the playlist entry at the given index. Index values start counting with 0. The special value removes the current entry. Note that removing the current entry also stops playback and starts playing the next entry. Move the playlist entry at index1, so that it takes the place of the entry index2. (Paradoxically, the moved playlist entry will not have the index value index2 after moving if index1 was lower than index2, because index2 refers to the target entry, not the index the entry will have after moving.) Shuffle the playlist. This is similar to what is done on start if the option is used. Attempt to revert the previous command. This works only once (multiple successive commands do nothing). May not work correctly if new recursive playlists have been opened since a command. Run the given command. Unlike in MPlayer/mplayer2 and earlier versions of mpv (0.2.x and older), this doesn't call the shell. Instead, the command is run directly, with each argument passed separately. Each argument is expanded like in Property Expansion. This command has a variable number of arguments, and cannot be used with named arguments. The program is run in a detached way. mpv doesn't wait until the command is completed, but continues playback right after spawning it. To get the old behavior, use and as the first two arguments. This is not a particularly good example, because it doesn't handle escaping, and a specially prepared file might allow an attacker to execute arbitrary shell commands. It is recommended to write a small shell script, and call that with . Similar to , but gives more control about process execution to the caller, and does not detach the process. You can avoid blocking until the process terminates by running this command asynchronously. (For example in Lua scripting.) This has the following named arguments. The order of them is not guaranteed, so you should always call them with named arguments, see Named arguments. Array of strings with the command as first argument, and subsequent command line arguments following. This is just like the command argument list. The first array entry is either an absolute path to the executable, or a filename with no path components, in which case the executable is searched in the directories in the environment variable. On Unix, this is equivalent to and behavior. Boolean indicating whether the process should be killed when playback of the current playlist entry terminates (optional, default: true). If enabled, stopping playback will automatically kill the process, and you can't start it outside of playback. Integer setting the maximum number of stdout plus stderr bytes that can be captured (optional, default: 64MB). If the number of bytes exceeds this, capturing is stopped. The limit is per captured stream. Capture all data the process outputs to stdout and return it once the process ends (optional, default: no). Same as , but for stderr. Whether to run the process in detached mode (optional, default: no). In this mode, the process is run in a new process session, and the command does not wait for the process to terminate. If neither nor have been set to true, the command returns immediately after the new process has been started, otherwise the command will read as long as the pipes are open. Set a list of environment variables for the new process (default: empty). If an empty list is passed, the environment of the mpv process is used instead. (Unlike the underlying OS mechanisms, the mpv command cannot start a process with empty environment. Fortunately, that is completely useless.) The format of the list is as in the syscall. Each string item defines an environment variable as in . On Lua, you may use to retrieve the current environment if you e.g. simply want to add a new variable. Feed the given string to the new process' stdin. Since this is a string, you cannot pass arbitrary binary data. If the process terminates or closes the pipe before all data is written, the remaining data is silently discarded. Probably does not work on win32. If enabled, wire the new process' stdin to mpv's stdin (default: no). Before mpv 0.33.0, this argument did not exist, but the behavior was as if this was set to true. The command returns the following result (as ): Typically this is the process exit code (0 or positive) if the process terminates normally, or negative for other errors (failed to start, terminated by mpv, and others). The meaning of negative values is undefined, other than meaning error (and does not correspond to OS low level exit status values). On Windows, it can happen that a negative return value is returned even if the process terminates normally, because the win32 exit code is assigned to an variable before being set as field in the result map. This might be fixed later. Same as , but for stderr. Empty string if the process terminated normally. The string if the process was terminated in an unusual way. The string if the process could not be started. On Windows, is only returned when the process has been killed by mpv as a result of being set to true. Whether the process has been killed by mpv, for example as a result of being set to true, aborting the command (e.g. by ), or if the player is about to exit. Note that the command itself will always return success as long as the parameters are correct. Whether the process could be spawned or whether it was somehow killed or returned an error status has to be queried from the result value. This command can be asynchronously aborted via API. Also see Asynchronous command details. Only the command can start processes in a truly detached way. The subprocess will always be terminated on player exit if it wasn't started in detached mode, even if is false. Don't forget to set the field to false if you want the command to run while the player is in idle mode, or if you don't want the end of playback to kill the command. local r = mp.command_native({ name = \"subprocess\", playback_only = false, capture_stdout = true, args = {\"cat\", \"/proc/cpuinfo\"}, }) if r.status == 0 then print(\"result: \" .. r.stdout) end This is a fairly useless Lua example, which demonstrates how to run a process in a blocking manner, and retrieving its stdout output. Exit the player. If an argument is given, it's used as process exit code. Exit player, and store current playback position. Playing that file later will seek to the previous position on start. The (optional) argument is exactly as in the command. See RESUMING PLAYBACK. Load the given subtitle file or stream. By default, it is selected as current subtitle after loading. The argument is one of the following values: Don't select the subtitle. (Or in some special situations, let the default stream selection mechanism decide.) Select the subtitle. If a subtitle with the same filename was already added, that one is selected, instead of loading a duplicate entry. (In this case, title/language are ignored, and if the was changed since it was loaded, these changes won't be reflected.) The argument sets the track title in the UI. The argument sets the track language, and can also influence stream selection with set to . Remove the given subtitle track. If the argument is missing, remove the current track. (Works on external subtitle files only.) Reload the given subtitle tracks. If the argument is missing, reload the current track. (Works on external subtitle files only.) This works by unloading and re-adding the subtitle track. Change subtitle timing such, that the subtitle event after the next subtitle events is displayed. can be negative to step backwards. Change video and audio position such that the subtitle event after subtitle events is displayed. For example, skips to the next subtitle, skips to the previous subtitles, and seeks to the beginning of the current subtitle. This is similar to , except that it seeks video and audio instead of adjusting the subtitle delay. For embedded subtitles (like with Matroska), this works only with subtitle events that have already been displayed, or are within a short prefetch range. See Cache for details on how to control the available prefetch range. Print text to stdout. The string can contain properties (see Property Expansion). Take care to put the argument in quotes. Show text on the OSD. The string can contain properties, which are expanded as described in Property Expansion. This can be used to show playback time, filename, and so on. has no effect on this command. The time in ms to show the message for. By default, it uses the same value as . The minimum OSD level to show the text at (see ). Property-expand the argument and return the expanded string. This can be used only through the client API or from a script using . (see Property Expansion). Expand a path's double-tilde placeholders into a platform-specific path. As , this can only be used through the client API or from a script using . This line of Lua would show the location of the user's mpv configuration directory on the OSD. Return a canonical representation of the path by converting it to an absolute path, removing consecutive slashes, removing components, resolving components, and converting slashes to backslashes on Windows. Symlinks are not resolved unless the platform is Unix-like and one of the path components is . If is a URL, it is returned unchanged. This can only be used through the client API or from a script using . This line of Lua prints \"/foo/bar\" on the OSD. Modify so that commands and functions that interpret ASS tags, such as and , will display it verbatim, and return it. This can only be used through the client API or from a script using . This line of Lua prints \"foo \\{bar}\" on the OSD. Show the progress bar, the elapsed time and the total duration of the file on the OSD. has no effect on this command. Write the resume config file that the command writes, but continue playback normally. Delete any existing resume config file that was written by or . If a filename is specified, then the deleted config is for that file; otherwise, it is the same one as would be written by or in the current circumstance. Stop playback and clear playlist. With default settings, this is essentially like . Useful for the client API: playback can be stopped without terminating the player. The first argument is optional, and supports the following flags: Do not clear the playlist. The button number of clicked mouse button. This should be one of 0-19. If is omitted, only the position will be updated. Send a key event through mpv's input handler, triggering whatever behavior is configured to that key. uses the naming scheme for keys and modifiers. is used to scale numerical change effected by the bound command (same mechanism as precise scrolling). Useful for the client API: key events can be sent to libmpv to handle internally. Similar to , but sets the flag so that if the key is bound to a repeatable command, it will be run repeatedly with mpv's key repeat timing until the command is called. Set the flag, stopping any repeated behavior that had been triggered. is optional. If is not given or is an empty string, will be set on all keys. Otherwise, will only be set on the key specified by . Binds a key to an input command. must be a complete command containing all the desired arguments and flags. Both and use the naming scheme. This is primarily useful for the client API. Load the given audio file. See command. Remove the given audio track. See command. Reload the given audio tracks. See command. Load the given video file. See command for common options. If enabled, mpv will load the given video as album art. Remove the given video track. See command. Reload the given video tracks. See command. Rescan external files according to the current , and settings. This can be used to auto-load external files after the file was loaded. The argument is one of the following: Select the default audio and subtitle streams, which typically selects external files with the highest preference. (The implementation is not perfect, and could be improved on request.) Show context menu on the video window. See Context Menu section for details. Input Commands that are Possibly Subject to Change The semantics are exactly the same as with option parsing (see VIDEO FILTERS). As such the text below is a redundant and incomplete summary. The first argument decides what happens: Overwrite the previous filter chain with the new one. Append the new filter chain to the previous one. Check if the given filter (with the exact parameters) is already in the video chain. If it is, remove the filter. If it isn't, add the filter. (If several filters are passed to the command, this is done for each filter.) A special variant is combining this with labels, and using without filter name and parameters as filter entry. This toggles the enable/disable flag. Like , but always remove the given filter from the chain. Remove all filters. Note that like the other sub-commands, this does not control automatically inserted filters. The argument is always needed. E.g. in case of use . You can assign labels to filter by prefixing them with (where is a user-chosen arbitrary identifier). Labels can be used to refer to filters by name in all of the filter chain modification commands. For , using an already used label will replace the existing filter. The command shows the list of requested filters on the OSD after changing the filter chain. This is roughly equivalent to . Note that auto-inserted filters for format conversion are not shown on the list, only what was requested by the user. Normally, the commands will check whether the video chain is recreated successfully, and will undo the operation on failure. If the command is run before video is configured (can happen if the command is run immediately after opening a file and before a video frame is decoded), this check can't be run. Then it can happen that creating the video chain fails.\n• turn the video upside-down on the key Example how to toggle disabled filters at runtime\n• Add something like to . The is the label, an arbitrary, user-given name for this filter entry. The before the filter name disables the filter by default. Everything after this is the normal filter name and possibly filter parameters, like in the normal syntax.\n• Add to . This toggles the \"disabled\" flag for the filter with the label when the key is hit. Cycle through a list of values. Each invocation of the command will set the given property to the next value in the list. The command will use the current value of the property/option, and use it to determine the current position in the list of values. Once it has found it, it will set the next value in the list (wrapping around to the first item if needed). This command has a variable number of arguments, and cannot be used with named arguments. The special argument can be used to cycle the value list in reverse. The only advantage is that you don't need to reverse the value list yourself when adding a second key binding for cycling backwards. This command is deprecated, except for mpv-internal uses. Enable all key bindings in the named input section. The enabled input sections form a stack. Bindings in sections on the top of the stack are preferred to lower sections. This command puts the section on top of the stack. If the section was already on the stack, it is implicitly removed beforehand. (A section cannot be on the stack more than once.) The parameter can be a combination (separated by ) of the following flags: All sections enabled before the newly enabled section are disabled. They will be re-enabled as soon as all exclusive sections above them are removed. In other words, the new section shadows all previous sections. This feature can't be used through the public API. This command is deprecated, except for mpv-internal uses. This command is deprecated, except for mpv-internal uses. Create a named input section, or replace the contents of an already existing input section. The parameter uses the same syntax as the file (except that using the section syntax in it is not allowed), including the need to separate bindings with a newline character. If the parameter is an empty string, the section is removed. The section with the name is the normal input section. In general, input sections have to be enabled with the command, or they are ignored. The last parameter has the following meaning: <default> (also used if parameter omitted) Use a key binding defined by this section only if the user hasn't already bound this key to a command. Always bind a key. (The input section that was made active most recently wins if there are ambiguities.) This command can be used to dispatch arbitrary keys to a script or a client API user. If the input section defines commands, it is also possible to get separate events on key up/down, and relatively detailed information about the key state. The special key name can be used to match any unmapped key. Add an OSD overlay sourced from raw data. This might be useful for scripts and applications controlling mpv, and which want to display things on top of the video window. Overlays are usually displayed in screen resolution, but with some VOs, the resolution is reduced to that of the video's. You can read the and properties. At least with and anamorphic video (such as DVD), should be read as well, and the overlay should be aspect-compensated. This has the following named arguments. The order of them is not guaranteed, so you should always call them with named arguments, see Named arguments. is an integer between 0 and 63 identifying the overlay element. The ID can be used to add multiple overlay parts, update a part by using this command with an already existing ID, or to remove a part with . Using a previously unused ID will add a new overlay, while reusing an ID will update it. and specify the position where the OSD should be displayed. specifies the file the raw image data is read from. It can be either a numeric UNIX file descriptor prefixed with (e.g. ), or a filename. The file will be mapped into memory with , copied, and unmapped before the command returns (changed in mpv 0.18.1). It is also possible to pass a raw memory address for use as bitmap memory by passing a memory address as integer prefixed with an character. Passing the wrong thing here will crash the player. This mode might be useful for use with libmpv. The parameter is simply added to the memory address (since mpv 0.8.0, ignored before). is the byte offset of the first pixel in the source file. (The current implementation always mmap's the whole file from position 0 to the end of the image, so large offsets should be avoided. Before mpv 0.8.0, the offset was actually passed directly to , but it was changed to make using it easier.) is a string identifying the image format. Currently, only is defined. This format has 4 bytes per pixels, with 8 bits per component. The least significant 8 bits are blue, and the most significant 8 bits are alpha (in little endian, the components are B-G-R-A, with B as first byte). This uses premultiplied alpha: every color component is already multiplied with the alpha component. This means the numeric value of each component is equal to or smaller than the alpha component. (Violating this rule will lead to different results with different VOs: numeric overflows resulting from blending broken alpha values is considered something that shouldn't happen, and consequently implementations don't ensure that you get predictable behavior in this case.) , , and specify the size of the overlay. is the visible width of the overlay, while gives the width in bytes in memory. In the simple case, and with the format, . In general, the total amount of memory accessed is . (Technically, the minimum size would be , but for simplicity, the player will access all bytes.) and specify the (optional) display size of the overlay. The overlay visible portion of the overlay ( and ) is scaled to in display to and . If parameters are not present, the values for and are used. Before mpv 0.18.1, you had to do manual \"double buffering\" when updating an overlay by replacing it with a different memory buffer. Since mpv 0.18.1, the memory is simply copied and doesn't reference any of the memory indicated by the command's arguments after the command returns. If you want to use this command before mpv 0.18.1, reads the old docs to see how to handle this correctly. Remove an overlay added with and the same ID. Does nothing if no overlay with this ID exists. You can use this to add text overlays in ASS format. ASS has advanced positioning and rendering tags, which can be used to render almost any kind of vector graphics. This command accepts the following parameters: Arbitrary integer that identifies the overlay. Multiple overlays can be added by calling this command with different parameters. Calling this command with the same replaces the previously set overlay. There is a separate namespace for each libmpv client (i.e. IPC connection, script), so IDs can be made up and assigned by the API user without conflicting with other API users. If the libmpv client is destroyed, all overlays associated with it are also deleted. In particular, connecting via , adding an overlay, and disconnecting will remove the overlay immediately again. String that gives the type of the overlay. Accepts the following values (HTML rendering of this is broken, view the generated manpage instead, or the raw RST source): The parameter is a string. The string is split on the newline character. Every line is turned into the part of a ASS event. Timing is unused (but behavior of timing dependent ASS tags may change in future mpv versions). Note that it's better to put multiple lines into , instead of adding multiple OSD overlays. This provides 2 ASS . contains the text style as defined by the current options. is similar, and contains style that would have if all options were set to the default. In addition, the and options specify the value of the ASS and header fields. If is set to 0, is initialized to an arbitrary default value (but note that the default for this command is 720, not 0). If is set to 0, is set based on such that a virtual ASS pixel has a square pixel aspect ratio. Special value that causes the overlay to be removed. Most parameters other than and are mostly ignored. String defining the overlay contents according to the parameter. Used if is set to (see description there). Optional, defaults to 0/720. The Z order of the overlay. Optional, defaults to 0. Note that Z order between different overlays of different formats is static, and cannot be changed (currently, this means that bitmap overlays added by are always on top of the ASS overlays added by ). In addition, the builtin OSD components are always below any of the custom OSD. (This includes subtitles of any kind as well as text rendered by .) It's possible that future mpv versions will randomly change how Z order between different OSD formats and builtin OSD is handled. If set to true, do not display this (default: false). If set to true, attempt to determine bounds and write them to the command's result value as , , , rectangle (default: false). If the rectangle is empty, not known, or somehow degenerate, it is not set. / is the coordinate of the bottom exclusive corner of the rectangle. The result value may depend on the VO window size, and is based on the last known window size at the time of the call. This means the results may be different from what is actually rendered. For , the result rectangle is recomputed to coordinates ( / ). If window size is not known, a fallback is chosen. You should be aware that this mechanism is very inefficient, as it renders the full result, and then uses the bounding box of the rendered bitmap list (even if is set). It will flush various caches. Its results also depend on the used libass version. This feature is experimental, and may change in some way again. Always use named arguments ( ). Lua scripts should use the helper instead of invoking this command directly. Send a message to all clients, and pass it the following list of arguments. What this message means, how many arguments it takes, and what the arguments mean is fully up to the receiver and the sender. Every client receives the message, so be careful about name clashes (or use ). This command has a variable number of arguments, and cannot be used with named arguments. Same as , but send it only to the client named . Each client (scripts etc.) has a unique name. For example, Lua scripts can get their name via . Note that client names only consist of alphanumeric characters and . This command has a variable number of arguments, and cannot be used with named arguments. Invoke a script-provided key binding. This can be used to remap key bindings provided by external Lua scripts. The argument is the name of the binding. It can optionally be prefixed with the name of the script, using as separator, e.g. . Note that script names only consist of alphanumeric characters and . For completeness, here is how this command works internally. The details could change any time. On any matching key event, or is called (depending on whether the script name is included), with the following arguments:\n• The name of the binding (as established above).\n• The key state as string (see below).\n• The key name (since mpv 0.15.0).\n• The text the key would produce, or empty string if not applicable. The 5th argument is only set if no modifiers are present (using the shift key with a letter is normally not emitted as having a modifier, and results in upper case text instead, but some backends may mess up).\n• One of (key was pressed down), (was released), (key is still down, and was repeated; only if key repeat is enabled for this binding), (key was pressed; happens if up/down can't be tracked).\n• Whether the event originates from the mouse, either (mouse button) or (something else).\n• Whether the event results from a cancellation (e.g. the key is logically released but not physically released), either (canceled) or (something else). Not all types of cancellations set this flag. Future versions can add more arguments and more key state characters to support more input peculiarities. Cycle through A-B loop states. The first command will set the point (the property); the second the point, and the third will clear both points. Drop audio/video/demuxer buffers, and restart from fresh. Might help with unseekable streams that are going out of sync. This command might be changed or removed in the future. Return a screenshot in memory. This can be used only through the client API. The MPV_FORMAT_NODE_MAP returned by this command has the , , fields set to obvious contents. The field is set to by default. This format is organized as (where is the LSB). The contents of the padding are undefined. The field is of type MPV_FORMAT_BYTE_ARRAY with the actual image data. The image is freed as soon as the result mpv_node is freed. As usual with client API semantics, you are not allowed to write to the image data. The is the number of bytes from a pixel at to the pixel at . This can be larger than if the image was cropped, or if there is padding. This number can be negative as well. You access a pixel with (assuming the format). The argument is like the first argument to and supports , , . Send a command to the filter. Note that currently, this only works with the filter. Refer to the libavfilter documentation for the list of supported commands for each filter. is a mpv filter label, use to send it to all filters at once. is a filter or filter instance name and defaults to . Note that the target is an additional specifier for filters that support them, such as complex filter chains. Same as , but for audio filters. Apply the contents of a named profile. This is like using in a config file, except you can map it to a key binding to change it at runtime. Apply the profile. Default if the argument is omitted. Restore options set by a previous command for this profile. Only works if the profile has set to a relevant mode. Prints a warning if nothing could be done. See Runtime profiles for details. Load a configuration file, similar to the option. If the file was already included, its previous options are not reset before it is reparsed. Load an input configuration file, similar to the option. If the file was already included, its previous bindings are not reset before it is reparsed. Load a script, similar to the option. Whether this waits for the script to finish initialization or not changed multiple times, and the future behavior is left undefined. On success, returns a with a field set to the return value of the API call of the newly created script handle. This command changes list options as described in List Options. The parameter is the normal option name, while is the suffix or action used on the option. Some operations take no value, but the command still requires the value parameter. In these cases, the value must be an empty string. Add a filename to the list. The command line equivalent is or alternatively . Dump the current cache to the given filename. The file is overwritten if it already exists. and give the time range of what to dump. If no data is cached at the given time range, nothing may be dumped (creating a file with no packets). Dumping a larger part of the cache will freeze the player. No effort was made to fix this, as this feature was meant mostly for creating small excerpts. See for various caveats that mostly apply to this command too, as both use the same underlying code for writing the output file. If is an empty string, an ongoing is stopped. If is , then continuous dumping is enabled. Then, after dumping the existing parts of the cache, anything read from network is appended to the cache as well. This behaves similar to (although it does not conflict with that option, and they can be both active at the same time). If the time is after the cache, the command will _not_ wait and write newly received data to it. The end of the resulting file may be slightly damaged or incomplete at the end. (Not enough effort was made to ensure that the end lines up properly.) Note that this command will finish only once dumping ends. That means it works similar to the command, just that it can block much longer. If continuous dumping is used, the command will not finish until playback is stopped, an error happens, another command is run, or an API like was called to explicitly stop the command. See Synchronous vs. Asynchronous. This was mostly created for network streams. For local files, there may be much better methods to create excerpts and such. There are tons of much more user-friendly Lua scripts, that will re-encode parts of a file by spawning a separate instance of . With network streams, this is not that easily possible, as the stream would have to be downloaded again. Even if is used to record the stream to the local filesystem, there may be problems, because the recorded file is still written to. This command is experimental, and all details about it may change in the future. Essentially calls with the current AB-loop points as arguments. Like , this will overwrite the file at . Likewise, if the B point is set to , it will enter continuous dumping after the existing cache was dumped. The author reserves the right to remove this command if enough motivation is found to move this functionality to a trivial Lua script. Re-adjust the A/B loop points to the start and end within the cache the command will (probably) dump. Basically, it aligns the times on keyframes. The guess might be off especially at the end (due to granularity issues due to remuxing). If the cache shrinks in the meantime, the points set by the command will not be the effective parameters either. This command has an even more uncertain future than and might disappear without replacement if the author decides it's useless. Begin window dragging if supported by the current VO. This command should only be called while a mouse button is being pressed, otherwise it will be ignored. The exact effect of this command depends on the VO implementation of window dragging. For example, on Windows only the left mouse button can begin window dragging, while X11 and Wayland allow other mouse buttons. This is a partial list of events. This section describes what returns, and which is what scripting APIs and the JSON IPC sees. Note that the C API has separate C-level declarations with , which may be slightly different. Note that events are asynchronous: the player core continues running while events are delivered to scripts and other clients. In some cases, you can use hooks to enforce synchronous execution. All events can have the following fields: Name as the event (as returned by ). The field (opaque user value). If is 0, the field is not added. Set to an error string (as returned by ). This field is missing if no error happened, or the event type does not report error. Most events leave this unset. This list uses the event name field value, and the C API symbol in brackets: Happens right before a new file is loaded. When you receive this, the player is loading the file (or possibly already done with it). This has the following fields: Playlist entry ID of the file being loaded now. Happens after a file was unloaded. Typically, the player will load the next file right away, or quit if this was the last file. The event has the following fields: The file has ended. This can (but doesn't have to) include incomplete files or broken network connections under circumstances. Playback was ended by sending the quit command. An error happened. In this case, an field is present with the error string. Happens with playlists and similar. Details see in the C API. Unknown. Normally doesn't happen, unless the Lua API is out of sync with the C API. (Likewise, it could happen that your script gets reason strings that did not exist yet at the time your script was written.) Playlist entry ID of the file that was being played or attempted to be played. This has the same value as the field in the corresponding event. Set to mpv error string describing the approximate reason why playback failed. Unset if no error known. (In Lua scripting, this value was set on the field directly. This is deprecated since mpv 0.33.0. In the future, this field will be unset for this specific event.) If loading ended, because the playlist entry to be played was for example a playlist, and the current playlist entry is replaced with a number of other entries. This may happen at least with MPV_END_FILE_REASON_REDIRECT (other event types may use this for similar but different purposes in the future). In this case, playlist_insert_id will be set to the playlist entry ID of the first inserted entry, and playlist_insert_num_entries to the total number of inserted playlist entries. Note this in this specific case, the ID of the last inserted entry is playlist_insert_id+num-1. Beware that depending on circumstances, you may observe the new playlist entries before seeing the event (e.g. reading the \"playlist\" property or getting a property change notification before receiving the event). If this is 0 in the C API, this field isn't added. See playlist_insert_id. Only present if playlist_insert_id is present. Happens after a file was loaded and begins playback. Happens on seeking. (This might include cases when the player seeks internally, even without user interaction. This includes e.g. segment changes when playing ordered chapters Matroska files.) Start of playback after seek or after file was loaded. Sent when the player quits, and the script should terminate. Normally handled automatically. See Details on the script initialization and lifecycle. This contains, in addition to the default event fields, the following fields: The module prefix, identifies the sender of the message. This is what the terminal player puts in front of the message text when using the option, and is also what is used for . The log level as string. See for possible log level names. Note that later versions of mpv might add new levels or remove (undocumented) existing ones. The log message. The text will end with a newline character. Sometimes it can contain multiple lines. Keep in mind that these messages are meant to be hints for humans. You should not parse them, and prefix/level/text of messages might change any time. The event has the following fields: ID to pass to . The Lua scripting wrapper provides a better API around this with . This is one of the commands for which the field is meaningful. JSON IPC and Lua and possibly other backends treat this specially and may not pass the actual event to the user. See C API. The event has the following fields: The result (on success) of any type, if any. Lua and possibly other backends treat this specially and may not pass the actual event to the user. The event has the following fields: Array of strings with the message data. Happens on video output or filter reconfig. Happens on audio output or filter reconfig. Happens when a property that is being observed changes value. The event has the following fields: The name of the property. The new value of the property. The following events also happen, but are deprecated: , Use (Lua: ) instead. Hooks are synchronous events between player core and a script or similar. This applies to client API (including the Lua scripting interface). Normally, events are supposed to be asynchronous, and the hook API provides an awkward and obscure way to handle events that require stricter coordination. There are no API stability guarantees made. Not following the protocol exactly can make the player freeze randomly. Basically, nobody should use this API. The C API is described in the header files. The Lua API is described in the Lua section. Before a hook is actually invoked on an API clients, it will attempt to return new values for all observed properties that were changed before the hook. This may make it easier for an application to set defined \"barriers\" between property change notifications by registering hooks. (That means these hooks will have an effect, even if you do nothing and make them continue immediately.) The following hooks are currently defined: Called when a file is to be opened, before anything is actually done. For example, you could read and write the property to redirect an URL to something else (consider support for streaming sites which rarely give the user a direct media URL), or you could set per-file options with by setting the property . The player will wait until all hooks are run. Ordered after and before . Called after after a file has been opened, but failed to. This can be used to provide a fallback in case native demuxers failed to recognize the file, instead of always running before the native demuxers like . Demux will only be retried if was changed. If it fails again, this hook is _not_ called again, and loading definitely fails. Ordered after , and before and . Called after a file has been opened, and before tracks are selected and decoders are created. This has some usefulness if an API users wants to select tracks manually, based on the set of available tracks. It's also useful to initialize in a specific way by API, without having to \"probe\" the available streams at first. Note that this does not yet apply default track selection. Which operations exactly can be done and not be done, and what information is available and what is not yet available yet, is all subject to change. Ordered after etc. and before . Run before closing a file, and before actually uninitializing everything. It's not possible to resume playback in this state. Ordered before . Will also happen in the error case (then after ). Run before a event is sent. (If any client changes the current playlist entry, or sends a quit command to the player, the corresponding event will not actually happen after the hook returns.) Useful to drain property changes before a new file is loaded. Run after an event. Useful to drain property changes after a file has finished. These prefixes are placed between key name and the actual command. Multiple prefixes can be specified. They are separated by whitespace. Use the default behavior for this command. This is the default for commands. Some libmpv/scripting/IPC APIs do not use this as default, but use instead. Do not use any OSD for this command. If possible, show a bar with this command. Seek commands will show the progress bar, property changing commands may show the newly set value. If possible, show an OSD message with this command. Seek command show the current playback time, property changing commands show the newly set value as text. Do not expand properties in string arguments. (Like .) This is the default for some libmpv/scripting/IPC APIs. All string arguments are expanded as described in Property Expansion. This is the default for commands. For some commands, keeping a key pressed doesn't run the command repeatedly. This prefix forces enabling key repeat in any case. For a list of commands: the first command determines the repeatability of the whole list (up to and including version 0.33 - a list was always repeatable). For some commands, keeping a key pressed runs the command repeatedly. This prefix forces disabling key repeat in any case. Allow asynchronous execution (if possible). Note that only a few commands will support this (usually this is explicitly documented). Some commands are asynchronous by default (or rather, their effects might manifest after completion of the command). The semantics of this flag might change in the future. Set it only if you don't rely on the effects of this command being fully realized when it returns. See Synchronous vs. Asynchronous. Allow synchronous execution (if possible). Normally, all commands are synchronous by default, but some are asynchronous by default for compatibility with older behavior. All of the osd prefixes are still overridden by the global settings. The and prefix matter only for how the issuer of the command waits on the completion of the command. Normally it does not affect how the command behaves by itself. There are the following cases:\n• Normal input.conf commands are always run asynchronously. Slow running commands are queued up or run in parallel.\n• \"Multi\" input.conf commands (1 key binding, concatenated with ) will be executed in order, except for commands that are async (either prefixed with , or async by default for some commands). The async commands are run in a detached manner, possibly in parallel to the remaining sync commands in the list.\n• Normal Lua and libmpv commands (e.g. ) are run in a blocking manner, unless the prefix is used, or the command is async by default. This means in the sync case the caller will block, even if the core continues playback. Async mode runs the command in a detached manner.\n• Async libmpv command API (e.g. ) never blocks the caller, and always notify their completion with a message. The and prefixes make no difference.\n• Lua also provides APIs for running async commands, which behave similar to the C counterparts.\n• In all cases, async mode can still run commands in a synchronous manner, even in detached mode. This can for example happen in cases when a command does not have an asynchronous implementation. The async libmpv API still never blocks the caller in these cases. Before mpv 0.29.0, the prefix was only used by screenshot commands, and made them run the file saving code in a detached manner. This is the default now, and changes behavior only in the ways mentioned above. Currently the following commands have different waiting characteristics with sync vs. async: sub-add, audio-add, sub-reload, audio-reload, rescan-external-files, screenshot, screenshot-to-file, dump-cache, ab-loop-dump-cache. On the API level, every asynchronous command is bound to the context which started it. For example, an asynchronous command started by is bound to the passed to the function. Only this receives the completion notification ( ), and only this handle can abort a still running command directly. If the is destroyed, any still running async. commands started by it are terminated. The scripting APIs and JSON IPC give each script/connection its own implicit . If the player is closed, the core may abort all pending async. commands on its own (like a forced call for each pending command on behalf of the API user). This happens at the same time is sent, and there is no way to prevent this. Input sections group a set of bindings, and enable or disable them at once. In , each key binding is assigned to an input section, rather than actually having explicit text sections. See also: and commands. Bindings without input section are implicitly assigned to this section. It is enabled by default during normal playback. Section which is active in encoding mode. It is enabled exclusively, so that bindings in the sections are ignored. Properties are used to set mpv options during runtime, or to query arbitrary information. They can be manipulated with the / / commands, and retrieved with , or anything else that uses property expansion. (See Property Expansion.) The property name is annotated with RW to indicate whether the property is generally writable. If an option is referenced, the property will normally take/return exactly the same values as the option. In these cases, properties are merely a way to change an option at runtime. Most options can be set at runtime via properties as well. Just remove the leading from the option name. These are not documented below, see OPTIONS instead. Only properties which do not exist as option with the same name, or which have very different behavior from the options are documented below. Properties marked as (RW) are writeable, while those that aren't are read-only. Factor multiplied with at which the player attempts to play the file. Usually it's exactly 1. (Display sync mode will make this useful.) OSD formatting will display it in the form of , with the number being for the given raw property value. Whether is actually active. Currently played file, with path stripped. If this is an URL, try to undo percent encoding as well. (The result is not necessarily correct, but looks better for display purposes. Use the property to get an unmodified filename.) Like the property, but if the text contains a , strip all text after the last . Usually this removes the file extension. Length in bytes of the source file/stream. (This is the same as . For segmented/multi-part files, this will return the size of the main or manifest file, whatever it is.) This is only an estimate. (It's computed from two unreliable quantities: fps and stream length.) This is only an estimate. (It's computed from two unreliable quantities: fps and possibly rounded timestamps.) Full path of the currently played file. Usually this is exactly the same string you pass on the mpv command line or the command, even if it's a relative path. If you expect an absolute path, you will have to determine it yourself, for example by using the property. The full path to the currently played media. This is different from only in special cases. In particular, if is used, and the URL is detected by , then the script will set this property to the actual media URL. This property should be set only during the or hooks, otherwise it will have no effect (or may do something implementation defined in the future). The property is reset if playback of the current media ends. If the currently played file has a tag, use that. Symbolic name of the file format. In some cases, this is a comma-separated list of format names, e.g. mp4 is (the list may grow in the future for any format). Name of the current demuxer. (This is useless.) Filename (full path) of the stream layer filename. (This is probably useless and is almost never different from .) Raw byte position in source stream. Technically, this returns the position of the most recent packet passed to a decoder. Duration of the current file in seconds. If the duration is unknown, the property is unavailable. Note that the file duration is not always exactly known, so this is an estimate. This replaces the property, which was deprecated after the mpv 0.9 release. (The semantics are the same.) Last A/V synchronization difference. Unavailable if audio or video is disabled. Total A-V sync correction done. Unavailable if audio or video is disabled. Video frames dropped by decoder, because video is too far behind audio (when using ). Sometimes, this may be incremented in other situations, e.g. when video packets are damaged, or the decoder doesn't follow the usual rules. Unavailable if video is disabled. Frames dropped by VO (when using ). Number of video frames that were not timed correctly in display-sync mode for the sake of keeping A/V sync. This does not include external circumstances, such as video rendering being too slow or the graphics driver somehow skipping a vsync. It does not include rounding errors either (which can happen especially with bad source timestamps). For example, using the mode should never change this value from 0. For how many vsyncs a frame is displayed on average. This is available if display-sync is active only. For 30 FPS video on a 60 Hz screen, this will be 2. This is the moving average of what actually has been scheduled, so 24 FPS on 60 Hz will never remain exactly on 2.5, but jitter depending on the last frame displayed. Estimated number of frames delayed due to external circumstances in display-sync mode. Note that in general, mpv has to guess that this is happening, and the guess can be inaccurate. Position in current file (0-100). The advantage over using this instead of calculating it out of other properties is that it properly falls back to estimating the playback position from the byte position, if the file duration is not known. Deprecated. Always returns 0. Before mpv 0.14, this used to return the start time of the file (could affect e.g. transport streams). See option. Remaining length of the file in seconds. Note that the file duration is not always exactly known, so this is an estimate. Current audio playback position in current file in seconds. Unlike , this updates more often than once per frame. This is mostly equivalent to for audio-only files however it also takes into account the audio driver delay. This can lead to negative values in certain cases, so in general you probably want to simply use . Prior to mpv 0.39.0, and could report different values in certain edge cases. How many more times the current file is going to be looped. This is initialized from the value of . This counts the number of times it causes the player to seek to the beginning of the file, so it is 0 the last the time is played. -1 corresponds to infinity. How many more times the current A-B loop is going to be looped, if one is active. This is initialized from the value of . This counts the number of times it causes the player to seek to , so it is 0 the last the time the loop is played. -1 corresponds to infinity. Current chapter number. The number of the first chapter is 0. Current MKV edition number. Setting this property to a different value will restart playback. The number of the first edition is 0. Before mpv 0.31.0, this showed the actual edition selected at runtime, if you didn't set the option or property manually. With mpv 0.31.0 and later, this strictly returns the user-set option or property value, and the property was added to return the runtime selected edition (this matters with , the default). Currently selected edition. This property is unavailable if no file is loaded, or the file has no editions. (Matroska files make a difference between having no editions and a single edition, which will be reflected by the property, although in practice it does not matter.) List of editions, current entry marked. Currently, the raw property value is useless. This has a number of sub-properties. Replace with the 0-based edition index. Number of editions. If there are no editions, this can be 0 or 1 (1 if there's a useless dummy edition). Edition ID as integer. Use this to set the property. Currently, this is the same as the edition index. Whether this is the default edition. Edition title as stored in the file. Not always available. When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: If the property is accessed with Lua's , this returns a table with metadata keys mapping to metadata values. If it is accessed with the client API, this returns a , with tag keys mapping to tag values. For OSD, it returns a formatted list. Trying to retrieve this property as a raw string doesn't work. This has a number of sub-properties: Key name of the Nth metadata entry. (The first entry is ). Value of the Nth metadata entry. Old version of . Use is discouraged, because the metadata key string could conflict with other sub-properties. The layout of this property might be subject to change. Suggestions are welcome how exactly this property should work. When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: MPV_FORMAT_NODE_MAP (key and string value for each metadata entry) Like , but includes only fields listed in the option. This is the same set of tags that is printed to the terminal. Metadata of current chapter. Works similar to property. It also allows the same access methods (using sub-properties). Per-chapter metadata is very rare. Usually, only the chapter name ( ) is set. For accessing other information, like chapter start, see the property. Metadata added by video filters. Accessed by the filter label, which, if not explicitly specified using the syntax, will be . Works similar to property. It allows the same access methods (using sub-properties). An example of this kind of metadata are the cropping parameters added by . Equivalent to , but for audio filters. Returns /true if mpv's deinterlacing filter is active. Note that it will not detect any manually inserted deinterlacing filters done via . Returns /true if no file is loaded, but the player is staying around because of the option. Whether the playback core is paused. This can differ from in special situations, such as when the player pauses itself due to low network cache. This also returns /true if playback is restarting or if nothing is playing at all. In other words, it's only /false if there's actually video playing. (Behavior since mpv 0.7.0.) Current I/O read speed between the cache and the lower layer (like network). This gives the number bytes per seconds over a 1 second window (using the type for the client API). This is the same as . Approximate duration of video buffered in the demuxer, in seconds. The guess is very unreliable, and often the property will not be available at all, even if data is buffered. Approximate time of video buffered in the demuxer, in seconds. Same as but returns the last timestamp of buffered data in demuxer. Whether the demuxer is idle, which means that the demuxer cache is filled to the requested amount, and is currently not reading more data. Each entry in represents a region in the demuxer cache that can be seeked to, with a and fields containing the respective timestamps. If there are multiple demuxers active, this only returns information about the \"main\" demuxer, but might be changed in future to return unified information about all demuxers. The ranges are in arbitrary order. Often, ranges will overlap for a bit, before being joined. In broken corner cases, ranges may overlap all over the place. The end of a seek range is usually smaller than the value returned by the property, because that property returns the guessed buffering amount, while the seek ranges represent the buffered data that can actually be used for cached seeking. indicates whether the seek range with the lowest timestamp points to the beginning of the stream (BOF). This implies you cannot seek before this position at all. indicates whether the seek range with the highest timestamp points to the end of the stream (EOF). If both and are true, and there's only 1 cache range, the entire stream is cached. is the number of bytes of packets buffered in the range starting from the current decoding position. This is a rough estimate (may not account correctly for various overhead), and stops at the demuxer position (it ignores seek ranges after it). is the number of bytes stored in the file cache. This includes all overhead, and possibly unused data (like pruned data). This member is missing if the file cache wasn't enabled with . is the approximate timestamp of the start of the buffered range. Missing if unavailable. is the estimated input rate of the network layer (or any other byte-oriented input layer) in bytes per second. May be inaccurate or missing. is an array containing an entry for each stream type: video, audio, and subtitle. For each stream type, the details for the demuxer cache for that stream type are available as , and . When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: Other fields (might be changed or removed in the future): Whether the reader thread has hit the end of the file. Whether the reader thread could not satisfy a decoder's request for a new packet. Whether the thread is currently not reading. Sum of packet bytes (plus some overhead estimation) of the entire packet queue, including cached seekable ranges. Whether the stream demuxed via the main demuxer is most likely played via network. What constitutes \"network\" is not always clear, might be used for other types of untrusted streams, could be wrong in certain cases, and its definition might be changing. Also, external files (like separate audio files or streams) do not influence the value of this property (currently). The start time reported by the demuxer in fractional seconds. Whether playback is paused because of waiting for the cache. The percentage (0-100) of the cache fill status until the player will unpause (related to ). Whether the end of playback was reached. Note that this is usually interesting only if is enabled, since otherwise the player will immediately play the next file (or exit or enter idle mode), and in these cases the property will logically be cleared immediately after it's set. Whether the player is currently seeking, or otherwise trying to restart playback. (It's possible that it returns /true while a file is loaded. This is because the same underlying code is used for seeking and resyncing.) Whether the audio mixer is active. This option is relatively useless. Before mpv 0.18.1, it could be used to infer behavior of the property. System volume. This property is available only if mpv audio output is currently active, and only if the underlying implementation supports volume control. What this option does depends on the API. For example, on ALSA this usually changes system-wide audio, while with PulseAudio this controls per-application volume. Similar to , but controls the mute state. May be unimplemented even if works. Audio format as output by the audio decoder. This has a number of sub-properties: The sample format as string. This uses the same names as used in other places of mpv. The channel layout as a string. This is similar to what the accepts. As , but instead of the possibly cryptic actual layout sent to the audio device, return a hopefully more human readable form. (Usually only makes sense.) Number of audio channels. This is redundant to the field described above. When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: Same as , but the format of the data written to the audio API. Redirects to . This parameter (as well as similar ones) can be overridden with the video filter. Writing to it may change the currently used hardware decoder, if possible. (Internally, the player may reinitialize the decoder, and will perform a seek to refresh the video properly.) You can watch the other hwdec properties to see whether this was successful. Unlike in mpv 0.9.x and before, this does not return the currently active hardware decoder. Since mpv 0.18.0, is available for this purpose. The current hardware decoding in use. If decoding is active, return one of the values used by the option/property. /false indicates software decoding. If no decoder is loaded, the property is unavailable. This returns the currently loaded hardware decoding/output interop driver. This is known only once the VO has opened (and possibly later). With some VOs (like ), this might be never known in advance, but only when the decoder attempted to create the hw decoder successfully. (Using can load it eagerly.) If there are multiple drivers loaded, they will be separated by . If no VO is active or no interop driver is known, this property is unavailable. This does not necessarily use the same values as . There can be multiple interop drivers for the same hardware decoder, depending on platform and VO. Video size. This uses the size of the video as decoded, or if no video frame has been decoded yet, the (possibly incorrect) container indicated size. Video parameters, as output by the decoder (with overrides like aspect etc. applied). This has a number of sub-properties: The pixel format as string. This uses the same names as used in other places of mpv. The underlying pixel format as string. This is relevant for some cases of hardware decoding and unavailable otherwise. Average bits-per-pixel as integer. Subsampled planar formats use a different resolution, which is the reason this value can sometimes be odd or confusing. Can be unavailable with some formats. Video size as integers, with no aspect correction applied. Display aspect ratio name as string. The name corresponds to motion picture film format that introduced given aspect ratio in film. The colormatrix in use as string. (Exact values subject to change.) The colorlevels as string. (Exact values subject to change.) The primaries in use as string. (Exact values subject to change.) The gamma function in use as string. (Exact values subject to change.) The light type in use as a string. (Exact values subject to change.) Alpha type. If the format has no alpha channel, this will be unavailable (but in future releases, it could change to ). If alpha is present, this is set to or . Minimum luminance, as reported by HDR10 metadata (in cd/m²) Maximum luminance, as reported by HDR10 metadata (in cd/m²) Maximum content light level, as reported by HDR10 metadata (in cd/m²) Maximum frame average light level, as reported by HDR10 metadata (in cd/m²) MaxRGB of a scene for R component, as reported by HDR10+ metadata (in cd/m²) MaxRGB of a scene for G component, as reported by HDR10+ metadata (in cd/m²) MaxRGB of a scene for B component, as reported by HDR10+ metadata (in cd/m²) Maximum PQ luminance of a frame, as reported by peak detection (in PQ, 0-1) Average PQ luminance of a frame, as reported by peak detection (in PQ, 0-1) When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: Video display size. This is the video size after filters and aspect scaling have been applied. The actual video window size can still be different from this, e.g. if the user resized the video window manually. These have the same values as and . Exactly like , but no overrides applied. Same as , but after video filters have been applied. If there are no video filters in use, this will contain the same values as . Note that this is still not necessarily what the video window uses, since the user can change the window size, and all real VOs do their own scaling independently from the filter chain. Has the same sub-properties as . Same as , but with the target properties that VO outputs to. Has the same sub-properties as . Approximate information of the current frame. Note that if any of these are used on OSD, the information might be off by a few frames due to OSD redrawing and frame display being somewhat disconnected, and you might have to pause and force a redraw. This has a number of sub-properties: The type of the picture. It can be \"I\" (intra), \"P\" (predicted), \"B\" (bi-dir predicted) or unavailable. Whether the content of the frame is interlaced. If the content is interlaced, whether the top field is displayed first. Whether the frame must be delayed when decoding. Container FPS. This can easily contain bogus values. For videos that use modern container formats or video codecs, this will often be incorrect. Estimated/measured FPS of the video filter chain output. (If no filters are used, this corresponds to decoder output.) This uses the average of the 10 past frame durations to calculate the FPS. It will be inaccurate if frame-dropping is involved (such as when framedrop is explicitly enabled, or after precise seeking). Files with imprecise timestamps (such as Matroska) might lead to unstable results. The value calculated from the current window size. This has the same value as if the window size was not changed since setting the option, and the window size was not restricted in other ways. If the window is fullscreened, this will return the scale value calculated from the last non-fullscreen size of the window. The property is unavailable if no video is active. It is also possible to write to this property. This has the same behavior as writing . Note that writing to will not affect the value of . Whether the window has focus. Might not be supported by all VOs. Names of the displays that the mpv window covers. On X11, these are the xrandr names (LVDS1, HDMI1, DP1, VGA1, etc.). On Windows, these are the GDI names (\\.DISPLAY1, \\.DISPLAY2, etc.) and the first display in the list will be the one that Windows considers associated with the window (as determined by the MonitorFromWindow API.) On macOS these are the Display Product Names as used in the System Information with a serial number in brackets and only one display name is returned since a window can only be on one screen. On Wayland, these are the wl_output names if protocol version >= 4 is used (LVDS-1, HDMI-A-1, X11-1, etc.), or the wl_output model reported by the geometry event if protocol version < 4 is used. The refresh rate of the current display. Currently, this is the lowest FPS of any display covered by the video, as retrieved by the underlying system APIs (e.g. xrandr on X11). It is not the measured FPS. It's not necessarily available on all platforms. Note that any of the listed facts may change any time without a warning. The actual rate at which display refreshes seem to occur, measured by system time. Only available if display-sync mode (as selected by ) is active. The current display's horizontal and vertical resolution in pixels. Whether or not these values update as the mpv window changes displays depends on the windowing backend. It may not be available on all platforms. The HiDPI scale factor as reported by the windowing backend. If no VO is active, or if the VO does not report a value, this property is unavailable. It may be saner to report an absolute DPI, however, this is the way HiDPI support is implemented on most OS APIs. See also . Last known OSD width (can be 0). This is needed if you want to use the command. It gives you the actual OSD/window size (not including decorations drawn by the OS window manager). Last known OSD display pixel aspect (can be 0). Has the following sub-properties (which can be read as or Lua table with ): Size of the VO window in OSD render units (usually pixels, but may be scaled pixels with VOs like ). Size of the VO window in OSD render units, Pixel aspect ratio of the OSD (usually 1). Display aspect ratio of the VO window. (Computing from the properties above.) OSD to video margins (top, bottom, left, right). This describes the area into which the video is rendered. Any of these properties may be unavailable or set to dummy values if the VO window is not created or visible. This has two sub-properties. width of the terminal in cells height of the terminal in cells This property is not observable. Reacting to size changes requires polling. Read-only - mpv's window id. May not always be available, i.e due to window not being opened yet or not being supported by the VO. Read-only - last known mouse position, normalized to OSD dimensions. Has the following sub-properties (which can be read as or Lua table with ): Last known coordinates of the mouse pointer. Boolean - whether the mouse pointer hovers the video window. The coordinates should be ignored when this value is false, because the video backends update them only when the pointer hovers the window. Read-only - last known touch point positions, normalized to OSD dimensions. This has a number of sub-properties. Replace with the 0-based touch point index. Whenever a new finger touches the screen, a new touch point is added to the list of touch points with the smallest unused available. Unique identifier of the touch point. This can be used to identify individual touch points when their indexes change. When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: The current ASS subtitle track's extradata. There is no formatting done. The extradata is returned as a string as-is. This property is not available for non-ASS subtitle tracks. The current subtitle text regardless of sub visibility. Formatting is stripped. If the subtitle is not text-based (i.e. DVD/BD subtitles), an empty string is returned. This has sub-properties for different formats: Like , but return the text in ASS format. Text subtitles in other formats are converted. For native ASS subtitles, events that do not contain any text (but vector drawings etc.) are not filtered out. If multiple events match with the current playback time, they are concatenated with line breaks. Contains only the \"Text\" part of the events. This property is not enough to render ASS subtitles correctly, because ASS header and per-event metadata are not returned. Use for that. Like , but return the full event with all fields, formatted as lines in a .ass text file. Use with for style information. Same as (with the same sub-properties), but for the secondary subtitles. The current subtitle start time (in seconds). If there's multiple current subtitles, returns the first start time. If no current subtitle is present null is returned instead. Same as , but for the secondary subtitles. The current subtitle end time (in seconds). If there's multiple current subtitles, return the last end time. If no current subtitle is present, or if it's present but has unknown or incorrect duration, null is returned instead. Same as , but for the secondary subtitles. Current position on playlist. The first entry is on position 0. Writing to this property may start playback at the new position. In some cases, this is not necessarily the currently playing file. See explanation of and flags in . If there the playlist is empty, or if it's non-empty, but no entry is \"current\", this property returns -1. Likewise, writing -1 will put the player into idle mode (or exit playback if idle mode is not enabled). If an out of range index is written to the property, this behaves as if writing -1. (Before mpv 0.33.0, instead of returning -1, this property was unavailable if no playlist entry was current.) Writing the current value back to the property will have no effect. Use to restart the playback of the current entry if desired. Same as , but 1-based. Index of the \"current\" item on playlist. This usually, but not necessarily, the currently playing item (see ). Depending on the exact internal state of the player, it may refer to the playlist item to play next, or the playlist item used to determine what to play next. For reading, this is exactly the same as . For writing, this only sets the position of the \"current\" item, without stopping playback of the current file (or starting playback, if this is done in idle mode). Use -1 to remove the current flag. This property is only vaguely useful. If set during playback, it will typically cause the playlist entry after it to be played next. Another possibly odd observable state is that if is run during playback, this property is set to the playlist entry to play next (unlike the previous case). There is an internal flag that decides whether the current playlist entry or the next one should be played, and this flag is currently inaccessible for API users. (Whether this behavior will kept is possibly subject to change.) Index of the \"playing\" item on playlist. A playlist item is \"playing\" if it's being loaded, actually playing, or being unloaded. This property is set during the ( ) and the ( ) events. Outside of that, it returns -1. If the playlist entry was somehow removed during playback, but playback hasn't stopped yet, or is in progress of being stopped, it also returns -1. (This can happen at least during state transitions.) In the \"playing\" state, this is usually the same as , except during state changes, or if was written explicitly. The original path of the playlist for the current entry before mpv expanded the entries. Unavailable if the file was not originally associated with a playlist in some way. Playlist, current entry marked. Currently, the raw property value is useless. This has a number of sub-properties. Replace with the 0-based playlist entry index. Number of playlist entries (same as ). /true if the property points to this entry, /false or unavailable otherwise. /true if the property points to this entry, /false or unavailable otherwise. Name of the Nth entry. Available if the playlist file contains such fields and mpv's parser supports it for the given playlist format, or if the playlist entry has been opened before and a media-title other than filename has been acquired. Unique ID for this entry. This is an automatically assigned integer ID that is unique for the entire life time of the current mpv core instance. Other commands, events, etc. use this as fields. The original path of the playlist for this entry before mpv expanded it. Unavailable if the file was not originally associated with a playlist in some way. When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: MPV_FORMAT_NODE_ARRAY MPV_FORMAT_NODE_MAP (for each playlist entry) \"filename\" MPV_FORMAT_STRING \"current\" MPV_FORMAT_FLAG (might be missing; since mpv 0.7.0) \"playing\" MPV_FORMAT_FLAG (same) \"title\" MPV_FORMAT_STRING (optional) \"id\" MPV_FORMAT_INT64 List of audio/video/sub tracks, current entry marked. Currently, the raw property value is useless. This has a number of sub-properties. Replace with the 0-based track index. The ID as it's used for / / . This is unique within tracks of the same type (sub/audio/video), but otherwise not. String describing the media type. One of , , . Track ID as used in the source file. Not always available. (It is missing if the format has no native ID, if the track is a pseudo-track that does not exist in this way in the actual file, or if the format is handled by libavformat, and the format was not whitelisted as having track IDs.) Track title as it is stored in the file. Not always available. Track language as identified by the file. Not always available. /true if this is a video track that consists of a single picture, /false or unavailable otherwise. The heuristic used to determine if a stream is an image doesn't attempt to detect images in codecs normally used for videos. Otherwise, it is reliable. /true if this is an image embedded in an audio file or external cover art, /false or unavailable otherwise. /true if the track has the default flag set in the file, /false or unavailable otherwise. /true if the track has the forced flag set in the file, /false or unavailable otherwise. /true if the track has the dependent flag set in the file, /false or unavailable otherwise. /true if the track has the visual impaired flag set in the file, /false or unavailable otherwise. /true if the track has the hearing impaired flag set in the file, /false or unavailable otherwise. The bitrate of the HLS stream, if available. The program ID of the HLS stream, if available. The codec name used by this track, for example . Unavailable in some rare cases. The codec descriptive name used by this track. The codec profile used by this track. Available only if the track has been already decoded. /true if the track is an external file, /false or unavailable otherwise. This is set for separate subtitle files. The filename if the track is from an external file, unavailable otherwise. /true if the track is currently decoded, /false or unavailable otherwise. It indicates the selection order of tracks for the same type. If a track is not selected, or is selected by the , it is not available. For subtitle tracks, represents the , and represents the . The stream index as usually used by the FFmpeg utilities. Note that this can be potentially wrong if a demuxer other than libavformat ( ) is used. For mkv files, the index will usually match even if the default (builtin) demuxer is used, but there is no hard guarantee. If this track is being decoded, the short decoder name, If this track is being decoded, the human-readable decoder name, Video size hint as indicated by the container. (Not always accurate.) Number of audio channels as indicated by the container. (Not always accurate - in particular, the track could be decoded as a different number of channels.) Channel layout as indicated by the container. (Not always accurate.) Audio sample rate as indicated by the container. (Not always accurate.) Video FPS as indicated by the container. (Not always accurate.) Audio average bitrate, in bits per second. (Not always accurate.) Short name for format from ffmpeg. If the track is audio, this will be the name of the sample format. If the track is video, this will be the name of the pixel format. Per-track replaygain values. Only available for audio tracks with corresponding information stored in the source file. Per-album replaygain values. If the file has per-track but no per-album information, the per-album values will be copied from the per-track values currently. It's possible that future mpv versions will make these properties unavailable instead in this case. Dolby Vision profile and level. May not be available if the container does not provide this information. When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: This gives access to currently selected tracks. It redirects to the correct entry in . The following sub-entries are defined: , , , For example, returns the current audio track's language field (the same value as ). If tracks of the requested type are selected via , the first one is returned. List of chapters, current entry marked. Currently, the raw property value is useless. This has a number of sub-properties. Replace with the 0-based chapter index. Chapter title as stored in the file. Not always available. When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: See / and the / command. When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: MPV_FORMAT_NODE_ARRAY MPV_FORMAT_NODE_MAP (for each filter entry) \"name\" MPV_FORMAT_STRING \"label\" MPV_FORMAT_STRING [optional] \"enabled\" MPV_FORMAT_FLAG [optional] \"params\" MPV_FORMAT_NODE_MAP [optional] \"key\" MPV_FORMAT_STRING \"value\" MPV_FORMAT_STRING It's also possible to write the property using this format. Whether it's generally possible to seek in the current file. Whether the current file is considered seekable, but only because the cache is active. This means small relative seeks may be fine, but larger seeks may fail anyway. Whether a seek will succeed or not is generally not known in advance. If this property returns /true, so will . Whether playback is stopped or is to be stopped. (Useful in obscure situations like during hook processing, when the user can stop playback, but the script has to explicitly end processing.) See . Setting this to a new value will always update the cursor, and reset the internal timer. Inserts the current OSD symbol as opaque OSD control code (cc). This makes sense only with the command or options which set OSD messages. The control code is implementation specific and is useless for anything else. disables escaping ASS sequences of text in OSD, enables it again. By default, ASS sequences are escaped to avoid accidental formatting, and this property can disable this behavior. Note that the properties return an opaque OSD control code, which only makes sense for the command or options which set OSD messages. Any ASS override tags as understood by libass can be used. Note that you need to escape the character, because the string is processed for C escape sequences before passing it to the OSD code. See Flat command syntax for details. A list of tags can be found here: https://aegisub.org/docs/latest/ass_tags/ Whether the VO is configured right now. Usually this corresponds to whether the video window is visible. If the option is used, this usually always returns /true. Contains introspection about the VO's active render passes and their execution times. Not implemented by all VOs. This is further subdivided into two frame types, for fresh frames (which have to be uploaded, scaled, etc.) and for redrawn frames (which only have to be re-painted). The number of passes for any given subtype can change from frame to frame, and should not be relied upon. Each frame type has a number of further sub-properties. Replace with the frame type, with the 0-based pass index, and with the 0-based sample index. Average execution time of this pass, in nanoseconds. The exact timeframe varies, but it should generally be a handful of seconds. The peak execution time (highest value) within this averaging range, in nanoseconds. The number of samples for this pass. The raw execution time of a specific sample for this pass, in nanoseconds. When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: Note that directly accessing this structure via subkeys is not supported, the only access is through aforementioned . Further performance data. Querying this property triggers internal collection of some data, and may slow down the player. Each query will reset some internal state. Property change notification doesn't and won't work. All of this may change in the future, so don't use this. The builtin script is supposed to be the only user; since it's bundled and built with the source code, it can use knowledge of mpv internal to render the information properly. See script description for some details. Bitrate values calculated on the packet level. This works by dividing the bit size of all packets between two keyframes by their presentation timestamp distance. (This uses the timestamps are stored in the file, so e.g. playback speed does not influence the returned values.) In particular, the video bitrate will update only per keyframe, and show the \"past\" bitrate. To make the property more UI friendly, updates to these properties are throttled in a certain way. The unit is bits per second. OSD formatting turns these values in kilobits (or megabits, if appropriate), which can be prevented by using the raw property value, e.g. with . Note that the accuracy of these properties is influenced by a few factors. If the underlying demuxer rewrites the packets on demuxing (done for some file formats), the bitrate might be slightly off. If timestamps are bad or jittery (like in Matroska), even constant bitrate streams might show fluctuating bitrate. How exactly these values are calculated might change in the future. In earlier versions of mpv, these properties returned a static (but bad) guess using a completely different method. The list of discovered audio devices. This is mostly for use with the client API, and reflects what with the command line player returns. When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: MPV_FORMAT_NODE_ARRAY MPV_FORMAT_NODE_MAP (for each device entry) \"name\" MPV_FORMAT_STRING \"description\" MPV_FORMAT_STRING The is what is to be passed to the option (and often a rather cryptic audio API-specific ID), while is human readable free form text. The description is set to the device name (minus mpv-specific prefix) if no description is available or the description would have been an empty string. The special entry with the name set to selects the default audio output driver and the default device. The property can be watched with the property observation mechanism in the client API and in Lua scripts. (Technically, change notification is enabled the first time this property is read.) Set the audio device. This directly reads/writes the option, but on write accesses, the audio output will be scheduled for reloading. Writing this property while no audio output is active will not automatically enable audio. (This is also true in the case when audio was disabled due to reinitialization failure after a previous write access to .) This property also doesn't tell you which audio device is actually in use. How these details are handled may change in the future. Current video output driver (name as used with ). Current GPU context of video output driver (name as used with ). Valid for and . Current audio output driver (name as used with ). This is a recursive key/value map of arbitrary nodes shared between clients for general use (i.e. scripts, IPC clients, host applications, etc). The player itself does not use any data in it (although some builtin scripts may). The property is not preserved across player restarts. The following sub-paths are reserved for internal uses or have special semantics: , . Unless noted otherwise, the semantics of any properties under these sub-paths can change at any time and may not be relied upon, and writing to these properties may prevent builtin scripts from working properly. Currently, the following properties have defined special semantics: This property is written by an OSC implementation to indicate the margins that it occupies. Its sub-properties , , , and should all be set to the left, right, top, and bottom margins respectively. Values are between 0.0 and 1.0, normalized to window width/height. Sub-paths can be accessed directly; e.g. can be read, written, or observed. The top-level object itself cannot be written directly; write to sub-paths instead. Converting this property or its sub-properties to strings will give a JSON representation. If converting a leaf-level object (i.e. not a map or array) and not using raw mode, the underlying content will be given (e.g. strings will be printed directly, rather than quoted and JSON-escaped). Path to the ytdl executable, if found, or an empty string otherwise. The property is not set until the script attempts to find the ytdl executable, i.e. until an URL is being loaded by the script. Result of executing ytdl to retrieve the JSON data of the URL being loaded. The format is the same as 's result, capturing stdout and stderr. This property stores the raw menu definition. See Context Menu section for details. Menu item type. Can be: , , or empty. Menu item title. Required if type is not . Command to execute when the menu item is clicked. Menu item shortcut key which appears to the right of the menu item. A shortcut key does not have to be functional; it's just a visual hint. Menu item state. Can be: , , , or empty. Submenu items, which is required if type is . When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: Writing to this property with the client API using or with Lua will trigger an immediate update of the menu if mpv video output is currently active. You may observe the property to check if this is the case. The working directory of the mpv process. Can be useful for JSON IPC users, because the command line player usually works with relative paths. List of protocol prefixes potentially recognized by the player. They are returned without trailing suffix (which is still always required). In some cases, the protocol will not actually be supported (consider if ffmpeg is not compiled with TLS support). List of decoders supported. This lists decoders which can be passed to and . Canonical codec name, which identifies the format the decoder can handle. The name of the decoder itself. Often, this is the same as . Sometimes it can be different. It is used to distinguish multiple decoders for the same codec. Human readable description of the decoder and codec. When querying the property with the client API using , or with Lua , this will return a mpv_node with the following contents: List of libavcodec encoders. This has the same format as . The encoder names ( entries) can be passed to and (without the prefix required by and ). List of available libavformat demuxers' names. This can be used to check for support for a specific format or use with . List of Key names, same as output by . The mpv version/copyright string. Depending on how the binary was built, it might contain either a release version, or just a git hash. The configuration arguments that were passed to the build system. If the meson version used to compile mpv is older than 1.1.0, then a hardcoded string of a few, arbitrary options is displayed instead. The contents of the API call. This is a string which identifies the build in some way, either through a release version number, or a git hash. This property is unavailable if mpv is linked against older FFmpeg versions. The value of . This is an integer, encoded in a somewhat weird form (apparently \"hex BCD\"), indicating the release version of the libass library linked to mpv. Returns a string describing what target platform mpv was built for. The value of this is dependent on what the underlying build system detects. Some of the most common values are: , (macos or ios), , , and . Note that this is not a complete listing. The value of option . Most options can be changed at runtime by writing to this property. Note that many options require reloading the file for changes to take effect. If there is an equivalent property, prefer setting the property instead. There shouldn't be any reason to access instead of , except in situations in which the properties have different behavior or conflicting semantics. Similar to , but when setting an option through this property, the option is reset to its old value once the current file has stopped playing. Trying to write an option while no file is playing (or is being loaded) results in an error. This has a number of sub-properties. Replace with the name of a top-level option. No guarantee of stability is given to any of these sub-properties - they may change radically in the feature. The name of the option. The name of the option type, like or . For many complex types, this isn't very accurate. Whether the option was set from the mpv command line. What this is set to if the option is e.g. changed at runtime is left undefined (meaning it could change in the future). Whether the option was set per-file. This is the case with automatically loaded profiles, file-dir configs, and other cases. It means the option value will be restored to the value before playback start when playback ends. Whether the option takes file paths as arguments. The default value of the option. May not always be available. Integer minimum and maximum values allowed for the option. Only available if the options are numeric, and the minimum/maximum has been set internally. It's also possible that only one of these is set. If the option is a choice option, the possible choices. Choices that are integers may or may not be included (they can be implied by and ). Note that options which behave like choice options, but are not actual choice options internally, may not have this info available. The list of profiles and their contents. This is highly implementation-specific, and may change any time. Currently, it returns an array of options for each profile. Each option has a name and a value, with the value currently always being a string. Note that the options array is not a map, as order matters and duplicate entries are possible. Recursive profiles are not expanded, and show up as special options. The field is currently missing if it holds the default value (either because it was not set, or set explicitly to ), but in the future it might hold the value . The list of input commands. This returns an array of maps, where each map node represents a command. This map currently only has a single entry: for the name of the command. (This property is supposed to be a replacement for . The option dumps some more information, but it's a valid feature request to extend this property if needed.) The list of current input key bindings. This returns an array of maps, where each map node represents a binding for a single key/command. This map has the following entries: The key name. This is normalized and may look slightly different from how it was specified in the source (e.g. in input.conf). The command mapped to the key. (Currently, this is exactly the same string as specified in the source, other than stripping whitespace and comments. It's possible that it will be normalized in the future.) If set to true, any existing and active user bindings will take priority. If this entry exists, the name of the script (or similar) which added this binding. Name of the section this binding is part of. This is a rarely used mechanism. This entry may be removed or change meaning in the future. A number. Bindings with a higher value are preferred over bindings with a lower value. If the value is negative, this binding is inactive and will not be triggered by input. Note that mpv does not use this value internally, and matching of bindings may work slightly differently in some cases. In addition, this value is dynamic and can change around at runtime. If available, the comment following the command on the same line. (For example, the input.conf entry would result in an entry with .) This property is read-only, and change notification is not supported. Currently, there is no mechanism to change key bindings at runtime, other than scripts adding or removing their own bindings. You can access (almost) all options as properties, though there are some caveats with some properties (due to historical reasons): While playback is active, these return the actually active tracks. For example, if you set , and the currently played file contains no audio track with ID 5, the property will return . Before mpv 0.31.0, you could set existing tracks at runtime only. This inconsistent behavior is deprecated. Post-deprecation, the reported value and the option value are cleanly separated ( for the option value). If you set the properties during playback, and the filter chain fails to reinitialize, the option will be set, but the runtime filter chain does not change. On the other hand, the next video to be played will fail, because the initial filter chain cannot be created. This behavior changed in mpv 0.31.0. Before this, the new value was rejected iff a video (for ) or an audio (for ) track was active. If playback was not active, the behavior was the same as the current one. The property is read-only and returns the current internal playlist. The option is for loading playlist during command line parsing. For client API uses, you should use the command instead. These are write-only, and will perform actions as they are written to, exactly as if they were used on the mpv CLI commandline. Their only use is when using libmpv before , which in turn is probably only useful in encoding mode. Normal libmpv users should use other mechanisms, such as the command, and the API function. Avoid these properties. All string arguments to input commands as well as certain options (like ) are subject to property expansion. Note that property expansion does not work in places where e.g. numeric parameters are expected. (For example, the command does not do property expansion. The command is an exception and not a general rule.) shows the filename of the current file when pressing the key Whether property expansion is enabled by default depends on which API is used (see Flat command syntax, Commands specified as arrays and Named arguments), but it can always be enabled with the prefix or disabled with the prefix, as described in Input Command Prefixes. The following expansions are supported: Expands to the value of the property . If retrieving the property fails, expand to an error string. (Use with a trailing to expand to an empty string instead.) If is prefixed with , expand to the raw value of the property (see section below). Expands to the value of the property , or if the property cannot be retrieved. is expanded recursively. Expands to (recursively) if the property is available. Expands to (recursively) if the property cannot be retrieved. Expands to (recursively) if the property expands to a string equal to . You can prefix with in order to compare the raw value of a property (see section below). If the property is unavailable, or other errors happen when retrieving it, the value is never considered equal. Note that can't contain any of the characters or . Also, it is possible that escaping with or might be added in the future, should the need arise. Same as with the variant, but is expanded if the value is not equal. (Using the same semantics as with .) Expands to . (To produce this character inside recursive expansion.) Disable property expansion and special handling of for the rest of the string. In places where property expansion is allowed, C-style escapes are often accepted as well. Example: Normally, properties are formatted as human-readable text, meant to be displayed on OSD or on the terminal. It is possible to retrieve an unformatted (raw) value from a property by prefixing its name with . These raw values can be parsed by other programs and follow the same conventions as the options associated with the properties. Additionally, there is a prefix to format human-readable text, with fixed precision for floating-point values. This is useful for printing values where a constant width is important.\n• expands to (if playback position is at 14 minutes 23 seconds)\n• expands to (same time, plus 400 milliseconds - milliseconds are normally not shown in the formatted case) Sometimes, the difference in amount of information carried by raw and formatted property values can be rather big. In some cases, raw values have more information, like higher precision than seconds with . Sometimes it is the other way around, e.g. shows track title and language in the formatted case, but only the track number if it is raw.\n\nmpv provides the built-in module , which contains functions to send commands to the mpv core and to retrieve information about playback state, user settings, file information, and so on. These scripts can be used to control mpv in a similar way to slave mode. Technically, the Lua code uses the client API internally. A script which leaves fullscreen mode when the player is paused: function on_pause_change(name, value) if value == true then mp.set_property(\"fullscreen\", \"no\") end end mp.observe_property(\"pause\", \"bool\", on_pause_change) Scripts can be passed to the option, and are automatically loaded from the subdirectory of the mpv configuration directory (usually ). A script can be a single file. The file extension is used to select the scripting backend to use for it. For Lua, it is . If the extension is not recognized, an error is printed. (If an error happens, the extension is either mistyped, or the backend was not compiled into your mpv binary.) mpv internally loads the script's name by stripping the extension and replacing all nonalphanumeric characters with . E.g., becomes . If there are several scripts with the same name, it is made unique by appending a number. This is the name returned by . Entries with extension are always ignored. If a script is a directory (either if a directory is passed to , or any sub-directories in the script directory, such as for example ), then the directory represents a single script. The player will try to load a file named , where is replaced with the file extension. For example, if exists, it is loaded with the Lua scripting backend. You must not put any other files or directories that start with into the script's top level directory. If the script directory contains for example both and , only one of them will be loaded (and which one depends on mpv internals that may change any time). Likewise, if there is for example , your script will break as soon as mpv adds a backend that uses the file extension. mpv also appends the top level directory of the script to the start of Lua's package path so you can import scripts from there too. Be aware that this will shadow Lua libraries that use the same package path. (Single file scripts do not include mpv specific directories in the Lua package path. This was silently changed in mpv 0.32.0.) Using a script directory is the recommended way to package a script that consists of multiple source files, or requires other files (you can use to get the location and e.g. load data files). Making a script a git repository, basically a repository which contains a file in the root directory, makes scripts easily updateable (without the dangers of auto-updates). Another suggestion is to use git submodules to share common files or libraries. Details on the script initialization and lifecycle Your script will be loaded by the player at program start from the configuration subdirectory, or from a path specified with the option. Some scripts are loaded internally (like ). Each script runs in its own thread. Your script is first run \"as is\", and once that is done, the event loop is entered. This event loop will dispatch events received by mpv and call your own event handlers which you have registered with , or timers added with or similar. Note that since the script starts execution concurrently with player initialization, some properties may not be populated with meaningful values until the relevant subsystems have initialized. When the player quits, all scripts will be asked to terminate. This happens via a event, which by default will make the event loop return. If your script got into an endless loop, mpv will probably behave fine during playback, but it won't terminate when quitting, because it's waiting on your script. Internally, the C code will call the Lua function after loading a Lua script. This function is normally defined by the default prelude loaded before your script (see in the mpv sources). The event loop will wait for events and dispatch events registered with . It will also handle timers added with and similar (by waiting with a timeout). Since mpv 0.6.0, the player will wait until the script is fully loaded before continuing normal operation. The player considers a script as fully loaded as soon as it starts waiting for mpv events (or it exits). In practice this means the player will more or less hang until the script returns from the main chunk (and is called), or the script calls or directly. This is done to make it possible for a script to fully setup event handlers etc. before playback actually starts. In older mpv versions, this happened asynchronously. With mpv 0.29.0, this changes slightly, and it merely waits for scripts to be loaded in this manner before starting playback as part of the player initialization phase. Scripts run though initialization in parallel. This might change again. The module is preloaded, although it can be loaded manually with . It provides the core client API. Run the given command. This is similar to the commands used in input.conf. See List of Input Commands. By default, this will show something on the OSD (depending on the command), as if it was used in . See Input Command Prefixes how to influence OSD usage per command. Returns on success, or on error. Similar to , but pass each command argument as separate parameter. This has the advantage that you don't have to care about quoting and escaping in some cases. These two commands are equivalent, except that the first version breaks if the filename contains spaces or certain special characters. Note that properties are not expanded. You can use either , the prefix, or the family of functions. Unlike , this will not use OSD by default either (except for some OSD-specific commands). Similar to , but pass the argument list as table. This has the advantage that in at least some cases, arguments can be passed as native types. It also allows you to use named argument. If the table is an array, each array item is like an argument in (but can be a native type instead of a string). If the table contains string keys, it's interpreted as command with named arguments. This requires at least an entry with the key to be present, which must be a string, and contains the command name. The special entry is optional, and if present, must be an array of Input Command Prefixes to apply. All other entries are interpreted as arguments. Returns a result table on success (usually empty), or on error. is the second parameter provided to the function, and is nil if it's missing. Like , but the command is ran asynchronously (as far as possible), and upon completion, fn is called. fn has three arguments: : Always a Boolean and is true if the command was successful, otherwise false. The result value (can be nil) in case of success, nil otherwise (as returned by ). The error string in case of an error, nil otherwise. Returns a table with undefined contents, which can be used as argument for . If starting the command failed for some reason, is returned, and is called indicating failure, using the same error value. is always called asynchronously, even if the command failed to start. Abort a call. The argument is the return value of that command (which starts asynchronous execution of the command). Whether this works and how long it takes depends on the command and the situation. The abort call itself is asynchronous. Does not return anything. Delete the given property. See and Properties for more information about properties. Most properties cannot be deleted. Returns true on success, or on error. Return the value of the given property as string. These are the same properties as used in input.conf. See Properties for a list of properties. The returned string is formatted similar to (see Property Expansion). Returns the string on success, or on error. is the second parameter provided to the function, and is nil if it's missing. Similar to , but return the property value formatted for OSD. This is the same string as printed with when used in input.conf. Returns the string on success, or on error. is the second parameter provided to the function, and is an empty string if it's missing. Unlike , assigning the return value to a variable will always result in a string. Similar to , but return the property value as Boolean. Returns a Boolean on success, or on error. Similar to , but return the property value as number. Note that while Lua does not distinguish between integers and floats, mpv internals do. This function simply request a double float from mpv, and mpv will usually convert integer property values to float. Returns a number on success, or on error. Similar to , but return the property value using the best Lua type for the property. Most time, this will return a string, Boolean, or number. Some properties (for example ) are returned as tables. Returns a value on success, or on error. Note that might be a possible, valid value too in some corner cases. Set the given property to the given string value. See and Properties for more information about properties. Returns true on success, or on error. Similar to , but set the given property to the given Boolean value. Similar to , but set the given property to the given numeric value. Note that while Lua does not distinguish between integers and floats, mpv internals do. This function will test whether the number can be represented as integer, and if so, it will pass an integer value to mpv, otherwise a double float. Similar to , but set the given property using its native type. Since there are several data types which cannot represented natively in Lua, this might not always work as expected. For example, while the Lua wrapper can do some guesswork to decide whether a Lua table is an array or a map, this would fail with empty tables. Also, there are not many properties for which it makes sense to use this, instead of , , . For these reasons, this function should probably be avoided for now, except for properties that use tables natively. Return the current mpv internal time in seconds as a number. This is basically the system time, with an arbitrary offset. Register callback to be run on a key binding. The binding will be mapped to the given , which is a string describing the physical key. This uses the same key names as in input.conf, and also allows combinations (e.g. ). If the key is empty or , no physical key is registered, but the user still can create own bindings (see below). After calling this function, key presses will cause the function to be called (unless the user remapped the key with another binding). However, if the key binding is canceled , the function will not be called, unless flag is set to , where the function will be called with the entry set to . For example, a canceled key binding can happen in the following situations:\n• If key A is pressed while key B is being held down, key B is logically released (\"canceled\" by key A), which stops the current autorepeat action key B has.\n• If key A is pressed while a mouse button is being held down, the mouse button is logically released, but the mouse button's action will not be called, unless flag is set to . The argument should be a short symbolic string. It allows the user to remap the key binding via input.conf using the command, and the name of the key binding (see below for an example). The name should be unique across other bindings in the same script - if not, the previous binding with the same name will be overwritten. You can omit the name, in which case a random name is generated internally. (Omitting works as follows: either pass for , or pass the argument in place of the name. The latter is not recommended and is handled for compatibility only.) The last argument is used for optional flags. This is a table, which can have the following entries: If set to , enables key repeat for this specific binding. This option only makes sense when is not set to . If set to , then is called on key down, repeat and up events, with the first argument being a table. This table has the following entries (and may contain undocumented ones): Set to one of the strings , , or (the latter if key up/down/repeat can't be tracked), which indicates the key's logical state. Boolean: Whether the event was caused by a mouse button. Boolean: Whether the event was canceled. Not all types of cancellations set this flag. The name of they key that triggered this, or if invoked artificially. If the key name is unknown, it's an empty string. Text if triggered by a text key, otherwise . See description of command for details (this field is equivalent to the 5th argument). Internally, key bindings are dispatched via the or input commands and . Trying to map multiple commands to a key will essentially prefer a random binding, while the other bindings are not called. It is guaranteed that user defined bindings in the central input.conf are preferred over bindings added with this function (but see ). This will print the message when was pressed. The user can remap these key bindings. Then the user has to put the following into their input.conf to remap the command to the key: This will print the message when the key is pressed. ( will still work, unless the user remaps it.) You can also explicitly send a message to a named script only. Assume the above script was using the filename : This works almost the same as , but registers the key binding in a way that will overwrite the user's custom bindings in their input.conf. ( overwrites default key bindings only, but not those by the user's input.conf.) Remove a key binding added with or . Use the same name as you used when adding the bindings. It's not possible to remove bindings for which you omitted the name. Call a specific function when an event happens. The event name is a string, and the function fn is a Lua function value. Some events have associated data. This is put into a Lua table and passed as argument to fn. The Lua table by default contains a field, which is a string containing the event name. If the event has an error associated, the field is set to a string describing the error, on success it's not set. If multiple functions are registered for the same event, they are run in registration order, which the first registered function running before all the other ones. Returns true if such an event exists, false otherwise. See Events and List of events for details. Undo . This removes all event handlers that are equal to the parameter. This uses normal Lua comparison, so be careful when dealing with closures. Watch a property for changes. If the property is changed, then the function will be called. can be , or be set to one of , , , , or . is the same as . For all other values, the new value of the property will be passed as second argument to , using to retrieve it. This means if is for example , is roughly called as in . If possible, change events are coalesced. If a property is changed a bunch of times in a row, only the last change triggers the change function. (The exact behavior depends on timing and other things.) If a property is unavailable, or on error, the value argument to is . (The call always succeeds, even if a property does not exist.) In some cases the function is not called even if the property changes. This depends on the property, and it's a valid feature request to ask for better update handling of a specific property. If the is or , the change function will be called sporadically even if the property doesn't actually change. You should therefore avoid using these types. You always get an initial change notification. This is meant to initialize the user's state to the current value of the property. Undo . This removes all property handlers that are equal to the parameter. This uses normal Lua comparison, so be careful when dealing with closures. Call the given function fn when the given number of seconds has elapsed. Note that the number of seconds can be fractional. For now, the timer's resolution may be as low as 50 ms, although this will be improved in the future. If the argument is set to or a truthy value, the timer will wait to be manually started with a call to its method. This is a one-shot timer: it will be removed when it's fired. Call the given function periodically. This is like , but the timer is re-added after the function fn is run. Returns a timer object. The timer object provides the following methods: Disable the timer. Does nothing if the timer is already disabled. This will remember the current elapsed time when stopping, so that essentially unpauses the timer. Disable the timer. Resets the elapsed time. will restart the timer. Restart the timer. If the timer was disabled with , this will resume at the time it was stopped. If the timer was disabled with , or if it's a previously fired one-shot timer (added with ), this starts the timer from the beginning, using the initially configured timeout. Whether the timer is currently enabled or was previously disabled (e.g. by or ). This field contains the current timeout period. This value is not updated as time progresses. It's only used to calculate when the timer should fire next when the timer expires. If you write this, you can call to reset the current timeout to the new one. ( won't use the new timeout.) Whether the timer is periodic ( ) or fires just once ( ). This value is used when the timer expires (but before the timer callback function fn is run). Note that these are methods, and you have to call them using instead of (Refer to https://www.lua.org/manual/5.2/manual.html#3.4.9 .) seconds = 0 timer = mp.add_periodic_timer(1, function() print(\"called every second\") # stop it after 10 seconds seconds = seconds + 1 if seconds >= 10 then timer:kill() end end) Return a setting from the option. It's up to the user and the script how this mechanism is used. Currently, all scripts can access this equally, so you should be careful about collisions. Return the name of the current script. The name is usually made of the filename of the script, with directory and file extension removed. If there are several scripts which would have the same name, it's made unique by appending a number. Any nonalphanumeric characters are replaced with . Return the directory if this is a script packaged as directory (see Script location for a description). Return nothing if this is a single file script. Show an OSD message on the screen. is in seconds, and is optional (uses by default). These also live in the module, but are documented separately as they are useful only in special situations. Calls and returns the read end of the wakeup pipe. This is deprecated, but still works. (See for details.) Return the relative time in seconds when the next timer ( and similar) expires. If there is no timer, return . This can be used to run custom event loops. If you want to have direct control what the Lua script does (instead of being called by the default event loop), you can set the global variable to your own function running the event loop. From your event loop, you should call to dequeue and dispatch mpv events. If the parameter is set to , the function will block until the next event is received or the next timer expires. Otherwise (and this is the default behavior), it returns as soon as the event loop is emptied. It's strongly recommended to use and if you're interested in properly working notification of new events and working timers. Register an event loop idle handler. Idle handlers are called before the script goes to sleep after handling all new events. This can be used for example to delay processing of property change events: if you're observing multiple properties at once, you might not want to act on each property change, but only when all change notifications have been received. Undo . This removes all idle handlers that are equal to the parameter. This uses normal Lua comparison, so be careful when dealing with closures. Set the minimum log level of which mpv message output to receive. These messages are normally printed to the terminal. By calling this function, you can set the minimum log level of messages which should be received with the event. See the description of this event for details. The level is a string, see for allowed log levels. This is a helper to dispatch or invocations to Lua functions. is called if or (with this script as destination) is run with as first parameter. The other parameters are passed to . If a message with the given name is already registered, it's overwritten. Used by , so be careful about name collisions. Undo a previous registration with . Does nothing if the wasn't registered. Create an OSD overlay. This is a very thin wrapper around the command. The function returns a table, which mostly contains fields that will be passed to . The parameter is used to initialize the field. The field contains the text to be used as overlay. For details, see the command. In addition, it provides the following methods: Commit the OSD overlay to the screen, or in other words, run the command with the current fields of the overlay table. Returns the result of the command itself. Remove the overlay from the screen. A call will add it again. The advantage of using this wrapper (as opposed to running directly) is that the field is allocated automatically. Returns a tuple of . The first two give the size of the OSD in pixels (for video outputs like , this may be \"scaled\" pixels). The third is the display pixel aspect ratio. May return invalid/nonsense values if OSD is not initialized yet. This module allows outputting messages to the terminal, and can be loaded with . The level parameter is the message priority. It's a string and one of , , , , , , . The user's settings will determine which of these messages will be visible. Normally, all messages are visible, except , and . The parameters after that are all converted to strings. Spaces are inserted to separate multiple parameters. You don't need to add newlines. All of these are shortcuts and equivalent to the corresponding call. mpv comes with a built-in module to manage options from config-files and the command-line. All you have to do is to supply a table with default options to the read_options function. The function will overwrite the default values with values found in the config-file and the command-line (in that order). A with key-value pairs. The type of the default values is important for converting the values read from the config file or command-line back. Do not use as a default value! The is used to identify the config-file and the command-line options. These needs to unique to avoid collisions with other scripts. Defaults to if the parameter is or missing. The parameter enables run-time updates of all matching option values via the option/property. If any of the matching options changes, the values in the (which was originally passed to the function) are changed, and is called. is a table where each updated option has a entry. There is no initial call. This never re-reads the config file. is always applied on the original config file, ignoring previous values (for example, if an option is removed from at runtime, the option will have the value in the config file). entries are only written for option values whose values effectively change (this is important if the script changes entries independently). The config file will be stored in in mpv's user folder. Comment lines can be started with # and stray spaces are not removed. Boolean values will be represented with yes/no. Command-line options are read from the parameter. To avoid collisions, all keys have to be prefixed with . This built-in module provides generic helper functions for Lua, and have strictly speaking nothing to do with mpv or video/audio playback. They are provided for convenience. Most compensate for Lua's scarce standard library. Be warned that any of these functions might disappear any time. They are not strictly part of the guaranteed API. Returns the directory that mpv was launched from. On error, is returned. Enumerate all entries at the given path on the filesystem, and return them as array. Each entry is a directory entry (without the path). The list is unsorted (in whatever order the operating system returns it). If the argument is given, it must be one of the following strings: List regular files only. This excludes directories, special files (like UNIX device files or FIFOs), and dead symlinks. It includes UNIX symlinks to regular files. List directories only, or symlinks to directories. and are not included. Include the results of both and . (This is the default.) List all entries, even device files, dead symlinks, FIFOs, and the and entries. Stats the given path for information and returns a table with the following entries: protection bits (on Windows, always 755 (octal) for directories and 644 (octal) for files) and are integers. Timestamps ( , and ) are integer seconds since the Unix epoch (Unix time). The booleans and are provided as a convenience; they can be and are derived from . On error (e.g. path does not exist), is returned. Split a path into directory component and filename component, and return them. The first return value is always the directory. The second return value is the trailing part of the path, the directory entry. Return the concatenation of the 2 paths. Tries to be clever. For example, if is an absolute path, is returned without change. Runs an external process and waits until it exits. Returns process status and the captured output. This is a legacy wrapper around calling the command with . It does the following things:\n• copy to field if the string is non-empty It is recommended to use or directly, instead of calling this legacy wrapper. It is for compatibility only. See the documentation for semantics and further parameters. Runs an external process and detaches it from mpv's control. The parameter is a table. The function reads the following entries: Array of strings of the same semantics as the used in the function. This is a legacy wrapper around calling the command with and other functions. Returns the process ID of the running mpv process. This can be used to identify the calling mpv when launching (detached) subprocesses. Returns the C environment as a list of strings. (Do not confuse this with the Lua \"environment\", which is an unrelated concept.) Parses the given string argument as JSON, and returns it as a Lua table. On error, returns . (Currently, is just a string reading , because there is no fine-grained error reporting of any kind.) The returned value uses similar conventions as to distinguish empty objects and arrays. If the parameter is (or any value equal to ), then trailing non-whitespace text is tolerated by the function, and the trailing text is returned as 3rd return value. (The 3rd return value is always there, but with set, no error is raised.) Format the given Lua table (or value) as a JSON string and return it. On error, returns . (Errors usually only happen on value types incompatible with JSON.) The argument value uses similar conventions as to distinguish empty objects and arrays. Turn the given value into a string. Formats tables and their contents. This doesn't do anything special; it is only needed because Lua is terrible. This module lets scripts get textual input from the user using the console REPL. Show the console to let the user enter text. The following entries of are read: The string to be displayed before the input field. A callback invoked when the user presses Enter. The first argument is the text in the console. You can close the console from within the callback by calling . If you don't, the console stays open and the user can input more text. A callback invoked when the console is shown. This can be used to present a list of options with . A callback invoked when the text changes. The first argument is the text in the console. A callback invoked when the user presses TAB. The first argument is the text before the cursor. The callback should return a table of the string candidate completion values and the 1-based cursor position from which the completion starts. console.lua will filter the suggestions beginning with the the text between this position and the cursor, sort them alphabetically, insert their longest common prefix, and show them when there are multiple ones. A callback invoked when the console is hidden, either because was invoked from the other callbacks, or because the user closed it with a key binding. The first argument is the text in the console, and the second argument is the cursor position. A string to pre-fill the input field with. An identifier that determines which input history and log buffer to use among the ones stored for calls. The input histories and logs are stored in memory and do not persist across different mpv invocations. Defaults to the calling script name with appended. Add a line to the log buffer. can contain additional ASS tags to apply to , and can contain escape sequences that are used when the console is displayed in the terminal. Helper to add a line to the log buffer with the same color as the one the console uses for errors. Useful when the user submits invalid input. is a table of strings, or tables with , and keys. Specify a list of items that are presented to the user for selection. The user can type part of the desired item and/or navigate them with keybindings: and go down, and go up, and scroll down one page, and and scroll up one page. The following entries of are read: The string to be displayed before the input field. The table of the entries to choose from. The 1-based integer index of the preselected item. The callback invoked when the user presses Enter. The first argument is the 1-based index of the selected item. Unlike with , the console is automatically closed on submit without having to call . Events are notifications from player core to scripts. You can register an event handler with . Note that all scripts (and other parts of the player) receive events equally, and there's no such thing as blocking other scripts from receiving events. For the existing event types, see List of events. This documents experimental features, or features that are \"too special\" to guarantee a stable interface. Add a hook callback for (a string identifying a certain kind of hook). These hooks allow the player to call script functions and wait for their result (normally, the Lua scripting interface is asynchronous from the point of view of the player core). is an arbitrary integer that allows ordering among hooks of the same kind. Using the value 50 is recommended as neutral default value. is the function that will be called during execution of the hook. The parameter passed to it ( ) is a Lua object that can control further aspects about the currently invoked hook. It provides the following methods: Returning from the hook function should not automatically continue the hook. Instead, the API user wants to call on its own at a later point in time (before or after the function has returned). Continue the hook. Doesn't need to be called unless was called. See Hooks for currently existing hooks and what they do - only the hook list is interesting; handling hook execution is done by the Lua script function automatically."
    },
    {
        "link": "https://github.com/mpv-player/mpv/issues/3810",
        "document": "I'm currently trying to hook into _mpv_wait_event from c#.\n\nBut that's a little over my head, especially since I've never worked much with Invokes from c++ dlls\n\nThat's as far as I got so far:\n\nMost of the code is based on the chsharp example, I simply added the event structs of c++\n\n But honestly, I barely have an idea how to convert C++ structs into c# code, so pretty much any help at all is very appreciated.\n\nCrashes with System.AccessViolationException\n\n most likely because my attempt is probably completely wrong."
    },
    {
        "link": "https://ccoderun.ca/programming/doxygen/mpv/client_8h.html",
        "document": "This is in fact implemented using the same underlying code as for mpv_set_wakeup_callback() (though they don't conflict), and it is as if each callback invocation writes a single 0 byte to the pipe. When the pipe becomes readable, the code calling poll() (or select()) on the pipe should read all contents of the pipe and then call mpv_wait_event(c, 0) until no new events are returned. The pipe contents do not matter and can just be discarded. There is not necessarily one byte per readable event in the pipe. For example, the pipes are non-blocking, and mpv won't block if the pipe is full. Pipes are normally limited to 4096 bytes, so if there are more than 4096 events, the number of readable bytes can not equal the number of events queued. Also, it's possible that mpv does not write to the pipe once it's guaranteed that the client was already signaled. See the example below how to do it correctly."
    },
    {
        "link": "https://docs.rs/libmpv-sys-sirno",
        "document": "The end of file was reached. Sometimes this may also happen on incomplete or corrupted files, or if the network connection was interrupted when playing a remote file. It also happens if the playback range was restricted with –end or –frames or similar. Some kind of error happened that lead to playback abort. Does not necessarily happen on incomplete or broken files (in these cases, both MPV_END_FILE_REASON_ERROR or MPV_END_FILE_REASON_EOF are possible). Playback was stopped by the quit command or player shutdown. The file was a playlist or similar. When the playlist is read, its entries will be appended to the playlist after the entry of the current file, the entry of the current file is removed, and a MPV_EVENT_END_FILE event is sent with reason set to MPV_END_FILE_REASON_REDIRECT. Then playback continues with the playlist contents. Since API version 1.18. Playback was stopped by an external action (e.g. playlist controls). General error when running a command with mpv_command and similar. The event ringbuffer is full. This means the client is choked, and can’t receive any events. This can happen when too many asynchronous requests have been made, but not answered. Probably never happens in practice, unless the mpv core is frozen for some reason, and the client keeps making asynchronous requests. (Bugs in the client API implementation could also trigger this, e.g. if events become “lost”.) Generic catch-all error if a parameter is set to an invalid or unsupported value. This is used if there is no better error code. Generic error on loading (usually used with mpv_event_end_file.error). There was no audio or video data to play. This also happens if the file was recognized, but did not contain any audio or video streams, or no streams were selected. The API function which was called is a stub only. Setting the option failed. Typically this happens if the provided option value could not be parsed. Trying to set an option using an unsupported MPV_FORMAT. Trying to set an option that doesn’t exist. Trying to set or get a property using an unsupported MPV_FORMAT. The property exists, but is not available. This usually happens when the associated subsystem is not active, e.g. querying audio parameters while audio is disabled. No error happened (used to signal successful operation). Keep in mind that many API functions returning error codes can also return positive values, which also indicate success. API users can hardcode the fact that “>= 0” means success. The mpv core wasn’t configured and initialized yet. See the notes in mpv_create(). When trying to load the file, the file format could not be determined, or the file was too broken to open it. Generic error for signaling that certain system requirements are not fulfilled. Similar to MPV_EVENT_VIDEO_RECONFIG. This is relatively uninteresting, because there is no such thing as audio output embedding. Triggered by the script-message input command. The command uses the first argument of the command as client name (see mpv_client_name()) to dispatch the message, and passes along all arguments starting from the second argument as strings. See also mpv_event and mpv_event_client_message. Reply to a mpv_command_async() or mpv_command_node_async() request. See also mpv_event and mpv_event_command. Notification after playback end (after the file was unloaded). See also mpv_event and mpv_event_end_file. Notification when the file has been loaded (headers were read etc.), and decoding starts. Reply to a mpv_get_property_async() request. See also mpv_event and mpv_event_property. Triggered if a hook handler was registered with mpv_hook_add(), and the hook is invoked. If you receive this, you must handle it, and continue the hook with mpv_hook_continue(). See also mpv_event and mpv_event_hook. Idle mode was entered. In this mode, no file is played, and the playback core waits for new commands. (The command line player normally quits instead of entering idle mode, unless –idle was specified. If mpv was started with mpv_create(), idle mode is enabled by default.) Nothing happened. Happens on timeouts or sporadic wakeups. There was a discontinuity of some sort (like a seek), and playback was reinitialized. Usually happens on start of playback and after seeking. The main purpose is allowing the client to detect when a seek request is finished. Event sent due to mpv_observe_property(). See also mpv_event and mpv_event_property. Happens if the internal per-mpv_handle ringbuffer overflows, and at least 1 event had to be dropped. This can happen if the client doesn’t read the event queue quickly enough with mpv_wait_event(), or if the client makes a very large number of asynchronous calls at once. Happens when a seek was initiated. Playback stops. Usually it will resume with MPV_EVENT_PLAYBACK_RESTART as soon as the seek is finished. Reply to a mpv_set_property_async() request. (Unlike MPV_EVENT_GET_PROPERTY, mpv_event_property is not used.) Happens when the player quits. The player enters a state where it tries to disconnect all clients. Most requests to the player will fail, and the client should react to this and quit with mpv_destroy() as soon as possible. Notification before playback start of a file (before the file is loaded). See also mpv_event and mpv_event_start_file. Sent every time after a video frame is displayed. Note that currently, this will be sent in lower frequency if there is no video, or playback is paused - but that will be removed in the future, and it will be restricted to video frames only. Happens after video changed in some way. This can happen on resolution changes, pixel format changes, or video filter changes. The event is sent after the video filters and the VO are reconfigured. Applications embedding a mpv window should listen to this event in order to resize the window if needed. Note that this event can happen sporadically, and you should check yourself whether the video parameters really changed before doing something expensive. A raw, untyped byte array. Only used only with mpv_node, and only in some very specific situations. (Some commands use it.) The basic type is int. The only allowed values are 0 (“no”) and 1 (“yes”). Used with mpv_node only. Can usually not be used directly. Invalid. Sometimes used for empty values. This is always defined to 0, so a normal 0-init of mpv_format (or e.g. mpv_node) is guaranteed to set this it to MPV_FORMAT_NONE (which makes some things saner as consequence). The basic type is char*. It returns the OSD property string, like using ${property} in input.conf (see input.rst). In many cases, this is the same as the raw string, but in other cases it’s formatted for display on OSD. It’s intended to be human readable. Do not attempt to parse these strings. The basic type is char*. It returns the raw property string, like using ${=property} in input.conf (see input.rst). If set, the player timing code expects that the user thread blocks on vsync (by either delaying the render call, or by making a call to mpv_render_context_report_swap() at vsync time). Set if there is actually a next frame. If unset, there is no next frame yet, and other flags and fields that require a frame to be queued will be unset. If set, the frame is not an actual new video frame, but a redraw request. For example if the video is paused, and an option that affects video rendering was changed (or any other reason), an update request can be issued and this flag will be set. If set, this is supposed to reproduce the previous frame perfectly. This is usually used for certain “video-sync” options (“display-…” modes). Typically the renderer will blit the video from a FBO. Unset otherwise. Better control about rendering and enabling some advanced features. Valid for mpv_render_context_create(). Ambient light in lux. Valid for mpv_render_context_set_parameter(). Type: int* This can be used for automatic gamma correction. The render API to use. Valid for mpv_render_context_create(). Control surface depth. Valid for mpv_render_context_render(). Type: int* This implies the depth of the surface passed to the render function in bits per channel. If omitted or set to 0, the renderer will assume 8. Typically used to control dithering. Deprecated. Not supported. Use MPV_RENDER_PARAM_DRM_DISPLAY_V2 instead. Type : struct mpv_opengl_drm_params* Control flipped rendering. Valid for mpv_render_context_render(). Type: int* If the value is set to 0, render normally. Otherwise, render it flipped, which is needed e.g. when rendering to an OpenGL default framebuffer (which has a flipped coordinate system). ICC profile blob. Valid for mpv_render_context_set_parameter(). Type: mpv_byte_array* Set an ICC profile for use with the “icc-profile-auto” option. (If the option is not enabled, the ICC data will not be used.) Not a valid value, but also used to terminate a params array. Its value is always guaranteed to be 0 (even if the ABI changes in the future). Return information about the next frame to render. Valid for mpv_render_context_get_info(). Required parameters for initializing the OpenGL renderer. Valid for mpv_render_context_create(). Type: mpv_opengl_init_params* Use to skip rendering in mpv_render_context_render(). MPV_RENDER_API_TYPE_SW only: rendering target surface bytes per line, mandatory. Valid for MPV_RENDER_API_TYPE_SW & mpv_render_context_render(). Type: size_t* MPV_RENDER_API_TYPE_SW only: rendering target surface bytes per line, mandatory. Valid for MPV_RENDER_API_TYPE_SW & mpv_render_context_render(). Type: size_t* Wayland display, sometimes used for hwdec. Valid for mpv_render_context_create(). The wl_display must stay valid for the lifetime of the mpv_render_context. Type: struct wl_display* X11 Display, sometimes used for hwdec. Valid for mpv_render_context_create(). The Display must stay valid for the lifetime of the mpv_render_context. Type: Display* A new video frame must be rendered. mpv_render_context_render() must be called.\n\nSignal to all async requests with the matching ID to abort. This affects the following API calls: Return the MPV_CLIENT_API_VERSION the mpv source has been compiled with. Return the ID of this client handle. Every client has its own unique ID. This ID is never reused by the core, even if the mpv_handle at hand gets destroyed and new handles get allocated. Return the name of this client handle. Every client has its own unique name, which is mostly used for user interface purposes. Send a command to the player. Commands are the same as those used in input.conf, except that this function takes parameters in a pre-split form. Same as mpv_command, but run the command asynchronously. Same as mpv_command(), but allows passing structured data in any format. In particular, calling mpv_command() is exactly like calling mpv_command_node() with the format set to MPV_FORMAT_NODE_ARRAY, and every arg passed in order as MPV_FORMAT_STRING. Same as mpv_command_node(), but run it asynchronously. Basically, this function is to mpv_command_node() what mpv_command_async() is to mpv_command(). This is essentially identical to mpv_command() but it also returns a result. Same as mpv_command, but use input.conf parsing for splitting arguments. This is slightly simpler, but also more error prone, since arguments may need quoting/escaping. Create a new mpv instance and an associated client API handle to control the mpv instance. This instance is in a pre-initialized state, and needs to be initialized to be actually used with most other API functions. Create a new client handle connected to the same player core as ctx. This context has its own event queue, its own mpv_request_event() state, its own mpv_request_log_messages() state, its own set of observed properties, and its own state for asynchronous operations. Otherwise, everything is shared. This is the same as mpv_create_client(), but the created mpv_handle is treated as a weak reference. If all mpv_handles referencing a core are weak references, the core is automatically destroyed. (This still goes through normal uninit of course. Effectively, if the last non-weak mpv_handle is destroyed, then the weak mpv_handles receive MPV_EVENT_SHUTDOWN and are asked to terminate as well.) Disconnect and destroy the mpv_handle. ctx will be deallocated with this API call. Return a string describing the error. For unknown errors, the string “unknown error” is returned. Return a string describing the event. For unknown events, NULL is returned. Convert the given src event to a mpv_node, and set *dst to the result. dst is set to a MPV_FORMAT_NODE_MAP, with fields for corresponding mpv_event and mpv_event.data/mpv_event_ fields. General function to deallocate memory returned by some of the API functions. Call this only if it’s explicitly documented as allowed. Calling this on mpv memory not owned by the caller will lead to undefined behavior. Frees any data referenced by the node. It doesn’t free the node itself. Call this only if the mpv client API set the node. If you constructed the node yourself (manually), you have to free it yourself. Read the value of the given property. Get a property asynchronously. You will receive the result of the operation as well as the property data with the MPV_EVENT_GET_PROPERTY_REPLY event. You should check the mpv_event.error field on the reply event. Return the property as “OSD” formatted string. This is the same as mpv_get_property_string, but using MPV_FORMAT_OSD_STRING. Return the value of the property with the given name as string. This is equivalent to mpv_get_property() with MPV_FORMAT_STRING. Return the internal time in microseconds. This has an arbitrary start offset, but will never wrap or go backwards. Return a UNIX file descriptor referring to the read end of a pipe. This pipe can be used to wake up a poll() based processing loop. The purpose of this function is very similar to mpv_set_wakeup_callback(), and provides a primitive mechanism to handle coordinating a foreign event loop and the libmpv event loop. The pipe is non-blocking. It’s closed when the mpv_handle is destroyed. This function always returns the same value (on success). A hook is like a synchronous event that blocks the player. You register a hook handler with this function. You will get an event, which you need to handle, and once things are ready, you can let the player continue with mpv_hook_continue(). Respond to a MPV_EVENT_HOOK event. You must call this after you have handled the event. There is no way to “cancel” or “stop” the hook. Initialize an uninitialized mpv instance. If the mpv instance is already running, an error is returned. Load a config file. This loads and parses the file, and sets every entry in the config file’s default section as if mpv_set_option_string() is called. Get a notification whenever the given property changes. You will receive updates as MPV_EVENT_PROPERTY_CHANGE. Note that this is not very precise: for some properties, it may not send updates even if the property changed. This depends on the property, and it’s a valid feature request to ask for better update handling of a specific property. (For some properties, like , which shows the wall clock, this mechanism doesn’t make too much sense anyway.) Initialize the renderer state. Depending on the backend used, this will access the underlying GPU API and initialize its own objects. Retrieve information from the render context. This is NOT a counterpart to mpv_render_context_set_parameter(), because you generally can’t read parameters set with it, and this function is not meant for this purpose. Instead, this is for communicating information from the renderer back to the user. See mpv_render_param_type; entries which support this function explicitly mention it, and for other entries you can assume it will fail. Tell the renderer that a frame was flipped at the given time. This is optional, but can help the player to achieve better timing. Attempt to change a single parameter. Not all backends and parameter types support all kinds of changes. Set the callback that notifies you when a new video frame is available, or if the video display configuration somehow changed and requires a redraw. Similar to mpv_set_wakeup_callback(), you must not call any mpv API from the callback, and all the other listed restrictions apply (such as not exiting the callback by throwing exceptions). The API user is supposed to call this when the update callback was invoked (like all mpv_render_* functions, this has to happen on the render thread, and not from the update callback itself). Enable or disable the given event. Enable or disable receiving of log messages. These are the messages the command line player prints to the terminal. This call sets the minimum required log level for a message to be received with MPV_EVENT_LOG_MESSAGE. Set an option. Note that you can’t normally set options during runtime. It works in uninitialized state (see mpv_create()), and in some cases in at runtime. Convenience function to set an option to a string value. This is like calling mpv_set_option() with MPV_FORMAT_STRING. Set a property to a given value. Properties are essentially variables which can be queried or set at runtime. For example, writing to the pause property will actually pause or unpause playback. Set a property asynchronously. You will receive the result of the operation as MPV_EVENT_SET_PROPERTY_REPLY event. The mpv_event.error field will contain the result status of the operation. Otherwise, this function is similar to mpv_set_property(). Convenience function to set a property to a string value. Set a custom function that should be called when there are new events. Use this if blocking in mpv_wait_event() to wait for new events is not feasible. Add a custom stream protocol. This will register a protocol handler under the given protocol prefix, and invoke the given callbacks if an URI with the matching protocol prefix is opened. Similar to mpv_destroy(), but brings the player and all clients down as well, and waits until all of them are destroyed. This function blocks. The advantage over mpv_destroy() is that while mpv_destroy() merely detaches the client handle from the player, this function quits the player, waits until all other clients are destroyed (i.e. all mpv_handles are detached), and also waits for the final termination of the player. Undo mpv_observe_property(). This will remove all observed properties for which the given number was passed as reply_userdata to mpv_observe_property. Block until all asynchronous requests are done. This affects functions like mpv_command_async(), which return immediately and return their result as events. Wait for the next event, or until the timeout expires, or if another thread makes a call to mpv_wakeup(). Passing 0 as timeout will never wait, and is suitable for polling. Interrupt the current mpv_wait_event() call. This will wake up the thread currently waiting in mpv_wait_event(). If no thread is waiting, the next mpv_wait_event() call will return immediately (this is to avoid lost wakeups).\n\nList of error codes than can be returned by API functions. 0 and positive return values always mean success, negative values are always errors. Data format for options and properties. The API functions to get/set properties and options support multiple formats, and this enum describes them. Numeric log levels. The lower the number, the more important the message is. MPV_LOG_LEVEL_NONE is never used when receiving messages. The string in the comment after the value is the name of the log level as used for the mpv_request_log_messages() function. Unused numeric values are unused, but reserved for future use. Flags used in mpv_render_frame_info.flags. Each value represents a bit in it. Parameters for mpv_render_param (which is used in a few places such as mpv_render_context_create(). Flags returned by mpv_render_context_update(). Each value represents a bit in the function’s return value. Open callback used to implement a custom read-only (ro) stream. The user must set the callback fields in the passed info struct. The cookie field also can be set to store state associated to the stream instance. Read callback used to implement a custom stream. The semantics of the callback match read(2) in blocking mode. Short reads are allowed (you can return less bytes than requested, and libmpv will retry reading the rest with another call). If no data can be immediately read, the callback must block until there is new data. A return of 0 will be interpreted as final EOF, although libmpv might retry the read, or seek to a different position."
    }
]