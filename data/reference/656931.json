[
    {
        "link": "https://nodejs.org/api/modules.html",
        "document": "CommonJS modules are the original way to package JavaScript code for Node.js. Node.js also supports the ECMAScript modules standard used by browsers and other JavaScript runtimes.\n\nIn Node.js, each file is treated as a separate module. For example, consider a file named :\n\nOn the first line, loads the module that is in the same directory as .\n\nHere are the contents of :\n\nThe module has exported the functions and . Functions and objects are added to the root of a module by specifying additional properties on the special object.\n\nVariables local to the module will be private, because the module is wrapped in a function by Node.js (see module wrapper). In this example, the variable is private to .\n\nThe property can be assigned a new value (such as a function or object).\n\nIn the following code, makes use of the module, which exports a Square class:\n\nThe module is defined in :\n\nThe CommonJS module system is implemented in the core module.\n\nThe semantics of the Node.js function were designed to be general enough to support reasonable directory structures. Package manager programs such as , , and will hopefully find it possible to build native packages from Node.js modules without modification. In the following, we give a suggested directory structure that could work: Let's say that we wanted to have the folder at hold the contents of a specific version of a package. Packages can depend on one another. In order to install package , it may be necessary to install a specific version of package . The package may itself have dependencies, and in some cases, these may even collide or form cyclic dependencies. Because Node.js looks up the of any modules it loads (that is, it resolves symlinks) and then looks for their dependencies in folders, this situation can be resolved with the following architecture:\n• : Contents of the package that depends on.\n• : Symbolic links to the packages that depends on. Thus, even if a cycle is encountered, or if there are dependency conflicts, every module will be able to get a version of its dependency that it can use. When the code in the package does , it will get the version that is symlinked into . Then, when the code in the package calls , it'll get the version that is symlinked into . Furthermore, to make the module lookup process even more optimal, rather than putting packages directly in , we could put them in . Then Node.js will not bother looking for missing dependencies in or . In order to make modules available to the Node.js REPL, it might be useful to also add the folder to the environment variable. Since the module lookups using folders are all relative, and based on the real path of the files making the calls to , the packages themselves can be anywhere.\n\nThis feature no longer emits an experimental warning by default, though the warning can still be emitted by --trace-require-module. This feature is no longer behind the CLI flag. The extension is reserved for ECMAScript Modules. See Determining module system section for more info regarding which files are parsed as ECMAScript modules. only supports loading ECMAScript modules that meet the following requirements:\n• The module is fully synchronous (contains no top-level ); and\n• One of these conditions are met:\n• The file has a extension, and the closest contains\n• The file has a extension, the closest does not contain , and the module contains ES module syntax. If the ES Module being loaded meets the requirements, can load it and return the module namespace object. In this case it is similar to dynamic but is run synchronously and returns the name space object directly. With the following ES Modules: A CommonJS module can load them with : For interoperability with existing tools that convert ES Modules into CommonJS, which could then load real ES Modules through , the returned namespace would contain a property if it has a export so that consuming code generated by tools can recognize the default exports in real ES Modules. If the namespace already defines , this would not be added. This property is experimental and can change in the future. It should only be used by tools converting ES modules into CommonJS modules, following existing ecosystem conventions. Code authored directly in CommonJS should avoid depending on it. When an ES Module contains both named exports and a default export, the result returned by is the module namespace object, which places the default export in the property, similar to the results returned by . To customize what should be returned by directly, the ES Module can export the desired value using the string name . Notice in the example above, when the export name is used, named exports will be lost to CommonJS consumers. To allow CommonJS consumers to continue accessing named exports, the module can make sure that the default export is an object with the named exports attached to it as properties. For example with the example above, can be attached to the default export, the class, as a static method. If the module being 'd contains top-level , or the module graph it s contains top-level , will be thrown. In this case, users should load the asynchronous module using . If is enabled, instead of throwing before evaluation, Node.js will evaluate the module, try to locate the top-level awaits, and print their location to help users fix them. Support for loading ES modules using is currently experimental and can be disabled using . To print where this feature is used, use . This feature can be detected by checking if is .\n\nTo get the exact filename that will be loaded when is called, use the function. Putting together all of the above, here is the high-level algorithm in pseudocode of what does: require(X) from module at path Y 1. If X is a core module, a. return the core module b. STOP 2. If X begins with '/' a. set Y to the file system root 3. If X begins with './' or '/' or '../' a. LOAD_AS_FILE(Y + X) b. LOAD_AS_DIRECTORY(Y + X) c. THROW \"not found\" 4. If X begins with '#' a. LOAD_PACKAGE_IMPORTS(X, dirname(Y)) 5. LOAD_PACKAGE_SELF(X, dirname(Y)) 6. LOAD_NODE_MODULES(X, dirname(Y)) 7. THROW \"not found\" MAYBE_DETECT_AND_LOAD(X) 1. If X parses as a CommonJS module, load X as a CommonJS module. STOP. 2. Else, if the source code of X can be parsed as ECMAScript module using <a href=\"esm.md#resolver-algorithm-specification\">DETECT_MODULE_SYNTAX defined in the ESM resolver</a>, a. Load X as an ECMAScript module. STOP. 3. THROW the SyntaxError from attempting to parse X as CommonJS in 1. STOP. LOAD_AS_FILE(X) 1. If X is a file, load X as its file extension format. STOP 2. If X.js is a file, a. Find the closest package scope SCOPE to X. b. If no scope was found 1. MAYBE_DETECT_AND_LOAD(X.js) c. If the SCOPE/package.json contains \"type\" field, 1. If the \"type\" field is \"module\", load X.js as an ECMAScript module. STOP. 2. If the \"type\" field is \"commonjs\", load X.js as a CommonJS module. STOP. d. MAYBE_DETECT_AND_LOAD(X.js) 3. If X.json is a file, load X.json to a JavaScript Object. STOP 4. If X.node is a file, load X.node as binary addon. STOP LOAD_INDEX(X) 1. If X/index.js is a file a. Find the closest package scope SCOPE to X. b. If no scope was found, load X/index.js as a CommonJS module. STOP. c. If the SCOPE/package.json contains \"type\" field, 1. If the \"type\" field is \"module\", load X/index.js as an ECMAScript module. STOP. 2. Else, load X/index.js as a CommonJS module. STOP. 2. If X/index.json is a file, parse X/index.json to a JavaScript object. STOP 3. If X/index.node is a file, load X/index.node as binary addon. STOP LOAD_AS_DIRECTORY(X) 1. If X/package.json is a file, a. Parse X/package.json, and look for \"main\" field. b. If \"main\" is a falsy value, GOTO 2. c. let M = X + (json main field) d. LOAD_AS_FILE(M) e. LOAD_INDEX(M) f. LOAD_INDEX(X) DEPRECATED g. THROW \"not found\" 2. LOAD_INDEX(X) LOAD_NODE_MODULES(X, START) 1. let DIRS = NODE_MODULES_PATHS(START) 2. for each DIR in DIRS: a. LOAD_PACKAGE_EXPORTS(X, DIR) b. LOAD_AS_FILE(DIR/X) c. LOAD_AS_DIRECTORY(DIR/X) NODE_MODULES_PATHS(START) 1. let PARTS = path split(START) 2. let I = count of PARTS - 1 3. let DIRS = [] 4. while I >= 0, a. if PARTS[I] = \"node_modules\", GOTO d. b. DIR = path join(PARTS[0 .. I] + \"node_modules\") c. DIRS = DIR + DIRS d. let I = I - 1 5. return DIRS + GLOBAL_FOLDERS LOAD_PACKAGE_IMPORTS(X, DIR) 1. Find the closest package scope SCOPE to DIR. 2. If no scope was found, return. 3. If the SCOPE/package.json \"imports\" is null or undefined, return. 4. If `--experimental-require-module` is enabled a. let CONDITIONS = [\"node\", \"require\", \"module-sync\"] b. Else, let CONDITIONS = [\"node\", \"require\"] 5. let MATCH = PACKAGE_IMPORTS_RESOLVE(X, pathToFileURL(SCOPE), CONDITIONS) <a href=\"esm.md#resolver-algorithm-specification\">defined in the ESM resolver</a>. 6. RESOLVE_ESM_MATCH(MATCH). LOAD_PACKAGE_EXPORTS(X, DIR) 1. Try to interpret X as a combination of NAME and SUBPATH where the name may have a @scope/ prefix and the subpath begins with a slash (`/`). 2. If X does not match this pattern or DIR/NAME/package.json is not a file, return. 3. Parse DIR/NAME/package.json, and look for \"exports\" field. 4. If \"exports\" is null or undefined, return. 5. If `--experimental-require-module` is enabled a. let CONDITIONS = [\"node\", \"require\", \"module-sync\"] b. Else, let CONDITIONS = [\"node\", \"require\"] 6. let MATCH = PACKAGE_EXPORTS_RESOLVE(pathToFileURL(DIR/NAME), \".\" + SUBPATH, `package.json` \"exports\", CONDITIONS) <a href=\"esm.md#resolver-algorithm-specification\">defined in the ESM resolver</a>. 7. RESOLVE_ESM_MATCH(MATCH) LOAD_PACKAGE_SELF(X, DIR) 1. Find the closest package scope SCOPE to DIR. 2. If no scope was found, return. 3. If the SCOPE/package.json \"exports\" is null or undefined, return. 4. If the SCOPE/package.json \"name\" is not the first segment of X, return. 5. let MATCH = PACKAGE_EXPORTS_RESOLVE(pathToFileURL(SCOPE), \".\" + X.slice(\"name\".length), `package.json` \"exports\", [\"node\", \"require\"]) <a href=\"esm.md#resolver-algorithm-specification\">defined in the ESM resolver</a>. 6. RESOLVE_ESM_MATCH(MATCH) RESOLVE_ESM_MATCH(MATCH) 1. let RESOLVED_PATH = fileURLToPath(MATCH) 2. If the file at RESOLVED_PATH exists, load RESOLVED_PATH as its extension format. STOP 3. THROW \"not found\"\n\nModules are cached after the first time they are loaded. This means (among other things) that every call to will get exactly the same object returned, if it would resolve to the same file. Provided is not modified, multiple calls to will not cause the module code to be executed multiple times. This is an important feature. With it, \"partially done\" objects can be returned, thus allowing transitive dependencies to be loaded even when they would cause cycles. To have a module execute code multiple times, export a function, and call that function. Modules are cached based on their resolved filename. Since modules may resolve to a different filename based on the location of the calling module (loading from folders), it is not a guarantee that will always return the exact same object, if it would resolve to different files. Additionally, on case-insensitive file systems or operating systems, different resolved filenames can point to the same file, but the cache will still treat them as different modules and will reload the file multiple times. For example, and return two different objects, irrespective of whether or not and are the same file.\n\nNode.js has several modules compiled into the binary. These modules are described in greater detail elsewhere in this documentation. The built-in modules are defined within the Node.js source and are located in the folder. Built-in modules can be identified using the prefix, in which case it bypasses the cache. For instance, will always return the built in HTTP module, even if there is entry by that name. Some built-in modules are always preferentially loaded if their identifier is passed to . For instance, will always return the built-in HTTP module, even if there is a file by that name. The list of all the built-in modules can be retrieved from . The modules being all listed without the prefix, except those that mandate such prefix (as explained in the next section). When being loaded by , some built-in modules must be requested with the prefix. This requirement exists to prevent newly introduced built-in modules from having a conflict with user land packages that already have taken the name. Currently the built-in modules that requires the prefix are: The list of these modules is exposed in , including the prefix.\n\nThe directory name of the current module. This is the same as the of the . The file name of the current module. This is the current module file's absolute path with symlinks resolved. For a main program this is not necessarily the same as the file name used in the command line. See for the directory name of the current module. Given two modules: and , where is a dependency of and there is a directory structure of: References to within will return while references to within will return . A reference to the that is shorter to type. See the section about the exports shortcut for details on when to use and when to use . A reference to the current module, see the section about the object. In particular, is used for defining what a module exports and makes available through . Used to import modules, , and local files. Modules can be imported from . Local modules and JSON files can be imported using a relative path (e.g. , , , ) that will be resolved against the directory named by (if defined) or the current working directory. The relative paths of POSIX style are resolved in an OS independent fashion, meaning that the examples above will work on Windows in the same way they would on Unix systems. Modules are cached in this object when they are required. By deleting a key value from this object, the next will reload the module. This does not apply to native addons, for which reloading will result in an error. Adding or replacing entries is also possible. This cache is checked before built-in modules and if a name matching a built-in module is added to the cache, only -prefixed require calls are going to receive the built-in module. Use with care! Instruct on how to handle certain file extensions. Process files with the extension as : Deprecated. In the past, this list has been used to load non-JavaScript modules into Node.js by compiling them on-demand. However, in practice, there are much better ways to do this, such as loading modules via some other Node.js program, or compiling them to JavaScript ahead of time. Avoid using . Use could cause subtle bugs and resolving the extensions gets slower with each registered extension. The object representing the entry script loaded when the Node.js process launched, or if the entry point of the program is not a CommonJS module. See \"Accessing the main module\". The option is now supported.\n• <Object>\n• <string[]> Paths to resolve module location from. If present, these paths are used instead of the default resolution paths, with the exception of GLOBAL_FOLDERS like , which are always included. Each of these paths is used as a starting point for the module resolution algorithm, meaning that the hierarchy is checked from this location. Use the internal machinery to look up the location of a module, but rather than loading the module, just return the resolved filename. If the module can not be found, a error is thrown.\n• <string> The module path whose lookup paths are being retrieved. Returns an array containing the paths searched during resolution of or if the string references a core module, for example or .\n\nIn each module, the free variable is a reference to the object representing the current module. For convenience, is also accessible via the module-global. is not actually a global but rather local to each module. The module objects required for the first time by this one. The object is created by the system. Sometimes this is not acceptable; many want their module to be an instance of some class. To do this, assign the desired export object to . Assigning the desired object to will simply rebind the local variable, which is probably not what is desired. For example, suppose we were making a module called : Then in another file we could do: Assignment to must be done immediately. It cannot be done in any callbacks. This does not work: The variable is available within a module's file-level scope, and is assigned the value of before the module is evaluated. It allows a shortcut, so that can be written more succinctly as . However, be aware that like any variable, if a new value is assigned to , it is no longer bound to : When the property is being completely replaced by a new object, it is common to also reassign : To illustrate the behavior, imagine this hypothetical implementation of , which is quite similar to what is actually done by : The fully resolved filename of the module. The identifier for the module. Typically this is the fully resolved filename.\n• Type: <boolean> if the module is running during the Node.js preload phase. Whether or not the module is done loading, or is in the process of loading. - Deprecated: Please use - Deprecated: Please use Stability: 0 - Deprecated: Please use and instead. The module that first required this one, or if the current module is the entry point of the current process, or if the module was loaded by something that is not a CommonJS module (E.G.: REPL or ). The directory name of the module. This is usually the same as the of the . The search paths for the module. The method provides a way to load a module as if was called from the original module. In order to do this, it is necessary to get a reference to the object. Since returns the , and the is typically only available within a specific module's code, it must be explicitly exported in order to be used."
    },
    {
        "link": "https://nodejs.org/docs/latest/api/modules.html",
        "document": "CommonJS modules are the original way to package JavaScript code for Node.js. Node.js also supports the ECMAScript modules standard used by browsers and other JavaScript runtimes.\n\nIn Node.js, each file is treated as a separate module. For example, consider a file named :\n\nOn the first line, loads the module that is in the same directory as .\n\nHere are the contents of :\n\nThe module has exported the functions and . Functions and objects are added to the root of a module by specifying additional properties on the special object.\n\nVariables local to the module will be private, because the module is wrapped in a function by Node.js (see module wrapper). In this example, the variable is private to .\n\nThe property can be assigned a new value (such as a function or object).\n\nIn the following code, makes use of the module, which exports a Square class:\n\nThe module is defined in :\n\nThe CommonJS module system is implemented in the core module.\n\nThe semantics of the Node.js function were designed to be general enough to support reasonable directory structures. Package manager programs such as , , and will hopefully find it possible to build native packages from Node.js modules without modification. In the following, we give a suggested directory structure that could work: Let's say that we wanted to have the folder at hold the contents of a specific version of a package. Packages can depend on one another. In order to install package , it may be necessary to install a specific version of package . The package may itself have dependencies, and in some cases, these may even collide or form cyclic dependencies. Because Node.js looks up the of any modules it loads (that is, it resolves symlinks) and then looks for their dependencies in folders, this situation can be resolved with the following architecture:\n• : Contents of the package that depends on.\n• : Symbolic links to the packages that depends on. Thus, even if a cycle is encountered, or if there are dependency conflicts, every module will be able to get a version of its dependency that it can use. When the code in the package does , it will get the version that is symlinked into . Then, when the code in the package calls , it'll get the version that is symlinked into . Furthermore, to make the module lookup process even more optimal, rather than putting packages directly in , we could put them in . Then Node.js will not bother looking for missing dependencies in or . In order to make modules available to the Node.js REPL, it might be useful to also add the folder to the environment variable. Since the module lookups using folders are all relative, and based on the real path of the files making the calls to , the packages themselves can be anywhere.\n\nThis feature no longer emits an experimental warning by default, though the warning can still be emitted by --trace-require-module. This feature is no longer behind the CLI flag. The extension is reserved for ECMAScript Modules. See Determining module system section for more info regarding which files are parsed as ECMAScript modules. only supports loading ECMAScript modules that meet the following requirements:\n• The module is fully synchronous (contains no top-level ); and\n• One of these conditions are met:\n• The file has a extension, and the closest contains\n• The file has a extension, the closest does not contain , and the module contains ES module syntax. If the ES Module being loaded meets the requirements, can load it and return the module namespace object. In this case it is similar to dynamic but is run synchronously and returns the name space object directly. With the following ES Modules: A CommonJS module can load them with : For interoperability with existing tools that convert ES Modules into CommonJS, which could then load real ES Modules through , the returned namespace would contain a property if it has a export so that consuming code generated by tools can recognize the default exports in real ES Modules. If the namespace already defines , this would not be added. This property is experimental and can change in the future. It should only be used by tools converting ES modules into CommonJS modules, following existing ecosystem conventions. Code authored directly in CommonJS should avoid depending on it. When an ES Module contains both named exports and a default export, the result returned by is the module namespace object, which places the default export in the property, similar to the results returned by . To customize what should be returned by directly, the ES Module can export the desired value using the string name . Notice in the example above, when the export name is used, named exports will be lost to CommonJS consumers. To allow CommonJS consumers to continue accessing named exports, the module can make sure that the default export is an object with the named exports attached to it as properties. For example with the example above, can be attached to the default export, the class, as a static method. If the module being 'd contains top-level , or the module graph it s contains top-level , will be thrown. In this case, users should load the asynchronous module using . If is enabled, instead of throwing before evaluation, Node.js will evaluate the module, try to locate the top-level awaits, and print their location to help users fix them. Support for loading ES modules using is currently experimental and can be disabled using . To print where this feature is used, use . This feature can be detected by checking if is .\n\nTo get the exact filename that will be loaded when is called, use the function. Putting together all of the above, here is the high-level algorithm in pseudocode of what does: require(X) from module at path Y 1. If X is a core module, a. return the core module b. STOP 2. If X begins with '/' a. set Y to the file system root 3. If X begins with './' or '/' or '../' a. LOAD_AS_FILE(Y + X) b. LOAD_AS_DIRECTORY(Y + X) c. THROW \"not found\" 4. If X begins with '#' a. LOAD_PACKAGE_IMPORTS(X, dirname(Y)) 5. LOAD_PACKAGE_SELF(X, dirname(Y)) 6. LOAD_NODE_MODULES(X, dirname(Y)) 7. THROW \"not found\" MAYBE_DETECT_AND_LOAD(X) 1. If X parses as a CommonJS module, load X as a CommonJS module. STOP. 2. Else, if the source code of X can be parsed as ECMAScript module using <a href=\"esm.md#resolver-algorithm-specification\">DETECT_MODULE_SYNTAX defined in the ESM resolver</a>, a. Load X as an ECMAScript module. STOP. 3. THROW the SyntaxError from attempting to parse X as CommonJS in 1. STOP. LOAD_AS_FILE(X) 1. If X is a file, load X as its file extension format. STOP 2. If X.js is a file, a. Find the closest package scope SCOPE to X. b. If no scope was found 1. MAYBE_DETECT_AND_LOAD(X.js) c. If the SCOPE/package.json contains \"type\" field, 1. If the \"type\" field is \"module\", load X.js as an ECMAScript module. STOP. 2. If the \"type\" field is \"commonjs\", load X.js as a CommonJS module. STOP. d. MAYBE_DETECT_AND_LOAD(X.js) 3. If X.json is a file, load X.json to a JavaScript Object. STOP 4. If X.node is a file, load X.node as binary addon. STOP LOAD_INDEX(X) 1. If X/index.js is a file a. Find the closest package scope SCOPE to X. b. If no scope was found, load X/index.js as a CommonJS module. STOP. c. If the SCOPE/package.json contains \"type\" field, 1. If the \"type\" field is \"module\", load X/index.js as an ECMAScript module. STOP. 2. Else, load X/index.js as a CommonJS module. STOP. 2. If X/index.json is a file, parse X/index.json to a JavaScript object. STOP 3. If X/index.node is a file, load X/index.node as binary addon. STOP LOAD_AS_DIRECTORY(X) 1. If X/package.json is a file, a. Parse X/package.json, and look for \"main\" field. b. If \"main\" is a falsy value, GOTO 2. c. let M = X + (json main field) d. LOAD_AS_FILE(M) e. LOAD_INDEX(M) f. LOAD_INDEX(X) DEPRECATED g. THROW \"not found\" 2. LOAD_INDEX(X) LOAD_NODE_MODULES(X, START) 1. let DIRS = NODE_MODULES_PATHS(START) 2. for each DIR in DIRS: a. LOAD_PACKAGE_EXPORTS(X, DIR) b. LOAD_AS_FILE(DIR/X) c. LOAD_AS_DIRECTORY(DIR/X) NODE_MODULES_PATHS(START) 1. let PARTS = path split(START) 2. let I = count of PARTS - 1 3. let DIRS = [] 4. while I >= 0, a. if PARTS[I] = \"node_modules\", GOTO d. b. DIR = path join(PARTS[0 .. I] + \"node_modules\") c. DIRS = DIR + DIRS d. let I = I - 1 5. return DIRS + GLOBAL_FOLDERS LOAD_PACKAGE_IMPORTS(X, DIR) 1. Find the closest package scope SCOPE to DIR. 2. If no scope was found, return. 3. If the SCOPE/package.json \"imports\" is null or undefined, return. 4. If `--experimental-require-module` is enabled a. let CONDITIONS = [\"node\", \"require\", \"module-sync\"] b. Else, let CONDITIONS = [\"node\", \"require\"] 5. let MATCH = PACKAGE_IMPORTS_RESOLVE(X, pathToFileURL(SCOPE), CONDITIONS) <a href=\"esm.md#resolver-algorithm-specification\">defined in the ESM resolver</a>. 6. RESOLVE_ESM_MATCH(MATCH). LOAD_PACKAGE_EXPORTS(X, DIR) 1. Try to interpret X as a combination of NAME and SUBPATH where the name may have a @scope/ prefix and the subpath begins with a slash (`/`). 2. If X does not match this pattern or DIR/NAME/package.json is not a file, return. 3. Parse DIR/NAME/package.json, and look for \"exports\" field. 4. If \"exports\" is null or undefined, return. 5. If `--experimental-require-module` is enabled a. let CONDITIONS = [\"node\", \"require\", \"module-sync\"] b. Else, let CONDITIONS = [\"node\", \"require\"] 6. let MATCH = PACKAGE_EXPORTS_RESOLVE(pathToFileURL(DIR/NAME), \".\" + SUBPATH, `package.json` \"exports\", CONDITIONS) <a href=\"esm.md#resolver-algorithm-specification\">defined in the ESM resolver</a>. 7. RESOLVE_ESM_MATCH(MATCH) LOAD_PACKAGE_SELF(X, DIR) 1. Find the closest package scope SCOPE to DIR. 2. If no scope was found, return. 3. If the SCOPE/package.json \"exports\" is null or undefined, return. 4. If the SCOPE/package.json \"name\" is not the first segment of X, return. 5. let MATCH = PACKAGE_EXPORTS_RESOLVE(pathToFileURL(SCOPE), \".\" + X.slice(\"name\".length), `package.json` \"exports\", [\"node\", \"require\"]) <a href=\"esm.md#resolver-algorithm-specification\">defined in the ESM resolver</a>. 6. RESOLVE_ESM_MATCH(MATCH) RESOLVE_ESM_MATCH(MATCH) 1. let RESOLVED_PATH = fileURLToPath(MATCH) 2. If the file at RESOLVED_PATH exists, load RESOLVED_PATH as its extension format. STOP 3. THROW \"not found\"\n\nModules are cached after the first time they are loaded. This means (among other things) that every call to will get exactly the same object returned, if it would resolve to the same file. Provided is not modified, multiple calls to will not cause the module code to be executed multiple times. This is an important feature. With it, \"partially done\" objects can be returned, thus allowing transitive dependencies to be loaded even when they would cause cycles. To have a module execute code multiple times, export a function, and call that function. Modules are cached based on their resolved filename. Since modules may resolve to a different filename based on the location of the calling module (loading from folders), it is not a guarantee that will always return the exact same object, if it would resolve to different files. Additionally, on case-insensitive file systems or operating systems, different resolved filenames can point to the same file, but the cache will still treat them as different modules and will reload the file multiple times. For example, and return two different objects, irrespective of whether or not and are the same file.\n\nNode.js has several modules compiled into the binary. These modules are described in greater detail elsewhere in this documentation. The built-in modules are defined within the Node.js source and are located in the folder. Built-in modules can be identified using the prefix, in which case it bypasses the cache. For instance, will always return the built in HTTP module, even if there is entry by that name. Some built-in modules are always preferentially loaded if their identifier is passed to . For instance, will always return the built-in HTTP module, even if there is a file by that name. The list of all the built-in modules can be retrieved from . The modules being all listed without the prefix, except those that mandate such prefix (as explained in the next section). When being loaded by , some built-in modules must be requested with the prefix. This requirement exists to prevent newly introduced built-in modules from having a conflict with user land packages that already have taken the name. Currently the built-in modules that requires the prefix are: The list of these modules is exposed in , including the prefix.\n\nThe directory name of the current module. This is the same as the of the . The file name of the current module. This is the current module file's absolute path with symlinks resolved. For a main program this is not necessarily the same as the file name used in the command line. See for the directory name of the current module. Given two modules: and , where is a dependency of and there is a directory structure of: References to within will return while references to within will return . A reference to the that is shorter to type. See the section about the exports shortcut for details on when to use and when to use . A reference to the current module, see the section about the object. In particular, is used for defining what a module exports and makes available through . Used to import modules, , and local files. Modules can be imported from . Local modules and JSON files can be imported using a relative path (e.g. , , , ) that will be resolved against the directory named by (if defined) or the current working directory. The relative paths of POSIX style are resolved in an OS independent fashion, meaning that the examples above will work on Windows in the same way they would on Unix systems. Modules are cached in this object when they are required. By deleting a key value from this object, the next will reload the module. This does not apply to native addons, for which reloading will result in an error. Adding or replacing entries is also possible. This cache is checked before built-in modules and if a name matching a built-in module is added to the cache, only -prefixed require calls are going to receive the built-in module. Use with care! Instruct on how to handle certain file extensions. Process files with the extension as : Deprecated. In the past, this list has been used to load non-JavaScript modules into Node.js by compiling them on-demand. However, in practice, there are much better ways to do this, such as loading modules via some other Node.js program, or compiling them to JavaScript ahead of time. Avoid using . Use could cause subtle bugs and resolving the extensions gets slower with each registered extension. The object representing the entry script loaded when the Node.js process launched, or if the entry point of the program is not a CommonJS module. See \"Accessing the main module\". The option is now supported.\n• <Object>\n• <string[]> Paths to resolve module location from. If present, these paths are used instead of the default resolution paths, with the exception of GLOBAL_FOLDERS like , which are always included. Each of these paths is used as a starting point for the module resolution algorithm, meaning that the hierarchy is checked from this location. Use the internal machinery to look up the location of a module, but rather than loading the module, just return the resolved filename. If the module can not be found, a error is thrown.\n• <string> The module path whose lookup paths are being retrieved. Returns an array containing the paths searched during resolution of or if the string references a core module, for example or .\n\nIn each module, the free variable is a reference to the object representing the current module. For convenience, is also accessible via the module-global. is not actually a global but rather local to each module. The module objects required for the first time by this one. The object is created by the system. Sometimes this is not acceptable; many want their module to be an instance of some class. To do this, assign the desired export object to . Assigning the desired object to will simply rebind the local variable, which is probably not what is desired. For example, suppose we were making a module called : Then in another file we could do: Assignment to must be done immediately. It cannot be done in any callbacks. This does not work: The variable is available within a module's file-level scope, and is assigned the value of before the module is evaluated. It allows a shortcut, so that can be written more succinctly as . However, be aware that like any variable, if a new value is assigned to , it is no longer bound to : When the property is being completely replaced by a new object, it is common to also reassign : To illustrate the behavior, imagine this hypothetical implementation of , which is quite similar to what is actually done by : The fully resolved filename of the module. The identifier for the module. Typically this is the fully resolved filename.\n• Type: <boolean> if the module is running during the Node.js preload phase. Whether or not the module is done loading, or is in the process of loading. - Deprecated: Please use - Deprecated: Please use Stability: 0 - Deprecated: Please use and instead. The module that first required this one, or if the current module is the entry point of the current process, or if the module was loaded by something that is not a CommonJS module (E.G.: REPL or ). The directory name of the module. This is usually the same as the of the . The search paths for the module. The method provides a way to load a module as if was called from the original module. In order to do this, it is necessary to get a reference to the object. Since returns the , and the is typically only available within a specific module's code, it must be explicitly exported in order to be used."
    },
    {
        "link": "https://nodejs.org/api/esm.html",
        "document": "ECMAScript modules are the official standard format to package JavaScript code for reuse. Modules are defined using a variety of and statements. The following example of an ES module exports a function: The following example of an ES module imports the function from : Node.js fully supports ECMAScript modules as they are currently specified and provides interoperability between them and its original module format, CommonJS.\n\nNode.js has two module systems: CommonJS modules and ECMAScript modules. Authors can tell Node.js to interpret JavaScript as an ES module via the file extension, the field with a value , or the flag with a value of . These are explicit markers of code being intended to run as an ES module. Inversely, authors can explicitly tell Node.js to interpret JavaScript as CommonJS via the file extension, the field with a value , or the flag with a value of . When code lacks explicit markers for either module system, Node.js will inspect the source code of a module to look for ES module syntax. If such syntax is found, Node.js will run the code as an ES module; otherwise it will run the module as CommonJS. See Determining module system for more details.\n\nThe specifier of an statement is the string after the keyword, e.g. in . Specifiers are also used in statements, and as the argument to an expression. There are three types of specifiers:\n• Relative specifiers like or . They refer to a path relative to the location of the importing file. The file extension is always necessary for these.\n• Bare specifiers like or . They can refer to the main entry point of a package by the package name, or a specific feature module within a package prefixed by the package name as per the examples respectively. Including the file extension is only necessary for packages without an field.\n• Absolute specifiers like . They refer directly and explicitly to a full path. Bare specifier resolutions are handled by the Node.js module resolution and loading algorithm. All other specifier resolutions are always only resolved with the standard relative URL resolution semantics. Like in CommonJS, module files within packages can be accessed by appending a path to the package name unless the package's contains an field, in which case files within packages can only be accessed via the paths defined in . For details on these package resolution rules that apply to bare specifiers in the Node.js module resolution, see the packages documentation. A file extension must be provided when using the keyword to resolve relative or absolute specifiers. Directory indexes (e.g. ) must also be fully specified. This behavior matches how behaves in browser environments, assuming a typically configured server. ES modules are resolved and cached as URLs. This means that special characters must be percent-encoded, such as with and with . , , and URL schemes are supported. A specifier like is not supported natively in Node.js unless using a custom HTTPS loader. Modules are loaded multiple times if the specifier used to resolve them has a different query or fragment. The volume root may be referenced via , , or . Given the differences between URL and path resolution (such as percent encoding details), it is recommended to use url.pathToFileURL when importing a path. URLs are supported for importing with the following MIME types: URLs only resolve bare specifiers for builtin modules and absolute specifiers. Resolving relative specifiers does not work because is not a special scheme. For example, attempting to load from fails to resolve because there is no concept of relative resolution for URLs. URLs are supported as an alternative means to load Node.js builtin modules. This URL scheme allows for builtin modules to be referenced by valid absolute URL strings.\n\nThe meta property is an that contains the following properties. It is only supported in ES modules.\n• <string> The directory name of the current module. This is the same as the of the .\n• <string> The full absolute path and filename of the current module, with symlinks resolved.\n• This is the same as the of the . Caveat only local modules support this property. Modules not using the protocol will not provide it.\n• <string> The absolute URL of the module. This is defined exactly the same as it is in browsers providing the URL of the current module file. This enables useful patterns such as relative file loading: No longer behind CLI flag, except for the non-standard parameter. This API no longer throws when targeting URLs that do not map to an existing file on the local FS. This API now returns a string synchronously instead of a Promise.\n• <string> The module specifier to resolve relative to the current module.\n• Returns: <string> The absolute URL string that the specifier would resolve to. is a module-relative resolution function scoped to each module, returning the URL string. All features of the Node.js module resolution are supported. Dependency resolutions are subject to the permitted exports resolutions within the package.\n• This can result in synchronous file-system operations, which can impact performance similarly to .\n• This feature is not available within custom loaders (it would create a deadlock). When using the flag, that function accepts a second argument:\n• <string> | <URL> An optional absolute parent module URL to resolve from. Default:\n\nAn statement can reference an ES module or a CommonJS module. statements are permitted only in ES modules, but dynamic expressions are supported in CommonJS for loading ES modules. When importing CommonJS modules, the object is provided as the default export. Named exports may be available, provided by static analysis as a convenience for better ecosystem compatibility. The CommonJS module currently only supports loading synchronous ES modules (that is, ES modules that do not use top-level ). See Loading ECMAScript modules using for details. CommonJS modules consist of a object which can be of any type. To support this, when importing CommonJS from an ECMAScript module, a namespace wrapper for the CommonJS module is constructed, which always provides a export key pointing to the CommonJS value. In addition, a heuristic static analysis is performed against the source text of the CommonJS module to get a best-effort static list of exports to provide on the namespace from values on . This is necessary since these namespaces must be constructed prior to the evaluation of the CJS module. These CommonJS namespace objects also provide the export as a named export, in order to unambiguously indicate that their representation in CommonJS uses this value, and not the namespace value. This mirrors the semantics of the handling of the export name in interop support. When importing a CommonJS module, it can be reliably imported using the ES module default import or its corresponding sugar syntax: This Module Namespace Exotic Object can be directly observed either when using or a dynamic import: For better compatibility with existing usage in the JS ecosystem, Node.js in addition attempts to determine the CommonJS named exports of every imported CommonJS module to provide them as separate ES module exports using a static analysis process. For example, consider a CommonJS module written: As can be seen from the last example of the Module Namespace Exotic Object being logged, the export is copied off of the object and set directly on the ES module namespace when the module is imported. Live binding updates or new exports added to are not detected for these named exports. The detection of named exports is based on common syntax patterns but does not always correctly detect named exports. In these cases, using the default import form described above can be a better option. Named exports detection covers many common export patterns, reexport patterns and build tool and transpiler outputs. See cjs-module-lexer for the exact semantics implemented. In most cases, the ES module can be used to load CommonJS modules. If needed, a function can be constructed within an ES module using . These CommonJS variables are not available in ES modules. and use cases can be replicated via and . Addons are not currently supported with ES module imports. They can instead be loaded with or . Relative resolution can be handled via . For a complete replacement, there is the import.meta.resolve API. Alternatively can be used. is not part of resolving specifiers. Please use symlinks if this behavior is desired. is not used by . Module customization hooks can provide a replacement. is not used by as the ES module loader has its own separate cache.\n\nThe default resolver has the following properties:\n• FileURL-based resolution as is used by ES modules\n• Does not fail on unknown extensions or protocols\n• Can optionally provide a hint of the format to the loading phase The default loader has the following properties\n• Fails on any other URL protocol\n• Fails on unknown extensions for loading (supports only , , and ) The algorithm to load an ES module specifier is given through the ESM_RESOLVE method below. It returns the resolved URL for a module specifier relative to a parentURL. The resolution algorithm determines the full resolved URL for a module load, along with its suggested module format. The resolution algorithm does not determine whether the resolved URL protocol can be loaded, or whether the file extensions are permitted, instead these validations are applied by Node.js during the load phase (for example, if it was asked to load a URL that has a protocol that is not , or . The algorithm also tries to determine the format of the file based on the extension (see algorithm below). If it does not recognize the file extension (eg if it is not , , or ), then a format of is returned, which will throw during the load phase. The algorithm to determine the module format of a resolved URL is provided by ESM_FILE_FORMAT, which returns the unique module format for any file. The \"module\" format is returned for an ECMAScript Module, while the \"commonjs\" format is used to indicate loading through the legacy CommonJS loader. Additional formats such as \"addon\" can be extended in future updates. In the following algorithms, all subroutine errors are propagated as errors of these top-level routines unless stated otherwise. defaultConditions is the conditional environment name array, . The resolver can throw the following errors:\n• Invalid Module Specifier: Module specifier is an invalid URL, package name or package subpath specifier.\n• Invalid Package Configuration: package.json configuration is invalid or contains an invalid configuration.\n• Invalid Package Target: Package exports or imports define a target module for the package that is an invalid type or string target.\n• Package Path Not Exported: Package exports do not define or permit a target subpath in the package for the given module.\n• Package Import Not Defined: Package imports do not define the specifier.\n• Module Not Found: The package or module requested does not exist.\n• Unsupported Directory Import: The resolved path corresponds to a directory, which is not a supported target for module imports.\n• If specifier is a valid URL, then\n• Set resolved to the result of parsing and reserializing specifier as a URL.\n• Otherwise, if specifier starts with \"/\", \"./\", or \"../\", then\n• Set resolved to the URL resolution of specifier relative to parentURL.\n• Otherwise, if specifier starts with \"#\", then\n• Set resolved to the result of PACKAGE_IMPORTS_RESOLVE(specifier, parentURL, defaultConditions).\n• If resolved is a \"file:\" URL, then\n• If resolved contains any percent encodings of \"/\" or \"\\\" (\"%2F\" and \"%5C\" respectively), then\n• If the file at resolved is a directory, then\n• If the file at resolved does not exist, then\n• Set resolved to the real path of resolved, maintaining the same URL querystring and fragment components.\n• Set format to the result of ESM_FILE_FORMAT(resolved).\n• Otherwise,\n• Set format the module format of the content type associated with the URL resolved.\n• Return format and resolved to the loading phase\n• If packageSpecifier is an empty string, then\n• If packageSpecifier is a Node.js builtin module name, then\n• If packageSpecifier does not start with \"@\", then\n• Set packageName to the substring of packageSpecifier until the first \"/\" separator or the end of the string.\n• Otherwise,\n• If packageSpecifier does not contain a \"/\" separator, then\n• Set packageName to the substring of packageSpecifier until the second \"/\" separator or the end of the string.\n• If packageName starts with \".\" or contains \"\\\" or \"%\", then\n• Let packageSubpath be \".\" concatenated with the substring of packageSpecifier from the position at the length of packageName.\n• If packageSubpath ends in \"/\", then\n• Let selfUrl be the result of PACKAGE_SELF_RESOLVE(packageName, packageSubpath, parentURL).\n• If selfUrl is not undefined, return selfUrl.\n• While parentURL is not the file system root,\n• Let packageURL be the URL resolution of \"node_modules/\" concatenated with packageSpecifier, relative to parentURL.\n• Set parentURL to the parent folder URL of parentURL.\n• If the folder at packageURL does not exist, then\n• Let pjson be the result of READ_PACKAGE_JSON(packageURL).\n• If pjson is not null and pjson.exports is not null or undefined, then\n• Otherwise, if packageSubpath is equal to \".\", then\n• If pjson.main is a string, then\n• Return the URL resolution of main in packageURL.\n• Otherwise,\n• Return the URL resolution of packageSubpath in packageURL.\n• Let packageURL be the result of LOOKUP_PACKAGE_SCOPE(parentURL).\n• If packageURL is null, then\n• Let pjson be the result of READ_PACKAGE_JSON(packageURL).\n• If pjson is null or if pjson.exports is null or undefined, then\n• If pjson.name is equal to packageName, then\n• If exports is an Object with both a key starting with \".\" and a key not starting with \".\", throw an Invalid Package Configuration error.\n• If subpath is equal to \".\", then\n• If exports is a String or Array, or an Object containing no keys starting with \".\", then\n• Otherwise if exports is an Object containing a \".\" property, then\n• If mainExport is not undefined, then\n• Let resolved be the result of PACKAGE_TARGET_RESOLVE( packageURL, mainExport, null, false, conditions).\n• If resolved is not null or undefined, return resolved.\n• Otherwise, if exports is an Object and all keys of exports start with \".\", then\n• Let resolved be the result of PACKAGE_IMPORTS_EXPORTS_RESOLVE( subpath, exports, packageURL, false, conditions).\n• If resolved is not null or undefined, return resolved.\n• If specifier is exactly equal to \"#\" or starts with \"#/\", then\n• Let packageURL be the result of LOOKUP_PACKAGE_SCOPE(parentURL).\n• If packageURL is not null, then\n• Let pjson be the result of READ_PACKAGE_JSON(packageURL).\n• If pjson.imports is a non-null Object, then\n• Let resolved be the result of PACKAGE_IMPORTS_EXPORTS_RESOLVE( specifier, pjson.imports, packageURL, true, conditions).\n• If resolved is not null or undefined, return resolved.\n• If matchKey is a key of matchObj and does not contain \"*\", then\n• Let target be the value of matchObj[matchKey].\n• Let expansionKeys be the list of keys of matchObj containing only a single \"*\", sorted by the sorting function PATTERN_KEY_COMPARE which orders in descending order of specificity.\n• For each key expansionKey in expansionKeys, do\n• Let patternBase be the substring of expansionKey up to but excluding the first \"*\" character.\n• If matchKey starts with but is not equal to patternBase, then\n• Let patternTrailer be the substring of expansionKey from the index after the first \"*\" character.\n• If patternTrailer has zero length, or if matchKey ends with patternTrailer and the length of matchKey is greater than or equal to the length of expansionKey, then\n• Let target be the value of matchObj[expansionKey].\n• Let patternMatch be the substring of matchKey starting at the index of the length of patternBase up to the length of matchKey minus the length of patternTrailer.\n• Let baseLengthA be the index of \"*\" in keyA.\n• Let baseLengthB be the index of \"*\" in keyB.\n• If baseLengthA is greater than baseLengthB, return -1.\n• If baseLengthB is greater than baseLengthA, return 1.\n• If the length of keyA is greater than the length of keyB, return -1.\n• If the length of keyB is greater than the length of keyA, return 1.\n• If target is a String, then\n• If target does not start with \"./\", then\n• If isImports is false, or if target starts with \"../\" or \"/\", or if target is a valid URL, then\n• If patternMatch is a String, then\n• Return PACKAGE_RESOLVE(target with every instance of \"*\" replaced by patternMatch, packageURL + \"/\").\n• If target split on \"/\" or \"\\\" contains any \"\", \".\", \"..\", or \"node_modules\" segments after the first \".\" segment, case insensitive and including percent encoded variants, throw an Invalid Package Target error.\n• Let resolvedTarget be the URL resolution of the concatenation of packageURL and target.\n• If patternMatch is null, then\n• If patternMatch split on \"/\" or \"\\\" contains any \"\", \".\", \"..\", or \"node_modules\" segments, case insensitive and including percent encoded variants, throw an Invalid Module Specifier error.\n• Return the URL resolution of resolvedTarget with every instance of \"*\" replaced with patternMatch.\n• Otherwise, if target is a non-null Object, then\n• If target contains any index property keys, as defined in ECMA-262 6.1.7 Array Index, throw an Invalid Package Configuration error.\n• For each property p of target, in object insertion order as,\n• If p equals \"default\" or conditions contains an entry for p, then\n• Let targetValue be the value of the p property in target.\n• Let resolved be the result of PACKAGE_TARGET_RESOLVE( packageURL, targetValue, patternMatch, isImports, conditions).\n• If resolved is equal to undefined, continue the loop.\n• Otherwise, if target is an Array, then\n• If _target.length is zero, return null.\n• For each item targetValue in target, do\n• Let resolved be the result of PACKAGE_TARGET_RESOLVE( packageURL, targetValue, patternMatch, isImports, conditions), continuing the loop on any Invalid Package Target error.\n• If resolved is undefined, continue the loop.\n• Return or throw the last fallback resolution null return or error.\n• Otherwise, if target is null, return null.\n• If url ends in \".mjs\", then\n• If url ends in \".cjs\", then\n• If url ends in \".json\", then\n• If is enabled and url ends in \".wasm\", then\n• If is enabled and url ends in \".node\", then\n• Let packageURL be the result of LOOKUP_PACKAGE_SCOPE(url).\n• Let pjson be the result of READ_PACKAGE_JSON(packageURL).\n• If pjson?.type is \"module\" or \"commonjs\", then\n• If url ends in \".js\", then\n• If packageType is not null, then\n• If the result of DETECT_MODULE_SYNTAX(source) is true, then\n• If url does not have any extension, then\n• If packageType is \"module\" and is enabled and the file at url contains the header for a WebAssembly module, then\n• If packageType is not null, then\n• If the result of DETECT_MODULE_SYNTAX(source) is true, then\n• While scopeURL is not the file system root,\n• Set scopeURL to the parent URL of scopeURL.\n• Let pjsonURL be the resolution of \"package.json\" within scopeURL.\n• if the file at pjsonURL exists, then\n• Let pjsonURL be the resolution of \"package.json\" within packageURL.\n• If the file at pjsonURL does not exist, then\n• If the file at packageURL does not parse as valid JSON, then\n• Return the parsed JSON source of the file at pjsonURL.\n• If the parse is successful, then\n• If source contains top-level , static or statements, or , return true.\n• If source contains a top-level lexical declaration ( , , or ) of any of the CommonJS wrapper variables ( , , , , or ) then return true. Module customization hooks provide a mechanism for customizing the ESM specifier resolution algorithm. An example that provides CommonJS-style resolution for ESM specifiers is commonjs-extension-resolution-loader."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules",
        "document": "Throughout this article, we've used extensions for our module files, but in other resources you may see the extension used instead. V8's documentation recommends this, for example. The reasons given are:\n• It is good for clarity, i.e. it makes it clear which files are modules, and which are regular JavaScript.\n• It ensures that your module files are parsed as a module by runtimes such as Node.js, and build tools such as Babel. However, we decided to keep using , at least for the moment. To get modules to work correctly in a browser, you need to make sure that your server is serving them with a header that contains a JavaScript MIME type such as . If you don't, you'll get a strict MIME type checking error along the lines of \"The server responded with a non-JavaScript MIME type\" and the browser won't run your JavaScript. Most servers already set the correct type for files, but not yet for files. Servers that already serve files correctly include GitHub Pages and for Node.js. This is OK if you are using such an environment already, or if you aren't but you know what you are doing and have access (i.e. you can configure your server to set the correct for files). It could however cause confusion if you don't control the server you are serving files from, or are publishing files for public use, as we are here. For learning and portability purposes, we decided to keep to . If you really value the clarity of using for modules versus using for \"normal\" JavaScript files, but don't want to run into the problem described above, you could always use during development and convert them to during your build step. It is also worth noting that:\n• Some tools may never support .\n• The attribute is used to denote when a module is being pointed to, as you'll see below.\n\nOnce you've exported some features out of your module, you need to import them into your script to be able to use them. The simplest way to do this is as follows: You use the statement, followed by a comma-separated list of the features you want to import wrapped in curly braces, followed by the keyword , followed by the module specifier. The module specifier provides a string that the JavaScript environment can resolve to a path to the module file. In a browser, this could be a path relative to the site root, which for our example would be . However, here we are instead using the dot ( ) syntax to mean \"the current location\", followed by the relative path to the file we are trying to find. This is much better than writing out the entire absolute path each time, as relative paths are shorter and make the URL portable — the example will still work if you move it to a different location in the site hierarchy. You can see such lines in action in . Note: In some module systems, you can use a module specifier like that isn't a relative or absolute path, and that doesn't have a file extension. This kind of specifier can be used in a browser environment if you first define an import map. Once you've imported the features into your script, you can use them just like they were defined inside the same file. The following is found in , below the import lines: Note: The imported values are read-only views of the features that were exported. Similar to variables, you cannot re-assign the variable that was imported, but you can still modify properties of object values. The value can only be re-assigned by the module exporting it. See the reference for an example.\n\nAbove we saw how a browser can import a module using a module specifier that is either an absolute URL, or a relative URL that is resolved using the base URL of the document: import { name as squareName, draw } from \"./shapes/square.js\"; import { name as circleName } from \"https://example.com/shapes/circle.js\"; Import maps allow developers to instead specify almost any text they want in the module specifier when importing a module; the map provides a corresponding value that will replace the text when the module URL is resolved. For example, the key in the import map below defines a \"module specifier map\" JSON object where the property names can be used as module specifiers, and the corresponding values will be substituted when the browser resolves the module URL. The values must be absolute or relative URLs. Relative URLs are resolved to absolute URL addresses using the base URL of the document containing the import map. The import map is defined using a JSON object inside a element with the attribute set to . Note that an import map only applies to the document — the specification does not cover how to apply an import map in a worker or worklet context. With this map you can now use the property names above as module specifiers. If there is no trailing forward slash on the module specifier key then the whole module specifier key is matched and substituted. For example, below we match bare module names, and remap a URL to another path. // Bare module names as module specifiers import { name as squareNameOne } from \"shapes\"; import { name as squareNameTwo } from \"shapes/square\"; // Remap a URL to another URL import { name as squareNameThree } from \"https://example.com/shapes/square.js\"; If the module specifier has a trailing forward slash then the value must have one as well, and the key is matched as a \"path prefix\". This allows remapping of whole classes of URLs. // Remap a URL as a prefix ( https://example.com/shapes/) import { name as squareNameFour } from \"https://example.com/shapes/moduleshapes/square.js\"; It is possible for multiple keys in an import map to be valid matches for a module specifier. For example, a module specifier of could match the module specifier keys and . In this case the browser will select the most specific (longest) matching module specifier key. Import maps allow modules to be imported using bare module names (as in Node.js), and can also simulate importing modules from packages, both with and without file extensions. While not shown above, they also allow particular versions of a library to be imported, based on the path of the script that is importing the module. Generally they let developers write more ergonomic import code, and make it easier to manage the different versions and dependencies of modules used by a site. This can reduce the effort required to use the same JavaScript libraries in both browser and server. The following sections expand on the various features outlined above.\n\nEcosystems like Node use package managers such as npm to manage modules and their dependencies. The package manager ensures that each module is separated from other modules and their dependencies. As a result, while a complex application might include the same module multiple times with several different versions in different parts of the module graph, users do not need to think about this complexity. Note: You can also achieve version management using relative paths, but this is subpar because, among other things, this forces a particular structure on your project, and prevents you from using bare module names. Import maps similarly allow you to have multiple versions of dependencies in your application and refer to them using the same module specifier. You implement this with the key, which allows you to provide module specifier maps that will be used depending on the path of the script performing the import. The example below demonstrates this. With this mapping, if a script with an URL that contains imports , the version in will be used. The map in is used as a fallback if there is no matching scope in the scoped map, or the matching scopes don't contain a matching specifier. For example, if is imported from a script with a non-matching scope path, then the module specifier map in will be used instead, mapping to the version in . Note that the path used to select a scope does not affect how the address is resolved. The value in the mapped path does not have to match the scopes path, and relative paths are still resolved to the base URL of the script that contains the import map. Just as for module specifier maps, you can have many scope keys, and these may contain overlapping paths. If multiple scopes match the referrer URL, then the most specific scope path is checked first (the longest scope key) for a matching specifier. The browsers will fall back to the next most specific matching scoped path if there is no matching specifier, and so on. If there is no matching specifier in any of the matching scopes, the browser checks for a match in the module specifier map in the key.\n\nA recent addition to JavaScript modules functionality is dynamic module loading. This allows you to dynamically load modules only when they are needed, rather than having to load everything up front. This has some obvious performance advantages; let's read on and see how it works. This new functionality allows you to call as a function, passing it the path to the module as a parameter. It returns a , which fulfills with a module object (see Creating a module object) giving you access to that object's exports. For example: import(\"./modules/myModule.js\").then((module) => { // Do something with the module. }); Note: Dynamic import is permitted in the browser main thread, and in shared and dedicated workers. However will throw if called in a service worker or worklet. Let's look at an example. In the dynamic-module-imports directory we've got another example based on our classes example. This time however we are not drawing anything on the canvas when the example loads. Instead, we include three buttons — \"Circle\", \"Square\", and \"Triangle\" — that, when pressed, dynamically load the required module and then use it to draw the associated shape. In this example we've only made changes to our and files — the module exports remain the same as before. Over in we've grabbed a reference to each button using a call, for example: We then attach an event listener to each button so that when pressed, the relevant module is dynamically loaded and used to draw the shape: Note that, because the promise fulfillment returns a module object, the class is then made a subfeature of the object, hence we now need to access the constructor with prepended to it, e.g. . Another advantage of dynamic imports is that they are always available, even in script environments. Therefore, if you have an existing tag in your HTML that doesn't have , you can still reuse code distributed as modules by dynamically importing it. <script> import(\"./modules/square.js\").then((module) => { // Do something with the module. }); // Other code that operates on the global scope and is not // ready to be refactored into modules yet. var btn = document.querySelector(\".square\"); </script>\n\nThe introduction of modules encourages the JavaScript ecosystem to distribute and reuse code in a modular fashion. However, that doesn't necessarily mean a piece of JavaScript code can run in every environment. Suppose you discovered a module that generates SHA hashes of your user's password. Can you use it in the browser front end? Can you use it on your Node.js server? The answer is: it depends. Modules still have access to global variables, as demonstrated previously. If the module references globals like , it can run in the browser, but will throw an error in your Node.js server, because is not available there. Similarly, if the code requires access to to be functional, it can only be used in Node.js. In order to maximize the reusability of a module, it is often advised to make the code \"isomorphic\" — that is, exhibits the same behavior in every runtime. This is commonly achieved in three ways:\n• Separate your modules into \"core\" and \"binding\". For the \"core\", focus on pure JavaScript logic like computing the hash, without any DOM, network, filesystem access, and expose utility functions. For the \"binding\" part, you can read from and write to the global context. For example, the \"browser binding\" may choose to read the value from an input box, while the \"Node binding\" may read it from , but values read from either place will be piped to the same core function and handled in the same way. The core can be imported in every environment and used in the same way, while only the binding, which is usually lightweight, needs to be platform-specific.\n• Detect whether a particular global exists before using it. For example, if you test that , you know that you are probably in a Node.js environment, and should not read DOM. // myModule.js let password; if (typeof process !== \"undefined\") { // We are running in Node.js; read it from `process.env` password = process.env.PASSWORD; } else if (typeof window !== \"undefined\") { // We are running in the browser; read it from the input box password = document.getElementById(\"password\").value; } This is preferable if the two branches actually end up with the same behavior (\"isomorphic\"). If it's impossible to provide the same functionality, or if doing so involves loading significant amounts of code while a large part remains unused, better use different \"bindings\" instead.\n• Use a polyfill to provide a fallback for missing features. For example, if you want to use the function, which is only supported in Node.js since v18, you can use a similar API, like the one provided by . You can do so conditionally through dynamic imports: // myModule.js if (typeof fetch === \"undefined\") { // We are running in Node.js; use node-fetch globalThis.fetch = (await import(\"node-fetch\")).default; } // … The variable is a global object that is available in every environment and is useful if you want to read or create global variables within modules. These practices are not unique to modules. Still, with the trend of code reusability and modularization, you are encouraged to make your code cross-platform so that it can be enjoyed by as many people as possible. Runtimes like Node.js are also actively implementing web APIs where possible to improve interoperability with the web."
    },
    {
        "link": "https://medium.com/@diego.coder/module-system-in-node-js-commonjs-c89f33257062",
        "document": "Basic article on module handling in Node.js. CommonJS system, module object, and require export functions.\n\nCommonJS emerged in 2009 as a project aimed at establishing conventions for module handling in the JavaScript ecosystem outside the web browser. At that time, JavaScript lacked common and standardized methods for reusing software components in environments other than the browser.\n\nOver time, the Node.js team adopted and applied CommonJS in all incoming versions of Node.js. This was done with the purpose of establishing a standard for server-side development in JavaScript. CommonJS became a popular protocol for code modularization in server environments.\n\nIt is important to note that the module system in JavaScript varies depending on the execution environment, whether on the client or the server. In the browser, a different module system known as ES modules is used, which has become the standard. All modern client-side frameworks adopt this system to build their applications.\n\nNOTE 🤓: This article will only cover the server-side system.\n\nThe module object in Node.js is like a “logbook” that keeps track of all the references to the modules used in our application. This…"
    },
    {
        "link": "https://medium.com/@stheodorejohn/mastering-json-in-javascript-best-practices-and-real-world-scenarios-b001cb79bb20",
        "document": "🔍Unlock the power of JSON with best practices and practical examples!\n\nMastering JSON in JavaScript — Best Practices and Real-World Scenarios\n\nJSON (JavaScript Object Notation) stands out as a universal favorite for data representation. In this comprehensive guide, we will explore best practices for working with JSON in JavaScript. We’ll dive deep into what JSON is, why it’s crucial, real-world scenarios where it’s employed, various implementation techniques, and offer in-depth explanations. Additionally, we’ll discuss important considerations for practical usage to ensure your JSON-related tasks are executed flawlessly.\n\nJSON, short for JavaScript Object Notation, is a lightweight data interchange format. It’s easy for humans to read and write, and it’s easy for machines to parse and generate. JSON is often used to transmit data between a server and a web application as an alternative to XML."
    },
    {
        "link": "https://stackoverflow.com/questions/21912088/json-data-structure-json-to-objects-best-practice",
        "document": "I am struggling with my web-application design using JSON, ASP.NET, typescript/javascript and AngularJS.\n\n\n\nIn Short: I need a best-practice for sending data from the server to a client via JSON, using the JSON-string on the client side to create objects.\n\n\n\n\n\nI have a WebServerAPI project (ASP.NET) with the following structure:\n\nThe id of each model class belongs to an id in a database table (primary key).\n\n\n\n\n\nThe Get() Method of the DataController returns a JSON result.\n\n\n\n\n\nThe JSON result looks like the following:\n\nAs you can see in the JSON data some As share the same Types. Although this is valid JSON, I wonder if this is the best practice to send data. \n\n\n\n\n\nWouldn't it be better to send something like this:\n\nSo we get only the Id of the Type. But then we have to request all available Types to identify which Type has to be set in the corresponding As. Which may be bad? I think this might be slow, because I have to send two queries.\n\n\n\n\n\nA third option may be sending all available Types and the As in the same JSON result.\n\nSo I am wondering if there is a best-practice for this. Sending the same object (Type) over and over again as a nested object in A seems quite \"stupid\".\n\nEspecially if I convert the JSON-string into Typescript objects.\n\n\n\n\n\nWithout any \"storage/cache\" logic I create the \"same\" object over and over again:\n\n\n\n\n\nCreating different objects which represent the same Types seems just wrong. Because I work a lot with references in other languages (C#, Java, C++). Using this way of de-serializing the data and creating the objects allows no usage of references at all (maybe this is wrong in web-applications?). And I also think, generating a lot of useless objects instead of one per Type is a waste of memory and CPU time.\n\nQuite a long post, but I hope it explains my problem well.\n\n\n\n\n\nTo summarize it: I need a best-practice for sending data from the server to a client via JSON, using the JSON-string on the client side to create objects."
    },
    {
        "link": "https://javascript.plainenglish.io/best-practices-working-with-json-in-javascript-a-deep-dive-63d7d2b5bf09",
        "document": "Best Practices Working with JSON in JavaScript: A Deep Dive\n\nJSON, or JavaScript Object Notation, is the go-to data format for web developers. Born from JavaScript, it’s now the universal language for data interchange on the web, and its simplicity and versatility make it a favorite over its predecessors like XML.\n\nWhy Every Web Developer Should Understand JSON?\n\nIf you’re building anything on the web, chances are, you’ll encounter JSON: Web APIs, configuration files, data storage — JSON is everywhere. And with its rise in RESTful services and modern frontend frameworks, grasping JSON is non-negotiable for both front-end and back-end devs.\n\nThink of JSON as a Dictionary"
    },
    {
        "link": "https://stackoverflow.com/questions/56137030/best-practice-only-possibility-json-to-javascript-typescript-object-by-const",
        "document": "Since you're using better & best I will answer with my, probably unwanted, opinion. Disclaimer: I'm no guru, this answer is based on opinion, feel free to disregard.\n\nDon't do it. Your server has a set of objects in its domain, probably some kind of problem solving or data storage domain.\n\nYour client has a set of objects in its domain, typically focused on presenting the data to the user and allowing the user to understand and manipulate it.\n\nBoth of these domains may have objects that have the same name or are based on the same real world concept. It can be tempting to feel like they are the same domain with the same objects. They are not. If they were the same you would not be writing a client and a server you would be writing two of the same thing. The two should communicate with pure data objects. In TS this means you should only create an interface, not a class, for the objects you receive from the server.\n\nInstead, start over. Create a new domain based on what you want to appear in the API. If you design your API from the top (UI) down to the bottom (access services) you'll likely find that you don't have a one-to-one mapping between objects. On the occasions you do then you can probably get away with the occasional assign / merge (see below) but I've personally never found reason to do more than what you posted above.\n\nShould you persist you may come across the option to reassign the prototype of the JSON literal from the base to the class the data represents but that is a contentious topic and potential performance pitfall.. Your best bet is probably to just do a recursive/deep assign like Lodash's merge."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Scripting/JSON",
        "document": "JavaScript Object Notation (JSON) is a standard text-based format for representing structured data based on JavaScript object syntax. It is commonly used for transmitting data in web applications (e.g., sending some data from the server to the client, so it can be displayed on a web page, or vice versa). You'll come across it quite often, so in this article, we give you all you need to work with JSON using JavaScript, including parsing JSON so you can access data within it, and creating JSON. An understanding of HTML and the fundamentals of CSS, familiarity with JavaScript basics as covered in previous lessons.\n• What JSON is — a very commonly used data format based on JavaScript object syntax.\n• That JSON can also contain arrays.\n• Retrieve JSON as a JavaScript object using mechanisms available in Web APIs (for example, in the Fetch API).\n• Converting between objects and text using and .\n\nNo, really, what is JSON? JSON is a text-based data format following JavaScript object syntax. It represents structured data as a string, which is useful when you want to transmit data across a network. Even though it closely resembles JavaScript object literal syntax, it can be used independently from JavaScript. Many programming environments feature the ability to read (parse) and generate JSON. In JavaScript, the methods for parsing and generating JSON are provided by the object. Note: Converting a string to a native object is called deserialization, while converting a native object to a string so it can be transmitted across the network is called serialization. A JSON string can be stored in its own file, which is basically just a text file with an extension of , and a MIME type of .\n\nAs described above, JSON is a string whose format very much resembles JavaScript object literal format. The following is a valid JSON string representing an object. Note how it is also a valid JavaScript object literal — just with some more syntax restrictions. { \"squadName\": \"Super hero squad\", \"homeTown\": \"Metro City\", \"formed\": 2016, \"secretBase\": \"Super tower\", \"active\": true, \"members\": [ { \"name\": \"Molecule Man\", \"age\": 29, \"secretIdentity\": \"Dan Jukes\", \"powers\": [\"Radiation resistance\", \"Turning tiny\", \"Radiation blast\"] }, { \"name\": \"Madame Uppercut\", \"age\": 39, \"secretIdentity\": \"Jane Wilson\", \"powers\": [ \"Million tonne punch\", \"Damage resistance\", \"Superhuman reflexes\" ] }, { \"name\": \"Eternal Flame\", \"age\": 1000000, \"secretIdentity\": \"Unknown\", \"powers\": [ \"Immortality\", \"Heat Immunity\", \"Inferno\", \"Teleportation\", \"Interdimensional travel\" ] } ] } If you load this JSON in your JavaScript program as a string, you can parse it into a normal object and then access the data inside it using the same dot/bracket notation we looked at in the JavaScript object basics article. For example:\n• First, we have the variable name — .\n• Inside that, we want to access the property, so we use .\n• contains an array populated by objects. We want to access the second object inside the array, so we use .\n• Inside this object, we want to access the property, so we use .\n• Inside the property is an array containing the selected hero's superpowers. We want the third one, so we use . The key takeaway is that there's really nothing special about working with JSON; after you've parsed it into a JavaScript object, you work with it just like you would with an object declared using the same object literal syntax. Note: We've made the JSON seen above available inside a variable in our JSONTest.html example (see the source code). Try loading this up and then accessing data inside the variable via your browser's JavaScript console.\n\nAbove we mentioned that JSON text basically looks like a JavaScript object inside a string. We can also convert arrays to/from JSON. The below example is perfectly valid JSON: You have to access array items (in its parsed version) by starting with an array index, for example . The JSON can also contain a single primitive. For example, , , or are all valid JSON.\n\nTo begin with, make local copies of our heroes.html and style.css files. The latter contains some simple CSS to style our page, while the former contains some very simple body HTML, plus a element to contain the JavaScript code we will be writing in this exercise: We have made our JSON data available on our GitHub, at https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json. We are going to load the JSON into our script, and use some nifty DOM manipulation to display it, like this:\n\nThe top-level function looks like this: To obtain the JSON, we use an API called Fetch. This API allows us to make network requests to retrieve resources from a server via JavaScript (e.g. images, text, JSON, even HTML snippets), meaning that we can update small sections of content without having to reload the entire page. In our function, the first four lines use the Fetch API to fetch the JSON from the server:\n• we declare the variable to store the GitHub URL\n• we use the URL to initialize a new object.\n• we make the network request using the function, and this returns a object\n• we retrieve the response as JSON using the function of the object. Note: The API is asynchronous. You can learn about asynchronous functions in detail in our Asynchronous JavaScript module, but for now, we'll just say that we need to add the keyword before the name of the function that uses the fetch API, and add the keyword before the calls to any asynchronous functions. After all that, the variable will contain the JavaScript object based on the JSON. We are then passing that object to two function calls — the first one fills the with the correct data, while the second one creates an information card for each hero on the team, and inserts it into the .\n\nNow that we've retrieved the JSON data and converted it into a JavaScript object, let's make use of it by writing the two functions we referenced above. First of all, add the following function definition below the previous code: Here we first create an h1 element with , set its to equal the property of the object, then append it to the header using . We then do a very similar operation with a paragraph: create it, set its text content and append it to the header. The only difference is that its text is set to a template literal containing both the and properties of the object.\n\nNext, add the following function at the bottom of the code, which creates and displays the superhero cards: function populateHeroes(obj) { const section = document.querySelector(\"section\"); const heroes = obj.members; for (const hero of heroes) { const myArticle = document.createElement(\"article\"); const myH2 = document.createElement(\"h2\"); const myPara1 = document.createElement(\"p\"); const myPara2 = document.createElement(\"p\"); const myPara3 = document.createElement(\"p\"); const myList = document.createElement(\"ul\"); myH2.textContent = hero.name; myPara1.textContent = `Secret identity: ${hero.secretIdentity}`; myPara2.textContent = `Age: ${hero.age}`; myPara3.textContent = \"Superpowers:\"; const superPowers = hero.powers; for (const power of superPowers) { const listItem = document.createElement(\"li\"); listItem.textContent = power; myList.appendChild(listItem); } myArticle.appendChild(myH2); myArticle.appendChild(myPara1); myArticle.appendChild(myPara2); myArticle.appendChild(myPara3); myArticle.appendChild(myList); section.appendChild(myArticle); } } To start with, we store the property of the JavaScript object in a new variable. This array contains multiple objects that contain the information for each hero. Next, we use a for...of loop to loop through each object in the array. For each one, we:\n• Create several new elements: an , an , three s, and a .\n• Set the to contain the current hero's .\n• Fill the three paragraphs with their , , and a line saying \"Superpowers:\" to introduce the information in the list.\n• Store the property in another new constant called — this contains an array that lists the current hero's superpowers.\n• Use another loop to loop through the current hero's superpowers — for each one we create an element, put the superpower inside it, then put the inside the element ( ) using .\n• The very last thing we do is to append the , s, and inside the ( ), then append the inside the . The order in which things are appended is important, as this is the order they will be displayed inside the HTML. Note: If you are having trouble getting the example to work, try referring to our heroes-finished.html source code (see it running live also.) Note: If you are having trouble following the dot/bracket notation we are using to access the JavaScript object, it can help to have the superheroes.json file open in another tab or your text editor, and refer to it as you look at our JavaScript. You should also refer back to our JavaScript object basics article for more information on dot and bracket notation.\n\nThe above example was simple in terms of accessing the JavaScript object, because we converted the network response directly into a JavaScript object using . But sometimes we aren't so lucky — sometimes we receive a raw JSON string, and we need to convert it to an object ourselves. And when we want to send a JavaScript object across the network, we need to convert it to JSON (a string) before sending it. Luckily, these two problems are so common in web development that a built-in JSON object is available in browsers, which contains the following two methods:\n• : Accepts a JSON string as a parameter, and returns the corresponding JavaScript object.\n• : Accepts an object as a parameter, and returns the equivalent JSON string. You can see the first one in action in our heroes-finished-json-parse.html example (see the source code) — this does exactly the same thing as the example we built up earlier, except that:\n• we retrieve the response as text rather than JSON, by calling the method of the response\n• we then use to convert the text to a JavaScript object. The key snippet of code is here: As you might guess, works the opposite way. Try entering the following lines into your browser's JavaScript console one by one to see it in action: let myObj = { name: \"Chris\", age: 38 }; myObj; let myString = JSON.stringify(myObj); myString; Here we're creating a JavaScript object, then checking what it contains, then converting it to a JSON string using — saving the return value in a new variable — then checking it again."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static",
        "document": "This page introduces public static properties of classes, which include static methods, static accessors, and static fields.\n• For instance features, see methods definitions, getter, setter, and public class fields.\n\nPublic static features are declared using the keyword. They are added to the class constructor at the time of class evaluation using the semantic (which is essentially ). They are accessed again from the class constructor.\n\nStatic methods are often utility functions, such as functions to create or clone instances. Public static fields are useful when you want a field to exist only once per class, not on every class instance you create. This is useful for caches, fixed-configuration, or any other data you don't need to be replicated across instances.\n\nStatic field names can be computed. The value in the computed expression is the surrounding the class definition, and referring to the class's name is a because the class is not initialized yet. and work as expected in this expression.\n\nStatic fields can have an initializer. Static fields without initializers are initialized to . Public static fields are not reinitialized on subclasses, but can be accessed via the prototype chain.\n\nIn the field initializer, refers to the current class (which you can also access through its name), and refers to the base class constructor.\n\nThe expression is evaluated synchronously. You cannot use or in the initializer expression. (Think of the initializer expression as being implicitly wrapped in a function.)\n\nStatic field initializers and static initialization blocks are evaluated one-by-one. Field initializers can refer to field values above it, but not below it. All static methods are added beforehand and can be accessed, although calling them may not behave as expected if they refer to fields below the one being initialized."
    },
    {
        "link": "https://stackoverflow.com/questions/61093601/how-the-json-parse-inside-the-static-method-is-accessing-class-properties-in-j",
        "document": "I am new to JavaScript and I was learning about \"classes\" and \"static methods\" in JavaScript. While learning, I came across a line of code, which I am unable to understand. Below is my whole code.\n\nAs you can see, inside my \"static parse\" method, the tutor who is teaching me is accessing the \"radius\" property from .\n\nWhen I removed the \".radius\" after the , my code is still working.\n\nCan you please tell me how object is able to access my \"radius\" property and what is the purpose of writing this \".radius\" if the code is still working without writing this?"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_classes",
        "document": "JavaScript is a prototype-based language — an object's behaviors are specified by its own properties and its prototype's properties. However, with the addition of classes, the creation of hierarchies of objects and the inheritance of properties and their values are much more in line with other object-oriented languages such as Java. In this section, we will demonstrate how objects can be created from classes. In many other languages, classes, or constructors, are clearly distinguished from objects, or instances. In JavaScript, classes are mainly an abstraction over the existing prototypical inheritance mechanism — all patterns are convertible to prototype-based inheritance. Classes themselves are normal JavaScript values as well, and have their own prototype chains. In fact, most plain JavaScript functions can be used as constructors — you use the operator with a constructor function to create a new object. We will be playing with the well-abstracted class model in this tutorial, and discuss what semantics classes offer. If you want to dive deep into the underlying prototype system, you can read the Inheritance and the prototype chain guide. This chapter assumes that you are already somewhat familiar with JavaScript and that you have used ordinary objects.\n\nPerhaps the most important job of a class is to act as a \"factory\" for objects. For example, when we use the constructor, we expect it to give a new object which represents the date data we passed in — which we can then manipulate with other methods the instance exposes. In classes, the instance creation is done by the constructor. As an example, we would create a class called , which represents a specific color. Users create colors through passing in an RGB triplet. class Color { constructor(r, g, b) { // Assign the RGB values as a property of `this`. this.values = [r, g, b]; } } Open your browser's devtools, paste the above code into the console, and then create an instance: You should see some output like this: You have successfully created a instance, and the instance has a property, which is an array of the RGB values you passed in. That is pretty much equivalent to the following: The constructor's syntax is exactly the same as a normal function — which means you can use other syntaxes, like rest parameters: class Color { constructor(...values) { this.values = values; } } const red = new Color(255, 0, 0); // Creates an instance with the same shape as above. Each time you call , a different instance is created. Within a class constructor, the value of points to the newly created instance. You can assign properties to it, or read existing properties (especially methods — which we will cover next). The value will be automatically returned as the result of . You are advised to not return any value from the constructor — because if you return a non-primitive value, it will become the value of the expression, and the value of is dropped. (You can read more about what does in its description.)\n\nIf a class only has a constructor, it is not much different from a factory function which just creates plain objects. However, the power of classes is that they can be used as \"templates\" which automatically assign methods to instances. For example, for instances, you can use a range of methods to get different information from a single date value, such as the year, month, day of the week, etc. You can also set those values through the counterparts like . For our own class, we can add a method called which returns the red value of the color. Without methods, you may be tempted to define the function within the constructor: This also works. However, a problem is that this creates a new function every time a instance is created, even when they all do the same thing! In contrast, if you use a method, it will be shared between all instances. A function can be shared between all instances, but still have its behavior differ when different instances call it, because the value of is different. If you are curious where this method is stored in — it's defined on the prototype of all instances, or , which is explained in more detail in Inheritance and the prototype chain. Similarly, we can create a new method called , which sets the red value of the color. class Color { constructor(r, g, b) { this.values = [r, g, b]; } getRed() { return this.values[0]; } setRed(value) { this.values[0] = value; } } const red = new Color(255, 0, 0); red.setRed(0); console.log(red.getRed()); // 0; of course, it should be called \"black\" at this stage!\n\nYou might be wondering: why do we want to go to the trouble of using and methods, when we can directly access the array on the instance? There is a philosophy in object-oriented programming called \"encapsulation\". This means you should not access the underlying implementation of an object, but instead use well-abstracted methods to interact with it. For example, if we suddenly decided to represent colors as HSL instead: class Color { constructor(r, g, b) { // values is now an HSL array! this.values = rgbToHSL([r, g, b]); } getRed() { return this.values[0]; } setRed(value) { this.values[0] = value; } } const red = new Color(255, 0, 0); console.log(red.values[0]); // 0; It's not 255 anymore, because the H value for pure red is 0 The user assumption that means the RGB value suddenly collapses, and it may cause their logic to break. So, if you are an implementor of a class, you would want to hide the internal data structure of your instance from your user, both to keep the API clean and to prevent the user's code from breaking when you do some \"harmless refactors\". In classes, this is done through private fields. A private field is an identifier prefixed with (the hash symbol). The hash is an integral part of the field's name, which means a private property can never have name clash with a public property. In order to refer to a private field anywhere in the class, you must declare it in the class body (you can't create a private property on the fly). Apart from this, a private field is pretty much equivalent to a normal property. class Color { // Declare: every Color instance has a private field called #values. #values; constructor(r, g, b) { this.#values = [r, g, b]; } getRed() { return this.#values[0]; } setRed(value) { this.#values[0] = value; } } const red = new Color(255, 0, 0); console.log(red.getRed()); // 255 Accessing private fields outside the class is an early syntax error. The language can guard against this because is a special syntax, so it can do some static analysis and find all usage of private fields before even evaluating the code. console.log(red.#values); // SyntaxError: Private field '#values' must be declared in an enclosing class Note: Code run in the Chrome console can access private properties outside the class. This is a DevTools-only relaxation of the JavaScript syntax restriction. Private fields in JavaScript are hard private: if the class does not implement methods that expose these private fields, there's absolutely no mechanism to retrieve them from outside the class. This means you are safe to do any refactors to your class's private fields, as long as the behavior of exposed methods stay the same. After we've made the field private, we can add some more logic in the and methods, instead of making them simple pass-through methods. For example, we can add a check in to see if it's a valid R value: class Color { #values; constructor(r, g, b) { this.#values = [r, g, b]; } getRed() { return this.#values[0]; } setRed(value) { if (value < 0 || value > 255) { throw new RangeError(\"Invalid R value\"); } this.#values[0] = value; } } const red = new Color(255, 0, 0); red.setRed(1000); // RangeError: Invalid R value If we leave the property exposed, our users can easily circumvent that check by assigning to directly, and create invalid colors. But with a well-encapsulated API, we can make our code more robust and prevent logic errors downstream. A class method can read the private fields of other instances, as long as they belong to the same class. class Color { #values; constructor(r, g, b) { this.#values = [r, g, b]; } redDifference(anotherColor) { // #values doesn't necessarily need to be accessed from this: // you can access private fields of other instances belonging // to the same class. return this.#values[0] - anotherColor.#values[0]; } } const red = new Color(255, 0, 0); const crimson = new Color(220, 20, 60); red.redDifference(crimson); // 35 However, if is not a Color instance, won't exist. (Even if another class has an identically named private field, it's not referring to the same thing and cannot be accessed here.) Accessing a nonexistent private property throws an error instead of returning like normal properties do. If you don't know if a private field exists on an object and you wish to access it without using / to handle the error, you can use the operator. class Color { #values; constructor(r, g, b) { this.#values = [r, g, b]; } redDifference(anotherColor) { if (!(#values in anotherColor)) { throw new TypeError(\"Color instance expected\"); } return this.#values[0] - anotherColor.#values[0]; } } Note: Keep in mind that the is a special identifier syntax, and you can't use the field name as if it's a string. would look for a property name literally called , instead of a private field. There are some limitations in using private properties: the same name can't be declared twice in a single class, and they can't be deleted. Both lead to early syntax errors. Methods, getters, and setters can be private as well. They're useful when you have something complex that the class needs to do internally but no other part of the code should be allowed to call. For example, imagine creating HTML custom elements that should do something somewhat complicated when clicked/tapped/otherwise activated. Furthermore, the somewhat complicated things that happen when the element is clicked should be restricted to this class, because no other part of the JavaScript will (or should) ever access it. In this case, pretty much every field and method is private to the class. Thus, it presents an interface to the rest of the code that's essentially just like a built-in HTML element. No other part of the program has the power to affect any of the internals of .\n\nWith the example, we have also encountered the method, which returns the current date. This method does not belong to any date instance — it belongs to the class itself. However, it's put on the class instead of being exposed as a global function, because it's mostly useful when dealing with date instances. Note: Prefixing utility methods with what they deal with is called \"namespacing\" and is considered a good practice. For example, in addition to the older, unprefixed method, JavaScript also later added the prefixed method to indicate that it's for dealing with numbers. Static properties are a group of class features that are defined on the class itself, rather than on individual instances of the class. These features include: Everything also has private counterparts. For example, for our class, we can create a static method that checks whether a given triplet is a valid RGB value: Static properties are very similar to their instance counterparts, except that:\n• They are all prefixed with , and\n• They are not accessible from instances. There is also a special construct called a static initialization block, which is a block of code that runs when the class is first loaded. Static initialization blocks are almost equivalent to immediately executing some code after a class has been declared. The only difference is that they have access to static private properties.\n\nA key feature that classes bring about (in addition to ergonomic encapsulation with private fields) is inheritance, which means one object can \"borrow\" a large part of another object's behaviors, while overriding or enhancing certain parts with its own logic. For example, suppose our class now needs to support transparency. We may be tempted to add a new field that indicates its transparency: class Color { #values; constructor(r, g, b, a = 1) { this.#values = [r, g, b, a]; } get alpha() { return this.#values[3]; } set alpha(value) { if (value < 0 || value > 1) { throw new RangeError(\"Alpha value must be between 0 and 1\"); } this.#values[3] = value; } } However, this means every instance — even the vast majority which aren't transparent (those with an alpha value of 1) — will have to have the extra alpha value, which is not very elegant. Plus, if the features keep growing, our class will become very bloated and hard to maintain. Instead, in object-oriented programming, we would create a derived class. The derived class has access to all public properties of the parent class. In JavaScript, derived classes are declared with an clause, which indicates the class it extends from. class ColorWithAlpha extends Color { #alpha; constructor(r, g, b, a) { super(r, g, b); this.#alpha = a; } get alpha() { return this.#alpha; } set alpha(value) { if (value < 0 || value > 1) { throw new RangeError(\"Alpha value must be between 0 and 1\"); } this.#alpha = value; } } There are a few things that have immediately come to attention. First is that in the constructor, we are calling . It is a language requirement to call before accessing . The call calls the parent class's constructor to initialize — here it's roughly equivalent to . You can have code before , but you cannot access before — the language prevents you from accessing the uninitialized . After the parent class is done with modifying , the derived class can do its own logic. Here we added a private field called , and also provided a pair of getter/setters to interact with them. A derived class inherits all methods from its parent. For example, although doesn't declare a accessor itself, you can still access because this behavior is specified by the parent class: Derived classes can also override methods from the parent class. For example, all classes implicitly inherit the class, which defines some basic methods like . However, the base method is notoriously useless, because it prints in most cases: Instead, our class can override it to print the color's RGB values: Within derived classes, you can access the parent class's methods by using . This allows you to build enhancement methods and avoid code duplication. class ColorWithAlpha extends Color { #alpha; // … toString() { // Call the parent class's toString() and build on the return value return `${super.toString()}, ${this.#alpha}`; } } console.log(new ColorWithAlpha(255, 0, 0, 0.5).toString()); // '255, 0, 0, 0.5' When you use , the static methods inherit from each other as well, so you can also override or enhance them. class ColorWithAlpha extends Color { // ... static isValid(r, g, b, a) { // Call the parent class's isValid() and build on the return value return super.isValid(r, g, b) && a >= 0 && a <= 1; } } console.log(ColorWithAlpha.isValid(255, 0, 0, -1)); // false Derived classes don't have access to the parent class's private fields — this is another key aspect to JavaScript private fields being \"hard private\". Private fields are scoped to the class body itself and do not grant access to any outside code. class ColorWithAlpha extends Color { log() { console.log(this.#values); // SyntaxError: Private field '#values' must be declared in an enclosing class } } A class can only extend from one class. This prevents problems in multiple inheritance like the diamond problem. However, due to the dynamic nature of JavaScript, it's still possible to achieve the effect of multiple inheritance through class composition and mixins. Instances of derived classes are also instances of the base class.\n\nThe guide has been pragmatic so far: we are focusing on how classes can be used, but there's one question unanswered: why would one use a class? The answer is: it depends. Classes introduce a paradigm, or a way to organize your code. Classes are the foundations of object-oriented programming, which is built on concepts like inheritance and polymorphism (especially subtype polymorphism). However, many people are philosophically against certain OOP practices and don't use classes as a result. For example, one thing that makes objects infamous is that they're mutable. function incrementDay(date) { return date.setDate(date.getDate() + 1); } const date = new Date(); // 2019-06-19 const newDay = incrementDay(date); console.log(newDay); // 2019-06-20 // The old date is modified as well!? console.log(date); // 2019-06-20 Mutability and internal state are important aspects of object-oriented programming, but often make code hard to reason with — because any seemingly innocent operation may have unexpected side effects and change the behavior in other parts of the program. In order to reuse code, we usually resort to extending classes, which can create big hierarchies of inheritance patterns. However, it is often hard to describe inheritance cleanly when one class can only extend one other class. Often, we want the behavior of multiple classes. In Java, this is done through interfaces; in JavaScript, it can be done through mixins. But at the end of the day, it's still not very convenient. On the brighter side, classes are a very powerful way to organize our code on a higher level. For example, without the class, we may need to create a dozen of utility functions: But with classes, we can congregate them all under the namespace, which improves readability. In addition, the introduction of private fields allows us to hide certain data from downstream users, creating a clean API. In general, you should consider using classes when you want to create objects that store their own internal data and expose a lot of behavior. Take built-in JavaScript classes as examples:\n• The and classes store a collection of elements and allow you to access them by key using , , , etc.\n• The class stores a date as a Unix timestamp (a number) and allows you to format, update, and read individual date components.\n• The class stores information about a particular exception, including the error message, stack trace, cause, etc. It's one of the few classes that come with a rich inheritance structure: there are multiple built-in classes like and that extend . In the case of errors, this inheritance allows refining the semantics of errors: each error class represents a specific type of error, which can be easily checked with . JavaScript offers the mechanism to organize your code in a canonical object-oriented way, but whether and how to use it is entirely up to the programmer's discretion."
    },
    {
        "link": "https://w3schools.com/jsref/jsref_parse_json.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://abdulapopoola.com/2013/03/30/static-and-instance-methods-in-javascript",
        "document": "I thought I quite ‘understood’ inheritance in JavaScript until I got flummoxed while trying to test my understanding. The JS prototypical inheritance model is hugely different from the classical approaches of the languages I started out with; the only way to fix this that I know of is by writing code and after spending hours screaming at my console I finally saw the light Alhamdulilah.\n\nJS is a weakly-typed prototypical language and thus classes aren’t really ‘classes‘; instead they are functions which are in turn objects. New objects are created from constructor functions by using the new keyword and this allows you to kind of ‘simulate’ OOP. But mind you; its inheritance model is still different.\n\nSome sample code that shows this difference between static and instance properties. All object properties are public although can easily make them private by declaring them with var (I added an example); for these private properties you’ll have to add accessors and setters; read this for an explanation of closures and this pattern.\n\nIt’s interesting to see that static fields cannot be accessed from child context in JavaScript (which makes sense); Java, however, allows static fields to be accessed from object context; this is kinda weird as the objects don’t really ‘have’ that variable.\n\nHere’s a quote from the Java Tutorials website:\n\nOne tip: don’t just read code and assume you understand it. Sure, you can always convince yourself that you know it. However, if you really want to KNOW it, then read it, write it and then try extend it (if you have the time and enthusiasm).\n\nSo, what other differences do you know between classical and prototypical inheritance?"
    }
]