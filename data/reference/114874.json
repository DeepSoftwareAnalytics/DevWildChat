[
    {
        "link": "https://jmhero05.medium.com/maze-generation-with-depth-first-search-and-recursive-backtracking-f341c8997867",
        "document": "What we want to take away from this Iterative Implementation is the idea of the stack. With the use of the stack we will be able to continue our recursive implementation so our maze generator won‚Äôt get stuck as it looks for unvisited cells. It‚Äôll make much more sense as we move through the code, but I wanted to apologize that I overlooked this before. BUT DON‚ÄôT WORRY, this is still gonna be sweet üòé.\n\nOkay! Let‚Äôs do this.\n\nSO, first things first, we need to create a parameter that is a current cell. I‚Äôm going to create a new file for our maze generator to keep us within the design principle of separation of concerns, and we will set our current cell as our cell within our grid at index of 0.\n\nOur maze generating algorithm will start at . Boom. Done.\n\nWe are going to want to visualize the algorithm at work as the maze is generated. We have already given our a class of ‚Äòcell‚Äô, so let‚Äôs grab all of those and set it to a variable. Let‚Äôs create a stack variable that is an empty array as well to make our lives easier later.\n\nOkay, well, our current cell is , and we know that our cell class objects start with . That means once the current cell has been defined we need to set that cell‚Äôs value to . Now comes the fun part of building our maze generating function!\n\nLet‚Äôs start with coloring in the current cell ( ) we are on to begin our visualization and write our conditional in regards to . AND, taking a page out of our iterative implementation we will push our current cell into our stack variable.\n\nStep 3 ‚Äî While the current cell has any unvisited neighbor cells‚Ä¶\n\nHere‚Äôs where things get interesting. The first part of step three is‚Ä¶\n\nWhile the current cell has any unvisited neighbor cells, choose one of those unvisited neighbors.\n\nNow that we have taken our current cell and marked it as visited we need to check if the cell has any unvisited neighbors and then choose one of them. We can do this by creating another empty array to hold the neighbors of the current cell and then pushing unvisited neighbors into that array. We will then choose one of those neighbors from the unvisited array. I found a loop was the best way of adding unvisited neighbors to our array.\n\nWith our unvisited neighbor chosen randomly from our unvisited array, we are ready to move to the second part of step three, which is‚Ä¶\n\nWhile the current cell has any unvisited neighbor cells, choose one of those unvisited neighbors; Remove the wall between the current cell and the chosen cell.\n\nEach one of our cell objects has a constructor of which holds an array of 4 boolean statements set to true. Now we need to remove the wall between the current cell and the chosen neighbor cell by setting that wall value to false. In the Part 2 of this series we focused on the cell where it‚Äôs x & y coordinates equaled 1. Using that same cell as an example, how do we find the correct index from our walls array to switch to false?\n\nIt‚Äôs easier than you think. Using our cell where & (or & ), if we were to check the neighbor just above the coordinates would be & (or & ). Now the wall to the top of our current cell is what needs to be removed and the wall to the bottom of our neighbor cell needs to be removed. If we subtract our neighbor cell‚Äôs value from our current cell‚Äôs value (since those numbers have changed and do not equal 0) we end up with 1 ( ). SO, if we want to remove the current cell‚Äôs top wall, and the neighbor cell‚Äôs bottom wall by setting those values to false. Previously, we decided that the index of 0 in our walls array would be top, index of 1 would be right, index of 2 would be bottom, and index of 3 would be left. This leaves us with‚Ä¶\n\nAnd that‚Äôs basically it, except now we apply this to every different possibility when removing walls. This leads us to the code below.\n\nWe end this part of the conditional by setting the current cell to whatever the next cell was and then it runs through again and again‚Ä¶or does it?\n\nActually, it would eventually stop/get stuck. This is because it will probably find a cell that has already been visited and all of its neighbors have been visited as well, so it will stop running. THIS is why the stack is necessary. The stack is keeping track of every cell that‚Äôs been visited. As the algorithm visits the cells and checks for neighbors randomly we run into the problem of visiting all nearby cells already. That can leave our grid still intact with walls all the way around some cells. To avoid this possible outcome we add an statement to our conditional that will look to the stack array we‚Äôve been adding to for help.\n\nWhile are stack has a length greater than 0 our algorithm will continue to run.\n\nFINALLY, we are going to add some code so that you can visualize all of these steps before your very eyes. You‚Äôll see the files below and this last part is a bit rushed, but I didn‚Äôt realize how large of an endeavor I was taking on when I started this series and this blog post is getting entirely too long as it is and I really should have broken this up into two posts, but I PROMISED we finish in this one and I don‚Äôt like to be a liar‚Ä¶so here we are.\n\nIn our maze-generator.js file screenshot you‚Äôll notice that we now have a variable holding an invocation of the method. We finish our function statement by clearing this interval. We also have a new function called that uses our Cell‚Äôs class method , which is located in our cell.js file. This method applies CSS styling to our grid by removing borders if a value from our Cell‚Äôs constructor is false, allowing you to see the algorithm at work and watch the maze generation process.\n\nYour four files should look something like this‚Ä¶"
    },
    {
        "link": "https://weblog.jamisbuck.org/2010/12/27/maze-generation-recursive-backtracking",
        "document": "I‚Äôve said before that generating mazes is a great default project when experimenting with a new programming language. I‚Äôve yet to find a better one (but I‚Äôd love to hear recommendations). However, before you can dive into generating a maze (especially in a syntax you are unfamiliar with), you had better have a solid grasp of how the process works.\n\nMy favorite, and the one I implement by default, is recursive backtracking. It is fast, easy to understand, and straightforward to implement. You‚Äôll need sufficient memory to store the entire maze in memory, though, and it requires stack space again proportional to the size of the maze, so for exceptionally large mazes it can be fairly inefficient. But for most mazes, it works a charm.\n‚Ä¢ Randomly choose a wall at that point and carve a passage through to the adjacent cell, but only if the adjacent cell has not been visited yet. This becomes the new current cell.\n‚Ä¢ The algorithm ends when the process has backed all the way up to the starting point.\n\nI generally implement the field as a grid of bitfields (where the bits in each cell describe which direction passages have been carved). That‚Äôs probably just the C programmer in me asserting dominance, though; feel free to experiment with other representations.\n\nIn Ruby, I usually initialize the grid like so:\n\nThis begins carving passages in the grid, starting at the upper-left corner, (0,0). And as you might have guessed from the algorithm‚Äôs name, this works recursively, as we‚Äôll see next.\n\nThe method first creates a list of directions that ought to be tried from the current cell:\n\nWe sort the list in random order, so that the path will meander, rather than having a bias in any particular direction.\n\nThen, the function iterates over each of those directions, determining the coordinates of the cell in that direction and deciding if the cell is valid or not. Note that a cell is valid only if it lies within the bounds of the maze, AND it has not previously been visited: we only want to carve passages into untouched cells, to avoid creating circular loops in the maze.\n\nFinally, if the cell is valid, we carve a passage out of the current cell and into the next cell. Then, we recursively call on the new cell:\n\nFor all of you not using IE (and I honestly hope no reader of my blog uses IE), here‚Äôs a Javascript demo you can play with to see the algorithm in action:\n\nStart by writing your own implementation in a language you‚Äôre comfortable in, just to wrap your mind around the algorithm. Try replacing the recursion with iteration (always a fun exercise). Consider extending it to include weave mazes (where passages move over or under other passages), or braided mazes (mazes where deadends are removed to create loops in the maze), or symmetrical mazes, or wrapped mazes. Or even different cell tesselations. If you‚Äôre at all like me, you may find that your ‚Äútoy‚Äù project has taken on a life of its own, and you‚Äôre suddenly researching new and exciting ways to build mazes!\n\nOnce you understand the algorithm, though, the real fun is trying it in a language you‚Äôre unfamiliar with. It‚Äôll show you conditionals, bit manipulation (if you use the bitfield storage like I showed above), iteration, recursion, and console output (if you decide to render your maze, too). When you‚Äôve finished, you‚Äôll have a good idea of how the language looks and works in practice, and not just for trivial ‚Äúhello world‚Äù apps."
    },
    {
        "link": "https://aryanab.medium.com/maze-generation-recursive-backtracking-5981bc5cc766",
        "document": "The set up for this project is very simple. The language we will be using is Python. There are a few external libraries required for this project:\n\nNumpy is a very fast Python library used for working with multi-dimensional arrays. If you haven‚Äôt noticed by now, our maze is merely a 2d array. To install Numpy, run the following command:\n\nOpenCV is a library designed mainly for computer-vision and image processing. Since it has very nice pixel-based drawings, we can use it for our project. To install OpenCV, run the following command:\n\nWe begin by importing the libraries into our python code.\n\nWe can check that we have imported OpenCV correctly by adding the following to the beginning of our code:\n\nIf the library is installed correctly, you should get the version number of the OpenCV that you are using.\n\nWith the libraries all set up, we can move to implement the algorithm. One way to do this is to put our algorithm inside a function, and just call that function whenever we need it. This works, but as the project gets bigger and we introduce more algorithms and features, it might become a hassle to manage all of these functions. Instead, what we will do is encapsulate our algorithm inside a class. Then these classes contain the function(s) that are responsible for creating the maze.\n\nSo what are the attributes that we need? Firstly, we need to know the height and width of the maze that we are making. Then, we need to take the path that we will store the Maze‚Äôs image. Finally, I am going to add another parameter, which is going to be boolean determining if at the end we want to see the maze created or not. It is not necessary but it could come in handy for some projects.\n\nNow we are ready to build our grid. We want the edges of our grid to be walls. After all, what sort of maze has no outer walls? Then, just like a normal grid, we will alternate between cells and walls, both horizontally and vertically. We will place this code in a function called create_maze() since it will also give us the final version of the maze.\n\nIn the first line after the function deceleration, we use numpy to create a 2d array. At this point, this array is the grid, but later on, it will turn into the maze, hence the name. The size of this array is the height and width, and we will fill it with 1. 1 in grayscale represents white, which we are using to denote unvisited cells.\n\nThen, in the for loop, we go through the maze and change all the odd rows and columns to 0, black, which we are using to denote the walls. This will give us the desired alternating pattern of a grid.\n\nNow, a keen eye might notice a problem here. What if our algorithm ends up on one of the unvisited cells on the edge? Then as it is examining its surroundings, it might try to check outside of the array. We can handle each edge and corner individually, but we can also apply a trick. Add an outer layer to the maze, and make every spot on this outer layer a visited node. This way, the algorithm can check places that are indeed outside of the maze, but still in the array, and since they are marked in advance, it will never try to go to these cells. This will save us quite a bit of overhead.\n\nTo add this to our code, we must also make sure that the height and width of our maze, including the outer visited layer, is odd. If this sounds confusing, try to draw a grid, with an outer layer and all edges being walls, and it will be obvious why. So now we have this code:\n\nWe are using 0.5, gray, to denote visited cells.\n\nWith our grid done, it is time to implement the algorithm itself. Remember that the algorithm is recursive, meaning that it will call itself. As a result, we are placing it in its own function. I am going to call this function generator and place it in the Backtracking class. The function requires 3 inputs: the current x and y location that it is at, and the grid it is in.\n\nThe first step is to mark the current location as visited. Then we want to check if we have any adjacent cells to visit or not.\n\nAt first, it might seem a bit confusing why we have grid[cy, cx] and not grid[cx, cy]. This is due to how numpy defines its axes. Axis 0 is the rows of the array, which means it‚Äôs the height. Axis 1 is the columns of the array, which means it‚Äôs the width.\n\nNow, what if we are surrounded on all sides by visited cells? Well, then nothing. We are not going to do anything and will break out of one function call. What if there is a path through? In that case, we want to randomly choose a direction, and continue going that way.\n\nHere is where the enum comes in handy. We can represent each direction with a number, but remembering which number is up, and which one is down isn‚Äôt optimal. Instead, we will use enums. Outside of the Backtracking class, declare an enum for directions:\n\nPassing the class Enum as a parameter means that Directions will inherit from Enum, and therefore be an enum too. Note that you can create an enum (or just constants) for the colors on our grid. Here, I haven‚Äôt done that since that way it is a bit harder to see the relation between the numbers and grayscale colors, but that‚Äôs just personal preference.\n\nNow we are ready to randomly select a direction.\n\nAfter the else, we choose one element randomly from it and get some values corresponding to that direction. For instance, if we are traveling upwards, then the new empty cell to go to is located 2 units above (cy) and the wall to carve through is 1 unit above (my). Since we are moving in the up direction, we do not need to change the x values. Note that the else statement should never run, since at this point there is always 1 unvisited adjacent cell, but I kept it there.\n\nLastly, we want to check if this randomly selected adjacent cell is visited or not. If it is, then go and select another cell to move to. If not, then carve the wall, and then do the same process, this time on the new cell.\n\nTake a look at the while statement. Let‚Äôs say at a cell, we have two options to go to: down and left. By chance, we start moving towards the bottom of the maze. Then we start hitting dead-ends and get back to this original cell. Now since we have this while statement, we have 3 more directions to check, only one of them unvisited. Therefore this time we will go towards the left side of the maze. Now you can see how all possible directions are checked.\n\nAt some point, the algorithm will find no adjacent cells to visit and will backtrack all the way to where it started, at this point, we have our maze. Luckily we don‚Äôt have to write any code for this, as this is when the function finishes.\n\nBack in our create_maze() function, we must call our generator function. For us to make the function even more random, we select the starting points randomly. Make sure that the starting position is an unvisited cell, and not a wall or an outer layer part of the maze.\n\nNow, maze will contain the ‚Ä¶ maze. It‚Äôs just that now everything that is not a wall is in gray, so we will just loop through the maze and change the color back to white.\n\nWe will add the entrance and exit to our maze. You can write additional code to place it somewhere random and valid in the maze, but for now, I‚Äôll just put them in the top left and bottom right.\n\nLastly, we want to know if we should display the maze we just created, and save it as an image.\n\nIf you run into trouble creating bigger mazes, you can increase the recursion limit by using the following code:\n\nYou can take a look at the final code on GitHub."
    },
    {
        "link": "https://stackoverflow.com/questions/60425024/implementing-a-recursive-backtracker-in-javascript",
        "document": "I have a 2-D array filled with objects. I want to convert this array into a maze where some objects are walls (they have a property that should be marked true) and some objects are passageways ( will be false).\n\nI'm trying to use Recursive Backtracking (I'm using a stack as opposed to recursion) for this, but my Maze is showing up like this\n\nThe black squares represent walls whereas the white squares represent passageways. The numbers inside the white squares are irrelevant (just weights I use for Djikstra).\n\nHere is my implementation of Recursive Backtracking in JavaScript.\n\nI'd really appreciate some guidance on where my code is going wrong. Thank you!"
    },
    {
        "link": "https://dstromberg.com/2013/07/tutorial-random-maze-generation-algorithm-in-javascript",
        "document": "I recently began working on a mobile game, more info of which will be coming as it gets closer to a release date. One of the central points of the game requires generating random mazes in a variety of sizes. This is a fairly well known concept in computer science, and there are a number of different algorithms which can be used to provide the maze. However, in my research, I came across few good tutorials on what exactly these algorithms did. As any developer knows, understanding what an algorithm does step by step is important to utilizing it in your own programs. Merely copying and pasting a function from some other site will invariably lead to convoluted code surrounding that function in order to get the parameters you need from it, and can lead to many problems down the road when a problem arises with that function. And believe me, a problem will always arise.I was able to work off of several different examples in a few languages in order to work through the algorithms I found, and to then rewrite the code in a manner that was suited to my purposes. For this particular purpose, I would be writing the code in Javascript. For anyone who would just like to jump ahead and see the finished code for themselves, you are free to visit the project at https://github.com/dstromberg2/maze-generator There are a number of different common algorithms for generating a random maze, and each approach will yield differing characteristics for the completed maze. For this particular project, I decided upon a depth-first search algorithm, with recursive backtracking. This is probably the simplest approach to the problem, and ensures that every maze will be solvable, and that every cell of the maze will be accessible, ensuring no wasted space in the maze.The first step in constructing the algorithm is determining what is needed for the return values. For my game, I decided that I wanted a nested array that defined each cell, consisting of arrays of cells (x values) nested in arrays of rows (y values). Each cell would then be defined by the presence of each of its four borders. I decided to construct the result in this manner to facilitate an easy process of laying out each cell in HTML, and then defining each of its borders using CSS. As such, the border definitions are presented in CSS order of [top, right, bottom, left]. Familiarity with HTML should make it apparent that defining rows as the first element of the array, with cells nested in rows, provides an easy way to loop through the array when drawing the final outcome. This may make it slightly confusing in that y values are stored before x values, but the alternative requires much more convoluted for loops than are really necessary. So the output of the function will be in the form of:And defining the first cell in the maze with all walls still intact would be:Now knowing the return value of the function, we get in to actually writing the complete script. First off is defining the function, along with the input parameters of x and y values, and the defining each of the starting variables that we will be working with.The \"totalCells\" variable will be used later when we are looping through the arrays to make sure that we check every cell in the generated maze. \"cells\" is the main array, and will contain all of the values that will be used for the return. \"unvis\" keeps track of which specifc cells in the maze have not yet been checked. Since the algorithm will be moving through the maze in a random fashion, it is important to keep track of which cells are left to be checked.Next up is looping through each of these arrays and establishing all of the nested arrays, as well as the default starting values for each. Considering the intended look of the final array, this should be fairly straightforward.In order to generate a more randomized maze, we pick a random place within the maze to start from. If the algorithm were to always start at the first cell, the resulting mazes would end up being too similar over time. By starting at a random cell and working out to the rest of the cells, the algorithm will end up drawing more unique mazes.With a starting point determined, we next establish that starting cell as being visited, and store it as the first cell in our algorithm's path. As we go through each other cell, the path along the way will continue to be stored. Whenever a dead end is reached, we will then be able to trace back the steps and start creating a new path in a different direction.Now we get to the nitty gritty of the algorithm. Establish a while loop which will check whether all the cells in the maze have been visited yet.With our starting cell in place, we define which other four cells are its potential neighbors which should be checked.The array of potential neighbors defines the y and x coordinates of the neighbor (zero and first values), as well as which wall will be the border between the neighbor and the current cell. The second value defines the wall of the current cell which is adjoining, while the third value defines the wall of the neighboring cell which is adjoining. In case there is any confusion about my numbering of the values there, since this is being stored in an array, the first listed element is always zero in an array. It's a good habit to get in to thinking about array positions with zero as the starting point, rather than thinking that the first element will be referenced with a zero in your code. Although now I fear I have made that explanation more complicated than it may have been already.With each of the potential neighbors defined, we check each of them against a series of conditions to see if they are eligible. We need to know whether each of the neighboring cells are valid points within the game grid, and whether the cell has already been checked.A quick for loop will check each of the neighbors for the conditions. I have broken out the if statement here in to multiple lines for readability, and provided a comment for each condition. This is not present in my final code, but is used here for explanation. If all of the conditions are met, the eligible neighboring cell is added to an array, which we will be using momentarily. After the for loop has checked each of the neighbor cells, the result will be an array containing each of the eligible neighbors.Once we have determined which neighbors are available, we check to make sure we ended up with at least one. If there are no eligible neighboring cells, that means we have reached a dead end. As I had mentioned earlier in this tutorial, when a dead end is reached in the maze, we will go back up the path of cells we have already visited and try again. In Javascript, the pop() method of an array will remove the highest value from the array, which is the most recently stored, and store it in a new variable if one is defined. In our code, it will take the previously visited cell in our path, and make it the current cell, so that we can begin checking again.Within the if statement, where that comment is currently, defines what the algorithm will do if there are eligible neighbors that we need to check. We will begin by randomly choosing one of the eligible neighbors.Having chosen one of the neighbors, the next step is to knock down the wall between that neighbor, and our current cell. Since each cell is defined by its borders, a wall actually consists of two definitions, one for each cell which borders the wall. In order to make sure our final array is correct for every cell, we have to remove the wall first of the current cell, and then of the selected neighbor cell. Since the position of the walls was defined earlier in the potential neighbors array, those values will be used as a reference to knock down the wall.Here we select a cell from the result array using the determined x and y values, then select which border we are removing, and mark it as 1, signifying that no wall is present at that location. You can change those values to false, and the original cell definitions can use true, if you desire to have true boolean expressions. For my purposes, one and zero was easier. In fact, the values you choose to store here are completely up to you. The benefit of understanding what the algorithm is actually doing is that you can modify any of this to suit your exact needs, and this is a great example.With the walls removed between the current cell and the neighbor, we need to move in to the neighboring cell, and set it as the current cell, so that we can repeat the process, and continue repeating it until we are done. First mark the neighboring cell as having been visited, and increment our counter.Then set the current cell equal to the values of the neighboring cell, and add it to our path that we are following through the maze.Here I am only using the zero and first elements of the neighbor's array, since the other two values define the borders, and we will not be needing those anymore. It would do no harm to pass that entire array in to the current cell, but I always choose to keep my stored values to the minimum needed to avoid confusion down the road.All of that will be contained within the while loop, so that the algorithm will continue tracing its path and knocking down walls until it has checked every cell in the maze. The only thing left from here is to close out our brackets and send the completed cells array as the return value for the function.That should do it! Again, to see the completed code, use the Github link at the top of this tutorial. You are welcome to clone and fork that repository for your own needs. Hopefully this tutorial will be helpful to anyone out there looking to get a better understanding of exactly how these types of algorithms work. If you ever come across code where you aren't sure what it does, take the time to dig in to it and understand what it is accomplishing, so that you can leverage it for your own purposes. It will always pay off in the long run.There will likely be more information, and possibly some more tutorials, about my game in the coming weeks, so keep it tuned here to find out more!"
    },
    {
        "link": "https://stackoverflow.com/questions/18040846/best-approach-for-collision-detection-with-html5-and-javascript",
        "document": "1. Should I re-check in every frame (it runs on 30 FPS)?\n\nWho says it runs in 30 FPS? I found no such thing in the HTML5 specification. Closest you'll get to have anything to say about the framerate at all is to programmatically call or the newish, more preferred, function.\n\nHowever, back to the story. You should always look for collisions as much as you can. Usually, writing games on other platforms where one have a greater ability to measure CPU load, this could be one of those things you might find favorable to scale back some if the CPU has a hard time to follow suit. In JavaScript though, you're out of luck trying to implement advanced solutions like this one.\n\nI don't think there's a shortcut here. The computer has no way of knowing what collided, how, when- and where, if you don't make that computation yourself. And yes, this is usually, if not at all times even, done just before each new frame is painted.\n\nIf by \"map\" you mean an array-like object or multidimensional array that maps coordinates to objects, then the short answer has to be no. But please do have an array of all objects on the scene. The width, height and coordinates of the object should be stored in variables in the object. Leaking these things would quickly become a burden; rendering the code complex and introduce bugs (please see separation of concerns and cohesion).\n\nDo note that I just said \"array of all objects on the scene\" =) There is a subtle but most important point in this quote:\n\nWhenever you walk through objects to determine their position and whether they have collided with someone or not. Also have a look at your viewport boundaries and determine whether the object are still \"on the scene\" or not. For instance, if you have a space craft simulator of some kind and a star just passed the player's viewport from one side to the other and then of the screen, and there is no way for the star to return and become visible again, then there is no reason for the star to be left behind in the system any more. He should be deleted and removed. He should definitely not be stored in an array and become part of a future collision detection with the player's avatar! Such things could dramatically slow down your game.\n‚Ä¢ None Divide the screen into parts. There is no reason for you to look for a collision between two objects if one of them are on left side of the screen, and the other one is on the right side. You could split up the screen into more logical units than just left and right too.\n‚Ä¢ None Always strive to have a cheap computation made first. We kind of already did that in the last tip. But even if you now know that two objects just might be in collision with each other, draw two logical squares around your objects. For instance, say you have two 2D airplanes, then there is no reason for you to first look if some part of their wings collide. Draw a square around each airplane, effectively capturing their largest width and their largest height. If these two squares do not overlap, then just like in the last tip, you know they cannot be in collision with each other. But, if your first-phase cheap computation hinted that they might be in collision, pass those two airplanes to another more expensive computation to really look into the matter a bit more."
    },
    {
        "link": "https://stackoverflow.com/questions/13099845/collision-detection-in-html5-canvas-optimization-too",
        "document": "I know this will sound like horrible overhead to you, but you should consider using a Scene Graph to handle all your collision detection, drawing and even click events on the screen.\n\nA Scene Graph is basicly a tree data structure representing 1-parent to n-child relation (note: the DOM of every HTML page is also a Scene Graph)\n\nSo to aproach this, you would have a basic interface or abstract class called \"node\" or whatever, representing the interface every node in your sceneGraph must implement. Again its just like Elements in the dom, they all have CSS properties, methods for event handling and position modifiers.\n\nNow, as you might know, if you move one element in the DOM per maring, position or what so ever, all the child elements automaticly go to the new position with their parent, this behaviour is achieved via transformation inheritance, for simplicity i'm not gonna show a 3D transformation Matrix, rather just a translation (an x,y offset).\n\nNow your worldTranslation (or globalTranslation) features all offsets a node can inherit from its parents.\n\nbefore i go into collision detection, i will show how to draw sprites with this techniqe. Basicly you will fill an array in your Draw-loop with position-image pairs\n\nNow that we have the basic understanding of drawing images from a sceneGraph, we go to collision detection:\n\nFirst we need our Nodes to have BoundryBoxes:\n\nin 2D Games i prefer having boundry boxes not in the coordinate system of the node its in, rather having it to know its Absolute values. Explanation via CSS: in css you can set margin and padding, those values do not depend on the page, rather they only exist in the \"coordinate system\" of the element who has those values set. so its like having position: absolute and left: 10px vs margin-left: 10px; the benifit in 2D is we dont need to bubble the sceneGraph all along to find detections AND we dont have to compute the box out of its current coordinate system -> into the world coordinate system -> back into each node for collision detection.\n\nNote: Not every node has to represent an Image, you can create Nodes to just add a Translation to its children, like making a DIV container with no visuals to arrange a bunch of objects while only have to edit the position of one. A Character could consist of:\n\nNow those are just some basics arround Scene Management used in Games, you can google on many therms i used here, make some further optimizations and feel free to ask any question."
    },
    {
        "link": "https://chriscourses.com/blog/coding-collision-detection-in-javascript",
        "document": "If your game's collision detection is jank, you're gonna have a bad time.\n\nTo better my understanding of collision detection (and yours of course, how could I forget?) I'll be detailing out a few ways in which you can detect and react to object collision in real-time with HTML canvas and JavaScript.\n\nTo create some objects with HTML canvas we're going to need some initial setup.\n\nAs a prerequisite, you should have a simple element in an file. Here we'll use a tag to load all of the JavaScript within :\n\nNext, we'll create a class which precisely defines what a box should look like. It has some defaults like a red color and 100 pixels of width and height, properties we can easily change later on if needed:\n\nNext we'll instantiate two objects from this class then render them by calling their associated methods:\n\nRunning this code, we should see two boxes rendered out next to each other near the center of the screen:\n\nSee the Pen Collision Detection - 1 by Christopher Lis (@chriscourses) on CodePen.\n\nWe could detect for object collision on initial load, but it's more likely that you'll be testing for collision between moving objects instead.\n\nTo get our boxes moving, we'll start by using to create an animation loop. Next, we'll clear our canvas for each frame of our animation, draw out our boxes, then add a value of onto 's position:\n\nRunning this code, our red box will move to the right (click \"Rerun\" to see effect again):\n\nSee the Pen Collision Detection - 2 by Christopher Lis (@chriscourses) on CodePen.\n\nWith one box moving, we can officially detect for whether or not two squares are colliding.\n\nIn brief, we need a way to determine whether our red box overlaps with our blue box. To do this, we'll need a total of four conditionals, but it's going to be easier to focus on one‚Äîone that can tell whether the righthand side of overlaps with the left side of .\n\nSince canvas coordinates always start from the top left of whatever object we're dealing with, to get the righthand side of , we need to add 's property onto its property. Now all that's left is to see whether or not that value is greater than or equal to the left side of 's . If it is, we know that the two are colliding from the righthand side of :\n\nThis function will detect for collision when used correctly, but there's no real use to implementing it if we aren't reacting to this collision in a meaningful way. To react to this collision we'll put this new function to use to determine if two objects are touching for every frame of our animation loop, and if they are, we'll turn their borders green:\n\nSince our class has a property that sets each box's within , changing a box's property will immediately change each corresponding box's stroke color.\n\nWith this we have the most basic collision detection we can ask for (one-sided box collision detection):\n\nSee the Pen Collision Detection - 3 by Christopher Lis (@chriscourses) on CodePen.\n\nBut what would happen if we moved down a bit so as it moves to the right, it never actually touches ?\n\nSee the Pen Collision Detection - 4 by Christopher Lis (@chriscourses) on CodePen.\n\nAs you can see, the boxes still turn green, even though they never touched. This means our collision detection code is faulty‚Äîwe need to take the three other sides of our boxes into account when looking for collisions. We can do that by adding in the remaining three conditionals of the four that I mentioned earlier:\n\nThese additional conditionals look for any overlap on the remaining sides of our boxes. We originally took care of the side of and the side of , but to get full collision detection, we'll need to determine whether the side of and the side of are touching, then do the same for the side of and the side of , and then again, the same for the side of and the side of .\n\nIt can sound quite confusing if you're new to the technique, so to further clarify, I animated a straight-to-the-point video which you can view here for extra credit:\n\nBy updating our function with the three extra conditionals, our red box will no longer turn green as it passes by our blue box on the x-axis‚Äîthe two must be touching to get the correct effect:\n\nSee the Pen Collision Detection - 5 by Christopher Lis (@chriscourses) on CodePen.\n\nNow you may not know this yet, but the order in which we call our render operations is important. To react to collisions correctly, you're going to want to render things out in the following order:\n\nImagine we're rendering out a frame on our canvas‚Äîwe update our red square's , call its method, and detect for collision. If the red square collided with the blue one, we can react to this collision however we'd like, but we'd be reacting to the collision after the fact‚Äîthe red square would be drawn as if it's already overlapping with the blue one:\n\nSee the Pen Collision Detection - 6 by Christopher Lis (@chriscourses) on CodePen.\n\nIn this case, we let collision happen, and then we would react. This could be viable in some sort of implementation, but most of the time, it makes sense to react to the collision before it actually happens. This means we never actually draw the two squares overlapping with eachother.\n\nWe'll start by calling the method, update the red square's , and then detect for collision. With this order, we're essentially asking one frame into the future, \"Is the red square about to collide with the blue one?\" We never actually show the collision, we just test if it's about to happen. If it is, we can restrict our red square from going any further, bouncing it backwards or stopping it at the perfect spot so the two are adjacent to one another.\n\nIn this case, I've added some code to react to an impending collision by placing in the perfect position so it looks like and are touching (you don't have to code this, I just want to illustrate a potential result of collision detection):\n\nSee the Pen Collision Detection - 7 by Christopher Lis (@chriscourses) on CodePen.\n\nSo rather than reacting to a collision after you've rendered it out, in my opinion, it makes more sense to react prior.\n\nIn summary, the order you'll want to call your collision detection code is as follows:\n\nThis order clears our screen and renders our objects. Then, without actually moving our objects, we update their properties and test for collision to see if the next frame to be rendered will result in overlap.\n\nWe do not render an overlap and then detect for collision, we detect for collision first and prevent any overlap from occurring.\n\nWith this new knowledge in mind, let's react to our collisions by creating a robust bounce effect.\n\nTaking the order of operations into account, we should start by giving our box red box a since we know we'll be changing this property later on:\n\nThen we'll alter 's movement code within our animation loop to make use of this new velocity property:\n\nNow, we can change up the reactionary code within our collision statement so that we're reversing 's movement on hit:\n\nAnd this'll give us the effect of the red box bouncing off of the blue box:\n\nSee the Pen Untitled by Christopher Lis (@chriscourses) on CodePen.\n\nWith how quickly frames are rendered within you might not be able to visibly see the effect of checking for collision before rendering out the next frame, but the little bit of precision you gain from rendering things the correct way will save you time and headaches from the rendering bugs you might receive by doing things out of order.\n\nIf you enjoyed this post or if you'd like to see more collision detection topics covered (gravity and collision blocks), be sure to let me know down in the comments below. You can also learn more by taking game and collision detection related courses right here on chriscourses.com. Otherwise, thanks for your attention and hope you learned a bit."
    },
    {
        "link": "https://spicyyoghurt.com/tutorials/html5-javascript-game-development/collision-detection-physics",
        "document": "Perform collision detection and react with physics, using JavaScript. Check for overlap between shapes, apply hitboxes and calculate new velocities. Make it more natural with object mass, gravity and restitution. By the end of this tutorial, you'll have a basic physics simulation running in your game.\n\nBefore you can detect collisions between moving objects, you'll need some objects to begin with. In the previous tutorial you've learned how to move a single rectangle. Let's expand that logic and create a whole bunch of moving objects to fill your game. First, define a new type of game object. It's going to be a simple square.\n\nThis code might look a bit familiar. There is a draw() and a update() function, just like in the previous tutorial. Only this time it is baked into a separate square class. This way you can create many instances of a square and they all use the same logic to draw and update. You'll have the behavior and looks of the square in one, easy-to-manage, place.\n\nThe fillStyle in this new class is tweaked a bit. When this object is colliding, it will change color from blue to red. You'll see this in action when the first collisions are detected. For now, all squares will be blue.\n\nAll the squares inherit from the GameObject class. Every game object has a position and a speed. This enables you to easily create new types of game objects. They inherit the attributes and methods of the GameObject class. The square is just an example, but you could also make objects like enemies or players for your game this way.\n\nYou can create a new instance of a class by using the new keyword. Make some squares to fill up your game world using this createWorld() function.\n\nIn the function, a bunch of squares are created. They are passed a position and speed as arguments. For now, this function is very static, but you could easily modify it to create more random squares or use some spawning algorithm.\n\nEverything is in place to draw squares now. Update your game loop with the following code to loop over the newly created game objects and draw them on the screen.\n\nAs you can see, update() and draw() are no longer just called once per iteration. There are called once for every object on screen, every iteration.\n\nThis way the implementation of update() and draw() is object-specific. For the game loop it doesn't matter what kind of objects you are trying to draw, as long as they have an update() and draw() function.\n\nFor the square you are using, it will draw a simple square and move it in a straight line. But imagine other types of objects who have their own implementation of the two functions and have behavior and looks of their own. This game loop can handle it.\n\nBy the way, did you notice the \"use strict\" line missing in these new classes? That's because classes defined with the class keyword are strict by default. So, there is no need to specifically add \"use strict\" in these classes.\n\nTake a look at the result:\n\nYou can see a bunch of rectangles getting drawn now. They each have their own starting position and move in a different direction. Just as defined in the createWorld() function. You can tweak the variables to create new types of squares.\n\nWhy do you need collision detection?\n\nThe squares may overlap in their movement, but that doesn't do much for now. It would be cool if the squares could interact and behave like actual solid objects and bounce off of each other. To make this happen, they would have to start with knowing they're colliding with one another. That's where collision detection comes in.\n\nCollision detection is the art of detecting if two objects are colliding with each other, or did so between now and the last frame. It's the first step of implementing physics in your game.\n\nThe squares are moving on the screen, but there is no form of interaction jet. It's like they don't notice each other. Let's do something about that.\n\nYou are going to check for collisions between the moving objects. That requires you to loop over all objects and check if any of them overlaps with another. You'll need a nested for loop for this. Take a look at the example:\n\nAll objects are checked for intersection with each other. The second for loop is a bit smarter and skips all previous checked items. You don't have to check objects twice. If they overlap the first time, they will too the second time. And of course, you don't have to check an object against itself, it would always overlap.\n\nThe function calls rectIntersect() for every combination of objects. When it finds a collision, it sets isColliding to true for both objects involved.\n\nRemember the draw() function from the square? It will react to isColliding and draw the square in a different color. You can easily see when two objects overlap.\n\nWhen do you check for collisions?\n\nJust as with the draw() method, you want to update the position of all your game objects first, before checking for collisions. This way you'll always check for overlapping objects in their most recent state. If you do it the other way around and check for collisions before updating, you'll be checking for overlap on the state of the previous frame. You'll always run behind the facts.\n\nAnother option would be to do the collision check in the right order, but iterative. You would update object-a, check object-a for overlap with all other objects, update object-b, check object-b for overlap with all other objects, and so on. This is also an incorrect way of doing a collision check. Imagine object-a would be in collision with object-b after updating object-a's position. The system would detect a collision, even though it might not have been the case when object-b would have moved first too. That's why you'll always have to update all objects, before doing a collision check.\n\nThe correct order for your game loop is, update, collision check, clear canvas, draw. So, place the detectCollisions() function right after the loop for updating all game objects. Your total game loop now looks like this:\n\nThe last piece of the puzzle is the rectIntersect() method. You can use it to check if two rectangles overlap. Checking for overlap between two axis-aligned (unrotated) rectangles is pretty simple and straight forward. You can probably come up with a method of checking for overlap on both axis by using the position and size of the rectangles. There are a lot of ways to do this, but the next method is very efficient:\n\nThe code detects rectangles clearly overlapping halfway, but also works in the case of one small rectangle falling completely in a large one.\n\nWith this piece of code in place, you can finally check out the result. Here are the squares again, but this time they react upon each other.\n\nAfter detecting a collision, the isColliding attribute is set to true. This makes the squares draw in red. You can clearly see when two objects overlap now.\n\nYou have a method now for checking collision between unrotated rectangles. But what if you want to do the same for circles? Well, that's not that hard either.\n\nImagine you have two circles, each with their own radius. They are placed with a distance between them. The circles would overlap if the distance is smaller than the sum of the radius of both circles. Since circles are round, this would even work when rotating the objects, they don't have to be axis-aligned.\n\nSo, if this distance is smaller than- or equal to the radius of circle-a plus circle-b, the circles overlap or touch. This principle is used in the next function:\n\nAs you can see, the formula is tweaked a bit. Multiplication is much faster than getting the square root with Math.sqrt(), so the distance is calculated without getting the root and the sum of the radii is multiplied by itself. The outcome stays the same, but the performance is better.\n\nHere is the same example as before, but with circles this time:\n\nWhat about other shapes?\n\nIn this article, collision detection is only covered for two types of shapes. But what if your game objects consist of other, more complex, shapes or even images and you want to perform collision checks between them?\n\nWell, for geometric shapes you can find other formulas to detect when two objects overlap. Here's a website who covers collision detection for a lot of different shapes. Overall, more complex shapes make collision detection more difficult. And for images you could apply pixel perfect collision detection. The downside of this is that it's a super CPU-heavy operation. Imagine having to match every pixel with one another, it would be a heck of a job.\n\nThat's why, to make things easier and put less stress on your system, developers often use hitboxes to detect collisions between complexly shaped game objects. It's a way to make collision detection easier and uses only basic geometric shapes, like the rectangles and circles covered in this tutorial. So, before you start building support for all kinds of complex shapes, try to think of a simple way to achieve the same effect, with basic shapes and hitboxes.\n\nWhat are hitboxes and how do you use them?\n\nHitboxes are imaginary geometric shapes around game objects that are used to determine collision detection. Imagine you have a player figure. You won't check its arms and legs for collision but instead just check a big imaginary rectangle that's placed around the player.\n\nYou could simply use the function for rectangle collision detection, you've applied before, to check the hitboxes for collisions. It's far less CPU-intensive and makes supporting complex shapes in your game much easier. In some special cases, you could even use multiple hitboxes per game object. It would still outperform the pixel perfect solution.\n\nThe image above demonstrates the different types of collision detection. They each have their own advantages and disadvantages:\n‚Ä¢ - Super precise collision detection, but it requires some serious system resources. In most cases this is an overkill.\n‚Ä¢ - Much better performance, but the collision detection can be pretty imprecise. In many game scenarios though, this doesn't really matter.\n‚Ä¢ - Less efficient than a single hitbox but it still outperforms the pixel perfect variant. And you can support complex shapes. This is a nice option to use for important game objects that need some extra precision, like the player with limbs like mentioned before. You could make a hitbox for the core and separates ones for arms, legs and the head.\n\nThe example image is an actual game asset from the game Pixi Pop. In the game, the asset is used when precise collision detection is important and not too many other game tasks are running. That's why, in this case, the choice is made to work with multiple hitboxes. Just pick the option that suits your game scenario the best.\n\nYou now have game objects who can detect a collision and change color. But wouldn't it be much cooler if the objects bounce off on each other, like real life objects? It's time to apply some physics to your game.\n\nTo change the velocity of the moving objects, you'll need to find out in what direction and with what speed the collision took place. You can then apply a change in velocity to the collided objects. The principles behind this work for both rectangles and circles.\n\nFind the direction and speed of the collision\n\nImagine the next collision between two game objects. Both objects have a speed and direction of their own. They don't hit each other exactly straight on, but just happen to cause a collision while moving on their own course.\n\nYou'll want to find out the speed and direction of the collision so you can apply it to the velocity of the game objects. Start by creating a vector for the collision that took place. This vector is nothing more than the difference in x and y between the two colliding objects. You can see it as an arrow with length and direction. With vectors, the length is also called magnitude. Calculate the collision vector like this:\n\nIn the example of the two game objects, the collision vector will look like this:\n\nThe magnitude in this case, is equal to the distance between the two colliding objects. It has nothing to do with speed yet. But you can use the direction of the vector. To get to the direction, you need to take away the factor of the distance.\n\nLet's first calculate the distance of the collision vector. You can use the same formula as you did before to calculate the distance between two colliding circles. So the code becomes:\n\nNow use the distance to compute a normalized collision vector. You basically remove the distance as a factor in the collision vector, so you are left with just a direction. The collision norm is in the same direction as the collision vector, only with norm/magnitude/length 1. You also call this an unit vector. You can calculate the normalized vector like this:\n\nThis will basically leave you with just a direction for the collision. In the example of the two game objects, it will look like this:\n\nYou now have a direction. This is the direction in which the collision took place. All you need now is the collision speed and you'll be able to calculate how the velocity of the objects will be affected by the collision. You can calculate the speed of the collision like this:\n\nAs first row in the example code, another vector is created with the relative velocity of the objects. It's like the vector you would have left if you would make one of the game objects stationary. (You can read more about relative velocities here.) It's easier to understand in the next example. The vectors of the two game objects are displayed on top of each other, so you can visualize the relative velocity vector:\n\nTogether with the collision normal, the relative velocity vector is used to calculate the dot product of the two vectors. The dot product is the length of the projection of relative velocity on the collision normal. Or in other words, the length of the velocity vector when it's in the direction of the collision. Learn more about dot products here. Learn more about vector operations here.\n\nThe dot product is equal to the speed of the collision. So that's it, you've got a speed and direction of the collision between the two objects. You can apply this to the velocity of the game objects and make them bounce off of each other.\n\nThe speed of the collision can be positive or negative. When it's positive, the objects are moving toward each other. When it's negative, they move away. When objects move away, there is no need to perform any further action. They will move out of collision on their own.\n\nFor the other case, when objects are moving toward each other, apply the speed in the direction of the collision. Both objects get the same change in velocity from the collision. Subtract or add the velocity to the velocity of the two collided objects.\n\nThat's it, by applying speed to direction you calculate the collision velocity. And that velocity is now processed in the velocity of the objects involved. Your game objects should bounce in a natural looking way.\n\nNow take a look at the result:\n\nIf you like, you can apply physics even further and take mass into the equation by calculating the collision impulse from the speed. Use the impulse to calculate momentum. Heavy objects will push light ones aside.\n\nIf you have two objects with a mass of 1, the impulse is just equal to the speed. In other cases, you basically split the speed into many small parts. Heavy objects receive a few of those parts as momentum, light objects a lot. This makes the lighter objects more effected by the collision.\n\nDon't forget to add mass to your game objects. The GameObject class is a good place to store mass. You can modify the createWorld() function to pass mass as an argument via the Circle and Rectangle classes.\n\nHere's an example that's modified to create a lot of small circles and two larger ones. (The spawning algorithm isn't very smart so the objects might start in collision)\n\nIn the example, the big circles have a very large mass compared to the smaller circles. They push everything out of their way. But when the two heavy objects hit each other, they bounce off too.\n\nGet the heading of the objects\n\nThe objects are constantly colliding and changing direction. For a game it would be helpful to know which direction exactly, so you can add rotated textures or build game logic based on it. Let's calculate it!\n\nYou can easily get the angle of the objects by using Math.atan2() on the x- and y velocities. The result is in radians, use Math.PI to translate it to degrees. Here's an example which calculates the angle in your update() function:\n\nYou can use the angle later in your game, to draw rotated images. This will be further explained in the next tutorial of this series.\n\nFor now, rotating isn't so interesting since the circle is a plain shape. You wouldn't notice a change in rotation. So, here's a simple implementation that shows the movement direction of the objects with a little line. The higher the speed, the longer the line. This basically represents the heading vector of the object. You can easily add this visualisation to your drawing function.\n\nThe examples shown in this tutorial contain just a basic implementation of physics. You could add more aspects to your game to make it look even more natural. Things like gravity or restitution aren't too hard to implement. Let's start right now with adding gravity to your simulation.\n\nFor gravity, simply adjust the y-speed of your objects with the gravitational acceleration. On Earth it's about 9.81 meter per second per second. You can apply it inside the update() function of your game objects. Every second, g is added to the y-speed, this will make the object fall faster and faster.\n\nUpdate the velocity before you update the position. This will give more accurate results, as explained in this article about integrating the equations of motion. This type of integration is called Semi-implicit Euler.\n\nConfine the movement space of the objects\n\nFor the effects of gravity to show nicely, you can limit the movement of your objects to the edges of the canvas. It will act like a closed box on which the objects can bounce off.\n\nYou can make it happen with a simple adjustment. Execute the next function right after your main collision detection function, so object-edge collisions are checked together with the object-object collisions.\n\nIt basically checks for objects positioned beyond the edges and resets their position to fall within the box again. The speed of the objects is then flipped to move perpendicular to the wall.\n\nIt's a very basic implementation and only works this way because the edges of the canvas are predefined straight lines. You could do the same with a circle-line collision and set-up dynamic lines, but that would be much more complicated than this quick example.\n\nIf you would run the code up till now, you'll see the game objects will never get in a resting state. They will keep bouncing and bouncing and never lose any energy. To counter this, you can implement restitution.\n\nRestitution basically describes how much energy is left after each collision. It has an effect on the bounciness of objects. The ratio between the starting and ending velocity after a bounce is called coefficient of restitution, or COR.\n‚Ä¢ Objects with a COR of 0 would absorb all energy on impact, like a bag of sand hitting the floor.\n‚Ä¢ Objects with a COR of 1 would have perfect elasticity, like a super bouncy bouncing ball.\n‚Ä¢ Objects with a COR > 1 are completely fictional and would add extra energy after each collision.\n\nIn the previous coding example, the COR is being applied to the collision with the edges. This will make the objects lose just a little bit of energy after each bounce. It will make the simulation much more realistic, leaving it out would let the objects bounce on forever.\n\nTo complete the implementation of the restitution, you'll need to apply it to the objects involved in an object-object collision as well. Just multiply their speed by the COR (just restitution in the code). Every collision will now use up a bit of energy.\n\nWhen two objects collide with a different restitution setting, like for instance when a bouncing ball hits a bag of sand, the lowest restitution will count. In this case, neither the bouncing ball or the bag of sand will bounce, they both inherit the restitution of the bag.\n\nThe next live canvas example shows gravity, restitution and boxing being applied.\n\nYou can easily tweak the variables to create different scenarios. Set a high gravity to simulate being on a foreign planet or lower the restitution to make the objects act like bags of sand who absorb all impacts.\n\nYou might not really notice it right now, but with many game objects on screen at once or with more complex shapes, the collision detection and -reaction can put some serious stress on your system. Here are some tips that might help to improve performance. They might seem obvious, but when a game gets more complex it's easy to overlook some of these concepts.\n‚Ä¢ Only compare objects that are close enough to have a possible collision. You could use a grid system or only detect collision when objects enter a certain radius. This is called splitting the collision detection into a and . Learn more about broad phase collision detection here.\n‚Ä¢ Keep your clean. Clean up objects when they are out of view or destroyed in-game.\n‚Ä¢ Exclude . Some objects won't ever react to collisions, so don't include them in the iteration.\n‚Ä¢ Use . As explained before, hitboxes are a great way of optimizing collision detection and simplify complex shapes.\n‚Ä¢ Adjust the of collision detection and physics to fit your game. You don't need a full physics engine when all you want to do is to make tic-tac-toe. That's a bit of a drastic example, but you get the point. Strip your logic to only support what is needed.\n\nOne final note about collision detection. The above example detects collisions by checking if two objects overlap. This is a good solution in many cases. But it won't work when your objects move at great speed. When the speed is higher than the size of your smallest object, objects have a chance of skipping the collision check. They pass through each other.\n\nImagine you check for a collision between a bullet and an enemy in your game. The first frame the bullet is before the enemy. There is no overlap, so the objects didn't hit. The next frame the bullet moved so fast, it is now behind your enemy. There still is no overlap, so no collision. But the bullet did pass right through the enemy and there should've been a hit.\n\nHere's an image to demonstrate the situation of a fast-moving object, like a bullet, that never has any real overlap with another game object but should've caused a collision:\n\nYou need another approach for this kind of situation. The simplest way is to limit the speed of your game objects. In short, make sure the speed is never larger than the smallest game object, so it can't pass through. For many types of games this is a great solution and it requires minimal effort.\n\nThe other solution is to perform collision detection with the projected path instead of the current position of the two objects. Try to visualize the path of a bullet as a line. The length of the line is equal to the distance the bullet will travel. Now you can use a line-to-rectangle or line-to-circle collision check to find out if the bullet will hit another object. For large bullets, you could use a rectangle instead of a line.\n\nThis is a simplified solution. You will probably run into other problems along the way, like finding the point of impact or determining which object of a greater set is hit first. But the steps mentioned here might help to point you in the right direction. For now, this is all on fast-moving objects for this tutorial.\n\nThat's all for now on collisions and physics. Your collision check is in place and your game objects are now interacting with each other in a semi-natural way. If you have any comments or questions, feel free to post them in the comment section below. You can\n\nIn the next step of the tutorial, you'll learn how to use images in your game and create sprite animations."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript/Collision_detection",
        "document": "This is the 7th step out of 10 of the Gamedev Canvas tutorial. You can find the source code as it should look after completing this lesson at Gamedev-Canvas-workshop/lesson7.html. We have the bricks appearing on the screen already, but the game still isn't that interesting as the ball goes through them. We need to think about adding collision detection so it can bounce off the bricks and break them. It's our decision how to implement this, of course, but it can be tough to calculate whether the ball is touching the rectangle or not because there are no helper functions in Canvas for this. For the sake of this tutorial we will do it the easiest way possible. We will check if the center of the ball is colliding with any of the given bricks. This won't give a perfect result every time, and there are much more sophisticated ways to do collision detection, but this will work fine for teaching you the basic concepts.\n\nTo kick this all off we want to create a collision detection function that will loop through all the bricks and compare every single brick's position with the ball's coordinates as each frame is drawn. For better readability of the code we will define the variable for storing the brick object in every loop of the collision detection: function collisionDetection() { for (let c = 0; c < brickColumnCount; c++) { for (let r = 0; r < brickRowCount; r++) { const b = bricks[c][r]; // calculations } } } If the center of the ball is inside the coordinates of one of our bricks, we'll change the direction of the ball. For the center of the ball to be inside the brick, all four of the following statements need to be true:\n‚Ä¢ The x position of the ball is greater than the x position of the brick.\n‚Ä¢ The x position of the ball is less than the x position of the brick plus its width.\n‚Ä¢ The y position of the ball is greater than the y position of the brick.\n‚Ä¢ The y position of the ball is less than the y position of the brick plus its height. Let's write that down in code: function collisionDetection() { for (let c = 0; c < brickColumnCount; c++) { for (let r = 0; r < brickRowCount; r++) { const b = bricks[c][r]; if (x > b.x && x < b.x + brickWidth && y > b.y && y < b.y + brickHeight) { dy = -dy; } } } } Add the above block to your code, below the function.\n\nMaking the bricks disappear after they are hit The above code will work as desired and the ball changes its direction. The problem is that the bricks are staying where they are. We have to figure out a way to get rid of the ones we've already hit with the ball. We can do that by adding an extra parameter to indicate whether we want to paint each brick on the screen or not. In the part of the code where we initialize the bricks, let's add a property to each brick object. Update the following part of the code as indicated by the highlighted line: let bricks = []; for (let c = 0; c < brickColumnCount; c++) { bricks[c] = []; for (let r = 0; r < brickRowCount; r++) { bricks[c][r] = { x: 0, y: 0, status: 1 }; } } Next we'll check the value of each brick's property in the function before drawing it ‚Äî if is , then draw it, but if it's , then it was hit by the ball and we don't want it on the screen anymore. Update your function as follows: function drawBricks() { for (let c = 0; c < brickColumnCount; c++) { for (let r = 0; r < brickRowCount; r++) { if (bricks[c][r].status === 1) { const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft; const brickY = r * (brickHeight + brickPadding) + brickOffsetTop; bricks[c][r].x = brickX; bricks[c][r].y = brickY; ctx.beginPath(); ctx.rect(brickX, brickY, brickWidth, brickHeight); ctx.fillStyle = \"#0095DD\"; ctx.fill(); ctx.closePath(); } } } }\n\nTracking and updating the status in the collision detection function Now we need to involve the brick property in the function: if the brick is active (its status is ) we will check whether the collision happens; if a collision does occur we'll set the status of the given brick to so it won't be painted on the screen. Update your function as indicated below: function collisionDetection() { for (let c = 0; c < brickColumnCount; c++) { for (let r = 0; r < brickRowCount; r++) { const b = bricks[c][r]; if (b.status === 1) { if ( x > b.x && x < b.x + brickWidth && y > b.y && y < b.y + brickHeight ) { dy = -dy; b.status = 0; } } } } }\n\nThe collision detection of the ball is now checked on every frame, with every brick. Now we can destroy bricks! :-) const canvas = document.getElementById(\"myCanvas\"); const ctx = canvas.getContext(\"2d\"); const ballRadius = 10; let x = canvas.width / 2; let y = canvas.height - 30; let dx = 2; let dy = -2; const paddleHeight = 10; const paddleWidth = 75; let paddleX = (canvas.width - paddleWidth) / 2; let rightPressed = false; let leftPressed = false; let interval = 0; const brickRowCount = 3; const brickColumnCount = 5; const brickWidth = 75; const brickHeight = 20; const brickPadding = 10; const brickOffsetTop = 30; const brickOffsetLeft = 30; let bricks = []; for (let c = 0; c < brickColumnCount; c++) { bricks[c] = []; for (let r = 0; r < brickRowCount; r++) { bricks[c][r] = { x: 0, y: 0, status: 1 }; } } document.addEventListener(\"keydown\", keyDownHandler, false); document.addEventListener(\"keyup\", keyUpHandler, false); function keyDownHandler(e) { if (e.key == \"Right\" || e.key == \"ArrowRight\") { rightPressed = true; } else if (e.key == \"Left\" || e.key == \"ArrowLeft\") { leftPressed = true; } } function keyUpHandler(e) { if (e.key == \"Right\" || e.key == \"ArrowRight\") { rightPressed = false; } else if (e.key == \"Left\" || e.key == \"ArrowLeft\") { leftPressed = false; } } function collisionDetection() { for (let c = 0; c < brickColumnCount; c++) { for (let r = 0; r < brickRowCount; r++) { let b = bricks[c][r]; if (b.status == 1) { if ( x > b.x && x < b.x + brickWidth && y > b.y && y < b.y + brickHeight ) { dy = -dy; b.status = 0; } } } } } function drawBall() { ctx.beginPath(); ctx.arc(x, y, ballRadius, 0, Math.PI * 2); ctx.fillStyle = \"#0095DD\"; ctx.fill(); ctx.closePath(); } function drawPaddle() { ctx.beginPath(); ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight); ctx.fillStyle = \"#0095DD\"; ctx.fill(); ctx.closePath(); } function drawBricks() { for (let c = 0; c < brickColumnCount; c++) { for (let r = 0; r < brickRowCount; r++) { if (bricks[c][r].status == 1) { let brickX = c * (brickWidth + brickPadding) + brickOffsetLeft; let brickY = r * (brickHeight + brickPadding) + brickOffsetTop; bricks[c][r].x = brickX; bricks[c][r].y = brickY; ctx.beginPath(); ctx.rect(brickX, brickY, brickWidth, brickHeight); ctx.fillStyle = \"#0095DD\"; ctx.fill(); ctx.closePath(); } } } } function draw() { ctx.clearRect(0, 0, canvas.width, canvas.height); drawBricks(); drawBall(); drawPaddle(); collisionDetection(); if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) { dx = -dx; } if (y + dy < ballRadius) { dy = -dy; } else if (y + dy > canvas.height - ballRadius) { if (x > paddleX && x < paddleX + paddleWidth) { if ((y = y - paddleHeight)) { dy = -dy; } } else { alert(\"GAME OVER\"); document.location.reload(); clearInterval(interval); // Needed for Chrome to end game } } if (rightPressed && paddleX < canvas.width - paddleWidth) { paddleX += 7; } else if (leftPressed && paddleX > 0) { paddleX -= 7; } x += dx; y += dy; } function startGame() { interval = setInterval(draw, 10); } document.getElementById(\"runButton\").addEventListener(\"click\", function () { startGame(); this.disabled = true; });"
    }
]