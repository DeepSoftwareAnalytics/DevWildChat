[
    {
        "link": "https://go.dev/ref/spec",
        "document": "This is the reference manual for the Go programming language. The pre-Go1.18 version, without generics, can be found here. For more information and other documents, see go.dev.\n\nGo is a general-purpose language designed with systems programming in mind. It is strongly typed and garbage-collected and has explicit support for concurrent programming. Programs are constructed from packages, whose properties allow efficient management of dependencies.\n\nThe syntax is compact and simple to parse, allowing for easy analysis by automatic tools such as integrated development environments.\n\nThe syntax is specified using a variant of Extended Backus-Naur Form (EBNF):\n\nProductions are expressions constructed from terms and the following operators, in increasing precedence:\n\nLowercase production names are used to identify lexical (terminal) tokens. Non-terminals are in CamelCase. Lexical tokens are enclosed in double quotes or back quotes .\n\nThe form represents the set of characters from through as alternatives. The horizontal ellipsis is also used elsewhere in the spec to informally denote various enumerations or code snippets that are not further specified. The character (as opposed to the three characters ) is not a token of the Go language.\n\nA link of the form [Go 1.xx] indicates that a described language feature (or some aspect of it) was changed or added with language version 1.xx and thus requires at minimum that language version to build. For details, see the linked section in the appendix.\n\nSource code is Unicode text encoded in UTF-8. The text is not canonicalized, so a single accented code point is distinct from the same character constructed from combining an accent and a letter; those are treated as two code points. For simplicity, this document will use the unqualified term character to refer to a Unicode code point in the source text.\n\nEach code point is distinct; for instance, uppercase and lowercase letters are different characters.\n\nImplementation restriction: For compatibility with other tools, a compiler may disallow the NUL character (U+0000) in the source text.\n\nImplementation restriction: For compatibility with other tools, a compiler may ignore a UTF-8-encoded byte order mark (U+FEFF) if it is the first Unicode code point in the source text. A byte order mark may be disallowed anywhere else in the source.\n\nThe following terms are used to denote specific Unicode character categories:\n\nIn The Unicode Standard 8.0, Section 4.5 \"General Category\" defines a set of character categories. Go treats all characters in any of the Letter categories Lu, Ll, Lt, Lm, or Lo as Unicode letters, and those in the Number category Nd as Unicode digits.\n\nComments serve as program documentation. There are two forms:\n• Line comments start with the character sequence and stop at the end of the line.\n• General comments start with the character sequence and stop with the first subsequent character sequence .\n\nA comment cannot start inside a rune or string literal, or inside a comment. A general comment containing no newlines acts like a space. Any other comment acts like a newline.\n\nTokens form the vocabulary of the Go language. There are four classes: identifiers, keywords, operators and punctuation, and literals. White space, formed from spaces (U+0020), horizontal tabs (U+0009), carriage returns (U+000D), and newlines (U+000A), is ignored except as it separates tokens that would otherwise combine into a single token. Also, a newline or end of file may trigger the insertion of a semicolon. While breaking the input into tokens, the next token is the longest sequence of characters that form a valid token.\n\nThe formal syntax uses semicolons as terminators in a number of productions. Go programs may omit most of these semicolons using the following two rules:\n• When the input is broken into tokens, a semicolon is automatically inserted into the token stream immediately after a line's final token if that token is\n• one of the keywords , , , or\n• one of the operators and punctuation , , , , or\n• To allow complex statements to occupy a single line, a semicolon may be omitted before a closing or .\n\nTo reflect idiomatic use, code examples in this document elide semicolons using these rules.\n\nIdentifiers name program entities such as variables and types. An identifier is a sequence of one or more letters and digits. The first character in an identifier must be a letter.\n\nThe following keywords are reserved and may not be used as identifiers.\n\nThe following character sequences represent operators (including assignment operators) and punctuation [Go 1.18]:\n\nAn integer literal is a sequence of digits representing an integer constant. An optional prefix sets a non-decimal base: or for binary, , , or for octal, and or for hexadecimal [Go 1.13]. A single is considered a decimal zero. In hexadecimal literals, letters through and through represent values 10 through 15.\n\nFor readability, an underscore character may appear after a base prefix or between successive digits; such underscores do not change the literal's value.\n\nA floating-point literal is a decimal or hexadecimal representation of a floating-point constant.\n\nA decimal floating-point literal consists of an integer part (decimal digits), a decimal point, a fractional part (decimal digits), and an exponent part ( or followed by an optional sign and decimal digits). One of the integer part or the fractional part may be elided; one of the decimal point or the exponent part may be elided. An exponent value exp scales the mantissa (integer and fractional part) by 10exp.\n\nA hexadecimal floating-point literal consists of a or prefix, an integer part (hexadecimal digits), a radix point, a fractional part (hexadecimal digits), and an exponent part ( or followed by an optional sign and decimal digits). One of the integer part or the fractional part may be elided; the radix point may be elided as well, but the exponent part is required. (This syntax matches the one given in IEEE 754-2008 §5.12.3.) An exponent value exp scales the mantissa (integer and fractional part) by 2exp [Go 1.13].\n\nFor readability, an underscore character may appear after a base prefix or between successive digits; such underscores do not change the literal value.\n\nAn imaginary literal represents the imaginary part of a complex constant. It consists of an integer or floating-point literal followed by the lowercase letter . The value of an imaginary literal is the value of the respective integer or floating-point literal multiplied by the imaginary unit i [Go 1.13]\n\nFor backward compatibility, an imaginary literal's integer part consisting entirely of decimal digits (and possibly underscores) is considered a decimal integer, even if it starts with a leading .\n\nA rune literal represents a rune constant, an integer value identifying a Unicode code point. A rune literal is expressed as one or more characters enclosed in single quotes, as in or . Within the quotes, any character may appear except newline and unescaped single quote. A single quoted character represents the Unicode value of the character itself, while multi-character sequences beginning with a backslash encode values in various formats.\n\nThe simplest form represents the single character within the quotes; since Go source text is Unicode characters encoded in UTF-8, multiple UTF-8-encoded bytes may represent a single integer value. For instance, the literal holds a single byte representing a literal , Unicode U+0061, value , while holds two bytes ( ) representing a literal -dieresis, U+00E4, value .\n\nSeveral backslash escapes allow arbitrary values to be encoded as ASCII text. There are four ways to represent the integer value as a numeric constant: followed by exactly two hexadecimal digits; followed by exactly four hexadecimal digits; followed by exactly eight hexadecimal digits, and a plain backslash followed by exactly three octal digits. In each case the value of the literal is the value represented by the digits in the corresponding base.\n\nAlthough these representations all result in an integer, they have different valid ranges. Octal escapes must represent a value between 0 and 255 inclusive. Hexadecimal escapes satisfy this condition by construction. The escapes and represent Unicode code points so within them some values are illegal, in particular those above and surrogate halves.\n\nAn unrecognized character following a backslash in a rune literal is illegal.\n\nA string literal represents a string constant obtained from concatenating a sequence of characters. There are two forms: raw string literals and interpreted string literals.\n\nRaw string literals are character sequences between back quotes, as in . Within the quotes, any character may appear except back quote. The value of a raw string literal is the string composed of the uninterpreted (implicitly UTF-8-encoded) characters between the quotes; in particular, backslashes have no special meaning and the string may contain newlines. Carriage return characters ('\\r') inside raw string literals are discarded from the raw string value.\n\nInterpreted string literals are character sequences between double quotes, as in . Within the quotes, any character may appear except newline and unescaped double quote. The text between the quotes forms the value of the literal, with backslash escapes interpreted as they are in rune literals (except that is illegal and is legal), with the same restrictions. The three-digit octal ( nnn) and two-digit hexadecimal ( nn) escapes represent individual bytes of the resulting string; all other escapes represent the (possibly multi-byte) UTF-8 encoding of individual characters. Thus inside a string literal and represent a single byte of value =255, while , , and represent the two bytes of the UTF-8 encoding of character U+00FF.\n\nThese examples all represent the same string:\n\nIf the source code represents a character as two code points, such as a combining form involving an accent and a letter, the result will be an error if placed in a rune literal (it is not a single code point), and will appear as two code points if placed in a string literal.\n\nThere are boolean constants, rune constants, integer constants, floating-point constants, complex constants, and string constants. Rune, integer, floating-point, and complex constants are collectively called numeric constants.\n\nA constant value is represented by a rune, integer, floating-point, imaginary, or string literal, an identifier denoting a constant, a constant expression, a conversion with a result that is a constant, or the result value of some built-in functions such as or applied to constant arguments, applied to certain values, or applied to some expressions, and applied to a complex constant and applied to numeric constants. The boolean truth values are represented by the predeclared constants and . The predeclared identifier iota denotes an integer constant.\n\nIn general, complex constants are a form of constant expression and are discussed in that section.\n\nNumeric constants represent exact values of arbitrary precision and do not overflow. Consequently, there are no constants denoting the IEEE 754 negative zero, infinity, and not-a-number values.\n\nConstants may be typed or untyped. Literal constants, , , , and certain constant expressions containing only untyped constant operands are untyped.\n\nA constant may be given a type explicitly by a constant declaration or conversion, or implicitly when used in a variable declaration or an assignment statement or as an operand in an expression. It is an error if the constant value cannot be represented as a value of the respective type. If the type is a type parameter, the constant is converted into a non-constant value of the type parameter.\n\nAn untyped constant has a default type which is the type to which the constant is implicitly converted in contexts where a typed value is required, for instance, in a short variable declaration such as where there is no explicit type. The default type of an untyped constant is , , , , , or respectively, depending on whether it is a boolean, rune, integer, floating-point, complex, or string constant.\n\nImplementation restriction: Although numeric constants have arbitrary precision in the language, a compiler may implement them using an internal representation with limited precision. That said, every implementation must:\n• Represent integer constants with at least 256 bits.\n• Represent floating-point constants, including the parts of a complex constant, with a mantissa of at least 256 bits and a signed binary exponent of at least 16 bits.\n• Give an error if unable to represent an integer constant precisely.\n• Give an error if unable to represent a floating-point or complex constant due to overflow.\n• Round to the nearest representable constant if unable to represent a floating-point or complex constant due to limits on precision.\n\nThese requirements apply both to literal constants and to the result of evaluating constant expressions.\n\nA variable is a storage location for holding a value. The set of permissible values is determined by the variable's type.\n\nA variable declaration or, for function parameters and results, the signature of a function declaration or function literal reserves storage for a named variable. Calling the built-in function or taking the address of a composite literal allocates storage for a variable at run time. Such an anonymous variable is referred to via a (possibly implicit) pointer indirection.\n\nStructured variables of array, slice, and struct types have elements and fields that may be addressed individually. Each such element acts like a variable.\n\nThe static type (or just type) of a variable is the type given in its declaration, the type provided in the call or composite literal, or the type of an element of a structured variable. Variables of interface type also have a distinct dynamic type, which is the (non-interface) type of the value assigned to the variable at run time (unless the value is the predeclared identifier , which has no type). The dynamic type may vary during execution but values stored in interface variables are always assignable to the static type of the variable.\n\nA variable's value is retrieved by referring to the variable in an expression; it is the most recent value assigned to the variable. If a variable has not yet been assigned a value, its value is the zero value for its type.\n\nA type determines a set of values together with operations and methods specific to those values. A type may be denoted by a type name, if it has one, which must be followed by type arguments if the type is generic. A type may also be specified using a type literal, which composes a type from existing types.\n\nThe language predeclares certain type names. Others are introduced with type declarations or type parameter lists. Composite types—array, struct, pointer, function, interface, slice, map, and channel types—may be constructed using type literals.\n\nPredeclared types, defined types, and type parameters are called named types. An alias denotes a named type if the type given in the alias declaration is a named type.\n\nA boolean type represents the set of Boolean truth values denoted by the predeclared constants and . The predeclared boolean type is ; it is a defined type.\n\nAn integer, floating-point, or complex type represents the set of integer, floating-point, or complex values, respectively. They are collectively called numeric types. The predeclared architecture-independent numeric types are:\n\nThe value of an n-bit integer is n bits wide and represented using two's complement arithmetic.\n\nThere is also a set of predeclared integer types with implementation-specific sizes:\n\nTo avoid portability issues all numeric types are defined types and thus distinct except , which is an alias for , and , which is an alias for . Explicit conversions are required when different numeric types are mixed in an expression or assignment. For instance, and are not the same type even though they may have the same size on a particular architecture.\n\nA string type represents the set of string values. A string value is a (possibly empty) sequence of bytes. The number of bytes is called the length of the string and is never negative. Strings are immutable: once created, it is impossible to change the contents of a string. The predeclared string type is ; it is a defined type.\n\nThe length of a string can be discovered using the built-in function . The length is a compile-time constant if the string is a constant. A string's bytes can be accessed by integer indices 0 through . It is illegal to take the address of such an element; if is the 'th byte of a string, is invalid.\n\nAn array is a numbered sequence of elements of a single type, called the element type. The number of elements is called the length of the array and is never negative.\n\nThe length is part of the array's type; it must evaluate to a non-negative constant representable by a value of type . The length of array can be discovered using the built-in function . The elements can be addressed by integer indices 0 through . Array types are always one-dimensional but may be composed to form multi-dimensional types.\n\nAn array type may not have an element of type , or of a type containing as a component, directly or indirectly, if those containing types are only array or struct types.\n\nA slice is a descriptor for a contiguous segment of an underlying array and provides access to a numbered sequence of elements from that array. A slice type denotes the set of all slices of arrays of its element type. The number of elements is called the length of the slice and is never negative. The value of an uninitialized slice is .\n\nThe length of a slice can be discovered by the built-in function ; unlike with arrays it may change during execution. The elements can be addressed by integer indices 0 through . The slice index of a given element may be less than the index of the same element in the underlying array.\n\nA slice, once initialized, is always associated with an underlying array that holds its elements. A slice therefore shares storage with its array and with other slices of the same array; by contrast, distinct arrays always represent distinct storage.\n\nThe array underlying a slice may extend past the end of the slice. The capacity is a measure of that extent: it is the sum of the length of the slice and the length of the array beyond the slice; a slice of length up to that capacity can be created by slicing a new one from the original slice. The capacity of a slice can be discovered using the built-in function .\n\nA new, initialized slice value for a given element type may be made using the built-in function , which takes a slice type and parameters specifying the length and optionally the capacity. A slice created with always allocates a new, hidden array to which the returned slice value refers. That is, executing\n\nproduces the same slice as allocating an array and slicing it, so these two expressions are equivalent:\n\nLike arrays, slices are always one-dimensional but may be composed to construct higher-dimensional objects. With arrays of arrays, the inner arrays are, by construction, always the same length; however with slices of slices (or arrays of slices), the inner lengths may vary dynamically. Moreover, the inner slices must be initialized individually.\n\nA struct is a sequence of named elements, called fields, each of which has a name and a type. Field names may be specified explicitly (IdentifierList) or implicitly (EmbeddedField). Within a struct, non-blank field names must be unique.\n\nA field declared with a type but no explicit field name is called an embedded field. An embedded field must be specified as a type name or as a pointer to a non-interface type name , and itself may not be a pointer type or type parameter. The unqualified type name acts as the field name.\n\nThe following declaration is illegal because field names must be unique in a struct type:\n\nA field or method of an embedded field in a struct is called promoted if is a legal selector that denotes that field or method .\n\nPromoted fields act like ordinary fields of a struct except that they cannot be used as field names in composite literals of the struct.\n\nGiven a struct type and a type name , promoted methods are included in the method set of the struct as follows:\n• If contains an embedded field , the method sets of and both include promoted methods with receiver . The method set of also includes promoted methods with receiver .\n• If contains an embedded field , the method sets of and both include promoted methods with receiver or .\n\nA field declaration may be followed by an optional string literal tag, which becomes an attribute for all the fields in the corresponding field declaration. An empty tag string is equivalent to an absent tag. The tags are made visible through a reflection interface and take part in type identity for structs but are otherwise ignored.\n\nA struct type may not contain a field of type , or of a type containing as a component, directly or indirectly, if those containing types are only array or struct types.\n\nA pointer type denotes the set of all pointers to variables of a given type, called the base type of the pointer. The value of an uninitialized pointer is .\n\nA function type denotes the set of all functions with the same parameter and result types. The value of an uninitialized variable of function type is .\n\nWithin a list of parameters or results, the names (IdentifierList) must either all be present or all be absent. If present, each name stands for one item (parameter or result) of the specified type and all non-blank names in the signature must be unique. If absent, each type stands for one item of that type. Parameter and result lists are always parenthesized except that if there is exactly one unnamed result it may be written as an unparenthesized type.\n\nThe final incoming parameter in a function signature may have a type prefixed with . A function with such a parameter is called variadic and may be invoked with zero or more arguments for that parameter.\n\nAn interface type defines a type set. A variable of interface type can store a value of any type that is in the type set of the interface. Such a type is said to implement the interface. The value of an uninitialized variable of interface type is .\n\nAn interface type is specified by a list of interface elements. An interface element is either a method or a type element, where a type element is a union of one or more type terms. A type term is either a single type or a single underlying type.\n\nIn its most basic form an interface specifies a (possibly empty) list of methods. The type set defined by such an interface is the set of types which implement all of those methods, and the corresponding method set consists exactly of the methods specified by the interface. Interfaces whose type sets can be defined entirely by a list of methods are called basic interfaces.\n\nThe name of each explicitly specified method must be unique and not blank.\n\nMore than one type may implement an interface. For instance, if two types and have the method set\n\n(where stands for either or ) then the interface is implemented by both and , regardless of what other methods and may have or share.\n\nEvery type that is a member of the type set of an interface implements that interface. Any given type may implement several distinct interfaces. For instance, all types implement the empty interface which stands for the set of all (non-interface) types:\n\nFor convenience, the predeclared type is an alias for the empty interface. [Go 1.18]\n\nSimilarly, consider this interface specification, which appears within a type declaration to define an interface called :\n\nIf and also implement\n\nthey implement the interface as well as the interface.\n\nIn a slightly more general form an interface may use a (possibly qualified) interface type name as an interface element. This is called embedding interface in [Go 1.14]. The type set of is the intersection of the type sets defined by 's explicitly declared methods and the type sets of ’s embedded interfaces. In other words, the type set of is the set of all types that implement all the explicitly declared methods of and also all the methods of [Go 1.18].\n\nWhen embedding interfaces, methods with the same names must have identical signatures.\n\nIn their most general form, an interface element may also be an arbitrary type term , or a term of the form specifying the underlying type , or a union of terms [Go 1.18]. Together with method specifications, these elements enable the precise definition of an interface's type set as follows:\n• The type set of the empty interface is the set of all non-interface types.\n• The type set of a non-empty interface is the intersection of the type sets of its interface elements.\n• The type set of a method specification is the set of all non-interface types whose method sets include that method.\n• The type set of a non-interface type term is the set consisting of just that type.\n• The type set of a term of the form is the set of all types whose underlying type is .\n• The type set of a union of terms is the union of the type sets of the terms.\n\nThe quantification \"the set of all non-interface types\" refers not just to all (non-interface) types declared in the program at hand, but all possible types in all possible programs, and hence is infinite. Similarly, given the set of all non-interface types that implement a particular method, the intersection of the method sets of those types will contain exactly that method, even if all types in the program at hand always pair that method with another method.\n\nBy construction, an interface's type set never contains an interface type.\n\nIn a term of the form , the underlying type of must be itself, and cannot be an interface.\n\nThe type in a term of the form or cannot be a type parameter, and the type sets of all non-interface terms must be pairwise disjoint (the pairwise intersection of the type sets must be empty). Given a type parameter :\n\nImplementation restriction: A union (with more than one term) cannot contain the predeclared identifier or interfaces that specify methods, or embed or interfaces that specify methods.\n\nInterfaces that are not basic may only be used as type constraints, or as elements of other interfaces used as constraints. They cannot be the types of values or variables, or components of other, non-interface types.\n\nAn interface type may not embed a type element that is, contains, or embeds , directly or indirectly.\n• is not an interface and is an element of the type set of ; or\n• is an interface and the type set of is a subset of the type set of .\n\nA value of type implements an interface if implements the interface.\n\nA map is an unordered group of elements of one type, called the element type, indexed by a set of unique keys of another type, called the key type. The value of an uninitialized map is .\n\nThe comparison operators and must be fully defined for operands of the key type; thus the key type must not be a function, map, or slice. If the key type is an interface type, these comparison operators must be defined for the dynamic key values; failure will cause a run-time panic.\n\nThe number of map elements is called its length. For a map , it can be discovered using the built-in function and may change during execution. Elements may be added during execution using assignments and retrieved with index expressions; they may be removed with the and built-in function.\n\nA new, empty map value is made using the built-in function , which takes the map type and an optional capacity hint as arguments:\n\nThe initial capacity does not bound its size: maps grow to accommodate the number of items stored in them, with the exception of maps. A map is equivalent to an empty map except that no elements may be added.\n\nA channel provides a mechanism for concurrently executing functions to communicate by sending and receiving values of a specified element type. The value of an uninitialized channel is .\n\nThe optional operator specifies the channel direction, send or receive. If a direction is given, the channel is directional, otherwise it is bidirectional. A channel may be constrained only to send or only to receive by assignment or explicit conversion.\n\nThe operator associates with the leftmost possible:\n\nA new, initialized channel value can be made using the built-in function , which takes the channel type and an optional capacity as arguments:\n\nThe capacity, in number of elements, sets the size of the buffer in the channel. If the capacity is zero or absent, the channel is unbuffered and communication succeeds only when both a sender and receiver are ready. Otherwise, the channel is buffered and communication succeeds without blocking if the buffer is not full (sends) or not empty (receives). A channel is never ready for communication.\n\nA channel may be closed with the built-in function . The multi-valued assignment form of the receive operator reports whether a received value was sent before the channel was closed.\n\nA single channel may be used in send statements, receive operations, and calls to the built-in functions and by any number of goroutines without further synchronization. Channels act as first-in-first-out queues. For example, if one goroutine sends values on a channel and a second goroutine receives them, the values are received in the order sent.\n\nValues of predeclared types (see below for the interfaces and ), arrays, and structs are self-contained: Each such value contains a complete copy of all its data, and variables of such types store the entire value. For instance, an array variable provides the storage (the variables) for all elements of the array. The respective zero values are specific to the value's types; they are never .\n\nNon-nil pointer, function, slice, map, and channel values contain references to underlying data which may be shared by multiple values:\n• A pointer value is a reference to the variable holding the pointer base type value.\n• A function value contains references to the (possibly anonymous) function and enclosed variables.\n• A slice value contains the slice length, capacity, and a reference to its underlying array.\n• A map or channel value is a reference to the implementation-specific data structure of the map or channel.\n\nAn interface value may be self-contained or contain references to underlying data depending on the interface's dynamic type. The predeclared identifier is the zero value for types whose values can contain references.\n\nWhen multiple values share underlying data, changing one value may change another. For instance, changing an element of a slice will change that element in the underlying array for all slices that share the array.\n\nEach type has an underlying type: If is one of the predeclared boolean, numeric, or string types, or a type literal, the corresponding underlying type is itself. Otherwise, 's underlying type is the underlying type of the type to which refers in its declaration. For a type parameter that is the underlying type of its type constraint, which is always an interface.\n\nThe underlying type of , , , , and is . The underlying type of , , and is . The underlying type of is .\n\nEach non-interface type has a core type, which is the same as the underlying type of .\n\nAn interface has a core type if one of the following conditions is satisfied:\n• There is a single type which is the underlying type of all types in the type set of ; or\n• the type set of contains only channel types with identical element type , and all directional channels have the same direction.\n\nNo other interfaces have a core type.\n\nThe core type of an interface is, depending on the condition that is satisfied, either:\n• the type if contains only bidirectional channels, or the type or depending on the direction of the directional channels present.\n\nBy definition, a core type is never a defined type, type parameter, or interface type.\n\nSome operations (slice expressions, and ) rely on a slightly more loose form of core types which accept byte slices and strings. Specifically, if there are exactly two types, and , which are the underlying types of all types in the type set of interface , the core type of is called .\n\nNote that is not a real type; it cannot be used to declare variables or compose other types. It exists solely to describe the behavior of some operations that read from a sequence of bytes, which may be a byte slice or a string.\n\nTwo types are either identical or different.\n\nA named type is always different from any other type. Otherwise, two types are identical if their underlying type literals are structurally equivalent; that is, they have the same literal structure and corresponding components have identical types. In detail:\n• Two array types are identical if they have identical element types and the same array length.\n• Two slice types are identical if they have identical element types.\n• Two struct types are identical if they have the same sequence of fields, and if corresponding pairs of fields have the same names, identical types, and identical tags, and are either both embedded or both not embedded. Non-exported field names from different packages are always different.\n• Two pointer types are identical if they have identical base types.\n• Two function types are identical if they have the same number of parameters and result values, corresponding parameter and result types are identical, and either both functions are variadic or neither is. Parameter and result names are not required to match.\n• Two interface types are identical if they define the same type set.\n• Two map types are identical if they have identical key and element types.\n• Two channel types are identical if they have identical element types and the same direction.\n• Two instantiated types are identical if their defined types and all type arguments are identical.\n\nand are different because they are new types created by distinct type definitions; and are different because is different from ; and and are different because they are different type parameters. and are different because the former is an instantiated defined type while the latter is a type literal (but they are still assignable).\n\nA value of type is assignable to a variable of type (\" is assignable to \") if one of the following conditions applies:\n• and have identical underlying types but are not type parameters and at least one of or is not a named type.\n• and are channel types with identical element types, is a bidirectional channel, and at least one of or is not a named type.\n• is an interface type, but not a type parameter, and implements .\n• is the predeclared identifier and is a pointer, function, slice, map, channel, or interface type, but not a type parameter.\n• is an untyped constant representable by a value of type .\n\nAdditionally, if 's type or are type parameters, is assignable to a variable of type if one of the following conditions applies:\n• is the predeclared identifier , is a type parameter, and is assignable to each type in 's type set.\n• is not a named type, is a type parameter, and is assignable to each type in 's type set.\n• is a type parameter and is not a named type, and values of each type in 's type set are assignable to .\n\nA constant is representable by a value of type , where is not a type parameter, if one of the following conditions applies:\n• is in the set of values determined by .\n• is a floating-point type and can be rounded to 's precision without overflow. Rounding uses IEEE 754 round-to-even rules but with an IEEE negative zero further simplified to an unsigned zero. Note that constant values never result in an IEEE negative zero, NaN, or infinity.\n• is a complex type, and 's components and are representable by values of 's component type ( or ).\n\nIf is a type parameter, is representable by a value of type if is representable by a value of each type in 's type set.\n\nThe method set of a type determines the methods that can be called on an operand of that type. Every type has a (possibly empty) method set associated with it:\n• The method set of a defined type consists of all methods declared with receiver type .\n• The method set of a pointer to a defined type (where is neither a pointer nor an interface) is the set of all methods declared with receiver or .\n• The method set of an interface type is the intersection of the method sets of each type in the interface's type set (the resulting method set is usually just the set of declared methods in the interface).\n\nFurther rules apply to structs (and pointer to structs) containing embedded fields, as described in the section on struct types. Any other type has an empty method set.\n\nIn a method set, each method must have a unique non-blank method name.\n\nA block is a possibly empty sequence of declarations and statements within matching brace brackets.\n\nIn addition to explicit blocks in the source code, there are implicit blocks:\n• The universe block encompasses all Go source text.\n• Each package has a package block containing all Go source text for that package.\n• Each file has a file block containing all Go source text in that file.\n• Each \"if\", \"for\", and \"switch\" statement is considered to be in its own implicit block.\n• Each clause in a \"switch\" or \"select\" statement acts as an implicit block.\n\nA declaration binds a non-blank identifier to a constant, type, type parameter, variable, function, label, or package. Every identifier in a program must be declared. No identifier may be declared twice in the same block, and no identifier may be declared in both the file and package block.\n\nThe blank identifier may be used like any other identifier in a declaration, but it does not introduce a binding and thus is not declared. In the package block, the identifier may only be used for function declarations, and like the blank identifier it does not introduce a new binding.\n\nThe scope of a declared identifier is the extent of source text in which the identifier denotes the specified constant, type, variable, function, label, or package.\n\nGo is lexically scoped using blocks:\n• The scope of a predeclared identifier is the universe block.\n• The scope of an identifier denoting a constant, type, variable, or function (but not method) declared at top level (outside any function) is the package block.\n• The scope of the package name of an imported package is the file block of the file containing the import declaration.\n• The scope of an identifier denoting a method receiver, function parameter, or result variable is the function body.\n• The scope of an identifier denoting a type parameter of a function or declared by a method receiver begins after the name of the function and ends at the end of the function body.\n• The scope of an identifier denoting a type parameter of a type begins after the name of the type and ends at the end of the TypeSpec.\n• The scope of a constant or variable identifier declared inside a function begins at the end of the ConstSpec or VarSpec (ShortVarDecl for short variable declarations) and ends at the end of the innermost containing block.\n• The scope of a type identifier declared inside a function begins at the identifier in the TypeSpec and ends at the end of the innermost containing block.\n\nAn identifier declared in a block may be redeclared in an inner block. While the identifier of the inner declaration is in scope, it denotes the entity declared by the inner declaration.\n\nThe package clause is not a declaration; the package name does not appear in any scope. Its purpose is to identify the files belonging to the same package and to specify the default package name for import declarations.\n\nLabels are declared by labeled statements and are used in the \"break\", \"continue\", and \"goto\" statements. It is illegal to define a label that is never used. In contrast to other identifiers, labels are not block scoped and do not conflict with identifiers that are not labels. The scope of a label is the body of the function in which it is declared and excludes the body of any nested function.\n\nThe blank identifier is represented by the underscore character . It serves as an anonymous placeholder instead of a regular (non-blank) identifier and has special meaning in declarations, as an operand, and in assignment statements.\n\nThe following identifiers are implicitly declared in the universe block [Go 1.18] [Go 1.21]:\n\nAn identifier may be exported to permit access to it from another package. An identifier is exported if both:\n• the first character of the identifier's name is a Unicode uppercase letter (Unicode character category Lu); and\n• the identifier is declared in the package block or it is a field name or method name.\n\nAll other identifiers are not exported.\n\nGiven a set of identifiers, an identifier is called unique if it is different from every other in the set. Two identifiers are different if they are spelled differently, or if they appear in different packages and are not exported. Otherwise, they are the same.\n\nA constant declaration binds a list of identifiers (the names of the constants) to the values of a list of constant expressions. The number of identifiers must be equal to the number of expressions, and the nth identifier on the left is bound to the value of the nth expression on the right.\n\nIf the type is present, all constants take the type specified, and the expressions must be assignable to that type, which must not be a type parameter. If the type is omitted, the constants take the individual types of the corresponding expressions. If the expression values are untyped constants, the declared constants remain untyped and the constant identifiers denote the constant values. For instance, if the expression is a floating-point literal, the constant identifier denotes a floating-point constant, even if the literal's fractional part is zero.\n\nWithin a parenthesized declaration list the expression list may be omitted from any but the first ConstSpec. Such an empty list is equivalent to the textual substitution of the first preceding non-empty expression list and its type if any. Omitting the list of expressions is therefore equivalent to repeating the previous list. The number of identifiers must be equal to the number of expressions in the previous list. Together with the constant generator this mechanism permits light-weight declaration of sequential values:\n\nWithin a constant declaration, the predeclared identifier represents successive untyped integer constants. Its value is the index of the respective ConstSpec in that constant declaration, starting at zero. It can be used to construct a set of related constants:\n\nBy definition, multiple uses of in the same ConstSpec all have the same value:\n\nThis last example exploits the implicit repetition of the last non-empty expression list.\n\nA type declaration binds an identifier, the type name, to a type. Type declarations come in two forms: alias declarations and type definitions.\n\nAn alias declaration binds an identifier to the given type [Go 1.9].\n\nWithin the scope of the identifier, it serves as an alias for the given type.\n\nIf the alias declaration specifies type parameters [Go 1.24], the type name denotes a generic alias. Generic aliases must be instantiated when they are used.\n\nIn an alias declaration the given type cannot be a type parameter.\n\nA type definition creates a new, distinct type with the same underlying type and operations as the given type and binds an identifier, the type name, to it.\n\nThe new type is called a defined type. It is different from any other type, including the type it is created from.\n\nA defined type may have methods associated with it. It does not inherit any methods bound to the given type, but the method set of an interface type or of elements of a composite type remains unchanged:\n\nType definitions may be used to define different boolean, numeric, or string types and associate methods with them:\n\nIf the type definition specifies type parameters, the type name denotes a generic type. Generic types must be instantiated when they are used.\n\nIn a type definition the given type cannot be a type parameter.\n\nA generic type may also have methods associated with it. In this case, the method receivers must declare the same number of type parameters as present in the generic type definition.\n\nA type parameter list declares the type parameters of a generic function or type declaration. The type parameter list looks like an ordinary function parameter list except that the type parameter names must all be present and the list is enclosed in square brackets rather than parentheses [Go 1.18].\n\nAll non-blank names in the list must be unique. Each name declares a type parameter, which is a new and different named type that acts as a placeholder for an (as of yet) unknown type in the declaration. The type parameter is replaced with a type argument upon instantiation of the generic function or type.\n\nJust as each ordinary function parameter has a parameter type, each type parameter has a corresponding (meta-)type which is called its type constraint.\n\nA parsing ambiguity arises when the type parameter list for a generic type declares a single type parameter with a constraint such that the text forms a valid expression:\n\nIn these rare cases, the type parameter list is indistinguishable from an expression and the type declaration is parsed as an array type declaration. To resolve the ambiguity, embed the constraint in an interface or use a trailing comma:\n\nType parameters may also be declared by the receiver specification of a method declaration associated with a generic type.\n\nWithin a type parameter list of a generic type , a type constraint may not (directly, or indirectly through the type parameter list of another generic type) refer to .\n\nA type constraint is an interface that defines the set of permissible type arguments for the respective type parameter and controls the operations supported by values of that type parameter [Go 1.18].\n\nIf the constraint is an interface literal of the form where is an embedded type element (not a method), in a type parameter list the enclosing may be omitted for convenience:\n\nThe predeclared interface type denotes the set of all non-interface types that are strictly comparable [Go 1.18].\n\nEven though interfaces that are not type parameters are comparable, they are not strictly comparable and therefore they do not implement . However, they satisfy .\n\nThe interface and interfaces that (directly or indirectly) embed may only be used as type constraints. They cannot be the types of values or variables, or components of other, non-interface types.\n\nA type argument satisfies a type constraint if is an element of the type set defined by ; in other words, if implements . As an exception, a strictly comparable type constraint may also be satisfied by a comparable (not necessarily strictly comparable) type argument [Go 1.20]. More precisely:\n• can be written in the form , where is a basic interface and is comparable and implements .\n\nBecause of the exception in the constraint satisfaction rule, comparing operands of type parameter type may panic at run-time (even though comparable type parameters are always strictly comparable).\n\nA variable declaration creates one or more variables, binds corresponding identifiers to them, and gives each a type and an initial value.\n\nIf a list of expressions is given, the variables are initialized with the expressions following the rules for assignment statements. Otherwise, each variable is initialized to its zero value.\n\nIf a type is present, each variable is given that type. Otherwise, each variable is given the type of the corresponding initialization value in the assignment. If that value is an untyped constant, it is first implicitly converted to its default type; if it is an untyped boolean value, it is first implicitly converted to type . The predeclared identifier cannot be used to initialize a variable with no explicit type.\n\nImplementation restriction: A compiler may make it illegal to declare a variable inside a function body if the variable is never used.\n\nIt is shorthand for a regular variable declaration with initializer expressions but no types:\n\nUnlike regular variable declarations, a short variable declaration may redeclare variables provided they were originally declared earlier in the same block (or the parameter lists if the block is the function body) with the same type, and at least one of the non-blank variables is new. As a consequence, redeclaration can only appear in a multi-variable short declaration. Redeclaration does not introduce a new variable; it just assigns a new value to the original. The non-blank variable names on the left side of must be unique.\n\nShort variable declarations may appear only inside functions. In some contexts such as the initializers for \"if\", \"for\", or \"switch\" statements, they can be used to declare local temporary variables.\n\nA function declaration binds an identifier, the function name, to a function.\n\nIf the function's signature declares result parameters, the function body's statement list must end in a terminating statement.\n\nIf the function declaration specifies type parameters, the function name denotes a generic function. A generic function must be instantiated before it can be called or used as a value.\n\nA function declaration without type parameters may omit the body. Such a declaration provides the signature for a function implemented outside Go, such as an assembly routine.\n\nA method is a function with a receiver. A method declaration binds an identifier, the method name, to a method, and associates the method with the receiver's base type.\n\nThe receiver is specified via an extra parameter section preceding the method name. That parameter section must declare a single non-variadic parameter, the receiver. Its type must be a defined type or a pointer to a defined type , possibly followed by a list of type parameter names enclosed in square brackets. is called the receiver base type. A receiver base type cannot be a pointer or interface type and it must be defined in the same package as the method. The method is said to be bound to its receiver base type and the method name is visible only within selectors for type or .\n\nA non-blank receiver identifier must be unique in the method signature. If the receiver's value is not referenced inside the body of the method, its identifier may be omitted in the declaration. The same applies in general to parameters of functions and methods.\n\nFor a base type, the non-blank names of methods bound to it must be unique. If the base type is a struct type, the non-blank method and field names must be distinct.\n\nbind the methods and , with receiver type , to the base type .\n\nIf the receiver base type is a generic type, the receiver specification must declare corresponding type parameters for the method to use. This makes the receiver type parameters available to the method. Syntactically, this type parameter declaration looks like an instantiation of the receiver base type: the type arguments must be identifiers denoting the type parameters being declared, one for each type parameter of the receiver base type. The type parameter names do not need to match their corresponding parameter names in the receiver base type definition, and all non-blank parameter names must be unique in the receiver parameter section and the method signature. The receiver type parameter constraints are implied by the receiver base type definition: corresponding type parameters have corresponding constraints.\n\nIf the receiver type is denoted by (a pointer to) an alias, the alias must not be generic and it must not denote an instantiated generic type, neither directly nor indirectly via another alias, and irrespective of pointer indirections.\n\nAn expression specifies the computation of a value by applying operators and functions to operands.\n\nOperands denote the elementary values in an expression. An operand may be a literal, a (possibly qualified) non-blank identifier denoting a constant, variable, or function, or a parenthesized expression.\n\nAn operand name denoting a generic function may be followed by a list of type arguments; the resulting operand is an instantiated function.\n\nThe blank identifier may appear as an operand only on the left-hand side of an assignment statement.\n\nImplementation restriction: A compiler need not report an error if an operand's type is a type parameter with an empty type set. Functions with such type parameters cannot be instantiated; any attempt will lead to an error at the instantiation site.\n\nA qualified identifier is an identifier qualified with a package name prefix. Both the package name and the identifier must not be blank.\n\nA qualified identifier accesses an identifier in a different package, which must be imported. The identifier must be exported and declared in the package block of that package.\n\nComposite literals construct new composite values each time they are evaluated. They consist of the type of the literal followed by a brace-bound list of elements. Each element may optionally be preceded by a corresponding key.\n\nThe LiteralType's core type must be a struct, array, slice, or map type (the syntax enforces this constraint except when the type is given as a TypeName). The types of the elements and keys must be assignable to the respective field, element, and key types of type ; there is no additional conversion. The key is interpreted as a field name for struct literals, an index for array and slice literals, and a key for map literals. For map literals, all elements must have a key. It is an error to specify multiple elements with the same field name or constant key value. For non-constant map keys, see the section on evaluation order.\n\nFor struct literals the following rules apply:\n• A key must be a field name declared in the struct type.\n• An element list that does not contain any keys must list an element for each struct field in the order in which the fields are declared.\n• If any element has a key, every element must have a key.\n• An element list that contains keys does not need to have an element for each struct field. Omitted fields get the zero value for that field.\n• A literal may omit the element list; such a literal evaluates to the zero value for its type.\n• It is an error to specify an element for a non-exported field of a struct belonging to a different package.\n\nFor array and slice literals the following rules apply:\n• Each element has an associated integer index marking its position in the array.\n• An element with a key uses the key as its index. The key must be a non-negative constant representable by a value of type ; and if it is typed it must be of integer type.\n• An element without a key uses the previous element's index plus one. If the first element has no key, its index is zero.\n\nTaking the address of a composite literal generates a pointer to a unique variable initialized with the literal's value.\n\nNote that the zero value for a slice or map type is not the same as an initialized but empty value of the same type. Consequently, taking the address of an empty slice or map composite literal does not have the same effect as allocating a new slice or map value with new.\n\nThe length of an array literal is the length specified in the literal type. If fewer elements than the length are provided in the literal, the missing elements are set to the zero value for the array element type. It is an error to provide elements with index values outside the index range of the array. The notation specifies an array length equal to the maximum element index plus one.\n\nA slice literal describes the entire underlying array literal. Thus the length and capacity of a slice literal are the maximum element index plus one. A slice literal has the form\n\nand is shorthand for a slice operation applied to an array:\n\nWithin a composite literal of array, slice, or map type , elements or map keys that are themselves composite literals may elide the respective literal type if it is identical to the element or key type of . Similarly, elements or keys that are addresses of composite literals may elide the when the element or key type is .\n\nA parsing ambiguity arises when a composite literal using the TypeName form of the LiteralType appears as an operand between the keyword and the opening brace of the block of an \"if\", \"for\", or \"switch\" statement, and the composite literal is not enclosed in parentheses, square brackets, or curly braces. In this rare case, the opening brace of the literal is erroneously parsed as the one introducing the block of statements. To resolve the ambiguity, the composite literal must appear within parentheses.\n\nA function literal can be assigned to a variable or invoked directly.\n\nFunction literals are closures: they may refer to variables defined in a surrounding function. Those variables are then shared between the surrounding function and the function literal, and they survive as long as they are accessible.\n\nPrimary expressions are the operands for unary and binary expressions.\n\nFor a primary expression that is not a package name, the selector expression\n\ndenotes the field or method of the value (or sometimes ; see below). The identifier is called the (field or method) selector; it must not be the blank identifier. The type of the selector expression is the type of . If is a package name, see the section on qualified identifiers.\n\nA selector may denote a field or method of a type , or it may refer to a field or method of a nested embedded field of . The number of embedded fields traversed to reach is called its depth in . The depth of a field or method declared in is zero. The depth of a field or method declared in an embedded field in is the depth of in plus one.\n\nThe following rules apply to selectors:\n• For a value of type or where is not a pointer or interface type, denotes the field or method at the shallowest depth in where there is such an . If there is not exactly one with shallowest depth, the selector expression is illegal.\n• For a value of type where is an interface type, denotes the actual method with name of the dynamic value of . If there is no method with name in the method set of , the selector expression is illegal.\n• As an exception, if the type of is a defined pointer type and is a valid selector expression denoting a field (but not a method), is shorthand for .\n• In all other cases, is illegal.\n• If is of pointer type and has the value and denotes a struct field, assigning to or evaluating causes a run-time panic.\n• If is of interface type and has the value , calling or evaluating the method causes a run-time panic.\n\nFor example, given the declarations:\n\nbut the following is invalid:\n\nIf is in the method set of type , is a function that is callable as a regular function with the same arguments as prefixed by an additional argument that is the receiver of the method.\n\nConsider a struct type with two methods, , whose receiver is of type , and , whose receiver is of type .\n\nyields a function equivalent to but with an explicit receiver as its first argument; it has signature\n\nThat function may be called normally with an explicit receiver, so these five invocations are equivalent:\n\nFor a method with a value receiver, one can derive a function with an explicit pointer receiver, so\n\nSuch a function indirects through the receiver to create a value to pass as the receiver to the underlying method; the method does not overwrite the value whose address is passed in the function call.\n\nThe final case, a value-receiver function for a pointer-receiver method, is illegal because pointer-receiver methods are not in the method set of the value type.\n\nFunction values derived from methods are called with function call syntax; the receiver is provided as the first argument to the call. That is, given , is invoked as not . To construct a function that binds the receiver, use a function literal or method value.\n\nIt is legal to derive a function value from a method of an interface type. The resulting function takes an explicit receiver of that interface type.\n\nIf the expression has static type and is in the method set of type , is called a method value. The method value is a function value that is callable with the same arguments as a method call of . The expression is evaluated and saved during the evaluation of the method value; the saved copy is then used as the receiver in any calls, which may be executed later.\n\nThe type may be an interface or non-interface type.\n\nAs in the discussion of method expressions above, consider a struct type with two methods, , whose receiver is of type , and , whose receiver is of type .\n\nThese two invocations are equivalent:\n\nAs with selectors, a reference to a non-interface method with a value receiver using a pointer will automatically dereference that pointer: is equivalent to .\n\nAs with method calls, a reference to a non-interface method with a pointer receiver using an addressable value will automatically take the address of that value: is equivalent to .\n\nAlthough the examples above use non-interface types, it is also legal to create a method value from a value of interface type.\n\ndenotes the element of the array, pointer to array, slice, string or map indexed by . The value is called the index or map key, respectively. The following rules apply:\n\nIf is neither a map nor a type parameter:\n• the index must be an untyped constant or its core type must be an integer\n• a constant index must be non-negative and representable by a value of type\n• a constant index that is untyped is given type\n• the index is in range if , otherwise it is out of range\n• a constant index must be in range\n• if is out of range at run time, a run-time panic occurs\n• is the array element at index and the type of is the element type of\n\nFor of pointer to array type:\n• if is out of range at run time, a run-time panic occurs\n• is the slice element at index and the type of is the element type of\n• a constant index must be in range if the string is also constant\n• if is out of range at run time, a run-time panic occurs\n• is the non-constant byte value at index and the type of is\n• may not be assigned to\n• 's type must be assignable to the key type of\n• if the map contains an entry with key , is the map element with key and the type of is the element type of\n• if the map is or does not contain such an entry, is the zero value for the element type of\n• The index expression must be valid for values of all types in 's type set.\n• The element types of all types in 's type set must be identical. In this context, the element type of a string type is .\n• If there is a map type in the type set of , all types in that type set must be map types, and the respective key types must be all identical.\n• is the array, slice, or string element at index , or the map element with key of the type argument that is instantiated with, and the type of is the type of the (identical) element types.\n• may not be assigned to if 's type set includes string types.\n\nAn index expression on a map of type used in an assignment statement or initialization of the special form\n\nyields an additional untyped boolean value. The value of is if the key is present in the map, and otherwise.\n\nAssigning to an element of a map causes a run-time panic.\n\nSlice expressions construct a substring or slice from a string, array, pointer to array, or slice. There are two variants: a simple form that specifies a low and high bound, and a full form that also specifies a bound on the capacity.\n\nconstructs a substring or slice. The core type of must be a string, array, pointer to array, slice, or a . The indices and select which elements of operand appear in the result. The result has indices starting at 0 and length equal to - . After slicing the array\n\nthe slice has type , length 3, capacity 4, and elements\n\nFor convenience, any of the indices may be omitted. A missing index defaults to zero; a missing index defaults to the length of the sliced operand:\n\nIf is a pointer to an array, is shorthand for .\n\nFor arrays or strings, the indices are in range if <= <= <= , otherwise they are out of range. For slices, the upper index bound is the slice capacity rather than the length. A constant index must be non-negative and representable by a value of type ; for arrays or constant strings, constant indices must also be in range. If both indices are constant, they must satisfy . If the indices are out of range at run time, a run-time panic occurs.\n\nExcept for untyped strings, if the sliced operand is a string or slice, the result of the slice operation is a non-constant value of the same type as the operand. For untyped string operands the result is a non-constant value of type . If the sliced operand is an array, it must be addressable and the result of the slice operation is a slice with the same element type as the array.\n\nIf the sliced operand of a valid slice expression is a slice, the result is a slice. Otherwise, if the result is a slice, it shares its underlying array with the operand.\n\nconstructs a slice of the same type, and with the same length and elements as the simple slice expression . Additionally, it controls the resulting slice's capacity by setting it to . Only the first index may be omitted; it defaults to 0. The core type of must be an array, pointer to array, or slice (but not a string). After slicing the array\n\nthe slice has type , length 2, capacity 4, and elements\n\nAs for simple slice expressions, if is a pointer to an array, is shorthand for . If the sliced operand is an array, it must be addressable.\n\nThe indices are in range if , otherwise they are out of range. A constant index must be non-negative and representable by a value of type ; for arrays, constant indices must also be in range. If multiple indices are constant, the constants that are present must be in range relative to each other. If the indices are out of range at run time, a run-time panic occurs.\n\nFor an expression of interface type, but not a type parameter, and a type , the primary expression\n\nasserts that is not and that the value stored in is of type . The notation is called a type assertion.\n\nMore precisely, if is not an interface type, asserts that the dynamic type of is identical to the type . In this case, must implement the (interface) type of ; otherwise the type assertion is invalid since it is not possible for to store a value of type . If is an interface type, asserts that the dynamic type of implements the interface .\n\nIf the type assertion holds, the value of the expression is the value stored in and its type is . If the type assertion is false, a run-time panic occurs. In other words, even though the dynamic type of is known only at run time, the type of is known to be in a correct program.\n\nA type assertion used in an assignment statement or initialization of the special form\n\nyields an additional untyped boolean value. The value of is if the assertion holds. Otherwise it is and the value of is the zero value for type . No run-time panic occurs in this case.\n\nGiven an expression with a core type of function type,\n\ncalls with arguments . Except for one special case, arguments must be single-valued expressions assignable to the parameter types of and are evaluated before the function is called. The type of the expression is the result type of . A method invocation is similar but the method itself is specified as a selector upon a value of the receiver type for the method.\n\nIf denotes a generic function, it must be instantiated before it can be called or used as a function value.\n\nIn a function call, the function value and arguments are evaluated in the usual order. After they are evaluated, new storage is allocated for the function's variables, which includes its parameters and results. Then, the arguments of the call are passed to the function, which means that they are assigned to their corresponding function parameters, and the called function begins execution. The return parameters of the function are passed back to the caller when the function returns.\n\nAs a special case, if the return values of a function or method are equal in number and individually assignable to the parameters of another function or method , then the call will invoke after passing the return values of to the parameters of in order. The call of must contain no parameters other than the call of , and must have at least one return value. If has a final parameter, it is assigned the return values of that remain after assignment of regular parameters.\n\nA method call is valid if the method set of (the type of) contains and the argument list can be assigned to the parameter list of . If is addressable and 's method set contains , is shorthand for :\n\nThere is no distinct method type and there are no method literals.\n\nIf is variadic with a final parameter of type , then within the type of is equivalent to type . If is invoked with no actual arguments for , the value passed to is . Otherwise, the value passed is a new slice of type with a new underlying array whose successive elements are the actual arguments, which all must be assignable to . The length and capacity of the slice is therefore the number of arguments bound to and may differ for each call site.\n\nGiven the function and calls\n\nwithin , will have the value in the first call, and in the second.\n\nIf the final argument is assignable to a slice type and is followed by , it is passed unchanged as the value for a parameter. In this case no new slice is created.\n\nGiven the slice and call\n\nwithin , will have the same value as with the same underlying array.\n\nA generic function or type is instantiated by substituting type arguments for the type parameters [Go 1.18]. Instantiation proceeds in two steps:\n• Each type argument is substituted for its corresponding type parameter in the generic declaration. This substitution happens across the entire function or type declaration, including the type parameter list itself and any types in that list.\n• After substitution, each type argument must satisfy the constraint (instantiated, if necessary) of the corresponding type parameter. Otherwise instantiation fails.\n\nInstantiating a type results in a new non-generic named type; instantiating a function produces a new non-generic function.\n\nWhen using a generic function, type arguments may be provided explicitly, or they may be partially or completely inferred from the context in which the function is used. Provided that they can be inferred, type argument lists may be omitted entirely if the function is:\n• assigned to a variable with a known type\n• passed as an argument to another function, or\n\nIn all other cases, a (possibly partial) type argument list must be present. If a type argument list is absent or partial, all missing type arguments must be inferrable from the context in which the function is used.\n\nA partial type argument list cannot be empty; at least the first argument must be present. The list is a prefix of the full list of type arguments, leaving the remaining arguments to be inferred. Loosely speaking, type arguments may be omitted from \"right to left\".\n\nFor a generic type, all type arguments must always be provided explicitly.\n\nA use of a generic function may omit some or all type arguments if they can be inferred from the context within which the function is used, including the constraints of the function's type parameters. Type inference succeeds if it can infer the missing type arguments and instantiation succeeds with the inferred type arguments. Otherwise, type inference fails and the program is invalid.\n\nType inference uses the type relationships between pairs of types for inference: For instance, a function argument must be assignable to its respective function parameter; this establishes a relationship between the type of the argument and the type of the parameter. If either of these two types contains type parameters, type inference looks for the type arguments to substitute the type parameters with such that the assignability relationship is satisfied. Similarly, type inference uses the fact that a type argument must satisfy the constraint of its respective type parameter.\n\nEach such pair of matched types corresponds to a type equation containing one or multiple type parameters, from one or possibly multiple generic functions. Inferring the missing type arguments means solving the resulting set of type equations for the respective type parameters.\n\nFor example, given\n\nthe variable of type must be assignable to the function parameter type for the program to be valid. To reduce complexity, type inference ignores the directionality of assignments, so the type relationship between and can be expressed via the (symmetric) type equation (or for that matter), where the in indicates that the LHS and RHS types must match per assignability rules (see the section on type unification for details). Similarly, the type parameter must satisfy its constraint . This can be expressed as where stands for \" satisfies constraint \". These observations lead to a set of two equations\n\nwhich now can be solved for the type parameters and . From (1) a compiler can infer that the type argument for is . Similarly, because the underlying type of is and must match of the constraint, a compiler can infer that must be . Thus, for these two equations, type inference infers\n\nGiven a set of type equations, the type parameters to solve for are the type parameters of the functions that need to be instantiated and for which no explicit type arguments is provided. These type parameters are called bound type parameters. For instance, in the example above, the type parameters and are bound to . An argument to a generic function call may be a generic function itself. The type parameters of that function are included in the set of bound type parameters. The types of function arguments may contain type parameters from other functions (such as a generic function enclosing a function call). Those type parameters may also appear in type equations but they are not bound in that context. Type equations are always solved for the bound type parameters only.\n\nType inference supports calls of generic functions and assignments of generic functions to (explicitly function-typed) variables. This includes passing generic functions as arguments to other (possibly also generic) functions, and returning generic functions as results. Type inference operates on a set of equations specific to each of these cases. The equations are as follows (type argument lists are omitted for clarity):\n• For a function call where or a function argument is a generic function: \n\n Each pair of corresponding function arguments and parameters where is not an untyped constant yields an equation . \n\n If is an untyped constant , and is a bound type parameter , the pair is collected separately from the type equations.\n• For an assignment of a generic function to a (non-generic) variable of function type: \n\n .\n• For a return statement where is a generic function returned as a result to a (non-generic) result variable of function type: \n\n .\n\nAdditionally, each type parameter and corresponding type constraint yields the type equation .\n\nType inference gives precedence to type information obtained from typed operands before considering untyped constants. Therefore, inference proceeds in two phases:\n• The type equations are solved for the bound type parameters using type unification. If unification fails, type inference fails.\n• For each bound type parameter for which no type argument has been inferred yet and for which one or more pairs with that same type parameter were collected, determine the constant kind of the constants in all those pairs the same way as for constant expressions. The type argument for is the default type for the determined constant kind. If a constant kind cannot be determined due to conflicting constant kinds, type inference fails.\n\nIf not all type arguments have been found after these two phases, type inference fails.\n\nIf the two phases are successful, type inference determined a type argument for each bound type parameter:\n\nA type argument may be a composite type, containing other bound type parameters as element types (or even be just another bound type parameter). In a process of repeated simplification, the bound type parameters in each type argument are substituted with the respective type arguments for those type parameters until each type argument is free of bound type parameters.\n\nIf type arguments contain cyclic references to themselves through bound type parameters, simplification and thus type inference fails. Otherwise, type inference succeeds.\n\nType inference solves type equations through type unification. Type unification recursively compares the LHS and RHS types of an equation, where either or both types may be or contain bound type parameters, and looks for type arguments for those type parameters such that the LHS and RHS match (become identical or assignment-compatible, depending on context). To that effect, type inference maintains a map of bound type parameters to inferred type arguments; this map is consulted and updated during type unification. Initially, the bound type parameters are known but the map is empty. During type unification, if a new type argument is inferred, the respective mapping from type parameter to argument is added to the map. Conversely, when comparing types, a known type argument (a type argument for which a map entry already exists) takes the place of its corresponding type parameter. As type inference progresses, the map is populated more and more until all equations have been considered, or until unification fails. Type inference succeeds if no unification step fails and the map has an entry for each type parameter.\n\nFor example, given the type equation with the bound type parameter\n\ntype inference starts with an empty map. Unification first compares the top-level structure of the LHS and RHS types. Both are arrays of the same length; they unify if the element types unify. Both element types are structs; they unify if they have the same number of fields with the same names and if the field types unify. The type argument for is not known yet (there is no map entry), so unifying with adds the mapping to the map. Unifying the types of the field requires unifying and and thus and . Since the type argument for is known at this point (there is a map entry for ), its type argument takes the place of . And since is identical to , this unification step succeeds as well. Unification of the LHS and RHS of the equation is now finished. Type inference succeeds because there is only one type equation, no unification step failed, and the map is fully populated.\n\nUnification uses a combination of exact and loose unification depending on whether two types have to be identical, assignment-compatible, or only structurally equal. The respective type unification rules are spelled out in detail in the Appendix.\n\nFor an equation of the form , where and are types involved in an assignment (including parameter passing and return statements), the top-level type structures may unify loosely but element types must unify exactly, matching the rules for assignments.\n\nFor an equation of the form , where is a type parameter and its corresponding constraint, the unification rules are bit more complicated:\n• If has a core type and has a known type argument , and must unify loosely. If does not have a known type argument and contains exactly one type term that is not an underlying (tilde) type, unification adds the mapping to the map.\n• If does not have a core type and has a known type argument , must have all methods of , if any, and corresponding method types must unify exactly.\n\nWhen solving type equations from type constraints, solving one equation may infer additional type arguments, which in turn may enable solving other equations that depend on those type arguments. Type inference repeats type unification as long as new type arguments are inferred.\n\nComparisons are discussed elsewhere. For other binary operators, the operand types must be identical unless the operation involves shifts or untyped constants. For operations involving constants only, see the section on constant expressions.\n\nExcept for shift operations, if one operand is an untyped constant and the other operand is not, the constant is implicitly converted to the type of the other operand.\n\nThe right operand in a shift expression must have integer type [Go 1.13] or be an untyped constant representable by a value of type . If the left operand of a non-constant shift expression is an untyped constant, it is first implicitly converted to the type it would assume if the shift expression were replaced by its left operand alone.\n\nUnary operators have the highest precedence. As the and operators form statements, not expressions, they fall outside the operator hierarchy. As a consequence, statement is the same as .\n\nThere are five precedence levels for binary operators. Multiplication operators bind strongest, followed by addition operators, comparison operators, (logical AND), and finally (logical OR):\n\nBinary operators of the same precedence associate from left to right. For instance, is the same as .\n\nArithmetic operators apply to numeric values and yield a result of the same type as the first operand. The four standard arithmetic operators ( , , , ) apply to integer, floating-point, and complex types; also applies to strings. The bitwise logical and shift operators apply to integers only.\n\nIf the operand type is a type parameter, the operator must apply to each type in that type set. The operands are represented as values of the type argument that the type parameter is instantiated with, and the operation is computed with the precision of that type argument. For example, given the function:\n\nthe product and the addition are computed with or precision, respectively, depending on the type argument for .\n\nFor two integer values and , the integer quotient and remainder satisfy the following relationships:\n\nwith truncated towards zero (\"truncated division\").\n\nThe one exception to this rule is that if the dividend is the most negative value for the int type of , the quotient is equal to (and ) due to two's-complement integer overflow:\n\nIf the divisor is a constant, it must not be zero. If the divisor is zero at run time, a run-time panic occurs. If the dividend is non-negative and the divisor is a constant power of 2, the division may be replaced by a right shift, and computing the remainder may be replaced by a bitwise AND operation:\n\nThe shift operators shift the left operand by the shift count specified by the right operand, which must be non-negative. If the shift count is negative at run time, a run-time panic occurs. The shift operators implement arithmetic shifts if the left operand is a signed integer and logical shifts if it is an unsigned integer. There is no upper limit on the shift count. Shifts behave as if the left operand is shifted times by 1 for a shift count of . As a result, is the same as and is the same as but truncated towards negative infinity.\n\nFor integer operands, the unary operators , , and are defined as follows:\n\nFor unsigned integer values, the operations , , , and are computed modulo 2n, where n is the bit width of the unsigned integer's type. Loosely speaking, these unsigned integer operations discard high bits upon overflow, and programs may rely on \"wrap around\".\n\nFor signed integers, the operations , , , , and may legally overflow and the resulting value exists and is deterministically defined by the signed integer representation, the operation, and its operands. Overflow does not cause a run-time panic. A compiler may not optimize code under the assumption that overflow does not occur. For instance, it may not assume that is always true.\n\nFor floating-point and complex numbers, is the same as , while is the negation of . The result of a floating-point or complex division by zero is not specified beyond the IEEE 754 standard; whether a run-time panic occurs is implementation-specific.\n\nAn implementation may combine multiple floating-point operations into a single fused operation, possibly across statements, and produce a result that differs from the value obtained by executing and rounding the instructions individually. An explicit floating-point type conversion rounds to the precision of the target type, preventing fusion that would discard that rounding.\n\nFor instance, some architectures provide a \"fused multiply and add\" (FMA) instruction that computes without rounding the intermediate result . These examples show when a Go implementation can use that instruction:\n\nStrings can be concatenated using the operator or the assignment operator:\n\nString addition creates a new string by concatenating the operands.\n\nComparison operators compare two operands and yield an untyped boolean value.\n\nIn any comparison, the first operand must be assignable to the type of the second operand, or vice versa.\n\nThe equality operators and apply to operands of comparable types. The ordering operators , , , and apply to operands of ordered types. These terms and the result of the comparisons are defined as follows:\n• Boolean types are comparable. Two boolean values are equal if they are either both or both .\n• Integer types are comparable and ordered. Two integer values are compared in the usual way.\n• Floating-point types are comparable and ordered. Two floating-point values are compared as defined by the IEEE 754 standard.\n• Complex types are comparable. Two complex values and are equal if both and .\n• String types are comparable and ordered. Two string values are compared lexically byte-wise.\n• Pointer types are comparable. Two pointer values are equal if they point to the same variable or if both have value . Pointers to distinct zero-size variables may or may not be equal.\n• Channel types are comparable. Two channel values are equal if they were created by the same call to or if both have value .\n• Interface types that are not type parameters are comparable. Two interface values are equal if they have identical dynamic types and equal dynamic values or if both have value .\n• A value of non-interface type and a value of interface type can be compared if type is comparable and implements . They are equal if 's dynamic type is identical to and 's dynamic value is equal to .\n• Struct types are comparable if all their field types are comparable. Two struct values are equal if their corresponding non-blank field values are equal. The fields are compared in source order, and comparison stops as soon as two field values differ (or all fields have been compared).\n• Array types are comparable if their array element types are comparable. Two array values are equal if their corresponding element values are equal. The elements are compared in ascending index order, and comparison stops as soon as two element values differ (or all elements have been compared).\n• Type parameters are comparable if they are strictly comparable (see below).\n\nA comparison of two interface values with identical dynamic types causes a run-time panic if that type is not comparable. This behavior applies not only to direct interface value comparisons but also when comparing arrays of interface values or structs with interface-valued fields.\n\nSlice, map, and function types are not comparable. However, as a special case, a slice, map, or function value may be compared to the predeclared identifier . Comparison of pointer, channel, and interface values to is also allowed and follows from the general rules above.\n\nA type is strictly comparable if it is comparable and not an interface type nor composed of interface types. Specifically:\n• Struct types are strictly comparable if all their field types are strictly comparable.\n• Array types are strictly comparable if their array element types are strictly comparable.\n• Type parameters are strictly comparable if all types in their type set are strictly comparable.\n\nLogical operators apply to boolean values and yield a result of the same type as the operands. The left operand is evaluated, and then the right if the condition requires it.\n\nFor an operand of type , the address operation generates a pointer of type to . The operand must be addressable, that is, either a variable, pointer indirection, or slice indexing operation; or a field selector of an addressable struct operand; or an array indexing operation of an addressable array. As an exception to the addressability requirement, may also be a (possibly parenthesized) composite literal. If the evaluation of would cause a run-time panic, then the evaluation of does too.\n\nFor an operand of pointer type , the pointer indirection denotes the variable of type pointed to by . If is , an attempt to evaluate will cause a run-time panic.\n\nFor an operand whose core type is a channel, the value of the receive operation is the value received from the channel . The channel direction must permit receive operations, and the type of the receive operation is the element type of the channel. The expression blocks until a value is available. Receiving from a channel blocks forever. A receive operation on a closed channel can always proceed immediately, yielding the element type's zero value after any previously sent values have been received.\n\nA receive expression used in an assignment statement or initialization of the special form\n\nyields an additional untyped boolean result reporting whether the communication succeeded. The value of is if the value received was delivered by a successful send operation to the channel, or if it is a zero value generated because the channel is closed and empty.\n\nA conversion changes the type of an expression to the type specified by the conversion. A conversion may appear literally in the source, or it may be implied by the context in which an expression appears.\n\nAn explicit conversion is an expression of the form where is a type and is an expression that can be converted to type .\n\nIf the type starts with the operator or , or if the type starts with the keyword and has no result list, it must be parenthesized when necessary to avoid ambiguity:\n\nA constant value can be converted to type if is representable by a value of . As a special case, an integer constant can be explicitly converted to a string type using the same rule as for non-constant .\n\nConverting a constant to a type that is not a type parameter yields a typed constant.\n\nConverting a constant to a type parameter yields a non-constant value of that type, with the value represented as a value of the type argument that the type parameter is instantiated with. For example, given the function:\n\nthe conversion results in a non-constant value of type and the value is represented as a or a depending on the type argument for . Accordingly, if is instantiated with a type, the numeric value of the expression will be computed with the same precision as the corresponding non-constant addition.\n\nA non-constant value can be converted to type in any of these cases:\n• ignoring struct tags (see below), 's type and are not type parameters but have identical underlying types.\n• ignoring struct tags (see below), 's type and are pointer types that are not named types, and their pointer base types are not type parameters but have identical underlying types.\n• 's type and are both integer or floating point types.\n• 's type and are both complex types.\n• is an integer or a slice of bytes or runes and is a string type.\n• is a string and is a slice of bytes or runes.\n• is a slice, is an array [Go 1.20] or a pointer to an array [Go 1.17], and the slice and array types have identical element types.\n\nAdditionally, if or 's type are type parameters, can also be converted to type if one of the following conditions applies:\n• Both and are type parameters and a value of each type in 's type set can be converted to each type in 's type set.\n• Only is a type parameter and a value of each type in 's type set can be converted to .\n• Only is a type parameter and can be converted to each type in 's type set.\n\nStruct tags are ignored when comparing struct types for identity for the purpose of conversion:\n\nSpecific rules apply to (non-constant) conversions between numeric types or to and from a string type. These conversions may change the representation of and incur a run-time cost. All other conversions only change the type but not the representation of .\n\nThere is no linguistic mechanism to convert between pointers and integers. The package implements this functionality under restricted circumstances.\n\nFor the conversion of non-constant numeric values, the following rules apply:\n• When converting between integer types, if the value is a signed integer, it is sign extended to implicit infinite precision; otherwise it is zero extended. It is then truncated to fit in the result type's size. For example, if , then . The conversion always yields a valid value; there is no indication of overflow.\n• When converting a floating-point number to an integer, the fraction is discarded (truncation towards zero).\n• When converting an integer or floating-point number to a floating-point type, or a complex number to another complex type, the result value is rounded to the precision specified by the destination type. For instance, the value of a variable of type may be stored using additional precision beyond that of an IEEE 754 32-bit number, but float32(x) represents the result of rounding 's value to 32-bit precision. Similarly, may use more than 32 bits of precision, but does not.\n\nIn all non-constant conversions involving floating-point or complex values, if the result type cannot represent the value the conversion succeeds but the result value is implementation-dependent.\n\nConversions to and from a string type\n• Converting a slice of bytes to a string type yields a string whose successive bytes are the elements of the slice.\n• Converting a slice of runes to a string type yields a string that is the concatenation of the individual rune values converted to strings.\n• Converting a value of a string type to a slice of bytes type yields a non-nil slice whose successive elements are the bytes of the string. The capacity of the resulting slice is implementation-specific and may be larger than the slice length.\n• Converting a value of a string type to a slice of runes type yields a slice containing the individual Unicode code points of the string. The capacity of the resulting slice is implementation-specific and may be larger than the slice length.\n• Finally, for historical reasons, an integer value may be converted to a string type. This form of conversion yields a string containing the (possibly multi-byte) UTF-8 representation of the Unicode code point with the given integer value. Values outside the range of valid Unicode code points are converted to . Note: This form of conversion may eventually be removed from the language. The tool flags certain integer-to-string conversions as potential errors. Library functions such as or should be used instead.\n\nConversions from slice to array or array pointer\n\nConverting a slice to an array yields an array containing the elements of the underlying array of the slice. Similarly, converting a slice to an array pointer yields a pointer to the underlying array of the slice. In both cases, if the length of the slice is less than the length of the array, a run-time panic occurs.\n\nConstant expressions may contain only constant operands and are evaluated at compile time.\n\nUntyped boolean, numeric, and string constants may be used as operands wherever it is legal to use an operand of boolean, numeric, or string type, respectively.\n\nA constant comparison always yields an untyped boolean constant. If the left operand of a constant shift expression is an untyped constant, the result is an integer constant; otherwise it is a constant of the same type as the left operand, which must be of integer type.\n\nAny other operation on untyped constants results in an untyped constant of the same kind; that is, a boolean, integer, floating-point, complex, or string constant. If the untyped operands of a binary operation (other than a shift) are of different kinds, the result is of the operand's kind that appears later in this list: integer, rune, floating-point, complex. For example, an untyped integer constant divided by an untyped complex constant yields an untyped complex constant.\n\nApplying the built-in function to untyped integer, rune, or floating-point constants yields an untyped complex constant.\n\nConstant expressions are always evaluated exactly; intermediate values and the constants themselves may require precision significantly larger than supported by any predeclared type in the language. The following are legal declarations:\n\nThe divisor of a constant division or remainder operation must not be zero:\n\nThe values of typed constants must always be accurately representable by values of the constant type. The following constant expressions are illegal:\n\nThe mask used by the unary bitwise complement operator matches the rule for non-constants: the mask is all 1s for unsigned constants and -1 for signed and untyped constants.\n\nImplementation restriction: A compiler may use rounding while computing untyped floating-point or complex constant expressions; see the implementation restriction in the section on constants. This rounding may cause a floating-point constant expression to be invalid in an integer context, even if it would be integral when calculated using infinite precision, and vice versa.\n\nAt package level, initialization dependencies determine the evaluation order of individual initialization expressions in variable declarations. Otherwise, when evaluating the operands of an expression, assignment, or return statement, all function calls, method calls, receive operations, and binary logical operations are evaluated in lexical left-to-right order.\n\nFor example, in the (function-local) assignment\n\nthe function calls and communication happen in the order , (if evaluates to false), , , , , and . However, the order of those events compared to the evaluation and indexing of and the evaluation of and is not specified, except as required lexically. For instance, cannot be called before its arguments are evaluated.\n\nAt package level, initialization dependencies override the left-to-right rule for individual initialization expressions, but not for operands within each expression:\n\nThe function calls happen in the order , , , , , and .\n\nFloating-point operations within a single expression are evaluated according to the associativity of the operators. Explicit parentheses affect the evaluation by overriding the default associativity. In the expression the addition is performed before adding .\n\nA terminating statement interrupts the regular flow of control in a block. The following statements are terminating:\n• A block in which the statement list ends in a terminating statement.\n• An \"if\" statement in which:\n• the \"else\" branch is present, and\n• A \"for\" statement in which:\n• there are no \"break\" statements referring to the \"for\" statement, and\n• the loop condition is absent, and\n• the \"for\" statement does not use a range clause.\n• A \"switch\" statement in which:\n• there are no \"break\" statements referring to the \"switch\" statement,\n• there is a default case, and\n• the statement lists in each case, including the default, end in a terminating statement, or a possibly labeled \"fallthrough\" statement.\n• A \"select\" statement in which:\n• there are no \"break\" statements referring to the \"select\" statement, and\n• the statement lists in each case, including the default if present, end in a terminating statement.\n\nAll other statements are not terminating.\n\nA statement list ends in a terminating statement if the list is not empty and its final non-empty statement is terminating.\n\nThe empty statement does nothing.\n\nA labeled statement may be the target of a , or statement.\n\nWith the exception of specific built-in functions, function and method calls and receive operations can appear in statement context. Such statements may be parenthesized.\n\nThe following built-in functions are not permitted in statement context:\n\nA send statement sends a value on a channel. The channel expression's core type must be a channel, the channel direction must permit send operations, and the type of the value to be sent must be assignable to the channel's element type.\n\nBoth the channel and the value expression are evaluated before communication begins. Communication blocks until the send can proceed. A send on an unbuffered channel can proceed if a receiver is ready. A send on a buffered channel can proceed if there is room in the buffer. A send on a closed channel proceeds by causing a run-time panic. A send on a channel blocks forever.\n\nThe \"++\" and \"--\" statements increment or decrement their operands by the untyped constant . As with an assignment, the operand must be addressable or a map index expression.\n\nThe following assignment statements are semantically equivalent:\n\nAn assignment replaces the current value stored in a variable with a new value specified by an expression. An assignment statement may assign a single value to a single variable, or multiple values to a matching number of variables.\n\nEach left-hand side operand must be addressable, a map index expression, or (for assignments only) the blank identifier. Operands may be parenthesized.\n\nAn assignment operation op where op is a binary arithmetic operator is equivalent to op but evaluates only once. The op construct is a single token. In assignment operations, both the left- and right-hand expression lists must contain exactly one single-valued expression, and the left-hand expression must not be the blank identifier.\n\nA tuple assignment assigns the individual elements of a multi-valued operation to a list of variables. There are two forms. In the first, the right hand operand is a single multi-valued expression such as a function call, a channel or map operation, or a type assertion. The number of operands on the left hand side must match the number of values. For instance, if is a function returning two values,\n\nassigns the first value to and the second to . In the second form, the number of operands on the left must equal the number of expressions on the right, each of which must be single-valued, and the nth expression on the right is assigned to the nth operand on the left:\n\nThe blank identifier provides a way to ignore right-hand side values in an assignment:\n\nThe assignment proceeds in two phases. First, the operands of index expressions and pointer indirections (including implicit pointer indirections in selectors) on the left and the expressions on the right are all evaluated in the usual order. Second, the assignments are carried out in left-to-right order.\n\nIn assignments, each value must be assignable to the type of the operand to which it is assigned, with the following special cases:\n• Any typed value may be assigned to the blank identifier.\n• If an untyped constant is assigned to a variable of interface type or the blank identifier, the constant is first implicitly converted to its default type.\n• If an untyped boolean value is assigned to a variable of interface type or the blank identifier, it is first implicitly converted to type .\n\nWhen a value is assigned to a variable, only the data that is stored in the variable is replaced. If the value contains a reference, the assignment copies the reference but does not make a copy of the referenced data (such as the underlying array of a slice).\n\n\"If\" statements specify the conditional execution of two branches according to the value of a boolean expression. If the expression evaluates to true, the \"if\" branch is executed, otherwise, if present, the \"else\" branch is executed.\n\nThe expression may be preceded by a simple statement, which executes before the expression is evaluated.\n\n\"Switch\" statements provide multi-way execution. An expression or type is compared to the \"cases\" inside the \"switch\" to determine which branch to execute.\n\nThere are two forms: expression switches and type switches. In an expression switch, the cases contain expressions that are compared against the value of the switch expression. In a type switch, the cases contain types that are compared against the type of a specially annotated switch expression. The switch expression is evaluated exactly once in a switch statement.\n\nIn an expression switch, the switch expression is evaluated and the case expressions, which need not be constants, are evaluated left-to-right and top-to-bottom; the first one that equals the switch expression triggers execution of the statements of the associated case; the other cases are skipped. If no case matches and there is a \"default\" case, its statements are executed. There can be at most one default case and it may appear anywhere in the \"switch\" statement. A missing switch expression is equivalent to the boolean value .\n\nIf the switch expression evaluates to an untyped constant, it is first implicitly converted to its default type. The predeclared untyped value cannot be used as a switch expression. The switch expression type must be comparable.\n\nIf a case expression is untyped, it is first implicitly converted to the type of the switch expression. For each (possibly converted) case expression and the value of the switch expression, must be a valid comparison.\n\nIn other words, the switch expression is treated as if it were used to declare and initialize a temporary variable without explicit type; it is that value of against which each case expression is tested for equality.\n\nIn a case or default clause, the last non-empty statement may be a (possibly labeled) \"fallthrough\" statement to indicate that control should flow from the end of this clause to the first statement of the next clause. Otherwise control flows to the end of the \"switch\" statement. A \"fallthrough\" statement may appear as the last statement of all but the last clause of an expression switch.\n\nThe switch expression may be preceded by a simple statement, which executes before the expression is evaluated.\n\nImplementation restriction: A compiler may disallow multiple case expressions evaluating to the same constant. For instance, the current compilers disallow duplicate integer, floating point, or string constants in case expressions.\n\nA type switch compares types rather than values. It is otherwise similar to an expression switch. It is marked by a special switch expression that has the form of a type assertion using the keyword rather than an actual type:\n\nCases then match actual types against the dynamic type of the expression . As with type assertions, must be of interface type, but not a type parameter, and each non-interface type listed in a case must implement the type of . The types listed in the cases of a type switch must all be different.\n\nThe TypeSwitchGuard may include a short variable declaration. When that form is used, the variable is declared at the end of the TypeSwitchCase in the implicit block of each clause. In clauses with a case listing exactly one type, the variable has that type; otherwise, the variable has the type of the expression in the TypeSwitchGuard.\n\nInstead of a type, a case may use the predeclared identifier ; that case is selected when the expression in the TypeSwitchGuard is a interface value. There may be at most one case.\n\nGiven an expression of type , the following type switch:\n\nA type parameter or a generic type may be used as a type in a case. If upon instantiation that type turns out to duplicate another entry in the switch, the first matching case is chosen.\n\nThe type switch guard may be preceded by a simple statement, which executes before the guard is evaluated.\n\nThe \"fallthrough\" statement is not permitted in a type switch.\n\nA \"for\" statement specifies repeated execution of a block. There are three forms: The iteration may be controlled by a single condition, a \"for\" clause, or a \"range\" clause.\n\nIn its simplest form, a \"for\" statement specifies the repeated execution of a block as long as a boolean condition evaluates to true. The condition is evaluated before each iteration. If the condition is absent, it is equivalent to the boolean value .\n\nA \"for\" statement with a ForClause is also controlled by its condition, but additionally it may specify an init and a post statement, such as an assignment, an increment or decrement statement. The init statement may be a short variable declaration, but the post statement must not.\n\nIf non-empty, the init statement is executed once before evaluating the condition for the first iteration; the post statement is executed after each execution of the block (and only if the block was executed). Any element of the ForClause may be empty but the semicolons are required unless there is only a condition. If the condition is absent, it is equivalent to the boolean value .\n\nEach iteration has its own separate declared variable (or variables) [Go 1.22]. The variable used by the first iteration is declared by the init statement. The variable used by each subsequent iteration is declared implicitly before executing the post statement and initialized to the value of the previous iteration's variable at that moment.\n\nPrior to [Go 1.22], iterations share one set of variables instead of having their own separate variables. In that case, the example above prints\n\nA \"for\" statement with a \"range\" clause iterates through all entries of an array, slice, string or map, values received on a channel, integer values from zero to an upper limit [Go 1.22], or values passed to an iterator function's yield function [Go 1.23]. For each entry it assigns iteration values to corresponding iteration variables if present and then executes the block.\n\nThe expression on the right in the \"range\" clause is called the range expression, its core type must be an array, pointer to an array, slice, string, map, channel permitting receive operations, an integer, or a function with specific signature (see below). As with an assignment, if present the operands on the left must be addressable or map index expressions; they denote the iteration variables. If the range expression is a function, the maximum number of iteration variables depends on the function signature. If the range expression is a channel or integer, at most one iteration variable is permitted; otherwise there may be up to two. If the last iteration variable is the blank identifier, the range clause is equivalent to the same clause without that identifier.\n\nThe range expression is evaluated before beginning the loop, with one exception: if at most one iteration variable is present and or is constant, the range expression is not evaluated.\n\nFunction calls on the left are evaluated once per iteration. For each iteration, iteration values are produced as follows if the respective iteration variables are present:\n• For an array, pointer to array, or slice value , the index iteration values are produced in increasing order, starting at element index 0. If at most one iteration variable is present, the range loop produces iteration values from 0 up to and does not index into the array or slice itself. For a slice, the number of iterations is 0.\n• For a string value, the \"range\" clause iterates over the Unicode code points in the string starting at byte index 0. On successive iterations, the index value will be the index of the first byte of successive UTF-8-encoded code points in the string, and the second value, of type , will be the value of the corresponding code point. If the iteration encounters an invalid UTF-8 sequence, the second value will be , the Unicode replacement character, and the next iteration will advance a single byte in the string.\n• The iteration order over maps is not specified and is not guaranteed to be the same from one iteration to the next. If a map entry that has not yet been reached is removed during iteration, the corresponding iteration value will not be produced. If a map entry is created during iteration, that entry may be produced during the iteration or may be skipped. The choice may vary for each entry created and from one iteration to the next. If the map is , the number of iterations is 0.\n• For channels, the iteration values produced are the successive values sent on the channel until the channel is closed. If the channel is , the range expression blocks forever.\n• For an integer value , where is of integer type or an untyped integer constant, the iteration values 0 through are produced in increasing order. If is of integer type, the iteration values have that same type. Otherwise, the type of is determined as if it were assigned to the iteration variable. Specifically: if the iteration variable is preexisting, the type of the iteration values is the type of the iteration variable, which must be of integer type. Otherwise, if the iteration variable is declared by the \"range\" clause or is absent, the type of the iteration values is the default type for . If <= 0, the loop does not run any iterations.\n• For a function , the iteration proceeds by calling with a new, synthesized function as its argument. If is called before returns, the arguments to become the iteration values for executing the loop body once. After each successive loop iteration, returns true and may be called again to continue the loop. As long as the loop body does not terminate, the \"range\" clause will continue to generate iteration values this way for each call until returns. If the loop body terminates (such as by a statement), returns false and must not be called again.\n\nThe iteration variables may be declared by the \"range\" clause using a form of short variable declaration ( ). In this case their scope is the block of the \"for\" statement and each iteration has its own new variables [Go 1.22] (see also \"for\" statements with a ForClause). The variables have the types of their respective iteration values.\n\nIf the iteration variables are not explicitly declared by the \"range\" clause, they must be preexisting. In this case, the iteration values are assigned to the respective variables as in an assignment statement.\n\nA \"go\" statement starts the execution of a function call as an independent concurrent thread of control, or goroutine, within the same address space.\n\nThe expression must be a function or method call; it cannot be parenthesized. Calls of built-in functions are restricted as for expression statements.\n\nThe function value and parameters are evaluated as usual in the calling goroutine, but unlike with a regular call, program execution does not wait for the invoked function to complete. Instead, the function begins executing independently in a new goroutine. When the function terminates, its goroutine also terminates. If the function has any return values, they are discarded when the function completes.\n\nA \"select\" statement chooses which of a set of possible send or receive operations will proceed. It looks similar to a \"switch\" statement but with the cases all referring to communication operations.\n\nA case with a RecvStmt may assign the result of a RecvExpr to one or two variables, which may be declared using a short variable declaration. The RecvExpr must be a (possibly parenthesized) receive operation. There can be at most one default case and it may appear anywhere in the list of cases.\n\nExecution of a \"select\" statement proceeds in several steps:\n• For all the cases in the statement, the channel operands of receive operations and the channel and right-hand-side expressions of send statements are evaluated exactly once, in source order, upon entering the \"select\" statement. The result is a set of channels to receive from or send to, and the corresponding values to send. Any side effects in that evaluation will occur irrespective of which (if any) communication operation is selected to proceed. Expressions on the left-hand side of a RecvStmt with a short variable declaration or assignment are not yet evaluated.\n• If one or more of the communications can proceed, a single one that can proceed is chosen via a uniform pseudo-random selection. Otherwise, if there is a default case, that case is chosen. If there is no default case, the \"select\" statement blocks until at least one of the communications can proceed.\n• Unless the selected case is the default case, the respective communication operation is executed.\n• If the selected case is a RecvStmt with a short variable declaration or an assignment, the left-hand side expressions are evaluated and the received value (or values) are assigned.\n• The statement list of the selected case is executed.\n\nSince communication on channels can never proceed, a select with only channels and no default case blocks forever.\n\nA \"return\" statement in a function terminates the execution of , and optionally provides one or more result values. Any functions deferred by are executed before returns to its caller.\n\nIn a function without a result type, a \"return\" statement must not specify any result values.\n\nThere are three ways to return values from a function with a result type:\n• The return value or values may be explicitly listed in the \"return\" statement. Each expression must be single-valued and assignable to the corresponding element of the function's result type.\n• The expression list in the \"return\" statement may be a single call to a multi-valued function. The effect is as if each value returned from that function were assigned to a temporary variable with the type of the respective value, followed by a \"return\" statement listing these variables, at which point the rules of the previous case apply.\n• The expression list may be empty if the function's result type specifies names for its result parameters. The result parameters act as ordinary local variables and the function may assign values to them as necessary. The \"return\" statement returns the values of these variables.\n\nRegardless of how they are declared, all the result values are initialized to the zero values for their type upon entry to the function. A \"return\" statement that specifies results sets the result parameters before any deferred functions are executed.\n\nImplementation restriction: A compiler may disallow an empty expression list in a \"return\" statement if a different entity (constant, type, or variable) with the same name as a result parameter is in scope at the place of the return.\n\nA \"break\" statement terminates execution of the innermost \"for\", \"switch\", or \"select\" statement within the same function.\n\nIf there is a label, it must be that of an enclosing \"for\", \"switch\", or \"select\" statement, and that is the one whose execution terminates.\n\nA \"continue\" statement begins the next iteration of the innermost enclosing \"for\" loop by advancing control to the end of the loop block. The \"for\" loop must be within the same function.\n\nIf there is a label, it must be that of an enclosing \"for\" statement, and that is the one whose execution advances.\n\nA \"goto\" statement transfers control to the statement with the corresponding label within the same function.\n\nExecuting the \"goto\" statement must not cause any variables to come into scope that were not already in scope at the point of the goto. For instance, this example:\n\nis erroneous because the jump to label skips the creation of .\n\nA \"goto\" statement outside a block cannot jump to a label inside that block. For instance, this example:\n\nis erroneous because the label is inside the \"for\" statement's block but the is not.\n\nA \"fallthrough\" statement transfers control to the first statement of the next case clause in an expression \"switch\" statement. It may be used only as the final non-empty statement in such a clause.\n\nA \"defer\" statement invokes a function whose execution is deferred to the moment the surrounding function returns, either because the surrounding function executed a return statement, reached the end of its function body, or because the corresponding goroutine is panicking.\n\nThe expression must be a function or method call; it cannot be parenthesized. Calls of built-in functions are restricted as for expression statements.\n\nEach time a \"defer\" statement executes, the function value and parameters to the call are evaluated as usual and saved anew but the actual function is not invoked. Instead, deferred functions are invoked immediately before the surrounding function returns, in the reverse order they were deferred. That is, if the surrounding function returns through an explicit return statement, deferred functions are executed after any result parameters are set by that return statement but before the function returns to its caller. If a deferred function value evaluates to , execution panics when the function is invoked, not when the \"defer\" statement is executed.\n\nFor instance, if the deferred function is a function literal and the surrounding function has named result parameters that are in scope within the literal, the deferred function may access and modify the result parameters before they are returned. If the deferred function has any return values, they are discarded when the function completes. (See also the section on handling panics.)\n\nBuilt-in functions are predeclared. They are called like any other function but some of them accept a type instead of an expression as the first argument.\n\nThe built-in functions do not have standard Go types, so they can only appear in call expressions; they cannot be used as function values.\n\nThe built-in functions and assist in common slice operations. For both functions, the result is independent of whether the memory referenced by the arguments overlaps.\n\nThe variadic function appends zero or more values to a slice and returns the resulting slice of the same type as . The core type of must be a slice of type . The values are passed to a parameter of type and the respective parameter passing rules apply. As a special case, if the core type of is , also accepts a second argument with core type followed by . This form appends the bytes of the byte slice or string.\n\nIf the capacity of is not large enough to fit the additional values, allocates a new, sufficiently large underlying array that fits both the existing slice elements and the additional values. Otherwise, re-uses the underlying array.\n\nThe function copies slice elements from a source to a destination and returns the number of elements copied. The core types of both arguments must be slices with identical element type. The number of elements copied is the minimum of and . As a special case, if the destination's core type is , also accepts a source argument with core type . This form copies the bytes from the byte slice or string into the byte slice.\n\nThe built-in function takes an argument of map, slice, or type parameter type, and deletes or zeroes out all elements [Go 1.21].\n\nIf the type of the argument to is a type parameter, all types in its type set must be maps or slices, and performs the operation corresponding to the actual type argument.\n\nIf the map or slice is , is a no-op.\n\nFor an argument with a core type that is a channel, the built-in function records that no more values will be sent on the channel. It is an error if is a receive-only channel. Sending to or closing a closed channel causes a run-time panic. Closing the nil channel also causes a run-time panic. After calling , and after any previously sent values have been received, receive operations will return the zero value for the channel's type without blocking. The multi-valued receive operation returns a received value along with an indication of whether the channel is closed.\n\nThree functions assemble and disassemble complex numbers. The built-in function constructs a complex value from a floating-point real and imaginary part, while and extract the real and imaginary parts of a complex value.\n\nThe type of the arguments and return value correspond. For , the two arguments must be of the same floating-point type and the return type is the complex type with the corresponding floating-point constituents: for arguments, and for arguments. If one of the arguments evaluates to an untyped constant, it is first implicitly converted to the type of the other argument. If both arguments evaluate to untyped constants, they must be non-complex numbers or their imaginary parts must be zero, and the return value of the function is an untyped complex constant.\n\nFor and , the argument must be of complex type, and the return type is the corresponding floating-point type: for a argument, and for a argument. If the argument evaluates to an untyped constant, it must be a number, and the return value of the function is an untyped floating-point constant.\n\nThe and functions together form the inverse of , so for a value of a complex type , .\n\nIf the operands of these functions are all constants, the return value is a constant.\n\nArguments of type parameter type are not permitted.\n\nThe built-in function removes the element with key from a map . The value must be assignable to the key type of .\n\nIf the type of is a type parameter, all types in that type set must be maps, and they must all have identical key types.\n\nIf the map is or the element does not exist, is a no-op.\n\nThe built-in functions and take arguments of various types and return a result of type . The implementation guarantees that the result always fits into an .\n\nIf the argument type is a type parameter , the call (or respectively) must be valid for each type in 's type set. The result is the length (or capacity, respectively) of the argument whose type corresponds to the type argument with which was instantiated.\n\nThe capacity of a slice is the number of elements for which there is space allocated in the underlying array. At any time the following relationship holds:\n\nThe length of a slice, map or channel is 0. The capacity of a slice or channel is 0.\n\nThe expression is constant if is a string constant. The expressions and are constants if the type of is an array or pointer to an array and the expression does not contain channel receives or (non-constant) function calls; in this case is not evaluated. Otherwise, invocations of and are not constant and is evaluated.\n\nThe built-in function takes a type , optionally followed by a type-specific list of expressions. The core type of must be a slice, map or channel. It returns a value of type (not ). The memory is initialized as described in the section on initial values.\n\nEach of the size arguments and must be of integer type, have a type set containing only integer types, or be an untyped constant. A constant size argument must be non-negative and representable by a value of type ; if it is an untyped constant it is given type . If both and are provided and are constant, then must be no larger than . For slices and channels, if is negative or larger than at run time, a run-time panic occurs.\n\nCalling with a map type and size hint will create a map with initial space to hold map elements. The precise behavior is implementation-dependent.\n\nThe built-in functions and compute the smallest—or largest, respectively—value of a fixed number of arguments of ordered types. There must be at least one argument [Go 1.21].\n\nThe same type rules as for operators apply: for ordered arguments and , is valid if is valid, and the type of is the type of (and similarly for ). If all arguments are constant, the result is constant.\n\nFor numeric arguments, assuming all NaNs are equal, and are commutative and associative:\n\nFor floating-point arguments negative zero, NaN, and infinity the following rules apply:\n\nFor string arguments the result for is the first argument with the smallest (or for , largest) value, compared lexically byte-wise:\n\nThe built-in function takes a type , allocates storage for a variable of that type at run time, and returns a value of type pointing to it. The variable is initialized as described in the section on initial values.\n\nallocates storage for a variable of type , initializes it ( , ), and returns a value of type containing the address of the location.\n\nTwo built-in functions, and , assist in reporting and handling run-time panics and program-defined error conditions.\n\nWhile executing a function , an explicit call to or a run-time panic terminates the execution of . Any functions deferred by are then executed as usual. Next, any deferred functions run by 's caller are run, and so on up to any deferred by the top-level function in the executing goroutine. At that point, the program is terminated and the error condition is reported, including the value of the argument to . This termination sequence is called panicking.\n\nThe function allows a program to manage behavior of a panicking goroutine. Suppose a function defers a function that calls and a panic occurs in a function on the same goroutine in which is executing. When the running of deferred functions reaches , the return value of 's call to will be the value passed to the call of . If returns normally, without starting a new , the panicking sequence stops. In that case, the state of functions called between and the call to is discarded, and normal execution resumes. Any functions deferred by before are then run and 's execution terminates by returning to its caller.\n\nThe return value of is when the goroutine is not panicking or was not called directly by a deferred function. Conversely, if a goroutine is panicking and was called directly by a deferred function, the return value of is guaranteed not to be . To ensure this, calling with a interface value (or an untyped ) causes a run-time panic.\n\nThe function in the example below invokes the function argument and protects callers from run-time panics raised by .\n\nCurrent implementations provide several built-in functions useful during bootstrapping. These functions are documented for completeness but are not guaranteed to stay in the language. They do not return a result.\n\nImplementation restriction: and need not accept arbitrary argument types, but printing of boolean, numeric, and string types must be supported.\n\nGo programs are constructed by linking together packages. A package in turn is constructed from one or more source files that together declare constants, types, variables and functions belonging to the package and which are accessible in all files of the same package. Those elements may be exported and used in another package.\n\nEach source file consists of a package clause defining the package to which it belongs, followed by a possibly empty set of import declarations that declare packages whose contents it wishes to use, followed by a possibly empty set of declarations of functions, types, variables, and constants.\n\nA package clause begins each source file and defines the package to which the file belongs.\n\nThe PackageName must not be the blank identifier.\n\nA set of files sharing the same PackageName form the implementation of a package. An implementation may require that all source files for a package inhabit the same directory.\n\nAn import declaration states that the source file containing the declaration depends on functionality of the imported package (§Program initialization and execution) and enables access to exported identifiers of that package. The import names an identifier (PackageName) to be used for access and an ImportPath that specifies the package to be imported.\n\nThe PackageName is used in qualified identifiers to access exported identifiers of the package within the importing source file. It is declared in the file block. If the PackageName is omitted, it defaults to the identifier specified in the package clause of the imported package. If an explicit period ( ) appears instead of a name, all the package's exported identifiers declared in that package's package block will be declared in the importing source file's file block and must be accessed without a qualifier.\n\nThe interpretation of the ImportPath is implementation-dependent but it is typically a substring of the full file name of the compiled package and may be relative to a repository of installed packages.\n\nImplementation restriction: A compiler may restrict ImportPaths to non-empty strings using only characters belonging to Unicode's L, M, N, P, and S general categories (the Graphic characters without spaces) and may also exclude the characters and the Unicode replacement character U+FFFD.\n\nConsider a compiled a package containing the package clause , which exports function , and installed the compiled package in the file identified by . This table illustrates how is accessed in files that import the package after the various types of import declaration.\n\nAn import declaration declares a dependency relation between the importing and imported package. It is illegal for a package to import itself, directly or indirectly, or to directly import a package without referring to any of its exported identifiers. To import a package solely for its side-effects (initialization), use the blank identifier as explicit package name:\n\nHere is a complete Go package that implements a concurrent prime sieve.\n\nThe zero value\n\nWhen storage is allocated for a variable, either through a declaration or a call of , or when a new value is created, either through a composite literal or a call of , and no explicit initialization is provided, the variable or value is given a default value. Each element of such a variable or value is set to the zero value for its type: for booleans, for numeric types, for strings, and for pointers, functions, interfaces, slices, channels, and maps. This initialization is done recursively, so for instance each element of an array of structs will have its fields zeroed if no value is specified.\n\nThese two simple declarations are equivalent:\n\nThe same would also be true after\n\nWithin a package, package-level variable initialization proceeds stepwise, with each step selecting the variable earliest in declaration order which has no dependencies on uninitialized variables.\n\nMore precisely, a package-level variable is considered ready for initialization if it is not yet initialized and either has no initialization expression or its initialization expression has no dependencies on uninitialized variables. Initialization proceeds by repeatedly initializing the next package-level variable that is earliest in declaration order and ready for initialization, until there are no variables ready for initialization.\n\nIf any variables are still uninitialized when this process ends, those variables are part of one or more initialization cycles, and the program is not valid.\n\nMultiple variables on the left-hand side of a variable declaration initialized by single (multi-valued) expression on the right-hand side are initialized together: If any of the variables on the left-hand side is initialized, all those variables are initialized in the same step.\n\nFor the purpose of package initialization, blank variables are treated like any other variables in declarations.\n\nThe declaration order of variables declared in multiple files is determined by the order in which the files are presented to the compiler: Variables declared in the first file are declared before any of the variables declared in the second file, and so on. To ensure reproducible initialization behavior, build systems are encouraged to present multiple files belonging to the same package in lexical file name order to a compiler.\n\nDependency analysis does not rely on the actual values of the variables, only on lexical references to them in the source, analyzed transitively. For instance, if a variable 's initialization expression refers to a function whose body refers to variable then depends on . Specifically:\n• A reference to a variable or function is an identifier denoting that variable or function.\n• A reference to a method is a method value or method expression of the form , where the (static) type of is not an interface type, and the method is in the method set of . It is immaterial whether the resulting function value is invoked.\n• A variable, function, or method depends on a variable if 's initialization expression or body (for functions and methods) contains a reference to or to a function or method that depends on .\n\nFor example, given the declarations\n\nthe initialization order is , , , . Note that the order of subexpressions in initialization expressions is irrelevant: and result in the same initialization order in this example.\n\nDependency analysis is performed per package; only references referring to variables, functions, and (non-interface) methods declared in the current package are considered. If other, hidden, data dependencies exists between variables, the initialization order between those variables is unspecified.\n\nFor instance, given the declarations\n\nthe variable will be initialized after but whether is initialized before , between and , or after , and thus also the moment at which is called (before or after is initialized) is not specified.\n\nVariables may also be initialized using functions named declared in the package block, with no arguments and no result parameters.\n\nMultiple such functions may be defined per package, even within a single source file. In the package block, the identifier can be used only to declare functions, yet the identifier itself is not declared. Thus functions cannot be referred to from anywhere in a program.\n\nThe entire package is initialized by assigning initial values to all its package-level variables followed by calling all functions in the order they appear in the source, possibly in multiple files, as presented to the compiler.\n\nThe packages of a complete program are initialized stepwise, one package at a time. If a package has imports, the imported packages are initialized before initializing the package itself. If multiple packages import a package, the imported package will be initialized only once. The importing of packages, by construction, guarantees that there can be no cyclic initialization dependencies. More precisely:\n\nGiven the list of all packages, sorted by import path, in each step the first uninitialized package in the list for which all imported packages (if any) are already initialized is initialized. This step is repeated until all packages are initialized.\n\nPackage initialization—variable initialization and the invocation of functions—happens in a single goroutine, sequentially, one package at a time. An function may launch other goroutines, which can run concurrently with the initialization code. However, initialization always sequences the functions: it will not invoke the next one until the previous one has returned.\n\nA complete program is created by linking a single, unimported package called the main package with all the packages it imports, transitively. The main package must have package name and declare a function that takes no arguments and returns no value.\n\nProgram execution begins by initializing the program and then invoking the function in package . When that function invocation returns, the program exits. It does not wait for other (non- ) goroutines to complete.\n\nThe predeclared type is defined as\n\nIt is the conventional interface for representing an error condition, with the nil value representing no error. For instance, a function to read data from a file might be defined:\n\nExecution errors such as attempting to index an array out of bounds trigger a run-time panic equivalent to a call of the built-in function with a value of the implementation-defined interface type . That type satisfies the predeclared interface type . The exact error values that represent distinct run-time error conditions are unspecified.\n\nThe built-in package , known to the compiler and accessible through the import path , provides facilities for low-level programming including operations that violate the type system. A package using must be vetted manually for type safety and may not be portable. The package provides the following interface:\n\nA is a pointer type but a value may not be dereferenced. Any pointer or value of core type can be converted to a type of core type and vice versa. The effect of converting between and is implementation-defined.\n\nThe functions and take an expression of any type and return the alignment or size, respectively, of a hypothetical variable as if were declared via .\n\nThe function takes a (possibly parenthesized) selector , denoting a field of the struct denoted by or , and returns the field offset in bytes relative to the struct's address. If is an embedded field, it must be reachable without pointer indirections through fields of the struct. For a struct with field :\n\nComputer architectures may require memory addresses to be aligned; that is, for addresses of a variable to be a multiple of a factor, the variable's type's alignment. The function takes an expression denoting a variable of any type and returns the alignment of the (type of the) variable in bytes. For a variable :\n\nA (variable of) type has variable size if is a type parameter, or if it is an array or struct type containing elements or fields of variable size. Otherwise the size is constant. Calls to , , and are compile-time constant expressions of type if their arguments (or the struct in the selector expression for ) are types of constant size.\n\nThe function adds to and returns the updated pointer [Go 1.17]. The argument must be of integer type or an untyped constant. A constant argument must be representable by a value of type ; if it is an untyped constant it is given type . The rules for valid uses of still apply.\n\nThe function returns a slice whose underlying array starts at and whose length and capacity are . is equivalent to\n\nexcept that, as a special case, if is and is zero, returns [Go 1.17].\n\nThe argument must be of integer type or an untyped constant. A constant argument must be non-negative and representable by a value of type ; if it is an untyped constant it is given type . At run time, if is negative, or if is and is not zero, a run-time panic occurs [Go 1.17].\n\nThe function returns a pointer to the underlying array of the argument. If the slice's capacity is not zero, that pointer is . If is , the result is . Otherwise it is a non- pointer to an unspecified memory address [Go 1.20].\n\nThe function returns a value whose underlying bytes start at and whose length is . The same requirements apply to the and argument as in the function . If is zero, the result is the empty string . Since Go strings are immutable, the bytes passed to must not be modified afterwards. [Go 1.20]\n\nThe function returns a pointer to the underlying bytes of the argument. For an empty string the return value is unspecified, and may be . Since Go strings are immutable, the bytes returned by must not be modified [Go 1.20].\n\nFor the numeric types, the following sizes are guaranteed:\n\nThe following minimal alignment properties are guaranteed:\n• For a variable of any type: is at least 1.\n• For a variable of struct type: is the largest of all the values for each field of , but at least 1.\n• For a variable of array type: is the same as the alignment of a variable of the array's element type.\n\nA struct or array type has size zero if it contains no fields (or elements, respectively) that have a size greater than zero. Two distinct zero-size variables may have the same address in memory.\n\nThe Go 1 compatibility guarantee ensures that programs written to the Go 1 specification will continue to compile and run correctly, unchanged, over the lifetime of that specification. More generally, as adjustments are made and features added to the language, the compatibility guarantee ensures that a Go program that works with a specific Go language version will continue to work with any subsequent version.\n\nFor instance, the ability to use the prefix for binary integer literals was introduced with Go 1.13, indicated by [Go 1.13] in the section on integer literals. Source code containing an integer literal such as will be rejected if the implied or required language version used by the compiler is older than Go 1.13.\n\nThe following table describes the minimum language version required for features introduced after Go 1.\n• An alias declaration may be used to declare an alias name for a type.\n• Integer literals may use the prefixes , , , and for binary, and octal literals, respectively.\n• Hexadecimal floating-point literals may be written using the prefixes and .\n• The imaginary suffix may be used with any (binary, decimal, hexadecimal) integer or floating-point literal, not just decimal literals.\n• The digits of any number literal may be separated (grouped) using underscores .\n• The shift count in a shift operation may be a signed integer type.\n• Emdedding a method more than once through different embedded interfaces is not an error.\n• A slice may be converted to an array pointer if the slice and array element types match, and the array is not longer than the slice.\n• The built-in package includes the new functions and .\n\nThe 1.18 release adds polymorphic functions and types (\"generics\") to the language. Specifically:\n• The set of operators and punctuation includes the new token .\n• Interface types may embed arbitrary types (not just type names of interfaces) as well as union and type elements.\n• The set of predeclared types includes the new types and .\n• A slice may be converted to an array if the slice and array element types match and the array is not longer than the slice.\n• The built-in package includes the new functions , , and .\n• Comparable types (such as ordinary interfaces) may satisfy constraints, even if the type arguments are not strictly comparable.\n• The set of predeclared functions includes the new functions , , and .\n• Type inference uses the types of interface methods for inference. It also infers type arguments for generic functions assigned to variables or passed as arguments to other (possibly generic) functions.\n• In a \"for\" statement, each iteration has its own set of iteration variables rather than sharing the same variables in each iteration.\n• A \"for\" statement with \"range\" clause may iterate over integer values from zero to an upper limit.\n• A \"for\" statement with \"range\" clause accepts an iterator function as range expression.\n\nThe type unification rules describe if and how two types unify. The precise details are relevant for Go implementations, affect the specifics of error messages (such as whether a compiler reports a type inference or other error), and may explain why type inference fails in unusual code situations. But by and large these rules can be ignored when writing Go code: type inference is designed to mostly \"work as expected\", and the unification rules are fine-tuned accordingly.\n\nType unification is controlled by a matching mode, which may be exact or loose. As unification recursively descends a composite type structure, the matching mode used for elements of the type, the element matching mode, remains the same as the matching mode except when two types are unified for assignability ( ): in this case, the matching mode is loose at the top level but then changes to exact for element types, reflecting the fact that types don't have to be identical to be assignable.\n\nTwo types that are not bound type parameters unify exactly if any of following conditions is true:\n• Both types have identical structure and their element types unify exactly.\n• Exactly one type is an unbound type parameter with a core type, and that core type unifies with the other type per the unification rules for (loose unification at the top level and exact unification for element types).\n\nIf both types are bound type parameters, they unify per the given matching modes if:\n• At most one of the type parameters has a known type argument. In this case, the type parameters are joined: they both stand for the same type argument. If neither type parameter has a known type argument yet, a future type argument inferred for one the type parameters is simultaneously inferred for both of them.\n• Both type parameters have a known type argument and the type arguments unify per the given matching modes.\n\nA single bound type parameter and another type unify per the given matching modes if:\n• doesn't have a known type argument. In this case, is inferred as the type argument for .\n• does have a known type argument , and unify per the given matching modes, and one of the following conditions is true:\n• Both and are interface types: In this case, if both and are also defined types, they must be identical. Otherwise, if neither of them is a defined type, they must have the same number of methods (unification of and already established that the methods match).\n• Neither nor are interface types: In this case, if is a defined type, replaces as the inferred type argument for .\n\nFinally, two types that are not bound type parameters unify loosely (and per the element matching mode) if:\n• One type is a defined type, the other type is a type literal, but not an interface, and their underlying types unify per the element matching mode.\n• Both types are interfaces (but not type parameters) with identical type terms, both or neither embed the predeclared type comparable, corresponding method types unify exactly, and the method set of one of the interfaces is a subset of the method set of the other interface.\n• Only one type is an interface (but not a type parameter), corresponding methods of the two types unify per the element matching mode, and the method set of the interface is a subset of the method set of the other type.\n• Both types have the same structure and their element types unify per the element matching mode."
    },
    {
        "link": "https://hostman.com/tutorials/strings-in-go",
        "document": "Variables are named values stored in specific areas of memory and used during program execution. Go (also known as Golang) is a statically typed programming language. This means that once a variable is declared, its type is fixed and cannot be changed. Variables can have various types, each with its own purpose and characteristics.Go provides several basic data types, which form the foundation of the language's logic: Integer Floating-point String Boolean Additionally, Go supports composite data types: Arrays Slices Structures Maps There are also several auxiliary types: Pointers Interfaces Besides these, Go (similar to C++) includes a Standard Library (std) containing many predefined types. You can find more detailed information about variable types in Go in a separate article. For instructions on installing Go on Linux, Windows, or macOS, refer to the Hostman guides. All the code examples in this tutorial were tested using Go version 1.21.3. Compiling and Running Code All the code examples in this guide are run in separate files with the .go extension. First, create a new file: sudo nano example.go Next, fill it with code inside the main() function, including any necessary modules: package main import \"fmt\" func main() { // start of example var number int = 10 fmt.Println(number) // end of example } Then run the file: go run example.go Declaring a Variable There are different ways to declare a variable in Go before using it—ranging from a full form, explicitly specifying the parameters (or multiple parameters) of the variable, to a shorthand form that uses automatic type inference and initialization. The choice of declaration method depends on the context. However, it’s generally recommended to use the most concise and automatic form whenever possible, as this reduces the likelihood of programmer errors by shifting some of the responsibility to the language's interpreter. Using the var Keyword The most explicit way to declare a variable in Golang is by using the var keyword, followed by the variable name, type, and value: var some_variable int = 5 However, if the variable is initialized with a value, you can omit the explicit type: var some_variable = 5 You can also declare a variable without assigning a value, but in this case, you must specify the type: var some_variable intsome_variable = 5 In all of these examples: var — the keyword for declaring a variable some_variable — the variable's name int — the variable's type 5 — the variable's value For example, this is how you can declare string variables: var some_name string = \"John\" The following declaration will result in an error: // ERROR: no value or type specified during declarationvar some_namesome_name = \"John\" It’s important to note that type inference is only possible during the initial declaration of the variable when the interpreter allocates the appropriate amount of memory for its value. Short Form := Despite Go's strict static typing, it allows variables to be declared in a more concise form without explicitly specifying their parameters: some_variable := 5 In this case, the interpreter understands that it needs to automatically infer the variable type based on the assigned value. However, this shorthand declaration is only allowed inside a function (including main()); it cannot be used outside a function: package main // ERROR: short form declaration outside of a function some_variable := 5 func main() { // OK: short form declaration inside a function other_variable := 10 } It’s important to understand the distinction between declaring a variable (with initialization) and assigning a value to it: package main func main() { some_variable := 5 // this is declaration and initialization (colon is present) some_variable = 50 // this is assignment (no colon) other_variable = 7 // ERROR: this is assignment (no colon) to an undeclared variable } For example, you can declare (and initialize) several variables sequentially: age := 50 // variable of type int name := \"John\" // variable of type string occupation := \"Just a guy\" // variable of type string height := 190.5 // variable of type float32 You cannot use the := operator together with the var keyword. Doing so will result in an error: var someVariable int := 5 // ERRORvar someVariable := 5 // ERROR Excluding the var keyword but still explicitly specifying the type will still result in an error: someVariable int := 5 // ERROR Multiple Variables In Go, you can declare multiple variables in one line or block. For example, you can use the var keyword with a single type for all declared variables: var width, height, depth int = 100, 200, 300 You can also separate the declaration of variables and their assignment: var width, height, depth intwidth, height, depth = 100, 200, 300 If the variable types differ, the interpreter can automatically infer their types: var name, age, fired = \"John\", 50, false Similarly, you can use the short form for multiple variables: name, age, fired := \"John\", 50, false In this case, there is no var keyword, nor are the types of the variables specified. Another way to declare multiple variables is by using a block: var ( name string = \"John\" age int = 50 height float64 = 190 fired bool = false ) By the way, you can format block declarations using spaces in such a way that names, types, and values align in columns, improving code readability: var ( name string = \"John\" age int = 50 height float64 = 190.5 fired bool = false ) The block declaration has no particular utility significance. It’s just syntactic sugar that: Improves code readability by grouping important variables in one place. Improves code cleanliness by avoiding repeated use of the var keyword for each variable. Improves code maintainability by simplifying the search and modification of variable parameters. Thus, block declaration is justified only when you need to group several key variables, simplifying their visual perception in a code editor. No Initialization In Go, it is possible to create a variable without initializing it. In this case, the variable is assigned a zero value corresponding to the specified type: For int, float32, float64: 0, 0.0, 0.0 For bool: false For string: \"\" For pointers: nil We can demonstrate this behavior of Go regarding variable declaration and initialization in the following script: package main import \"fmt\" func main() { // Integer var numberInt int fmt.Println(\"Integer:\", numberInt) // Floating-point number var numberFloat float32 fmt.Println(\"Floating-point number:\", numberFloat) // String var text string fmt.Println(\"String:\", text) // Boolean var condition bool fmt.Println(\"Boolean:\", condition) // Array var array [5]int fmt.Println(\"Array:\", array) // Slice var cut []int fmt.Println(\"Slice:\", cut) // Struct type S struct { name string size int address string } var structure S fmt.Println(\"Struct:\", structure) // Map var dictionary map[int]int fmt.Println(\"Map:\", dictionary) // Pointer var pointer *int fmt.Println(\"Pointer:\", pointer) } The console output will be as follows: Integer: 0 Floating-point number: 0 String: Boolean: false Array: [0 0 0 0 0] Slice: [] Struct: { 0} Map: map[] Pointer: <nil> As you can see, variables of different types are automatically initialized with zero (or empty) values wherever possible. Naming Conventions In Golang, variable names can either start with a Latin letter or an underscore (_): onething := 123 // OK Onething := 123 // OK _onething := 123 // OK __onething := 123 // OK 1thing := 123 // ERROR Additionally, variable names have a functional feature: names starting with an uppercase letter are visible in other packages, while names starting with a lowercase letter are not. There are also several universal naming conventions across programming languages, including Go: Snake Case Camel Case Pascal Case Kebab Case (not supported in Go) Snake Case In Snake Case, the variable name looks like this: some_random_variable := 123 // lowercaseSOME_RANDOM_VARIABLE := 123 // uppercase Camel Case In Camel Case, the variable name looks like this: someRandomVariable := 12 Pascal Case In Pascal Case, the variable name looks like this: SomeRandomVariable := 123 Kebab Case In Kebab Case, the variable name looks like this: // ERRORsome-random-variable := 123 // lowercaseSOME-RANDOM-VARIABLE := 123 // uppercase However, Go doesn't support the Kebab Case style due to the hyphen character, which is reserved for the subtraction operation. Example: Declaring Multiple Variables Let’s further explore all the aforementioned ways of declaring variables in Golang in this script example: package main import \"fmt\" func main() { // Explicit declaration with type specification var age int = 50 fmt.Println(\"Age:\", age) // Explicit declaration with type inference var height = 190.5 fmt.Println(\"Height:\", height) // Short declaration name := \"John\" fmt.Println(\"Name:\", name) // Explicit declaration of multiple variables var width, depth int = 100, 200 fmt.Println(\"Width:\", width, \"Depth:\", depth) // Explicit declaration without initialization var distance int fmt.Println(\"Distance:\", distance) // Block declaration of multiple variables var ( occupation string = \"Welder\" category float32 = 3.4 license bool ) fmt.Println(\"Occupation:\", occupation, \"Category:\", category, \"License:\", license) } The result of running this code will be the following output in the console: Age: 50 Height: 190.5 Name: John Width: 100 Depth: 200 Distance: 0 Occupation: Welder Category: 3.4 License: false The var keyword is required for explicit variable declaration, especially in the global scope. The := operator is used for short variable declarations, particularly within functions. The block () syntax is used for readable declaration of multiple variables. It's important to remember that Go emphasizes minimalism and concise syntax. Therefore, the most compact form of notation should be used wherever possible. This reduces errors and issues while maintaining the cleanliness and readability of the code. Variable Initialization Typically, when a variable is declared, it is manually initialized with a specific value. The initialization of different types has syntactic differences. Number Numerical variables are initialized by assigning a numerical value, which is syntactically simple: // int var someNumber int = 5 // float32 otherNumber := 10.0 A number can be initialized with another number: // int var someNumber int = 5 var otherNumber int = someNumber // int oneMoreNumber := someNumber String String variables are initialized by assigning a sequence of characters enclosed in double quotes: // stringvar someString string = \"Some programmer was here\" A string can also be initialized with another string: // string var someString string = \"Some programmer was here\" var otherString string = someString // string oneMoreString := someString Boolean Initializing boolean variables is similar to initializing numeric and string variables, except that the value used is the keyword true or false: // boolvar someBool bool = true Similarly, boolean variables can be initialized with other boolean variables: // bool var someBool bool = true var otherBool bool = someBool // bool oneMoreBool := someBool Array There are several ways to initialize an array. The simplest one is through sequential access to the elements: // array var languages [3]string languages[0] = \"Golang\" languages[1] = \"Python\" languages[2] = \"Rust\" A more complex method is using a composite literal. A composite literal is a compact syntax for initializing any composite (struct-like) type, which avoids assigning each element individually. Thus, the array can be initialized in one step: var languages = [3]string{\"Golang\", \"Python\", \"Rust\"} Or using the shorthand form: languages := [3]string{\"Golang\", \"Python\", \"Rust\"} You can also partially initialize array elements: // array size 5, but only 3 elements initialized languages := [5]string{\"Golang\", \"Python\", \"Rust\"} languages[3] = \"Java\" languages[4] = \"C++\" To make the initialization of a large array more readable, you can format it like this: languages := [5]string{ \"Golang\", \"Python\", \"Rust\", \"Java\", \"C++\", // the comma at the end is REQUIRED } By the way, an array can be initialized with another array, copying all of its elements: languages := [3]string{\"Golang\", \"Python\", \"Rust\"}otherLanguages := languages It’s important to understand that copying an array also occurs when it is passed to a function: package main import \"fmt\" func change(languages [5]string) { for i := range languages { languages[i] = \"[\" + languages[i] + \"]\" } } func main() { languages := [5]string{ \"Golang\", \"Python\", \"Rust\", \"Java\", \"C++\", } change(languages) fmt.Println(languages) } The output in the console will be: [Golang Python Rust Java C++] Thus, only the copy of the array inside the change() function was modified, not the original array from the main() function. However, explicit initialization of an array with another array is possible only if both arrays have the same length and type: languages := [3]string{\"Golang\", \"Python\", \"Rust\"} var otherLanguages [3]string = languages // OK var oneMoreLanguages [4]string = languages // ERROR Additionally, in Go, you can create arrays from an arbitrary number of other arrays. You can initialize elements of such arrays both sequentially: var matrix [2][2]string matrix[0][0] = \"a\" matrix[0][1] = \"b\" matrix[1][0] = \"c\" matrix[1][1] = \"d\" Or using a composite literal: var matrix = [2][2][2]string{{{\"a\", \"b\"}, {\"c\", \"d\"}}, {{\"e\", \"f\"}, {\"g\", \"h\"}}} As shown, the second option takes up less space, but the syntax is more complex. Slice A slice is initialized the same way as an array: var languages = []string{\"Golang\", \"Python\", \"Rust\"} However, unlike an array, a slice can be initialized with another slice of arbitrary length: var languages = []string{\"Golang\", \"Python\", \"Rust\"}var otherLanguages []string = languages Map Maps are initialized using a composite literal with the type of the key and value specified. The content is listed using commas and separated by a colon: var languages = map[string]string{\"first\": \"Golang\", \"second\": \"Python\", \"third\": \"Rust\"} You can also use the shorthand declaration and a more readable initialization format: languages := map[string]string{ \"first\": \"Golang\", \"second\": \"Python\", \"third\": \"Rust\", // the comma at the end is MANDATORY } However, initializing a map with another map does not copy the elements; instead, it makes them shared: package main import \"fmt\" func main() { languages := map[string]string{\"first\": \"Golang\", \"second\": \"Python\", \"third\": \"Rust\"} otherLanguages := languages fmt.Println(languages) fmt.Println(otherLanguages) otherLanguages[\"first\"] = \"C++\" fmt.Println(languages) fmt.Println(otherLanguages) delete(otherLanguages, \"second\") fmt.Println(languages) fmt.Println(otherLanguages) } The console output of this example will be: map[first:Golang second:Python third:Rust] map[first:Golang second:Python third:Rust] map[first:C++ second:Python third:Rust] map[first:C++ second:Python third:Rust] map[first:C++ third:Rust] map[first:C++ third:Rust] Pointer Pointers can only be initialized with the address of a variable of the same type: var variable int = 15var pointer *int = &variable The ampersand (&) symbol is used to get the address of any variable: package main import \"fmt\" func main() { var variable int = 15 var pointer *int = &variable fmt.Println(pointer) } The console output of this example will look something like: 0xc000104040 You can also use shorthand notation to initialize pointers: variable := 15pointer := &variable To access the value stored at the address of a pointer, you need to dereference it using the asterisk (*): package main import \"fmt\" func main() { var variable int = 15 var pointer *int = &variable fmt.Println(*pointer) } In this case, the console output will show: 15 Thus, you can assign new values to a variable located at the address of the pointer: package main import \"fmt\" func main() { var variable int = 15 var pointer *int = &variable *pointer = 5 fmt.Println(*pointer) } The console will display: 5 Finally, a pointer can be initialized with an anonymous object in memory. This is done using the new() function, which returns the address of the allocated memory: variable := new(int)*variable = 15 You don't need to manually delete the allocated memory — the garbage collector automatically handles this. Structure A structure can be initialized either with explicitly specified values in order: type something struct { first string second int } var structure something = something{\"John\", 15} Or with explicitly specified values by key names: type something struct { first string second int } var structure something = something{second: 15, first: \"John\"} Alternatively, you can choose not to specify any values, which will automatically initialize all fields to their zero values: package main import \"fmt\" type something struct { first string second int } func main() { var structure something = something{} fmt.Println(structure) structure.first = \"John\" structure.second = 15 fmt.Println(structure) } In this case, the console output will be: { 0} {John 15} Branching Based on Variables Variables play a central role in branching. Different parts of the program's code are executed based on their values (conditions). if/else The most basic conditional construct is created using the if/else statements. Here's the simplest condition: a := 5 b := 10 if a < b { fmt.Println(\"A is less than B\") } For example, you can use a simple condition to check a pointer: var pointer *int if pointer == nil { fmt.Println(\"No address\") } A more complex form would look like this: a := 10 b := 5 if a < b { fmt.Println(\"A is less than B\") } else { fmt.Println(\"A is greater than B\") } You can create even more complex constructs by combining else and if: a := 10 b := 5 if a < b { fmt.Println(\"A is less than B\") } else if a > b { fmt.Println(\"A is greater than B\") } else { fmt.Println(\"A is equal to B\") } Multiple if/else expressions can be used: a := 12 if a < 5 { fmt.Println(\"A is less than 5\") } else if a < 10 { fmt.Println(\"A is less than 10\") } else if a < 20 { fmt.Println(\"A is less than 20\") } else { fmt.Println(\"A is in superposition\") } switch Another way to branch is using the switch construct, where possible values of a variable are defined, and actions are performed if there's a match: a := 1 switch a { case 0: fmt.Println(\"A is 0\") case 1: fmt.Println(\"A is 1\") case 2: fmt.Println(\"A is 2\") } The default section can be used to define an action that runs if no match occurs: a := 3 switch a { case 0: fmt.Println(\"A is 0\") case 1: fmt.Println(\"A is 1\") case 2: fmt.Println(\"A is 2\") default: fmt.Println(\"A is in superposition\") } You can also combine multiple possible matches into one section: a := 1 switch a { case 0, 1, 2: fmt.Println(\"A is either 0, 1, or 2\") default: fmt.Println(\"A is in superposition\") } Useful Functions Go has many utility functions for working with variables. In this guide, we'll cover just the basic ones. Environment Variables Go provides special system functions that allow you to set and get environment variables: package main import ( \"fmt\" \"os\" ) func main() { os.Setenv(\"SOMEVAR\", \"1\") // Set an environment variable fmt.Println(\"SOMEVAR:\", os.Getenv(\"SOMEVAR\")) // Read an environment variable } Time Variables Often, the program logic requires measuring time. Go has a corresponding tool for this — the time type. Time is a broad topic by itself. To learn more about the time package, you can check the official documentation. This guide will show how to get the current time in different formats: package main import ( \"fmt\" \"time\" ) func main() { fmt.Println(\"Current time:\", time.Now()) fmt.Println(\"Current time (UTC):\", time.Now().UTC()) fmt.Println(\"Current time (Unix):\", time.Now().Unix()) } The console output will look something like this: Current time: 2009-11-10 23:00:00 +0000 UTC m=+0.000000001 Current time (UTC): 2009-11-10 23:00:00 +0000 UTC Current time (Unix): 1257894000 You can also specify specific time parameters: package main import ( \"fmt\" \"time\" ) func main() { timeNow := time.Now() fmt.Println(\"Full time:\", timeNow) fmt.Println(\"Year:\", timeNow.Year()) fmt.Println(\"Month:\", timeNow.Month()) fmt.Println(\"Day:\", timeNow.Day()) fmt.Println(\"Hour:\", timeNow.Hour()) fmt.Println(\"Minutes:\", timeNow.Minute()) fmt.Println(\"Seconds:\", timeNow.Second()) } In this case, the console output will be: Full time: 2024-11-15 23:46:09.157929822 +0000 UTC m=+0.000031801 Year: 2024 Month: November Day: 15 Hour: 23 Minutes: 23 Seconds: 9 Adding and Removing Elements from a Slice You can add elements to slices: var languages = []string{\"Golang\", \"Python\", \"Rust\"} languages = append(languages, \"Java\", \"C++\") fmt.Println(languages) This will append \"Java\" and \"C++\" to the languages slice. You can also remove elements from slices: var languages = []string{\"Golang\", \"Python\", \"Rust\"} // Remove the 2nd element (index 1) n := 1 languages = append(languages[:n], languages[n+1:]...) fmt.Println(languages) In this example, the second element is removed from the languages slice using slice operators, which create a new sequence from parts of the original slice. Here’s an example of slicing a sequence: package main import \"fmt\" func main() { var sequence = []string{\"One\", \"Two\", \"Three\", \"Four\", \"Five\"} newSequence := sequence[1:4] // Elements from index 1 to 3 become the new slice fmt.Println(newSequence) } The output in the console will be: [Two Three Four] Checking the Type of a Variable You can check the type of a variable using the TypeOf() function from the reflect package: package main import ( \"fmt\" \"reflect\" // Package to determine the type ) func main() { variableString := \"string\" variableInt := 5 variableFloat64 := 1.5 variableBool := true fmt.Println(reflect.TypeOf(variableString)) fmt.Println(reflect.TypeOf(variableInt)) fmt.Println(reflect.TypeOf(variableFloat64)) fmt.Println(reflect.TypeOf(variableBool)) } The console output for this example will be: string int float64 bool Variables in Strings Often, you need to insert a variable into a string. There are several ways to do this: package main import \"fmt\" func main() { // METHOD 1 stringPre := \"human-readable\" stringEnd1 := fmt.Sprintf(\"This is a %s string\", stringPre) fmt.Println(stringEnd1) // METHOD 2 stringEnd2 := \"This is \" + stringPre + \" string\" fmt.Println(stringEnd2) } The output in the console will be: This is a human-readable stringThis is a human-readable string You can also combine numeric variables with strings: package main import \"fmt\" func main() { name := \"John\" age := 50 fmt.Printf(\"Hi, my name is %v and I'm %v years old.\n\n\", name, age) } The output will be: Hi, my name is John and I'm 50 years old. Conclusion Like in most other programming languages, variables in Go are essential for storing data. Since data types differ from each other, Golang variables have several basic types, each having a specific representation in the computer's memory. In this guide, we only covered the basic ways to work with variables. You can find more detailed (and comprehensive) information about types and their specifics in the official Golang documentation. Additionally, the official Go package manager catalog provides information on many useful modules available for import into your project. One such module is the Standard Library. Check out our app platform to deploy Go applications (such as Beego and Gin)."
    },
    {
        "link": "https://tip.golang.org/doc/go1.20",
        "document": "The latest Go release, version 1.20, arrives six months after Go 1.19. Most of its changes are in the implementation of the toolchain, runtime, and libraries. As always, the release maintains the Go 1 promise of compatibility. We expect almost all Go programs to continue to compile and run as before.\n\nChanges to the language\n\nGo 1.20 includes four changes to the language.\n\nGo 1.17 added conversions from slice to an array pointer. Go 1.20 extends this to allow conversions from a slice to an array: given a slice , can now be written instead of .\n\nThe package defines three new functions , , and . Along with Go 1.17’s , these functions now provide the complete ability to construct and deconstruct slice and string values, without depending on their exact representation.\n\nThe specification now defines that struct values are compared one field at a time, considering fields in the order they appear in the struct type definition, and stopping at the first mismatch. The specification could previously have been read as if all fields needed to be compared beyond the first mismatch. Similarly, the specification now defines that array values are compared one element at a time, in increasing index order. In both cases, the difference affects whether certain comparisons must panic. Existing programs are unchanged: the new spec wording describes what the implementations have always done.\n\nComparable types (such as ordinary interfaces) may now satisfy constraints, even if the type arguments are not strictly comparable (comparison may panic at runtime). This makes it possible to instantiate a type parameter constrained by (e.g., a type parameter for a user-defined generic map key) with a non-strictly comparable type argument such as an interface type, or a composite type containing an interface type.\n\nGo 1.20 is the last release that will run on any release of Windows 7, 8, Server 2008 and Server 2012. Go 1.21 will require at least Windows 10 or Server 2016.\n\nGo 1.20 is the last release that will run on macOS 10.13 High Sierra or 10.14 Mojave. Go 1.21 will require macOS 10.15 Catalina or later.\n\nGo 1.20 adds experimental support for FreeBSD on RISC-V ( , ).\n\nThe directory no longer stores pre-compiled package archives for the standard library: no longer writes them, the build no longer checks for them, and the Go distribution no longer ships them. Instead, packages in the standard library are built as needed and cached in the build cache, just like packages outside . This change reduces the size of the Go distribution and also avoids C toolchain skew for packages that use cgo.\n\nThe implementation of has been improved to make it more robust. Programs that run do not need any updates. Programs that invoke directly should now run the test binary with (for example, or ) instead of plain .\n\nA related change to is the addition of an event with set to at the beginning of each test program’s execution. When running multiple tests using the command, these start events are guaranteed to be emitted in the same order as the packages named on the command line.\n\nThe command now defines architecture feature build tags, such as , to allow selecting a package implementation file based on the presence or absence of a particular architecture feature. See for details.\n\nThe subcommands now accept to change directory to <dir> before performing the command, which may be useful for scripts that need to execute commands in multiple different modules.\n\nThe and commands no longer accept the flag, which has been deprecated since Go 1.16.\n\nThe command now accepts to skip directives matching .\n\nThe command now accepts to skip tests, subtests, or examples matching .\n\nWhen the main module is located within , no longer installs libraries for non- packages to , and no longer reports a field for such packages. (In module mode, compiled packages are stored in the build cache only, but a bug had caused the install targets to unexpectedly remain in effect.)\n\nThe , , and other build-related commands now support a flag that enables profile-guided optimization, which is described in more detail in the Compiler section below. The flag specifies the file path of the profile. Specifying causes the command to search for a file named in the main package’s directory and use it if present. This mode currently requires a single main package to be specified on the command line, but we plan to lift this restriction in a future release. Specifying turns off profile-guided optimization.\n\nThe , , and other build-related commands now support a flag that builds the specified target with code coverage instrumentation. This is described in more detail in the Cover section below.\n\nThe command now supports reading more types of Go binaries, most notably, Windows DLLs built with and Linux binaries without execute permission.\n\nThe command now disables by default on systems without a C toolchain. More specifically, when the environment variable is unset, the environment variable is unset, and the default C compiler (typically or ) is not found in the path, defaults to . As always, you can override the default by setting explicitly.\n\nThe most important effect of the default change is that when Go is installed on a system without a C compiler, it will now use pure Go builds for packages in the standard library that use cgo, instead of using pre-distributed package archives (which have been removed, as noted above) or attempting to use cgo and failing. This makes Go work better in some minimal container environments as well as on macOS, where pre-distributed package archives have not been used for cgo-based packages since Go 1.16.\n\nThe packages in the standard library that use cgo are , , and . On macOS, the and packages have been rewritten not to use cgo: the same code is now used for cgo and non-cgo builds as well as cross-compiled builds. On Windows, the and packages have never used cgo. On other systems, builds with cgo disabled will use a pure Go version of these packages.\n\nA consequence is that, on macOS, if Go code that uses the package is built with , linking the resulting archive into a C program requires passing when linking the C code.\n\nOn macOS, the race detector has been rewritten not to use cgo: race-detector-enabled programs can be built and run without Xcode. On Linux and other Unix systems, and on Windows, a host C toolchain is required to use the race detector.\n\nGo 1.20 supports collecting code coverage profiles for programs (applications and integration tests), as opposed to just unit tests.\n\nTo collect coverage data for a program, build it with ’s flag, then run the resulting binary with the environment variable set to an output directory for coverage profiles. See the ‘coverage for integration tests’ landing page for more on how to get started. For details on the design and implementation, see the proposal.\n\nThe tool now reports references to loop variables following a call to within subtest function bodies. Such references may observe the value of the variable from a different iteration (typically causing test cases to be skipped) or an invalid state due to unsynchronized concurrent access.\n\nThe tool also detects reference mistakes in more places. Previously it would only consider the last statement of the loop body, but now it recursively inspects the last statements within if, switch, and select statements.\n\nThe vet tool now reports use of the time format 2006-02-01 (yyyy-dd-mm) with and . This format does not appear in common date standards, but is frequently used by mistake when attempting to use the ISO 8601 date format (yyyy-mm-dd).\n\nSome of the garbage collector’s internal data structures were reorganized to be both more space and CPU efficient. This change reduces memory overheads and improves overall CPU performance by up to 2%.\n\nThe garbage collector behaves less erratically with respect to goroutine assists in some circumstances.\n\nGo 1.20 adds a new package containing APIs for writing coverage profile data at runtime from long-running and/or server programs that do not terminate via .\n\nGo 1.20 adds preview support for profile-guided optimization (PGO). PGO enables the toolchain to perform application- and workload-specific optimizations based on run-time profile information. Currently, the compiler supports pprof CPU profiles, which can be collected through usual means, such as the or packages. To enable PGO, pass the path of a pprof profile file via the flag to , as mentioned above. Go 1.20 uses PGO to more aggressively inline functions at hot call sites. Benchmarks for a representative set of Go programs show enabling profile-guided inlining optimization improves performance about 3–4%. See the PGO user guide for detailed documentation. We plan to add more profile-guided optimizations in future releases. Note that profile-guided optimization is a preview, so please use it with appropriate caution.\n\nThe Go 1.20 compiler upgraded its front-end to use a new way of handling the compiler’s internal data, which fixes several generic-types issues and enables type declarations within generic functions and methods.\n\nThe compiler now rejects anonymous interface cycles with a compiler error by default. These arise from tricky uses of embedded interfaces and have always had subtle correctness issues, yet we have no evidence that they’re actually used in practice. Assuming no reports from users adversely affected by this change, we plan to update the language specification for Go 1.22 to formally disallow them so tools authors can stop supporting them too.\n\nGo 1.18 and 1.19 saw regressions in build speed, largely due to the addition of support for generics and follow-on work. Go 1.20 improves build speeds by up to 10%, bringing it back in line with Go 1.17. Relative to Go 1.19, generated code performance is also generally slightly improved.\n\nOn Linux, the linker now selects the dynamic interpreter for or at link time.\n\nOn Windows, the Go linker now supports modern LLVM-based C toolchains.\n\nGo 1.20 uses and prefixes for compiler-generated symbols rather than and . This avoids confusion for user packages whose name starts with . The package understands this new naming convention for binaries built with Go 1.20 and newer.\n\nWhen building a Go release from source and is not set, previous versions of Go looked for a Go 1.4 or later bootstrap toolchain in the directory ( on Windows). Go 1.18 and Go 1.19 looked first for or before falling back to , in anticipation of requiring Go 1.17 for use when bootstrapping Go 1.20. Go 1.20 does require a Go 1.17 release for bootstrapping, but we realized that we should adopt the latest point release of the bootstrap toolchain, so it requires Go 1.17.13. Go 1.20 looks for or before falling back to (to support systems that hard-coded the path $HOME/go1.4 but have installed a newer Go toolchain there). In the future, we plan to move the bootstrap toolchain forward approximately once a year, and in particular we expect that Go 1.22 will require the final point release of Go 1.20 for bootstrap.\n\nGo 1.20 adds a new package to provide explicit support for Elliptic Curve Diffie-Hellman key exchanges over NIST curves and Curve25519.\n\nPrograms should use instead of the lower-level functionality in for ECDH, and third-party modules for more advanced use cases.\n\nGo 1.20 expands support for error wrapping to permit an error to wrap multiple other errors.\n\nAn error can wrap more than one error by providing an method that returns a .\n\nThe and functions have been updated to inspect multiply wrapped errors.\n\nThe function now supports multiple occurrences of the format verb, which will cause it to return an error that wraps all of those error operands.\n\nThe new function returns an error wrapping a list of errors.\n\nThe new type provides access to extended per-request functionality not handled by the interface.\n\nPreviously, we have added new per-request functionality by defining optional interfaces which a can implement, such as . These interfaces are not discoverable and clumsy to use.\n\nThe type provides a clearer, more discoverable way to add per-handler controls. Two such controls also added in Go 1.20 are and , which allow setting per-request read and write deadlines. For example:\n\nThe forwarding proxy includes a new hook function, superseding the previous hook.\n\nThe hook accepts a parameter, which includes both the inbound request received by the proxy and the outbound request that it will send. Unlike hooks, which only operate on the outbound request, this permits hooks to avoid certain scenarios where a malicious inbound request may cause headers added by the hook to be removed before forwarding. See issue #50580.\n\nThe method routes the outbound request to a provided destination and supersedes the function. Unlike , also sets the header of the outbound request.\n\nThe method sets the , , and headers of the outbound request. When using a , these headers are not added by default.\n\nAn example of a hook using these features is:\n\nno longer adds a header to forwarded requests when the incoming request does not have one.\n\nMinor changes to the library\n\nAs always, there are various minor changes and updates to the library, made with the Go 1 promise of compatibility in mind. There are also various performance improvements, not enumerated here.\n\nWhen the environment variable is set, method will now return the error for an entry with a file name that is an absolute path, refers to a location outside the current directory, contains invalid characters, or (on Windows) is a reserved name such as . A future version of Go may disable insecure paths by default.\n\nWhen the environment variable is set, will now return the error when opening an archive which contains any file name that is an absolute path, refers to a location outside the current directory, contains invalid characters, or (on Windows) is a reserved names such as . A future version of Go may disable insecure paths by default.\n\nReading from a directory file that contains file data will now return an error. The zip specification does not permit directory files to contain file data, so this change only affects reading from invalid archives.\n\nThe new and functions are like and but also report whether the string was trimmed.\n\nThe new function allocates a copy of a byte slice.\n\nThe new function provides a way to cancel a context with a given error. That error can be retrieved by calling the new function.\n\nWhen using supported curves, all operations are now implemented in constant time. This led to an increase in CPU time between 5% and 30%, mostly affecting P-384 and P-521.\n\nThe new method converts an to an .\n\nThe method and the function now support signing pre-hashed messages with Ed25519ph, indicated by an that returns . They also now support Ed25519ctx and Ed25519ph with context, indicated by setting the new field.\n\nThe new field allows configuring the MGF1 hash separately for OAEP decryption.\n\ncrypto/rsa now uses a new, safer, constant-time backend. This causes a CPU runtime increase for decryption operations between approximately 15% (RSA-2048 on amd64) and 45% (RSA-4096 on arm64), and more on 32-bit architectures. Encryption operations are approximately 20x slower than before (but still 5-10x faster than decryption). Performance is expected to improve in future releases. Programs must not modify or manually generate the fields of .\n\nThe new function XORs two byte slices together.\n\nParsed certificates are now shared across all clients actively using that certificate. The memory savings can be significant in programs that make many concurrent connections to a server or collection of servers sharing any part of their certificate chains.\n\nFor a handshake failure due to a certificate verification failure, the TLS client and server now return an error of the new type , which includes the presented certificates.\n\nand now support keys of type . and now support keys of type . Parsing NIST curve keys still returns values of type and . Use their new methods to convert to the types.\n\nThe new function allows a program to define a set of fallback root certificates in case an operating system verifier or standard platform root bundle is unavailable at runtime. It will most commonly be used with a new package, golang.org/x/crypto/x509roots/fallback, which will provide an up to date root bundle.\n\nAttempts to read from a section using or the reader returned by now return an error.\n\nAdditional constants are defined for use with LoongArch systems.\n\nAdditional constants are defined for use with PPC64 ELFv2 relocations.\n\nThe constant value for is corrected, from 61 to 62.\n\nDue to a change of Go’s symbol naming conventions, tools that process Go binaries should use Go 1.20’s package to transparently handle both old and new binaries.\n\nAdditional constants are defined for use with RISC-V systems.\n\nThe and functions will now return after reading a partial value, rather than .\n\nThe new method can be used to check for unclosed elements when finished encoding.\n\nThe decoder now rejects element and attribute names with more than one colon, such as , as well as namespaces that resolve to an empty string, such as .\n\nThe decoder now rejects elements that use different namespace prefixes in the opening and closing tag, even if those prefixes both denote the same namespace.\n\nThe new function returns an error wrapping a list of errors.\n\nThe function supports multiple occurrences of the format verb, returning an error that unwraps to the list of all arguments to .\n\nThe new function recovers the formatting directive corresponding to a , which can be useful in . implementations.\n\nThe new field records the position of the keyword in a range statement.\n\nThe new and fields record the position of the start and end of the entire source file.\n\nThe new method removes a file from a . Long-running programs can use this to release memory associated with files they no longer need.\n\nThe new function reports whether a type satisfies a constraint. This change aligns with the new language semantics that distinguish satisfying a constraint from implementing an interface.\n\nGo 1.20.3 and later disallow actions in ECMAScript 6 template literals. This behavior can be reverted by the setting.\n\nThe new wraps an underlying and provides , , and methods that adjust their effective file offset position by a fixed amount.\n\nThe new error terminates a immediately but successfully.\n\nThe math/big package’s wide scope and input-dependent timing make it ill-suited for implementing cryptography. The cryptography packages in the standard library no longer call non-trivial Int methods on attacker-controlled inputs. In the future, the determination of whether a bug in math/big is considered a security vulnerability will depend on its wider impact on the standard library.\n\nThe math/rand package now automatically seeds the global random number generator (used by top-level functions like and ) with a random value, and the top-level function has been deprecated. Programs that need a reproducible sequence of random numbers should prefer to allocate their own random source, using .\n\nPrograms that need the earlier consistent global seeding behavior can set in their environment.\n\nThe top-level function has been deprecated. In almost all cases, is more appropriate.\n\nThe function now allows duplicate parameter names, so long as the values of the names are the same.\n\nMethods of the type now wrap errors returned by the underlying .\n\nIn Go 1.19.8 and later, this package sets limits the size of the MIME data it processes to protect against malicious inputs. and limit the number of headers in a part to 10000 and limits the total number of headers in all to 10000. These limits may be adjusted with the setting. further limits the number of parts in a form to 1000. This limit may be adjusted with the setting.\n\nThe function now consistently returns the contents of a record when one exists. Previously on Unix systems and when using the pure Go resolver, would return an error if a record referred to a name that with no , , or record. This change modifies to match the previous behavior on Windows, allowing to succeed whenever a exists.\n\nnow includes the new flag , indicating an operationally active interface. An interface which is administratively configured but not active (for example, because the network cable is not connected) will have set but not .\n\nThe new field contains a callback function similar to the existing hook, that additionally accepts the dial context as a parameter. is ignored when is not nil.\n\nThe Go DNS resolver recognizes the resolver option. When is set in , the Go resolver will set the AD bit in DNS queries. The resolver does not make use of the AD bit in responses.\n\nDNS resolution will detect changes to and reload the file when it changes. Checks are made at most once every five seconds, matching the previous handling of and .\n\nThe new configuration setting allows disabling the default handler.\n\nThe new hook is called when a receives an HTTP response from a proxy for a request.\n\nThe HTTP server now accepts HEAD requests containing a body, rather than rejecting them as invalid.\n\nHTTP/2 stream errors returned by functions may be converted to a using .\n\nLeading and trailing spaces are trimmed from cookie names, rather than being rejected as invalid. For example, a cookie setting of “name =value” is now accepted as setting the cookie “name”.\n\nA with an empty Expires field is now considered valid. only checks Expires when it is set.\n\nThe new and functions are the equivalents of and .\n\nOn Windows, the name is no longer treated as a special case in and .\n\nOn Windows, now uses the file handle to retrieve attributes when the file is a directory. Previously it would use the path passed to , which may no longer be the file represented by the file handle if the file has been moved or replaced. This change modifies to open directories without the access, which match the behavior of regular files.\n\nOn Windows, now supports seeking to the beginning of a directory.\n\nThe new fields and specify the behavior of the when its associated is canceled or its process exits with I/O pipes still held open by a child process.\n\nThe new error terminates a immediately but successfully.\n\nThe new function reports whether a path is lexically local to a directory. For example, if is , then will refer to a file that is lexically within the subtree rooted at the current directory.\n\nThe new and methods can be used to compare two s for equality. reports whether is a valid operation for a given receiver.\n\nThe new method extends a slice to guarantee space for another elements.\n\nThe new method sets a value to be the zero value for its type.\n\nGo 1.18 introduced and methods. These are optimizations: is meant to be equivalent to . The implementations incorrectly omitted a check for use of unexported fields that was present in the unoptimized forms. Go 1.20 corrects these methods to include the unexported field check.\n\nGo 1.19.2 and Go 1.18.7 included a security fix to the regular expression parser, making it reject very large expressions that would consume too much memory. Because Go patch releases do not introduce new API, the parser returned in this case. Go 1.20 adds a more specific error, , which the parser now returns instead.\n\nGo 1.20 adds new marker type. Code generated by cgo will use to mark an incomplete C type.\n\nGo 1.20 adds new supported metrics, including the current setting ( ), the number of cgo calls executed ( ), total mutex block time ( ), and various measures of time spent in garbage collection.\n\nTime-based histogram metrics are now less precise, but take up much less memory.\n\nMutex profile samples are now pre-scaled, fixing an issue where old mutex profile samples would be scaled incorrectly if the sampling rate changed during execution.\n\nProfiles collected on Windows now include memory mapping information that fixes symbolization issues for position-independent binaries.\n\nThe garbage collector’s background sweeper now yields less frequently, resulting in many fewer extraneous events in execution traces.\n\nThe new and functions are like and but also report whether the string was trimmed.\n\nThe new methods , , and allow existing map entries to be updated atomically.\n\nOn FreeBSD, compatibility shims needed for FreeBSD 11 and earlier have been removed.\n\nOn Linux, additional constants are defined for use with the field.\n\nOn Linux, the new and fields provide a way to place a child process into a specific cgroup.\n\nThe new method reports the current elapsed time of the benchmark, which may be useful for calculating rates to report with .\n\nCalling from a function passed to was never well-defined, and will now panic.\n\nThe new time layout constants , , and provide names for three of the most common layout strings used in a survey of public Go source code.\n\nThe new method compares two times.\n\nnow ignores sub-nanosecond precision in its input, instead of reporting those digits as an error.\n\nThe method is now more strict about adherence to RFC 3339.\n\nThe new function appends the UTF-16 encoding of a given rune to a uint16 slice, analogous to ."
    },
    {
        "link": "https://meetgor.com/golang-strings",
        "document": "In the 15th post of the Series, we will be looking into the details of the String manipulation and performing types of operations in Golang. We will explore string manipulation, concatenation, helper functions, etc. which will help in working with strings in Golang.\n\nString Concatenation refers to the combining and formatting of strings in Golang. We can combine multiple strings and formating the way we display the strings in Golang. We have a few ways and functions to concatenate strings in Golang.\n\nWe can simply concatenate strings using the operator, though keep in mind you should only concatenate the string with a string and not any other data type like integer, or float, it will throw out errors for mismatched string types.\n\nThe operator will literally join the strings as it is and form a string.\n\nThe other way to continuously append a string to an existing string, we can use the operator. This operator will append the provided string to the end of the original string.\n\nThe join method is a function available in the string package in Golang. We can join strings elements in a slice or an array using the Join method in the strings package in golang. The Join method will combine all the elements in between the elements with a particular string. So, the function takes two parameters , the array or a slice is parsed into the function which will be used to insert the provided string in between the elements of the slice.\n\nIn the above example, we use have used the method to insert a string in between the elements of a slice of strings. The string has been inserted in between the elements, and the elements are combined as a single string. So, each individual element starting from the index is appended the string and further the next element have been appended and the procedure caries on till the last element. Note that the string is not inserted after the last element. The function returns a string and thereby we store the string in a variable.\n\nWe can use the Sprintf function from the fmt package to format the string by storing the string rather than printing it to the console. The sprintf function is quite similar to the but it only parses strings rather than printing them directly to the console.\n\nThe sprintf function basically allows us to concatenate strings in a defined format just like we use to print formatted strings. In the above example, we have formatted three strings in the form of an email by assigning a placeholder for the string i.e. , and adding the required characters in the formatted string.\n\nThe Builder type is provided by the strings package in Golang. The Builder type helps in building strings in an efficient way. By creating a string builder object, we can perform operations on a String.\n\nThe builder structure provided by the strings package is quite important for working with strings in an efficient manner. Its usually used for string concatenation operations. We can perform write operations to the buffer which is a byte slice. Here we have created the variable which is of type , further we have appended the string to it in a for a loop. So, we construct a string from the string list elements, they can be even rune slice or byte slice. We have used three methods here, the , , and which are quite obliviously used for writing , , and to the string builder object.\n\nThe package also has something similar to type in as Buffer. It has almost the same set of methods and properties. The main difference is the efficiency, is comparatively faster than the type due to several low-level implementations. We can discuss those fine details in a separate article but right now we'll focus on the ways we can utilize this type for string concatenation.\n\nSo, like for the type, we have WriteString, WriteByte, and WriteRune in the type. We can use it exactly the way we do with the previous example. Also, the type returns a slice of bytes so we will have to use the String() method to format it as a string.\n\nIf we look at the bytes.Buffer type, it returns a slice of bytes and two more properties viz. and . These two properties are used for indicating the index of the byte in the buffer and reallocation of the buffer. This is too low-level stuff that can be explored and explained in a separate section. For further readings on the bytes Buffer or String Builder types, you can follow up with these articles:\n• Best ways to use bytes.Buffer\n\nNow, we can move into the comparison of Strings in Golang. We have quite a few ways to compare strings in golang. We cover some of them in this section.\n\nThe basic comparison can be done with the comparison operators provided by Golang. Just like we compare numeric data we can compare strings. Though the factor with which we compare them is different. We compare them by the lexical order of the string characters.\n\nIn the above examples, we are able to see the comparison of two strings. There are three strings, two of which are identical, and the third is identical as well but is not equal considering the case of the characters in the string. We have compared the strings in order of the ASCII value of the characters of the strings. For example, A (65) comes before a (97). Similarly, numbers come before letters. So accordingly the comparison of these string characters decides the result.\n\nFor the ASCII table, you can take a look over the below image:\n\nWe also have the Compare method in the strings package for comparing two strings. The comparison method returns an integer value of either -1, 0, or 1. If the two strings are equal, it will return 0. Else if the first string is lexicographically smaller than the second string, it will return -1, else it will return +1.\n\nYou can check out the source code for further clarity.\n\nIn the above example, the two strings and are compared and it returns the integer value , indicating the first string is lexicographically greater than the second string which is true will be lexicographically after due to the presence of .\n\nIn the second example, we are comparing the strings and which are equal, and hence the function returns as expected.\n\nIn the third example, we are comparing the strings and identical to the first case but here order matters. We are comparing with so the first string is lexicographically smaller than the second string and thereby returning as discussed.\n\nWe also have another method in the strings library called EqualFold which compares two strings lexicographically but without considering the case precedence. That is the upper case or lower case is ignored and considered equal. So we are truly case-insensitively comparing the strings.\n\nSo, in the above example, we are comparing the strings and i.e. and , which are equal if we think case-insensitively. Hence the method returns true, they are equal. In the next example, we compare the strings, and i.e. which are not equal, and hence we return . Similar is the case for and which is . Also, if we consider two strings and it will quite obliviously return .\n\nThe strings package in golang has some great utility methods for working with string or any form of text. We will explore some of the quite useful and widely used utilities in the strings package.\n\nThe strings package also provides some utility functions for operating on the case of the characters in the strings. We have functions like ToLower, ToUpper, and Title which can be used to convert the string into lower case, uppercased or Capitalised(Title) cased characters respectively.\n\nHere, we can see that the function, has converted all the characters of a string to the lower case of the alphabet. Similarly, the function has turned the characters of the strings to their respective alphabetical upper case.\n\nThe Title method in the strings package has been deprecated due to incompatibility with certain languages and cases. So, we are using the text/cases package to get the Title method that appropriately converts a string to Title cased. To set up this function, you need to perform a certain package installation process which is quite straightforward. Just create a go mod which is used for managing dependencies and packages for a project. So run the commands given below in the same order in your local setup:\n\nThis will set up a go.mod file and install the packages namely the and packages. After doing this you will be able to access the functions from the cases package which can be imported by the format and . Now, we can use the Title function and parse the parameters which is the language type. Here we have used the which is a language Tag to say use the semantics of English language while parsing the title cased characters. We now assign the value of the function to a variable as it will be of type and we want to still parse the string into the function. The caser object will have certain methods and properties attached to it, we will use the method Strings that will convert the given string into the title cased string. Hence we return the title cased string using the title function with the help of cases and language packages.\n\nIn the strings package, we have the Contains and ContainsAny method which checks for the presence of substrings within a string. This will help in looking up hidden patterns and find for substrings in a string.\n\nThe Contains method helps in getting the exact match of the substring in the given string. Firstly, the method takes two parameters one being the actual string and the other being the substring that you want to find inside the string. Let's say we have the and , then the method will return true because the string contains the substring .\n\nThe method just like the Contains method takes two parameters string and the other as the substring, but it would return true if it finds any character or a single byte(Unicode chars) inside the string. Let's say the and , then the method will return true because the string contains at least one character in the substring which is .\n\nHere, we have used the string methods like and to find the substring inside a string. In the first example, the variable is assigned as and string as . We use the function with parameters . This will return as we can see the is a substring of . Also, we have initialized the variable to . We use the method with the parameters which will return as is not a substring of .\n\nThe next set of examples is of the method which will return true for any character present in the substring is present in the string :). Quite a Simple right, Just understand that any character in your substring present in the string will return . As we see in the example, method is used with the parameters , It will return as is present inside the string, though the entire substring is not present.\n\nThe next example is by passing to the method will return as we don't have either , , or in the string. So this is how the method works.\n\nOther similar methods you might be interested in learning are: Index, IndexAny, LastIndex, etc. you can find the list of methods in the strings package.\n\nWe also have methods to manipulate the string for splitting the characters or bytes with certain patterns. In the strings package, the Split and SplitAfter methods are quite handy to know about.\n\nSo, from the above examples, we can see how and methods work. The Split method splits the text before and after the pattern string also removing the pattern string whereas the method keeps the pattern and splits it after it, hence we see the pattern string getting attached to the left string.\n\nIn the first example, we see the variable being split into strings as being the separator. The Split method returns the slice of the string elements which have been split. In the variable, the is the separator, so we get the resultant slice as , the string acts as a separator and it is ignored.\n\nIn the next example, we see the variable being split into strings as being the separator as previously but here, the splitting occurs after the separator has been parsed. So, we see being split after the separator string and then and so on. Also the next example, in the variable, we see being split instead of using Split.\n\nIn the strings package, we have methods like Repeat and Fields for manipulating the text inside the string. These methods are used to populate or extract data from the string.\n\nThe method is used to create a string by repeating it n number of times and appending it to the string which is returned as the final string. So, the method takes in two parameters the string to repeat, an integer as a count to repeat the string, and returns a string.\n\nSo in this example, we can see that the string is passed to the method with the integer and thus it is appended into itself three times and the resultant string becomes .\n\nThe method is used to extract the words from the string, that is the characters/bytes and group them with one or more consecutive white spaces. The function returns a slice of string.\n\nThe above example demonstrates the usage of which will extract characters and split after encountering whitespace. So, we return a slice of string in which the string elements are split before white space. Thus, using the Fields method we get the words or characters as space-separated values in the slice.\n\nYou can even expand on this method with the FieldsFunc method which allows you to write a custom delimiter option and extract data according to your requirement. There are tons of methods in the strings package for working with strings, you can see a detailed list of functions in the documentation.\n\nThat's it from this part. Reference for all the code examples and commands can be found in the 100 days of Golang GitHub repository.\n\nSo, from this post, we were able to understand the different methods and types to concatenate and interpolate strings in golang. We explored different types of concatenating strings, string comparison, and various methods for manipulating and interpolating strings.\n\nThank you for reading, if you have any queries, feedback, or questions, you can freely ask me on my social handles. Happy Coding :)"
    },
    {
        "link": "https://gobyexample.com/string-functions",
        "document": "The standard library’s package provides many useful string-related functions. Here are some examples to give you a sense of the package.\n\nWe alias to a shorter name as we’ll use it a lot below.\n\nHere’s a sample of the functions available in . Since these are functions from the package, not methods on the string object itself, we need pass the string in question as the first argument to the function. You can find more functions in the package docs."
    },
    {
        "link": "https://pkg.go.dev/strconv",
        "document": "Package strconv implements conversions to and from string representations of basic data types. The most common numeric conversions are Atoi (string to int) and Itoa (int to string). These assume decimal and the Go int type. The parse functions return the widest type (float64, int64, and uint64), but if the size argument specifies a narrower width the result can be converted to that narrower type without data loss: AppendBool, AppendFloat, AppendInt, and AppendUint are similar but append the formatted value to a destination slice. Quote and QuoteToASCII convert strings to quoted Go string literals. The latter guarantees that the result is an ASCII string, by escaping any non-ASCII Unicode with \\u: QuoteRune and QuoteRuneToASCII are similar but accept runes and return quoted Go rune literals. Unquote and UnquoteChar unquote Go string and rune literals.\n\nAppendBool appends \"true\" or \"false\", according to the value of b, to dst and returns the extended buffer. AppendFloat appends the string form of the floating-point number f, as generated by FormatFloat, to dst and returns the extended buffer. AppendInt appends the string form of the integer i, as generated by FormatInt, to dst and returns the extended buffer. AppendQuote appends a double-quoted Go string literal representing s, as generated by Quote, to dst and returns the extended buffer. AppendQuoteRune appends a single-quoted Go character literal representing the rune, as generated by QuoteRune, to dst and returns the extended buffer. AppendQuoteRuneToASCII appends a single-quoted Go character literal representing the rune, as generated by QuoteRuneToASCII, to dst and returns the extended buffer. AppendQuoteRuneToGraphic appends a single-quoted Go character literal representing the rune, as generated by QuoteRuneToGraphic, to dst and returns the extended buffer. AppendQuoteToASCII appends a double-quoted Go string literal representing s, as generated by QuoteToASCII, to dst and returns the extended buffer. AppendQuoteToGraphic appends a double-quoted Go string literal representing s, as generated by QuoteToGraphic, to dst and returns the extended buffer. AppendUint appends the string form of the unsigned integer i, as generated by FormatUint, to dst and returns the extended buffer. Atoi is equivalent to ParseInt(s, 10, 0), converted to type int. CanBackquote reports whether the string s can be represented unchanged as a single-line backquoted string without control characters other than tab. FormatBool returns \"true\" or \"false\" according to the value of b. FormatComplex converts the complex number c to a string of the form (a+bi) where a and b are the real and imaginary parts, formatted according to the format fmt and precision prec. The format fmt and precision prec have the same meaning as in FormatFloat. It rounds the result assuming that the original was obtained from a complex value of bitSize bits, which must be 64 for complex64 and 128 for complex128. FormatFloat converts the floating-point number f to a string, according to the format fmt and precision prec. It rounds the result assuming that the original was obtained from a floating-point value of bitSize bits (32 for float32, 64 for float64). The precision prec controls the number of digits (excluding the exponent) printed by the 'e', 'E', 'f', 'g', 'G', 'x', and 'X' formats. For 'e', 'E', 'f', 'x', and 'X', it is the number of digits after the decimal point. For 'g' and 'G' it is the maximum number of significant digits (trailing zeros are removed). The special precision -1 uses the smallest number of digits necessary such that ParseFloat will return f exactly. The exponent is written as a decimal integer; for all formats other than 'b', it will be at least two digits. package main import ( \"fmt\" \"strconv\" ) func main() { v := 3.1415926535 s32 := strconv.FormatFloat(v, 'E', -1, 32) fmt.Printf(\"%T, %v\n\n\", s32, s32) s64 := strconv.FormatFloat(v, 'E', -1, 64) fmt.Printf(\"%T, %v\n\n\", s64, s64) // fmt.Println uses these arguments to print floats fmt64 := strconv.FormatFloat(v, 'g', -1, 64) fmt.Printf(\"%T, %v\n\n\", fmt64, fmt64) } FormatInt returns the string representation of i in the given base, for 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z' for digit values >= 10. FormatUint returns the string representation of i in the given base, for 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z' for digit values >= 10. IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such characters include letters, marks, numbers, punctuation, symbols, and spaces, from categories L, M, N, P, S, and Zs. IsPrint reports whether the rune is defined as printable by Go, with the same definition as unicode.IsPrint: letters, numbers, punctuation, symbols and ASCII space. ParseBool returns the boolean value represented by the string. It accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False. Any other value returns an error. ParseComplex converts the string s to a complex number with the precision specified by bitSize: 64 for complex64, or 128 for complex128. When bitSize=64, the result still has type complex128, but it will be convertible to complex64 without changing its value. The number represented by s must be of the form N, Ni, or N±Ni, where N stands for a floating-point number as recognized by ParseFloat, and i is the imaginary component. If the second N is unsigned, a + sign is required between the two components as indicated by the ±. If the second N is NaN, only a + sign is accepted. The form may be parenthesized and cannot contain any spaces. The resulting complex number consists of the two components converted by ParseFloat. The errors that ParseComplex returns have concrete type *NumError and include err.Num = s. If s is not syntactically well-formed, ParseComplex returns err.Err = ErrSyntax. If s is syntactically well-formed but either component is more than 1/2 ULP away from the largest floating point number of the given component's size, ParseComplex returns err.Err = ErrRange and c = ±Inf for the respective component. ParseFloat converts the string s to a floating-point number with the precision specified by bitSize: 32 for float32, or 64 for float64. When bitSize=32, the result still has type float64, but it will be convertible to float32 without changing its value. ParseFloat accepts decimal and hexadecimal floating-point numbers as defined by the Go syntax for floating-point literals. If s is well-formed and near a valid floating-point number, ParseFloat returns the nearest floating-point number rounded using IEEE754 unbiased rounding. (Parsing a hexadecimal floating-point value only rounds when there are more bits in the hexadecimal representation than will fit in the mantissa.) The errors that ParseFloat returns have concrete type *NumError and include err.Num = s. If s is not syntactically well-formed, ParseFloat returns err.Err = ErrSyntax. If s is syntactically well-formed but is more than 1/2 ULP away from the largest floating point number of the given size, ParseFloat returns f = ±Inf, err.Err = ErrRange. ParseFloat recognizes the string \"NaN\", and the (possibly signed) strings \"Inf\" and \"Infinity\" as their respective special floating point values. It ignores case when matching. package main import ( \"fmt\" \"strconv\" ) func main() { v := \"3.1415926535\" if s, err := strconv.ParseFloat(v, 32); err == nil { fmt.Printf(\"%T, %v\n\n\", s, s) } if s, err := strconv.ParseFloat(v, 64); err == nil { fmt.Printf(\"%T, %v\n\n\", s, s) } if s, err := strconv.ParseFloat(\"NaN\", 32); err == nil { fmt.Printf(\"%T, %v\n\n\", s, s) } // ParseFloat is case insensitive if s, err := strconv.ParseFloat(\"nan\", 32); err == nil { fmt.Printf(\"%T, %v\n\n\", s, s) } if s, err := strconv.ParseFloat(\"inf\", 32); err == nil { fmt.Printf(\"%T, %v\n\n\", s, s) } if s, err := strconv.ParseFloat(\"+Inf\", 32); err == nil { fmt.Printf(\"%T, %v\n\n\", s, s) } if s, err := strconv.ParseFloat(\"-Inf\", 32); err == nil { fmt.Printf(\"%T, %v\n\n\", s, s) } if s, err := strconv.ParseFloat(\"-0\", 32); err == nil { fmt.Printf(\"%T, %v\n\n\", s, s) } if s, err := strconv.ParseFloat(\"+0\", 32); err == nil { fmt.Printf(\"%T, %v\n\n\", s, s) } } ParseInt interprets a string s in the given base (0, 2 to 36) and bit size (0 to 64) and returns the corresponding value i. The string may begin with a leading sign: \"+\" or \"-\". If the base argument is 0, the true base is implied by the string's prefix following the sign (if present): 2 for \"0b\", 8 for \"0\" or \"0o\", 16 for \"0x\", and 10 otherwise. Also, for argument base 0 only, underscore characters are permitted as defined by the Go syntax for integer literals. The bitSize argument specifies the integer type that the result must fit into. Bit sizes 0, 8, 16, 32, and 64 correspond to int, int8, int16, int32, and int64. If bitSize is below 0 or above 64, an error is returned. The errors that ParseInt returns have concrete type *NumError and include err.Num = s. If s is empty or contains invalid digits, err.Err = ErrSyntax and the returned value is 0; if the value corresponding to s cannot be represented by a signed integer of the given size, err.Err = ErrRange and the returned value is the maximum magnitude integer of the appropriate bitSize and sign. package main import ( \"fmt\" \"strconv\" ) func main() { v32 := \"-354634382\" if s, err := strconv.ParseInt(v32, 10, 32); err == nil { fmt.Printf(\"%T, %v\n\n\", s, s) } if s, err := strconv.ParseInt(v32, 16, 32); err == nil { fmt.Printf(\"%T, %v\n\n\", s, s) } v64 := \"-3546343826724305832\" if s, err := strconv.ParseInt(v64, 10, 64); err == nil { fmt.Printf(\"%T, %v\n\n\", s, s) } if s, err := strconv.ParseInt(v64, 16, 64); err == nil { fmt.Printf(\"%T, %v\n\n\", s, s) } } ParseUint is like ParseInt but for unsigned numbers. Quote returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\\t, \n\n, \\xFF, \\u0100) for control characters and non-printable characters as defined by IsPrint. QuoteRune returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\\t, \n\n, \\xFF, \\u0100) for control characters and non-printable characters as defined by IsPrint. If r is not a valid Unicode code point, it is interpreted as the Unicode replacement character U+FFFD. QuoteRuneToASCII returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\\t, \n\n, \\xFF, \\u0100) for non-ASCII characters and non-printable characters as defined by IsPrint. If r is not a valid Unicode code point, it is interpreted as the Unicode replacement character U+FFFD. QuoteRuneToGraphic returns a single-quoted Go character literal representing the rune. If the rune is not a Unicode graphic character, as defined by IsGraphic, the returned string will use a Go escape sequence (\\t, \n\n, \\xFF, \\u0100). If r is not a valid Unicode code point, it is interpreted as the Unicode replacement character U+FFFD. QuoteToASCII returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\\t, \n\n, \\xFF, \\u0100) for non-ASCII characters and non-printable characters as defined by IsPrint. QuoteToGraphic returns a double-quoted Go string literal representing s. The returned string leaves Unicode graphic characters, as defined by IsGraphic, unchanged and uses Go escape sequences (\\t, \n\n, \\xFF, \\u0100) for non-graphic characters. package main import ( \"fmt\" \"strconv\" ) func main() { s := strconv.QuoteToGraphic(\"☺\") fmt.Println(s) // This string literal contains a tab character. s = strconv.QuoteToGraphic(\"This is a \\u263a \\u000a\") fmt.Println(s) s = strconv.QuoteToGraphic(`\" This is a ☺ \n\n \"`) fmt.Println(s) } \"☺\" \"This is a ☺\\t\n\n\" \"\\\" This is a ☺ \\\n\n \\\"\" QuotedPrefix returns the quoted string (as understood by Unquote) at the prefix of s. If s does not start with a valid quoted string, QuotedPrefix returns an error. package main import ( \"fmt\" \"strconv\" ) func main() { s, err := strconv.QuotedPrefix(\"not a quoted string\") fmt.Printf(\"%q, %v\n\n\", s, err) s, err = strconv.QuotedPrefix(\"\\\"double-quoted string\\\" with trailing text\") fmt.Printf(\"%q, %v\n\n\", s, err) s, err = strconv.QuotedPrefix(\"`or backquoted` with more trailing text\") fmt.Printf(\"%q, %v\n\n\", s, err) s, err = strconv.QuotedPrefix(\"'\\u263a' is also okay\") fmt.Printf(\"%q, %v\n\n\", s, err) } Unquote interprets s as a single-quoted, double-quoted, or backquoted Go string literal, returning the string value that s quotes. (If s is single-quoted, it would be a Go character literal; Unquote returns the corresponding one-character string. For an empty character literal Unquote returns the empty string.) package main import ( \"fmt\" \"strconv\" ) func main() { s, err := strconv.Unquote(\"You can't unquote a string without quotes\") fmt.Printf(\"%q, %v\n\n\", s, err) s, err = strconv.Unquote(\"\\\"The string must be either double-quoted\\\"\") fmt.Printf(\"%q, %v\n\n\", s, err) s, err = strconv.Unquote(\"`or backquoted.`\") fmt.Printf(\"%q, %v\n\n\", s, err) s, err = strconv.Unquote(\"'\\u263a'\") // single character only allowed in single quotes fmt.Printf(\"%q, %v\n\n\", s, err) s, err = strconv.Unquote(\"'\\u2639\\u2639'\") fmt.Printf(\"%q, %v\n\n\", s, err) } \"\", invalid syntax \"The string must be either double-quoted\", <nil> \"or backquoted.\", <nil> \"☺\", <nil> \"\", invalid syntax UnquoteChar decodes the first character or byte in the escaped string or character literal represented by the string s. It returns four values:\n• value, the decoded Unicode code point or byte value;\n• tail, the remainder of the string after the character; and\n• an error that will be nil if the character is syntactically valid. The second argument, quote, specifies the type of literal being parsed and therefore which escaped quote character is permitted. If set to a single quote, it permits the sequence \\' and disallows unescaped '. If set to a double quote, it permits \\\" and disallows unescaped \". If set to zero, it does not permit either escape and allows both quote characters to appear unescaped."
    },
    {
        "link": "https://tip.golang.org/doc/comment",
        "document": "“Doc comments” are comments that appear immediately before top-level package, const, func, type, and var declarations with no intervening newlines. Every exported (capitalized) name should have a doc comment.\n\nThe go/doc and go/doc/comment packages provide the ability to extract documentation from Go source code, and a variety of tools make use of this functionality. The command looks up and prints the doc comment for a given package or symbol. (A symbol is a top-level const, func, type, or var.) The web server pkg.go.dev shows the documentation for public Go packages (when their licenses permit that use). The program serving that site is golang.org/x/pkgsite/cmd/pkgsite, which can also be run locally to view documentation for private modules or without an internet connection. The language server gopls provides documentation when editing Go source files in IDEs.\n\nThe rest of this page documents how to write Go doc comments.\n\nEvery package should have a package comment introducing the package. It provides information relevant to the package as a whole and generally sets expectations for the package. Especially in large packages, it can be helpful for the package comment to give a brief overview of the most important parts of the API, linking to other doc comments as needed.\n\nIf the package is simple, the package comment can be brief. For example:\n\nAs can be seen in this example, Go doc comments use complete sentences. For a package comment, that means the first sentence begins with “Package\n\nFor multi-file packages, the package comment should only be in one source file. If multiple files have package comments, they are concatenated to form one large comment for the entire package.\n\nA package comment for a command is similar, but it describes the behavior of the program rather than the Go symbols in the package. The first sentence conventionally begins with the name of the program itself, capitalized because it is at the start of a sentence. For example, here is an abridged version of the package comment for gofmt:\n\nThe beginning of the comment is written using semantic linefeeds, in which each new sentence or long phrase is on a line by itself, which can make diffs easier to read as code and comments evolve. The later paragraphs happen not to follow this convention and have been wrapped by hand. Whatever is best for your code base is fine. Either way, and rewrap doc comment text when printing it. For example:\n\nThe indented lines are treated as preformatted text: they are not rewrapped and are printed in code font in HTML and Markdown presentations. (The Syntax section below gives the details.)\n\nA type’s doc comment should explain what each instance of that type represents or provides. If the API is simple, the doc comment can be quite short. For example:\n\nBy default, programmers should expect that a type is safe for use only by a single goroutine at a time. If a type provides stronger guarantees, the doc comment should state them. For example:\n\nGo types should also aim to make the zero value have a useful meaning. If it isn’t obvious, that meaning should be documented. For example:\n\nFor a struct with exported fields, either the doc comment or per-field comments should explain the meaning of each exported field. For example, this type’s doc comment explains the fields:\n\nIn contrast, this type’s doc comment leaves the explanations to per-field comments:\n\nAs with packages (above) and funcs (below), doc comments for types start with complete sentences naming the declared symbol. An explicit subject often makes the wording clearer, and it makes the text easier to search, whether on a web page or a command line. For example:\n\nA function’s doc comment should explain what the function returns or, for functions called for side effects, what it does. Named parameters and results can be referred to directly in the comment, without any special syntax like backquotes. (A consequence of this convention is that names like , which might be mistaken for ordinary words, are typically avoided.) For example:\n\nDoc comments typically use the phrase “reports whether” to describe functions that return a boolean. The phrase “or not” is unnecessary. For example:\n\nIf a doc comment needs to explain multiple results, naming the results can make the doc comment more understandable, even if the names are not used in the body of the function. For example:\n\nConversely, when the results don’t need to be named in the doc comment, they are usually omitted in the code as well, like in the example above, to avoid cluttering the presentation.\n\nThese rules all apply both to plain functions and to methods. For methods, using the same receiver name avoids needless variation when listing all the methods of a type:\n\nThis example also shows that top-level functions returning a type or pointer , perhaps with an additional error result, are shown alongside the type and its methods, under the assumption that they are ’s constructors.\n\nBy default, programmers can assume that a top-level function is safe to call from multiple goroutines; this fact need not be stated explicitly.\n\nOn the other hand, as noted in the previous section, using an instance of a type in any way, including calling a method, is typically assumed to be restricted to a single goroutine at a time. If the methods that are safe for concurrent use are not documented in the type’s doc comment, they should be documented in per-method comments. For example:\n\nNote that function and method doc comments focus on what the operation returns or does, detailing what the caller needs to know. Special cases can be particularly important to document. For example:\n\nDoc comments should not explain internal details such as the algorithm used in the current implementation. Those are best left to comments inside the function body. It may be appropriate to give asymptotic time or space bounds when that detail is particularly important to callers. For example:\n\nBecause this doc comment makes no mention of which sorting algorithm is used, it is easier to change the implementation to use a different algorithm in the future.\n\nGo’s declaration syntax allows grouping of declarations, in which case a single doc comment can introduce a group of related constants, with individual constants only documented by short end-of-line comments. For example:\n\nSometimes the group needs no doc comment at all. For example:\n\nOn the other hand, ungrouped constants typically warrant a full doc comment starting with a complete sentence. For example:\n\nTyped constants are displayed next to the declaration of their type and as a result often omit a const group doc comment in favor of the type’s doc comment. For example:\n\nThe conventions for variables are the same as those for constants. For example, here is a set of grouped variables:\n\nGo doc comments are written in a simple syntax that supports paragraphs, headings, links, lists, and preformatted code blocks. To keep comments lightweight and readable in source files, there is no support for complex features like font changes or raw HTML. Markdown aficionados can view the syntax as a simplified subset of Markdown.\n\nThe standard formatter gofmt reformats doc comments to use a canonical formatting for each of these features. Gofmt aims for readability and user control over how comments are written in source code but will adjust presentation to make the semantic meaning of a particular comment clearer, analogous to reformatting to in ordinary source code.\n\nDirective comments such as are not considered part of a doc comment and are omitted from rendered documentation. Gofmt moves directive comments to the end of the doc comment, preceded by a blank line. For example:\n\nA directive comment is a line matching the regular expression . Tools that define their own directives should use the form .\n\nGofmt removes leading and trailing blank lines in doc comments. If all lines in a doc comment begin with the same sequence of spaces and tabs, gofmt removes that prefix.\n\nA paragraph is a span of unindented non-blank lines. We’ve already seen many examples of paragraphs.\n\nA pair of consecutive backticks (` U+0060) is interpreted as a Unicode left quote (“ U+201C), and a pair of consecutive single quotes (' U+0027) is interpreted as a Unicode right quote (” U+201D).\n\nGofmt preserves line breaks in paragraph text: it does not rewrap the text. This allows the use of semantic linefeeds, as seen earlier. Gofmt replaces duplicated blank lines between paragraphs with a single blank line. Gofmt also reformats consecutive backticks or single quotes to their Unicode interpretations.\n\nNotes are special comments of the form . MARKER should consist of 2 or more upper case letters, identifying the type of note, while uid is at least 1 character, usually a username of someone who can provide more information. The following the uid is optional.\n\nNotes are collected and rendered in their own section on pkg.go.dev.\n\nParagraphs starting with are treated as deprecation notices. Some tools will warn when deprecated identifiers are used. pkg.go.dev will hide their docs by default.\n\nDeprecation notices are followed by some information about the deprecation, and a recommendation on what to use instead, if applicable. The paragraph does not have to be the last paragraph in the doc comment.\n\nA heading is a line beginning with a number sign (U+0023) and then a space and the heading text. To be recognized as a heading, the line must be unindented and set off from adjacent paragraph text by blank lines.\n\nOn the other hand:\n\nThe # syntax was added in Go 1.19. Before Go 1.19, headings were identified implicitly by single-line paragraphs satisfying certain conditions, most notably the lack of any terminating punctuation.\n\nGofmt reformats lines treated as implicit headings by earlier versions of Go to use # headings instead. If the reformatting is not appropriate—that is, if the line was not meant to be a heading—the easiest way to make it a paragraph is to introduce terminating punctuation such as a period or colon, or to break it into two lines.\n\nA span of unindented non-blank lines defines link targets when every line is of the form “[Text]: URL”. In other text in the same doc comment, “[Text]” represents a link to URL using the given text—in HTML, <a href=“URL”>Text</a>. For example:\n\nBy keeping URLs in a separate section, this format only minimally interrupts the flow of the actual text. It also roughly matches the Markdown shortcut reference link format, without the optional title text.\n\nIf there is no corresponding URL declaration, then (except for doc links, described in the next section) “[Text]” is not a hyperlink, and the square brackets are preserved when displayed. Each doc comment is considered independently: link target definitions in one comment do not affect other comments.\n\nAlthough link target definition blocks may be interleaved with ordinary paragraphs, gofmt moves all link target definitions to the end of the doc comment, in up to two blocks: first a block containing all the link targets that are referenced in the comment, and then a block containing all the targets not referenced in the comment. The separate block makes unused targets easy to notice and fix (in case the links or the definitions have typos) or to delete (in case the definitions are no longer needed).\n\nPlain text that is recognized as a URL is automatically linked in HTML renderings.\n\nDoc links are links of the form “[Name1]” or “[Name1.Name2]” to refer to exported identifiers in the current package, or “[pkg]”, “[pkg.Name1]”, or “[pkg.Name1.Name2]” to refer to identifiers in other packages.\n\nThe bracketed text for a symbol link can include an optional leading star, making it easy to refer to pointer types, such as [*bytes.Buffer].\n\nWhen referring to other packages, “pkg” can be either a full import path or the assumed package name of an existing import. The assumed package name is either the identifier in a renamed import or else the name assumed by goimports. (Goimports inserts renamings when that assumption is not correct, so this rule should work for essentially all Go code.) For example, if the current package imports encoding/json, then “[json.Decoder]” can be written in place of “[encoding/json.Decoder]” to link to the docs for encoding/json’s Decoder. If different source files in a package import different packages using the same name, then the shorthand is ambiguous and cannot be used.\n\nA “pkg” is only assumed to be a full import path if it starts with a domain name (a path element with a dot) or is one of the packages from the standard library (“[os]”, “[encoding/json]”, and so on). For example, and are documentation links (the latter will be a broken link), but is not, because there is no os/sys package in the standard library.\n\nTo avoid problems with maps, generics, and array types, doc links must be both preceded and followed by punctuation, spaces, tabs, or the start or end of a line. For example, the text “map[ast.Expr]TypeAndValue” does not contain a doc link.\n\nA list is a span of indented or blank lines (which would otherwise be a code block, as described in the next section) in which the first indented line begins with a bullet list marker or a numbered list marker.\n\nA bullet list marker is a star, plus, dash, or Unicode bullet (*, +, -, •; U+002A, U+002B, U+002D, U+2022) followed by a space or tab and then text. In a bullet list, each line beginning with a bullet list marker starts a new list item.\n\nA numbered list marker is a decimal number of any length followed by a period or right parenthesis, then a space or tab, and then text. In a numbered list, each line beginning with a number list marker starts a new list item. Item numbers are left as is, never renumbered.\n\nList items only contain paragraphs, not code blocks or nested lists. This avoids any space-counting subtlety as well as questions about how many spaces a tab counts for in inconsistent indentation.\n\nGofmt reformats bullet lists to use a dash as the bullet marker, two spaces of indentation before the dash, and four spaces of indentation for continuation lines.\n\nGofmt reformats numbered lists to use a single space before the number, a period after the number, and again four spaces of indentation for continuation lines.\n\nGofmt preserves but does not require a blank line between a list and the preceding paragraph. It inserts a blank line between a list and the following paragraph or heading.\n\nA code block is a span of indented or blank lines not starting with a bullet list marker or numbered list marker. It is rendered as preformatted text (a <pre> block in HTML).\n\nCode blocks often contain Go code. For example:\n\nOf course, code blocks also often contain preformatted text besides code. For example:\n\nGofmt indents all lines in a code block by a single tab, replacing any other indentation the non-blank lines have in common. Gofmt also inserts a blank line before and after each code block, distinguishing the code block clearly from the surrounding paragraph text.\n\nThe rule that any span of indented or blank lines in a doc comment is rendered as a code block dates to the earliest days of Go. Unfortunately, the lack of support for doc comments in gofmt has led to many existing comments that use indentation without meaning to create a code block.\n\nFor example, this unindented list has always been interpreted by godoc as a three-line paragraph followed by a one-line code block:\n\nThis always rendered in as:\n\nSimilarly, the command in this comment is a one-line paragraph followed by a one-line code block:\n\nThis rendered in as:\n\nAnd this comment is a two-line paragraph (the second line is “{”), followed by a six-line indented code block and a one-line paragraph (“}”).\n\nAnd this rendered in as:\n\nAnother common mistake was an unindented Go function definition or block statement, similarly bracketed by “{” and “}”.\n\nThe introduction of doc comment reformatting in Go 1.19’s gofmt makes mistakes like these more visible by adding blank lines around the code blocks.\n\nAnalysis in 2022 found that only 3% of doc comments in public Go modules were reformatted at all by the draft Go 1.19 gofmt. Limiting ourselves to those comments, about 87% of gofmt’s reformattings preserved the structure that a person would infer from reading the comment; about 6% were tripped up by these kinds of unindented lists, unindented multiline shell commands, and unindented brace-delimited code blocks.\n\nBased on this analysis, the Go 1.19 gofmt applies a few heuristics to merge unindented lines into an adjacent indented list or code block. With those adjustments, the Go 1.19 gofmt reformats the above examples to:\n\nThis reformatting makes the meaning clearer as well as making the doc comments render correctly in earlier versions of Go. If the heuristic ever makes a bad decision, it can be overridden by inserting a blank line to clearly separate the paragraph text from non-paragraph text.\n\nEven with these heuristics, other existing comments will need manual adjustment to correct their rendering. The most common mistake is indenting a wrapped unindented line of text. For example:\n\nIn both of these, the last line is indented, making it a code block. The fix is to unindent the lines.\n\nAnother common mistake is not indenting a wrapped indented line of a list or code block. For example:\n\nThe fix is to indent the wrapped lines.\n\nGo doc comments do not support nested lists, so gofmt reformats\n\nRewriting the text to avoid nested lists usually improves the documentation and is the best solution. Another potential workaround is to mix list markers, since bullet markers do not introduce list items in a numbered list, nor vice versa. For example:"
    },
    {
        "link": "https://pkg.go.dev/encoding/binary",
        "document": "Package binary implements simple translation between numbers and byte sequences and encoding and decoding of varints. Numbers are translated by reading and writing fixed-size values. A fixed-size value is either a fixed-size arithmetic type (bool, int8, uint8, int16, float32, complex64, ...) or an array or struct containing only fixed-size values. The varint functions encode and decode single integer values using a variable-length encoding; smaller values require fewer bytes. For a specification, see https://developers.google.com/protocol-buffers/docs/encoding. This package favors simplicity over efficiency. Clients that require high-performance serialization, especially for large data structures, should look at more advanced solutions such as the encoding/gob package or google.golang.org/protobuf for protocol buffers.\n\nAppend appends the binary representation of data to buf. buf may be nil, in which case a new buffer will be allocated. See Write on which data are acceptable. It returns the (possibly extended) buffer containing data or an error. AppendUvarint appends the varint-encoded form of x, as generated by PutUvarint, to buf and returns the extended buffer. AppendVarint appends the varint-encoded form of x, as generated by PutVarint, to buf and returns the extended buffer. Decode decodes binary data from buf into data according to the given byte order. It returns an error if buf is too small, otherwise the number of bytes consumed from buf. Encode encodes the binary representation of data into buf according to the given byte order. It returns an error if buf is too small, otherwise the number of bytes written into buf. PutUvarint encodes a uint64 into buf and returns the number of bytes written. If the buffer is too small, PutUvarint will panic. PutVarint encodes an int64 into buf and returns the number of bytes written. If the buffer is too small, PutVarint will panic. Read reads structured binary data from r into data. Data must be a pointer to a fixed-size value or a slice of fixed-size values. Bytes read from r are decoded using the specified byte order and written to successive fields of the data. When decoding boolean values, a zero byte is decoded as false, and any other non-zero byte is decoded as true. When reading into structs, the field data for fields with blank (_) field names is skipped; i.e., blank field names may be used for padding. When reading into a struct, all non-blank fields must be exported or Read may panic. The error is io.EOF only if no bytes were read. If an io.EOF happens after reading some but not all the bytes, Read returns io.ErrUnexpectedEOF. ReadUvarint reads an encoded unsigned integer from r and returns it as a uint64. The error is io.EOF only if no bytes were read. If an io.EOF happens after reading some but not all the bytes, ReadUvarint returns io.ErrUnexpectedEOF. ReadVarint reads an encoded signed integer from r and returns it as an int64. The error is io.EOF only if no bytes were read. If an io.EOF happens after reading some but not all the bytes, ReadVarint returns io.ErrUnexpectedEOF. Size returns how many bytes Write would generate to encode the value v, which must be a fixed-size value or a slice of fixed-size values, or a pointer to such data. If v is neither of these, Size returns -1. Uvarint decodes a uint64 from buf and returns that value and the number of bytes read (> 0). If an error occurred, the value is 0 and the number of bytes n is <= 0 meaning:\n• n < 0: value larger than 64 bits (overflow) and -n is the number of bytes read. package main import ( \"encoding/binary\" \"fmt\" ) func main() { inputs := [][]byte{ {0x01}, {0x02}, {0x7f}, {0x80, 0x01}, {0xff, 0x01}, {0x80, 0x02}, } for _, b := range inputs { x, n := binary.Uvarint(b) if n != len(b) { fmt.Println(\"Uvarint did not consume all of in\") } fmt.Println(x) } } Varint decodes an int64 from buf and returns that value and the number of bytes read (> 0). If an error occurred, the value is 0 and the number of bytes n is <= 0 with the following meaning:\n• n < 0: value larger than 64 bits (overflow) and -n is the number of bytes read. package main import ( \"encoding/binary\" \"fmt\" ) func main() { inputs := [][]byte{ {0x81, 0x01}, {0x7f}, {0x03}, {0x01}, {0x00}, {0x02}, {0x04}, {0x7e}, {0x80, 0x01}, } for _, b := range inputs { x, n := binary.Varint(b) if n != len(b) { fmt.Println(\"Varint did not consume all of in\") } fmt.Println(x) } } Write writes the binary representation of data into w. Data must be a fixed-size value or a slice of fixed-size values, or a pointer to such data. Boolean values encode as one byte: 1 for true, and 0 for false. Bytes written to w are encoded using the specified byte order and read from successive fields of the data. When writing structs, zero values are written for fields with blank (_) field names. package main import ( \"bytes\" \"encoding/binary\" \"fmt\" ) func main() { buf := new(bytes.Buffer) var data = []any{ uint16(61374), int8(-54), uint8(254), } for _, v := range data { err := binary.Write(buf, binary.LittleEndian, v) if err != nil { fmt.Println(\"binary.Write failed:\", err) } } fmt.Printf(\"%x\", buf.Bytes()) }"
    },
    {
        "link": "https://golang.bg/pkg/strconv",
        "document": "Package strconv implements conversions to and from string representations of basic data types. The most common numeric conversions are Atoi (string to int) and Itoa (int to string). These assume decimal and the Go int type. The parse functions return the widest type (float64, int64, and uint64), but if the size argument specifies a narrower width the result can be converted to that narrower type without data loss: AppendBool, AppendFloat, AppendInt, and AppendUint are similar but append the formatted value to a destination slice. Quote and QuoteToASCII convert strings to quoted Go string literals. The latter guarantees that the result is an ASCII string, by escaping any non-ASCII Unicode with \\u: QuoteRune and QuoteRuneToASCII are similar but accept runes and return quoted Go rune literals. Unquote and UnquoteChar unquote Go string and rune literals.\n\nIntSize is the size in bits of an int or uint value.\n\nErrRange indicates that a value is out of range for the target type.\n\nErrSyntax indicates that a value does not have the right syntax for the target type.\n\nAppendBool appends \"true\" or \"false\", according to the value of b, to dst and returns the extended buffer.\n\nAppendFloat appends the string form of the floating-point number f, as generated by FormatFloat, to dst and returns the extended buffer.\n\nAppendInt appends the string form of the integer i, as generated by FormatInt, to dst and returns the extended buffer.\n\nAppendQuote appends a double-quoted Go string literal representing s, as generated by Quote, to dst and returns the extended buffer.\n\nAppendQuoteRune appends a single-quoted Go character literal representing the rune, as generated by QuoteRune, to dst and returns the extended buffer.\n\nAppendQuoteRuneToASCII appends a single-quoted Go character literal representing the rune, as generated by QuoteRuneToASCII, to dst and returns the extended buffer.\n\nAppendQuoteRuneToGraphic appends a single-quoted Go character literal representing the rune, as generated by QuoteRuneToGraphic, to dst and returns the extended buffer.\n\nAppendQuoteToASCII appends a double-quoted Go string literal representing s, as generated by QuoteToASCII, to dst and returns the extended buffer.\n\nAppendQuoteToGraphic appends a double-quoted Go string literal representing s, as generated by QuoteToGraphic, to dst and returns the extended buffer.\n\nAppendUint appends the string form of the unsigned integer i, as generated by FormatUint, to dst and returns the extended buffer.\n\nAtoi is equivalent to ParseInt(s, 10, 0), converted to type int.\n\nCanBackquote reports whether the string s can be represented unchanged as a single-line backquoted string without control characters other than tab.\n\nFormatBool returns \"true\" or \"false\" according to the value of b.\n\nFormatComplex converts the complex number c to a string of the form (a+bi) where a and b are the real and imaginary parts, formatted according to the format fmt and precision prec.\n\nThe format fmt and precision prec have the same meaning as in FormatFloat. It rounds the result assuming that the original was obtained from a complex value of bitSize bits, which must be 64 for complex64 and 128 for complex128.\n\nFormatFloat converts the floating-point number f to a string, according to the format fmt and precision prec. It rounds the result assuming that the original was obtained from a floating-point value of bitSize bits (32 for float32, 64 for float64).\n\nThe format fmt is one of\n\nThe precision prec controls the number of digits (excluding the exponent) printed by the 'e', 'E', 'f', 'g', 'G', 'x', and 'X' formats. For 'e', 'E', 'f', 'x', and 'X', it is the number of digits after the decimal point. For 'g' and 'G' it is the maximum number of significant digits (trailing zeros are removed). The special precision -1 uses the smallest number of digits necessary such that ParseFloat will return f exactly. The exponent is written as a decimal integer; for all formats other than 'b', it will be at least two digits.\n\nFormatInt returns the string representation of i in the given base, for 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z' for digit values >= 10.\n\nFormatUint returns the string representation of i in the given base, for 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z' for digit values >= 10.\n\nIsGraphic reports whether the rune is defined as a Graphic by Unicode. Such characters include letters, marks, numbers, punctuation, symbols, and spaces, from categories L, M, N, P, S, and Zs.\n\nIsPrint reports whether the rune is defined as printable by Go, with the same definition as unicode.IsPrint: letters, numbers, punctuation, symbols and ASCII space.\n\nParseBool returns the boolean value represented by the string. It accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False. Any other value returns an error.\n\nParseComplex converts the string s to a complex number with the precision specified by bitSize: 64 for complex64, or 128 for complex128. When bitSize=64, the result still has type complex128, but it will be convertible to complex64 without changing its value.\n\nThe number represented by s must be of the form N, Ni, or N±Ni, where N stands for a floating-point number as recognized by ParseFloat, and i is the imaginary component. If the second N is unsigned, a + sign is required between the two components as indicated by the ±. If the second N is NaN, only a + sign is accepted. The form may be parenthesized and cannot contain any spaces. The resulting complex number consists of the two components converted by ParseFloat.\n\nThe errors that ParseComplex returns have concrete type *NumError and include err.Num = s.\n\nIf s is not syntactically well-formed, ParseComplex returns err.Err = ErrSyntax.\n\nIf s is syntactically well-formed but either component is more than 1/2 ULP away from the largest floating point number of the given component's size, ParseComplex returns err.Err = ErrRange and c = ±Inf for the respective component.\n\nParseFloat converts the string s to a floating-point number with the precision specified by bitSize: 32 for float32, or 64 for float64. When bitSize=32, the result still has type float64, but it will be convertible to float32 without changing its value.\n\nParseFloat accepts decimal and hexadecimal floating-point numbers as defined by the Go syntax for floating-point literals. If s is well-formed and near a valid floating-point number, ParseFloat returns the nearest floating-point number rounded using IEEE754 unbiased rounding. (Parsing a hexadecimal floating-point value only rounds when there are more bits in the hexadecimal representation than will fit in the mantissa.)\n\nThe errors that ParseFloat returns have concrete type *NumError and include err.Num = s.\n\nIf s is not syntactically well-formed, ParseFloat returns err.Err = ErrSyntax.\n\nIf s is syntactically well-formed but is more than 1/2 ULP away from the largest floating point number of the given size, ParseFloat returns f = ±Inf, err.Err = ErrRange.\n\nParseFloat recognizes the string \"NaN\", and the (possibly signed) strings \"Inf\" and \"Infinity\" as their respective special floating point values. It ignores case when matching.\n\nParseInt interprets a string s in the given base (0, 2 to 36) and bit size (0 to 64) and returns the corresponding value i.\n\nThe string may begin with a leading sign: \"+\" or \"-\".\n\nIf the base argument is 0, the true base is implied by the string's prefix following the sign (if present): 2 for \"0b\", 8 for \"0\" or \"0o\", 16 for \"0x\", and 10 otherwise. Also, for argument base 0 only, underscore characters are permitted as defined by the Go syntax for integer literals.\n\nThe bitSize argument specifies the integer type that the result must fit into. Bit sizes 0, 8, 16, 32, and 64 correspond to int, int8, int16, int32, and int64. If bitSize is below 0 or above 64, an error is returned.\n\nThe errors that ParseInt returns have concrete type *NumError and include err.Num = s. If s is empty or contains invalid digits, err.Err = ErrSyntax and the returned value is 0; if the value corresponding to s cannot be represented by a signed integer of the given size, err.Err = ErrRange and the returned value is the maximum magnitude integer of the appropriate bitSize and sign.\n\nParseUint is like ParseInt but for unsigned numbers.\n\nQuote returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\\t, \n\n, \\xFF, \\u0100) for control characters and non-printable characters as defined by IsPrint.\n\nQuoteRune returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\\t, \n\n, \\xFF, \\u0100) for control characters and non-printable characters as defined by IsPrint. If r is not a valid Unicode code point, it is interpreted as the Unicode replacement character U+FFFD.\n\nQuoteRuneToASCII returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\\t, \n\n, \\xFF, \\u0100) for non-ASCII characters and non-printable characters as defined by IsPrint. If r is not a valid Unicode code point, it is interpreted as the Unicode replacement character U+FFFD.\n\nQuoteRuneToGraphic returns a single-quoted Go character literal representing the rune. If the rune is not a Unicode graphic character, as defined by IsGraphic, the returned string will use a Go escape sequence (\\t, \n\n, \\xFF, \\u0100). If r is not a valid Unicode code point, it is interpreted as the Unicode replacement character U+FFFD.\n\nQuoteToASCII returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\\t, \n\n, \\xFF, \\u0100) for non-ASCII characters and non-printable characters as defined by IsPrint.\n\nQuoteToGraphic returns a double-quoted Go string literal representing s. The returned string leaves Unicode graphic characters, as defined by IsGraphic, unchanged and uses Go escape sequences (\\t, \n\n, \\xFF, \\u0100) for non-graphic characters.\n\nQuotedPrefix returns the quoted string (as understood by Unquote) at the prefix of s. If s does not start with a valid quoted string, QuotedPrefix returns an error.\n\nUnquote interprets s as a single-quoted, double-quoted, or backquoted Go string literal, returning the string value that s quotes. (If s is single-quoted, it would be a Go character literal; Unquote returns the corresponding one-character string. For an empty character literal Unquote returns the empty string.)\n\nUnquoteChar decodes the first character or byte in the escaped string or character literal represented by the string s. It returns four values:\n• value, the decoded Unicode code point or byte value;\n• tail, the remainder of the string after the character; and\n• an error that will be nil if the character is syntactically valid.\n\nThe second argument, quote, specifies the type of literal being parsed and therefore which escaped quote character is permitted. If set to a single quote, it permits the sequence \\' and disallows unescaped '. If set to a double quote, it permits \\\" and disallows unescaped \". If set to zero, it does not permit either escape and allows both quote characters to appear unescaped."
    },
    {
        "link": "https://google.github.io/styleguide/go/best-practices.html",
        "document": "Note: This is part of a series of documents that outline Go Style at Google. This document is neither normative nor canonical, and is an auxiliary document to the core style guide. See the overview for more information.\n\nThis file documents guidance about how to best apply the Go Style Guide. This guidance is intended for common situations that arise frequently, but may not apply in every circumstance. Where possible, multiple alternative approaches are discussed along with the considerations that go into the decision about when and when not to apply them.\n\nSee the overview for the full set of Style Guide documents.\n\nWhen choosing the name for a function or method, consider the context in which the name will be read. Consider the following recommendations to avoid excess repetition at the call site:\n• The following can generally be omitted from function and method names:\n• The types of the inputs and outputs (when there is no collision)\n• Whether an input or output is a pointer\n• For functions, do not repeat the name of the package.\n• For methods, do not repeat the name of the method receiver.\n• Do not repeat the names of variables passed as parameters.\n• Do not repeat the names and types of the return values.\n\nWhen it is necessary to disambiguate functions of a similar name, it is acceptable to include extra information.\n\nThere are some other common conventions when choosing names for functions and methods:\n• Functions that return something are given noun-like names. A corollary of this is that function and method names should avoid the prefix .\n• Functions that do something are given verb-like names.\n• Identical functions that differ only by the types involved include the name of the type at the end of the name. If there is a clear “primary” version, the type can be omitted from the name for that version:\n\nThere are several disciplines you can apply to naming packages and types that provide test helpers and especially test doubles. A test double could be a stub, fake, mock, or spy.\n\nThese examples mostly use stubs. Update your names accordingly if your code uses fakes or another kind of test double.\n\nSuppose you have a well-focused package providing production code similar to this:\n\nSuppose you want to create a package that contains test doubles for another. We’ll use (from above) for this example:\n\nOne approach is to introduce a new Go package based on the production one for testing. A safe choice is to append the word to the original package name (“creditcard” + “test”):\n\nUnless stated explicitly otherwise, all examples in the sections below are in .\n\nYou want to add a set of test doubles for . Because is effectively a dumb data type, similar to a Protocol Buffer message, it needs no special treatment in tests, so no double is required. If you anticipate only test doubles for one type (like ), you can take a concise approach to naming the doubles:\n\nThis is strictly preferable to a naming choice like or the very poor , because the base package name and its domain types imply what is.\n\nFinally, if the package is built with Bazel, make sure the new rule for the package is marked as :\n\nThe approach above is conventional and will be reasonably well understood by other engineers.\n\nWhen one kind of stub is not enough (for example, you also need one that always fails), we recommend naming the stubs according to the behavior they emulate. Here we rename to and introduce a new stub called :\n\nBut now suppose that contains multiple types worth creating doubles for, as seen below with and :\n\nIn this case, more explicit test double naming is sensible:\n\nWhen variables in your tests refer to doubles, choose a name that most clearly differentiates the double from other production types based on context. Consider some production code you want to test:\n\nIn the tests, a test double called a “spy” for is juxtaposed against production types, so prefixing the name may improve clarity.\n\nThis is clearer than when the name is not prefixed.\n\nNote: This explanation uses two informal terms, stomping and shadowing. They are not official concepts in the Go language spec.\n\nLike many programming languages, Go has mutable variables: assigning to a variable changes its value.\n\nWhen using short variable declarations with the operator, in some cases a new variable is not created. We can call this stomping. It’s OK to do this when the original value is no longer needed.\n\nBe careful using short variable declarations in a new scope, though: that introduces a new variable. We can call this shadowing the original variable. Code after the end of the block refers to the original. Here is a buggy attempt to shorten the deadline conditionally:\n\nA correct version of the code might be:\n\nIn the case we called stomping, because there’s no new variable, the type being assigned must match that of the original variable. With shadowing, an entirely new entity is introduced so it can have a different type. Intentional shadowing can be a useful practice, but you can always use a new name if it improves clarity.\n\nIt is not a good idea to use variables with the same name as standard packages other than very small scopes, because that renders free functions and values from that package inaccessible. Conversely, when picking a name for your package, avoid names that are likely to require import renaming or cause shadowing of otherwise good variable names at the client side.\n\nGo packages have a name specified on the declaration, separate from the import path. The package name matters more for readability than the path.\n\nGo package names should be related to what the package provides. Naming a package just , , or similar is usually a poor choice (it can be used as part of the name though). Uninformative names make the code harder to read, and if used too broadly they are liable to cause needless import conflicts.\n\nInstead, consider what the callsite will look like.\n\nYou can tell roughly what each of these do even without knowing the imports list ( , , and ). With less focused names, these might read:\n\nIf you’re asking yourself how big your Go packages should be and whether to place related types in the same package or split them into different ones, a good place to start is the Go blog post about package names. Despite the post title, it’s not solely about naming. It contains some helpful hints and cites several useful articles and talks.\n\nHere are some other considerations and notes.\n\nUsers see godoc for the package in one page, and any methods exported by types supplied by the package are grouped by their type. Godoc also group constructors along with the types they return. If client code is likely to need two values of different type to interact with each other, it may be convenient for the user to have them in the same package.\n\nCode within a package can access unexported identifiers in the package. If you have a few related types whose implementation is tightly coupled, placing them in the same package lets you achieve this coupling without polluting the public API with these details. A good test for this coupling is to imagine a hypothetical user of two packages, where the packages cover closely related topics: if the user must import both packages in order to use either in any meaningful way, combining them together is usually the right thing to do. The standard library generally demonstrates this kind of scoping and layering well.\n\nAll of that being said, putting your entire project in a single package would likely make that package too large. When something is conceptually distinct, giving it its own small package can make it easier to use. The short name of the package as known to clients together with the exported type name work together to make a meaningful identifier: e.g. , . The Package Names blog post has more examples.\n\nGo style is flexible about file size, because maintainers can move code within a package from one file to another without affecting callers. But as a general guideline: it is usually not a good idea to have a single file with many thousands of lines in it, or having many tiny files. There is no “one type, one file” convention as in some other languages. As a rule of thumb, files should be focused enough that a maintainer can tell which file contains something, and the files should be small enough that it will be easy to find once there. The standard library often splits large packages to several source files, grouping related code by file. The source for package is a good example. Packages with long package documentation may choose to dedicate one file called that has the package documentation, a package declaration, and nothing else, but this is not required.\n\nWithin the Google codebase and in projects using Bazel, directory layout for Go code is different than it is in open source Go projects: you can have multiple targets in a single directory. A good reason to give each package its own directory is if you expect to open source your project in the future.\n\nA few non-canonical reference examples to help demonstrate these ideas in action:\n• small packages that contain one cohesive idea that warrant nothing more being added nor nothing being removed:\n• package : CSV data encoding and decoding with responsibility split respectively between reader.go and writer.go.\n• moderately sized packages that contain one large domain and its multiple responsibilities together:\n• large packages that divide several closely related domains across several files:\n• package : the core of HTTP: client.go, support for HTTP clients; server.go, support for HTTP servers; cookie.go, cookie management.\n\nProto library imports are treated differently than standard Go imports due to their cross-language nature. The convention for renamed proto imports are based on the rule that generated the package:\n• The suffix is generally used for rules.\n• The suffix is generally used for rules.\n\nOften a single word describing the package is used:\n\nFollow the style guidance for package names. Prefer whole words. Short names are good, but avoid ambiguity. When in doubt, use the proto package name up to _go with a pb suffix:\n\nNote: Previous guidance encouraged very short names such as “xpb” or even just “pb”. New code should prefer more descriptive names. Existing code which uses short names should not be used as an example, but does not need to be changed.\n\nImports are typically grouped into the following two (or more) blocks, in order:\n\nIf a file does not have a group for one of the optional categories above, the relevant imports are included in the project import group.\n\nAny import grouping that is clear and easy to understand is generally fine. For example, a team may choose to group gRPC imports separately from protobuf imports.\n\nIn Go, errors are values; they are created by code and consumed by code. Errors can be:\n• Converted into diagnostic information for display to humans\n• Used by the maintainer\n\nError messages also show up across a variety of different surfaces including log messages, error dumps, and rendered UIs.\n\nCode that processes (produces or consumes) errors should do so deliberately. It can be tempting to ignore or blindly propagate an error return value. However, it is always worth considering whether the current function in the call frame is positioned to handle the error most effectively. This is a large topic and it is hard to give categorical advice. Use your judgment, but keep the following considerations in mind:\n• When creating an error value, decide whether to give it any structure.\n• When handling an error, consider adding information that you have but that the caller and/or callee might not.\n• See also guidance on error logging.\n\nWhile it is usually not appropriate to ignore an error, a reasonable exception to this is when orchestrating related operations, where often only the first error is useful. Package provides a convenient abstraction for a group of operations that can all fail or be canceled as a group.\n• A post by the Go Blog on errors\n• GoTip #89: When to Use Canonical Status Codes as Errors\n\nIf callers need to interrogate the error (e.g., distinguish different error conditions), give the error value structure so that this can be done programmatically rather than having the caller perform string matching. This advice applies to production code as well as to tests that care about different error conditions.\n\nThe caller can simply compare the returned error value of the function with one of the known error values:\n\nThe above uses sentinel values, where the error must be equal (in the sense of ) to the expected value. That is perfectly adequate in many cases. If returns wrapped errors (discussed below), you can use .\n\nDo not attempt to distinguish errors based on their string form. (See Go Tip #13: Designing Errors for Checking for more.)\n\nIf there is extra information in the error that the caller needs programmatically, it should ideally be presented structurally. For example, the type is documented to place the pathname of the failing operation in a struct field which the caller can easily access.\n\nOther error structures can be used as appropriate, for example a project struct containing an error code and detail string. Package is a common encapsulation; if you choose this approach (which you are not obligated to do), use canonical codes. See Go Tip #89: When to Use Canonical Status Codes as Errors to know if using status codes is the right choice.\n\nAny function returning an error should strive to make the error value useful. Often, the function is in the middle of a callchain and is merely propagating an error from some other function that it called (maybe even from another package). Here there is an opportunity to annotate the error with extra information, but the programmer should ensure there’s sufficient information in the error without adding duplicate or irrelevant detail. If you’re unsure, try triggering the error condition during development: that’s a good way to assess what the observers of the error (either humans or code) will end up with.\n\nConvention and good documentation help. For example, the standard package advertises that its errors contain path information when it is available. This is a useful style, because callers getting back an error don’t need to annotate it with information that they had already provided the failing function.\n\nIf there is something interesting to say about the meaning of the error, of course it can be added. Just consider which level of the callchain is best positioned to understand this meaning.\n\nContrast with the redundant information here:\n\nWhen adding information to a propagated error, you can either wrap the error or present a fresh error. Wrapping the error with the verb in allows callers to access data from the original error. This can be very useful at times, but in other cases these details are misleading or uninteresting to the caller. See the blog post on error wrapping for more information. Wrapping errors also expands the API surface of your package in a non-obvious way, and this can cause breakages if you change the implementation details of your package.\n\nIt is best to avoid using unless you also document (and have tests that validate) the underlying errors that you expose. If you do not expect your caller to call , and so on, don’t bother with .\n\nThe same concept applies to structured errors like (see canonical codes). For example, if your server sends malformed requests to a backend and receives an code, this code should not be propagated to the client, assuming that the client has done nothing wrong. Instead, return an canonical code to the client.\n\nHowever, annotating errors helps automated logging systems preserve the status payload of an error. For example, annotating the error is appropriate in an internal function:\n\nCode directly at system boundaries (typically RPC, IPC, storage, and similar) should report errors using the canonical error space. It is the responsibility of code here to handle domain-specific errors and represent them canonically. For example:\n\nPrefer to place at the end of an error string.\n\nErrors can be wrapped with the verb, or by placing them in a structured error that implements (ex: ).\n\nWrapped errors form error chains: each new layer of wrapping adds a new entry to the front of the error chain. The error chain can be traversed with the method. For example:\n\nThis forms an error chain of the form,\n\nRegardless of where the verb is placed, the error returned always represents the front of the error chain, and the is the next child. Similarly, always traverses the error chain from newest to oldest error.\n\nPlacement of the verb does, however, affect whether the error chain is printed newest to oldest, oldest to newest, or neither:\n\nTherefore, in order for error text to mirror error chain structure, prefer placing the verb at the end with the form .\n\nFunctions sometimes need to tell an external system about an error without propagating it to their callers. Logging is an obvious choice here; but be conscious of what and how you log errors.\n• Like good test failure messages, log messages should clearly express what went wrong and help the maintainer by including relevant information to diagnose the problem.\n• Avoid duplication. If you return an error, it’s usually better not to log it yourself but rather let the caller handle it. The caller can choose to log the error, or perhaps rate-limit logging using . Other options include attempting recovery or even stopping the program. In any case, giving the caller control helps avoid logspam. The downside to this approach, however, is that any logging is written using the caller’s line coordinates.\n• Be careful with PII. Many log sinks are not appropriate destinations for sensitive end-user information.\n• Use sparingly. ERROR level logging causes a flush and is more expensive than lower logging levels. This can have serious performance impact on your code. When deciding between error and warning levels, consider the best practice that messages at the error level should be actionable rather than “more serious” than a warning.\n• Inside Google, we have monitoring systems that can be set up for more effective alerting than writing to a log file and hoping someone notices it. This is similar but not identical to the standard library package .\n\nUse verbose logging ( ) to your advantage. Verbose logging can be useful for development and tracing. Establishing a convention around verbosity levels can be helpful. For example:\n\nTo minimize the cost of verbose logging, you should ensure not to accidentally call expensive functions even when is turned off. offers two APIs. The more convenient one carries the risk of this accidental expense. When in doubt, use the slightly more verbose style.\n\nProgram initialization errors (such as bad flags and configuration) should be propagated upward to , which should call with an error that explains how to fix the error. In these cases, should not generally be used, because a stack trace that points at the check is not likely to be as useful as a human-generated, actionable message.\n\nAs stated in the decision against panics, standard error handling should be structured around error return values. Libraries should prefer returning an error to the caller rather than aborting the program, especially for transient errors.\n\nIt is occasionally necessary to perform consistency checks on an invariant and terminate the program if it is violated. In general, this is only done when a failure of the invariant check means that the internal state has become unrecoverable. The most reliable way to do this in the Google codebase is to call . Using in these cases is not reliable, because it is possible for deferred functions to deadlock or further corrupt internal or external state.\n\nSimilarly, resist the temptation to recover panics to avoid crashes, as doing so can result in propagating a corrupted state. The further you are from the panic, the less you know about the state of the program, which could be holding locks or other resources. The program can then develop other unexpected failure modes that can make the problem even more difficult to diagnose. Instead of trying to handle unexpected panics in code, use monitoring tools to surface unexpected failures and fix related bugs with a high priority.\n\nNote: The standard server violates this advice and recovers panics from request handlers. Consensus among experienced Go engineers is that this was a historical mistake. If you sample server logs from application servers in other languages, it is common to find large stacktraces that are left unhandled. Avoid this pitfall in your servers.\n\nThe standard library panics on API misuse. For example, issues a panic in many cases where a value is accessed in a way that suggests it was misinterpreted. This is analogous to the panics on core language bugs such as accessing an element of a slice that is out of bounds. Code review and tests should discover such bugs, which are not expected to appear in production code. These panics act as invariant checks that do not depend on a library, as the standard library does not have access to the levelled package that the Google codebase uses.\n\nAnother case in which panics can be useful, though uncommon, is as an internal implementation detail of a package which always has a matching recover in the callchain. Parsers and similar deeply nested, tightly coupled internal function groups can benefit from this design, where plumbing error returns adds complexity without value. The key attribute of this design is that these panics are never allowed to escape across package boundaries and do not form part of the package’s API. This is typically accomplished with a top-level deferred recover that translates a propagating panic into a returned error at the public API surfaces.\n\nPanic is also used when the compiler cannot identify unreachable code, for example when using a function like that will not return:\n\nDo not call functions before flags have been parsed. If you must die in a package initialization function (an or a “must” function), a panic is acceptable in place of the fatal logging call.\n\nGo code that is documented in familiar style is easier to read and less likely to be misused than something misdocumented or not documented at all. Runnable examples show up in Godoc and Code Search and are an excellent way of explaining how to use your code.\n\nNot every parameter must be enumerated in the documentation. This applies to:\n\nDocument the error-prone or non-obvious fields and parameters by saying why they are interesting.\n\nIn the following snippet, the highlighted commentary adds little useful information to the reader:\n\nHowever, this snippet demonstrates a code scenario similar to the previous where the commentary instead states something non-obvious or materially helpful to the reader:\n\nConsider your likely audience in choosing what to document and at what depth. Maintainers, newcomers to the team, external users, and even yourself six months in the future may appreciate slightly different information from what is on your mind when you first come to write your docs.\n\nIt is implied that the cancellation of a context argument interrupts the function it is provided to. If the function can return an error, conventionally it is .\n\nThis fact does not need to be restated:\n\nBecause that is implied, the following is better:\n\nWhere context behavior is different or non-obvious, it should be expressly documented if any of the following are true.\n• The function returns an error other than when the context is cancelled: // If the context is cancelled, Run returns a nil error.\n• The function has other mechanisms that may interrupt it or affect lifetime: // Run processes work until the context is cancelled or Stop is called. // before all work has stopped. The Stop method is synchronous and waits // until all operations from the run loop finish. Use Stop for graceful\n• The function has special expectations about context lifetime, lineage, or attached values: // NewReceiver starts receiving messages sent to the specified queue. // The context should not have a deadline. // Principal returns a human-readable name of the party who made the call. // The context must have a value attached to it from security.NewContext. Warning: Avoid designing APIs that make such demands (like contexts not having deadlines) from their callers. The above is only an example of how to document this if it cannot be avoided, not an endorsement of the pattern.\n\nGo users assume that conceptually read-only operations are safe for concurrent use and do not require extra synchronization.\n\nThe extra remark about concurrency can safely be removed in this Godoc:\n\nMutating operations, however, are not assumed to be safe for concurrent use and require the user to consider synchronization.\n\nSimilarly, the extra remark about concurrency can safely be removed here:\n\nDocumentation is strongly encouraged if any of the following are true.\n• It is unclear whether the operation is read-only or mutating: // Lookup returns the data associated with the key from the cache. // This operation is not safe for concurrent use. Why? A cache hit when looking up the key mutate a LRU cache internally. How this is implemented may not be obvious to all readers.\n• Synchronization is provided by the API: // NewFortuneTellerClient returns an *rpc.Client for the FortuneTeller service. // It is safe for simultaneous use by multiple goroutines. Note: If the API is a type and the API provides synchronization in entirety, conventionally only the type definition documents the semantics.\n• The API consumes user-implemented types of interfaces, and the interface’s consumer has particular concurrency requirements: // A Watcher reports the health of some entity (usually a backend service). // Watcher methods are safe for simultaneous use by multiple goroutines. // Watch sends true on the passed-in channel when the Watcher's // Health returns nil if the entity being watched is healthy, or a // non-nil error explaining why the entity is not healthy. Why? Whether an API is safe for use by multiple goroutines is part of its contract.\n\nDocument any explicit cleanup requirements that the API has. Otherwise, callers won’t use the API correctly, leading to resource leaks and other possible bugs.\n\nCall out cleanups that are up to the caller:\n\nIf it is potentially unclear how to clean up the resources, explain how:\n\nDocument significant error sentinel values or error types that your functions return to callers so that callers can anticipate what types of conditions they can handle in their code.\n\nWhen a function returns a specific error type, correctly note whether the error is a pointer receiver or not:\n\nDocumenting whether the values returned are pointer receivers enables callers to correctly compare the errors using , , and . This is because a non-pointer value is not equivalent to a pointer value.\n\nNote: In the example, the return type is written as rather than due to how nil interface values work.\n\nDocument overall error conventions in the package’s documentation when the behavior is applicable to most errors found in the package:\n\nThoughtful application of these approaches can add extra information to errors without much effort and help callers avoid adding redundant annotations.\n• Go Tip #89: When to Use Canonical Status Codes as Errors\n\nGo features a documentation server. It is recommended to preview the documentation your code produces both before and during the code review process. This helps to validate that the godoc formatting is rendered correctly.\n\nGodoc provides some specific syntax to format documentation.\n• // LoadConfig reads a configuration out of the named file.\n• Test files can contain runnable examples that appear attached to the corresponding documentation in godoc:\n• Indenting lines by an additional two spaces formats them verbatim: // Update runs the function in an atomic transaction. // This is typically used with an anonymous TransactionFunc: Note, however, that it can often be more appropriate to put code in a runnable example instead of including it in a comment. This verbatim formatting can be leveraged for formatting that is not native to godoc, such as lists and tables: // LoadConfig reads a configuration out of the named file. // LoadConfig treats the following keys in special ways: // \"import\" will make this configuration inherit from the named file. // \"env\" if present will be populated with the system environment.\n• A single line that begins with a capital letter, contains no punctuation except parentheses and commas, and is followed by another paragraph, is formatted as a header: // The following line is formatted as a heading. // Headings come with autogenerated anchor tags for easy linking.\n\nSometimes a line of code looks like something common, but actually isn’t. One of the best examples of this is an check (since is much more common). The following two conditional checks are hard to distinguish:\n\nYou can instead “boost” the signal of the conditional by adding a comment:\n\nThe comment draws attention to the difference in the conditional.\n\nFor consistency, prefer over when initializing a new variable with a non-zero value.\n\nThe following declarations use the zero value:\n\nYou should declare values using the zero value when you want to convey an empty value that is ready for later use. Using composite literals with explicit initialization can be clunky:\n\nA common application of zero value declaration is when using a variable as the output when unmarshalling:\n\nIt is also okay to use the zero value in the following form when you need a variable of a pointer type:\n\nIf you need a lock or other field that must not be copied in your struct, you can make it a value type to take advantage of zero value initialization. It does mean that the containing type must now be passed via a pointer and not a value. Methods on the type must take pointer receivers.\n\nIt’s acceptable to use value types for local variables of composites (such as structs and arrays) even if they contain such uncopyable fields. However, if the composite is returned by the function, or if all accesses to it end up needing to take an address anyway, prefer declaring the variable as a pointer type at the outset. Similarly, protobufs should be declared as pointer types.\n\nThis is because satisfies while does not.\n\nThe following are composite literal declarations:\n\nYou should declare a value using a composite literal when you know initial elements or members.\n\nIn contrast, using composite literals to declare empty or memberless values can be visually noisy compared to zero-value initialization.\n\nWhen you need a pointer to a zero value, you have two options: empty composite literals and . Both are fine, but the keyword can serve to remind the reader that if a non-zero value were needed, a composite literal wouldn’t work:\n\nThe following are declarations that take advantage of size hints in order to preallocate capacity:\n\nSize hints and preallocation are important steps when combined with empirical analysis of the code and its integrations, to create performance-sensitive and resource-efficient code.\n\nMost code does not need a size hint or preallocation, and can allow the runtime to grow the slice or map as necessary. It is acceptable to preallocate when the final size is known (e.g. when converting between a map and a slice) but this is not a readability requirement, and may not be worth the clutter in small cases.\n\nWarning: Preallocating more memory than you need can waste memory in the fleet or even harm performance. When in doubt, see GoTip #3: Benchmarking Go Code and default to a zero initialization or a composite literal declaration.\n\nSpecify channel direction where possible.\n\nThis prevents casual programming errors that are possible without specification:\n\nWhen the direction is specified, the compiler catches simple errors like this. It also helps to convey a measure of ownership to the type.\n\nDon’t let the signature of a function get too long. As more parameters are added to a function, the role of individual parameters becomes less clear, and adjacent parameters of the same type become easier to confuse. Functions with large numbers of arguments are less memorable and more difficult to read at the call-site.\n\nWhen designing an API, consider splitting a highly configurable function whose signature is growing complex into several simpler ones. These can share an (unexported) implementation if necessary.\n\nWhere a function requires many inputs, consider introducing an option struct for some of the arguments or employing the more advanced variadic options technique. The primary consideration for which strategy to choose should be how the function call looks across all expected use cases.\n\nThe recommendations below primarily apply to exported APIs, which are held to a higher standard than unexported ones. These techniques may be unnecessary for your use case. Use your judgment, and balance the principles of clarity and least mechanism.\n\nSee also: Go Tip #24: Use Case-Specific Constructions\n\nAn option structure is a struct type that collects some or all of the arguments of a function or method, that is then passed as the last argument to the function or method. (The struct should be exported only if it is used in an exported function.)\n\nUsing an option structure has a number of benefits:\n• The struct literal includes both fields and values for each argument, which makes them self-documenting and harder to swap.\n• Irrelevant or “default” fields can be omitted.\n• Callers can share the option struct and write helpers to operate on it.\n• Option structs can grow over time without impacting call-sites.\n\nHere is an example of a function that could be improved:\n\nThe function above could be rewritten with an option structure as follows:\n\nThe function can then be called in a different package:\n\nNote: Contexts are never included in option structs.\n\nThis option is often preferred when some of the following apply:\n• All callers need to specify one or more of the options.\n• A large number of callers need to provide many options.\n• The options are shared between multiple functions that the user will call.\n\nUsing variadic options, exported functions are created which return closures that can be passed to the variadic ( ) parameter of a function. The function takes as its parameters the values of the option (if any), and the returned closure accepts a mutable reference (usually a pointer to a struct type) that will be updated based on the inputs.\n\nUsing variadic options can provide a number of benefits:\n• Options take no space at a call-site when no configuration is needed.\n• Options are still values, so callers can share them, write helpers, and accumulate them.\n• The option functions can return a named type to group options together in godoc.\n• Packages can allow (or prevent) third-party packages to define (or from defining) their own options.\n\nNote: Using variadic options requires a substantial amount of additional code (see the following example), so it should only be used when the advantages outweigh the overhead.\n\nHere is an example of a function that could be improved:\n\nThe example above could be rewritten with variadic options as follows:\n\nThe function can then be called in a different package:\n\nPrefer this option when many of the following apply:\n• Most callers will not need to specify any options.\n• Most options are used infrequently.\n• There are a large number of options.\n• Options could fail or be set incorrectly (in which case the option function returns an ).\n• Options require a lot of documentation that can be hard to fit in a struct.\n• Users or other packages can provide custom options.\n\nOptions in this style should accept parameters rather than using presence to signal their value; the latter can make dynamic composition of arguments much more difficult. For example, binary settings should accept a boolean (e.g. is preferable to ). An enumerated option should accept an enumerated constant (e.g. is preferable to ). The alternative makes it much more difficult for users who must programmatically choose which options to pass; such users are forced to change the actual composition of the parameters rather than simply changing the arguments to the options. Don’t assume that all users will know the full set of options statically.\n\nIn general, options should be processed in order. If there is a conflict or if a non-cumulative option is passed multiple times, the last argument should win.\n\nThe parameter to the option function is generally unexported in this pattern, to restrict the options to being defined only within the package itself. This is a good default, though there may be times when it is appropriate to allow other packages to define options.\n\nSee Rob Pike’s original blog post and Dave Cheney’s talk for a more in-depth look at how these options can be used.\n\nSome programs wish to present users with a rich command-line interface that includes sub-commands. For example, , , and many other sub-commands are all provided by the program . There are at least the following libraries in common use for achieving this.\n\nIf you don’t have a preference or other considerations are equal, subcommands is recommended, since it is the simplest and is easy to use correctly. However, if you need different features that it doesn’t provide, pick one of the other options.\n• \n• Pitfalls in usage (see below).\n• \n• Simple and easy to use correctly.\n• Recommended if you don’t need extra features.\n\nWarning: cobra command functions should use to obtain a context rather than creating their own root context with . Code that uses the subcommands package already receives the correct context as a function parameter.\n\nYou are not required to place each subcommand in a separate package, and it is often not necessary to do so. Apply the same considerations about package boundaries as in any Go codebase. If your code can be used both as a library and as a binary, it is usually beneficial to separate the CLI code and the library, making the CLI just one more of its clients. (This is not specific to CLIs that have subcommands, but is mentioned here because it is a common place where it comes up.)\n\nGo distinguishes between “test helpers” and “assertion helpers”:\n• Test helpers are functions that do setup or cleanup tasks. All failures that occur in test helpers are expected to be failures of the environment (not from the code under test) — for example when a test database cannot be started because there are no more free ports on this machine. For functions like these, calling is often appropriate to mark them as a test helper. See error handling in test helpers for more details.\n• Assertion helpers are functions that check the correctness of a system and fail the test if an expectation is not met. Assertion helpers are not considered idiomatic in Go.\n\nThe purpose of a test is to report pass/fail conditions of the code under test. The ideal place to fail a test is within the function itself, as that ensures that failure messages and the test logic are clear.\n\nAs your testing code grows, it may become necessary to factor out some functionality to separate functions. Standard software engineering considerations still apply, as test code is still code. If the functionality does not interact with the testing framework, then all of the usual rules apply. When the common code interacts with the framework, however, some care must be taken to avoid common pitfalls that can lead to uninformative failure messages and unmaintainable tests.\n\nIf many separate test cases require the same validation logic, arrange the test in one of the following ways instead of using assertion helpers or complex validation functions:\n• Inline the logic (both the validation and the failure) in the function, even if it is repetitive. This works best in simple cases.\n• If inputs are similar, consider unifying them into a table-driven test while keeping the logic inlined in the loop. This helps to avoid repetition while keeping the validation and failure in the .\n• If there are multiple callers who need the same validation function but table tests are not suitable (typically because the inputs are not simple enough or the validation is required as part of a sequence of operations), arrange the validation function so that it returns a value (typically an ) rather than taking a parameter and using it to fail the test. Use logic within the to decide whether to fail, and to provide useful test failures. You can also create test helpers to factor out common boilerplate setup code.\n\nThe design outlined in the last point maintains orthogonality. For example, package is not designed to fail tests, but rather to compare (and to diff) values. It therefore does not need to know about the context in which the comparison was made, since the caller can supply that. If your common testing code provides a for your data type, that can often be the simplest design. For other validations, consider returning an value.\n\nThe function is agnostic about how it’s called; it doesn’t take a concrete input type nor does it police what to do in case two objects don’t match. Therefore, more callers can make use of it.\n\nNote: There is an analogy between test helpers and plain library code. Code in libraries should usually not panic except in rare circumstances; code called from a test should not stop the test unless there is no point in proceeding.\n\nMost of the advice about testing in the style guide is about testing your own code. This section is about how to provide facilities for other people to test the code they write to ensure that it conforms to your library’s requirements.\n\nSuch testing is referred to as acceptance testing. The premise of this kind of testing is that the person using the test does not know every last detail of what goes on in the test; they just hand the inputs over to the testing facility to do the work. This can be thought of as a form of inversion of control.\n\nIn a typical Go test, the test function controls the program flow, and the no assert and test functions guidance encourages you to keep it that way. This section explains how to author support for these tests in a way that is consistent with Go style.\n\nBefore diving into how, consider an example from , excerpted below:\n\nWhile there exist well-known implementations of , a Go developer may be expected to author one. To help validate the user-implemented is correct, a generic library has been provided in called . This API treats the implementation as a blackbox to make sure it upholds the most basic parts of the contract.\n\nNow that we know what an acceptance test is and why you might use one, let’s explore building an acceptance test for , a package used to simulate chess games. Users of are expected to implement the interface. These implementations are the primary thing we will validate. Our acceptance test concerns itself with whether the player implementation makes legal moves, not whether the moves are smart.\n• Create a new package for the validation behavior, customarily named by appending the word to the package name (for example, ).\n• Create the function that performs the validation by accepting the implementation under test as an argument and exercises it: // The board itself is spot checked for sensibility and correctness. // It returns a nil error if the player makes a correct move in the context // of the provided board. Otherwise ExercisePlayer returns one of this // package's errors to indicate how and why the player failed the The test should note which invariants are broken and how. Your design can choose between two disciplines for failure reporting:\n• Fail fast: return an error as soon as the implementation violates an invariant. This is the simplest approach, and it works well if the acceptance test is expected to execute quickly. Simple error sentinels and custom types can be used easily here, which conversely makes testing the acceptance test easy. // The king should never leave the board, because the game ends at\n• Aggregate all failures: collect all failures, and report them all. This approach resembles the keep going guidance in feel and may be preferable if the acceptance test is expected to execute slowly. How you aggregate the failures should be dictated by whether you want to give users the ability or yourself the ability to interrogate individual failures (for example, for you to test your acceptance test). Below demonstrates using a custom error type that aggregates errors:\n\nThe acceptance test should honor the keep going guidance by not calling unless the test detects a broken invariant in the system being exercised.\n\nFor example, should be reserved for exceptional cases such as setup failure as usual:\n\nThis technique can help you create concise, canonical validations. But do not attempt to use it to bypass the guidance on assertions.\n\nThe final product should be in a form similar to this for end users:\n\nWhen testing component integrations, especially where HTTP or RPC are used as the underlying transport between the components, prefer using the real underlying transport to connect to the test version of the backend.\n\nFor example, suppose the code you want to test (sometimes referred to as “system under test” or SUT) interacts with a backend that implements the long running operations API. To test your SUT, use a real OperationsClient that is connected to a test double (e.g., a mock, stub, or fake) of the OperationsServer.\n\nThis is recommended over hand-implementing the client, due to the complexity of imitating client behavior correctly. By using the production client with a test-specific server, you ensure your test is using as much of the real code as possible.\n\nTip: Where possible, use a testing library provided by the authors of the service under test.\n\nAs discussed in decisions, tests should generally not abort at the first encountered problem.\n\nHowever, some situations require that the test not proceed. Calling is appropriate when some piece of test setup fails, especially in test setup helpers, without which you cannot run the rest of the test. In a table-driven test, is appropriate for failures that set up the whole test function before the test loop. Failures that affect a single entry in the test table, which make it impossible to continue with that entry, should be reported as follows:\n• If you’re not using subtests, use followed by a statement to move on to the next table entry.\n• If you’re using subtests (and you’re inside a call to ), use , which ends the current subtest and allows your test case to progress to the next subtest.\n\nWarning: It is not always safe to call and similar functions. More details here.\n\nNote: This section discusses test helpers in the sense Go uses the term: functions that perform test setup and cleanup, not common assertion facilities. See the test functions section for more discussion.\n\nOperations performed by a test helper sometimes fail. For example, setting up a directory with files involves I/O, which can fail. When test helpers fail, their failure often signifies that the test cannot continue, since a setup precondition failed. When this happens, prefer calling one of the functions in the helper:\n\nThis keeps the calling side cleaner than if the helper were to return the error to the test itself:\n\nWarning: It is not always safe to call and similar functions. More details here.\n\nThe failure message should include a description of what happened. This is important, as you may be providing a testing API to many users, especially as the number of error-producing steps in the helper increases. When the test fails, the user should know where, and why.\n\nTip: Go 1.14 introduced a function that can be used to register cleanup functions that run when your test completes. The function also works with test helpers. See GoTip #4: Cleaning Up Your Tests for guidance on simplifying test helpers.\n\nThe snippet below in a fictional file called demonstrates how influences failure reporting in a Go test:\n\nHere is an example of this output when run. Note the highlighted text and how it differs:\n\nThe error with refers to the line of the setup function that failed in :\n\nt.Fatalf(\"Could not paint the house under test: %v\", err)\n\nWhereas refers to the line of the test that failed in :\n\nCorrectly using attributes the location of the failure much better when:\n• the amount of helper usage in the test functions grow\n\nTip: If a helper calls or , provide some context in the format string to help determine what went wrong and why.\n\nTip: If nothing a helper does can cause a test to fail, it doesn’t need to call . Simplify its signature by removing from the function parameter list.\n\nAs documented in package testing, it is incorrect to call , , etc. from any goroutine but the one running the Test function (or the subtest). If your test starts new goroutines, they must not call these functions from inside these goroutines.\n\nTest helpers usually don’t signal failure from new goroutines, and therefore it is all right for them to use . If in doubt, call and return instead.\n\nAdding to a test or subtest does not make it unsafe to call .\n\nWhen all calls to the API are in the test function, it is usually easy to spot incorrect usage because the keyword is plain to see. Passing arguments around makes tracking such usage harder. Typically, the reason for passing these arguments is to introduce a test helper, and those should not depend on the system under test. Therefore, if a test helper registers a fatal test failure, it can and should do so from the test’s goroutine.\n\nIn table-driven tests, prefer to specify field names when initializing test case struct literals. This is helpful when the test cases cover a large amount of vertical space (e.g. more than 20-30 lines), when there are adjacent fields with the same type, and also when you wish to omit fields which have the zero value. For example:\n\nWhere possible, setup of resources and dependencies should be as closely scoped to specific test cases as possible. For example, given a setup function:\n\nCall explicitly in test functions that need it:\n\nThe test function does not use the data set and therefore does not call , which could be slow and failure-prone:\n\nA user may wish to run a function in isolation of the others and should not be penalized by these factors:\n\nWhen to use a custom entrypoint\n\nIf all tests in the package require common setup and the setup requires teardown, you can use a custom testmain entrypoint. This can happen if the resource the test cases require is especially expensive to setup, and the cost should be amortized. Typically you have extracted any unrelated tests from the test suite at that point. It is typically only used for functional tests.\n\nUsing a custom should not be your first choice due the amount of care that should be taken for correct use. Consider first whether the solution in the amortizing common test setup section or an ordinary test helper is sufficient for your needs.\n\nIdeally a test case is hermetic between invocations of itself and between other test cases.\n\nAt the very least, ensure that individual test cases reset any global state they have modified if they have done so (for instance, if the tests are working with an external database).\n\nUsing a may be appropriate, though not required, if all of the following are true about the common setup:\n• It only applies to some tests.\n• It does not require teardown.\n\nWhen is used in multiple test functions, its cost is amortized:\n\nThe reason that common teardown is tricky is there is no uniform place to register cleanup routines. If the setup function (in this case ) relies on a context, may be problematic. This is because the second of two racing calls to the setup function would need to wait for the first call to finish before returning. This period of waiting cannot be easily made to respect the context’s cancellation.\n\nThere are several ways to concatenate strings in Go. Some examples include:\n\nThough there is no one-size-fits-all rule for which to choose, the following guidance outlines when each method is preferred.\n\nPrefer using “+” when concatenating few strings. This method is syntactically the simplest and requires no import.\n\nPrefer using when building a complex string with formatting. Using many “+” operators may obscure the end result.\n\nBest Practice: When the output of the string-building operation is an , don’t construct a temporary string with just to send it to the Writer. Instead, use to emit to the Writer directly.\n\nWhen the formatting is even more complex, prefer or as appropriate.\n\nPrefer using when building a string bit-by-bit. takes amortized linear time, whereas “+” and take quadratic time when called sequentially to form a larger string.\n\nNote: For more discussion, see GoTip #29: Building Strings Efficiently.\n\nPrefer to use backticks (`) when constructing constant, multi-line string literals.\n\nLibraries should not force their clients to use APIs that rely on global state. They are advised not to expose APIs or export package level variables that control behavior for all clients as parts of their API. The rest of the section uses “global” and “package level state” synonymously.\n\nInstead, if your functionality maintains state, allow your clients to create and use instance values.\n\nImportant: While this guidance is applicable to all developers, it is most critical for infrastructure providers who offer libraries, integrations, and services to other teams.\n\nYour users will instantiate the data they need (a ) and then pass it as an explicit dependency:\n\nThere are different approaches to migrating existing code to support dependency passing. The main one you will use is passing dependencies as parameters to constructors, functions, methods, or struct fields on the call chain.\n\nAPIs that do not support explicit dependency passing become fragile as the number of clients increases:\n\nConsider what happens in the case of tests exercising code that transitively relies on a sidecar for cloud logging.\n\nGo tests are executed sequentially by default, so the tests above run as:\n• , which overrides the default value of cloudlogger\n• , which requires the default value of cloudlogger registered in\n\nThis creates an order-dependent test case, which breaks running with test filters, and prevents tests from running in parallel or being sharded.\n\nUsing global state poses problems that lack easy answers for you and the API’s clients:\n• What happens if a client needs to use different and separately operating sets of s (for example, to support multiple servers) in the same process space?\n• What happens if a client wants to replace a registered with an alternative implementation in a test, like a test double? What happens if a client’s tests require hermeticity between instances of a , or between all of the plugins registered?\n• What happens if multiple clients a under the same name? Which one wins, if any? How should errors be handled? If the code panics or calls , will that always be appropriate for all places in which API would be called? Can a client verify it doesn’t do something bad before doing so?\n• Are there certain stages in a program’s startup phases or lifetime during which can be called and when it can’t? What happens if is called at the wrong time? A client could call in , before flags are parsed, or after . The stage at which a function is called affects error handling. If the author of an API assumes the API is only called during program initialization without the requirement that it is, the assumption may nudge the author to design error handling to abort the program by modeling the API as a -like function. Aborting is not appropriate for general-purpose library functions that can be used at any stage.\n• What if the client’s and the designer’s concurrency needs are mismatched?\n• Error Handling: Look Before You Leap versus Easier to Ask for Forgiveness than Permission\n\nGlobal state has cascading effects on the health of the Google codebase. Global state should be approached with extreme scrutiny.\n\nGlobal state comes in several forms, and you can use a few litmus tests to identify when it is safe.\n\nSeveral of the most common problematic API forms are enumerated below:\n• Top-level variables irrespective of whether they are exported. // Sinks manages the default output sources for this package's logging API. This // variable should be set at package initialization time and never thereafter. See the litmus tests to know when these are safe.\n• The service locator pattern. See the first example. The service locator pattern itself is not problematic, rather the locator being defined as global.\n• Thick-Client singletons for things like backends, storage, data access layers, and other system resources. These often pose additional problems with service reliability.\n\nAPIs using the patterns above are unsafe when:\n• Multiple functions interact via global state when executed in the same program, despite being otherwise independent (for example, authored by different authors in vastly different directories).\n• Independent test cases interact with each other through global state.\n• Users of the API are tempted to swap or replace global state for testing purposes, particularly to replace any part of the state with a test double, like a stub, fake, spy, or mock.\n• Users have to consider special ordering requirements when interacting with global state: , whether flags are parsed yet, etc.\n\nProvided the conditions above are avoided, there are a few limited circumstances under which these APIs are safe, namely when any of the following is true:\n• The global state is logically constant (example).\n• The package’s observable behavior is stateless. For example, a public function may use a private global variable as a cache, but so long as the caller can’t distinguish cache hits from misses, the function is stateless.\n• The global state does not bleed into things that are external to the program, like sidecar processes or files on a shared filesystem.\n• There is no expectation of predictable behavior (example).\n\nAn example of one of these safe situations is with its function. Consider the litmus tests from above applied to a typical decoder, like the one for handling the PNG format:\n• Multiple calls to ’s APIs that use the registered decoders (for example, ) cannot interfere with one another, similarly for tests. The only exception is , but that is mitigated by the points below.\n• It is extremely unlikely that a user would want to replace a decoder with a test double, as the PNG decoder exemplifies a case in which our codebase’s preference for real objects applies. However, a user would be more likely to replace a decoder with a test double if the decoder statefully interacted with operating system resources (for example, the network).\n• Collisions in registration are conceivable, though they are probably rare in practice.\n• The decoders are stateless, idempotent, and pure.\n\nWhile not recommended, it is acceptable to provide a simplified API that uses package level state if you need to maximize convenience for the user.\n\nFollow the litmus tests with these guidelines in such cases:\n• The package must offer clients the ability to create isolated instances of package types as described above.\n• The public APIs that use global state must be a thin proxy to the previous API. A good example of this is internally calling on the package variable .\n• This package-level API must only be used by binary build targets, not libraries, unless the libraries are undertaking a refactoring to support dependency passing. Infrastructure libraries that can be imported by other packages must not rely on package-level state of the packages they import. For example, an infrastructure provider implementing a sidecar that is to be shared with other teams using the API from the top should offer an API to accommodate this:\n• This package-level API must document and enforce its invariants (for example, at which stage in the program’s life it can be called, whether it can be used concurrently). Further, it must provide an API to reset global state to a known-good default (for example, to facilitate testing)."
    }
]