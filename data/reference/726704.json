[
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html",
        "document": "Resizable-array implementation of theinterface. Implements all optional list operations, and permits all elements, including. In addition to implementing theinterface, this class provides methods to manipulate the size of the array that is used internally to store the list. (This class is roughly equivalent to, except that it is unsynchronized.)\n\nThe , , , , , and operations run in constant time. The operation runs in amortized constant time, that is, adding n elements requires O(n) time. All of the other operations run in linear time (roughly speaking). The constant factor is low compared to that for the implementation.\n\nEach instance has a capacity. The capacity is the size of the array used to store the elements in the list. It is always at least as large as the list size. As elements are added to an ArrayList, its capacity grows automatically. The details of the growth policy are not specified beyond the fact that adding an element has constant amortized time cost.\n\nAn application can increase the capacity of an instance before adding a large number of elements using the operation. This may reduce the amount of incremental reallocation.\n\nNote that this implementation is not synchronized. If multiple threads access an instance concurrently, and at least one of the threads modifies the list structurally, it must be synchronized externally. (A structural modification is any operation that adds or deletes one or more elements, or explicitly resizes the backing array; merely setting the value of an element is not a structural modification.) This is typically accomplished by synchronizing on some object that naturally encapsulates the list. If no such object exists, the list should be \"wrapped\" using the method. This is best done at creation time, to prevent accidental unsynchronized access to the list:\n\nThe iterators returned by this class's and methods are fail-fast: if the list is structurally modified at any time after the iterator is created, in any way except through the iterator's own or methods, the iterator will throw a . Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.\n\nNote that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.\n\nThis class is a member of the Java Collections Framework."
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api?java/util/ArrayList.html",
        "document": "JavaScript is disabled on your browser.\n\nThis document is designed to be viewed using the frames feature. If you see this message, you are using a non-frame-capable web client. Link to Non-frame version."
    },
    {
        "link": "https://w3schools.com/java/java_arraylist.asp",
        "document": "The class is a resizable array, which can be found in the package.\n\nThe difference between a built-in array and an in Java, is that the size of an array cannot be modified (if you want to add or remove elements to/from an array, you have to create a new one). While elements can be added and removed from an whenever you want. The syntax is also slightly different:\n\nThe class has many useful methods. For example, to add elements to the list, use the method:\n\nYou can also add an item at a specified position by referring to the index number:\n\nTo access an element in the , use the method and refer to the index number:\n\nTo modify an element, use the method and refer to the index number:\n\nTo remove an element, use the method and refer to the index number:\n\nTo remove all the elements in the , use the method:\n\nTo find out how many elements an ArrayList have, use the method:\n\nLoop through the elements of an with a loop, and use the method to specify how many times the loop should run:\n\nYou can also loop through an with the for-each loop:\n\nElements in an ArrayList are actually objects. In the examples above, we created elements (objects) of type \"String\". Remember that a String in Java is an object (not a primitive type). To use other types, such as int, you must specify an equivalent wrapper class: . For other primitive types, use: for boolean, for char, for double, etc:\n\nAnother useful class in the package is the class, which include the method for sorting lists alphabetically or numerically:"
    },
    {
        "link": "https://courses.cs.washington.edu/courses/cse341/98au/java/jdk1.2beta4/docs/api/java/util/ArrayList.html",
        "document": ""
    },
    {
        "link": "https://download.java.net/java/GA/jdk14/docs/api/java.base/java/util/class-use/ArrayList.html",
        "document": "A RoleUnresolvedList represents a list of RoleUnresolved objects, representing roles not retrieved from a relation due to a problem encountered when trying to access (read or write) the roles.\n\nReturns an array list containing the elements returned by the specified enumeration in the order they are returned by the enumeration.\n\nDrag and Drop is a direct manipulation gesture found in many Graphical User Interface systems that provides a mechanism to transfer information between two entities logically associated with presentation elements in the GUI.\n\nReport a bug or suggest an enhancement\n\n For further API reference and developer documentation see the Java SE Documentation, which contains more detailed, developer-targeted descriptions with conceptual overviews, definitions of terms, workarounds, and working code examples.\n\n Java is a trademark or registered trademark of Oracle and/or its affiliates in the US and other countries.\n\n Copyright ¬© 1993, 2020, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.\n\nAll rights reserved. Use is subject to license terms and the documentation redistribution policy."
    },
    {
        "link": "https://siddosamith.medium.com/graph-traversals-in-java-dfs-bfs-a91910f6b9f9",
        "document": "‚ÄúDepth-first search is a traversal technique where we traverse the graph in depth exploring its neighbors‚Äù. You know sometimes textbooks are dumb, quite natural.\n\nBefore understanding the depth-first search let me tell you a story :)\n\nRemember Famous Gta Vice City Tommy‚Äôs estate ‚ÄúMaze‚Äù, look at the picture below\n\nWhat we do here \n\n1) Tommy(Vice City character) enters the maze at a ‚Äúparticular entry point‚Äù\n\n2) Continue traveling a path in the maze until he finds the dead end where you can't go further.\n\n3) Once Tommy finds the dead end he turns back and starts running back where he came from and once he reaches the starting point he starts traveling to another ‚Äúunexplored path‚Äù.\n\n4) Tommy follows the above 3 steps until he finds every possible path out.\n\nnow let's link this story with our famous ‚ÄúDepth-first search‚Äù üëá,\n\n1) Just like Tommy We start from a random starting vertex( usually 0) in the graph\n\n2) Next just like Tommy we travel the path we started until we reach a dead end, which means from the starting vertex we look at the unvisited neighbors of the starting vertex, ‚Äúwell where do we get this neighbor from?‚Äù we get this from the adjacency list ( where we store neighbors of the node in a list, refer to the previous article if you forgot the adjacency list).\n\n3) we reach the dead end means, while traveling at one point we reach the node that has no unvisited neighbors, there we backtrack or simply turn around and come back to the starting vertex where we started from.\n\n4) once we come back to the starting vertex we explore the next unvisited neighbor.\n\nDfs follow these steps until every vertex is visited. Below are the visual representation for the process.\n‚Ä¢ Start at a chosen vertex (the starting vertex) of the graph.\n‚Ä¢ Visit the starting vertex and mark it as visited in the boolean array.\n‚Ä¢ Explore one of the unvisited neighbors of the current vertex.\n‚Ä¢ Repeat step 3 recursively for the unvisited neighbors until all reachable vertices from the starting vertex have been visited.\n‚Ä¢ Backtrack to the previous vertex when we find any node when all its neighbors are visited and explore any remaining unvisited neighbors.\n‚Ä¢ Repeat steps 3‚Äì5 until all vertices in the graph have been visited.\n\nbelow is the process visualization:\n\nBreadth-first search is another traversal technique that we use to travel the graph. In bfs we systematically explore and visit all the nodes of a graph or tree in a‚Äú level-by-level manner‚Äù. It starts from a designated starting node (often referred to as the ‚Äúsource‚Äù or ‚Äúroot‚Äù node) and explores all its neighbors first before moving on to the next level of neighbors.\n\nlet's understand it with a real-life example\n\nconsider we are searching for a book in a library, a book rack that contains multiple rows, the usual way to search is to search the racks in a level-wise manner. This means we start by searching for the book in the first row once we complete searching we move to the next. we don't move to the second row until we are done searching the first row this is how exactly the breadth-first search works.\n\nnow let‚Äôs link this scenario with our famous ‚ÄúBreadth-first search‚Äù üëá,\n\nThe way we are searching for the book in a rack is in the ‚Äúlevel-wise‚Äù fashion which means ‚Äúwe don‚Äôt move to the next until we are done with the current .‚Äù\n\nIn bfs we start from a source node usually ‚Äú0‚Äù and explore or visit all its neighbors first before moving on to the next, unlike dfs , bfs first visits all its neighbors of the current node and proceeds to the next node in the graph means as we start from zero we complete visiting all neighbors of zero first and move to one next i.e 1.\n\nData structures we use to perform bfs:\n‚Ä¢ Visited Array i.e ‚Äúboolean vis[] = new boolean[no.of vertices] or int[] vis = new int[no.of vertices];‚Äù\n\nQueue is often referred as a ‚ÄúFirst In First Out (FIFO)‚Äù data structure which means ‚Äúwhat comes first goes out first‚Äù. To simply understand the working principle it is ideally equal to ‚ÄúStanding in the queue at a movie ticket issuing counter, one who comes first gets his ticket first and exits the queue first‚Äù.\n\nThe reason why we use a queue is that, we need to process the nodes level by level, so apparently bfs want us to process the nodes that come first like bfs wants us to process the nodes and their children in level 1 first then go to level 2 so on level n. so making this ‚Äúfirst come first serve‚Äù as priority the suitable data structure that we can come up with is a queue.\n\nStep 1 : Add the starting node on to the queue\n\nStep 2 : Remove or pop the node fromfront of the queue and mark it as visited and add all its unvisited neighbors on to the queue using the adjacency list.\n\nSteps 3 : Continue step 2 until the queue is empty\n\nStep 4 : bfs terminates when queue is empty indicating all vertices are visited."
    },
    {
        "link": "https://stackoverflow.com/questions/14812093/need-some-advice-for-my-graph-implementation-with-java",
        "document": "I want to implement some graph algorithms that's why I am creating a kind of graph framework. Up to now I implemented directed graphs very easily with the following classes;\n\nThis is perfectly fine in directed graphs. However in undirected graphs; I have to write like this; Let's say we have 2 nodes which are A, B and the weight between them is say 10. So because of the structure of undirected graphs I have to put two edges;\n\nThis type of edge creation is both inefficient and exhaustive.\n\nTherefore how can I modify my code so that I don't have to put two edges between two nodes for undirected graphs. What is best way to integrate undirected graph type to my code as well?\n\nThanks for your time."
    },
    {
        "link": "https://dev.to/wittedtech-by-harshit/the-ultimate-guide-to-graphs-in-java-a-deep-dive-for-developers-of-all-levels-fo1",
        "document": "The Ultimate Guide to Sets in Java: Uncovering Every Secret of This Humble Data Structure\n\nThe Ultimate Guide to Arrays in Java: From Zero to Hero (With a Dash of Humor)\n\nThe Ultimate Guide to Lists in Java: Everything You Need to Know\n\nThe Complete Guide to Queue Data Structure in Java\n\nA Deep Dive into Java Maps: The Ultimate Guide for All Developers\n\nThe Ultimate Guide to Trees in Java: From Roots to Branches (and Leaves, too!)\n\nThe Ultimate Guide to Graphs in Java: A Deep Dive for Developers of All Levels\n\nMastering DSA with Pen and Paper: Unplug and Think Like a Problem-Solver\n\nüöÄ Mastering Time and Space Complexity in DSA: Your Ultimate Guide üöÄ\n\nHow to Start DSA (Data Structures & Algorithms) as a Beginner\n\nUltimate Guide to the Best Resources, Books, and Problems for DSA Mastery: \"Which I Personally Use.\"\n\nWelcome to the comprehensive world of graphs! If you're a developer and the term \"graph\" only conjures up images of pie charts and bar graphs, get ready to expand your horizons. Graphs, in the data structure sense, are the unsung heroes behind a lot of complex computer science problems and real-world applications. From social networks and recommendation engines to finding the shortest path from point A to point B, graphs do it all. This guide will cover everything, from fundamentals to advanced graph algorithms. Buckle up; it's going to be a wild ride filled with knowledge, humor, and code snippets that‚Äôll make you a graph guru in Java!\n\n1. What Is a Graph, Anyway?\n\nAt its core, a graph is a collection of nodes (vertices) connected by edges. Unlike your average data structure, which might be linear (like arrays or linked lists), graphs allow for more complex relationships.\n\nA graph GGG is defined as G=(V,E)G = (V, E)G=(V,E) where:\n‚Ä¢ EEE is a set of edges connecting pairs of vertices.\n\nGraphs can be directed or undirected. In a directed graph, if Alice points to Bob, think of Alice saying, \"Hey Bob, I follow you, but you don‚Äôt follow me back.\"\n‚Ä¢ Undirected Graph: The relationship between nodes is two-way. If there's an edge between A and B, you can travel from A to B and B to A.\n‚Ä¢ Directed Graph (Digraph): Edges have a direction. If there's an edge from A to B, you can go from A to B but not necessarily back.\n‚Ä¢ Weighted Graph: Each edge has an associated weight (think of it as a distance or cost).\n‚Ä¢ Unweighted Graph: All edges are treated equally with no weight.\n‚Ä¢ Cyclic Graph: Contains at least one cycle (a path that starts and ends at the same node).\n‚Ä¢ Acyclic Graph: No cycles exist. The most famous type? The DAG (Directed Acyclic Graph), which is the backbone of topological sorting.\n‚Ä¢ Connected Graph: All nodes are reachable from any other node.\n‚Ä¢ Disconnected Graph: Some nodes cannot be reached from others.\n‚Ä¢ Tree: A connected acyclic undirected graph. Think of it as a family tree without loops‚Äîno one is married to their cousin here.\n‚Ä¢ Bipartite Graph: Can be divided into two sets such that no two graph vertices within the same set are adjacent.\n‚Ä¢ Complete Graph: Every pair of distinct vertices is connected by an edge.\n‚Ä¢ Sparse vs. Dense Graphs: Sparse graphs have few edges relative to the number of nodes; dense graphs are the opposite.\n\nA 2D array adj[i][j]adj[i][j]adj[i][j] is used where:\n‚Ä¢ adj[i][j]=1adj[i][j] = 1adj[i][j]=1 if there is an edge between node i and j.\n‚Ä¢ None adj[i][j]=weightadj[i][j] = weightadj[i][j]=weight if the graph is weighted.\n‚Ä¢ Fast lookups: O(1) to check if an edge exists.\n\nAn array or list where each index iii holds a list of nodes connected to vertex iii. Perfect for sparse graphs.\n\nA simple list of all edges. Each edge is represented as a pair (or triplet for weighted graphs).\n‚Ä¢ Social Networks: Users are nodes, and friendships are edges.\n‚Ä¢ Web Crawling: Pages are nodes, and hyperlinks are edges.\n‚Ä¢ Routing Algorithms: Google Maps, anyone? Cities as nodes and roads as edges.\n‚Ä¢ Recommendation Systems: Products are nodes; ‚Äúcustomers who bought X also bought Y‚Äù forms edges.\n‚Ä¢ \n‚Ä¢ Great for finding the shortest path in an unweighted graph.\n‚Ä¢ \n‚Ä¢ Goes as deep as possible before backtracking.\n‚Ä¢ Useful for pathfinding and cycle detection.\n‚Ä¢ Bellman-Ford Algorithm: Can handle negative weights but slower than Dijkstra.\n‚Ä¢ Floyd-Warshall Algorithm: Finds shortest paths between all pairs of nodes; useful for dense graphs.\n‚Ä¢ Prim‚Äôs Algorithm: Builds MST by adding the cheapest edge from the growing tree.\n‚Ä¢ Used for directed acyclic graphs (DAGs). Perfect for dependency resolution like job scheduling.\n‚Ä¢ DFS-based Approach: Keep track of nodes in the current DFS stack.\n\nGreat for problems like \"shortest distance to a particular type of node\" where there are multiple starting points.\n\nPowerful for handling connected components and cycle detection in undirected graphs.\n\nDynamic programming can be combined with graph traversal to optimize solutions to repetitive sub-problems.\n\nUsed in pathfinding with an informed guess (heuristic). Works like Dijkstra but prioritizes paths closer to the destination.\n‚Ä¢ Pathfinding: \"Find the shortest route from X to Y.\"\n‚Ä¢ Dependency Chains: \"Tasks that depend on other tasks.\"\n‚Ä¢ Traversal Scenarios: \"Visit all rooms,\" or \"Explore all options.\"\n\nIf you‚Äôve made it this far, congratulations! You‚Äôve not only survived the wild ride through graphs but also equipped yourself with the knowledge to tackle any graph-related question thrown your way. Whether you‚Äôre a coding contest junkie, an algorithm enthusiast, or just someone trying to pass your data structures course, this guide has covered everything you need.\n\nAnd remember, in the world of graphs, if you ever get lost, just traverse back to this guide!"
    },
    {
        "link": "https://stackoverflow.com/questions/19113189/detecting-cycles-in-a-graph-using-dfs-2-different-approaches-and-whats-the-dif",
        "document": "The graph has a cycle if and only if there exists a back edge. A back edge is an edge that is from a node to itself (selfloop) or one of its ancestor in the tree produced by DFS forming a cycle.\n\nBoth approaches above actually mean the same. However, this method can be applied only to undirected graphs.\n\nThe reason why this algorithm doesn't work for directed graphs is that in a directed graph 2 different paths to the same vertex don't make a cycle. For example: A-->B, B-->C, A-->C - don't make a cycle whereas in undirected ones: A--B, B--C, C--A does.\n\nAn undirected graph has a cycle if and only if a depth-first search (DFS) finds an edge that points to an already-visited vertex (a back edge).\n\nIn addition to visited vertices we need to keep track of vertices currently in recursion stack of function for DFS traversal. If we reach a vertex that is already in the recursion stack, then there is a cycle in the tree.\n\nUpdate: Working code is in the question section above."
    },
    {
        "link": "https://geeksforgeeks.org/detect-cycle-in-an-undirected-graph-using-bfs",
        "document": "Given an undirected graph, the task is to determine if cycle is present in it or not.\n\nThe idea is to use BFS to detect a cycle in an undirected graph. We start BFS for all components of the graph and check if a node has been visited earlier, ensuring that we do not consider the parent node of the current node while making this check. If we encounter a visited node that is not the parent, a cycle exists in the graph. Otherwise, we continue BFS by marking the node as visited and inserting it into the queue.\n‚Ä¢ Iterate through all nodes . If a node is not visited, start BFS.\n‚Ä¢ Push the node into the queue with its parent set to\n‚Ä¢ Perform BFS\n‚Ä¢ None If an adjacent node is visited and is not the parent\n‚Ä¢ None Otherwise, if the adjacent node is not visited, mark it as visited and push it into the queue with the current node as its parent.\n‚Ä¢ None If no cycle is found after checking all components, return\n\n// C++ program to Detect cycle in // If node is not visited, // If node is visited and // it is not the parent node. // If node is not visited, // If cycle is found in this // If node is not visited, // If node is visited and // it is not the parent node. // If node is not visited, // If cycle is found in this # If node is not visited, # it is not the parent node. # If node is not visited, # If cycle is found in this // C# program to Detect cycle in // If node is not visited, // If node is visited and // it is not the parent node. // If node is not visited, // If cycle is found in this // If node is not visited, // If node is visited and // it is not the parent node. // If node is not visited, // If cycle is found in this\n\nTime Complexity: The program does a simple BFS Traversal of the graph and the graph is represented using an adjacency list. So the time complexity is O(V+E)\n\nSpace Complexity: O(V) for BFS queue and visited array.\n‚Ä¢ None Detect cycle in an undirected graph (All Approaches)"
    }
]