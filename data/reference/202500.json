[
    {
        "link": "https://stackoverflow.com/questions/18469948/instantiating-a-class-in-java-with-reflection",
        "document": "I am trying to create a method that will instantiate a class based on a given interface. At the moment I am trying to instantiate a class based on a class name but I keep getting .\n\nCan anyone tell me what I am doing wrong?\n\nThey all throw and a window which tells me \"Source Not Found\" with a button (Edit Source Lookup Path..) that let's me browse documents.\n\nBoth the main class and classes are in a project called \"Project\" and a package called"
    },
    {
        "link": "https://digitalocean.com/community/tutorials/java-reflection-example-tutorial",
        "document": "Java Reflection provides ability to inspect and modify the runtime behavior of application. Reflection in Java is one of the advance topic of core java. Using java reflection we can inspect a class, interface, enum, get their structure, methods and fields information at runtime even though class is not accessible at compile time. We can also use reflection to instantiate an object, invoke it’s methods, change field values.\n\nReflection in Java is a very powerful concept and it’s of little use in normal programming but it’s the backbone for most of the Java, J2EE frameworks. Some of the frameworks that use java reflection are:\n• JUnit - uses reflection to parse @Test annotation to get the test methods and then invoke it.\n• Tomcat web container to forward the request to correct module by parsing their web.xml files and request URI.\n\nThe list is endless and they all use java reflection because all these frameworks have no knowledge and access of user defined classes, interfaces, their methods etc. We should not use reflection in normal programming where we already have access to the classes and interfaces because of following drawbacks.\n• Poor Performance - Since java reflection resolve the types dynamically, it involves processing like scanning the classpath to find the class to load, causing slow performance.\n• Security Restrictions - Reflection requires runtime permissions that might not be available for system running under security manager. This can cause you application to fail at runtime because of security manager.\n• Security Issues - Using reflection we can access part of code that we are not supposed to access, for example we can access private fields of a class and change it’s value. This can be a serious security threat and cause your application to behave abnormally.\n• High Maintenance - Reflection code is hard to understand and debug, also any issues with the code can’t be found at compile time because the classes might not be available, making it less flexible and hard to maintain.\n\nIn java, every object is either a primitive type or reference. All the classes, enums, arrays are reference types and inherit from . Primitive types are - boolean, byte, short, int, long, char, float, and double. java.lang.Class is the entry point for all the reflection operations. For every type of object, JVM instantiates an immutable instance of that provides methods to examine the runtime properties of the object and create new objects, invoke its method and get/set object fields. In this section, we will look into important methods of Class, for convenience, I am creating some classes and interfaces with inheritance hierarchy.\n\nLet’s look at some of the important refection methods for classes.\n\nWe can get Class of an object using three methods - through static variable , using method of object and . For primitive types and arrays, we can use static variable . Wrapper classes provide another static variable to get the class.\n\nreturns the canonical name of the underlying class. Notice that java.lang.Class uses Generics, it helps frameworks in making sure that the Class retrieved is subclass of framework Base Class. Check out Java Generics Tutorial to learn about generics and its wildcards.\n\ngetSuperclass() method on a Class object returns the super class of the class. If this Class represents either the Object class, an interface, a primitive type, or void, then null is returned. If this object represents an array class then the Class object representing the Object class is returned.\n\nmethod of a Class representation of object returns an array containing Class objects representing all the public classes, interfaces and enums that are members of the class represented by this Class object. This includes public class and interface members inherited from superclasses and public class and interface members declared by the class. This method returns an array of length 0 if this Class object has no public member classes or interfaces or if this Class object represents a primitive type, an array class, or void.\n\nmethod returns an array of Class objects reflecting all the classes and interfaces declared as members of the class represented by this Class object. The returned array doesn’t include classes declared in inherited classes and interfaces.\n\nmethod returns the Class object representing the class in which it was declared.\n\nmethod returns the package for this class. The class loader of this class is used to find the package. We can invoke method of Package to get the name of the package.\n\nmethod returns the int representation of the class modifiers, we can use method to get it in the string format as used in source code.\n\nreturns the array of TypeVariable if there are any Type parameters associated with the class. The type parameters are returned in the same order as declared.\n\nmethod returns the array of interfaces implemented by the class with generic type information. We can also use to get the class representation of all the implemented interfaces.\n\nmethod returns the array of public methods of the Class including public methods of it’s superclasses and super interfaces.\n\nmethod returns the list of public constructors of the class reference of object.\n\nmethod returns the array of public fields of the class including public fields of it’s super classes and super interfaces.\n\nmethod returns all the annotations for the element, we can use it with class, fields and methods also. Note that only annotations available with reflection are with retention policy of RUNTIME, check out Java Annotations Tutorial. We will look into this in more details in later sections.\n\nReflection API provides several methods to analyze Class fields and modify their values at runtime, in this section we will look into some of the commonly used reflection functions for methods.\n\nIn last section, we saw how to get the list of all the public fields of a class. Reflection API also provides method to get specific public field of a class through method. This method look for the field in the specified class reference and then in the super interfaces and then in the super classes.\n\nAbove call will return the field from BaseInterface that is implemented by ConcreteClass. If there is no field found then it throws NoSuchFieldException.\n\nWe can use of field object to get the class declaring the field.\n\ngetType() method returns the Class object for the declared field type, if field is primitive type, it returns the wrapper class object.\n\nWe can get and set the value of a field in an Object using reflection.\n\nget() method return Object, so if field is primitive type, it returns the corresponsing Wrapper Class. If the field is static, we can pass Object as null in get() method. There are several set*() methods to set Object to the field or set different types of primitive types to the field. We can get the type of field and then invoke correct function to set the field value correctly. If the field is final, the set() methods throw java.lang.IllegalAccessException.\n\nWe know that private fields and methods can’t be accessible outside of the class but using reflection we can get/set the private field value by turning off the java access check for field modifiers.\n\nUsing reflection we can get information about a method and we can invoke it also. In this section, we will learn different ways to get a method, invoke a method and accessing private methods.\n\nWe can use getMethod() to get a public method of class, we need to pass the method name and parameter types of the method. If the method is not found in the class, reflection API looks for the method in superclass. In below example, I am getting put() method of HashMap using reflection. The example also shows how to get the parameter types, method modifiers and return type of a method.\n\nWe can use invoke() method of Method object to invoke a method, in below example code I am invoking put method on HashMap using reflection.\n\nIf the method is static, we can pass NULL as object argument.\n\nWe can use getDeclaredMethod() to get the private method and then turn off the access check to invoke it, below example shows how we can invoke method3() of BaseClass that is static and have no parameters.\n\nReflection API provides methods to get the constructors of a class to analyze and we can create new instances of class by invoking the constructor. We have already learned how to get all the public constructors.\n\nWe can use getConstructor() method on the class representation of object to get specific public constructor. Below example shows how to get the constructor of ConcreteClass defined above and the no-argument constructor of HashMap. It also shows how to get the array of parameter types for the constructor.\n\nWe can use newInstance() method on the constructor object to instantiate a new instance of the class. Since we use reflection when we don’t have the classes information at compile time, we can assign it to Object and then further use reflection to access it’s fields and invoke it’s methods.\n\nAnnotations was introduced in Java 1.5 to provide metadata information of the class, methods or fields and now it’s heavily used in frameworks like Spring and Hibernate. Reflection API was also extended to provide support to analyze the annotations at runtime. Using reflection API we can analyze annotations whose retention policy is Runtime. I have already written a detailed tutorial on annotations and how we can use reflection API to parse annotations, so I would suggest you to check out Java Annotations Tutorial. Thats all for java reflection example tutorial, I hope you liked the tutorial and understood the importance of Java Reflection API."
    },
    {
        "link": "https://stackoverflow.com/questions/7698237/whats-the-proper-way-to-use-reflection-to-instantiate-objects-of-unknown-classe",
        "document": "I am working on a Configuration Loader class so that I can change the parameters of my program via an external text file (config.txt) rather than having to recompile my code with every change I make.\n\nIt has been suggested that I use Java's Reflection to do this, but I'm a little confused as to how I might actually implement this.\n\nI have been able to successfully extract the class name and the arguments for its constructor from my text file, but how do I go from this to an instantiated object?\n\nhere's what I have of my method so far:\n\nclassString is a string containing the name of the class, and hm is a hashmap where the class' constructor parameters map to their intended values.\n\nI.e., for , \"xPos\" would map to a string of the intended int, and \"yPos\" maps to a string of the intended float. I want to be able to return, , but I'm unsure how to dynamically use a constructor like that (the issue is, there are multiple possible classes -- perhaps it's a instead of a , for instance).\n\nI know that its possible to do an if/else based off the classString, and simply call the proper constructor after identifying it that way, but I am looking to create a more extensible code that doesn't have to be rewritten every time I add a new class to the program.\n\nAll of the possible objects inherit from a single parent object."
    },
    {
        "link": "https://oracle.com/technical-resources/articles/java/javareflection.html",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/how-to-invoke-method-by-name-in-java-dynamically-using-reflection",
        "document": "How to Invoke Method by Name in Java Dynamically Using Reflection?\n\nJava Reflection API provides us information about a Class to which the Object belongs to including the methods in this class. Using these Reflection API we would be able to get invoking pointer for a method in a class with its name.\n\nThere are two functions used for this purpose:\n• Invoking method with its name\n• Finding a method by Name in a class and invoking the same\n\n1. Invoking method with its name\n\ngetDeclaredMethod() is used for this purpose\n\nMethod name: the method we want to find by name\n\nReturn Type: This method would return an object with reference to the method’s address which would then be used to invoke the method. We would use invoke method for this\n\nIf there are many overloaded methods with the same name, the compiler would invoke the method matching the parameter\n\nWould be used to invoke the method using the Method object\n\nmethodObj: Object of method returned from the getDeclaredMethod\n\nParameters: parameter values used to invoke the method. If the method does not have any parameters to be passed, then we would pass null here\n\n2. Finding a method by Name in a class and invoking the same\n\nIn case we don’t know the exact method parameters, we could also get all the methods in the class and search through the method by its name and then get details of it\n• We would use getDeclaredMethods() API for the same. This would return array of Method objects in the class\n• We can use this to loop through the Method objects and find the method by its name using the getName().\n• Then we would use the getGenericParameterTypes() to find the parameter it takes and getGenericReturnType() to find its return type\n• Once we have the parameter and return type, we would use our invoke function mentioned above to invoke the method\n\nInvoke method would throw InvocationTargetException when the underlying method being invoked throws an exception. We would be able to retrieve the method’s exception by using getCause() method of InvocationTargetException"
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html",
        "document": "Thrown when a syntactically malformed signature attribute is encountered by a reflective method that needs to interpret the generic signature information for a type, method or constructor.\n\nThrown by a method invocation on a proxy instance if its invocation handler's invoke method throws a checked exception (athat is not assignable toor) that is not assignable to any of the exception types declared in theclause of the method that was invoked on the proxy instance and dispatched to the invocation handler.\n\nThrown when the java.lang.reflect package attempts to read method parameters from a class file and determines that one or more parameters are malformed.\n\nThrown when a semantically malformed parameterized type is encountered by a reflective method that needs to instantiate it.\n\nInvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor.\n\nProxy provides static methods for creating dynamic proxy classes and instances, and it is also the superclass of all dynamic proxy classes created by those methods.\n\nThe Modifier class provides static methods and constants to decode class and member access modifiers.\n\nA Method provides information about, and access to, a single method on a class or interface.\n\nA Field provides information about, and dynamic access to, a single field of a class or an interface.\n\nA shared superclass for the common functionality of Method and Constructor\n\nConstructor provides information about, and access to, a single constructor for a class.\n\nThe Array class provides static methods to dynamically create and access Java arrays.\n\nThe AccessibleObject class is the base class for Field, Method and Constructor objects.\n\nTypeVariable is the common superinterface for type variables of kinds.\n\nType is the common superinterface for all types in the Java programming language.\n\nMember is an interface that reflects identifying information about a single member (a field or a method) or a constructor.\n\nInvocationHandler is the interface implemented by the invocation handler of a proxy instance.\n\nGenericArrayType represents an array type whose component type is either a parameterized type or a type variable.\n\nAnnotatedWildcardType represents the potentially annotated use of a wildcard type argument, whose upper or lower bounds may themselves represent annotated uses of types.\n\nAnnotatedTypeVariable represents the potentially annotated use of a type variable, whose declaration may have bounds which themselves represent annotated uses of types.\n\nAnnotatedType represents the potentially annotated use of a type in the program currently running in this VM.\n\nAnnotatedParameterizedType represents the potentially annotated use of a parameterized type, whose type arguments may themselves represent annotated uses of types.\n\nRepresents an annotated element of the program currently running in this VM.\n\nAnnotatedArrayType represents the potentially annotated use of an array type, whose component type may itself represent the annotated use of a type.\n\nProvides classes and interfaces for obtaining reflective information about classes and objects. Reflection allows programmatic access to information about the fields, methods and constructors of loaded classes, and the use of reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.\n\nallows suppression of access checks if the necessary is available.\n\nprovides static methods to dynamically create and access arrays.\n\nClasses in this package, along with accommodate applications such as debuggers, interpreters, object inspectors, class browsers, and services such as Object Serialization and JavaBeans that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class."
    },
    {
        "link": "https://oracle.com/technical-resources/articles/java/javareflection.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/13611125/java-reflection-call-method-from-interface-name",
        "document": "I have have a name of an interface and I want to invoke a method defined by its concrete implemented class. So I took help of Java Reflection.\n\nBut it is not working and I am getting the following exception:\n\nThe exception is printing in console in loop, I need to stop the program.\n\nAny information will be very helpful to me."
    },
    {
        "link": "https://download.java.net/java/early_access/panama/docs/api/java.base/java/lang/reflect/package-summary.html",
        "document": "Provides classes and interfaces for obtaining reflective information about classes and objects. Reflection allows programmatic access to information about the fields, methods, and constructors of loaded classes, and the use of reflected fields, methods, and constructors to operate on their underlying counterparts, within encapsulation and security restrictions.\n\nClasses in this package, along with accommodate applications such as debuggers, interpreters, object inspectors, class browsers, and services such as Object Serialization and JavaBeans that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class.\n\nallows suppression of access checks if the necessary is available.\n\nprovides static methods to dynamically create and access arrays.\n\nThe components of core reflection, which include types in this package as well as , and , fundamentally present a JVM model of the entities in question rather than a Java programming language model. A Java compiler, such as, translates Java source code into executable output that can be run on a JVM, primarilyfiles. Compilers for source languages other than Java can and do target the JVM as well.\n\nThe translation process, including from Java language sources, to executable output for the JVM is not a one-to-one mapping. Structures present in the source language may have no representation in the output and structures not present in the source language may be present in the output. The latter are called synthetic structures. Synthetic structures can include methods, fields, parameters, classes and interfaces. One particular kind of synthetic method is a bridge method. It is possible a synthetic structure may not be marked as such. In particular, not all file versions support marking a parameter as synthetic. A source language compiler generally has multiple ways to translate a source program into a file representation. The translation may also depend on the version of the file format being targeted as different file versions have different capabilities and features. In some cases the modifiers present in the file representation may differ from the modifiers on the originating element in the source language, including on a parameter and , , and on classes and interfaces.\n\nBesides differences in structural representation between the source language and the JVM representation, core reflection also exposes runtime specific information. For example, the class loaders and protection domains of a are runtime concepts without a direct analogue in source code."
    },
    {
        "link": "https://stackoverflow.com/questions/3558620/java-reflection-where-a-method-parameter-is-an-interface",
        "document": "First off let me say I am maintaining someone else's poorly designed code so I am limited in how much I can change it.\n\nNow what is happening is that they have created a series of methods that are invoked by reflection. One of those methods takes a Map as one of its arguments. At runtime this Map is implemented with a Hashtable.\n\nHere's the problem - I get a NoSuchMethodException because it is looking for a method with Hashtable as an argument even though a Hashtable implements the Map interface. What is confusing me is that if I don't use reflection (a major design change in this case) and passed a Hashtable it would invoke the method with the Map parameter - so why doesn't it work the same way when I use reflection?\n\nGiven that I pretty much have to stick with reflection is there any way to get the method with the Map argument to get invoked when I pass it a class that implements that interface?\n\nIf you want I can mock some code up to demonstrate..."
    }
]