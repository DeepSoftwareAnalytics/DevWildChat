[
    {
        "link": "https://doc.qt.io/squish/squish-api.html",
        "document": "This section introduces the APIs that Squish provides in addition to the standard features of the scripting languages it supports. The Squish APIs provide the facilities that test engineers need to test GUI applications, and offer a wide range of functionality, from interacting with AUT objects, to recording information in test logs, performing verifications, controlling the AUT, and more.\n\nHere are some quick links to the Squish API functions (not including the Squish objects or the toolkit-specific convenience functions):\n\nFor all of the Squish API functions that take an argument, it can be a reference to an object or the name (symbolic name or real name) of an object.\n\nImage Search and OCR functions can take an optional argument. This can be an , a ScreenRectangle, or a list of them. If the string is passed, then all top-level widgets of the AUT will be searched.\n\nSome of the Squish API functions can take a argument that indicates which special keys are pressed at the time of a mouse click. Further, some of the functions take a argument that indicates which mouse button was clicked.\n\nThe can be 0 ( , the default), or the following: , , . If more than one modifier is used, they must be -d together. For example, . The form shown here works for Python and JavaScript. For Perl and Ruby, replace the period with two colons: . For Tcl, use the function: .\n\nThe can be any one of: , , , or .\n\nFor Perl use: , etc.\n\nFor Ruby use: , etc.\n\nFor Tcl use: , etc.\n\nMany of the APIs' functions apply to particular objects, so being able to identify the object of interest is particularly important.\n\nSquish provides several naming schemes, but the ones normally used are symbolic names and real names. Symbolic names are the most robust in the face of AUT changes, but real names can sometimes be more convenient to use. See How to Identify and Access Objects for more about names.\n\nFor Qt programs, using the QObject::setObjectName method on objects of interest from the AUT code (C++ or QML), makes it much easier to find those objects from Squish tests. We can use it in the real (multi-property) name specifying that object. For example:\n\nIt is rare that an AUT has a unique name for every single widget. Sometimes we must identify unnamed objects. This can be done using symbolic names or by matching an object's unique set of property values. The necessary information can be obtained using the Spy tool (How to Use the Spy). This tool can provide an object's symbolic name and its property-based (real) name. Another approach is to create a dummy test, interact with the objects of interest and then look in Squish's object map to see the names that Squish uses, and copy any that are needed.\n\nHere's an example that shows both approaches for finding an unnamed object of type . The object is in a whose title is \"My App\":\n\nThe Object waitForObject(objectOrName) function waits for the identified object to be ready (visible and enabled) and then returns a reference to it.\n\nOn the whole it is best to use symbolic names since they are more robust in the face of AUT changes, since they only require us to update the Object Map rather than our test script code if an object's properties change. (Note that for most GUI toolkits the property is mandatory when using real names.)\n\nSquish objects blend in seamlessly with the scripting language's native objects. This means that you can use standard language features to construct objects of the wrapped types, invoke member functions, and get, set, and iterate over properties on these objects.\n\nHere are some simple examples:\n\nFor Tcl we must use the function to get enum values. (See Tcl Notes.)\n\nThe function names in the scripting language API use the following convention: each colon ( ) in the selector name is replaced by an underscore ( ). So, for example, the selector becomes the script function (note the underscore at the end of the function).\n\nHere are some examples to illustrate the usage.\n\nIn Squish, we have different ways to convert and cast, depending on what kind of value we are working with. In short,\n• cast() can be used for converting values or pointers.\n• object.convertTo() is for converting basic types, and value types related to .\n• castToQObject() is specifically for downcasting -pointers/references in Squish for Qt using Run-Time Type Identification (RTTI).\n• typeName() is a function you can call to get the object's type name at runtime. Deprecated in favor of className()\n• className() is a function you can call to get the object's type name at runtime.\n\nThese functions can be used to group test results into logical units. A set of comparison or log/warning statements can be enclosed in / to have it logged as a distinct result section. The Squish IDE will display result sections as a nested set of test results. Executing tests on the commandline will, except when the XML3 report generator is used, get log messages added to the test report whenever a section starts or ends.\n\nThe compare, verify, and exception functions are used to record the results of tests applied to a running AUT in Squish's test log as passes or fails. The other functions can be used to programmatically record any kind of test results in the test log. See also, the Verification Point Creator view and How to Create and Use Verification Points."
    },
    {
        "link": "https://doc.qt.io/squish/how-to-identify-and-access-objects.html",
        "document": "How to Create Test Scripts How to Use Test Statements\n\nProbably the most important issue to face testers when writing scripts from scratch (or when modifying recorded scripts), is how to access objects in the user interface. We can obtain a reference to an object using the Object waitForObject(objectOrName) function. This function waits for the object to become visible and available and then returns a reference to it, or raises a catchable exception if it times out. If we need a reference to an object that isn't visible we must use the Object findObject(objectName) function, which does not wait. Both functions take an object name, but getting the right name can be tricky, so we will explain the issues and solutions here before going into the Squish edition-specific and scripting language-specific details.\n\nSquish supports a few completely different naming schemes, symbolic names, real names (also known as multi-property names), qualified names, and hierarchical names. In most editions of Squish, symbolic names are used when recording scripts. In Squish for Tk and Squish for Web, qualified and hierarchical names may also be used. For hand-written code, you can use symbolic names or real names. It is best to use symbolic names, although for some purposes real names are more convenient.\n\nIn cases where an object cannot be identified by name, a purely visual search can be performed based on a sub-image.\n\nThe easiest situation is where an application object has been given an explicit name by the programmer. For example, using the Qt toolkit, an object can be given a name like this:\n\nWhen an object is given a name in this way, we can identify it using a real name that specifies just two properties: type and name. Depending on the Object Map implementation used, the syntax for accessing the label differs slightly.\n\nHere are examples in the various scripting languages using the Object waitForObject(objectOrName) function when using a Text-Based Object Map:\n\nTo create a string that represents a real (multi-property) name, we create a string which has an opening brace, then one or more space-separated property items (each having the form, ), and finally a closing brace.\n\nWhen using a Script-Based Object Map, we can pass dictionaries to the Object waitForObject(objectOrName) function:\n\nWith Script-Based object maps, a dictionary object is constructed which accepts the properties to match a given object against as a set of key-value pairs. See Script-Based Object Map API for more information about the available API for constructing object names.\n\nFor most toolkits, at least two properties must be specified with one being the object's . If the object has an object name, using just the and properties is sufficient (providing that the name is unique amongst objects of the specified type).\n\nOnce we have a reference to an object we can access its properties, for example, to check them against expected values, or to change them. We will see how to do this in the Squish edition-specific sections that follow.\n\nSee also, the Application Objects view and the Properties view.\n\nHow to Access Objects Using Real (Multi-Property) Names\n\nSome objects are not identifiable by name, in which case, a special property, is 1. When we are faced with unnamed objects we can usually identify them using other properties. For example, here is one way to identify and access a button.\n\nThe real name above is expressed as a native key-value mapping in each script language, which is how the Script-Based Object Map works. Real names can also be expressed as strings using the legacy Text-Based Object Map, used prior to Squish 6.4:\n\nThese names specify enough criteria for this particular GUI, such that there is only one button on the form with the text of Pay.\n\nIn some cases, the object we are interested in has neither a name nor any unique text of its own. But even in such cases it is usually possible to identify it. For example, an unnamed spinbox might well be the buddy of an associated label, so we can use this relationship to uniquely identify the spinbox. A Script-Based Object Map allows referencing other object names using plain script variables. Here, the buddy is identified using a symbolic name copied from the Object Map.\n\nIf there is no obvious way of identifying an object, either use the Spy tool to get Squish to provide a suitable name, or record a quick throwaway test in which you interact with the object of interest and then put the mouse over the symbolic name, right-click and select Open Symbolic Name to see its real name in the Object Map. You can use one or the other in your real test.\n\nIn some cases we might want to use a property whose text varies. For example, if we want to identify a window whose caption text changes depending on the window's contents. This is possible using Squish's sophisticated matching capabilities and is described later in Improving Object Identification.\n\nIf the Object waitForObject(objectOrName) function cannot find the object with the given name, an exception is raised. For most languages this is a base class exception, but for Python it is the more specialized and for Ruby . If the exception isn't caught an error entry to be added to Squish's log in the Test Results view. (See How to Handle Exceptions Raised in Test Scripts.) This is normally what we want since it probably means we mistyped one of the property's values. However, if an object may exist only in some cases (for example, if a particular tab of a tab widget is chosen), we can use the Boolean object.exists(objectName) function to check if an object of the given name exists, and if it does to perform any tests we want on it in that case. For example, in Python we could write this (assuming an Script-Based Object Map is used):\n\nOne advantage of this approach is that if the object does not exist the script finds out straight away. Compare it with this approach:\n\nThis is potentially slower than using the Boolean object.exists(objectName) function since the Object waitForObject(objectOrName) function will wait for 20 seconds (the default timeout, which can be changed by giving a second argument), although both approaches are valid.\n\nHow to Access Objects Using Symbolic Names\n\nWhen Squish records a test it uses symbolic names to identify the widgets. Symbolic names assume different forms depending on whether the test uses a Text-Based Object Map or a Script-Based Object Map: in the former case, symbolic names are plain strings starting with a , in the latter case symbolic names are script variables. Some symbolic names are quite easy to understand, for example, , while others can be more cryptic, for example, —this symbolic name includes the window caption which shows the name of the current file. Symbolic names are generated programmatically by Squish although they can also be used in hand-written code, or when modifying or using extracts from recorded tests.\n\nSymbolic names have one major advantage over real names: if a property that a real name depends on changes (i.e., due to a change in the AUT), the real name will no longer be valid, and all uses of it in test scripts will have to be updated. But if a symbolic name has been used, the real name that the symbolic name refers to, (i.e., the name's properties and their values), can simply be updated in the Object Map, and no changes to tests are necessary. It is for this reason that it is almost always better to use symbolic names rather than real names whenever possible. (See Object Map and the Object Map view.)\n\nHow to Access Objects Using Images\n\nAccessing objects by name as described above is the preferred approach. In case of dynamic user interfaces the selection of fitting properties may require some work but will result in the most robust test scripts. In light of changes in the application's GUI style for example.\n\nIn some cases, however, object identification cannot be tackled by properties. Not as easily at least. Such cases are:\n• Access to applications other than the main AUT. This includes menus, task bars and desktop controls of the operating system itself.\n\nTo deal with such cases outside of the direct control, Squish provides an alternative look-up based on sub-images. Images of arbitrary size and shape can be searched for on the screen with ScreenRectangle waitForImage(imageFile, [parameterMap], [searchRegion]). The determined location will be returned as a ScreenRectangle which can again serve as an input to interaction functions like mouseClick(screenPoint, modifierState, button).\n\nCreation of the needed sub-images as well as insertion of the respective script functions is most conveniently achieved interactively by clicking Record ( ) and the Insert ( ) > mouseClick(<Image>) ( ) action."
    },
    {
        "link": "https://stackoverflow.com/questions/39459668/how-to-verify-text-using-squish",
        "document": "I am automating a windows application using Squish. I am trying to verify if the required text is displayed in a window after I make some changes in the GUI. I used object spy to get the object ID, but I am confused how to give a test verification point. The following Verification point says in the results window as 'True' and 'True' are equal. But I want it to be as, for example 4X and 4X are equal."
    },
    {
        "link": "https://stackoverflow.com/questions/71674129/squish-issue-to-recognize-in-gui-object-names",
        "document": "I use SQUISH to perform automated tests (written in python) on a GUI application (based Linux SUSE 15) with Qt version 5.9.4. This application contains objects with properties (example name of a menu) containing the character \"&\".\n\nMy test script crashes everytime an object containing the character \"&\" (in its properties) is called in the script. The error is : \"LookupError: Object 'Hardwired links from RCSL to turbine I&C' not found\n\nFor debugging, I erase this character from the the application design ==> No more issues were observed, the test scripts passed.\n\nBut, it is not a sustainble solution, I need the \"&\" character in my application.\n\nDo you guys have any information about SQUISH having problem with managing certain characters as \"&\" ?"
    },
    {
        "link": "https://origin2.cdn.componentsource.com/sites/default/files/resources/froglogic/539416/squish-manual.pdf",
        "document": ""
    },
    {
        "link": "https://docs.python.org/3/library/zipfile.html",
        "document": "The ZIP file format is a common archive and compression standard. This module provides tools to create, read, write, append, and list a ZIP file. Any advanced use of this module will require an understanding of the format, as defined in PKZIP Application Note.\n\nThis module does not currently handle multi-disk ZIP files. It can handle ZIP files that use the ZIP64 extensions (that is ZIP files that are more than 4 GiB in size). It supports decryption of encrypted files in ZIP archives, but it currently cannot create an encrypted file. Decryption is extremely slow as it is implemented in native Python rather than C.\n\nThe module defines the following items:\n\nOpen a ZIP file, where file can be a path to a file (a string), a file-like object or a path-like object. The mode parameter should be to read an existing file, to truncate and write a new file, to append to an existing file, or to exclusively create and write a new file. If mode is and file refers to an existing file, a will be raised. If mode is and file refers to an existing ZIP file, then additional files are added to it. If file does not refer to a ZIP file, then a new ZIP archive is appended to the file. This is meant for adding a ZIP archive to another file (such as ). If mode is and the file does not exist at all, it is created. If mode is or , the file should be seekable. compression is the ZIP compression method to use when writing the archive, and should be , , or ; unrecognized values will cause to be raised. If , or is specified but the corresponding module ( , or ) is not available, is raised. The default is . If allowZip64 is (the default) zipfile will create ZIP files that use the ZIP64 extensions when the zipfile is larger than 4 GiB. If it is will raise an exception when the ZIP file would require ZIP64 extensions. The compresslevel parameter controls the compression level to use when writing files to the archive. When using or it has no effect. When using integers through are accepted (see for more information). When using integers through are accepted (see for more information). The strict_timestamps argument, when set to , allows to zip files older than 1980-01-01 at the cost of setting the timestamp to 1980-01-01. Similar behavior occurs with files newer than 2107-12-31, the timestamp is also set to the limit. When mode is , metadata_encoding may be set to the name of a codec, which will be used to decode metadata such as the names of members and ZIP comments. If the file is created with mode , or and then without adding any files to the archive, the appropriate ZIP structures for an empty archive will be written to the file. ZipFile is also a context manager and therefore supports the statement. In the example, myzip is closed after the statement’s suite is finished—even if an exception occurs: metadata_encoding is an instance-wide setting for the ZipFile. It is not currently possible to set this on a per-member basis. This attribute is a workaround for legacy implementations which produce archives with names in the current locale encoding or code page (mostly on Windows). According to the .ZIP standard, the encoding of metadata may be specified to be either IBM code page (default) or UTF-8 by a flag in the archive header. That flag takes precedence over metadata_encoding, which is a Python-specific extension. Changed in version 3.2: Added the ability to use as a context manager. Changed in version 3.3: Added support for and compression. Changed in version 3.4: ZIP64 extensions are enabled by default. Changed in version 3.5: Added support for writing to unseekable streams. Added support for the mode. Changed in version 3.6: Previously, a plain was raised for unrecognized compression values. Changed in version 3.11: Added support for specifying member name encoding for reading metadata in the zipfile’s directory and file headers. Close the archive file. You must call before exiting your program or essential records will not be written. Return a object with information about the archive member name. Calling for a name not currently contained in the archive will raise a . Return a list containing a object for each member of the archive. The objects are in the same order as their entries in the actual ZIP file on disk if an existing archive was opened. Return a list of archive members by name. Access a member of the archive as a binary file-like object. name can be either the name of a file within the archive or a object. The mode parameter, if included, must be (the default) or . pwd is the password used to decrypt encrypted ZIP files as a object. is also a context manager and therefore supports the statement: With mode the file-like object ( ) is read-only and provides the following methods: , , , , , , . These objects can operate independently of the ZipFile. With , a writable file handle is returned, which supports the method. While a writable file handle is open, attempting to read or write other files in the ZIP file will raise a . In both cases the file-like object has also attributes , which is equivalent to the name of a file within the archive, and , which is or depending on the input mode. When writing a file, if the file size is not known in advance but may exceed 2 GiB, pass to ensure that the header format is capable of supporting large files. If the file size is known in advance, construct a object with set, and use that as the name parameter. The , and methods can take a filename or a object. You will appreciate this when trying to read a ZIP file that contains members with duplicate names. Changed in version 3.6: Removed support of . Use for reading compressed text files in universal newlines mode. Changed in version 3.6: can now be used to write files into the archive with the option. Changed in version 3.6: Calling on a closed ZipFile will raise a . Previously, a was raised. Changed in version 3.13: Added attributes and for the writeable file-like object. The value of the attribute for the readable file-like object was changed from to . Extract a member from the archive to the current working directory; member must be its full name or a object. Its file information is extracted as accurately as possible. path specifies a different directory to extract to. member can be a filename or a object. pwd is the password used for encrypted files as a object. Returns the normalized path created (a directory or new file). If a member filename is an absolute path, a drive/UNC sharepoint and leading (back)slashes will be stripped, e.g.: becomes on Unix, and becomes on Windows. And all components in a member filename will be removed, e.g.: becomes . On Windows illegal characters ( , , , , , , and ) replaced by underscore ( ). Changed in version 3.6: Calling on a closed ZipFile will raise a . Previously, a was raised. Extract all members from the archive to the current working directory. path specifies a different directory to extract to. members is optional and must be a subset of the list returned by . pwd is the password used for encrypted files as a object. Never extract archives from untrusted sources without prior inspection. It is possible that files are created outside of path, e.g. members that have absolute filenames starting with or filenames with two dots . This module attempts to prevent that. See note. Changed in version 3.6: Calling on a closed ZipFile will raise a . Previously, a was raised. Print a table of contents for the archive to . Return the bytes of the file name in the archive. name is the name of the file in the archive, or a object. The archive must be open for read or append. pwd is the password used for encrypted files as a object and, if specified, overrides the default password set with . Calling on a ZipFile that uses a compression method other than , , or will raise a . An error will also be raised if the corresponding compression module is not available. Changed in version 3.6: Calling on a closed ZipFile will raise a . Previously, a was raised. Read all the files in the archive and check their CRC’s and file headers. Return the name of the first bad file, or else return . Changed in version 3.6: Calling on a closed ZipFile will raise a . Previously, a was raised. Write the file named filename to the archive, giving it the archive name arcname (by default, this will be the same as filename, but without a drive letter and with leading path separators removed). If given, compress_type overrides the value given for the compression parameter to the constructor for the new entry. Similarly, compresslevel will override the constructor if given. The archive must be open with mode , or . The ZIP file standard historically did not specify a metadata encoding, but strongly recommended CP437 (the original IBM PC encoding) for interoperability. Recent versions allow use of UTF-8 (only). In this module, UTF-8 will automatically be used to write the member names if they contain any non-ASCII characters. It is not possible to write member names in any encoding other than ASCII or UTF-8. Archive names should be relative to the archive root, that is, they should not start with a path separator. If (or , if is not given) contains a null byte, the name of the file in the archive will be truncated at the null byte. A leading slash in the filename may lead to the archive being impossible to open in some zip programs on Windows systems. Changed in version 3.6: Calling on a ZipFile created with mode or a closed ZipFile will raise a . Previously, a was raised. Write a file into the archive. The contents is data, which may be either a or a instance; if it is a , it is encoded as UTF-8 first. zinfo_or_arcname is either the file name it will be given in the archive, or a instance. If it’s an instance, at least the filename, date, and time must be given. If it’s a name, the date and time is set to the current date and time. The archive must be opened with mode , or . If given, compress_type overrides the value given for the compression parameter to the constructor for the new entry, or in the zinfo_or_arcname (if that is a instance). Similarly, compresslevel will override the constructor if given. When passing a instance as the zinfo_or_arcname parameter, the compression method used will be that specified in the compress_type member of the given instance. By default, the constructor sets this member to . Changed in version 3.6: Calling on a ZipFile created with mode or a closed ZipFile will raise a . Previously, a was raised. Create a directory inside the archive. If zinfo_or_directory is a string, a directory is created inside the archive with the mode that is specified in the mode argument. If, however, zinfo_or_directory is a instance then the mode argument is ignored. The archive must be opened with mode , or . The following data attributes are also available: The level of debug output to use. This may be set from (the default, no output) to (the most output). Debugging information is written to . The comment associated with the ZIP file as a object. If assigning a comment to a instance created with mode , or , it should be no longer than 65535 bytes. Comments longer than this will be truncated.\n\nConstruct a Path object from a zipfile (which may be a instance or suitable for passing to the constructor). specifies the location of this Path within the zipfile, e.g. ‘dir/file.txt’, ‘dir/’, or ‘’. Defaults to the empty string, indicating the root. The class does not sanitize filenames within the ZIP archive. Unlike the and methods, it is the caller’s responsibility to validate or sanitize filenames to prevent path traversal vulnerabilities (e.g., filenames containing “..” or absolute paths). When handling untrusted archives, consider resolving filenames using and checking against the target directory with . Path objects expose the following features of objects: Path objects are traversable using the operator or . Invoke on the current path. Allows opening for read or write, text or binary through supported modes: ‘r’, ‘w’, ‘rb’, ‘wb’. Positional and keyword arguments are passed through to when opened as text and ignored otherwise. is the parameter to . Changed in version 3.9: Added support for text and binary modes for open. Default mode is now text. Changed in version 3.11.2: The parameter can be supplied as a positional argument without causing a . As it could in 3.9. Code needing to be compatible with unpatched 3.10 and 3.11 versions must pass all arguments, included, as keywords. Enumerate the children of the current directory. Return if the current context references a file or directory in the zip file. The last dot-separated portion of the final component, if any. This is commonly called the file extension. The final path component, without its suffix. Read the current file as unicode text. Positional and keyword arguments are passed through to (except , which is implied by the context). Changed in version 3.11.2: The parameter can be supplied as a positional argument without causing a . As it could in 3.9. Code needing to be compatible with unpatched 3.10 and 3.11 versions must pass all arguments, included, as keywords. Return a new Path object with each of the other arguments joined. The following are equivalent: Changed in version 3.10: Prior to 3.10, was undocumented and accepted exactly one parameter. The zipp project provides backports of the latest path object functionality to older Pythons. Use in place of for early access to changes.\n\nThe module provides a simple command-line interface to interact with ZIP archives. If you want to create a new ZIP archive, specify its name after the option and then list the filename(s) that should be included: If you want to extract a ZIP archive into the specified directory, use the option: For a list of the files in a ZIP archive, use the option: Test whether the zipfile is valid or not. Specify encoding of member names for , and .\n\nThe extraction in zipfile module might fail due to some pitfalls listed below. Decompression may fail due to incorrect password / CRC checksum / ZIP format or unsupported compression method / decryption. Exceeding limitations on different file systems can cause decompression failed. Such as allowable characters in the directory entries, length of the file name, length of the pathname, size of a single file, and number of files, etc. The lack of memory or disk volume would lead to decompression failed. For example, decompression bombs (aka ZIP bomb) apply to zipfile library that can cause disk volume exhaustion. Interruption during the decompression, such as pressing control-C or killing the decompression process may result in incomplete decompression of the archive. Not knowing the default extraction behaviors can cause unexpected decompression results. For example, when extracting the same archive twice, it overwrites files without asking."
    },
    {
        "link": "https://docs.python.org/3/library/archiving.html",
        "document": "The modules described in this chapter support data compression with the zlib, gzip, bzip2 and lzma algorithms, and the creation of ZIP- and tar-format archives. See also Archiving operations provided by the module."
    },
    {
        "link": "https://stackoverflow.com/questions/1855095/how-to-create-a-zip-archive-of-a-directory",
        "document": "How can I create a zip archive of a directory structure in Python?\n\nThe easiest way is to use . It supports both zip and tar formats. If you need to do something more complicated than zipping the whole directory (such as skipping certain files), then you'll need to dig into the module as others have suggested.\n\nHow can I create a zip archive of a directory structure in Python? from shutil import make_archive make_archive( 'zipfile_name', 'zip', # the archive format - or tar, bztar, gztar root_dir=None, # root for archive - current working dir if None base_dir=None) # start archiving from here - cwd if None too Here the zipped archive will be named . If is farther down from it will exclude files not in the , but still archive the files in the parent dirs up to the . I did have an issue testing this on Cygwin with 2.7 - it wants a root_dir argument, for cwd: Using Python from the shell You can do this with Python from the shell also using the module: Where is the name of the destination file you want (add if you want it, it won't do it automatically) and sourcedir is the path to the directory. Zipping up Python (or just don't want parent dir): If you're trying to zip up a python package with a and , and you don't want the parent dir, it's would run the package. (Note that you can't run subpackages as the entry point from a zipped archive.) If you have python3.5+, and specifically want to zip up a Python package, use zipapp:\n\nI've made some changes to code given by Mark Byers. Below function will also adds empty directories if you have them. Examples should make it more clear what is the path added to the zip. #!/usr/bin/env python import os import zipfile def addDirToZip(zipHandle, path, basePath=\"\"): \"\"\" Adding directory given by \\a path to opened zip file \\a zipHandle @param basePath path that will be removed from \\a path when adding to archive Examples: # add whole \"dir\" to \"test.zip\" (when you open \"test.zip\" you will see only \"dir\") zipHandle = zipfile.ZipFile('test.zip', 'w') addDirToZip(zipHandle, 'dir') zipHandle.close() # add contents of \"dir\" to \"test.zip\" (when you open \"test.zip\" you will see only it's contents) zipHandle = zipfile.ZipFile('test.zip', 'w') addDirToZip(zipHandle, 'dir', 'dir') zipHandle.close() # add contents of \"dir/subdir\" to \"test.zip\" (when you open \"test.zip\" you will see only contents of \"subdir\") zipHandle = zipfile.ZipFile('test.zip', 'w') addDirToZip(zipHandle, 'dir/subdir', 'dir/subdir') zipHandle.close() # add whole \"dir/subdir\" to \"test.zip\" (when you open \"test.zip\" you will see only \"subdir\") zipHandle = zipfile.ZipFile('test.zip', 'w') addDirToZip(zipHandle, 'dir/subdir', 'dir') zipHandle.close() # add whole \"dir/subdir\" with full path to \"test.zip\" (when you open \"test.zip\" you will see only \"dir\" and inside it only \"subdir\") zipHandle = zipfile.ZipFile('test.zip', 'w') addDirToZip(zipHandle, 'dir/subdir') zipHandle.close() # add whole \"dir\" and \"otherDir\" (with full path) to \"test.zip\" (when you open \"test.zip\" you will see only \"dir\" and \"otherDir\") zipHandle = zipfile.ZipFile('test.zip', 'w') addDirToZip(zipHandle, 'dir') addDirToZip(zipHandle, 'otherDir') zipHandle.close() \"\"\" basePath = basePath.rstrip(\"\\\\/\") + \"\" basePath = basePath.rstrip(\"\\\\/\") for root, dirs, files in os.walk(path): # add dir itself (needed for empty dirs zipHandle.write(os.path.join(root, \".\")) # add files for file in files: filePath = os.path.join(root, file) inZipPath = filePath.replace(basePath, \"\", 1).lstrip(\"\\\\/\") #print filePath + \" , \" + inZipPath zipHandle.write(filePath, inZipPath) Above is a simple function that should work for simple cases. You can find more elegant class in my Gist: https://gist.github.com/Eccenux/17526123107ca0ac28e6\n\nSo many answers here, and I hope I might contribute with my own version, which is based on the original answer (by the way), but with a more graphical perspective, also using context for each setup and sorting , in order to have a ordered output. Having these folders and them files (among other folders), I wanted to create a for each folder: Here's what I applied, with comments for better understanding of the process. $ cat zip_cap_dirs.py \"\"\" Zip 'cap_*' directories. \"\"\" import os import zipfile as zf for root, dirs, files in sorted(os.walk('.')): if 'cap_' in root: print(f\"Compressing: {root}\") # Defining .zip name, according to Capítulo. cap_dir_zip = '{}.zip'.format(root) # Opening zipfile context for current root dir. with zf.ZipFile(cap_dir_zip, 'w', zf.ZIP_DEFLATED) as new_zip: # Iterating over os.walk list of files for the current root dir. for f in files: # Defining relative path to files from current root dir. f_path = os.path.join(root, f) # Writing the file on the .zip file of the context new_zip.write(f_path) Basically, for each iteration over , I'm opening a context for setup and afterwards, iterating iterating over , which is a of files from directory, forming the relative path for each file based on the current directory, appending to the context which is running. And the output is presented like this: To see the contents of each directory, you can use command:"
    },
    {
        "link": "https://rpaframework.org/libraries/archive/python.html",
        "document": "This keyword creates an TAR or TAR.GZ archive of a local folder. Type of archive is determined by the file extension. By default subdirectories are not included, but they can included using argument.\n\nTo include only certain files, like TXT files, the argument can be used. Similarly to exclude certain file, like dotfiles, the argument can be used."
    },
    {
        "link": "https://stackoverflow.com/questions/58699196/archiving-files-using-python-apart-from-latest-file",
        "document": "I am trying to archive existing file apart from the latest modified file in Python or FME. I have managed to get it to point where I can get python pick up the latest modified file but any ideas on how I can archive all the files i have in my folder apart from the last modified file?"
    }
]