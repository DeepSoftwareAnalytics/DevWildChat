[
    {
        "link": "https://stackoverflow.com/questions/35250801/nested-loops-asymptotic-analysis",
        "document": "It might be easiest to analyze the runtime of the piece of code in the aggregate. On the first iteration of the outer loop, the inner loop will run 1 time. On the second iteration of the outer loop, the inner loop will run 2 times. On the third iteration of the outer loop, the inner loop will run 4 times. More generally, on the kth iteration of the outer loop, the inner loop will run 2k times. The outer loop stops as soon as i becomes greater than N, which happens after log N iterations.\n\nIf we sum up the total work done, we'll see that it's\n\n(This uses the fact that 1 + 2 + 4 + 8 + ... + 2k = 2k+1 - 1). Therefore, the total work done for the entire piece of code (that is, including both loops) is O(n)."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-analyse-loops-for-complexity-analysis-of-algorithms",
        "document": "We have discussed Asymptotic Analysis, Worst, Average and Best Cases and Asymptotic Notations in previous posts. In this post, an analysis of iterative programs with simple examples is discussed.\n\nThe analysis of loops for the complexity analysis of algorithms involves finding the number of operations performed by a loop as a function of the input size. This is usually done by determining the number of iterations of the loop and the number of operations performed in each iteration.\n\nHere are the general steps to analyze loops for complexity analysis:\n\nDetermine the number of iterations of the loop. This is usually done by analyzing the loop control variables and the loop termination condition.\n\nDetermine the number of operations performed in each iteration of the loop. This can include both arithmetic operations and data access operations, such as array accesses or memory accesses.\n\nExpress the total number of operations performed by the loop as a function of the input size. This may involve using mathematical expressions or finding a closed-form expression for the number of operations performed by the loop.\n\nDetermine the order of growth of the expression for the number of operations performed by the loop. This can be done by using techniques such as big O notation or by finding the dominant term and ignoring lower-order terms.\n\nThe time complexity of a function (or set of statements) is considered as O(1) if it doesn’t contain a loop, recursion, and call to any other non-constant time function. \n\n i.e. set of non-recursive and non-loop statements\n\nIn computer science, O(1) refers to constant time complexity, which means that the running time of an algorithm remains constant and does not depend on the size of the input. This means that the execution time of an O(1) algorithm will always take the same amount of time regardless of the input size. An example of an O(1) algorithm is accessing an element in an array using an index.\n• None A loop or recursion that runs a constant number of times is also considered O(1). For example, the following loop is O(1).\n\nThe Time Complexity of a loop is considered as O(n) if the loop variables are incremented/decremented by a constant amount. For example following functions have O(n) time complexity. Linear time complexity, denoted as O(n), is a measure of the growth of the running time of an algorithm proportional to the size of the input. In an O(n) algorithm, the running time increases linearly with the size of the input. For example, searching for an element in an unsorted array or iterating through an array and performing a constant amount of work for each element would be O(n) operations. In simple words, for an input of size n, the algorithm takes n steps to complete the operation.\n\nThe time complexity is defined as an algorithm whose performance is directly proportional to the squared size of the input data, as in nested loops it is equal to the number of times the innermost statement is executed. For example, the following sample loops have O(n2) time complexity\n\nQuadratic time complexity, denoted as O(n^2), refers to an algorithm whose running time increases proportional to the square of the size of the input. In other words, for an input of size n, the algorithm takes n * n steps to complete the operation. An example of an O(n^2) algorithm is a nested loop that iterates over the entire input for each element, performing a constant amount of work for each iteration. This results in a total of n * n iterations, making the running time quadratic in the size of the input.\n\nExample: Selection sort and Insertion Sort have O(n2) time complexity.\n\nThe time Complexity of a loop is considered as O(Logn) if the loop variables are divided/multiplied by a constant amount. And also for recursive calls in the recursive function, the Time Complexity is considered as O(Logn).\n\nThe Time Complexity of a loop is considered as O(LogLogn) if the loop variables are reduced/increased exponentially by a constant amount.\n\nSee this for mathematical details.\n\nHow to combine the time complexities of consecutive loops?\n\nWhen there are consecutive loops, we calculate time complexity as a sum of the time complexities of individual loops.\n\nTo combine the time complexities of consecutive loops, you need to consider the number of iterations performed by each loop and the amount of work performed in each iteration. The total time complexity of the algorithm can be calculated by multiplying the number of iterations of each loop by the time complexity of each iteration and taking the maximum of all possible combinations.\n\nFor example, consider the following code:\n\nHere, the outer loop performs n iterations, and the inner loop performs m iterations for each iteration of the outer loop. So, the total number of iterations performed by the inner loop is n * m, and the total time complexity is O(n * m).\n\nIn another example, consider the following code:\n\nHere, the outer loop performs n iterations, and the inner loop performs i iterations for each iteration of the outer loop, where i is the current iteration count of the outer loop. The total number of iterations performed by the inner loop can be calculated by summing the number of iterations performed in each iteration of the outer loop, which is given by the formula sum(i) from i=1 to n, which is equal to n * (n + 1) / 2. Hence, the total time complex\n\n\n\nHow to calculate time complexity when there are many if, else statements inside loops?\n\nAs discussed here, the worst-case time complexity is the most useful among best, average and worst. Therefore we need to consider the worst case. We evaluate the situation when values in if-else conditions cause a maximum number of statements to be executed. \n\nFor example, consider the linear search function where we consider the case when an element is present at the end or not present at all. \n\nWhen the code is too complex to consider all if-else cases, we can get an upper bound by ignoring if-else and other complex control statements.\n\nHow to calculate the time complexity of recursive functions?\n\nThe time complexity of a recursive function can be written as a mathematical recurrence relation. To calculate time complexity, we must know how to solve recurrences. We will soon be discussing recurrence-solving techniques as a separate post.\n\nQuiz on Analysis of Algorithms \n\nFor more details, please refer: Design and Analysis of Algorithms.\n\nPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above."
    },
    {
        "link": "https://stackoverflow.com/questions/28529601/asymptotic-analysis-for-nested-loop",
        "document": "I would like to understand Asymptotic Analysis better since I believe I don't have solid understanding on that. I would appreciate if someone can highlight a better approach to it. Here are two examples\n\nThis question is from Quiz and its answer is O(n log n)\n\nI watched a lecture of Stanford University and its example is below\n\nAsymptotic Analysis for second given problem is Quadratic O(n^2)\n\nHow can I know when is O(n log n) or O(n^2) they both have nested for loop?\n\nAny answer is highly appreciated. Thanks beforehand"
    },
    {
        "link": "https://cs.stackexchange.com/questions/121525/asymptotic-analysis-of-nested-loops-with-conditionals",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://geeksforgeeks.org/guidelines-for-asymptotic-analysis",
        "document": "In this article, the focus is on learning some rules that can help to determine the running time of an algorithm.\n\nAsymptotic analysis refers to computing the running time of any operation in mathematical units of computation. In Asymptotic Analysis, the performance of an algorithm in terms of input size (we don’t measure the actual running time) is evaluated. How the time (or space) taken by an algorithm increases with the input size is also calculated.\n\n(g(n)) = {f(n) such that g(n) is a curve which approximates f(n) at higher values of input size, n} This curve is called asymptotic curve and the algorithm analysis for such a curve is called Asymptotic analysis.\n\nLoops: The running time of a loop is, at most, the running time of the statements inside the loop, including tests) multiplied number of iterations.\n\nBelow is the python program that demonstrates the above concept:\n\nNested loops: Analyze from the inside out. The total running time is the product of the sizes of all the loops.\n\nBelow is a python program that demonstrates the above concept:\n\nConsecutive statements: Add the time complexity of each statement.\n\nBelow is a python program that demonstrates the above concept:\n\nIf-then-else statements: Worst-case running time: the test, plus either the then part of the else part whichever is the largest.\n\nBelow is a python program that demonstrates the above concept:"
    },
    {
        "link": "https://stackoverflow.com/questions/60087416/what-is-time-complexity-of-4-nested-loops-which-each-depend-on-the-parent-loop",
        "document": "I'm preparing for a technical interview, and I have a problem with calculating the time complexity of my algorithm. I know the time complexity for two loops nested in one another is O(n^2) but what if the nested loop continues the parent loop. Something like this:\n\nIs the time complexity for this code n^4, or something else? I wrote a program to count each operation, and I came up with 2^n, but I have no clue how to get to 2^n from 4 nested loops.\n\nI would appreciate if you explain your solution.\n\nHere is the program that I wrote to count the number of operations:"
    },
    {
        "link": "https://geeksforgeeks.org/understanding-time-complexity-simple-examples",
        "document": "A lot of students get confused while understanding the concept of time complexity, but in this article, we will explain it with a very simple example.\n\nQ. Imagine a classroom of 100 students in which you gave your pen to one person. You have to find that pen without knowing to whom you gave it.\n\nHere are some ways to find the pen and what the O order is.\n• O(n2): You go and ask the first person in the class if he has the pen. Also, you ask this person about the other 99 people in the classroom if they have that pen and so on, \n\n This is what we call O(n\n• O(n): Going and asking each student individually is O(N).\n• O(log n): Now I divide the class into two groups, then ask: “Is it on the left side, or the right side of the classroom?” Then I take that group and divide it into two and ask again, and so on. Repeat the process till you are left with one student who has your pen. This is what you mean by O(log n).\n\nI might need to do:\n• O(n2) only one student knows on which student the pen is hidden\n• O(n) one student had the pen and only they knew it\n• O(log n) all the students knew , but would only tell me if I guessed the right side.\n\nNOTE: We are interested in the rate of growth over time with respect to the inputs taken during the program execution.\n\nIs the Time Complexity of an Algorithm/Code the same as the Running/Execution Time of Code?\n\nThe Time Complexity of an algorithm/code is not equal to the actual time required to execute a particular code, but the number of times a statement executes. We can prove this by using the time command.\n\nFor example: Write code in C/C++ or any other language to find the maximum between N numbers, where N varies from 10, 100, 1000, and 10000. For Linux based operating system (Fedora or Ubuntu), use the below commands:\n\nYou will get surprising results i.e.:\n• None For N = 10: you may get 0.5 ms time,\n• None For N = 10,000: you may get 0.2 ms time.\n• None Also, you will get different timings on different machines. Even if you will not get the same timings on the same machine for the same code, the reason behind that is the current network load.\n\nSo, we can say that the actual time required to execute code is machine-dependent (whether you are using Pentium 1 or Pentium 5) and also it considers network load if your machine is in LAN/WAN.\n\nWhat is meant by the Time Complexity of an Algorithm?\n\nNow, the question arises if time complexity is not the actual time required to execute the code, then what is it?\n\nExample 1: Consider the below simple code to print Hello World\n\nTime Complexity: In the above code “Hello World” is printed only once on the screen. \n\nSo, the time complexity is constant: O(1) i.e. every time a constant amount of time is required to execute code, no matter which operating system or which machine configurations you are using. \n\nAuxiliary Space: O(1)\n\nTime Complexity: In the above code “Hello World !!!” is printed only n times on the screen, as the value of n can change. \n\nSo, the time complexity is linear: O(n) i.e. every time, a linear amount of time is required to execute code.\n\nAuxiliary Space: O(1)\n\nHow To Find The Time Complexity Of An Algorithm?\n\nNow let us see some other examples and the process to find the time complexity of an algorithm:\n\nExample: Let us consider a model machine that has the following specifications:\n\nQ1. Find the Sum of 2 numbers on the above machine:\n\nFor any machine, the pseudocode to add two numbers will be something like this:\n• None The above code will take 2 units of time(constant):\n• None one for arithmetic operations and\n• None one for return. (as per the above conventions).\n\nQ2. Find the sum of all elements of a list/array\n\nThe pseudocode to do so can be given as:\n\n\n\nTo understand the time complexity of the above code, let’s see how much time each statement will take:\n\nTherefore the total cost to perform sum operation\n\nTherefore, the time complexity of the above code is O(n)\n\nQ3. Find the sum of all elements of a matrix\n\nFor this one, the complexity is a polynomial equation (quadratic equation for a square matrix)\n• None Since Tsum is in order of n Time Complexity = O(n2)\n\nTime Complexity: O(n*m)\n\nThe program iterates through all the elements in the 2D array using two nested loops. The outer loop iterates n times and the inner loop iterates m times for each iteration of the outer loop. Therefore, the time complexity of the program is O(n*m).\n\nAuxiliary Space: O(n*m)\n\nThe program uses a fixed amount of auxiliary space to store the 2D array and a few integer variables. The space required for the 2D array is nm integers. The program also uses a single integer variable to store the sum of the elements. Therefore, the auxiliary space complexity of the program is O(nm + 1), which simplifies to O(n*m).\n\nIn conclusion, the time complexity of the program is O(nm), and the auxiliary space complexity is also O(nm).\n\nTo compare algorithms, let us define a few objective measures:\n• Execution times: Not a good measure as execution times are specific to a particular computer.\n• The number of statements executed: Not a good measure, since the number of statements varies with the programming language as well as the style of the individual programmer.\n• Ideal solution: Let us assume that we express the running time of a given algorithm as a function of the input size n (i.e., f(n)) and compare these different functions corresponding to running times. This kind of comparison is independent of machine time, programming style, etc. \n\n Therefore, an ideal solution can be used to compare algorithms.\n• None Analysis of Algorithms | Set 2 (Worst, Average and Best Cases)"
    },
    {
        "link": "https://stackoverflow.com/questions/52302600/best-and-the-worst-case-time-complexity-for-4-nested-for-loops",
        "document": "Worst case: O(n4), when there is no repeated element -> you end up iterating whole array for each element of it.\n\nNote that you could implement it more efficiently with a map or a set (will call it structure):\n• If the structure already has A[i][j], return 1\n\nThis will give you a worse case of O(n2 log n) or O(n2), depending on the structure you use"
    },
    {
        "link": "https://medium.com/enjoy-algorithm/analysis-of-loop-in-programming-cc9a644ef8cd",
        "document": "Loops are a fundamental operation in programming and are used to solve a variety of problems. Many problem-solving approaches in coding involve different types of loop structures. In fact, some approaches are entirely based on loops, such as:\n• Problem solving using data structures like stack, queue, hash table, etc.\n\nThe efficiency of an algorithm that uses these approaches often depends on the loop structure and the operations within the loop.\n\nThere are two common loop patterns that often appear in our solutions:\n• Single loop: This can involve a loop that runs in constant time, a loop that runs n times, a loop that grows exponentially, a loop that runs based on a specific condition, a loop that runs with a data structure, consecutive single loops, etc.\n• Nested loops: This can involve two nested loops, three nested loops, a single loop with nested loops, etc.\n\nOne way to design a better algorithm or optimize the code further is to learn how to analyze the time complexity of loops using Big-O notation. This is not difficult to learn, and with some practice on various loop patterns, you will be able to make optimization decisions quickly, saving time in the analysis process.\n\nSteps to analyze the time complexity of the loop\n• Counting the total loop iteration in the worst case: We can get this insight by considering the worst-case scenario, initial and final value of the loop variable, loop condition, and increment or decrement operation. Most of the time, loop will be running for each data element or total input size.\n• Calculating the time complexity of the code in the loop body: The loop executes this code on each iteration. This code may contain conditional statements, comparison operations, swapping operations, assignment operations, etc.\n• The time complexity of loop = (Count of loop iterations in the worst case) * (Time complexity of the code in the loop body). We represent this in the form of Big-O notation by ignoring lower-order terms and coefficients.\n\nSometimes, we can also follow another simple approach:\n• Identify the most critical operation inside the loop, which executes the maximum number of times in the worst case. This critical operation would be the dominating factor in the time complexity function.\n• Now calculate the total count of this operation for the complete loop in terms of input size. Representing this expression in terms of Big-O notation will give the time complexity of the loop.\n\nLet’s analyze the time complexity of the various loop pattern.\n\nTime complexity analysis of a single for and while loop\n\nSingle for and while loop running constant times: O(1)\n\nHere loop is running constant times and performing O(1) operation at each iteration of the loop. Time complexity = c * O(1) = O(1) * O(1) = O(1).\n\nBest examples of such loops: Accessing an element in an array, Finding minimum value in the min-heap, Searching elements in the hash table [O(1) average], Finding median in a sorted array, swapping two variables, etc.\n\nSingle for loop running n times and incrementing or decrementing by a constant: O(n)\n\nHere both loops are running n times and performing O(1) operation at each iteration of the loop. Time complexity = n * O(1) = O(n) * O(1) = O(n).\n\nFor better understanding, You can explore the analysis of these coding problems\n\nSingle for and while loop running constant multiple of n times: O(n)\n\nHere loop is running cn times and performing O(1) operation at each iteration of the loop. Time complexity = cn * O(1) = O(n) * O(1) = O(n).\n\nTwo pointers single for and while loop: O(n)\n\nIn the above loop, based on some conditions, we are either incrementing l or decrementing r by one and performing an O(1) operation at each step of the iteration. Loop will run n times because l and r are starting from opposite ends and end when l > r. So time complexity = n*O(1) = O(n).\n\nFor better understanding, You can explore the analysis of two pointers solution to these coding problems\n• Check two arrays are subset or not\n\nA single for and while loop incrementing or decrementing by a constant factor: O(logn)\n\nHere loop is running in the range of 1 to n, and the loop variable increases or decreases by a factor of 2 at each step. So we need to count the total number of iterations performed by the loop to calculate the time complexity.\n\nLet’s assume the loop will terminate after k steps where the loop variable increases or decreases by a factor of 2. Then 2^k must be equal to the n i.e. 2^k = n and k = logn = O(logn).\n\nSo the loop will run O(logn) number of times and do O(1) operation at each step. Time complexity = k * O(1) = O(logn)* O(1) = O(logn).\n\nBest examples of such loop patterns: Iterative binary search, iterative approach to find the nth power of a number, exponential search, iterative approach to find the nth power of a matrix, etc.\n\nSingle for and while loop incrementing by some constant power: O(log(logn))\n\nHere, the loop is running in the range of 1 to n, but the loop variable increases by factor i power constant c. So, how do we calculate the total number of loop steps? Let’s think!\n• The first iteration of the loop is starting with i = 2.\n• At second iteration, value of i = 2^c.\n• At third iteration, value of i = (2^c)^c = 2^(c²).\n• And it will go so on till the end. At any ith iteration the value of i = 2^(c^i).\n\nSo loop will run logc(log(n)) number of times, where each iteration is taking O(1) time. So the overall time complexity = O(log(log(n))) * O(1) = O(log(log(n))).\n\nFor calculating such consecutive loops, we need to do the sum of the time complexities of each loop. So overall time complexity = Time complexity of loop 1 + Time complexity of loop 2 = O(m) + O(n) = O(m + n).\n\nFor better understanding, You can explore the analysis of these coding problems.\n• Product of array except self\n\nTime complexity analysis of the nested for and while loops\n\nThe time complexity of nested loops is equal to the number of times the innermost statement is executed.\n\nTwo nested for and while loops: O(n²)\n\nIn the above nested-loop example, the inner loop is running n times for every iteration of the outer loop. So total number of nested loop iteration = Total number of iteration of outer loop * Total number of iteration of inner loop = n * n = n² = O(n²).\n\nAt each step of the iteration, the nested loop is doing an O(1) operation. So overall time complexity = O(n²) * O(1) = O(n²).\n\nIn the above nested loop example, outer loop is running n times and for every iteration of the outer loop, inner loop is running (n — i) times. So total number of nested loop iteration = (n — 1) + (n — 2) + (n — 3)…..+ 2 + 1 = Sum of arithmatic series from i = 0 to n — 1 = n(n — 1)/2 = n²/2 — n/2 = O(n²).\n\nAt each step of the iteration, the nested loop is doing an O(1) operation. So overall time complexity = O(n²) * O(1) = O(n²).\n\nNote: It’s an exercise for you to analyze the following loop.\n\nFor better understanding, You can explore the analysis of iterative solution of these coding problems.\n\nWe need to do the sum of the time complexities of each loop. In such a case, the time complexity is dominated by the time complexity of the nested loop.\n\nTime complexity = Time complexity of loop 1 + Time complexity of loop 2 + Time complexity of loop 3 = O(n) + O(mn) + O(n) = O(mn).\n\nThree nested for and while loops: O(n³)\n\nAll three nested loops are running n times and doing O(1) operation at each iteration, so time complexity = n * n * n*O(1) = n³ * O(1) = O(n³)*O(1) = O(n³).\n\nIn the above three nested loop situations, the outer loop runs n — 1 time, but two inner loops run n — i and j — i + 1 time. So what would be the total count of the nested loop iterations? Let’s think.\n\nNow we solve this tripple summation by expanding the summation one by one.\n\nHigher-order term in T(n) is n³, then T(n) = O(n³). We are ignoring lower-order terms and coefficients. Note: There is one error in the third line of the above image. Instead of + i(n — i), it would be — i (n — i).\n\nExplore these coding problems to learn more about the time complexity analysis of for and while loops\n• Count the number of possible triangles\n• Check whether two strings are anagram or not\n• Check if two arrays are equal or not\n\nFor more content, you can explore our free DSA course and coding interview blogs.\n\nIf you have any queries/doubts/feedback, please write us at contact@enjoyalgorithms.com. Enjoy learning, Enjoy algorithms!"
    },
    {
        "link": "https://quora.com/For-a-for-loop-nested-inside-another-for-loop-is-the-time-complexity-always-of-O-n-2-If-not-please-give-examples-of-some-cases-that-violate-this",
        "document": "Something went wrong. Wait a moment and try again."
    }
]