[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/how-to",
        "document": "How to write .NET objects as JSON (serialize)\n\nThis article shows how to use the System.Text.Json namespace to serialize to JavaScript Object Notation (JSON). If you're porting existing code from , see How to migrate to .\n\nTo write JSON to a string or to a file, call the JsonSerializer.Serialize method.\n\nThe following example creates JSON as a string:\n\nThe JSON output is minified (whitespace, indentation, and new-line characters are removed) by default.\n\nThe following example uses synchronous code to create a JSON file:\n\nThe following example uses asynchronous code to create a JSON file:\n\nThe preceding examples use type inference for the type being serialized. An overload of takes a generic type parameter:\n\nYou can also use GitHub Copilot to generate serialization code for you. For instructions, see the Use GitHub Copilot section in this article.\n• By default, all public properties are serialized. You can specify properties to ignore. You can also include private members.\n• The default encoder escapes non-ASCII characters, HTML-sensitive characters within the ASCII-range, and characters that must be escaped according to the RFC 8259 JSON spec.\n• By default, JSON is minified. You can pretty-print the JSON.\n• By default, casing of JSON names matches the .NET names. You can customize JSON name casing.\n• By default, circular references are detected and exceptions thrown. You can preserve references and handle circular references.\n• By default, fields are ignored. You can include fields.\n\nWhen you use System.Text.Json indirectly in an ASP.NET Core app, some default behaviors are different. For more information, see Web defaults for JsonSerializerOptions.\n• None .NET primitives that map to JavaScript primitives, such as numeric types, strings, and Boolean.\n• None Collections and dictionaries from the following namespaces: For more information, see Supported types in System.Text.Json.\n\nYou can implement custom converters to handle additional types or to provide functionality that isn't supported by the built-in converters.\n\nHere's an example showing how a class that contains collection properties and a user-defined type is serialized:\n\nIt's 5-10% faster to serialize to a UTF-8 byte array than to use the string-based methods. That's because the bytes (as UTF-8) don't need to be converted to strings (UTF-16).\n\nTo serialize to a UTF-8 byte array, call the JsonSerializer.SerializeToUtf8Bytes method:\n\nA Serialize overload that takes a Utf8JsonWriter is also available.\n\nTo pretty-print the JSON output, set JsonSerializerOptions.WriteIndented to :\n\nStarting in .NET 9, you can also customize the indent character and size using IndentCharacter and IndentSize.\n\nUse GitHub Copilot to serialize to JSON\n\nYou can use GitHub Copilot in your IDE to generate code that uses to serialize to JSON. You can customize the prompt to use object fields that suit your requirements.\n\nThe following text shows an example prompt for Copilot Chat:\n\nGitHub Copilot is powered by AI, so surprises and mistakes are possible. For more information, see Copilot FAQs.\n\nLearn more about GitHub Copilot in Visual Studio and GitHub Copilot in VS Code."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/overview",
        "document": "The System.Text.Json namespace provides functionality for serializing to and deserializing from (or marshalling and unmarshalling) JavaScript Object Notation (JSON). Serialization is the process of converting the state of an object, that is, the values of its properties, into a form that can be stored or transmitted. The serialized form doesn't include any information about an object's associated methods. Deserialization reconstructs an object from the serialized form.\n\nThe library design emphasizes high performance and low memory allocation over an extensive feature set. Built-in UTF-8 support optimizes the process of reading and writing JSON text encoded as UTF-8, which is the most prevalent encoding for data on the web and files on disk.\n\nThe library also provides classes for working with an in-memory document object model (DOM). This feature enables random access to the elements in a JSON file or string.\n\nFor Visual Basic, there are some limitations on what parts of the library you can use. For more information, see Visual Basic support.\n\nHow to get the library\n\nThe library is built-in as part of the shared framework for .NET Core 3.0 and later versions. The source generation feature is built-in as part of the shared framework for .NET 6 and later versions.\n\nFor framework versions earlier than .NET Core 3.0, install the System.Text.Json NuGet package. The package supports:\n• The System.Text.Json namespace contains all the entry points and the main types.\n• The System.Text.Json.Serialization namespace contains attributes and APIs for advanced scenarios and customization specific to serialization and deserialization.\n• The System.Net.Http.Json namespace contains extension methods for serializing and deserializing JSON payloads from the network.\n\nBy default, gathers the metadata it needs to access properties of objects for serialization and deserialization at run time using reflection. As an alternative, can use the C# source generation feature to improve performance, reduce private memory usage, and facilitate assembly trimming, which reduces app size.\n\nFor more information, see Reflection versus source generation.\n\nFor information about security threats that were considered when designing JsonSerializer, and how they can be mitigated, see Threat Model.\n\nThe serializer was designed with thread safety in mind. Practically, this means that once locked, JsonSerializerOptions instances can be safely shared across multiple threads. JsonDocument provides an immutable, and in .NET 8 and later versions, thread-safe, DOM representation for JSON values.\n• How to use the library"
    },
    {
        "link": "https://nuget.org/packages/system.text.json",
        "document": "Provides high-performance and low-allocating types that serialize objects to JavaScript Object Notation (JSON) text and deserialize JSON text to objects, with UTF-8 support built-in. Also provides types to read and write JSON text encoded as UTF-8, and to create an in-memory document object model (DOM), that is read-only, for random access of the JSON elements within a structured view of the data.\n• A fully-featured JSON serializer for .NET types using reflection or source generated contracts.\n• A high-performance read-only JSON DOM (JsonDocument) and a mutable DOM that interoperates with the serializer (JsonNode).\n\nHow to Use\n\nThe System.Text.Json library is built-in as part of the shared framework in .NET Runtime. The package can be installed when you need to use the most recent version in older target frameworks.\n\nThe main types provided by this library are:\n\nSystem.Text.Json is released as open source under the MIT license. Bug reports and contributions are welcome at the GitHub repository."
    },
    {
        "link": "https://nuget.org/packages/System.Text.json",
        "document": "Provides high-performance and low-allocating types that serialize objects to JavaScript Object Notation (JSON) text and deserialize JSON text to objects, with UTF-8 support built-in. Also provides types to read and write JSON text encoded as UTF-8, and to create an in-memory document object model (DOM), that is read-only, for random access of the JSON elements within a structured view of the data.\n• A fully-featured JSON serializer for .NET types using reflection or source generated contracts.\n• A high-performance read-only JSON DOM (JsonDocument) and a mutable DOM that interoperates with the serializer (JsonNode).\n\nHow to Use\n\nThe System.Text.Json library is built-in as part of the shared framework in .NET Runtime. The package can be installed when you need to use the most recent version in older target frameworks.\n\nThe main types provided by this library are:\n\nSystem.Text.Json is released as open source under the MIT license. Bug reports and contributions are welcome at the GitHub repository."
    },
    {
        "link": "https://stackoverflow.com/questions/58331479/how-to-globally-set-default-options-for-system-text-json-jsonserializer",
        "document": "Instead of this:\n\nI would like to do something like this:\n\nThe hope is to not have to pass an instance of for our most common cases, and override for the exception, not the rule.\n\nAs indicated in this q & a, this is a useful feature of Json.Net. I looked in the documentation for as well as this GitHub repo for .NET Core. And this one.\n\nThere doesn't seem to be an analog for managing JSON serialization defaults in .NET Core 3. Or am I overlooking it?\n• None UPDATE [2020-07-18]: See this answer for a nuget package with convenience methods that honor default settings.\n• None UPDATE [2019-12-23]: Due in part to vocal community input this issue has been added to the roadmap for .NET 5.0.\n• None UPDATE [2019-10-10]: If interested in seeing this behavior implemented for head on over to the open GitHub issue pointed out by Chris Yungmann and weigh in."
    },
    {
        "link": "https://stackoverflow.com/questions/70066572/deserialize-json-to-object-with-a-dictionary-system-text-json",
        "document": "I am working on a .Net 6.0 project, and I want to migrate from Newtonsoft.Json to System.Text.Json. So far most is working, except the following:\n\nWhich I am trying to store into the following:\n\nWhen I am deserializing using Newtonsoft.JSON, the dictionary gets populated just fine with the values from\n\nbut when I try to use System.Text.Json, the dictionary stays empty\n\nHow can I use System.Text.Json and populate the dictionary?"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/deserialization",
        "document": "How to read JSON as .NET objects (deserialize)\n\nThis article shows how to use the System.Text.Json namespace to deserialize from JavaScript Object Notation (JSON). If you're porting existing code from , see How to migrate to .\n\nA common way to deserialize JSON is to have (or create) a .NET class with properties and fields that represent one or more of the JSON properties. Then, to deserialize from a string or a file, call the JsonSerializer.Deserialize method. For the generic overloads, the generic type parameter is the .NET class. For the non-generic overloads, you pass the type of the class as a method parameter. You can deserialize either synchronously or asynchronously.\n\nAny JSON properties that aren't represented in your class are ignored by default. Also, if any properties on the type are required but not present in the JSON payload, deserialization will fail.\n\nThe following example shows how to deserialize a JSON string:\n\nTo deserialize from a file by using synchronous code, read the file into a string, as shown in the following example:\n\nTo deserialize from a file by using asynchronous code, call the DeserializeAsync method:\n\nThe following behaviors apply when deserializing JSON:\n• By default, property name matching is case-sensitive. You can specify case-insensitivity.\n• Non-public constructors are ignored by the serializer.\n• Deserialization to immutable objects or properties that don't have public accessors is supported but not enabled by default. See Immutable types and records.\n• By default, enums are supported as numbers. You can deserialize string enum fields.\n• By default, fields are ignored. You can include fields.\n• By default, comments or trailing commas in the JSON throw exceptions. You can allow comments and trailing commas.\n\nWhen you use System.Text.Json indirectly in an ASP.NET Core app, some default behaviors are different. For more information, see Web defaults for JsonSerializerOptions.\n\nYou can implement custom converters to provide functionality that isn't supported by the built-in converters.\n\nIf you have JSON that you want to deserialize, and you don't have the class to deserialize it into, you have options other than manually creating the class that you need:\n• None Deserialize into a JSON DOM (document object model) and extract what you need from the DOM. The DOM lets you navigate to a subsection of a JSON payload and deserialize a single value, a custom type, or an array. For information about the JsonNode DOM, see Deserialize subsections of a JSON payload. For information about the JsonDocument DOM, see How to search a JsonDocument and JsonElement for sub-elements.\n• None Use Visual Studio 2022 to automatically generate the class you need:\n• Copy the JSON that you need to deserialize. The result is a class that you can use for your deserialization target.\n\nTo deserialize from UTF-8, call a JsonSerializer.Deserialize overload that takes a or a , as shown in the following examples. The examples assume the JSON is in a byte array named jsonUtf8Bytes.\n\nYou can use GitHub Copilot in your IDE to generate code that uses to deserialize from JSON. You can customize the prompt to use a JSON string with property names and values that suit your requirements.\n\nThe following text shows an example prompt for Copilot Chat:\n\nGitHub Copilot is powered by AI, so surprises and mistakes are possible. For more information, see Copilot FAQs.\n\nLearn more about GitHub Copilot in Visual Studio and GitHub Copilot in VS Code."
    },
    {
        "link": "https://stackoverflow.com/questions/1207731/how-can-i-deserialize-json-to-a-simple-dictionarystring-string-in-asp-net",
        "document": "Apparently neither of these JSON libraries have this forehead-slapping obvious capability out of the box--they are totally focused on reflection-based deserialization via strong contracts.\n\nI can use anything available in ASP.NET 3.5, as well as the popular Json.NET (which I'm already using for serialization to the client).\n\nI simply need a plain old Dictionary(Of String, String) , or some equivalent (hash table, Dictionary(Of String, Object), old-school StringDictionary--hell, a 2-D array of strings would work for me.\n\nI AM NOT TRYING TO DESERIALIZE INTO STRONGLY-TYPED .NET OBJECTS\n\nI have a simple key/value list in JSON being sent back to ASP.NET via POST. Example:\n\nI had the same problem, so I wrote this my self. This solution is differentiated from other answers because it can deserialize in to multiple levels. Just send JSON string in to deserializeToDictionary function it will return non strongly-typed object. private Dictionary<string, object> deserializeToDictionary(string jo) { var values = JsonConvert.DeserializeObject<Dictionary<string, object>>(jo); var values2 = new Dictionary<string, object>(); foreach (KeyValuePair<string, object> d in values) { // if (d.Value.GetType().FullName.Contains(\"Newtonsoft.Json.Linq.JObject\")) if (d.Value is JObject) { values2.Add(d.Key, deserializeToDictionary(d.Value.ToString())); } else { values2.Add(d.Key, d.Value); } } return values2; } Ex: This will return object of a Facebook JSON response. My old answer works great if there is no array on JSON string. This one further deserialize in to a if an element is an array. Just send a JSON string in to deserializeToDictionaryOrList function it will return non strongly-typed object or . private static object deserializeToDictionaryOrList(string jo,bool isArray=false) { if (!isArray) { isArray = jo.Substring(0, 1) == \"[\"; } if (!isArray) { var values = JsonConvert.DeserializeObject<Dictionary<string, object>>(jo); var values2 = new Dictionary<string, object>(); foreach (KeyValuePair<string, object> d in values) { if (d.Value is JObject) { values2.Add(d.Key, deserializeToDictionary(d.Value.ToString())); } else if (d.Value is JArray) { values2.Add(d.Key, deserializeToDictionary(d.Value.ToString(), true)); } else { values2.Add(d.Key, d.Value); } } return values2; }else { var values = JsonConvert.DeserializeObject<List<object>>(jo); var values2 = new List<object>(); foreach (var d in values) { if (d is JObject) { values2.Add(deserializeToDictionary(d.ToString())); } else if (d is JArray) { values2.Add(deserializeToDictionary(d.ToString(), true)); } else { values2.Add(d); } } return values2; } }\n\nIf you're after a lightweight, no-added-references kind of approach, maybe this bit of code I just wrote will work (I can't 100% guarantee robustness though). using System; using System.Collections.Generic; using System.Text; using System.Text.RegularExpressions; public Dictionary<string, object> ParseJSON(string json) { int end; return ParseJSON(json, 0, out end); } private Dictionary<string, object> ParseJSON(string json, int start, out int end) { Dictionary<string, object> dict = new Dictionary<string, object>(); bool escbegin = false; bool escend = false; bool inquotes = false; string key = null; int cend; StringBuilder sb = new StringBuilder(); Dictionary<string, object> child = null; List<object> arraylist = null; Regex regex = new Regex(@\"\\\\u([0-9a-z]{4})\", RegexOptions.IgnoreCase); int autoKey = 0; for (int i = start; i < json.Length; i++) { char c = json[i]; if (c == '\\\\') escbegin = !escbegin; if (!escbegin) { if (c == '\"') { inquotes = !inquotes; if (!inquotes && arraylist != null) { arraylist.Add(DecodeString(regex, sb.ToString())); sb.Length = 0; } continue; } if (!inquotes) { switch (c) { case '{': if (i != start) { child = ParseJSON(json, i, out cend); if (arraylist != null) arraylist.Add(child); else { dict.Add(key, child); key = null; } i = cend; } continue; case '}': end = i; if (key != null) { if (arraylist != null) dict.Add(key, arraylist); else dict.Add(key, DecodeString(regex, sb.ToString())); } return dict; case '[': arraylist = new List<object>(); continue; case ']': if (key == null) { key = \"array\" + autoKey.ToString(); autoKey++; } if (arraylist != null && sb.Length > 0) { arraylist.Add(sb.ToString()); sb.Length = 0; } dict.Add(key, arraylist); arraylist = null; key = null; continue; case ',': if (arraylist == null && key != null) { dict.Add(key, DecodeString(regex, sb.ToString())); key = null; sb.Length = 0; } if (arraylist != null && sb.Length > 0) { arraylist.Add(sb.ToString()); sb.Length = 0; } continue; case ':': key = DecodeString(regex, sb.ToString()); sb.Length = 0; continue; } } } sb.Append(c); if (escend) escbegin = false; if (escbegin) escend = true; else escend = false; } end = json.Length - 1; return dict; //theoretically shouldn't ever get here } private string DecodeString(Regex regex, string str) { return Regex.Unescape(regex.Replace(str, match => char.ConvertFromUtf32(Int32.Parse(match.Groups[1].Value, System.Globalization.NumberStyles.HexNumber)))); } [I realise that this violates the OP Limitation #1, but technically, you didn't write it, I did]\n\nEdit: This works, but the accepted answer using Json.NET is much more straightforward. Leaving this one in case someone needs BCL-only code. It’s not supported by the .NET framework out of the box. A glaring oversight – not everyone needs to deserialize into objects with named properties. So I ended up rolling my own: <Serializable()> Public Class StringStringDictionary Implements ISerializable Public dict As System.Collections.Generic.Dictionary(Of String, String) Public Sub New() dict = New System.Collections.Generic.Dictionary(Of String, String) End Sub Protected Sub New(info As SerializationInfo, _ context As StreamingContext) dict = New System.Collections.Generic.Dictionary(Of String, String) For Each entry As SerializationEntry In info dict.Add(entry.Name, DirectCast(entry.Value, String)) Next End Sub Public Sub GetObjectData(info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData For Each key As String in dict.Keys info.AddValue(key, dict.Item(key)) Next End Sub End Class public class StringStringDictionary : ISerializable { public System.Collections.Generic.Dictionary<string, string> dict; public StringStringDictionary() { dict = new System.Collections.Generic.Dictionary<string, string>(); } protected StringStringDictionary(SerializationInfo info, StreamingContext context) { dict = new System.Collections.Generic.Dictionary<string, string>(); foreach (SerializationEntry entry in info) dict.Add(entry.Name, (string)entry.Value); } public void GetObjectData(SerializationInfo info, StreamingContext context) { foreach (string key in dict.Keys) info.AddValue(key, dict[key]); } } string MyJsonString = \"{ \\\"key1\\\": \\\"value1\\\", \\\"key2\\\": \\\"value2\\\"}\"; System.Runtime.Serialization.Json.DataContractJsonSerializer dcjs = new System.Runtime.Serialization.Json.DataContractJsonSerializer( typeof(StringStringDictionary)); System.IO.MemoryStream ms = new System.IO.MemoryStream(Encoding.UTF8.GetBytes(MyJsonString)); StringStringDictionary myfields = (StringStringDictionary)dcjs.ReadObject(ms); Response.Write(\"Value of key2: \" + myfields.dict[\"key2\"]); Sorry for the mix of C# and VB.NET…\n\nI've added upon the code submitted by jSnake04 and Dasun herein. I've added code to create lists of objects from instances. It has two-way recursion but as it is functioning on a fixed, finite tree model, there is no risk of stack overflow unless the data is massive. /// <summary> /// Deserialize the given JSON string data (<paramref name=\"data\"/>) into a /// dictionary. /// </summary> /// <param name=\"data\">JSON string.</param> /// <returns>Deserialized dictionary.</returns> private IDictionary<string, object> DeserializeData(string data) { var values = JsonConvert.DeserializeObject<Dictionary<string, object>>(data); return DeserializeData(values); } /// <summary> /// Deserialize the given JSON object (<paramref name=\"data\"/>) into a dictionary. /// </summary> /// <param name=\"data\">JSON object.</param> /// <returns>Deserialized dictionary.</returns> private IDictionary<string, object> DeserializeData(JObject data) { var dict = data.ToObject<Dictionary<String, Object>>(); return DeserializeData(dict); } /// <summary> /// Deserialize any elements of the given data dictionary (<paramref name=\"data\"/>) /// that are JSON object or JSON arrays into dictionaries or lists respectively. /// </summary> /// <param name=\"data\">Data dictionary.</param> /// <returns>Deserialized dictionary.</returns> private IDictionary<string, object> DeserializeData(IDictionary<string, object> data) { foreach (var key in data.Keys.ToArray()) { var value = data[key]; if (value is JObject) data[key] = DeserializeData(value as JObject); if (value is JArray) data[key] = DeserializeData(value as JArray); } return data; } /// <summary> /// Deserialize the given JSON array (<paramref name=\"data\"/>) into a list. /// </summary> /// <param name=\"data\">Data dictionary.</param> /// <returns>Deserialized list.</returns> private IList<Object> DeserializeData(JArray data) { var list = data.ToObject<List<Object>>(); for (int i = 0; i < list.Count; i++) { var value = list[i]; if (value is JObject) list[i] = DeserializeData(value as JObject); if (value is JArray) list[i] = DeserializeData(value as JArray); } return list; }\n\nIt seems all of these answers here just assume you can get that little string out of a bigger object... for people looking to simply deserealize a large object with such a dictionary somewhere inside the mapping, and who are using the DataContract system, here's a solution: An answer on gis.stackexchange.com had this interesting link. I had to recover it with archive.org, but it offers a pretty much perfect solution: a custom class in which you implement exactly your own types. I was able to expand it easily. I made a bunch of changes in it, though. Since the original source is no longer available, I'll post the entire class here: using System; using System.CodeDom; using System.Collections.Generic; using System.Collections.ObjectModel; using System.IO; using System.Linq; using System.Reflection; using System.Runtime.Serialization; using System.Runtime.Serialization.Json; using System.Text; namespace JsonTools { /// <summary> /// Allows using Dictionary<String,String> and Dictionary<String,Boolean> types, and any others you'd like to add. /// Source: https://web.archive.org/web/20100317222656/my6solutions.com/post/2009/06/30/DataContractSerializer-DataContractJsonSerializer-JavaScriptSerializer-XmlSerializer-for-serialization.aspx /// </summary> public class JsonSurrogate : IDataContractSurrogate { /// <summary> /// Deserialize an object with added support for the types defined in this class. /// </summary> /// <typeparam name=\"T\">Contract class</typeparam> /// <param name=\"json\">JSON String</param> /// <param name=\"encoding\">Text encoding</param> /// <returns>The deserialized object of type T</returns> public static T Deserialize<T>(String json, Encoding encoding) { if (encoding == null) encoding = new UTF8Encoding(false); DataContractJsonSerializer deserializer = new DataContractJsonSerializer( typeof(T), new Type[0], int.MaxValue, true, new JsonSurrogate(), false); using (MemoryStream stream = new MemoryStream(encoding.GetBytes(json))) { T result = (T)deserializer.ReadObject(stream); return result; } } // make sure all values in this are classes implementing JsonSurrogateObject. private static Dictionary<Type, Type> KnownTypes = new Dictionary<Type, Type>() { {typeof(Dictionary<String, String>), typeof(SSDictionary)}, {typeof(Dictionary<String, Boolean>), typeof(SBDictionary)} }; #region Implemented surrogate dictionary classes [Serializable] public class SSDictionary : SurrogateDictionary<String> { public SSDictionary() : base() {} protected SSDictionary (SerializationInfo info, StreamingContext context) : base(info, context) {} } [Serializable] public class SBDictionary : SurrogateDictionary<Boolean> { public SBDictionary() : base() {} protected SBDictionary (SerializationInfo info, StreamingContext context) : base(info, context) {} } #endregion /// <summary>Small interface to easily extract the final value from the object.</summary> public interface JsonSurrogateObject { Object DeserializedObject { get; } } /// <summary> /// Class for deserializing any simple dictionary types with a string as key. /// </summary> /// <typeparam name=\"T\">Any simple type that will be deserialized correctly.</typeparam> [Serializable] public abstract class SurrogateDictionary<T> : ISerializable, JsonSurrogateObject { public Object DeserializedObject { get { return dict; } } private Dictionary<String, T> dict; public SurrogateDictionary() { dict = new Dictionary<String, T>(); } // deserialize protected SurrogateDictionary(SerializationInfo info, StreamingContext context) { dict = new Dictionary<String, T>(); foreach (SerializationEntry entry in info) { // This cast will only work for base types, of course. dict.Add(entry.Name, (T)entry.Value); } } // serialize public void GetObjectData(SerializationInfo info, StreamingContext context) { foreach (String key in dict.Keys) { info.AddValue(key, dict[key]); } } } /// <summary> /// Uses the KnownTypes dictionary to get the surrogate classes. /// </summary> /// <param name=\"type\"></param> /// <returns></returns> public Type GetDataContractType(Type type) { Type returnType; if (KnownTypes.TryGetValue(type, out returnType)) { return returnType; } return type; } public object GetObjectToSerialize(object obj, Type targetType) { throw new NotImplementedException(); } /// <summary> /// Gets the object out of the surrogate datacontract object. This function is the reason all surrogate objects need to implement the JsonSurrogateObject class. /// </summary> /// <param name=\"obj\">Result of the deserialization</param> /// <param name=\"targetType\">Expected target type of the deserialization</param> /// <returns></returns> public object GetDeserializedObject(object obj, Type targetType) { if (obj is JsonSurrogateObject) { return ((JsonSurrogateObject)obj).DeserializedObject; } return obj; } public Type GetReferencedTypeOnImport(string typeName, string typeNamespace, object customData) { return null; } #region not implemented public object GetCustomDataToExport(MemberInfo memberInfo, Type dataContractType) { throw new NotImplementedException(); } public object GetCustomDataToExport(Type clrType, Type dataContractType) { throw new NotImplementedException(); } public void GetKnownCustomDataTypes(Collection<Type> customDataTypes) { throw new NotImplementedException(); } public CodeTypeDeclaration ProcessImportedType(CodeTypeDeclaration typeDeclaration, CodeCompileUnit compileUnit) { throw new NotImplementedException(); } #endregion } } To add new supported types to the class, you just need to add your class, give it the right constructors and functions (look at for an example), make sure it inherits , and add its type mapping to the dictionary. The included SurrogateDictionary can serve as basis for any types where T is any type that does deserialize correctly. Calling it is really simple: Note that for some reason this thing has trouble using key strings which contain spaces; they were simply not present in the final list. Might just be it's simply against json specs and the api I was calling was poorly implemented, mind you; I dunno. Anyway, I solved this by regex-replacing them with underscores in the raw json data and fixing the dictionary after the deserialization.\n\nA bit late to the game, but non of the above solutions pointed me in the direction of a pure and simple .NET, no json.net solution. So here it is, ended up being very simple. Below a full running example of how it is done with standard .NET Json serialization, the example has dictionary both in the root object and in the child objects. The golden bullet is this cat, parse the settings as second parameter to the serializer: using System; using System.Collections.Generic; using System.Runtime.Serialization; using System.Runtime.Serialization.Json; namespace Kipon.dk { public class JsonTest { public const string EXAMPLE = @\"{ \"\"id\"\": \"\"some id\"\", \"\"children\"\": { \"\"f1\"\": { \"\"name\"\": \"\"name 1\"\", \"\"subs\"\": { \"\"1\"\": { \"\"name\"\": \"\"first sub\"\" }, \"\"2\"\": { \"\"name\"\": \"\"second sub\"\" } } }, \"\"f2\"\": { \"\"name\"\": \"\"name 2\"\", \"\"subs\"\": { \"\"37\"\": { \"\"name\"\": \"\"is 37 in key\"\"} } } } } \"; [DataContract] public class Root { [DataMember(Name =\"id\")] public string Id { get; set; } [DataMember(Name = \"children\")] public Dictionary<string,Child> Children { get; set; } } [DataContract] public class Child { [DataMember(Name = \"name\")] public string Name { get; set; } [DataMember(Name = \"subs\")] public Dictionary<int, Sub> Subs { get; set; } } [DataContract] public class Sub { [DataMember(Name = \"name\")] public string Name { get; set; } } public static void Test() { var array = System.Text.Encoding.UTF8.GetBytes(EXAMPLE); using (var mem = new System.IO.MemoryStream(array)) { mem.Seek(0, System.IO.SeekOrigin.Begin); DataContractJsonSerializerSettings settings = new DataContractJsonSerializerSettings(); settings.UseSimpleDictionaryFormat = true; var ser = new DataContractJsonSerializer(typeof(Root), settings); var data = (Root)ser.ReadObject(mem); Console.WriteLine(data.Id); foreach (var childKey in data.Children.Keys) { var child = data.Children[childKey]; Console.WriteLine(\" Child: \" + childKey + \" \" + child.Name); foreach (var subKey in child.Subs.Keys) { var sub = child.Subs[subKey]; Console.WriteLine(\" Sub: \" + subKey + \" \" + sub.Name); } } } } } }\n\nAnnoyingly enough, if you want to use the default model binders, it looks like you will have to use numerical index values like a form POST. See the following excerpt from this article http://msdn.microsoft.com/en-us/magazine/hh781022.aspx: Though it’s somewhat counterintuitive, JSON requests have the same requirements—they, too, must adhere to the form post naming syntax. Take, for example, the JSON payload for the previous UnitPrice collection. The pure JSON array syntax for this data would be represented as: However, the default value providers and model binders require the data to be represented as a JSON form post: The complex object collection scenario is perhaps one of the most widely problematic scenarios that developers run into because the syntax isn’t necessarily evident to all developers. However, once you learn the relatively simple syntax for posting complex collections, these scenarios become much easier to deal with."
    },
    {
        "link": "https://dev.to/thebuzzsaw/converting-dictionaries-in-system-text-json-474b",
        "document": "Like many out there, I'm a long-time consumer of . It's simple and powerful, so it surprised me to learn that .NET Core 3 would be introducing its own JSON library. What surprised me more was learning that the man behind himself would be involved with designing this new library. This new library, , was built with a specific purpose in mind: performance with JSON-related functionality in ASP.NET Core. It promises reduced allocations and higher throughput.\n\nThe design of this new library is somewhat off-putting for many. Right out of the gate, I wondered what happened to , , and . They're just... gone... with no real replacement. The new library has , but it's largely a read-only component. It is only created as part of a large parse operation; I can't just create JSON things and glue them together like I could with Newtonsoft.\n\nI spent more time with it and slowly grew accustomed to its design philosophy. I no longer miss because it was a thin wrapper over things I already have in .NET anyway. What is a JSON object really? It's just a .\n\n\n\nCool. Simple enough. I can also serialize custom objects with arbitrary properties to accomplish the same things. With this in mind, I kind of see the old Newtonsoft classes as crutches more than anything else. They offer feel-good measures for directly crafting JSON objects and arrays. (And I'm not faulting anyone for sticking with that paradigm. It's pretty easy to read.)\n\nHowever, I was caught off guard when I went to deserialize a dictionary.\n\n\n\nThis code here throws a . It points out that having a non-string for the is simply unacceptable. This... is a problem. I work with extensively (at home and at work) and often use it as a dictionary key. I'm generally not OK with having to convert JSON to a string dictionary first and then to a non-string dictionary as a second step. It seems I am not alone in experiencing frustration at this.\n\nHowever, as much as I love to sit and complain about others' hard work, I decided to just do something about it. The documentation for creating your own JSON converters is pretty good. So, I set out to make my own, and I am pleased with the result so far. Now I can do this:\n\n\n\nBack in business! If you are interested in my implementation, the code is all here with a small explanation here. It's public domain. Knock yourself out."
    },
    {
        "link": "https://code-maze.com/csharp-deserialize-json-into-dynamic-object",
        "document": "In this article, we are going to learn how to deserialize JSON into a dynamic object in C#.\n\nJSON deserialization in C# refers to the process of forming .NET objects from a JSON string. Most of the time, this means creating strongly-typed POCOs. However, there are certain situations when we may prefer flexibility over type inference. For example, cherry-picking a small portion of JSON data, dealing with external JSON data whose structure is largely unknown or changes very often, etc. Dynamic deserialization comes into play in such cases. This does not necessarily mean the use of the language’s inbuilt keyword. There are other ways as well.\n\nWe are going to see how we can do this using the native System.Text.Json library and the popular library.\n\nVIDEO: How to Deserialize JSON Into Dynamic Object in C#.\n\nLet’s assume we have to extract genre and rating information from movie-stats data coming as a JSON string:\n\nFrom the stats of movie, we only want to cherry-pick “Genre” and rating of “IMDb” or “Rotten Tomatoes”.\n\nWe have three path-ways to achieve this:\n\nFirst of all, we want to explore the way. Newtonsoft library is quite convenient in this regard having long-time support for . On the other hand, the native library has a different story, and we will discuss it later.\n\nSo, let’s start with the Newtonsoft library.\n\nWe are going to add a helper class in our class library project that holds our first deserialization routine:\n\nLike always we use the class for the deserialization. A call to the method gives us a plain instance.\n\nUnder the hood, this object holds all the properties from the JSON tree. Because of declaration, we can directly access and properties from there. We can even access the nested property in a natural way. Even more, if we can’t directly access a JSON property by its name due to incompatibility with C# property-name like “Rotten Tomatoes”, we can access it as a dictionary item. Pretty convenient, right?\n\nAs a side note, we use the null-forgiving operator (!) here to keep syntax clean and short. We will continue using it in this article where relevant. However, you should be cautious about using this in a real application.\n\nOnce we apply this helper method on :\n\nWe get the result we desire. This is the most popular and widely used way for dynamic deserialization with Newtonsoft.\n\nPretty often a object corresponds to an of namespace:\n\nSimilar to the version, we can invoke the method with type argument.\n\nThe subsequent section resembles the previous routine until we hit the “Rotten Tomatoes” part. For this part, we need to cast its parent object ( ) to a dictionary. This allows us to retrieve the value of “Rotten Tomatoes” by key. It’s a bit inconvenient way but worth the effort if you’re a big fan of .\n\nUsing dynamic With System.Text.Json to Deserialize JSON Into a Dynamic Object\n\nNow is the time to go with the native library.\n\nIn the legacy ASP.NET MVC application, we would get a when using with the native deserializer class: . That was not a true thing of course, but surely offered a bit of flexibility in managing.\n\nHowever, the flexibility of comes at the price of performance. That’s why the .NET team set aside the design considerations of as they want this to come out as a high-performant library. And that’s not the only thing. is currently flagged as an “archived component”. That means it will not evolve with the latest language features for the time being. Check out this thread for more details.\n\nSo, we’re not getting support in the native JSON library in near future. That said, the deserializer does not complain if we use anyway:\n\nAs we see, we can form a object using the method. However, this object does not recognize the or property and throws an error if we try. Because, under the hood, this is a boxed , a type that is the building block of native JSON DOM. So, we don’t have the convenience to use it in a truly way.\n\nIn short, using with the native deserializer has no added benefit and results in a JSON DOM which has its own API to deal with.\n\nAnother convenient way of deserialization with Newtonsoft is to use the anonymous object:\n\nOnce again, we come up with an elegant solution in a few simple steps. We call the method along with an anonymous object. This anonymous object essentially needs to be a blueprint of our target JSON graph. That’s why we specify the property with an initial value of an empty . Similarly, we specify and initialize the nested property as . That does the trick!\n\nThe resulting object holds the target JSON data as we want. From there, we can access the and properties in a strongly-typed way!\n\nIf we want to get the value of “Rotten Tomatoes”, we can do that too:\n\nAgain, we just need to hint at the deserializer that is a dictionary. From there, we can easily pick the values by key.\n\nIn the case of the native library, we don’t have any direct method for the anonymous type. But, we can implement it on our own:\n\nThis is a bit tricky part. We prepare a generic method that works on type inference. Since we aim to call this method anonymously i.e. without specifying the generic type argument, we need a parameter that infers the type during invocation. That’s the role the parameter plays here. The rest is nothing but calling the usual deserializing method.\n\nWith this helper method, we can work the same way as the Newtonsoft version:\n\nBoth native and Newtonsoft library offers strong DOM API to retrieve data from JSON string on demand. Both of them has several DOM classes that work in pair and can be alternatively used. For example, the native library provides combinations for readonly DOM and pair for mutable DOM. Newtonsoft similarly uses .\n\nFirst, let’s talk about our already familiar type . We are going to implement a helper method in the native version of the class:\n\nWe simply deserialize to as we do for POCO. All we get here is a DOM tree of nodes – each node representing the corresponding node of JSON data structure.\n\nNext, we call our helper method that retrieves , , and traversing down the DOM tree.\n\nInside this method, we use the method of . This method looks for a descendant node by name. We find the node in the first layer of descendants. Similarly, we reach the node in the second layer by chain invocations of method. The same goes for the node. On reaching each node, we can obtain the value according to the target data type e.g. for string value, for double value, etc. That’s it.\n\nThough we can use the usual method, we go for a slightly faster alternative: method. Since is disposable we also declare a block. Subsequently, we pass the (an instance of ) to the method for the final output.\n\nAs mentioned before, the native library provides another set of DOM classes . They’re a bit slower but more convenient than their counterparts:\n\nHere, the deserialization part is nothing special. But the data retrieval part is quite interesting. We can access all the data in a nice chain of index notations!\n\nOur example is for , but it also applies to – you can see it for yourself in our source code.\n\nNewtonsoft also provides a similar elegant API with their DOM classes:\n\nThis is no different than the native version except for the deserialization part. We can also use in place of .\n\nHere, we leverage the power of JSON Path/Query API using the method. This is particularly useful if we want to cherry-pick data based on the value of some other node of the tree.\n\nOverall, Newtonsoft is quite feature-rich in all aspects of dynamic JSON deserialization as compared to .\n\nWe now have a few variants of dynamic deserialization routines. It’s time for benchmarking these methods. We’re going to use a bigger JSON data source for this purpose.\n\nOnce we run the benchmark, we can inspect the result:\n\nWe can see that the native library is way faster than Newtonsoft variants, especially when using the readonly DOM. Another important thing is that we should avoid using ExpandoObject for such purposes.\n\nIn this article, we have explored a few ways to deserialize JSON into a dynamic object. In the end, our performance analysis shows that performs better than in general."
    }
]