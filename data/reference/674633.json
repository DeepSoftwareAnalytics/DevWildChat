[
    {
        "link": "https://docs.unity3d.com/2023.1/Documentation/Manual/class-Rigidbody2D.html",
        "document": "You can attach a Rigidbody 2D component to a GameObjectThe fundamental object in Unity scenes, which can represent characters, props, scenery, cameras, waypoints, and more. A GameObject’s functionality is defined by the Components attached to it. More info\n\nSee in Glossary to control it with the physics system. The Rigidbody 2D shares similar properties with its standard RigidbodyA component that allows a GameObject to be affected by simulated gravity and other forces. More info\n\nSee in Glossary counterpart, but it’s adapted to 2D development. For example, GameObjects that have a Rigidbody 2D component attached to them can only move along the XY plane and can only rotate on an axis perpendicular to that plane.\n\nThe Unity Editor’s Transform component defines how to position, rotate, and scale a GameObject (and its child GameObjects) within the SceneA Scene contains the environments and menus of your game. Think of each unique Scene file as a unique level. In each Scene, you place your environments, obstacles, and decorations, essentially designing and building your game in pieces. More info\n\nSee in Glossary. When you change this component, it updates other components which can affect where they render or the position of other collidersAn invisible shape that is used to handle physical collisions for an object. A collider doesn’t need to be exactly the same shape as the object’s mesh - a rough approximation is often more efficient and indistinguishable in gameplay. More info\n\nSee in Glossary. Unity’s 2D physics system can move colliders and make them interact with each other, so Unity requires a method for the physics system to communicate this movement of colliders back to the Transform components. This movement and connection with colliders is what a Rigidbody 2D component is for. The Rigidbody 2D component overrides the Transform componentA Transform component determines the Position, Rotation, and Scale of each object in the scene. Every GameObject has a Transform. More info\n\nSee in Glossary and updates it to the position and/or rotation it defines instead.\n\nNote: You can override the Rigidbody 2D by directly modifying the Transform component yourself (because Unity exposes all properties on all components). However, this will cause issues such as unpredictable movement or GameObjects passing through and into each other.\n\nAny Collider 2D component added to the same GameObject or child GameObject is implicitly attached to that Rigidbody 2D GameObject, causing the Collider 2D to move with the Rigidbody 2D. When attached, you should never move the Collider 2D directly using the Transform or any collider offset; move the Rigidbody 2D instead. Moving the Rigidbody 2D provides the best performance and ensures correct collisionA collision occurs when the physics engine detects that the colliders of two GameObjects make contact or overlap, when at least one has a Rigidbody component and is in motion. More info\n\nSee in Glossary detection. Collider 2Ds attached to the same Rigidbody 2D won’t collide with each other. This means you can create a set of colliders that act effectively as a single compound collider, all moving and rotating in sync with the Rigidbody 2D.\n\nAdding a Rigidbody 2D moves a spriteA 2D graphic objects. If you are used to working in 3D, Sprites are essentially just standard textures but there are special techniques for combining and managing sprite textures for efficiency and convenience during development. More info\n\nSee in Glossary in a physically convincing way by applying forces from the scripting API. When you attach the appropriate collider component to the sprite GameObject, it’s affected by collisions with other moving GameObjects. Using the Unity physics system can simplify many common gameplay mechanics and portray realistic behavior with minimal coding.\n\nNote: Although Rigidbody 2Ds are often described as colliding with each other, it’s the Collider 2Ds attached to each of those bodies which collide. Rigidbody 2Ds can’t collide with each other without Colliders."
    },
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/Manual/2d-physics/rigidbody/introduction-to-rigidbody-2d.html",
        "document": "You can attach a Rigidbody 2D component to a GameObjectThe fundamental object in Unity scenes, which can represent characters, props, scenery, cameras, waypoints, and more. A GameObject’s functionality is defined by the Components attached to it. More info\n\nSee in Glossary to control it with the physics system. The Rigidbody 2D shares similar properties with its standard RigidbodyA component that allows a GameObject to be affected by simulated gravity and other forces. More info\n\nSee in Glossary counterpart, but it’s adapted to 2D development. For example, GameObjects that have a Rigidbody 2D component attached to them can only move along the XY plane and can only rotate on an axis perpendicular to that plane.\n\nThe Unity Editor’s Transform component defines how to position, rotate, and scale a GameObject (and its child GameObjects) within the SceneA Scene contains the environments and menus of your game. Think of each unique Scene file as a unique level. In each Scene, you place your environments, obstacles, and decorations, essentially designing and building your game in pieces. More info\n\nSee in Glossary. When you change this component, it updates other components which can affect where they render or the position of other collidersAn invisible shape that is used to handle physical collisions for an object. A collider doesn’t need to be exactly the same shape as the object’s mesh - a rough approximation is often more efficient and indistinguishable in gameplay. More info\n\nSee in Glossary. Unity’s 2D physics system can move colliders and make them interact with each other, so Unity requires a method for the physics system to communicate this movement of colliders back to the Transform components. This movement and connection with colliders is what a Rigidbody 2D component is for. The Rigidbody 2D component overrides the Transform componentA Transform component determines the Position, Rotation, and Scale of each object in the scene. Every GameObject has a Transform. More info\n\nSee in Glossary and updates it to the position and/or rotation it defines instead.\n\nNote: You can override the Rigidbody 2D by directly modifying the Transform component yourself (because Unity exposes all properties on all components). However, this will cause issues such as unpredictable movement or GameObjects passing through and into each other.\n\nAny Collider 2D component added to the same GameObject or child GameObject is implicitly attached to that Rigidbody 2D GameObject, causing the Collider 2D to move with the Rigidbody 2D. When attached, you should never move the Collider 2D directly using the Transform or any collider offset; move the Rigidbody 2D instead. Moving the Rigidbody 2D provides the best performance and ensures correct collisionA collision occurs when the physics engine detects that the colliders of two GameObjects make contact or overlap, when at least one has a Rigidbody component and is in motion. More info\n\nSee in Glossary detection. Collider 2Ds attached to the same Rigidbody 2D won’t collide with each other. This means you can create a set of colliders that act effectively as a single compound collider, all moving and rotating in sync with the Rigidbody 2D.\n\nAdding a Rigidbody 2D moves a spriteA 2D graphic objects. If you are used to working in 3D, Sprites are essentially just standard textures but there are special techniques for combining and managing sprite textures for efficiency and convenience during development. More info\n\nSee in Glossary in a physically convincing way by applying forces from the scripting API. When you attach the appropriate collider component to the sprite GameObject, it’s affected by collisions with other moving GameObjects. Using the Unity physics system can simplify many common gameplay mechanics and portray realistic behavior with minimal coding.\n\nNote: Although Rigidbody 2Ds are often described as colliding with each other, it’s the Collider 2Ds attached to each of those bodies which collide. Rigidbody 2Ds can’t collide with each other without Colliders."
    },
    {
        "link": "https://docs.unity.cn/560/Documentation/Manual/class-Rigidbody2D.html",
        "document": "A Rigidbody 2D component places an object under the control of the physics engine. Many concepts familiar from the standard Rigidbody component carry over to Rigidbody 2D; the differences are that in 2D, objects can only move in the XY plane and can only rotate on an axis perpendicular to that plane.\n\nUsually, the Unity Editor’s Transform component defines how a GameObject (and its child GameObjects) is positioned, rotated and scaled within the Scene. When it is changed, it updates other components, which may update things like where they render or where colliders are positioned. The 2D physics engine is able to move colliders and make them interact with each other, so a method is required for the physics engine to communicate this movement of colliders back to the Transform components. This movement and connection with colliders is what a Rigidbody 2D component is for.\n\nThe Rigidbody 2D component overrides the Transform and updates it to a position/rotation defined by the Rigidbody 2D. Note that while you can still override the Rigidbody 2D by modifying the Transform component yourself (because Unity exposes all properties on all components), doing so will cause problems such as GameObjects passing through or into each other, and unpredictable movement.\n\nAny Collider 2D component added to the same GameObject or child GameObject is implicitly attached to that Rigidbody 2D. When a Collider 2D is attached to the Rigidbody 2D, it moves with it. A Collider 2D should never be moved directly using the Transform or any collider offset; the Rigidbody 2D should be moved instead. This offers the best performance and ensures correct collision detection. Collider 2Ds attached to the same Rigidbody 2D won’t collide with each other. This means you can create a set of colliders that act effectively as a single compound collider, all moving and rotating in sync with the Rigidbody 2D.\n\nWhen designing a Scene, you are free to use a default Rigidbody 2D and start attaching colliders. These colliders allow any other colliders attached to different Rigidbody 2Ds to collide with each other.\n\nAdding a Rigidbody 2D allows a sprite to move in a physically convincing way by applying forces from the scripting API. When the appropriate collider component is also attached to the sprite GameObject, it is affected by collisions with other moving GameObjects. Using physics simplifies many common gameplay mechanics and allows for realistic behavior with minimal coding.\n\nThe Rigidbody 2D component has a setting at the top labelled Body Type. The option you choose for this affects the other settings available on the component.\n\nThere are three options for Body Type; each defines a common and fixed behavior. Any Collider 2D attached to a Rigidbody 2D inherits the Rigidbody 2D’s Body Type. The three options are:\n\nNote that although Rigidbody 2Ds are often described as colliding with each other, it is the Collider 2Ds attached to each of those bodies which collide. Rigidbody 2Ds cannot collide with each other without colliders.\n\nChanging the Body Type of a Rigidbody 2D can be a tricky process. When a Body Type changes, various mass-related internal properties are recalculated immediately, and all existing contacts for the Collider 2Ds attached to the Rigidbody 2D need to be re-evaluated during the GameObject’s next FixedUpdate. Depending on how many contacts and Collider 2Ds are attached to the body, changing the Body Type can cause variations in performance.\n\nA Dynamic Rigidbody 2D is designed to move under simulation. It has the full set of properties available to it such as finite mass and drag, and is affected by gravity and forces. A Dynamic body will collide with every other body type, and is the most interactive of body types. This is the default body type for a Rigidbody 2D, because it is the most common body type for things that need to move. It’s also the most performance-expensive body type, because of its dynamic nature and interactivity with everything around it. All Rigidbody 2D properties are available with this body type.\n\nDo not use the Transform component to set the position or rotation of a Dynamic Rigidbody 2D. The simulation repositions a Dynamic Rigidbody 2D according to its velocity; you can change this directly via forces applied to it by scripts, or indirectly via collisions and gravity.\n\nA Kinematic Rigidbody 2D is designed to move under simulation, but only under very explicit user control. While a Dynamic Rigidbody 2D is affected by gravity and forces, a Kinematic Rigidbody 2D isn’t. For this reason, it is fast and has a lower demand on system resources than a Dynamic Rigidbody 2D. Kinematic Rigidbody 2D is designed to be repositioned explicitly via Rigidbody2D.MovePosition or Rigidbody2D.MoveRotation. Use physics queries to detect collisions, and scripts to decide where and how the Rigidbody 2D should move.\n\nA Kinematic Rigidbody 2D does still move via its velocity, but the velocity is not affected by forces or gravity. A Kinematic Rigidbody 2D does not collide with other Kinematic Rigidbody 2Ds or with Static Rigidbody 2Ds; it only collides with Dynamic Rigidbody 2Ds. Similar to a Static Rigidbody 2D (see below), a Kinematic Rigidbody 2D behaves like an immovable object (as if it has infinite mass) during collisions. Mass-related properties are not available with this Body Type.\n\nA Static Rigidbody 2D is designed to not move under simulation at all; if anything collides with it, a Static Rigidbody 2D behaves like an immovable object (as though it has infinite mass). It is also the least resource-intensive body type to use. A Static body only collides with Dynamic Rigidbody 2Ds. Having two Static Rigidbody 2Ds collide is not supported, since they are not designed to move.\n\nOnly a very limited set of properties are available for this Body Type.\n\nThere are two ways to mark a Rigidbody 2D as Static:\n• None For the GameObject with the Collider 2D component not to have a Rigidbody 2D component at all. All such Collider 2Ds are internally considered to be attached to a single hidden Static Rigidbody 2D component.\n• None For the GameObject to have a Rigidbody 2D and for that Rigidbody 2D to be set to Static.\n\nMethod 1 is a shorthand for making Static Collider 2Ds. When creating large numbers of Static Collider 2Ds, it is easier not to have to add a Rigidbody 2D for each GameObject with a Collider 2D.\n\nMethod 2 exists for performance reasons. If a Static Collider 2D needs to be moved or reconfigured at run time, it is faster to do so when it has its own Rigidbody 2D. If a group of Collider 2Ds needs to be moved or reconfigured at run time, it is faster to have them all be children of one parent Rigidbody 2D marked as Static than to move each GameObject individually.\n\nNote: As stated above, Static Rigidbody 2Ds are designed not to move, and collisions between two Static Rigidbody 2D objects that intersect are not registered. However, Static Rigidbody 2Ds and Kinematic Rigidbody 2Ds will interact with each other if one of their Collider 2Ds is set to be a trigger. There is also a feature that changes what a Kinematic body will interact with (see Use Full Kinematic Contacts, below).\n\nUse the Simulated property to stop (unchecked) and start (checked) a Rigidbody 2D and any attached Collider 2Ds and Joint 2Ds from interacting with the 2D physics simulation. Changing this property is much more memory and processor-efficient than enabling or disabling individual Collider 2D and Joint 2D components.\n\nWhen the Simulation box is checked, the following occurs:\n• The Rigidbody 2D moves via the simulation (gravity and physics forces are applied)\n• Any attached Collider 2Ds continue creating new contacts and continuously re-evaluate contacts\n• Any attached Joint 2Ds are simulated and constrain the attached Rigidbody 2D\n• All internal physics objects for Rigidbody 2D, Collider 2D & Joint 2D stay in memory\n\nWhen the Simulated box is unchecked, the following occurs:\n• The Rigidbody 2D is not moved by the simulation (gravity and physics forces are not applied)\n• The Rigidbody 2D does not create new contacts, and any attached Collider 2D contacts are destroyed\n• Any attached Joint 2Ds are not simulated, and do not constrain any attached Rigidbody 2Ds\n• All internal physics objects for Rigidbody 2D, Collider 2D and Joint 2D are left in memory\n\nWhy is unchecking Simulated more efficient than individual component controls?\n\nIn the 2D physics simulation, a Rigidbody 2D component controls the position and rotation of attached Collider 2D components, and allows Joint 2D components to use these positions and rotations as anchor points. A Collider 2D moves when the Rigidbody 2D it is attached to moves. The Collider 2D then calculates contacts with other Collider 2Ds attached to other Rigidbody 2Ds. Joint 2Ds also constrain Rigidbody 2D positions and rotations. All of this takes simulation time.\n\nYou can stop and start individual elements of the 2D physics simulation by enabling and disabling components individually. You can do this on both Collider 2D and Joint 2D components. However, enabling and disabling individual elements of the physics simulations has memory use and processor power costs. When elements of the simulation are disabled, the 2D physics engine doesn’t produce any internal physics-based objects to simulate. When elements of the simulation are enabled, the 2D physics engine does have internal physics-based objects to simulate. Enabling and disabling of 2D physics simulation components means internal GameObjects and physics-based components have to be created and destroyed; disabling the simulation is easier and more efficient than disabling individual components.\n\nNOTE: When a Rigidbody 2D’s Simulated option is unchecked, any attached Collider 2D is effectively ‘invisible’, that is; it cannot be detected by any physics queries, such as Physics.Raycast.\n\nEnable this setting (check the checkbox) if you want the Kinematic Rigidbody 2D to collide with all Rigidbody 2D Body Types. This is similar to a Dynamic Rigidbody 2D, except the Kinematic Rigidbody 2D is not moved by the physics engine when contacting another Rigidbody 2D; it acts as an immovable object, with infinite mass.\n\nWhen this setting is disabled (unchecked), a Kinematic Rigidbody 2D only collides with Dynamic Rigidbody 2Ds; it does not collide with other Kinematic Rigidbody 2Ds or Static Rigidbody 2Ds (note that trigger colliders are an exception to this rule). This means that no collision scripting callbacks (OnCollisionEnter, OnCollisionStay, OnCollisionExit) occur.\n\nThis can be inconvenient when you are using physics queries (such as Physics.Raycast) to detect where and how a Rigidbody 2D should move, and when you require multiple Kinematic Rigidbody 2Ds to interact with each other. Enable Use Full Kinematic Contacts to make Kinematic Rigidbody 2D components interact in this way.\n\nUse Full Kinematic Contacts allows explicit position and rotation control of a Kinematic Rigidbody 2D, but still allows full collision callbacks. In a set-up where you need explicit control of all Rigidbody 2Ds, use Kinematic Rigidbody 2Ds in place of Dynamic Rigidbody 2Ds to still have full collision callback support."
    },
    {
        "link": "https://docs.unity.cn/550/Documentation/Manual/class-Rigidbody2D.html",
        "document": "A Rigidbody 2D component places an object under the control of the physics engine. Many concepts familiar from the standard Rigidbody component carry over to Rigidbody 2D; the differences are that in 2D, objects can only move in the XY plane and can only rotate on an axis perpendicular to that plane.\n\nUsually, the Unity Editor’s Transform component defines how a GameObject (and its child GameObjects) is positioned, rotated and scaled within the Scene. When it is changed, it updates other components, which may update things like where they render or where colliders are positioned. The 2D physics engine is able to move colliders and make them interact with each other, so a method is required for the physics engine to communicate this movement of colliders back to the Transform components. This movement and connection with colliders is what a Rigidbody 2D component is for.\n\nThe Rigidbody 2D component overrides the Transform and updates it to a position/rotation defined by the Rigidbody 2D. Note that while you can still override the Rigidbody 2D by modifying the Transform component yourself (because Unity exposes all properties on all components), doing so will cause problems such as GameObjects passing through or into each other, and unpredictable movement.\n\nAny Collider 2D component added to the same GameObject or child GameObject is implicitly attached to that Rigidbody 2D. When a Collider 2D is attached to the Rigidbody 2D, it moves with it. A Collider 2D should never be moved directly using the Transform or any collider offset; the Rigidbody 2D should be moved instead. This offers the best performance and ensures correct collision detection. Collider 2Ds attached to the same Rigidbody 2D won’t collide with each other. This means you can create a set of colliders that act effectively as a single compound collider, all moving and rotating in sync with the Rigidbody 2D.\n\nWhen designing a Scene, you are free to use a default Rigidbody 2D and start attaching colliders. These colliders allow any other colliders attached to different Rigidbody 2Ds to collide with each other.\n\nAdding a Rigidbody 2D allows a sprite to move in a physically convincing way by applying forces from the scripting API. When the appropriate collider component is also attached to the sprite GameObject, it is affected by collisions with other moving GameObjects. Using physics simplifies many common gameplay mechanics and allows for realistic behavior with minimal coding.\n\nThe Rigidbody 2D component has a setting at the top labelled Body Type. The option you choose for this affects the other settings available on the component.\n\nThere are three options for Body Type; each defines a common and fixed behavior. Any Collider 2D attached to a Rigidbody 2D inherits the Rigidbody 2D’s Body Type. The three options are:\n\nNote that although Rigidbody 2Ds are often described as colliding with each other, it is the Collider 2Ds attached to each of those bodies which collide. Rigidbody 2Ds cannot collide with each other without colliders.\n\nChanging the Body Type of a Rigidbody 2D can be a tricky process. When a Body Type changes, various mass-related internal properties are recalculated immediately, and all existing contacts for the Collider 2Ds attached to the Rigidbody 2D need to be re-evaluated during the GameObject’s next FixedUpdate. Depending on how many contacts and Collider 2Ds are attached to the body, changing the Body Type can cause variations in performance.\n\nA Dynamic Rigidbody 2D is designed to move under simulation. It has the full set of properties available to it such as finite mass and drag, and is affected by gravity and forces. A Dynamic body will collide with every other body type, and is the most interactive of body types. This is the default body type for a Rigidbody 2D, because it is the most common body type for things that need to move. It’s also the most performance-expensive body type, because of its dynamic nature and interactivity with everything around it. All Rigidbody 2D properties are available with this body type.\n\nDo not use the Transform component to set the position or rotation of a Dynamic Rigidbody 2D. The simulation repositions a Dynamic Rigidbody 2D according to its velocity; you can change this directly via forces applied to it by scripts, or indirectly via collisions and gravity.\n\nA Kinematic Rigidbody 2D is designed to move under simulation, but only under very explicit user control. While a Dynamic Rigidbody 2D is affected by gravity and forces, a Kinematic Rigidbody 2D isn’t. For this reason, it is fast and has a lower demand on system resources than a Dynamic Rigidbody 2D. Kinematic Rigidbody 2D is designed to be repositioned explicitly via Rigidbody2D.MovePosition or Rigidbody2D.MoveRotation. Use physics queries to detect collisions, and scripts to decide where and how the Rigidbody 2D should move.\n\nA Kinematic Rigidbody 2D does still move via its velocity, but the velocity is not affected by forces or gravity. A Kinematic Rigidbody 2D does not collide with other Kinematic Rigidbody 2Ds or with Static Rigidbody 2Ds; it only collides with Dynamic Rigidbody 2Ds. Similar to a Static Rigidbody 2D (see below), a Kinematic Rigidbody 2D behaves like an immovable object (as if it has infinite mass) during collisions. Mass-related properties are not available with this Body Type.\n\nA Static Rigidbody 2D is designed to not move under simulation at all; if anything collides with it, a Static Rigidbody 2D behaves like an immovable object (as though it has infinite mass). It is also the least resource-intensive body type to use. A Static body only collides with Dynamic Rigidbody 2Ds. Having two Static Rigidbody 2Ds collide is not supported, since they are not designed to move.\n\nOnly a very limited set of properties are available for this Body Type.\n\nThere are two ways to mark a Rigidbody 2D as Static:\n• None For the GameObject with the Collider 2D component not to have a Rigidbody 2D component at all. All such Collider 2Ds are internally considered to be attached to a single hidden Static Rigidbody 2D component.\n• None For the GameObject to have a Rigidbody 2D and for that Rigidbody 2D to be set to Static.\n\nMethod 1 is a shorthand for making Static Collider 2Ds. When creating large numbers of Static Collider 2Ds, it is easier not to have to add a Rigidbody 2D for each GameObject with a Collider 2D.\n\nMethod 2 exists for performance reasons. If a Static Collider 2D needs to be moved or reconfigured at run time, it is faster to do so when it has its own Rigidbody 2D. If a group of Collider 2Ds needs to be moved or reconfigured at run time, it is faster to have them all be children of one parent Rigidbody 2D marked as Static than to move each GameObject individually.\n\nNote: As stated above, Static Rigidbody 2Ds are designed not to move, and collisions between two Static Rigidbody 2D objects that intersect are not registered. However, Static Rigidbody 2Ds and Kinematic Rigidbody 2Ds will interact with each other if one of their Collider 2Ds is set to be a trigger. There is also a feature that changes what a Kinematic body will interact with (see Use Full Kinematic Contacts, below).\n\nUse the Simulated property to stop (unchecked) and start (checked) a Rigidbody 2D and any attached Collider 2Ds and Joint 2Ds from interacting with the 2D physics simulation. Changing this property is much more memory and processor-efficient than enabling or disabling individual Collider 2D and Joint 2D components.\n\nWhen the Simulation box is checked, the following occurs:\n• The Rigidbody 2D moves via the simulation (gravity and physics forces are applied)\n• Any attached Collider 2Ds continue creating new contacts and continuously re-evaluate contacts\n• Any attached Joint 2Ds are simulated and constrain the attached Rigidbody 2D\n• All internal physics objects for Rigidbody 2D, Collider 2D & Joint 2D stay in memory\n\nWhen the Simulated box is unchecked, the following occurs:\n• The Rigidbody 2D is not moved by the simulation (gravity and physics forces are not applied)\n• The Rigidbody 2D does not create new contacts, and any attached Collider 2D contacts are destroyed\n• Any attached Joint 2Ds are not simulated, and do not constrain any attached Rigidbody 2Ds\n• All internal physics objects for Rigidbody 2D, Collider 2D and Joint 2D are left in memory\n\nWhy is unchecking Simulated more efficient than individual component controls?\n\nIn the 2D physics simulation, a Rigidbody 2D component controls the position and rotation of attached Collider 2D components, and allows Joint 2D components to use these positions and rotations as anchor points. A Collider 2D moves when the Rigidbody 2D it is attached to moves. The Collider 2D then calculates contacts with other Collider 2Ds attached to other Rigidbody 2Ds. Joint 2Ds also constrain Rigidbody 2D positions and rotations. All of this takes simulation time.\n\nYou can stop and start individual elements of the 2D physics simulation by enabling and disabling components individually. You can do this on both Collider 2D and Joint 2D components. However, enabling and disabling individual elements of the physics simulations has memory use and processor power costs. When elements of the simulation are disabled, the 2D physics engine doesn’t produce any internal physics-based objects to simulate. When elements of the simulation are enabled, the 2D physics engine does have internal physics-based objects to simulate. Enabling and disabling of 2D physics simulation components means internal GameObjects and physics-based components have to be created and destroyed; disabling the simulation is easier and more efficient than disabling individual components.\n\nNOTE: When a Rigidbody 2D’s Simulated option is unchecked, any attached Collider 2D is effectively ‘invisible’, that is; it cannot be detected by any physics queries, such as Physics.Raycast.\n\nEnable this setting (check the checkbox) if you want the Kinematic Rigidbody 2D to collide with all Rigidbody 2D Body Types. This is similar to a Dynamic Rigidbody 2D, except the Kinematic Rigidbody 2D is not moved by the physics engine when contacting another Rigidbody 2D; it acts as an immovable object, with infinite mass.\n\nWhen this setting is disabled (unchecked), a Kinematic Rigidbody 2D only collides with Dynamic Rigidbody 2Ds; it does not collide with other Kinematic Rigidbody 2Ds or Static Rigidbody 2Ds (note that trigger colliders are an exception to this rule). This means that no collision scripting callbacks (OnCollisionEnter, OnCollisionStay, OnCollisionExit) occur.\n\nThis can be inconvenient when you are using physics queries (such as Physics.Raycast) to detect where and how a Rigidbody 2D should move, and when you require multiple Kinematic Rigidbody 2Ds to interact with each other. Enable Use Full Kinematic Contacts to make Kinematic Rigidbody 2D components interact in this way.\n\nUse Full Kinematic Contacts allows explicit position and rotation control of a Kinematic Rigidbody 2D, but still allows full collision callbacks. In a set-up where you need explicit control of all Rigidbody 2Ds, use Kinematic Rigidbody 2Ds in place of Dynamic Rigidbody 2Ds to still have full collision callback support."
    },
    {
        "link": "https://discussions.unity.com/t/understanding-rigidbody-and-movement/916173",
        "document": ""
    },
    {
        "link": "https://discussions.unity.com/t/health-system/805432",
        "document": ""
    },
    {
        "link": "https://quora.com/How-do-I-apply-specific-action-to-my-3D-character-using-Unity-and-Microsoft-vs-code-like-health-damage-and-shooting",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://discussions.unity.com/t/theres-no-good-way-to-build-an-ability-skill-system-with-unity-tools/790025",
        "document": ""
    },
    {
        "link": "https://docs.unity3d.com/550/Documentation/Manual/UNetSetup.html",
        "document": "This document describes steps to setup a new multiplayer project from nothing using the new networking system. This step-by-step process is generic, but can be customized for many types of multiplayer games once it is started.\n\nTo get started, create a new empty Unity project.\n\nThe first step is to create a NetworkManager object in the project:\n• Add a new empty game object, from the menu Game Object -> Create Empty.\n• Find the newly created object in the Hierarchy View and select it\n• Rename the object to “NetworkManager” from the right-click context menu or by clicking on the object’s name and typing.\n• In the inspector window for the object, click the Add Component button\n• Find the component Network -> NetworkManager and add it to the object. This component manages the network state of the game.\n• Find the component Network -> NetworkManagerHUD and add it to the object. This component supplies a simple user interface in your game for controlling the network state.\n\nFor more details, see Using the NetworkManager.\n\nThe next step is to setup the Unity Prefab that represents the player in the game. By default, the NetworkManager instantiates an object for each player by cloning the player prefab. In this example, the player object will be a simple cube.\n• Create a new Cube from the menu Game Object -> 3D Object -> Cube\n• Find the cube in the Hierarchy view and select it\n• In the inspector window for the object click the Add Component button\n• Add the component Network -> NetworkIdentity to the object. This component is used to identify the object between the server and clients.\n• Set the “Local Player Authority” checkbox on the NetworkIdentity to true. This will allow the client to control the movement of the player object\n• Make a prefab from the player cube object by dragging it into the Assets window. This will create a prefab called “PlayerCube”\n• Delete the PlayerCube object from the scene - we don’t need it now that we have a prefab\n\nOnce the player prefab is created, it must be registered with the network system.\n• Find the NetworkManager object in the Heirarchy View and select it\n• Open the “Spawn Info” foldout of the inspector for the NetworkManager\n• Drag the PlayerCube prefab into the “Player Prefab” slot\n\nNow is a good time to save the project for the first time. From the menu File -> Save Project, save the project. You should also save the scene. Lets call this scene the “offline” scene.\n\nThe first piece of game functionality is to move the player object. This will first be done without any networking, so it will only work in a single-player mode.\n• Find the PlayerCube prefab in the Asset view.\n• Enter the name “PlayerMove” for the new script name. A new script will be created.\n• Open this new script in an editor (such as Visual Studio) by double clicking it\n• Add this simple movement code to the script:\n\nThis hooks up the cube to be controlled by the arrow keys or a controller pad. The cube only moves on the client right now - it is not networked.\n\nEnter play mode in the editor by clicking the play button. You should see the NetworkManagerHUD default user interface:\n\nPress “Host” to start the game as the host of the game. This will cause a player object to be created, and the HUD will change to show the server is active. This game is running as a “host” - which is a server and a client in the same process.\n\nPressing the arrow keys should make the player cube object move around.\n\nExit play mode by pressing the stop button in the editor.\n• Use the menu File -> Build Settings to open the Build Settings dialog.\n• Add the current scene to the build by pressing the “Add Open Scenes” button\n• Create a build by pressing the “Build and Run” button. This will prompt for a name for the executable, enter a name such as “networkTest”\n• Choose the “windowed” checkbox and a lower resolution such as 640x480\n• The stand-alone player will start and show the NetworkManager HUD.\n• Choose “Host” from the menu to start as a host. A player cube should be created\n• Press the arrow keys to move the player cube around a little\n• Switch back to the editor and close the Build Settings dialog.\n• From the NetworkManagerHUD user interace, choose “LAN Client” to connect to the host as a client\n• There should be two cubes, one for the local player on the host and one for the remote player for this client\n• Press the arrow keys to move the cube around\n• Both cube currently move! This because the movement script is not network-aware.\n• Update the script to only move the local player\n• Add a check for “isLocalPlayer” in the Update function, so that only the local player processes input\n• Find the PlayerCube prefab in the Asset View and select\n• Click the “Add Component” button and add the Networking -> NetworkTransform component. This component makes the object sychronize it’s position across the network.\n• Build and run the stand-alone player again and start as host\n• Enter play mode in the editor and connect as a client\n• The player objects should now move independently of each other, and are controlled by the local player on their client.\n\nThe cubes in the game are currently all white, so the user cannot tell which one is their cube. To identify the player, we will make the cube of the local player red.\n• Add an implementation of the OnStartLocalPlayer function to change the player object’s color.\n\nThis function is only called on the local player on their client. This will make the user see their cube as red. The OnStartLocalPlayer function is a good place to do initialization that is only for the local player, such as configuring cameras and input.\n\nThere are also other useful virtual functions on the NetworkBehaviour base class. See Spawning.\n• The cube controlled by the local player should now be red, while the others are still white.\n\nA common feature in multiplayer games is to have player fire bullets. This section adds non-networked bullets to the example. Networking for bullets is added in the next section.\n• Change scale of the bullet from 1.o to 0.2\n• Drag the bullet to the assets folder to make a prefab of the bullet\n• Delete the bullet object from the scene\n• Set the “Use Gravity” checkbox on the rigidbody to false\n• Save the script and return to the editor\n• Select the PlayerCube prefab and find the PlayerMove component\n• Find the bulletPrefab slot on the component\n• Drag the bull prefab into the bulletPrefab slot\n• Make a build then start the stand-alone player as the host\n• Enter play mode in the editor and connect as a client\n• Pressing the space bar should cause a bullet to be created and fired from the player object\n• The bullet is not fired on other clients, only the one where the space bar was pressed.\n\nThis section adds networking to the bullets in the example.\n• Find the bullet prefab and select it\n• Set the send rate to zero on the NetworkTransform component on the bullet prefab. The bullet doesnt change direction or velocity after it is shot, so it does not need to send movement updates.\n• Select the NetworkManager and open the “Spawn Info” foldout\n• Add a new spawn prefab with the plus button\n• Drag the Bullet prefab into the new spawn prefab slot\n• Update the PlayerMove script to network the bullet:\n• Change the Fire function to be a networked command, by adding the [Command] custom attribute and the “Cmd” prefix\n\nThis code uses a [Command] to fire the bullet on the server. For more information see Networked Actions.\n• Make a build then start the stand-alone player as the host\n• Enter play mode in the editor and connect as a client\n• Pressing the space bar should make bullet fire for the correct player (only) on all clients\n\nThis adds a collision handler so that bullets will disappear when they hit a player cube object.\n• Find the bullet prefab and select it\n• Choose the Add Component button and add a new script\n• Open the new script and add the collision handler that destroys the bullet when it hits a player object\n\nNow when a bullet hits a player object it will be destroyed. When the bullet on the server is destroyed, since it is a spawned object managed by the network, it will be destroyed on clients too.\n\nA common feature related to bullets is that the player object has a “health” property that starts at a full value and then is reduced when the player takes damage from a bullet hitting them. This section adds non-networked health to the player object.\n• Choose the Add Component button and add a new script\n• Open the Combat script, add the health variables and TakeDamage function\n\nThe bullet script needs to be updated to call the TakeDamage function on a hit. * Open the bullet script * Add a call to TakeDamage() from the Combat script in the collision handler function\n\nThis will make health on the player object go down when hit by a bullet. But you cannot see this happening in the game. We need to add a simple health bar. * Select the PlayerCube prefab * Choose the Add Component button and add a new script called HealthBar * Open the HealthBar script\n\nThis is a lot of code that uses the old GUI system. This is not very relevant for networking so we’ll just use it without explaination for now.\n• Build and Run the game and see health bar on the player object\n• If a player shoots another player now, the health goes down on that particular client, but not on other clients.\n\nChanges to health are being applied everywhere now - independently on the client and host. This allows health to look different for different players. Health should only be applied on the server and the changes replicated to clients. We call this “server authority” for health.\n• Add isServer check to TakeDamage, so it will only be applied on the server\n\nFor more information on SyncVars, see State Synchronization.\n\nCurrently, nothing currently happens when the health of a player reaches zero except a log message. To make it more of a game, when health reaches zero, the player should be teleported back to the starting location with full health.\n• Add a [ClientRpc] function to respawn the player object. For more information see Networked Actions.\n• Call the repawn function on the server when health reaches zero\n\nIn this game, the client controls the position of the player object - the player object has “local authority” on the client. If the server just set the player’s position to the start position, it would be overridden by the client, since the client has authority. To avoid this, the server tells the owning client to move the player object to the start position.\n• Move the player objects away from the start position\n• Shoot bullets at one player until their health reaches zero\n• The player object should teleport to the starting position.\n\nWhile player objects are spawned when client connect to the host, most games have non-player objects that exist in the game world, such as enemies. In this section a spawner is added that creates non-player objects that can be shot and killed.\n• From the GameObject menu create a new empty game object\n• Choose the Add Component button and add a NetworkIdentity to the object\n• In the NetworkIdentity click the “Server Only” checkbox. This makes the spawner not be sent to clients.\n• Choose the Add Component button and create a new script called “EnemySpawner”\n• Implement the virtual function OnStartServer to create the enemies\n• From the GameObject menu create a new Capsule.\n• Choose the Add Component button add a NetworkIdentity component to the Enemy\n• Choose the Add Component button add a NetworkTransform component to the Enemy\n• Drag the Enemy object into the Asset view to create a prefab\n• there should be a prefab asset now called “Enemy”\n• Delete the Enemy object from the scene\n• Choose the Add Component button and add the Combat script to the Enemy\n• Choose the Add Component button and add the HealthBar script to the Enemy\n• Select the NetworkManager and in Spawn Info add a new spawnable prefab\n• Set the new spawn prefab to the Enemy Prefab\n\nThe bullet script was setup to only work for players. Now update the bullet script to work with any object that has the Combat script on it:\n• Change the collision check to use Combat instead of PlayerMove:\n\nHookup the EnemySpawner with the Enemy object:\n• Find the “Enemy” slot on the EnemySpawner component\n• Drag the Enemy prefab into the slot\n• Set the numEnemies value to 4\n• When starting as Host, four enemies should be created at random locations\n• The player should be able to shoot enemies, and their health should go down\n• When the client joins they should see the enemies in the same positions, and same health values as on the server\n\nWhile the enemies can be shot by bullets and their health goes down, then respawn like players. Enemies should be destroyed when their health reaches zero instead of respawning.\n• Set the destroyOnDeath checkbox to true for the Enemy\n\nNow the enemy will be destroyed when health reaches zero, but players will respawn.\n\nPlayers currently all appear at the zero point when they are created. This means that they are potentially on top of each other. Player should spawn at different locations. The NetworkStartPosition component can be used to do this.\n• None Choose the Add Component button and add the NetworkStartPosition component\n• None Move the Pos1 object to the position (–3,0,0)\n• None Choose the Add Component button and add the NetworkStartPosition component\n• None Move the Pos2 object to the position (3,0,0)\n• None Find the NetworkManager and select it.\n• None Player objects should now be created at the locations of the Pos1 and Pos2 objects instead of at zero."
    }
]