[
    {
        "link": "https://pyinstaller.org/en/stable/when-things-go-wrong.html",
        "document": "The information above covers most normal uses of PyInstaller. However, the variations of Python and third-party libraries are endless and unpredictable. It may happen that when you attempt to bundle your app either PyInstaller itself, or your bundled app, terminates with a Python traceback. Then please consider the following actions in sequence, before asking for technical help.\n\nThe PyInstaller FAQ page has work-arounds for some common problems. Code examples for some advanced uses and some common problems are available on our PyInstaller Recipes page. Some of the recipes there include:\n• None A more sophisticated way of collecting data files than the one shown above (Adding Files to the Bundle).\n• None A use of a run-time hook to set the PyQt5 API level. and others. Many of these Recipes were contributed by users. Please feel free to contribute more recipes!\n\nFinding out What Went Wrong When the step runs, it produces error and warning messages. These display after the command line if the option allows it. Analysis also puts messages in a warnings file named in the directory. Analysis creates a message when it detects an import and the module it names cannot be found. A message may also be produced when a class or function is declared in a package (an module), and the import specifies . In this case, the analysis can’t tell if name is supposed to refer to a submodule or package. The “module not found” messages are not classed as errors because typically there are many of them. For example, many standard modules conditionally import modules for different platforms that may or may not be present. All “module not found” messages are written to the file. They are not displayed to standard output because there are many of them. Examine the warning file; often there will be dozens of modules not found, but their absence has no effect. When you run the bundled app and it terminates with an ImportError, that is the time to examine the warning file. Then see Helping PyInstaller Find Modules below for how to proceed. On each run PyInstaller writes a cross-referencing file about dependencies into the build folder: in the directory is an HTML file that lists the full contents of the import graph, showing which modules are imported by which ones. You can open it in any web browser. Find a module name, then keep clicking the “imported by” links until you find the top-level import that causes that module to be included. If you specify to the command, PyInstaller additionally generates a GraphViz input file representing the dependency graph. The file is in the directory. You can process it with any GraphViz command, e.g. dot, to produce a graphical display of the import dependencies. These files are very large because even the simplest “hello world” Python program ends up including a large number of standard modules. For this reason the graph file is not very useful in this release. PyInstaller sometimes terminates by raising a Python exception. In most cases the reason is clear from the exception message, for example “Your system is not supported”, or “Pyinstaller requires at least Python 3.8”. Others clearly indicate a bug that should be reported. One of these errors can be puzzling, however: PyInstaller needs to bundle the Python library, which is the main part of the Python interpreter, linked as a dynamic load library. The name and location of this file varies depending on the platform in use. Some Python installations do not include a dynamic Python library by default (a static-linked one may be present but cannot be used). You may need to install a development package of some kind. Or, the library may exist but is not in a folder where PyInstaller is searching. The places where PyInstaller looks for the python library are different in different operating systems, but and are checked in most systems. If you cannot put the python library there, try setting the correct path in the environment variable in GNU/Linux or in macOS. The option (and its choices) provides a significant amount of diagnostic information. This can be useful during development of a complex package, or when your app doesn’t seem to be starting, or just to learn how the runtime works. Normally the debug progress messages go to standard output. If the option is used when bundling a Windows app, they are sent to any attached debugger. If you are not using a debugger (or don’t have one), the DebugView the free (beer) tool can be used to display such messages. It has to be started before running the bundled application. For a macOS app they are not displayed. Consider bundling without for your production version. Debugging messages require system calls and have an impact on performance. You can build the app with the option (see Getting Debug Messages above), which will pass the (verbose imports) flag to the embedded Python interpreter. This can be extremely useful. It can be informative even with apps that are apparently working, to make sure that they are getting all imports from the bundle, and not leaking out to the local installed Python. Python verbose and warning messages always go to standard output and are not visible when the option is used. Remember to not use this for your production version. Figuring Out Why Your GUI Application Won’t Start If you are using the option, your bundled application may fail to start with an error message like . In this case, you will want to get more verbose output to find out what is going on.\n• None For macOS, you can run your application on the command line, i.e. in instead of clicking on .\n• None For Windows, you will need to re-bundle your application without the option. Then you can run the resulting executable from the command line, i.e. .\n• None For Unix and GNU/Linux there in no option. Anyway, if a your GUI application fails, you can run your application on the command line, i.e. . This should give you the relevant error that is preventing your application from initializing, and you can then move on to other debugging steps. If you use the –onefile and it fails to run you program with error like: This can be caused by wrong permissions for the /tmp directory (e.g. the filesystem is mounted with flags). A simple way to solve this issue is to set, in the environment variable TMPDIR, a path to a directory in a filesystem mounted without flags, e.g.:\n\nIf Analysis recognizes that a module is needed, but cannot find that module, it is often because the script is manipulating . The easiest thing to do in this case is to use the option to list all the other places that the script might be searching for imports: These paths will be noted in the spec file in the argument. They will be added to the current during analysis. If Analysis thinks it has found all the imports, but the app fails with an import error, the problem is a hidden import; that is, an import that is not visible to the analysis phase. Hidden imports can occur when the code is using , or perhaps or . Hidden imports can also occur when an extension module uses the Python/C API to do an import. When this occurs, Analysis can detect nothing. There will be no warnings, only an ImportError at run-time. To find these hidden imports, build the app with the flag (see Getting Python’s Verbose Imports above) and run it. Once you know what modules are needed, you add the needed modules to the bundle using the command option, or by editing the spec file, or with a hook file (see Understanding PyInstaller Hooks below). Python allows a script to extend the search path used for imports through the mechanism. Normally, the of an imported module has only one entry, the directory in which the was found. But is free to extend its to include other directories. For example, the module actually resolves to . This is because appends to its . Because the of an imported module is not actually executed during analysis, changes it makes to are not seen by PyInstaller. We fix the problem with the same hook mechanism we use for hidden imports, with some additional logic; see Understanding PyInstaller Hooks below. Note that manipulations of hooked in this way apply only to the Analysis. At runtime all imports are intercepted and satisfied from within the bundle. is resolved the same way as , and knows nothing of . Once in a while, that’s not enough. More bizarre situations can be accommodated with runtime hooks. These are small scripts that manipulate the environment before your main script runs, effectively providing additional top-level code to your script. There are two ways of providing runtime hooks. You can name them with the option =path-to-script. Second, some runtime hooks are provided. At the end of an analysis, the names in the module list produced by the Analysis phase are looked up in in the PyInstaller install folder. This text file is the string representation of a Python dictionary. The key is the module name, and the value is a list of hook-script pathnames. If there is a match, those scripts are included in the bundled app and will be called before your main script starts. Hooks you name with the option are executed in the order given, and before any installed runtime hooks. If you specify then the execution order at runtime will be:\n• None Any hook specified for an included module that is found in . Hooks called in this way, while they need to be careful of what they import, are free to do almost anything. One reason to write a run-time hook is to override some functions or variables from some modules. A good example of this is the Django runtime hook (see in the PyInstaller folder). Django imports some modules dynamically and it is looking for some files. However files are not available in the one-file bundle. We need to override the function in a way that will just return a list of values. The runtime hook does this as follows:\n\nIf you have some reason to think you have found a bug in PyInstaller you can try downloading the latest development version. This version might have fixes or features that are not yet at PyPI. You can download the latest stable version and the latest development version from the PyInstaller Downloads page. You can also install the latest version of PyInstaller directly using pip:"
    },
    {
        "link": "https://pyinstaller.org/en/stable/usage.html",
        "document": "The syntax of the command is:\n\nIn the most simple case, set the current directory to the location of your program and execute:\n• None Writes in the same folder as the script.\n• None Creates a folder in the same folder as the script if it does not exist.\n• None Writes some log files and working files in the folder.\n• None Creates a folder in the same folder as the script if it does not exist.\n• None Writes the executable folder in the folder.\n\nIn the folder you find the bundled app you distribute to your users.\n\nNormally you name one script on the command line. If you name more, all are analyzed and included in the output. However, the first script named supplies the name for the spec file and for the executable folder or file. Its code is the first to execute at run-time.\n\nFor certain uses you may edit the contents of (described under Using Spec Files). After you do this, you name the spec file to PyInstaller instead of the script:\n\nThe file contains most of the information provided by the options that were specified when pyinstaller (or pyi-makespec) was run with the script file as the argument. You typically do not need to specify any options when running pyinstaller with the spec file. Only a few command-line options have an effect when building from a spec file.\n\nYou may give a path to the script or spec file, for example\n\nA full list of the command’s options are as follows: Name of scriptfiles to be processed or exactly one .spec file. If a .spec file is specified, most options are unnecessary and are ignored. show this help message and exit Where to put the bundled app (default: ./dist) Where to put all the temporary work files, .log, .pyz and etc. (default: ./build) Replace output directory (default: SPECPATH/dist/SPECNAME) without asking for confirmation Amount of detail in build-time console messages. LEVEL may be one of TRACE, DEBUG, INFO, WARN, DEPRECATION, ERROR, FATAL (default: INFO). Also settable via and overrides the PYI_LOG_LEVEL environment variable. Name to assign to the bundled app and spec file (default: first script’s basename) For onedir builds only, specify the name of the directory in which all supporting files (i.e. everything except the executable itself) will be placed in. Use “.” to re-enable old onedir layout without contents directory. What To Bundle, Where To Search Additional data files or directories containing data files to be added to the application. The argument value should be in form of “source:dest_dir”, where source is the path to file (or directory) to be collected, dest_dir is the destination directory relative to the top-level application directory, and both paths are separated by a colon (:). To put a file in the top-level application directory, use . as a dest_dir. This option can be used multiple times. Additional binary files to be added to the executable. See the option for the format. This option can be used multiple times. A path to search for imports (like using PYTHONPATH). Multiple paths are allowed, separated by , or use this option multiple times. Equivalent to supplying the argument in the spec file. Name an import not visible in the code of the script(s). This option can be used multiple times. Collect all submodules from the specified package or module. This option can be used multiple times. Collect all data from the specified package or module. This option can be used multiple times. Collect all binaries from the specified package or module. This option can be used multiple times. Collect all submodules, data files, and binaries from the specified package or module. This option can be used multiple times. Copy metadata for the specified package. This option can be used multiple times. Copy metadata for the specified package and all its dependencies. This option can be used multiple times. An additional path to search for hooks. This option can be used multiple times. Path to a custom runtime hook file. A runtime hook is code that is bundled with the executable and is executed before any other code or module to set up special features of the runtime environment. This option can be used multiple times. Optional module or package (the Python name, not the path name) that will be ignored (as though it was not found). This option can be used multiple times. (EXPERIMENTAL) Add an splash screen with the image IMAGE_FILE to the application. The splash screen can display progress updates while unpacking. Provide assistance with debugging a frozen application. This argument may be provided multiple times to select several of the following options. - all: All three of the following options. - imports: specify the -v option to the underlying Python interpreter, causing it to print a message each time a module is initialized, showing the place (filename or built-in module) from which it is loaded. See https://docs.python.org/3/using/cmdline.html#id4. - bootloader: tell the bootloader to issue progress messages while initializing and starting the bundled app. Used to diagnose problems with missing imports. - noarchive: instead of storing all frozen Python source files as an archive inside the resulting executable, store them as files in the resulting output directory. Bytecode optimization level used for collected python modules and scripts. For details, see the section “Bytecode Optimization Level” in PyInstaller manual. Specify a command-line option to pass to the Python interpreter at runtime. Currently supports “v” (equivalent to “–debug imports”), “u”, “W <warning control>”, “X <xoption>”, and “hash_seed=<value>”. For details, see the section “Specifying Python Interpreter Options” in PyInstaller manual. Apply a symbol-table strip to the executable and shared libs (not recommended for Windows) Do not use UPX even if it is available (works differently between Windows and *nix) Prevent a binary from being compressed when using upx. This is typically used if upx corrupts certain binaries during compression. FILE is the filename of the binary without path. This option can be used multiple times. Open a console window for standard i/o (default). On Windows this option has no effect if the first script is a ‘.pyw’ file. Windows and macOS: do not provide a console window for standard i/o. On macOS this also triggers building a macOS .app bundle. On Windows this option is automatically set if the first script is a ‘.pyw’ file. This option is ignored on *NIX systems. Windows only: in console-enabled executable, have bootloader automatically hide or minimize the console window if the program owns the console window (i.e., was not launched from an existing console window). FILE.ico: apply the icon to a Windows executable. FILE.exe,ID: extract the icon with ID from an exe. FILE.icns: apply the icon to the .app bundle on macOS. If an image file is entered that isn’t in the platform format (ico on Windows, icns on Mac), PyInstaller tries to use Pillow to translate the icon into the correct format (if Pillow is installed). Use “NONE” to not apply any icon, thereby making the OS show some default (default: apply PyInstaller’s icon). This option can be used multiple times. Disable traceback dump of unhandled exception in windowed (noconsole) mode (Windows and macOS only), and instead display a message that this feature is disabled. Add a version resource from FILE to the exe. Add manifest FILE or XML to the exe. Add or update a resource to a Windows executable. The RESOURCE is one to four items, FILE[,TYPE[,NAME[,LANGUAGE]]]. FILE can be a data file or an exe/dll. For data files, at least TYPE and NAME must be specified. LANGUAGE defaults to 0 or may be specified as wildcard * to update all resources of the given TYPE and NAME. For exe/dll files, all resources from FILE will be added/updated to the final executable if TYPE, NAME and LANGUAGE are omitted or specified as wildcard *. This option can be used multiple times. Using this option creates a Manifest that will request elevation upon application start. Using this option allows an elevated application to work with Remote Desktop. Enable argv emulation for macOS app bundles. If enabled, the initial open document/URL event is processed by the bootloader and the passed file paths or URLs are appended to sys.argv. macOS .app bundle identifier is used as the default unique program name for code signing purposes. The usual form is a hierarchical name in reverse DNS notation. For example: com.mycompany.department.appname (default: first script’s basename) Target architecture (macOS only; valid values: x86_64, arm64, universal2). Enables switching between universal2 and single-arch version of frozen application (provided python installation supports the target architecture). If not target architecture is not specified, the current running architecture is targeted. Code signing identity (macOS only). Use the provided identity to sign collected binaries and generated executable. If signing identity is not provided, ad- hoc signing is performed instead. Entitlements file to use when code-signing the collected binaries (macOS only). Where to extract libraries and support files in mode. If this option is given, the bootloader will ignore any temp-folder location defined by the run-time OS. The -folder will be created here. Please use this option only if you know what you are doing. Note that on POSIX systems, PyInstaller’s bootloader does NOT perform shell-style environment variable expansion on the given path string. Therefore, using environment variables (e.g., or ) in path will NOT work. Tell the bootloader to ignore signals rather than forwarding them to the child process. Useful in situations where for example a supervisor process signals both the bootloader and the child (e.g., via a process group) to avoid signalling the child twice.\n\nUPX is a free utility for compressing executable files and libraries. It is available for most operating systems and can compress a large number of executable file formats. See the UPX home page for downloads, and for the list of supported file formats. When UPX is available, PyInstaller uses it to individually compress each collected binary file (executable, shared library, or python extension) in order to reduce the overall size of the frozen application (the one-dir bundle directory, or the one-file executable). The frozen application’s executable itself is not UPX-compressed (regardless of one-dir or one-file mode), as most of its size comprises the embedded archive that already contains individually compressed files. PyInstaller looks for the UPX in the standard executable path(s) (defined by environment variable), or in the path specified via the command-line option. If found, it is used automatically. The use of UPX can be completely disabled using the command-line option. UPX is currently used only on Windows. On other operating systems, the collected binaries are not processed even if UPX is found. The shared libraries (e.g., the Python shared library) built on modern linux distributions seem to break when processed with UPX, resulting in defunct application bundles. On macOS, UPX currently fails to process .dylib shared libraries; furthermore the UPX-compressed files fail the validation check of the utility, and therefore cannot be code-signed (which is a requirement on the Apple M1 platform). Using UPX may end up corrupting a collected shared library. Known examples of such corruption are Windows DLLs with Control Flow Guard (CFG) enabled, as well as Qt5 and Qt6 plugins. In such cases, individual files may be need to be excluded from UPX processing, using the option (or using the argument in the .spec file). Changed in version 4.2: PyInstaller detects CFG-enabled DLLs and automatically excludes them from UPX processing. Changed in version 4.3: PyInstaller automatically excludes Qt5 and Qt6 plugins from UPX processing. Although PyInstaller attempts to automatically detect and exclude some of the problematic files from UPX processing, there are cases where the UPX excludes need to be specified manually. For example, 32-bit Windows binaries from the package (Qt5 DLLs and python extension modules) have been reported to be corrupted by UPX. Changed in version 5.0: Unlike earlier releases that compared the provided UPX-exclude names against basenames of the collect binary files (and, due to incomplete case normalization, required provided exclude names to be lowercase on Windows), the UPX-exclude pattern matching now uses OS-default case sensitivity and supports the wildcard ( ) operator. It also supports specifying (full or partial) parent path of the file. The provided UPX exclude patterns are matched against source (origin) paths of the collected binary files, and the matching is performed from right to left. For example, to exclude Qt5 DLLs from the PySide2 package, use , and to exclude the python extensions from the PySide2 package, use .\n\nThis feature is incompatible with macOS. In the current design, the splash screen operates in a secondary thread, which is disallowed by the Tcl/Tk (or rather, the underlying GUI toolkit) on macOS. Some applications may require a splash screen as soon as the application (bootloader) has been started, because especially in onefile mode large applications may have long extraction/startup times, while the bootloader prepares everything, where the user cannot judge whether the application was started successfully or not. The bootloader is able to display a one-image (i.e. only an image) splash screen, which is displayed before the actual main extraction process starts. The splash screen supports non-transparent and hard-cut-transparent images as background image, so non-rectangular splash screens can also be displayed. Splash images with transparent regions are not supported on Linux due to Tcl/Tk platform limitations. The and wm attributes used by PyInstaller are not available to Linux. This splash screen is based on Tcl/Tk, which is the same library used by the Python module tkinter. PyInstaller bundles the dynamic libraries of tcl and tk into the application at compile time. These are loaded into the bootloader at startup of the application after they have been extracted (if the program has been packaged as an onefile archive). Since the file sizes of the necessary dynamic libraries are very small, there is almost no delay between the start of the application and the splash screen. The compressed size of the files necessary for the splash screen is about 1.5 MB. As an additional feature, text can optionally be displayed on the splash screen. This can be changed/updated from within Python. This offers the possibility to display the splash screen during longer startup procedures of a Python program (e.g. waiting for a network response or loading large files into memory). You can also start a GUI behind the splash screen, and only after it is completely initialized the splash screen can be closed. Optionally, the font, color and size of the text can be set. However, the font must be installed on the user system, as it is not bundled. If the font is not available, a fallback font is used. If the splash screen is configured to show text, it will automatically (as onefile archive) display the name of the file that is currently being unpacked, this acts as a progress bar.\n\nWhen building your application in mode (see Bundling to One File and How the One-File Program Works), you might encounter situations where you want to control the location of the temporary directory where the application unpacks itself. For example:\n• None your application is supposed to be running for long periods of time, and you need to prevent its files from being deleted by the OS that performs periodic clean-up in standard temporary directories.\n• None your target POSIX system does not use standard temporary directory location (i.e., ) and the standard environment variables for temporary directory are not set in the environment.\n• None the default temporary directory on the target POSIX system is mounted with option, which prevents the frozen application from loading the unpacked shared libraries. The location of the temporary directory can be overridden dynamically, by setting corresponding environment variable(s) before launching the application, or set statically, using the option during the build process. The extraction location can be controlled dynamically, by setting the environment variable(s) that PyInstaller uses to determine the temporary directory. This can, for example, be done in a wrapper shell script that sets the environment variable(s) before running the frozen application’s executable. On POSIX systems, the environment variables used for temporary directory location are , , and , in that order; if none are defined (or the corresponding directories do not exist or cannot be used), , , and are used as hard-coded fall-backs, in the specified order. The directory specified via the environment variable must exist (i.e., the application attempts to create only its own directory under the base temporary directory). On Windows, the default temporary directory location is determined via GetTempPathW function (which looks at and environment variables for initial temporary directory candidates). The location of the temporary directory can be set statically, at compile time, using the option. If this option is used, the bootloader will ignore temporary directory locations defined by the OS, and use the specified path. The path can be either absolute or relative (which makes it relative to the current working directory). Please use this option only if you know what you are doing. On POSIX systems, PyInstaller’s bootloader does not perform shell-style environment variable expansion on the path string given via option. Therefore, using environment variables (e.g., or ) in the path will not work.\n\nIf you distribute your application for only one combination of OS and Python, just install PyInstaller like any other package and use it in your normal development setup. When you need to bundle your application within one OS but for different versions of Python and support libraries – for example, a Python 3.6 version and a Python 3.7 version; or a supported version that uses Qt4 and a development version that uses Qt5 – we recommend you use venv. With you can maintain different combinations of Python and installed packages, and switch from one combination to another easily. These are called or in short.\n• None Use to create as many different development environments as you need, each with its unique combination of Python and installed packages.\n• None Use PyInstaller to build your application in each virtual environment. Note that when using , the path to the PyInstaller commands is: Under Windows, the pip-Win package makes it especially easy to set up different environments and switch between them. Under GNU/Linux and macOS, you switch environments at the command line. See PEP 405 and the official Python Tutorial on Virtual Environments and Packages for more information about Python virtual environments. If you need to distribute your application for more than one OS, for example both Windows and macOS, you must install PyInstaller on each platform and bundle your app separately on each. You can do this from a single machine using virtualization. The free virtualBox or the paid VMWare and Parallels allow you to run another complete operating system as a “guest”. You set up a virtual machine for each “guest” OS. In it you install Python, the support packages your application needs, and PyInstaller. A File Sync & Share system like NextCloud is useful with virtual machines. Install the synchronization client in each virtual machine, all linked to your synchronization account. Keep a single copy of your script(s) in a synchronized folder. Then on any virtual machine you can run PyInstaller thus: # get rid of modules compiled by another Python \\ \\ \\ PyInstaller reads scripts from the common synchronized folder, but writes its work files and the bundled app in folders that are local to the virtual machine. If you share the same home directory on multiple platforms, for example GNU/Linux and macOS, you will need to set the PYINSTALLER_CONFIG_DIR environment variable to different values on each platform otherwise PyInstaller may cache files for one platform and use them on the other platform, as by default it uses a subdirectory of your home directory as its cache location. It is said to be possible to cross-develop for Windows under GNU/Linux using the free Wine environment. Further details are needed, see How to Contribute.\n\nA Windows app may require a Version resource file. A Version resource contains a group of data structures, some containing binary integers and some containing strings, that describe the properties of the executable. For details see the Microsoft Version Information Structures page. Version resources are complex and some elements are optional, others required. When you view the version tab of a Properties dialog, there’s no simple relationship between the data displayed and the structure of the resource. For this reason PyInstaller includes the command. It is invoked with the full path name of any Windows executable that has a Version resource: The command writes text that represents a Version resource in readable form to standard output. You can copy it from the console window or redirect it to a file. Then you can edit the version information to adapt it to your program. Using you can find an executable that displays the kind of information you want, copy its resource data, and modify it to suit your package. The version text file is encoded UTF-8 and may contain non-ASCII characters. (Unicode characters are allowed in Version resource string fields.) Be sure to edit and save the text file in UTF-8 unless you are certain it contains only ASCII string values. Your edited version text file can be given with the option to or . The text data is converted to a Version resource and installed in the bundled app. In a Version resource there are two 64-bit binary values, and . In the version text file these are given as four-element tuples, for example: The elements of each tuple represent 16-bit values from most-significant to least-significant. For example the value resolves to in hex. You can also install a Version resource from a text file after the bundled app has been created, using the command: The utility reads a version text file as written by , converts it to a Version resource, and installs that resource in the executable_file specified. For advanced uses, examine a version text file as written by . You find it is Python code that creates a object. The class definition for is found in in the PyInstaller distribution folder. You can write a program that imports . In that program you can the contents of a version info text file to produce a object. You can use the method of that object to produce a Version resource in binary form. Or you can apply the function to the object to reproduce the version text file.\n\nUnder macOS, PyInstaller always builds a UNIX executable in . If you specify , the output is a folder named containing supporting files and an executable named . If you specify , the output is a single UNIX executable named . Either executable can be started from a Terminal command line. Standard input and output work as normal through that Terminal window. If you specify with either option, the folder also contains a macOS app bundle named . Generating app bundles with onefile executables (i.e., using the combination of and options), while possible, is not recommended. Such app bundles are inefficient, because they require unpacking on each run (and the unpacked content might be scanned by the OS each time). Furthermore, onefile executables will not work when signed/notarized with sandbox enabled (which is a requirement for distribution of apps through Mac App Store). As you are likely aware, an app bundle is a special type of folder. The one built by PyInstaller always contains a folder named , which contains:\n• None A folder named that contains the program executable.\n• None A folder named that contains the collected binaries (shared libraries, python extensions) and nested .framework bundles. It also contains symbolic links to data files and directories from the directory.\n• None A folder named that contains the icon file and all collected data files. It also contains symbolic links to binaries and directories from the directory. The contents of the and directories are cross-linked between the two directories in an effort to maintain an illusion of a single content directory (which is required by some packages), while also trying to satisfy the Apple’s file placement requirements for codesigning. Use the argument to specify a custom icon for the application. It will be copied into the folder. (If you do not specify an icon file, PyInstaller supplies a file with the PyInstaller logo.) Use the argument to add a bundle identifier. This becomes the used in code-signing (see the PyInstaller code signing recipe and for more detail, the Apple code signing overview technical note). You can add other items to the by editing the spec file; see Spec File Options for a macOS Bundle below.\n\nUnder GNU/Linux, PyInstaller does not bundle (the C standard library, usually , the Gnu version) with the app. Instead, the app expects to link dynamically to the from the local OS where it runs. The interface between any app and is forward compatible to newer releases, but it is not backward compatible to older releases. For this reason, if you bundle your app on the current version of GNU/Linux, it may fail to execute (typically with a runtime dynamic link error) if it is executed on an older version of GNU/Linux. The solution is to always build your app on the oldest version of GNU/Linux you mean to support. It should continue to work with the found on newer versions. The GNU/Linux standard libraries such as are distributed in 64-bit and 32-bit versions, and these are not compatible. As a result you cannot bundle your app on a 32-bit system and run it on a 64-bit installation, nor vice-versa. You must make a unique version of the app for each word-length supported. Note that PyInstaller does bundle other shared libraries that are discovered via dependency analysis, such as libstdc++.so.6, libfontconfig.so.1, libfreetype.so.6. These libraries may be required on systems where older (and thus incompatible) versions of these libraries are available. On the other hand, the bundled libraries may cause issues when trying to load a system-provided shared library that is linked against a newer version of the system-provided library. For example, system-installed mesa DRI drivers (e.g., radeonsi_dri.so) depend on the system-provided version of libstdc++.so.6. If the frozen application bundles an older version of libstdc++.so.6 (as collected from the build system), this will likely cause missing symbol errors and prevent the DRI drivers from loading. In this case, the bundled libstdc++.so.6 should be removed. However, this may not work on a different distribution that provides libstdc++.so.6 older than the one from the build system; in that case, the bundled version should be kept, because the system-provided version may lack the symbols required by other collected binaries that depend on libstdc++.so.6. The developer needs to take special care to include the Visual C++ run-time .dlls: Python 3.5+ uses Visual Studio 2015 run-time, which has been renamed into “Universal CRT“ and has become part of Windows 10. For Windows Vista through Windows 8.1 there are Windows Update packages, which may or may not be installed in the target-system. So you have the following options:\n• None Build on Windows 7 which has been reported to work.\n• None Include one of the VCRedist packages (the redistributable package files) into your application’s installer. This is Microsoft’s recommended way, see “Distributing Software that uses the Universal CRT“ in the above-mentioned link, numbers 2 and 3.\n• None Install the Windows Software Development Kit (SDK) for Windows 10 and expand the -file to include the required DLLs, see “Distributing Software that uses the Universal CRT“ in the above-mentioned link, number 6. If you think, PyInstaller should do this by itself, please help improving PyInstaller. On macOS, system components from one version of the OS are usually compatible with later versions, but they may not work with earlier versions. While PyInstaller does not collect system components of the OS, the collected 3rd party binaries (e.g., python extension modules) are built against specific version of the OS libraries, and may or may not support older OS versions. As such, the only way to ensure that your frozen application supports an older version of the OS is to freeze it on the oldest version of the OS that you wish to support. This applies especially when building with Homebrew python, as its binaries usually explicitly target the running OS. For example, to ensure compatibility with “Mojave” (10.14) and later versions, you should set up a full environment (i.e., install python, PyInstaller, your application’s code, and all its dependencies) in a copy of macOS 10.14, using a virtual machine if necessary. Then use PyInstaller to freeze your application in that environment; the generated frozen application should be compatible with that and later versions of macOS. This section is largely obsolete, as support for 32-bit application was removed in macOS 10.15 Catalina (for 64-bit multi-arch support on modern versions of macOS, see here). However, PyInstaller still supports building 32-bit bootloader, and 32-bit/64-bit Python installers are still available from python.org for (some) versions of Python 3.7 which PyInstaller dropped support for in v6.0. Older versions of macOS supported both 32-bit and 64-bit executables. PyInstaller builds an app using the the word-length of the Python used to execute it. That will typically be a 64-bit version of Python, resulting in a 64-bit executable. To create a 32-bit executable, run PyInstaller under a 32-bit Python. To verify that the installed python version supports execution in either 64- or 32-bit mode, use the command on the Python executable: $ file /usr/local/bin/python3 /usr/local/bin/python3: Mach-O universal binary with 2 architectures /usr/local/bin/python3 (for architecture i386): Mach-O executable i386 /usr/local/bin/python3 (for architecture x86_64): Mach-O 64-bit executable x86_64 The OS chooses which architecture to run, and typically defaults to 64-bit. You can force the use of either architecture by name using the command: $ /usr/local/bin/python3 Python 3.7.6 (v3.7.6:43364a7ae0, Dec 18 2019, 14:12:53) [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> import sys; sys.maxsize 9223372036854775807 $ arch -i386 /usr/local/bin/python3 Python 3.7.6 (v3.7.6:43364a7ae0, Dec 18 2019, 14:12:53) [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> import sys; sys.maxsize 2147483647 PyInstaller does not provide pre-built 32-bit bootloaders for macOS anymore. In order to use PyInstaller with 32-bit python, you need to build the bootloader yourself, using an XCode version that still supports compiling 32-bit. Depending on the compiler/toolchain, you may also need to explicitly pass to the command. When user double-clicks a document of a type that is registered with your application, or when a user drags a document and drops it on your application’s icon, macOS launches your application and provides the name(s) of the opened document(s) in the form of an OpenDocument AppleEvent. These events are typically handled via installed event handlers in your application (e.g., using API via , or using facilities provided by UI toolkits, such as or ). Alternatively, PyInstaller also supports conversion of open document/URL events into arguments that are appended to . This applies only to events received during application launch, i.e., before your frozen code is started. To handle events that are dispatched while your application is already running, you need to set up corresponding event handlers. For details, see this section. Depending on whether Python was build as a 32-bit or a 64-bit executable you may need to set or unset the environment variable . To determine the size the following command can be used: When the answer is (as above) Python was build as a 32-bit executable. When working with a 32-bit Python executable proceed as follows: When working with a 64-bit Python executable proceed as follows: Under Cygwin, the PyInstaller’s bootloader executable (and therefore the frozen application’s executable) ends up being dynamically linked against the . As noted under Q 6.14 of the Cygwin’s FAQ, the Cygwin library cannot be statically linked into an executable in order to obtain an independent, self-contained executable. This means that at run-time, the needs to be available to the frozen application’s executable for it to be able to launch. Depending on the deployment scenario, this means that it needs to be either available in the environment (i.e., the environment’s search path) or a copy of the DLL needs to be available next to the executable. On the other hand, Cygwin does not permit more than one copy of ; or rather, it requires multiple copies of the DLL to be strictly separated, as each instance constitutes its own Cygwin installation/environment (see Q 4.20 of the Cygwin FAQ). Trying to run an executable with an adjacent copy of the DLL from an existing Cygwin environment will likely result in the application crashing. In practice, this means that if you want to create a frozen application that will run in an existing Cygwin environment, the application should not bundle a copy of . On the other hand, if you want to create a frozen application that will run outside of a Cygwin environment (i.e., a “stand-alone” application that runs directly under Windows), the application will require a copy of – and that copy needs to be placed next to the program’s executable, regardless of whether or build mode is used. As PyInstaller cannot guess the deployment mode that you are pursuing, it makes no attempt to collect . So if you want your application to run outside of an externally-provided Cygwin environment, you need to place a copy of next to the program’s executable and distribute them together. If you plan to create a “stand-alone” Cygwin-based frozen application (i.e., distribute along with the executable), you will likely want to build the bootloader with statically linked library, in order to avoid a run-time dependency on . You can do so by passing option to when manually building the bootloader before installing PyInstaller from source, or by adding the option to environment variable if installing directly via . For details, see Building the Bootloader."
    },
    {
        "link": "https://stackoverflow.com/questions/57227191/pyinstaller-hidden-import-not-found",
        "document": "Found the answer. If you are using a virtual environment (Like Pipenv, pyenv, venv) you need to run pyinstaller in the context of that environment. So...\n\nAlso, as mosegui pointed out, you should put your config flags before the file name:\n\nthough this was so long ago that I'm not sure if that was actually an issue for me.\n\nThese days I use Poetry so once I have a Poetry environment I just and/or . Anytime you use it runs whatever your command sequence is in the context of the current virtual environment. I believe accomplishes a similar thing but Poetry always works better for me."
    },
    {
        "link": "https://pyinstaller.org/en/stable/operating-mode.html",
        "document": "What PyInstaller Does and How It Does It\n\nThis section covers the basic ideas of PyInstaller. These ideas apply to all platforms. Options and special cases are covered below, under Using PyInstaller.\n\nPyInstaller reads a Python script written by you. It analyzes your code to discover every other module and library your script needs in order to execute. Then it collects copies of all those files – including the active Python interpreter! – and puts them with your script in a single folder, or optionally in a single executable file.\n\nFor the great majority of programs, this can be done with one short command,\n\nor with a few added options, for example a windowed application as a single-file executable,\n\nYou distribute the bundle as a folder or file to other people, and they can execute your program. To your users, the app is self-contained. They do not need to install any particular version of Python or any modules. They do not need to have Python installed at all.\n\nWhat other modules and libraries does your script need in order to run? (These are sometimes called its “dependencies”.) To find out, PyInstaller finds all the statements in your script. It finds the imported modules and looks in them for statements, and so on recursively, until it has a complete list of modules your script may use. PyInstaller understands the “egg” distribution format often used for Python packages. If your script imports a module from an “egg”, PyInstaller adds the egg and its dependencies to the set of needed files. PyInstaller also knows about many major Python packages, including the GUI packages Qt (imported via PyQt or PySide), WxPython, TkInter, matplotlib, and other major packages. For a complete list, see Supported Packages. Some Python scripts import modules in ways that PyInstaller cannot detect: for example, by using the function with variable data, using , or manipulating the value at run time. If your script requires files that PyInstaller does not know about, you must help it:\n• None You can give additional files on the command line.\n• None You can give additional import paths on the command line.\n• None You can edit the file that PyInstaller writes the first time you run it for your script. In the spec file you can tell PyInstaller about code modules that are unique to your script.\n• None You can write “hook” files that inform PyInstaller of hidden imports. If you create a “hook” for a package that other users might also use, you can contribute your hook file to PyInstaller. If your program depends on access to certain data files, you can tell PyInstaller to include them in the bundle as well. You do this by modifying the spec file, an advanced topic that is covered under Using Spec Files. In order to locate included files at run time, your program needs to be able to learn its path at run time in a way that works regardless of whether or not it is running from a bundle. This is covered under Run-time Information. PyInstaller does not include libraries that should exist in any installation of this OS. For example in GNU/Linux, it does not bundle any file from or , assuming these will be found in every system.\n\nWhen you apply PyInstaller to the default result is a single folder named . This folder contains all your script’s dependencies, and an executable file also named ( in Windows). You compress the folder to and transmit it to your users. They install the program simply by unzipping it. A user runs your app by opening the folder and launching the executable inside it. It is easy to debug problems that occur when building the app when you use one-folder mode. You can see exactly what files PyInstaller collected into the folder. Another advantage of a one-folder bundle is that when you change your code, as long as it imports exactly the same set of dependencies , you could send out only the updated executable. That is typically much smaller than the entire folder. (If you change the script so that it imports more or different dependencies, or if the dependencies are upgraded, you must redistribute the whole bundle.)\n\nA bundled program always starts execution in the PyInstaller bootloader. This is the heart of the executable in the folder. The PyInstaller bootloader is a binary executable program for the active platform (Windows, GNU/Linux, macOS, etc.). When the user launches your program, it is the bootloader that runs. The bootloader creates a temporary Python environment such that the Python interpreter will find all imported modules and libraries in the folder. The bootloader starts a copy of the Python interpreter to execute your script. Everything follows normally from there, provided that all the necessary support files were included.\n\nPyInstaller can bundle your script and all its dependencies into a single executable named ( in Windows). The advantage is that your users get something they understand, a single executable to launch. A disadvantage is that any related files such as a README must be distributed separately. Also, the single executable is a little slower to start up than the one-folder bundle. Before you attempt to bundle to one file, make sure your app works correctly when bundled to one folder. It is is much easier to diagnose problems in one-folder mode.\n\nThe bootloader is the heart of the one-file bundle also. When started it creates a temporary folder in the appropriate temp-folder location for this OS. The folder is named , where xxxxxx is a random number. The one executable file contains an embedded archive of all the Python modules used by your script, as well as compressed copies of any non-Python support files (e.g. files). The bootloader uncompresses the support files and writes copies into the the temporary folder. This can take a little time. That is why a one-file app is a little slower to start than a one-folder app. PyInstaller currently does not preserve file attributes. see #3926. After creating the temporary folder, the bootloader proceeds exactly as for the one-folder bundle, in the context of the temporary folder. When the bundled code terminates, the bootloader deletes the temporary folder. (In GNU/Linux and related systems, it is possible to mount the folder with a “no-execution” option. That option is not compatible with a PyInstaller one-file bundle. It needs to execute code out of . If you know the target environment, might be a workaround. Alternatively, you can set the environment variable that controls the temporary directory before launching the program. See Defining the Extraction Location). Because the program makes a temporary folder with a unique name, you can run multiple copies of the app; they won’t interfere with each other. However, running multiple copies is expensive in disk space because nothing is shared. The folder is not removed if the program crashes or is killed (kill -9 on Unix, killed by the Task Manager on Windows, “Force Quit” on macOS). Thus if your app crashes frequently, your users will lose disk space to multiple temporary folders. It is possible to control the location of the folder by using the command line option. The specified path is stored in the executable, and the bootloader will create the folder inside of the specified folder. Please see Defining the Extraction Location for details. Do not give administrator privileges to a one-file executable on Windows (“Run this program as an administrator”). There is an unlikely but not impossible way in which a malicious attacker could corrupt one of the shared libraries in the temp folder while the bootloader is preparing it. When distributing a privileged program in general, ensure that file permissions prevent shared libraries or executables from being tampered with. Otherwise, an unelevated process which has write access to these files may escalate privileges by modifying them. Applications that use may encounter permissions errors. The temporary folder where the bundled app runs may not being readable after is called. If your script needs to call , it may be better to use one-folder mode so as to have more control over the permissions on its files.\n\nThe bundled app does not include any source code. However, PyInstaller bundles compiled Python scripts ( files). These could in principle be decompiled to reveal the logic of your code. If you want to hide your source code more thoroughly, one possible option is to compile some of your modules with Cython. Using Cython you can convert Python modules into C and compile the C to machine language. PyInstaller can follow import statements that refer to Cython C object modules and bundle them."
    },
    {
        "link": "https://stackoverflow.com/questions/15229658/pyinstaller-what-are-hiddenimports-and-hooks",
        "document": "Some Python imports are untrackable during static analysis of your program. eg Your code may create the name of a module to import using Python code, and then import that module. In this case, pyinstaller will be unable to work out during its code analysis, what is the name of the module to import. If you know ahead of time, then you can tell pyinstaller to unconditionally include these modules.\n\nHooks are a way for you to bundle a set of hidden imports and other parameters to do with finding modules. Hooks are named where module is a fully qualified module name. eg . If your code does , then the contents of the hook script are read to include any hidden imports specific to .\n\nIf you create your own module and it requires hidden imports, you can create a hook script with the appropriate hidden imports settings and store in the PyInstaller hooks directory. The next time you use PyInstaller to freeze a program which imports your module, it will automatically find your hook file and pull in the required hidden imports without you having to remember each time what the hidden imports are for your module.\n\nThe documentation has more information about how all of this works but hopefully this provides some more background information."
    },
    {
        "link": "https://tutorialspoint.com/pyqt5/pyqt5_qmessagebox.htm",
        "document": "QMessageBox is a commonly used modal dialog to display some informational message and optionally ask the user to respond by clicking any one of the standard buttons on it. Each standard button has a predefined caption, a role and returns a predefined hexadecimal number.\n\nImportant methods and enumerations associated with QMessageBox class are given in the following table −\n\nIn the following example, click signal of the button on the top level window, the connected function displays the messagebox dialog.\n\nbuttonClicked() signal is connected to a slot function, which identifies the caption of source of the signal.\n\nThe complete code for the example is as follows −\n\nThe above code produces the following output. Message Box pops up when main windows button is clicked −\n\nIf you click on Ok or Cancel button on MessageBox, the following output is produced on the console −"
    },
    {
        "link": "https://geeksforgeeks.org/pyqt5-message-box",
        "document": "In this article, we will discuss the Message Box Widget of the PyQT5 module. It is used to display the message boxes. PyQt5 is a library used to create GUI using the Qt GUI framework. Qt is originally written in C++ but can be used in Python. The latest version of PyQt5 can be installed using the command:\n\nMessage Boxes are usually used for declaring a small piece of information to the user. It gives users a pop-up box, that cannot be missed, to avoid important errors and information being missed by the users and in some cases, the user cannot continue without acknowledging the message box.\n\nBased on the applications there are four types of message boxes. The following is the syntax for creating a message box. For any of the boxes, instantiation needs to be done.\n\nNow according to the requirement an appropriate message box is created.\n\nThis type of message box is used when related information needs to be passed to the user.\n\nThis message box is used to get an answer from a user regarding some activity or action to be performed.\n\nThis triggers a warning regarding the action the user is about to perform.\n\nThis is often used for getting the user’s opinion for a critical action.\n\nNow to create a program that produces a message box first import all the required modules, and create a widget with four buttons, on clicking any of these a message box will be generated.\n\nNow for each button associate a message box that pops when the respective button is clicked. For this first, instantiate a message box and add a required icon. Now set appropriate attributes for the pop that will be generated. Also, add buttons to deal with standard mechanisms.\n\nGiven below is the complete implementation."
    },
    {
        "link": "https://stackoverflow.com/questions/40155235/use-qmessagebox-in-pyqt5-to-restart-my-game-or-exit-the-application",
        "document": "I have a memory game made in PyQt5. When the user wins, I'd like to show a message with three options (buttons):\n\nI think the way to implement this is by using a QMessageBox, but I could not understand how to use it properly. I know it has to be something like:\n\nI also know there exist , which I can use for exiting ( , but I am not sure), but I don't know how can I add them and other custom buttons in order to have it working.\n\nOk, I think I made some steps towards the right direction, although something is stil missing. I was able to add custom buttons to my , I am able to something when one of them is clicked, but any method I call after is not doing anything. Also, if 'quit' is selected, it just closes the message box (I am using the method, maybe it's wrong).\n\nHere is the updated code, along with few comments:\n\nAs you can see, I tried both with and with , but none worked."
    },
    {
        "link": "https://tutorialspoint.com/pyqt/pyqt_qmessagebox.htm",
        "document": "QMessageBox is a commonly used modal dialog to display some informational message and optionally ask the user to respond by clicking any one of the standard buttons on it. Each standard button has a predefined caption, a role and returns a predefined hexadecimal number.\n\nImportant methods and enumerations associated with QMessageBox class are given in the following table −\n\nQMessageBox does not define predefined icons but rather provides them through the style. The default value is No Icon. Message boxes remain the same for all cases. It is recommended to use the standard icons as suggested in the table or as per the style guidelines for the platform.\n\nIn this case, none of the predefined icons is suitable for our message box, we can create a custom icon by setting the icon pixmap property instead of the icon property.\n\nIn this example, illustrate the predefined icon using QMessageBox class and it's method.\n\nOn executing the code, we see four on-click buttons to get the specific icons.\n\nIn the following example, click signal of the button on the top level window, the connected function displays the messagebox dialog.\n\nbuttonClicked() signal is connected to a slot function, which identifies the caption of source of the signal.\n\nThe complete code for the example is as follows −\n\nThe above code produces the following output. Message Box pops up when main windows button is clicked −\n\nIf you click on Ok or Cancel button on MessageBox, the following output is produced on the console −"
    },
    {
        "link": "https://pythonguis.com/tutorials/pyqt-dialogs",
        "document": "Dialogs are useful GUI components that allow you to communicate with the user (hence the name dialog). They are commonly used for file Open/Save, settings, preferences, or for functions that do not fit into the main UI of the application. They are small modal (or blocking) windows that sit in front of the main application until they are dismissed. Qt provides a number of 'special' built-in dialogs for the most common use-cases, allowing you to provide a platform-native user experience.\n\nIn Qt dialog boxes are handled by the class. To create a new dialog box simply create a new object of type passing in another widget, e.g. , as its parent.\n\nLet's create our own . We'll start with a simple skeleton app with a button to press hooked up to a slot method.\n\nIn the slot (which receives the signal from the button press) we create the dialog instance, passing our instance as a parent. This will make the dialog a modal window of . This means the dialog will completely block interaction with the parent window.\n\nRun it! Click the button and you'll see an empty dialog appear.\n\nOnce we have created the dialog, we start it using - just like we did for to create the main event loop of our application. That’s not a coincidence: when you exec the an entirely new event loop - specific for the dialog - is created.\n\nThe completely blocks your application execution. Don't start a dialog and expect anything else to happen anywhere else in your app. We'll see later how you can use threads & processes to get you out of this pickle.\n\nLike our very first window, this isn't very interesting. Let's fix that by adding a dialog title and a set of OK and Cancel buttons to allow the user to accept or reject the modal.\n\nTo customize the we can subclass it.\n\nIn the above code, we first create our subclass of which we've called . As for the we apply our customizations in the class block so our customizations are applied as the object is created. First we set a title for the using , exactly the same as we did for our main window.\n\nThe next block of code is concerned with creating and displaying the dialog buttons. This is probably a bit more involved than you were expecting. However, this is due to Qt's flexibility in handling dialog button positioning on different platforms.\n\nYou could of course choose to ignore this and use a standard in a layout, but the approach outlined here ensures that your dialog respects the host desktop standards (OK on left vs. right for example). Messing around with these behaviors can be incredibly annoying to your users, so I wouldn't recommend it.\n\nThe first step in creating a dialog button box is to define the buttons want to show, using namespace attributes from . The full list of buttons available is below.\n\nThese should be sufficient to create any dialog box you can think of. You can construct a line of multiple buttons by OR-ing them together using a pipe ( ). Qt will handle the order automatically, according to platform standards. For example, to show an OK and a Cancel button we used:\n\nThe variable now contains an integer value representing those two buttons. Next, we must create the instance to hold the buttons. The flag for the buttons to display is passed in as the first parameter.\n\nTo make the buttons have any effect, you must connect the correct signals to the slots on the dialog. In our case we've connected the and signals from the to the handlers for and on our subclass of .\n\nLastly, to make the appear in our dialog box we must add it to the dialog layout. So, as for the main window we create a layout, and add our to it ( is a widget), and then set that layout on our dialog.\n\nFinally, we launch the in our slot.\n\nRun it! Click to launch the dialog and you will see a dialog box with buttons.\n\nOur dialog with a label and buttons.\n\nWhen you click the button to launch the dialog, you may notice that it appears away from the parent window -- probably in the center of the screen. Normally you want dialogs to appear over their launching window to make them easier for users to find. To do this we need to give Qt a parent for the dialog. If we pass our main window as the parent, Qt will position the new dialog so that the center of the dialog aligns with the center of the window.\n\nWe can modify our class to accept a parameter.\n\nWe set a default value of so we can omit the parent if we wish.\n\nThen, when we create our instance of we can pass the main window in as a parameter. In our method, is our main window object.\n\nRun it! Click to launch the dialog and you should see the dialog pop up right in the middle of the parent window.\n\nOur dialog, centered over the parent window.\n\nCongratulations! You've created your first dialog box. Of course, you can continue to add any other content to the dialog box that you like. Simply insert it into the layout as normal.\n\nThere are many dialogs which follow the simple pattern we just saw -- a message with buttons with which you can accept or cancel the dialog. While you can construct these dialogs yourself, Qt also provides a built-in message dialog class called . This can be used to create information, warning, about or question dialogs.\n\nThe example below creates a simple and shows it.\n\nRun it! You'll see a simple dialog with an OK button.\n\nAs with the dialog button box we looked at already, the buttons shown on a are also configured with the same set of constants which can be combined with (the binary OR operator) to show multiple buttons. The full list of available button types is shown below.\n\nYou can also tweak the icon shown on the dialog by setting the icon with one of the following.\n\nFor example, the following creates a question dialog with Yes and No buttons.\n\nRun it! You'll see a question dialog with Yes and No buttons.\n\nTo make things even simpler the has a number of methods which can be used to construct these types of message dialog. These methods are shown below --\n\nThe parameter is the window which the dialog will be a child of. If you're launching your dialog from your main window, you can just pass in . The following example creates a question dialog, as before, with Yes and No buttons.\n\nRun it! You'll see the same result, this time using the built in method.\n\nNotice that rather than call we now simply call the dialog method and the dialog is created. The return value of each of the methods is the button which was pressed. We can detect what has been pressed by comparing the return value to the button constants.\n\nThe four , , and methods also accept optional and arguments which can be used to tweak the buttons shown on the dialog and select one by default. Generally though you don't want to change this from the default.\n\nRun it! You'll see a critical dialog with customized buttons.\n\nFor most situations these simple dialogs are all you need."
    }
]