[
    {
        "link": "https://refactoring.guru/design-patterns/mediator/csharp/example",
        "document": "Mediator is a behavioral design pattern that reduces coupling between components of a program by making them communicate indirectly, through a special mediator object. The Mediator makes it easy to modify, extend and reuse individual components because they’re no longer dependent on the dozens of other classes.\n\nUsage examples: The most popular usage of the Mediator pattern in C# code is facilitating communications between GUI components of an app. The synonym of the Mediator is the Controller part of MVC pattern.\n\nThis example illustrates the structure of the Mediator design pattern. It focuses on answering these questions:\n• What classes does it consist of?\n• What roles do these classes play?\n• In what way the elements of the pattern are related?"
    },
    {
        "link": "https://dev.to/kalkwst/mediator-pattern-in-c-4i3p",
        "document": "The Mediator is a behavioural design pattern that lets us reduce chaotic dependencies between objects. The pattern restricts direct communications between the entities and forces them to collaborate only via a mediator object.\n\nYou can find the example code of this post, on GitHub\n\nLet's say we have a user interface dialogue for creating and editing a customer profile. It consists of various form controls such as text fields, checkboxes, buttons, tabs, etc.\n\nSome of the form elements may interact with others. For instance, selecting the \"I have a roommate\" checkbox may reveal a hidden text field for entering the roommate's name. Another example is the submit button that triggers the validation of values of all fields before submitting the data.\n\nBy having this logic implemented directly by the form elements, we make these elements much harder to reuse in other parts of the application. For example, we won't be able to use that checkbox on another form, since it's coupled to the roommate's text field. We can either use all the classes involved in rendering on the profile form, or none at all.\n\nThe Mediator pattern suggests that we should cease all direct communication between the components that should be independent of each other. Instead, these components must communicate indirectly, by calling a special mediator object. This mediator object will redirect the calls to the appropriate components. As a result, the components only depend on a single mediator class instead of being coupled to each other.\n\nIn our example, the dialogue class may act as the mediator. Most likely, the dialogue class is already aware of all of its sub-elements, so we won't even need to introduce new dependencies into this class.\n\nThe most significant change happens to the actual form elements. Consider the submit button. With the previous implementation, each time a user clicked the button, it had to validate the values of every form element. Now its single job is to notify the dialogue about the click. Upon receiving this notification, the dialogue itself performs the validation or passes the task to the individual elements. Thus instead of being coupled with dozens of elements, the button is only dependent on the dialogue class.\n\nWe can make the dependency even looser by extracting the common interface for all types of dialogues. The interface would declare the notification method that all form elements can use to notify the dialogue about events triggered by those elements. Thus, our submit button should now be able to work with any dialogue that implements that interface.\n\nThis way, the Mediator pattern lets us encapsulate a complex web of relations between various objects inside a single mediator object. The fewer dependencies a class has, the easier it becomes to modify, extend or reuse that class.\n\nIn its base implementation, the Mediator pattern has three participants:\n• Component: The Components are various classes that contain some business logic. Each component has a reference to a mediator, declared through the mediator interface. The component isn't aware of the actual class of the mediator, so we can reuse the component by linking it to a different mediator. Components must not be aware of other components. If something important happens within or to a component, it must notify the mediator. When the mediator receives the notification, it can identify the sender, which is enough to decide what component should be triggered.\n• Mediator: The Mediator interface declares methods of communication with components, which most of the time include just a single notification method. Components may pass any context as arguments of this method, including their objects, but only in such a way that no coupling can occur.\n• Concrete Mediator: The Concrete Mediators encapsulate relations between various components. Concrete mediators often keep references to all components they manage and sometimes even manage their lifecycles.\n\nTo demonstrate how the Mediator pattern works, we are going to model the snack bars in big amusement parks.\n\nAmusement parks usually have a somewhat centralized food court with some snack bars and several smaller establishments peppered around, for gluttonous patrons to order salty snacks and sugary drinks to their increasingly-stressed heart's content.\n\nBut selling snacks to hungry hungry patrons requires supplies, and sometimes the different snack bars might run out of them. Let's imagine a system in which the different concession stands can talk to each other, communicating what supplies they need and who might have them. We can model this system using the Mediator pattern.\n\nFirst, we'll need a Mediator interface, which defines a method by which the snack bars can talk to each other:\n\n\n\nWe also need an abstract class to represent the Components that will be talking to one another:\n\n\n\nNow let's implement the different Components. In this case, we have two snack bars: one selling hotdogs and one selling french fries.\n\n\n\nNote that each Component must be aware of the Mediator that is mediating the snack bar's messages.\n\nFinally, we can implement the ConcreteMediator class, which will keep a reference to each Component and manage communication between them.\n\n\n\nIn our method, we can use our Mediator to simulate a conversation between two snack bars. Suppose that one of the snack bars has run out of cooking oil and needs to know if the other has extra that they're not using:\n\n\n\nIf we run this application, we'll see a conversation between the two snack stands:\n\nThe MediatR library describes itself as a Simple mediator implementation in .NET. MediatR is essentially a library that facilitates in-process messaging.\n\nFirst, we need to install the MediatR NuGet package. So from our package manager console, we can run:\n\n\n\nWe'll also need a package of extensions that allows us to use the .NET Core in-built IoC container.\n\n\n\nNext, we need to setup our MediatR dependencies:\n\n\n\nMediatR has two messaging types. We can use either send and receive messaging or broadcast messaging. In this example, we are going to simulate a very simple health check system, where the client pings a server, and if the server is up and running will pong the client.\n\nFirst, we are going to implement a simple class that will implement the interface.\n\n\n\nNext, we need a handler for the message. To do that we just need to implement the interface.\n\n\n\nFinally, we are going to create a runner class that will call our Mediator service. The method starts by using the writer instance to write the text \"Sending Ping...\" to the output stream. Then, it calls the Send method of the mediator instance and passes a new instance of the Ping class with the message \"Ping\" The Send method sends the Ping message to the Handler that should handle it, and then returns the answer:\n\n\n\nFinally, we need our main method to run everything.\n\nThe method makes a new object and adds the object and the library to it. Then, it makes a new instance and retrieves the instance from the provider.\n\nAt the start of the method, a new instance of the class is created. This class wraps the stream. Then, it calls the method and gives the writer instance as an argument to make a new instance.\n\nFinally, the method calls the method, passing in the instance and the writer instance, to run the message through the mediator and write the result to the output stream.\n\n\n\nRunning all of this and opening our debug console, we will get the following:\n\nThe difference between the Mediator and the Observer pattern is often elusive. In most cases, we can implement either of these patterns; but there are cases where we can implement both.\n\nThe primary goal of the Mediator is to eliminate dependencies among a set of components. These components instead become dependent on a single mediator object. The primary goal of the Observer, on the other hand, is to establish dynamic one-way connections between objects, where some objects act as subordinates of others.\n\nOne popular implementation of the Mediator pattern relies on the Observer pattern. The mediator plays the role of the publisher and the components act as subscribers to the mediator events. When the Mediator is implemented this way, it looks very similar to the Observer pattern.\n\nWhen you are confused about whether you have a Mediator or an Observer remember that the Mediator can be implemented differently. For example, you can permanently link all components to the same mediator object. This implementation won't resemble the Observer pattern but will still be an instance of the Mediator pattern.\n\nNow if you have a program where all components are publishers, allowing dynamic connections between each other, you have a distributed set of Observers, since there is no centralized Mediator object.\n• Chain of Responsibility, Command, Mediator and Observer are patterns that address various ways of connecting senders and receivers of requests.\n• The Chain of Responsibility pattern passes a request sequentially along a dynamic chain of receivers until one of them handles it\n• The Command pattern establishes unidirectional communication channels between senders and receivers\n• The Mediator pattern eliminates direct connections between senders and receivers, forcing them to communicate indirectly via the mediator object.\n• The Observer pattern lets receivers dynamically subscribe to and unsubscribe from receiving requests.\n\nIn this article, we have discussed what is the Mediator pattern, when to use it and what are the pros and cons of using this design pattern. We also examined the popular MediatR library and how the Mediator pattern relates to other classic design patterns.\n\nThe Mediator design pattern greatly reduces coupling and improves object interaction in your software application.\n\nIt is a useful tool for solving many common software design problems. The Mediator pattern can help improve your software’s maintainability and extensibility. It decouples objects and provides a central point for interaction logic.\n\nThe Mediator design pattern is helpful in many ways and is quite flexible if appropriately used. However, it's worth noting that the Mediator pattern, along with the rest of the design patterns presented by the Gang of Four, is not a panacea or a be-all-end-all solution when designing an application. Once again it's up to the engineers to consider when to use a specific pattern. After all these patterns are useful when used as a precision tool, not a sledgehammer."
    },
    {
        "link": "https://dofactory.com/net/mediator-design-pattern",
        "document": "A visualization of the classes and objects participating in this pattern.\n\nThe classes and objects participating in this pattern include:\n• Mediator ( )\n• defines an interface for communicating with Colleague objects\n• ConcreteMediator ( )\n• knows and maintains its colleagues\n• Colleague classes ( )\n• each Colleague class knows its Mediator object\n• each colleague communicates with its mediator whenever it would have otherwise communicated with another colleague\n\nThis structural code demonstrates the Mediator pattern facilitating loosely coupled communication between different objects and object types. The mediator is a central hub through which all interaction must take place.\n\nColleague2 gets message: How are you?\n\n Colleague1 gets message: Fine, thanks\n\n\n\nThis real-world code demonstrates the Mediator pattern facilitating loosely coupled communication between different Participants registering with a Chatroom. The Chatroom is the central hub through which all communication takes place. At this point only one-to-one communication is implemented in the Chatroom, but would be trivial to change to one-to-many.\n\nTo a Beatle: Yoko to John: 'Hi John!'\n\n To a Beatle: Paul to Ringo: 'All you need is love'\n\n To a Beatle: Ringo to George: 'My sweet Lord'\n\n To a Beatle: Paul to John: 'Can't buy me love'\n\n To a non-Beatle: John to Yoko: 'My sweet love'\n\n\n\nThe .NET optimized code demonstrates the same code as above but uses more modern C# and .NET features.\n\n\n\n Here is an elegant C# Mediator solution.\n\nTo a Beatle: Yoko to John: 'Hi John!'\n\n To a Beatle: Paul to Ringo: 'All you need is love'\n\n To a Beatle: Ringo to George: 'My sweet Lord'\n\n To a Beatle: Paul to John: 'Can't buy me love'\n\n To a non-Beatle: John to Yoko: 'My sweet love'"
    },
    {
        "link": "https://medium.com/codenx/mediator-pattern-explained-with-c-f0562cbce880",
        "document": "The Mediator pattern is a behavioral design pattern that aims to minimize complex dependencies among objects. This pattern limits direct communication between entities, compelling them to interact solely through a mediator object.\n\nAccording to the Mediator pattern, direct communication between components that should remain independent should be discontinued. Instead, these components should communicate indirectly by invoking a dedicated mediator object. The mediator object, in turn, manages and directs the communication to the relevant components. Consequently, the components rely on a single mediator class, avoiding tight coupling with each other.\n\nExample real world uses cases for Mediator Pattern\n• Chat Application — An exemplary use case of the mediator design pattern is illustrated in a chat application. In this scenario, numerous participants are involved, and establishing direct connections between each participant could compromise privacy, security, and escalate the complexity of connections. A more secure and efficient alternative is to employ a central mediator class, acting as a hub where all participants can connect.\n• Air Traffic Control — An analogous real-world scenario showcasing the mediator design pattern is found in the traffic control rooms at airports. If every flight were to communicate directly with one another to coordinate arrivals, it would be chaotic. Instead, flights transmit their status to the central tower. The tower, serving as the mediator, orchestrates the signals to determine the feasibility of takeoffs or landings. It’s crucial to note that these towers don’t exert control over the entire flight but rather impose restrictions within terminal areas.\n• Component: Components encompass diverse classes housing distinct business logic. Each component holds a reference to a mediator, as declared through the mediator interface. The component remains unaware of the specific mediator class, allowing for reusability by associating it with a different mediator. Components should operate without knowledge of other components. If a significant event occurs within or involving a component, it must inform the mediator. Upon receiving the notification, the mediator can discern the sender’s identity, enabling it to determine which component should be activated.\n• Mediator: The Mediator interface outlines communication methods with components, primarily featuring a notification method. Components can provide any context as arguments for this method, including their objects, ensuring that no direct coupling ensues.\n• Concrete Mediator: Concrete Mediators encapsulate relationships among various components. They typically retain references to all managed components and, at times, oversee their lifecycles.\n\nBelow is sample of Mediator interface.\n\nBelow is sample of Components, which our case are Users\n\nBelow is sample of Concrete Mediator nothing but chat application\n\nBelow is program for demonstrating chat application using Mediator Pattern\n• Principle of Single Responsibility: It simplifies communication paths among multiple components by consolidating them into a single location, enhancing clarity and manageability.\n• Principle of Open/Closed: Additional mediators can be added without altering the existing components.\n• Reuse of Individual Components: It avoids sub-classing by directing actions that would otherwise be dispersed among various objects. Colleague classes can be reused without modifications.\n• Simplicity: Components can be replaced without modifying classes or interfaces.\n• Centralization of Control: While it reduces interaction complexity, a mediator may become more intricate than individual colleagues, potentially becoming a challenging-to-maintain monolith.\n• Complexity: The mediator handles all interactions among participants’ objects, leading to potential complexity issues, especially with many participants and diverse participant classes.\n• Difficult to Maintain: The centralized and complex nature of a mediator makes it challenging to maintain over time."
    },
    {
        "link": "https://dotnettutorials.net/lesson/mediator-design-pattern",
        "document": "Back to: Design Patterns in C# With Real-Time Examples\n\nMediator Design Pattern in C# with Real-Time Examples\n\nIn this article, I will discuss the Mediator Design Pattern in C# with Real-Time Examples. Please read our previous article discussing the Interpreter Design Pattern in C# with Examples. The Mediator Design Pattern falls under the category of Behavioral Design Pattern. As part of this article, we will discuss the following pointers in detail.\n• None What is the Mediator Design Pattern?\n• Real-Time Example of Mediator Design Pattern – Facebook Group and ATC\n• Implementing the Mediator Design Pattern in C#\n• Understanding the Class or UML Diagram of Mediator Design Pattern\n• When to Use Mediator Design Pattern in C#?\n\nWhat is the Mediator Design Pattern?\n\nAccording to the Gang of Four definitions, define an object that encapsulates how a set of objects interact with each other. Mediator promotes loose coupling by keeping objects from explicitly referring to each other and letting you vary their interaction independently.\n\nThe Mediator Design Pattern reduces the communication complexity between multiple objects. This design pattern provides a mediator object, which will be responsible for handling all the communication complexities between different objects.\n\nThe Mediator Design Pattern restricts direct communications between the objects and forces them to collaborate only via a mediator object. This pattern is used to centralize complex communications and control between related objects in a system. The Mediator object acts as the communication center for all objects. That means when an object needs to communicate with another object, it does not call the other object directly. Instead, it calls the mediator object, and it is the responsibility of the mediator object to route the message to the destination object.\n\nLet us understand the Mediator Design Pattern in C# with an Example. Please have a look at the following diagram. As shown in the diagram below, we have four objects (Object A, Object B, Object C, and Object D). And these four objects want to communicate with each other. Suppose Object A wants to communicate with Object B, then Object A should know the reference of Object B, and using that reference, Object A can call the method of Object B. Similarly if Object B wants to send some message to Object C. It should know the reference of Object C, and using that reference, it will call the methods of Object C and send the message.\n\nThe couplings between the objects are more, i.e., tight coupling. A lot of object knows each other. Now, in the above image, four objects are there. In real-time, you may have thousands of objects, and those thousands of objects want to communicate with each other. Then, writing code and maintaining code is very difficult.\n\nHow do we Reduce the Coupling Between the Objects?\n\nUsing the Mediator Design Pattern, we can reduce the coupling between objects. To understand this, please have a look at the following diagram. As shown in the image below, here we introduce the Mediator object. Each object has to send messages to the mediator object. The mediator object here will receive the message from each object and route that message to the destination object. So, the mediator object will take care of handling the messages. So, in this scenario, we can use the Mediator Design Pattern.\n\nPlease have a look at the following diagram. Nowadays, everybody is aware of Facebook. On Facebook, we can create some specific groups; in those groups, people can join and share their knowledge. On Facebook, there is a group called Dot Net Tutorials, and in that group, many people (such as Ram, Sam, Pam, Dave, Steve, Anurag, etc.) are joined. Ram is sharing some messages in the Dot Net Tutorials group. Then, what this Facebook Group (Dot Net Tutorials) will do is it will send that message to all the members who have joined this group. So, here, the Facebook group is acting as a Mediator.\n\nImplementing Mediator Design Pattern Real-Time Example in C#:\n\nLet us first implement the above Facebook Example using the Mediator Design Pattern in C# step by step. Then, we will understand the UML or Class Diagram of the Mediator Design Pattern by comparing it with our Example so that you can easily understand the different components involved in the Mediator Design Pattern.\n\nThis will be an Interface that defines operations that colleague objects can call for communication. So, Create an interface named FacebookGroupMediator.cs and copy and paste the following code. This interface declares two abstract methods (i.e., SendMessage and RegisterUser).\n\nThis will be a class implementing the communication operations of the Mediator Interface. So, Create a class file named ConcreteFacebookGroupMediator.cs and then copy and paste the following code. This class implements the FacebookGroupMediator interface and provides implementations for the SendMessage and RegisterUser abstract methods. The RegisterUser method will add the user to the particular Facebook group, i.e., adding the user to the UsersList variable. On the other hand, whenever any user shares any message in the group, the SendMessage method will receive that message, and it will send that message to all the users who are registered in the group except the user who shares the message.\n\nThis will be an abstract class that defines a property that holds a reference to a mediator. So, create an abstract class named User.cs and copy and paste the following code. This abstract class has two abstract methods, i.e., Send and Receive.\n\nThese are the classes that communicate with each other via the mediator. Create a class file named ConcreteUser.cs and copy and paste the following code. This is a concrete class that implements the User abstract class and provides the implementation for the Send and Receive abstract methods. The Send method sends a message to a particular Facebook group. The Receive method receives a message from a particular Facebook group.\n\nThe Main method of the Program class is going to be the client. So, please modify the Main method of the Program class as shown below. Here, we create the FacebookGroupMediator object, create several Facebook users, and then register all the users to the mediator object. Then, we send a message to the Mediator using the Dave and Rajesh user. The following client code is self-explained, so please go through the comment lines for a better understanding.\n• None When a set of objects communicate in well-defined but complex ways, and you want to centralize this communication to make it more manageable and understandable.\n• None In a system where multiple classes interact, but the interactions are unstructured or complex.\n\nUnderstanding the Class or UML Diagram of Mediator Design Pattern in C#:\n\nLet us understand the Class Diagram or UML Diagram of the Mediator Design Pattern in C# and the components involved. Please have a look at the following image.\n\nAs shown in the above UML or Class Diagram, four participants are involved in the Mediator Design Pattern in C#. Their role and responsibilities are as follows:\n• None Mediator: This will be an Interface that defines the operations that colleague objects can call for communication. In our example, it is the IFacebookGroupMediator Interface.\n• None ConcreteMediator: This class will implement the communication operations of the Mediator Interface. In our example, it is the ConcreteFacebookGroupMediator class.\n• None Colleague: It is an abstract class, and Concrete Colleague classes will implement this abstract class. In our example, it is the User abstract class.\n• None ConcreteColleage1 / ConcreteColleage2: These are classes that implement the Colleague interface. If a concrete colleague (let’s say ConcreteColleage1) wants to communicate with another concrete colleague (let’s say ConcreteColleage2), they will not communicate directly; instead, they will communicate via the ConcreteMediator. In our example, it is the ConcreteUser class.\n\nATC stands for Air Traffic Control. The ATC mediator is nothing but the Air Traffic Control Tower, which is available at the Airport. Please have a look at the following image. Here, you can see different flights (such as Flight 101, Flight 202, Flight 707, and Flight 808).\n\nSuppose Flight 101 wants to land at a particular terminal in the Airport. Then, the Flight Pilot will communicate with the ATC Mediator and say he wants to land Flight 101 at the particular airport terminal. Then, the ATC Mediator will check whether any flight is at that particular terminal. If no flight is there, then what the ATC mediator will do is it will send a message to Pilots of other flights saying that Flight 101 is going to land and you should not land at that particular terminal. Then, the ATC mediator sends a message to the Flight 101 pilot, saying you can land your flight at the particular airport terminal. Once the Flight 101 pilot gets the ATC Mediator’s confirmation message, he will land the flight at that terminal.\n\nSo, here, the ATC mediator will act as a central point, and all flights should communicate with the ATC mediator. So, what the ATC mediator will do is it will receive the message and route the message to the appropriate destinations. Here, destinations are flights.\n\nNote: The pilots of the planes that are approaching or departing the terminal area communicate with the tower rather than explicitly communicating with one another. The tower enforces the constraints on who can take off or land. It is important to note that the tower does not control the whole flight. It exists only to enforce constraints in the terminal area.\n• None Reduced Complexity: It centralizes complex communications and controls logic between objects in a system.\n• None Decoupled Objects: Colleague objects are less coupled to each other, which increases maintainability and reusability.\n• None Simplified Object Protocols: Objects no longer communicate directly with each other but instead through a mediator, simplifying their interaction protocols.\n• None Centralized Control: The mediator encapsulates the logic for how objects interact, making it easier to change the logic independently of the colleague classes.\n\nWhen to Use Mediator Design Pattern in C#?\n\nThe Mediator Design Pattern in C# is particularly useful in scenarios where:\n• None Reducing Class Interdependencies: When you have a set of classes that communicate directly with each other in complex ways, leading to high coupling and dependencies. The Mediator pattern centralizes this communication in a mediator object, reducing direct class-to-class dependencies.\n• None Simplifying Object Communication: If an application has numerous components or objects that need to interact, but you want to avoid having them communicate directly in a tightly coupled manner. A mediator can act as a hub for communication and simplify interactions.\n• None Reusing Components: When you need to reuse components in different contexts or frameworks, and the direct communication between components would hinder this reusability. The mediator makes each component more modular and easier to reuse.\n• None Implementing Complex Communication Logic: In scenarios where the communication logic between objects is complex and needs to be centralized. The mediator encapsulates this logic, making it easier to maintain and update.\n• None Decoupling Components in a GUI Application: In GUI applications, for managing complex interactions between various GUI components without them needing to know about each other, thus making them easier to manage and extend.\n• None Changing Behavior Dynamically: When the behavior of an application needs to change dynamically based on certain conditions. A mediator can orchestrate these changes more efficiently by controlling the interaction between objects.\n• None Creating an Extensible Framework: In the development of frameworks where you expect future extensions and modifications and where having a central point of control or communication would be beneficial.\n\nIn the next article, I will discuss the Real-Time Examples of the Mediator Design Pattern in C#. Here, in this article, I try to explain the Mediator Design Pattern in C# with Real-Time Examples. I hope you now understand the need and use of the Mediator Design Pattern in C# with Real-Time Examples."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/events",
        "document": "Events in .NET are based on the delegate model. The delegate model follows the observer design pattern, which enables a subscriber to register with and receive notifications from a provider. An event sender pushes a notification when an event occurs. An event receiver defines the response. This article describes the major components of the delegate model, how to consume events in applications, and how to implement events in your code.\n\nAn event is a message sent by an object to signal the occurrence of an action. The action might be user interaction, such as a button press, or it might result from other program logic, such as a property value change. The object that raises the event is called the event sender. The event sender doesn't know the object or method that receives (handles) the events it raises. The event is typically a member of the event sender. For example, the Click event is a member of the Button class, and the PropertyChanged event is a member of the class that implements the INotifyPropertyChanged interface.\n\nTo define an event, you use the C# event or the Visual Basic Event keyword in the signature of your event class, and specify the type of delegate for the event. Delegates are described in the next section.\n\nTypically, to raise an event, you add a method that is marked as and (in C#) or and (in Visual Basic). The naming convention for the method is , such as . The method should take one parameter that specifies an event data object, which is an object of type EventArgs or a derived type. You provide this method to enable derived classes to override the logic for raising the event. A derived class should always call the method of the base class to ensure registered delegates receive the event.\n\nThe following example shows how to declare an event named . The event is associated with the EventHandler delegate and raised in a method named :\n\nA delegate is a type that holds a reference to a method. A delegate is declared with a signature that shows the return type and parameters for the methods it references. It can hold references only to methods that match its signature. A delegate is equivalent to a type-safe function pointer or a callback. A delegate declaration is sufficient to define a delegate class.\n\nDelegates have many uses in .NET. In the context of events, a delegate is an intermediary (or pointer-like mechanism) between the event source and the code that handles the event. You associate a delegate with an event by including the delegate type in the event declaration, as shown in the example in the previous section. For more information about delegates, see the Delegate class.\n\n.NET provides the EventHandler and EventHandler<TEventArgs> delegates to support most event scenarios. Use the EventHandler delegate for all events that don't include event data. Use the EventHandler<TEventArgs> delegate for events that include data about the event. These delegates have no return type value and take two parameters (an object for the source of the event and an object for event data).\n\nDelegates are multicast class objects, which means they can hold references to more than one event-handling method. For more information, see the Delegate reference page. Delegates provide flexibility and fine-grained control in event handling. A delegate acts as an event dispatcher for the class that raises the event by maintaining a list of registered event handlers for the event.\n\nUse the EventHandler and EventHandler<TEventArgs> delegate types to define the needed delegate. You mark a delegate with the type in [C#]](../../csharp/language-reference/builtin-types/reference-types.md#the-delegate-type) or the type in Visual Basic in the declaration. The following example shows how to declare a delegate named :\n\nData associated with an event can be provided through an event data class. .NET provides many event data classes that you can use in your applications. For example, the SerialDataReceivedEventArgs class is the event data class for the SerialPort.DataReceived event. .NET follows a naming pattern where all event data classes end with the suffix. You determine which event data class is associated with an event by looking at the delegate for the event. For example, the SerialDataReceivedEventHandler delegate includes the SerialDataReceivedEventArgs class as a parameter.\n\nThe EventArgs class is typically the base type for event data classes. You also use this class if an event doesn't have any data associated with it. When you create an event that notifies subscribers that something happened without any additional data, include the EventArgs class as the second parameter in the delegate. You can pass the EventArgs.Empty value when no data is provided. The EventHandler delegate includes the EventArgs class as a parameter.\n\nYou can create a class that derives from the EventArgs class to provide any members needed to pass data related to the event. Typically, you should use the same naming pattern as .NET and end your event data class name with the suffix.\n\nThe following example shows an event data class named that contains properties that are specific to the event being raised:\n\nTo respond to an event, you define an event handler method in the event receiver. This method must match the signature of the delegate for the event you're handling. In the event handler, you perform the actions that are required when the event is raised, such as collecting user input after the user presses a button. To receive notifications when the event occurs, your event handler method must subscribe to the event.\n\nThe following example shows an event handler method named that matches the signature for the EventHandler delegate. The method subscribes to the event:\n\n.NET allows subscribers to register for event notifications either statically or dynamically. Static event handlers are in effect for the entire life of the class whose events they handle. Dynamic event handlers are explicitly activated and deactivated during program execution, usually in response to some conditional program logic. You can use dynamic handlers when event notifications are needed only under certain conditions, or when run-time conditions determine the specific handler to call. The example in the previous section shows how to dynamically add an event handler. For more information, see Events (in Visual Basic) and Events (in C#).\n\nIf your class raises multiple events, the compiler generates one field per event delegate instance. If the number of events is large, the storage cost of one field per delegate might not be acceptable. For these scenarios, .NET provides event properties that you can use with another data structure of your choice to store event delegates.\n\nEvent properties consist of event declarations accompanied by event accessors. Event accessors are methods that you define to add or remove event delegate instances from the storage data structure.\n\nThe trade-off is between memory and speed. If your class defines many events that are infrequently raised, you should implement event properties. For more information, see Handle multiple events by using event properties.\n\nThe following resources describe other tasks and concepts related to working with events:\n• Raise and consume events: Find examples for raising and consuming events.\n• Handle multiple events with event properties: Discover how to use event properties to handle multiple events.\n• Explore the observer design pattern: Review a design pattern that enables a subscriber to register with and receive notifications from a provider.\n\nSpecification reference documentation is available for the APIs that support event handling:"
    },
    {
        "link": "https://stackoverflow.com/questions/16776787/static-public-events",
        "document": "It's bad because your listener objects (those are bound to those static events) will never be garbage-collected and you should avoid static events at all. That's why Weak Event Pattern born. Although I am not saying that you need to use that pattern (because I am not well informed about your app internals) but reading about this pattern would help you to design your app more carefully.\n\nThere is an (old yet useful) article on the matter. Again I am not saying you should use this pattern; I am saying studying this pattern will show you why static events are not a good idea."
    },
    {
        "link": "https://medium.com/codenx/implement-mediator-pattern-with-mediatr-in-c-8a271d7b9901",
        "document": "In this blog, we’ll explore the implementation of the mediator pattern in C#. To grasp the concept of the mediator pattern and its use cases, I recommend reading my previous blog.\n\nAs discussed in the previous blog, incorporating a mediator into an application can lead to increased complexity over time. For smaller applications, employing numerous design patterns may introduce unnecessary intricacies. However, as the application expands, accumulating business logic and adhering to principles like KISS (Keep It Simple, Stupid) and DRY (Don’t Repeat Yourself) may involve making direct calls between services or managers. While dependency injection can address tight coupling, it may still result in classes becoming cumbersome with various dependencies.\n\nThis is where the Mediator Pattern proves beneficial. In the context of business logic, each component communicates with the mediator, and the mediator takes on the responsibility of facilitating communication between different components. Another scenario where the mediator pattern finds utility is in .NET controllers. Instead of injecting all managers into controllers, you can simply inject a mediator, allowing it to handle communication with other managers.\n\nLot of times people hear mediator pattern used with CQRS and assume that for CQRS needs mediator pattern. That is not true you can implement CQRS without mediator pattern as well. Just using mediator pattern in CQRS reduces the coupling between command/queries and handlers. We will see CQRS and Event sourcing example in future blog.\n\nMediatR is a .NET implementation of the Mediator pattern that offers support for both synchronous and asynchronous requests/responses, commands, queries, notifications, and events. It employs intelligent dispatch using C# generic variance. Simplifying the adoption of the Command Query Responsibility Segregation (CQRS) pattern, MediatR provides a straightforward approach to managing command and query handlers. Functioning as a mediator, MediatR efficiently directs commands and queries to their designated handlers.\n• Decoupling: MediatR facilitates the separation of the request sender (command or query) from its recipient (handler), contributing to more maintainable and modular code.\n• Pipeline Behaviors: It accommodates the incorporation of pipeline behaviors, allowing for the easy addition of cross-cutting concerns like validation, logging, and authentication.\n• Automatic Handler Discovery: MediatR possesses the capability to automatically identify and register handlers, reducing the need for explicit configuration.\n\nLet’s explore the functionality of MediatR in C# by constructing a sample Customer API within an e-commerce application. In this context, we will refer to commands and queries as requests, and the corresponding classes responsible for handling them will be termed handlers.\n\nFor this we will create 2 projects, one is called MediatRAPI which will server Customer API. Another class library called MediatRHandlers where we configure requests and request handlers. Also install MediatR nuget package using below command.\n\nLet us create two requests as shown below for creating a Customer and retrieving the Customer by Customer Id\n\nFor each of the above requests create handlers as shown below.\n\nCreate a Customer Controller as shown below, if you notice we are not injecting all the handlers instead we are injecting only the mediator.\n\nRegister the MediatR registrations in program or start up file as shown below.\n\nOnce hit run for the API project you will see Customer API swagger, where you can test create customer and get customer as shown below.\n\nIt is crucial to thoroughly evaluate the pros and cons of the Mediator pattern before incorporating it into your project. Although it can serve as a robust solution for orchestrating communication between objects in your system, it may not be the optimal choice for every scenario."
    },
    {
        "link": "https://medium.com/c-sharp-programming/domain-events-2782ff03154d",
        "document": "Domain events are events that occur in a specific area or domain and are important for the business logic of an application. They represent significant state changes or activities within the system. In contrast to system-wide events, which can affect the entire application, domain events are closely linked to the specific domain or specialist area of your application.\n\nDomain events play a crucial role in the implementation of domain-driven design (DDD), an approach to developing complex software applications that focuses on the domain and its rules. They enable the mapping of real processes and events in the software and support a clearly structured and modularized architecture.\n\nBy using domain events, different parts of your application can work independently of each other as they only communicate via events without having to access each other directly.\n\nDomain Events serve as a log of important events in your application, facilitating traceability of activities and providing the ability to meet auditing and compliance requirements.\n\nBy using Domain Events, your application can be made more flexible and extensible as changes in the domain can be implemented more easily and existing functionality can be modified without affecting other parts of the application.\n\nUsing domain events improves the modularity of your application, as individual components are loosely coupled and can work independently of each other. This also facilitates scalability, as you can add or remove individual components as required without significantly changing the overall structure of your application.\n\nDomain events support the separation of domain logic and infrastructure by ensuring that your domain objects have no direct dependencies on external systems or frameworks. This leads to a cleaner and more maintainable code base.\n\nDomain events are a core element of domain-driven design and enable you to map the technical language of your domain directly in your software. This promotes a common understanding between developers and domain experts and leads to a better alignment of the software with the real requirements of your domain.\n\nIdentification of relevant events in the domain:\n\nBefore you can implement domain events, it is important to identify the relevant events in your domain. These events should represent significant state changes or activities within your application that are of interest to other parts of the system.\n\nFor each domain event identified, you should create a corresponding event class that contains the relevant information about the event. These classes can also implement interfaces to enable consistent handling and processing of events.\n\nTo use domain events in your application, you need to implement mechanisms for publishing and subscribing to events. This can be done, for example, by using event buses or brokers that allow different parts of your application to react to events and act accordingly.\n\nUse of event buses or brokers:\n\nTo integrate domain events in your application, you can use event buses or brokers. These components enable the central administration and distribution of events to the corresponding recipients within your application. Examples of event busses are RabbitMQ, Kafka or simple in-memory event busses.\n\nWhen integrating domain events, it is important to consider the handling of errors and the consideration of transaction boundaries. You should ensure that events are processed atomically and that no data inconsistencies occur, especially in the case of failed transactions.\n\nFor reliable integration of domain events, it is essential to develop appropriate testing strategies. This includes testing event generation, publication and processing as well as testing scenarios with faulty event processing to ensure the robustness of your application.\n\nTo illustrate the use of domain events in a practical application, let’s look at an example from the field of e-commerce: order processing. In this scenario, various events can occur that can be represented by domain events, e.g:\n\nWhen the status of an order changes, e.g. from “placed” to “paid”, corresponding domain events can be triggered and published. These events can be subscribed to by other parts of the application in order to react to changes and perform corresponding actions, e.g. updating the stock or sending a confirmation email to the customer.\n\nRespond to events to update other components:\n\nDomain events allow different components of your application to react to state changes and communicate with each other without having direct dependencies. This improves the flexibility and extensibility of your application and promotes a modular architecture.\n\nIt is advisable to use consistent naming conventions for your domain events to ensure uniform and easy-to-understand naming. Use meaningful and precise names that clearly reflect the content and meaning of the event.\n\nDocumentation of events and their payloads:\n\nTo facilitate the use of domain events and encourage collaboration between developers, it is important to document events and their payloads appropriately. Describe the purpose of each event as well as the data fields it contains and their meaning.\n\nTo ensure the reliability and performance of your application, you should monitor and log event-based operations appropriately. This includes logging event publications, receptions and processing as well as monitoring system metrics and error messages.\n\nBy applying these best practices, you can improve the effectiveness and robustness of your application and ensure that domain events are used efficiently and reliably.\n\nIn this example, MediatR is used to manage the commands and events. The `CreateOrderCommandHandler` is responsible for processing the command to create an order and then triggers the domain event “Order created”. The `OrderCreatedEventHandler` reacts to this event and executes corresponding actions.\n\nThis example shows how CQRS and domain events can be used together with MediatR in an application."
    },
    {
        "link": "https://dev.to/kalkwst/mediator-pattern-in-c-4i3p",
        "document": "The Mediator is a behavioural design pattern that lets us reduce chaotic dependencies between objects. The pattern restricts direct communications between the entities and forces them to collaborate only via a mediator object.\n\nYou can find the example code of this post, on GitHub\n\nLet's say we have a user interface dialogue for creating and editing a customer profile. It consists of various form controls such as text fields, checkboxes, buttons, tabs, etc.\n\nSome of the form elements may interact with others. For instance, selecting the \"I have a roommate\" checkbox may reveal a hidden text field for entering the roommate's name. Another example is the submit button that triggers the validation of values of all fields before submitting the data.\n\nBy having this logic implemented directly by the form elements, we make these elements much harder to reuse in other parts of the application. For example, we won't be able to use that checkbox on another form, since it's coupled to the roommate's text field. We can either use all the classes involved in rendering on the profile form, or none at all.\n\nThe Mediator pattern suggests that we should cease all direct communication between the components that should be independent of each other. Instead, these components must communicate indirectly, by calling a special mediator object. This mediator object will redirect the calls to the appropriate components. As a result, the components only depend on a single mediator class instead of being coupled to each other.\n\nIn our example, the dialogue class may act as the mediator. Most likely, the dialogue class is already aware of all of its sub-elements, so we won't even need to introduce new dependencies into this class.\n\nThe most significant change happens to the actual form elements. Consider the submit button. With the previous implementation, each time a user clicked the button, it had to validate the values of every form element. Now its single job is to notify the dialogue about the click. Upon receiving this notification, the dialogue itself performs the validation or passes the task to the individual elements. Thus instead of being coupled with dozens of elements, the button is only dependent on the dialogue class.\n\nWe can make the dependency even looser by extracting the common interface for all types of dialogues. The interface would declare the notification method that all form elements can use to notify the dialogue about events triggered by those elements. Thus, our submit button should now be able to work with any dialogue that implements that interface.\n\nThis way, the Mediator pattern lets us encapsulate a complex web of relations between various objects inside a single mediator object. The fewer dependencies a class has, the easier it becomes to modify, extend or reuse that class.\n\nIn its base implementation, the Mediator pattern has three participants:\n• Component: The Components are various classes that contain some business logic. Each component has a reference to a mediator, declared through the mediator interface. The component isn't aware of the actual class of the mediator, so we can reuse the component by linking it to a different mediator. Components must not be aware of other components. If something important happens within or to a component, it must notify the mediator. When the mediator receives the notification, it can identify the sender, which is enough to decide what component should be triggered.\n• Mediator: The Mediator interface declares methods of communication with components, which most of the time include just a single notification method. Components may pass any context as arguments of this method, including their objects, but only in such a way that no coupling can occur.\n• Concrete Mediator: The Concrete Mediators encapsulate relations between various components. Concrete mediators often keep references to all components they manage and sometimes even manage their lifecycles.\n\nTo demonstrate how the Mediator pattern works, we are going to model the snack bars in big amusement parks.\n\nAmusement parks usually have a somewhat centralized food court with some snack bars and several smaller establishments peppered around, for gluttonous patrons to order salty snacks and sugary drinks to their increasingly-stressed heart's content.\n\nBut selling snacks to hungry hungry patrons requires supplies, and sometimes the different snack bars might run out of them. Let's imagine a system in which the different concession stands can talk to each other, communicating what supplies they need and who might have them. We can model this system using the Mediator pattern.\n\nFirst, we'll need a Mediator interface, which defines a method by which the snack bars can talk to each other:\n\n\n\nWe also need an abstract class to represent the Components that will be talking to one another:\n\n\n\nNow let's implement the different Components. In this case, we have two snack bars: one selling hotdogs and one selling french fries.\n\n\n\nNote that each Component must be aware of the Mediator that is mediating the snack bar's messages.\n\nFinally, we can implement the ConcreteMediator class, which will keep a reference to each Component and manage communication between them.\n\n\n\nIn our method, we can use our Mediator to simulate a conversation between two snack bars. Suppose that one of the snack bars has run out of cooking oil and needs to know if the other has extra that they're not using:\n\n\n\nIf we run this application, we'll see a conversation between the two snack stands:\n\nThe MediatR library describes itself as a Simple mediator implementation in .NET. MediatR is essentially a library that facilitates in-process messaging.\n\nFirst, we need to install the MediatR NuGet package. So from our package manager console, we can run:\n\n\n\nWe'll also need a package of extensions that allows us to use the .NET Core in-built IoC container.\n\n\n\nNext, we need to setup our MediatR dependencies:\n\n\n\nMediatR has two messaging types. We can use either send and receive messaging or broadcast messaging. In this example, we are going to simulate a very simple health check system, where the client pings a server, and if the server is up and running will pong the client.\n\nFirst, we are going to implement a simple class that will implement the interface.\n\n\n\nNext, we need a handler for the message. To do that we just need to implement the interface.\n\n\n\nFinally, we are going to create a runner class that will call our Mediator service. The method starts by using the writer instance to write the text \"Sending Ping...\" to the output stream. Then, it calls the Send method of the mediator instance and passes a new instance of the Ping class with the message \"Ping\" The Send method sends the Ping message to the Handler that should handle it, and then returns the answer:\n\n\n\nFinally, we need our main method to run everything.\n\nThe method makes a new object and adds the object and the library to it. Then, it makes a new instance and retrieves the instance from the provider.\n\nAt the start of the method, a new instance of the class is created. This class wraps the stream. Then, it calls the method and gives the writer instance as an argument to make a new instance.\n\nFinally, the method calls the method, passing in the instance and the writer instance, to run the message through the mediator and write the result to the output stream.\n\n\n\nRunning all of this and opening our debug console, we will get the following:\n\nThe difference between the Mediator and the Observer pattern is often elusive. In most cases, we can implement either of these patterns; but there are cases where we can implement both.\n\nThe primary goal of the Mediator is to eliminate dependencies among a set of components. These components instead become dependent on a single mediator object. The primary goal of the Observer, on the other hand, is to establish dynamic one-way connections between objects, where some objects act as subordinates of others.\n\nOne popular implementation of the Mediator pattern relies on the Observer pattern. The mediator plays the role of the publisher and the components act as subscribers to the mediator events. When the Mediator is implemented this way, it looks very similar to the Observer pattern.\n\nWhen you are confused about whether you have a Mediator or an Observer remember that the Mediator can be implemented differently. For example, you can permanently link all components to the same mediator object. This implementation won't resemble the Observer pattern but will still be an instance of the Mediator pattern.\n\nNow if you have a program where all components are publishers, allowing dynamic connections between each other, you have a distributed set of Observers, since there is no centralized Mediator object.\n• Chain of Responsibility, Command, Mediator and Observer are patterns that address various ways of connecting senders and receivers of requests.\n• The Chain of Responsibility pattern passes a request sequentially along a dynamic chain of receivers until one of them handles it\n• The Command pattern establishes unidirectional communication channels between senders and receivers\n• The Mediator pattern eliminates direct connections between senders and receivers, forcing them to communicate indirectly via the mediator object.\n• The Observer pattern lets receivers dynamically subscribe to and unsubscribe from receiving requests.\n\nIn this article, we have discussed what is the Mediator pattern, when to use it and what are the pros and cons of using this design pattern. We also examined the popular MediatR library and how the Mediator pattern relates to other classic design patterns.\n\nThe Mediator design pattern greatly reduces coupling and improves object interaction in your software application.\n\nIt is a useful tool for solving many common software design problems. The Mediator pattern can help improve your software’s maintainability and extensibility. It decouples objects and provides a central point for interaction logic.\n\nThe Mediator design pattern is helpful in many ways and is quite flexible if appropriately used. However, it's worth noting that the Mediator pattern, along with the rest of the design patterns presented by the Gang of Four, is not a panacea or a be-all-end-all solution when designing an application. Once again it's up to the engineers to consider when to use a specific pattern. After all these patterns are useful when used as a precision tool, not a sledgehammer."
    }
]