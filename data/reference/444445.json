[
    {
        "link": "https://stackoverflow.com/questions/10510462/force-git-push-to-overwrite-remote-files",
        "document": "You should be able to force your local revision to the remote repo by using\n\n(e.g. ). Leaving off and will force push all local branches that have set .\n\nJust be warned, if other people are sharing this repository their revision history will conflict with the new one. And if they have any local commits after the point of change they will become invalid.\n\nUpdate: Thought I would add a side-note. If you are creating changes that others will review, then it's not uncommon to create a branch with those changes and rebase periodically to keep them up-to-date with the main development branch. Just let other developers know this will happen periodically so they'll know what to expect.\n\nUpdate 2: Because of the increasing number of viewers I'd like to add some additional information on what to do when your does experience a force push.\n\nSay I've cloned your repo and have added a few commits like so:\n\nBut later the branch is hit with a , which will cause me to receive an error like so when I run :\n\nHere I could fix the conflicts and , but that would leave me with a really ugly commit history:\n\nIt might look enticing to use but be careful because that'll leave you with stranded commits:\n\nSo probably the best option is to do a . This will require me to resolve any conflicts like before, but for each step instead of committing I'll use . In the end the commit history will look much better:\n\nUpdate 3: You can also use the option as a \"safer\" force push, as mentioned by Cupcake in his answer:\n\nForce pushing with a \"lease\" allows the force push to fail if there are new commits on the remote that you didn't expect (technically, if you haven't fetched them into your remote-tracking branch yet), which is useful if you don't want to accidentally overwrite someone else's commits that you didn't even know about yet, and you just want to overwrite your own: You can learn more details about how to use by reading any of the following:\n• Git: How to ignore fast forward and revert origin [branch] to earlier commit?"
    },
    {
        "link": "https://stackoverflow.com/questions/5509543/how-do-i-properly-force-a-git-push",
        "document": "And if doesn't work you can do . Look at 2nd line on this instance:\n\nNever ever go back on a public git history!\n• Don't do this or anything that can break someone's .\n• Don't ever or history in a repo someone might have already pulled.\n\nOf course there are exceptionally rare exceptions even to this rule, but in most cases it's not needed to do it and it will generate problems to everyone else.\n\nAnd always be careful with what you push to a public repo. Reverting:\n\nIn effect, both origin HEADs (from the revert and from the evil reset) will contain the same files.\n\nedit to add updated info and more arguments around\n\nConsider pushing force with lease instead of push, but still prefer revert\n\nAnother problem may bring is when someone push anything before you do, but after you've already fetched. If you push force your rebased version now you will replace work from others.\n\nintroduced in the git 1.8.5 (thanks to @VonC comment on the question) tries to address this specific issue. Basically, it will bring an error and not push if the remote was modified since your latest fetch.\n\nThis is good if you're really sure a is needed, but still want to prevent more problems. I'd go as far to say it should be the default behaviour. But it's still far from being an excuse to force a . People who fetched before your rebase will still have lots of troubles, which could be easily avoided if you had reverted instead.\n\nAnd since we're talking about instances...\n\nWhy would anyone want to force push?\n\n@linquize brought a good push force example on the comments: sensitive data. You've wrongly leaked data that shouldn't be pushed. If you're fast enough, you can \"fix\" it by forcing a push on top.\n\nThe data will still be on the remote unless you also do a garbage collect, or clean it somehow. There is also the obvious potential for it to be spread by others who'd fetched it already, but you get the idea."
    },
    {
        "link": "https://git-scm.com/docs/git-push",
        "document": "The \"remote\" repository that is the destination of a push operation. This parameter can be either a URL (see the section GIT URLS below) or the name of a remote (see the section REMOTES below). Specify what destination ref to update with what source object. The format of a <refspec> parameter is an optional plus , followed by the source object <src>, followed by a colon , followed by the destination ref <dst>. The <src> is often the name of the branch you would want to push, but it can be any arbitrary \"SHA-1 expression\", such as or (see gitrevisions[7]). The <dst> tells which ref on the remote side is updated with this push. Arbitrary expressions cannot be used here, an actual ref must be named. If without any argument is set to update some ref at the destination with with configuration variable, part can be omitted—​such a push will update a ref that normally updates without any on the command line. Otherwise, missing means to update the same ref as the . If <dst> doesn’t start with (e.g. ) we will try to infer where in on the destination <repository> it belongs based on the type of <src> being pushed and whether <dst> is ambiguous.\n• If <dst> unambiguously refers to a ref on the <repository> remote, then push to that ref.\n• If <src> resolves to a ref starting with refs/heads/ or refs/tags/, then prepend that to <dst>.\n• Other ambiguity resolutions might be added in the future, but for now any other cases will error out with an error indicating what we tried, and depending on the configuration (see git-config[1]) suggest what refs/ namespace you may have wanted to push to. The object referenced by <src> is used to update the <dst> reference on the remote side. Whether this is allowed depends on where in the <dst> reference lives as described in detail below, in those sections \"update\" means any modifications except deletes, which as noted after the next few sections are treated differently. The namespace will only accept commit objects, and updates only if they can be fast-forwarded. The namespace will accept any kind of object (as commits, trees and blobs can be tagged), and any updates to them will be rejected. It’s possible to push any type of object to any namespace outside of . In the case of tags and commits, these will be treated as if they were the commits inside for the purposes of whether the update is allowed. I.e. a fast-forward of commits and tags outside is allowed, even in cases where what’s being fast-forwarded is not a commit, but a tag object which happens to point to a new commit which is a fast-forward of the commit the last tag (or commit) it’s replacing. Replacing a tag with an entirely different tag is also allowed, if it points to the same commit, as well as pushing a peeled tag, i.e. pushing the commit that existing tag object points to, or a new tag object which an existing commit points to. Tree and blob objects outside of will be treated the same way as if they were inside , any update of them will be rejected. All of the rules described above about what’s not allowed as an update can be overridden by adding an the optional leading to a refspec (or using command line option). The only exception to this is that no amount of forcing will make the namespace accept a non-commit object. Hooks and configuration can also override or amend these rules, see e.g. in git-config[1] and and in githooks[5]. Pushing an empty <src> allows you to delete the <dst> ref from the remote repository. Deletions are always accepted without a leading in the refspec (or ), except when forbidden by configuration or hooks. See in git-config[1] and and in githooks[5]. The special refspec (or to allow non-fast-forward updates) directs Git to push \"matching\" branches: for every branch that exists on the local side, the remote side is updated if a branch of the same name already exists on the remote side. means the same as . Push all branches (i.e. refs under ); cannot be used with other <refspec>. Remove remote branches that don’t have a local counterpart. For example a remote branch will be removed if a local branch with the same name doesn’t exist any more. This also respects refspecs, e.g. would make sure that remote will be removed if doesn’t exist. Instead of naming each ref to push, specifies that all refs under (which includes but is not limited to , , and ) be mirrored to the remote repository. Newly created local refs will be pushed to the remote end, locally updated refs will be force updated on the remote end, and deleted refs will be removed from the remote end. This is the default if the configuration option is set. Do everything except actually send the updates. Produce machine-readable output. The output status line for each ref will be tab-separated and sent to stdout instead of stderr. The full symbolic names of the refs will be given. All listed refs are deleted from the remote repository. This is the same as prefixing all refs with a colon. All refs under are pushed, in addition to refspecs explicitly listed on the command line. Push all the refs that would be pushed without this option, and also push annotated tags in that are missing from the remote but are pointing at commit-ish that are reachable from the refs being pushed. This can also be specified with configuration variable . For more information, see in git-config[1]. GPG-sign the push request to update refs on the receiving side, to allow it to be checked by the hooks and/or be logged. If or , no signing will be attempted. If or , the push will fail if the server does not support signed pushes. If set to , sign if and only if the server supports signed pushes. The push will also fail if the actual call to fails. See git-receive-pack[1] for the details on the receiving end. Use an atomic transaction on the remote side if available. Either all refs are updated, or on error, no refs are updated. If the server does not support atomic pushes the push will fail. Transmit the given string to the server, which passes them to the pre-receive as well as the post-receive hook. The given string must not contain a NUL or LF character. When multiple are given, they are all sent to the other side in the order listed on the command line. When no is given from the command line, the values of configuration variable are used instead. Path to the git-receive-pack program on the remote end. Sometimes useful when pushing to a remote repository over ssh, and you do not have the program in a directory on the default $PATH. Usually, \"git push\" refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. This option overrides this restriction if the current value of the remote ref is the expected value. \"git push\" fails otherwise. Imagine that you have to rebase what you have already published. You will have to bypass the \"must fast-forward\" rule in order to replace the history you originally published with the rebased history. If somebody else built on top of your original history while you are rebasing, the tip of the branch at the remote may advance with their commit, and blindly pushing with will lose their work. This option allows you to say that you expect the history you are updating is what you rebased and want to replace. If the remote ref still points at the commit you specified, you can be sure that no other people did anything to the ref. It is like taking a \"lease\" on the ref without explicitly locking it, and the remote ref is updated only if the \"lease\" is still valid. alone, without specifying the details, will protect all remote refs that are going to be updated by requiring their current value to be the same as the remote-tracking branch we have for them. , without specifying the expected value, will protect the named ref (alone), if it is going to be updated, by requiring its current value to be the same as the remote-tracking branch we have for it. will protect the named ref (alone), if it is going to be updated, by requiring its current value to be the same as the specified value (which is allowed to be different from the remote-tracking branch we have for the refname, or we do not even have to have such a remote-tracking branch when this form is used). If is the empty string, then the named ref must not already exist. Note that all forms other than that specifies the expected current value of the ref explicitly are still experimental and their semantics may change as we gain experience with this feature. \"--no-force-with-lease\" will cancel all the previous --force-with-lease on the command line. A general note on safety: supplying this option without an expected value, i.e. as or interacts very badly with anything that implicitly runs on the remote to be pushed to in the background, e.g. on your repository in a cronjob. The protection it offers over is ensuring that subsequent changes your work wasn’t based on aren’t clobbered, but this is trivially defeated if some background process is updating refs in the background. We don’t have anything except the remote tracking info to go by as a heuristic for refs you’re expected to have seen & are willing to clobber. If your editor or some other system is running in the background for you a way to mitigate this is to simply set up another remote: Now when the background process runs the references on won’t be updated, and thus commands like: Will fail unless you manually run . This method is of course entirely defeated by something that runs , in that case you’d need to either disable it or do something more tedious like: git fetch # update 'master' from remote git tag base master # mark our base point git rebase -i master # rewrite some commits git push --force-with-lease=master:base master:master I.e. create a tag for versions of the upstream code that you’ve seen and are willing to overwrite, then rewrite history, and finally force push changes to if the remote version is still at , regardless of what your local has been updated to in the background. Alternatively, specifying as an ancillary option along with (i.e., without saying what exact commit the ref on the remote side must be pointing at, or which refs on the remote side are being protected) at the time of \"push\" will verify if updates from the remote-tracking refs that may have been implicitly updated in the background are integrated locally before allowing a forced update. Usually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. Also, when option is used, the command refuses to update a remote ref whose current value does not match what is expected. This flag disables these checks, and can cause the remote repository to lose commits; use it with care. Note that applies to all the refs that are pushed, hence using it with set to or with multiple push destinations configured with may overwrite refs other than the current branch (including local refs that are strictly behind their remote counterpart). To force a push to only one branch, use a in front of the refspec to push (e.g to force a push to the branch). See the section above for details. Force an update only if the tip of the remote-tracking ref has been integrated locally. This option enables a check that verifies if the tip of the remote-tracking ref is reachable from one of the \"reflog\" entries of the local branch based in it for a rewrite. The check ensures that any updates from the remote have been incorporated locally by rejecting the forced update if that is not the case. If the option is passed without specifying , or specified along with , it is a \"no-op\". This option is equivalent to the <repository> argument. If both are specified, the command-line argument takes precedence. For every branch that is up to date or successfully pushed, add upstream (tracking) reference, used by argument-less git-pull[1] and other commands. For more information, see in git-config[1]. These options are passed to git-send-pack[1]. A thin transfer significantly reduces the amount of sent data when the sender and receiver share many of the same objects in common. The default is . Suppress all output, including the listing of updated refs, unless an error occurs. Progress is not reported to the standard error stream. Progress status is reported on the standard error stream by default when it is attached to a terminal, unless -q is specified. This flag forces progress status even if the standard error stream is not directed to a terminal. May be used to make sure all submodule commits used by the revisions to be pushed are available on a remote-tracking branch. If check is used Git will verify that all submodule commits that changed in the revisions to be pushed are available on at least one remote of the submodule. If any commits are missing the push will be aborted and exit with non-zero status. If on-demand is used all submodules that changed in the revisions to be pushed will be pushed. If on-demand was not able to push all necessary revisions it will also be aborted and exit with non-zero status. If only is used all submodules will be pushed while the superproject is left unpushed. A value of no or using can be used to override the push.recurseSubmodules configuration variable when no submodule recursion is required. When using on-demand or only, if a submodule has a \"push.recurseSubmodules={on-demand,only}\" or \"submodule.recurse\" configuration, further recursion will occur. In this case, \"only\" is treated as \"on-demand\". Toggle the pre-push hook (see githooks[5]). The default is --verify, giving the hook a chance to prevent the push. With --no-verify, the hook is bypassed completely.\n\nIn general, URLs contain information about the transport protocol, the address of the remote server, and the path to the repository. Depending on the transport protocol, some of this information may be absent. Git supports ssh, git, http, and https protocols (in addition, ftp and ftps can be used for fetching, but this is inefficient and deprecated; do not use them). The native transport (i.e. URL) does no authentication and should be used with caution on unsecured networks. The following syntaxes may be used with them: An alternative scp-like syntax may also be used with the ssh protocol: This syntax is only recognized if there are no slashes before the first colon. This helps differentiate a local path that contains a colon. For example the local path could be specified as an absolute path or to avoid being misinterpreted as an ssh url. For local repositories, also supported by Git natively, the following syntaxes may be used: These two syntaxes are mostly equivalent, except when cloning, when the former implies option. See git-clone[1] for details. , and , but not , will also accept a suitable bundle file. See git-bundle[1]. When Git doesn’t know how to handle a certain transport protocol, it attempts to use the remote helper, if one exists. To explicitly request a remote helper, the following syntax may be used: where <address> may be a path, a server and path, or an arbitrary URL-like string recognized by the specific remote helper being invoked. See gitremote-helpers[7] for details. If there are a large number of similarly-named remote repositories and you want to use a different format for them (such that the URLs you use will be rewritten into URLs that work), you can create a configuration section of the form: a URL like \"work:repo.git\" or like \"host.xz:/path/to/repo.git\" will be rewritten in any context that takes a URL to be \"git://git.host.xz/repo.git\". If you want to rewrite URLs for push only, you can create a configuration section of the form: a URL like \"git://example.org/path/to/repo.git\" will be rewritten to \"ssh://example.org/path/to/repo.git\" for pushes, but pulls will still use the original URL.\n\nThe name of one of the following can be used instead of a URL as argument:\n• a file in the directory, or All of these also allow you to omit the refspec from the command line because they each contain a refspec which git will use by default. You can choose to provide the name of a remote which you had previously configured using git-remote[1], git-config[1] or even by a manual edit to the file. The URL of this remote will be used to access the repository. The refspec of this remote will be used by default when you do not provide a refspec on the command line. The entry in the config file would appear like this: The is used for pushes only. It is optional and defaults to . Pushing to a remote affects all defined pushurls or all defined urls if no pushurls are defined. Fetch, however, will only fetch from the first defined url if multiple urls are defined. You can choose to provide the name of a file in . The URL in this file will be used to access the repository. The refspec in this file will be used as default when you do not provide a refspec on the command line. This file should have the following format: URL: one of the above URL formats Push: <refspec> Pull: <refspec> lines are used by git push and lines are used by git pull and git fetch. Multiple and lines may be specified for additional branch mappings. You can choose to provide the name of a file in . The URL in this file will be used to access the repository. This file should have the following format: Depending on the operation, git will use one of the following refspecs, if you don’t provide one on the command line. is the name of this file in and defaults to .\n\nWhen an update changes a branch (or more in general, a ref) that used to point at commit A to point at another commit B, it is called a fast-forward update if and only if B is a descendant of A. In a fast-forward update from A to B, the set of commits that the original commit A built on top of is a subset of the commits the new commit B builds on top of. Hence, it does not lose any history. In contrast, a non-fast-forward update will lose history. For example, suppose you and somebody else started at the same commit X, and you built a history leading to commit B while the other person built a history leading to commit A. The history looks like this: Further suppose that the other person already pushed changes leading to A back to the original repository from which you two obtained the original commit X. The push done by the other person updated the branch that used to point at commit X to point at commit A. It is a fast-forward. But if you try to push, you will attempt to update the branch (that now points at A) with commit B. This does not fast-forward. If you did so, the changes introduced by commit A will be lost, because everybody will now start building on top of B. The command by default does not allow an update that is not a fast-forward to prevent such loss of history. If you do not want to lose your work (history from X to B) or the work by the other person (history from X to A), you would need to first fetch the history from the repository, create a history that contains changes done by both parties, and push the result back. You can perform \"git pull\", resolve potential conflicts, and \"git push\" the result. A \"git pull\" will create a merge commit C between commits A and B. Updating A with the resulting merge commit will fast-forward and your push will be accepted. Alternatively, you can rebase your change between X and B on top of A, with \"git pull --rebase\", and push the result back. The rebase will create a new commit D that builds the change between X and B on top of A. Again, updating A with this commit will fast-forward and your push will be accepted. There is another common situation where you may encounter non-fast-forward rejection when you try to push, and it is possible even when you are pushing into a repository nobody else pushes into. After you push commit A yourself (in the first picture in this section), replace it with \"git commit --amend\" to produce commit B, and you try to push it out, because forgot that you have pushed A out already. In such a case, and only if you are certain that nobody in the meantime fetched your earlier commit A (and started building on top of it), you can run \"git push --force\" to overwrite it. In other words, \"git push --force\" is a method reserved for a case where you do mean to lose history.\n\nThe fetch and push protocols are not designed to prevent one side from stealing data from the other repository that was not intended to be shared. If you have private data that you need to protect from a malicious peer, your best option is to store it in another repository. This applies to both clients and servers. In particular, namespaces on a server are not effective for read access control; you should only grant read access to a namespace to clients that you would trust with read access to the entire repository. The known attack vectors are as follows:\n• The victim sends \"have\" lines advertising the IDs of objects it has that are not explicitly intended to be shared but can be used to optimize the transfer if the peer also has them. The attacker chooses an object ID X to steal and sends a ref to X, but isn’t required to send the content of X because the victim already has it. Now the victim believes that the attacker has X, and it sends the content of X back to the attacker later. (This attack is most straightforward for a client to perform on a server, by creating a ref to X in the namespace the client has access to and then fetching it. The most likely way for a server to perform it on a client is to \"merge\" X into a public branch and hope that the user does additional work on this branch and pushes it back to the server without noticing the merge.)\n• As in #1, the attacker chooses an object ID X to steal. The victim sends an object Y that the attacker already has, and the attacker falsely claims to have X and not Y, so the victim sends Y as a delta against X. The delta reveals regions of X that are similar to Y to the attacker.\n\nEverything below this line in this section is selectively included from the git-config[1] documentation. The content is the same as what’s found there: If set to \"true\" assume on default push when no upstream tracking exists for the current branch; this option takes effect with push.default options simple, upstream, and current. It is useful if by default you want new branches to be pushed to the default remote (like the behavior of push.default=current) and you also want the upstream tracking to be set. Workflows most likely to benefit from this option are simple central workflows where all branches are expected to have the same name on the remote. Defines the action should take if no refspec is given (whether from the command-line, config, or elsewhere). Different values are well-suited for specific workflows; for instance, in a purely central workflow (i.e. the fetch source is equal to the push destination), is probably what you want. Possible values are:\n• - do not push anything (error out) unless a refspec is given. This is primarily meant for people who want to avoid mistakes by always being explicit.\n• - push the current branch to update a branch with the same name on the receiving end. Works in both central and non-central workflows.\n• - push the current branch back to the branch whose changes are usually integrated into the current branch (which is called ). This mode only makes sense if you are pushing to the same repository you would normally pull from (i.e. central workflow).\n• - This is a deprecated synonym for .\n• - push the current branch with the same name on the remote. If you are working on a centralized workflow (pushing to the same repository you pull from, which is typically ), then you need to configure an upstream branch with the same name. This mode is the default since Git 2.0, and is the safest option suited for beginners.\n• - push all branches having the same name on both ends. This makes the repository you are pushing to remember the set of branches that will be pushed out (e.g. if you always push maint and master there and no other branches, the repository you push to will have these two branches, and your local maint and master will be pushed there). To use this mode effectively, you have to make sure all the branches you would push out are ready to be pushed out before running git push, as the whole point of this mode is to allow you to push all of the branches in one go. If you usually finish work on only one branch and push out the result, while other branches are unfinished, this mode is not for you. Also this mode is not suitable for pushing into a shared central repository, as other people may add new branches there, or update the tip of existing branches outside your control. This used to be the default, but not since Git 2.0 ( is the new default). If set to true, enable option by default. You may override this configuration at time of push by specifying . May be set to a boolean value, or the string if-asked. A true value causes all pushes to be GPG signed, as if is passed to git-push[1]. The string if-asked causes pushes to be signed if the server supports it, as if is passed to git push. A false value may override a value from a lower-priority config file. An explicit command-line flag always overrides this config option. When no argument is given from the command line, behaves as if each <value> of this variable is given as . This is a multi-valued variable, and an empty value can be used in a higher priority configuration file (e.g. in a repository) to clear the values inherited from a lower priority configuration files (e.g. ). Example: /etc/gitconfig push.pushoption = a push.pushoption = b ~/.gitconfig push.pushoption = c repo/.git/config push.pushoption = push.pushoption = b This will result in only b (a and c are cleared). May be \"check\", \"on-demand\", \"only\", or \"no\", with the same behavior as that of \"push --recurse-submodules\". If not set, no is used by default, unless submodule.recurse is set (in which case a true value means on-demand). If set to \"true\", it is equivalent to specifying as an option to git-push[1] in the command line. Adding at the time of push overrides this configuration setting. If set to \"true\", attempt to reduce the size of the packfile sent by rounds of negotiation in which the client and the server attempt to find commits in common. If \"false\", Git will rely solely on the server’s ref advertisement to find commits in common. If set to \"false\", disable use of bitmaps for \"git push\" even if is \"true\", without preventing other git operations from using bitmaps. Default is true."
    },
    {
        "link": "https://git-tower.com/learn/git/faq/git-force-push",
        "document": "How to Use\n\nHere's one of the great things about Git: a safe state on the remote repository always goes first! The wonderful consequence of this is that conflicts cannot happen on the remote repository (unlike in other version control systems).\n\nOne of the reasons for this \"safety on the remote\" is how the \"push\" operation is designed in Git: you can only upload your own changes with a push if you have previously pulled in any outstanding changes from others. This way, a healthy state on the remote repository for everyone is always guaranteed.\n\nHowever, there might come situations where you deliberately want to overwrite the commit history on the remote with your local one. This is when comes into play.\n\nAs described above, Git will normally only allow you to push your changes if you have previously updated your local branch with the latest commits from its remote counterpart. Only when you are up-to-date will you be able to push your own new commits to the remote.\n\nThe option for allows you to override this rule: the commit history on the remote will be forcefully overwritten with your own local history.\n\nThis is a rather dangerous process, because it's very easy to overwrite (and thereby lose) commits from your colleagues. Also, even if no one else has pushed anything to the remote repository in the meantime, your colleagues might still have based their new work on the old commit history. Your \"force push\" changes this history and means theirs is not in line with the new one anymore.\n\nSince it is so easy to destroy or at least impede your colleagues' work, here are a few \"safety rules\" around :\n• Don't use it on shared history. Whenever you have pushed commits to a remote branch that is shared with your team, you should try NOT to use force push. If, on the other hand, you were working on a feature branch that only you yourself are using, then of course feel free to step on the gas and use the option.\n• Consider using instead. The basic need for a tool to correct a mistake that you've already pushed, of course, remains. However, consider using a tool that does NOT rewrite commit history, like git revert for example. This provides a much less obtrusive way to undo a mistake.\n• Use instead of . The push command has another option called . This helps to make sure that you are at least not overwriting work from others: it will present an error message and refuse to push if the remote was modified since you last fetched.\n• Check out the official documentation on git push"
    },
    {
        "link": "https://atlassian.com/git/tutorials/syncing/git-push",
        "document": "Push the specified branch to , along with all of the necessary commits and internal objects. This creates a local branch in the destination repository. To prevent you from overwriting commits, Git won’t let you push when it results in a non-fast-forward merge in the destination repository. Same as the above command, but force the push even if it results in a non-fast-forward merge. Do not use the flag unless you’re absolutely sure you know what you’re doing. Push all of your local branches to the specified remote.\n\nis most commonly used to publish an upload local changes to a central repository. After a local repository has been modified a push is executed to share the modifications with remote team members. The above diagram shows what happens when your local has progressed past the central repository’s and you publish changes by running . Notice how is essentially the same as running from inside the remote repository.\n\nis one component of many used in the overall Git \"syncing\" process. The syncing commands operate on remote branches which are configured using the git remote command. can be considered and 'upload' command whereas, git fetch and git pull can be thought of as 'download' commands. Once changesets have been moved via a download or upload a git merge may be performed at the destination to integrate the changes.\n\nA frequently used, modern Git practice is to have a remotely hosted repository act as a central origin repository. This origin repository is often hosted off-site with a trusted 3rd party like Bitbucket. Since pushing messes with the remote branch structure, It is safest and most common to push to repositories that have been created with the flag. Bare repos don’t have a working directory so a push will not alter any in progress working directory content. For more information on bare repository creation, read about git init.\n\nGit prevents you from overwriting the central repository’s history by refusing push requests when they result in a non-fast-forward merge. So, if the remote history has diverged from your history, you need to pull the remote branch and merge it into your local one, then try pushing again. This is similar to how SVN makes you synchronize with the central repository via before committing a changeset. The flag overrides this behavior and makes the remote repository’s branch match your local one, deleting any upstream changes that may have occurred since you last pulled. The only time you should ever need to force push is when you realize that the commits you just shared were not quite right and you fixed them with a or an interactive rebase. However, you must be absolutely certain that none of your teammates have pulled those commits before using the option.\n\nThe following example describes one of the standard methods for publishing local contributions to the central repository. First, it makes sure your local main is up-to-date by fetching the central repository’s copy and rebasing your changes on top of them. The interactive rebase is also a good opportunity to clean up your commits before sharing them. Then, the command sends all of the commits on your local main to the central repository. Since we already made sure the local main was up-to-date, this should result in a fast-forward merge, and should not complain about any of the non-fast-forward issues discussed above. The git commit command accepts a option which will update the previous commit. A commit is often amended to update the commit message or add new changes. Once a commit is amended a will fail because Git will see the amended commit and the remote commit as diverged content. The option must be used to push an amended commit. # make changes to a repo and git add\n\ngit commit --amend\n\n# update the existing commit message\n\ngit push --force origin main The above example assumes it is being executed on an existing repository with a commit history. is used to update the previous commit. The amended commit is then force pushed using the option. Sometimes branches need to be cleaned up for book keeping or organizational purposes. The fully delete a branch, it must be deleted locally and also remotely. The above will delete the remote branch named branch_name passing a branch name prefixed with a colon to will delete the remote branch."
    },
    {
        "link": "https://stackoverflow.com/questions/5509543/how-do-i-properly-force-a-git-push",
        "document": "And if doesn't work you can do . Look at 2nd line on this instance:\n\nNever ever go back on a public git history!\n• Don't do this or anything that can break someone's .\n• Don't ever or history in a repo someone might have already pulled.\n\nOf course there are exceptionally rare exceptions even to this rule, but in most cases it's not needed to do it and it will generate problems to everyone else.\n\nAnd always be careful with what you push to a public repo. Reverting:\n\nIn effect, both origin HEADs (from the revert and from the evil reset) will contain the same files.\n\nedit to add updated info and more arguments around\n\nConsider pushing force with lease instead of push, but still prefer revert\n\nAnother problem may bring is when someone push anything before you do, but after you've already fetched. If you push force your rebased version now you will replace work from others.\n\nintroduced in the git 1.8.5 (thanks to @VonC comment on the question) tries to address this specific issue. Basically, it will bring an error and not push if the remote was modified since your latest fetch.\n\nThis is good if you're really sure a is needed, but still want to prevent more problems. I'd go as far to say it should be the default behaviour. But it's still far from being an excuse to force a . People who fetched before your rebase will still have lots of troubles, which could be easily avoided if you had reverted instead.\n\nAnd since we're talking about instances...\n\nWhy would anyone want to force push?\n\n@linquize brought a good push force example on the comments: sensitive data. You've wrongly leaked data that shouldn't be pushed. If you're fast enough, you can \"fix\" it by forcing a push on top.\n\nThe data will still be on the remote unless you also do a garbage collect, or clean it somehow. There is also the obvious potential for it to be spread by others who'd fetched it already, but you get the idea."
    },
    {
        "link": "https://stackoverflow.com/questions/10510462/force-git-push-to-overwrite-remote-files",
        "document": "You should be able to force your local revision to the remote repo by using\n\n(e.g. ). Leaving off and will force push all local branches that have set .\n\nJust be warned, if other people are sharing this repository their revision history will conflict with the new one. And if they have any local commits after the point of change they will become invalid.\n\nUpdate: Thought I would add a side-note. If you are creating changes that others will review, then it's not uncommon to create a branch with those changes and rebase periodically to keep them up-to-date with the main development branch. Just let other developers know this will happen periodically so they'll know what to expect.\n\nUpdate 2: Because of the increasing number of viewers I'd like to add some additional information on what to do when your does experience a force push.\n\nSay I've cloned your repo and have added a few commits like so:\n\nBut later the branch is hit with a , which will cause me to receive an error like so when I run :\n\nHere I could fix the conflicts and , but that would leave me with a really ugly commit history:\n\nIt might look enticing to use but be careful because that'll leave you with stranded commits:\n\nSo probably the best option is to do a . This will require me to resolve any conflicts like before, but for each step instead of committing I'll use . In the end the commit history will look much better:\n\nUpdate 3: You can also use the option as a \"safer\" force push, as mentioned by Cupcake in his answer:\n\nForce pushing with a \"lease\" allows the force push to fail if there are new commits on the remote that you didn't expect (technically, if you haven't fetched them into your remote-tracking branch yet), which is useful if you don't want to accidentally overwrite someone else's commits that you didn't even know about yet, and you just want to overwrite your own: You can learn more details about how to use by reading any of the following:\n• Git: How to ignore fast forward and revert origin [branch] to earlier commit?"
    },
    {
        "link": "https://gitkraken.com/learn/git/problems/git-push-force",
        "document": "The Git push command takes the changes you’ve made on your local machine and updates your remote repository to reflect those changes. Developers use this command to update their remote repository in order to share the most accurate Git history with project collaborators.\n\nGit push is the command of choice for updating remote repositories. Not only does it take your local changes and add them to the remote, Git push does not overwrite any of the Git history previously held on the remote.\n\nHowever, there are some situations when you will need to overwrite your remote history. This is where Git push force comes in, which you may have heard referred to as “Git force push” or “force pushing.”\n\nRead on to learn how to leverage Git force pushing effectively and safely in your workflows. In this article, we will cover how to force push using GitKraken Client, first in the CLI and then in the Git GUI.\n\nUnlike Git push, does not require your local repository to be fully up-to-date with the remote repo. Quite the opposite, Git push force makes the remote repository match your local repo.\n\nGit push force overwrites the remote repository to match exactly what your local repo looked like when you ran the command. This means you need to make sure your local repository is entirely up-to-date with the latest changes from the remote before running Git push force or you risk losing commits.\n\nFor example, let’s say a team member pushed new changes to a remote and you forgot to pull them. Because you have failed to pull those changes, they are not reflected in your local repository. In this case, if you perform a Git push force, you will replace the remote repository with a copy of your local repo, effectively deleting your team member’s work.\n\nUsing Git push force still isn’t just as easy as making sure you pull or fetch the latest change before running the command. It’s possible that one or more of your team members are working on changes based on the old commit history. If you force push in this situation, it could make your team members’ contributions obsolete if you haven’t merged them into your current work.\n\nIf you determine that you want to keep your project’s history but still want to make a minor change to your remote repo, consider reverting your commits using . This doesn’t alter your project’s history the same way force pushing does, and can help you undo commits that conflict with your codebase.\n\nWhen Should I Use Git Push Force?\n\nThere are a few situations where using Git push force is the best course of action despite the potential for negative repercussions.\n\nSome common examples of when you may need to force push in Git include:\n• After squashing commits that have been pushed to the remote\n• After sensitive data has been accidentally pushed to the remote and needs to be removed\n\nWhile you can follow the same basic steps to force push in any terminal, we’re going to go over the process using the powerful GitKraken CLI.\n\nTo access the CLI in GitKraken Client, click the button in the top toolbar.\n\nYou’ll want to start by fetching any changes from the remote with . Performing a Git fetch grabs any changes from the remote that haven’t already been applied to your local repo and adds them.\n\nWhile this step is not necessary to execute a force push, it is a good practice as it allows you to verify that nothing has been recently pushed up that you don’t want to overwrite.\n\nNext, you should perform an interactive rebase to squash your commits. This practice promotes cleaner remote repositories and makes it easier for your team members to find and interact with your changes. To perform an interactive rebase and squash a group of commits:\n• Use to find the SHA of the base commit you’ll be working from.\n• Using a text editor program like Vim, select the commits you would like to squash.\n• Quit the text editor using the key and then type .\n• Finally, compose a comprehensive commit message based on all the files and then use and to finish.\n\nAs a general best practice, you may also want to run to confirm that your local branch is in the expected state. Running Git status will return differences between the index file and the current HEAD commit as well as the differences between the index file and the working tree.\n\nOnce you’ve taken those steps to create a safer environment for a Git push force, you can now run the following command to force push to the remote repository:\n\nAnother safety measure to consider from the CLI is using . Using this flag will fail to force push if it identifies that changes have been made to the remote that are not reflected in your local repository.\n\nThink back to our past example. If a team member has made changes to the remote and you haven’t pulled those changes, running Git push force alone will overwrite your team member’s contribution. However, if you run Git push force with lease, the force push will fail because it identifies that you need to pull changes from the remote. If no changes have been made to the remote since your last pull, the force push will proceed.\n\nJust like if you were to use the CLI, before executing a force push in a Git GUI, you will want to perform a fetch first. You can do this in GitKraken Client by selecting the small arrow just to the right of the button from the top toolbar. From the subsequent dropdown menu, select . As mentioned before, performing this action first can help mitigate the risk of accidentally overwriting work.\n\nOnce you’re satisfied with your local repo, you can push your changes to the remote using the button. When force pushing with GitKraken Client, a banner will appear with the following options: , or .\n\nNote: fetches any updates on the remote branch and attempts to fast-forward, or move, the local branch to point to the same commit as the remote. If a fast-forward is not possible, a Git merge will be performed. will cancel the push.\n\nIn the below example, there are a few commits that have been pushed that should be squashed. To do this, use to multi-select the desired commits from the graph, and then select . Notice the local main branch now diverges in history from the remote main branch.\n\nNow that the local main branch is pointing to the desired commit, it’s time to Git force push this change to remove the other commits from the remote history. To do this, select from the top toolbar in GitKraken Client. You will then be prompted with the following message:\n\nSelect , and finally confirm by selecting a second time. Because this is a potentially destructive action, GitKraken Client gives you the opportunity to double check and ensure you want to proceed.\n\nYou can confirm that the force push was successful by checking that the local and remote main branch are pointing to the same commit, and the other undesired commit has been removed.\n\nIt’s easy to understand why keeping a clean remote repository is so crucial based on the concepts we’ve covered. The need for a clean remote repository is compounded when working with a team. With so many touchpoints and contributors, it’s crucial to establish clear repository standards and promote as much project visibility with your collaborators as possible.\n\nGitKraken Client’s Git for Teams features alert you if you and a team member are working on the same file so you can avoid potential merge conflicts, and deep linking allows you to quickly share specific parts of a project with your team. GitKraken Client makes team collaboration seamless and easy so you can focus on writing amazing code."
    },
    {
        "link": "https://git-tower.com/learn/git/faq/git-force-push",
        "document": "How to Use\n\nHere's one of the great things about Git: a safe state on the remote repository always goes first! The wonderful consequence of this is that conflicts cannot happen on the remote repository (unlike in other version control systems).\n\nOne of the reasons for this \"safety on the remote\" is how the \"push\" operation is designed in Git: you can only upload your own changes with a push if you have previously pulled in any outstanding changes from others. This way, a healthy state on the remote repository for everyone is always guaranteed.\n\nHowever, there might come situations where you deliberately want to overwrite the commit history on the remote with your local one. This is when comes into play.\n\nAs described above, Git will normally only allow you to push your changes if you have previously updated your local branch with the latest commits from its remote counterpart. Only when you are up-to-date will you be able to push your own new commits to the remote.\n\nThe option for allows you to override this rule: the commit history on the remote will be forcefully overwritten with your own local history.\n\nThis is a rather dangerous process, because it's very easy to overwrite (and thereby lose) commits from your colleagues. Also, even if no one else has pushed anything to the remote repository in the meantime, your colleagues might still have based their new work on the old commit history. Your \"force push\" changes this history and means theirs is not in line with the new one anymore.\n\nSince it is so easy to destroy or at least impede your colleagues' work, here are a few \"safety rules\" around :\n• Don't use it on shared history. Whenever you have pushed commits to a remote branch that is shared with your team, you should try NOT to use force push. If, on the other hand, you were working on a feature branch that only you yourself are using, then of course feel free to step on the gas and use the option.\n• Consider using instead. The basic need for a tool to correct a mistake that you've already pushed, of course, remains. However, consider using a tool that does NOT rewrite commit history, like git revert for example. This provides a much less obtrusive way to undo a mistake.\n• Use instead of . The push command has another option called . This helps to make sure that you are at least not overwriting work from others: it will present an error message and refuse to push if the remote was modified since you last fetched.\n• Check out the official documentation on git push"
    },
    {
        "link": "https://codemia.io/knowledge-hub/path/force_git_push_to_overwrite_remote_files",
        "document": "Enhance your system design skills with over 120 practice problems, detailed solutions, and hands-on exercises."
    }
]