[
    {
        "link": "https://json-schema.org/learn/getting-started-step-by-step",
        "document": "JSON Schema is a vocabulary that you can use to annotate and validate JSON documents. This tutorial guides you through the process of creating a JSON Schema.\n\nAfter creating your JSON Schema, you can then validate example data against your schema by using a validator in a language of your choice. Please, visit Tools and select the validator that better suit your needs.\n\nIf you already know how to create JSON Schemas and you are looking for different JSON Schema use cases like schema generation, code generation, documentation, UI generation or JSON Schema processing or conversion, please visit Tools and explore the amazing tooling available in the JSON Schema Ecosystem.\n\nThe example we use in this guide is a product catalog that stores its data using JSON objects, like the following:\n\nEach product in the catalog has:\n• : an identifier for the product\n• : the cost to the consumer\n\nThe JSON object is human-readable, but it doesn’t include any context or metadata. There’s no way to tell from looking at the object what the keys mean or what the possible inputs are. JSON Schema is a standard for providing answers to these questions. In this guide, you will create a JSON Schema document that describes the structure, constraints, and data types for a set of JSON data.\n\nThe instance is the JSON document that is being validated or described, and the schema is the document that contains the description.\n\nThe most basic schema is a blank JSON object, which constrains nothing, allows anything, and describes nothing:\n\nBy adding validation keywords to the schema, you can apply constraints to an instance. For example, you can use the keyword to constrain an instance to an object, array, string, number, boolean, or null:\n\nJSON Schema is hypermedia-ready and ideal for annotating your existing JSON-based HTTP API. JSON Schema documents are identified by URIs, which can be used in HTTP link headers and within JSON Schema documents to allow for recursive definitions.\n\nTo create a basic schema definition, define the following keywords:\n• : specifies which draft of the JSON Schema standard the schema adheres to.\n• : sets a URI for the schema. You can use this unique URI to refer to elements of the schema from inside the same document or from external JSON documents.\n• and : state the intent of the schema. These keywords don’t add any constraints to the data being validated.\n• : defines the first constraint on the JSON data. In the product catalog example below, this keyword specifies that the data must be a JSON object.\n\nThe keywords are defined using JSON keys. Typically, the data being validated is contained in a JSON data document, but JSON Schema can also validate JSON data contained in other content types, such as text or XML files.\n\nIn JSON Schema terminology, and are schema keywords, and are schema annotations, and is a validation keyword.\n\nThis section adds the keyword. In JSON Schema terms, is a validation keyword. When you define , you create an object where each property represents a key in the JSON data that’s being validated. You can also specify which properties defined in the object are required.\n\nUsing the product catalog example, is a numeric value that uniquely identifies a product. Since this is the canonical identifier for the product, it’s required.\n\nTo add the object to the schema:\n• None Add the validation keyword to the end of the schema:\n• None Add the keyword, along with the following schema annotations:\n• : describes what is. In this case, it’s the product’s unique identifier.\n• None : defines what kind of data is expected. For this example, since the product identifier is a numeric value, use .\n\nWith the new validation keyword, the overall schema looks like this:\n\nThe following example adds another required key, . This value is a string:\n\nThe object now includes two keys, and . When JSON data is validated against this schema, validation fails for any documents that contain invalid data in either of these fields.\n\nThis section describes how to specify that certain properties are required. This example makes the two existing keys required and adds another required key named . The key has a and just like the other keys, but it also specifies a minimum value. Because nothing in the store is free, each product requires a price value that’s above zero. Define this using the validation keyword.\n• None Inside the object, add the key. Include the usual schema annotations and , where is a number: ... \"The price of the product\" } }\n• None Add the validation keyword and set the value to zero: \"The price of the product\" }\n• None Add the validation keyword to the end of the schema, after the object. Add , , and the new key to the array: ... \"The price of the product\" }, },\n\nWith the new keyword and key, the overall schema looks like this:\n\nThe validation keyword is set to zero, which means that only values above zero are considered valid. To include zero as a valid option, you could use the validation keyword instead.\n\nThis section describes how to define an optional property. For this example, define a keyword named using the following criteria:\n• If is included, it must contain at least one item.\n• All tags must be unique.\n• All tags must be text.\n• None Inside the object, add the keyword. Include the usual schema annotations and , and define as an array:\n• None Add a new validation keyword for to define what appears in the array. For example, :\n• None To make sure there is at least one item in the array, use the validation keyword:\n• None To make sure that every item in the array is unique, use the validation keyword and set it to :\n\nWith the new keyword, the overall schema looks like this:\n\nBecause the new keyword is not required, there are no changes to the section.\n\nThe earlier examples describe a flat schema with only one level. This section describes how to use nested data structures in JSON Schema.\n• None Add the validation keyword to contain the nested data structure. Inside the new keyword, add keywords for , , and that all use the type:\n• None To make each of these properties required, add a validation keyword inside the object:\n\nUsing the new nested data structures, the overall schema looks like this:\n\nThe new validation keyword only applies within the scope of the key.\n\nThis section describes how to reference resources outside of the schema. Sharing schemas across many data structures is a common way to make them easier to use, read, and keep up-to-date. So far, the product catalog schema is self-contained. This section creates a new schema and then references it in the product catalog schema.\n\nTo reference this schema in the product catalog schema:\n• None To link to the external geographical location schema, add the schema keyword and the schema URL: \"Coordinates of the warehouse where the product is located.\" }\n\nWith the external schema reference, the overall schema looks like this:\n\nNow that you have your JSON Schema, it is time to validate JSON data against it using a JSON Schema Validator.\n\nA Validator is a tool that implements the JSON Schema specification. All validators works in a similar way: they take a JSON Schema and a JSON Instance as input and they return the validation result as output.\n\nTo try it yourself, please visit Tools and select the validator that best suits your needs, or use the editors available below to explore the different Schemas and Instances and see the different validation results."
    },
    {
        "link": "https://stackoverflow.com/questions/58282728/typescript-type-of-json-schema-object",
        "document": "I needed to type a schema in the same way, but ideally I wanted a generic solution without an external package if possible, which allowed me to generically type the key based on a schema that can change and introduce additional property items.\n\nI did this by adding a key index signature onto the interface meaning the key can be any , but also typing additional properties for that in this example this is and giving me the benefit of the key being generic but the keys properties are strictly typed.\n\nSchema can be initialised as\n\nYou can then access properties in the schema by its key and also benefit from intellisense suggestions, this can also be extended to support JSON and schema items."
    },
    {
        "link": "https://json-schema.org",
        "document": "While JSON is probably the most popular format for exchanging data, JSON Schema is the vocabulary that enables JSON data consistency, validity, and interoperability at scale. Simplify your validation logic to reduce your code’s complexity and save time on development. Define constraints for your data structures to catch and prevent errors, inconsistencies, and invalid data. Establish a common language for data exchange, no matter the scale or complexity of your project. Define precise validation rules for your data structures to create shared understanding and increase interoperability across different systems and platforms. Create a clear, standardized representation of your data to improve understanding and collaboration among developers, stakeholders, and collaborators. Adopt JSON Schema with an expansive range of community-driven tools, libraries, and frameworks across many programming languages.\n\nDiscover JSON Schema tooling to help your organization leverage the benefits of JSON Schema. Because JSON Schema is much more than a Specification, it is a vibrant ecosystem of Validators, Generators, Linters, and other JSON Schema Utilities made by this amazing Community.\n\nThe following companies support us by letting us use their products.\n\nEmail us for more info!"
    },
    {
        "link": "https://ajv.js.org/guide/typescript.html",
        "document": "Ajv takes advantage of TypeScript type system to provide additional functionality that is not possible in JavaScript:\n• utility types and to convert data type into the schema type to simplify writing schemas, both for JSON Schema (but without union support) and for JSON Type Definition (with tagged unions support).\n• utility type to convert JSON Type Definition schema into the type of data that it defines.\n• compiled validation functions are type guards that narrow the type after successful validation.\n• validation errors for JSON Schema are defined as tagged unions, for type-safe error handling.\n• when utility type is used, compiled JTD serializers only accept data of correct type (as they do not validate that the data is valid) and compiled parsers return correct data type.\n\nFor the same example as in Getting started:\n\nSee this test (opens new window) for an advanced example.\n\nYou can use JTD schema to construct the type of data using utility type\n\nNote that it's currently not possible for to know whether the compiler is inferring timestamps as strings or Dates, and so it conservatively types any timestamp as . This is accurate, but often requires extra validation on the part of the user to confirm they're getting the appropriate data type.\n\nWith both JSON Schema and JSON Type Definition, the validation error type is an open union, but it can be cast to tagged unions (using validation keyword as tag) for easier error handling.\n\nContinuing the example above:\n\nWith typescript, your compiled parsers and serializers can be type-safe, either taking their type from schema type or from type parameter passed to compilation functions.\n\nThis example uses the same data and schema types as above:\n\nJSON Type Definition only supports tagged unions, so unions in JTD are fully supported for and . JSON Schema is more complex and so has limited support for type safe unions.\n\nwill type check unions where each union element is fully specified as an element of an array or array. Additionally, unions of primitives will type check appropriately if they're combined into an array , e.g. .\n\nHere's a more detailed example showing several union types:"
    },
    {
        "link": "https://json-schema.org/understanding-json-schema/reference",
        "document": "Master the full power of JSON Schema with our reference documentation.\n\n\n\nFrom basic data types to advanced techniques like conditional validation and schema composition, you will learn everything about JSON Schema keywords through clear explanations and examples. By learning best practices for building clear, scalable, and easy-to-maintain schemas, you will ensure that your JSON data is both robust and flexible.\n\n\n\nDid you find these docs helpful? Help us make our docs great! At JSON Schema, we value docs contributions as much as every other type of contribution! Still Need Help? Learning JSON Schema is often confusing, but don't worry, we are here to help!. Ask the community on GitHub Ask the community on Slack"
    },
    {
        "link": "https://stackoverflow.com/questions/33309824/calling-external-api-with-javascript",
        "document": "I need to make a POST request to an external server from my webpage using Javascript. The body and response are both json. I can't figure out how to make this call or what tools to use. How do I make this call?\n\nThis is what I have so far using jQuery and ajax:\n\nIt is throwing a alerts that just says \"Status:\" and \"Error:\"\n\nThe console says this \"XMLHttpRequest cannot load http://[domain]/vizportal/api/web/v1/getViews. No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://[domain]' is therefore not allowed access. The response had HTTP status code 405.\""
    },
    {
        "link": "https://medium.com/strapi/type-safe-fetch-with-next-js-strapi-and-openapi-4375fb924655",
        "document": "This blog post will teach you how to achieve type safety in a front-end application used for your Strapi backend. You can accomplish this with just a few lines of code using a REST API and the fetch function.\n\nIf you like the content in a video format, feel free to check the original version on YouTube: Type-Safe Fetch with Next.js, Strapi, and OpenAPI.\n\nTypeScript helps you in many ways in the context of a JavaScript app. It makes it easier to consume interfaces of any type.\n\nFor example, if a component’s properties are typed, it is much more straightforward to use this component. However, when developing a react component with typed properties, you know what data you can use to implement your component.\n\nHowever, TypeScript can also significantly help when interacting with external services using their APIs.\n\nWhen you use technologies like GraphQL, it is trivial to derive TypeScript types. A GraphQL API is created by implementing a schema. Generating the TypeScript type definitions from this schema is simple, and you do not have to do any more work than just making the GraphQL API. This is one reason why I like GraphQL so much.\n\nOther approaches, like tRPC (TypeScript Remote Procedure Calls), already include TypeScript in their name. When developing an API, you inherently also create its types.\n\nHowever, the most commonly used APIs are still simple JSON APIs (often called REST APIs). This API, in essence, gives you a URL that then returns a “whatever” JSON object.\n\nWorking with REST API could be more pleasant when you are used to fully typed APIs. You can start logging the response, or you will have to look up documentation for this API. Since you know that the documentation and API are technically not integrated, they are “out of sync” more often than not.\n\nHowever, REST APIs are still the de facto standard and most used type of API, so there is a lot of tooling around them.\n\nOne of these is the OpenAPI specification. In contrast to GraphQL, you do not create a schema that is your API. You first create your API in isolation, then describe it by creating a technical specification in the OpenAPI format.\n\nFrom this OpenAPI specification, you can, for example, generate UIs that help you with visual documentation and use them as a sandbox environment for the API. Essentially, it is not far from a GraphQL API with its Playgrounds.\n\nBut is REST still any good?\n\nThe commonality of a REST API is also its most significant advantage. No web developer is likely not familiar with REST APIs. Often, it is impossible to use any super modern and fancy technology, especially in environments with older IT systems or complicated IT Governance processes.\n\nAnother considerable advantage of simple REST APIs is that they are more likely to pass the test of time. Technologies and their best practices are still changing so fast. And the more common and uncomplicated the basic building blocks are, the more likely they can be used even years from now.\n\nGraphQL, for example. In web projects, you typically use GraphQL in conjunction with very complex client libraries like Apollo. These libraries do a lot of things, like normalizing data, maintaining state, and caching. This comes with a larger payload of JavaScript. But when things change, you might not want to use all of its capabilities anymore, and they can become harder to integrate and use with new approaches.\n\nRight now, we, as client-heavy JavaScript developers, are moving back to the server again. With next.js server components and lots of caching mechanisms baked into the framework itself, some complexities on the client side become obsolete again. Also, next.js is extending the native fetch API, so if you rely on tools that implement their own data fetching, things get more complex.\n\nThis is why I tried an uncomplicated approach that still gives you great TypeScript support and works great with your favorite headless CMS, Strapi.\n\nConceptually, you need to have the OpenAPI schema of your REST API, a way to generate the TypeScript type definitions from it, and a way to actually use those type definitions. Luckily, there are packages that make the whole process effortless.\n\nStrapi offers an official plugin called (here). Install it to your existing Strapi project using:\n\nThis plugin gives you two important things\n• It automatically generates the OpenAPI specifications for your Strapi service as a JSON file.\n• It provides you with a Swagger UI as a visual documentation to explore and try the REST API.\n\nIn the Swagger UI you can see the endpoints for the Page collection type created inside Strapi. There are endpoints to create, read, update or delete pages automatically when you create a collection type in Strapi.\n\nThis UI is generated from the OpenAPI schema file which you will be able to find in your project under.\n\nIn the OpenAPI specifications you can find all existing paths of the API:\n\nAnd within a path you can also find a reference to its response schema, which will be very important later on:\n\nWhen you dig deeper into the PageResponse schema you will eventually end up at the actual schema for a Page collection type:\n\nAs you can see there are some very relevant information about the collection type. It is of type object, well… that’s not a surprise. It does have a property of type and also a property that has items that can be different types. A or a . And those, as you might have guessed, are Strapi components which makes your blocks property a dynamic zone, just described within your OpenAPI specs.\n\nIn Strapi, the Page looks like this:\n\nSo indeed, the generated OpenAPI specifications match what you defined in Strapi.\n\nFrom that, you should now be able to generate the TypeScript type definitions.\n\nTo do so, all you need is a library called . This library takes a file with the OpenAPI specs or a URL to those and outputs your TypeScript type definitions.\n\nNote that you want to install this in your frontend application since you will use the TypeScript type definitions there.\n\nOnce installed, you can simply add a script to your package.json that provides the path to the generated OpenAPI specs (or URL Endpoint) and the location where to output the type definitions.\n\nIn this example, the Next.js frontend and the Strapi backend are in the same folder on the root level:\n\nThe resulting scripts in the package.json are therefore:\n\nRunning the script is as simple as:\n\nThis command creates a file containing the TypeScript type definitions from your OpenAPI specifications file.\n\nWhen you look at the generated file, you find familiar things:\n\nThe interface for all available paths is critical down the line. As you can see, the API routes exist to create, read, update or delete the route.\n\nIn the interface components of the same file, you then find the type for your collection type.\n\nThis way, you could already be using the TypeScript types for the content type you created in your Strapi backend. That is great already. As you can see, even the in the dynamic zone from Strapi are typed, as are the types of components that were generated.\n\nThe schema for the components shows the configuration that is available in your Strapi backend.\n\nThe referenced looks like this:\n\nFrom the image above, the component has attributes like and as an enum of or , and more. Those are valuable types when developing the graphical representation of your backend Strapi-Component as a react component in the frontend.\n\nUsing the Types in a React Component\n\nNow that you have generated the types, you can use them directly for your React components.\n\nYou can import the from the generated type definitions. And then use the you need. Here, you type the component and get the autocomplete for the props.\n\nIn order to receive the props in the first place, you still need to fetch the data. And of course you want to leverage the types for data fetching as well.\n\nIn order to use fetch in conjunction with the generated type definitions, you can use a library called . This library is a small wrapper around the native fetch and consumes the output of the openapi-typescript library.\n\nAll you need to do is create the client and reference the generated types for path :\n\nNow you can use the client to do your first data-fetching. For example, on a Next.js page, you want to fetch the data of a specific page. For example, the data of a page with .\n\nWhen using the typed fetch client, you can see all available paths in your :\n\nBut also the response is typed automatically for you:\n\nHere you can see the autocompletion of the actual data of your which includes the attribute.\n\nYou will notice that the data fetching above does not return the data of the assigned blocks. This is because the Strapi REST API requires you to specify some specific query parameters to instruct the REST API to include those relations in the response.\n\nWith libraries, query parameters can be easier to use and maintain. For example, the request for including fields and using population might look like this\n\nThat would mean a bit of string concatenation. Luckily Strapi suggest a library called to make this a bit more streamlined:\n\nSince you are using fetch not directly but you do not really pass a path that includes the query string as a simple string to fetch. The syntax for query parameters is like this:\n\nThough by default you cannot really just add the object from the Strapi examples using . For example, if you would want to add the style query to filter pages for the path and also populate all components used in the dynamic zone field blocks , you would do the following query:\n\nIf you do it like this you will get an error like this:\n\nBecause you cannot pass complex objects as a query to openapi-fetch out of the box, you can override the part responsible for converting the query object that is passed to the client. So what you want is for the so-called of to use , and you can do so when the client gets created:\n\nAnd with that the query string is generated by passing the query object to . So with that, you can create the queries exactly as shown in the Strapi documentation itself.\n\nWhat you have seen now works great especially when you are fetching data on the server, like in React Server Components using Next.js. But data fetching on the client side is often a bit more involved. At least what you want is for example some data loading indication and to know when the data is actually available in the client.\n\nA library that fullfills this need, but still has a small payload in terms of bundle size, is from tanstack.\n\nWe will be loading , which is also a data type defined in your Strapi backend.\n\nA simple approach could be to create a client-side react component that uses react-query to fetch the data.\n\nIn react-query, you need to pass a function to the that returns a promise. As you can see, you do not use here anywhere. But still the data is all typed by the type definitions generated directly from your Strapi backend.\n\nAnd this is simply because in the you passed to , you are leveraging out typed fetch approach again.\n\nAs you can see, you are again using the typescript-fetch client and return the typed data. And with that you have everything typed, also on the client side.\n\nAs you can see there is a way to achieve a meaningful grade of type safety or type-safe fetch with Next.js without much effort and especially without adding lots of complicated technologies and bundle size.\n\nUsing a simple fetch that leverages the generated type definitions based on the also automatically generated OpenAPI specifications from within Strapi is very little work but provides tons of values.\n\nNot only for the data fetching part. But also for developing react components that reflect the building blocks coming from your headless CMS.\n\nAnd the best thing is, that all of this is achievable in any environment where you cannot use the latest and greatest of tools available in JavaScript land.\n• The source code is available on GitHub.\n\nStay up to date with my latest tutorials on my website and feel free to connect with me on Twitter and YouTube."
    },
    {
        "link": "https://stackoverflow.com/questions/58970012/node-js-typescript-best-practice-to-call-external-api-asynchronously",
        "document": "In a Node.js app(written in TypeScript), an external API needs to be called when POST API(save data) is called. This external API is independent and should be running in the background without causing any delay in the response.\n\nWhat is the best practice to achieve this?"
    },
    {
        "link": "https://learningdaily.dev/how-to-integrate-apis-in-javascript-a-complete-guide-edb4819afdd9",
        "document": "On a typical day, Alice, a waiter at a restaurant, serves customers their orders. An example of an order they might receive is: “Alice, can I have a caffè latte with no sugar, please?” Alice would then take the order to the kitchen. The chef, working in the kitchen, prepares the order and hands it over to Alice, who serves it to the customer. This simple interaction shows how effective communication between different roles (waiter, chef, and customer) is essential for smooth order fulfillment.\n\nSimilarly, in software development, an application programming interface (API) is a software gateway that allows different software components to communicate with each other. APIs help expose the capabilities of an application to the outer world, allowing for programmatic access to the application’s data.\n\nConsider the case of an application providing stock or weather information. Building and exposing an API for such systems will allow others to programmatically fetch the data offered by these systems, such as weather forecasts for the provided location. The same example can be extended to various other use cases. Commonly used services such as YouTube, Reddit, Google Maps, and others provide APIs, allowing authorized clients to access their resources using API integration. We can also relate this to the restaurant analogy above in the following way:\n• Alice, the waiter, is the API acting as the interface between the clients and the backend services.\n• The kitchen and chef are analogous to downstream services, including the serving application and the persistence layer.\n\nOver the years, APIs have evolved and have acquired some features that make them even more efficient and useful. Modern APIs conform to HTTP standards, which makes them developer-friendly and easy to consume.\n\nRepresentational state transfer (REST) is a web architecture style introduced in 2000 to address the web’s exponential scalability problem. REST requires a server to fulfill a client’s request by providing a representation of the resource, which contains links to change the system’s state and acquire the representation of newer resources. The REST architecture style is derived from architecture constraints, such as client-server communication, cacheability, statelessness, and others, and forms the basis of the modern internet.\n\nAPIs based on REST architecture are aptly called RESTful APIs. They commonly use HTTP as the underlying protocol, with HTTP methods ( , , , ) for managing resources.\n\nAt Educative, we have a diverse catalog of interactive and hands-on courses on APIs, including the design of APIs and how to integrate APIs in JavaScript and Python. For instance, the course linked here provides hands-on expertise on consuming data from Api-Football, a great resource for any application consuming soccer-related data.\n\nLet’s start with runnable code to fetch a random recipe from TheMealDB, an open, crowd-sourced database of recipes. Don’t worry if you don’t understand the example completely at this stage; we are here to guide you through it.\n\nBefore going further, let’s briefly discuss the highlighted lines in the code above. We first provide the endpoint URL and then use the Fetch API to make an HTTP request to the endpoint. We have defined some helper functions in lines 16–32 to print the formatted response and any errors encountered.\n\nNow that we have a basic idea about HTTP requests let’s focus on the core concepts. We start with some background on endpoints and HTTP methods.\n\nIn bidirectional communication, an endpoint represents one end of the communication, essentially specifying how to reach the API using a URL. A client can send requests to an endpoint to retrieve resources or perform operations. The illustration below shows that endpoints have two parts: the base URL and the endpoint name.\n\nManipulating data with CRUD operations is a common requirement. For instance, when working with an SQL database, we utilize , , , and operations. Likewise, when interacting with REST applications, CRUD operations are frequently involved and are supported by HTTP methods.\n\nLet’s consider the example case of an API to manage courses using an API endpoint named . The table below presents the use of HTTP methods:\n\nBefore moving forward, let’s revisit the code shown earlier and see how we can specify the HTTP method with the Fetch API.\n\nWhen calling the method, we need to specify the and optionally, an object to specify other settings, in this case, the HTTP method to use. We have commented out some code representing some settings and excluded the presentation of others, such as and . To better understand these settings, let’s discuss the possible parameter types.\n\nThere are four important types of parameters we need to deal with when making API calls:\n• Path parameters: Parameters within the path of an endpoint that typically appear after .\n• Query string parameters: Parameters in the query string of the endpoint, normally after .\n• Body parameters: They contain data sent by the client to the server, providing additional information for processing the request. They are typically used with , , and methods.\n\nAll is now set for putting this knowledge into practice. We’ll consider the case of making requests to an API to manage courses.\n\nWe have already seen the code for making HTTP requests. However, for completion and for the use case of making a course catalog, we are using a path parameter to get the details of a specific course.\n\nHandling to add a new course\n\nTo add a new course to our collection, we’ll use the same endpoint. This time, we’ll use the method with this endpoint. We also need to pass body parameters with the request to add a new course. The code widget below is for the course catalog use case.\n\nWe can use the HTTP method to update the resource (and for partially updating it). Let’s take a moment to figure out how this can be done. First, how the endpoint has been designed, gives us a clue about the endpoint URL. We need to specify a course’s ID as a path parameter to update it.\n\nWe need to, of course, specify as the HTTP method to use. In addition, we need to provide the course information as a body parameter. The complete code is as follows:\n\nLet’s conclude this blog by discussing how to delete a course. Again looking at how the endpoint has been designed, gives us a clue about the endpoint URL. We need to specify a course's ID as a path parameter to delete it. We need to use as the HTTP method. One important thing to note and follow is that the body parameters are not sent with the request. The complete code is as follows:\n\nThis blog has provided a detailed guide on how to integrate APIs in JavaScript. We started by making an HTTP request using the Fetch API to fetch a random recipe from TheMealDB, an open, crowd-sourced database of recipes.\n\nWe then detailed the various related concepts and used a custom API to discuss using HTTP , , and methods to manage resources.\n\nThis blog focused on RESTful APIs; however, other API architecture styles, including GraphQL and gRPC, have their strengths and use cases. We encourage you to explore them further."
    },
    {
        "link": "https://medium.com/@diegogauna.developer/restful-api-using-typescript-and-react-hooks-3d99bdd0cd39",
        "document": "Fetch Data API is an indispensable tool for developers to fetch data from remote servers, manipulate it, and display it on a website. APIs allow us to create dynamic and interactive applications that can communicate with different services and databases. However, not all APIs are created equal, and some can be more challenging to work with than others. That’s why I want to share with you the benefits of using the fetch data API in REST using React and Typescript.\n\n5 benefits of using the fetch data API in REST in your React/Typescript Application.\n• Enhanced Performance: One of the most significant benefits of using the fetch data API in REST is its improved performance. With fetch, you can make asynchronous requests to the server without blocking the main thread, which means your application remains responsive and fast. This performance boost is particularly noticeable when working with large data sets, which can take a long time to load using traditional API calls. Additionally, the fetch API has built-in caching capabilities, so you can reuse responses without sending new requests.\n• Simplified Syntax: The fetch API has a simple and intuitive syntax that makes it easy to use, even for developers who are new to API development. The API follows a simple request/response pattern, where you send a request to the server and receive a response in return. The response object is a standard JavaScript object, which you can then manipulate and use as needed. The fetch API also has built-in error handling, making it easier to detect and handle any issues that may arise during the request.\n• Improved Data Management: The fetch API allows for easy manipulation and management of data, thanks to its support for various data formats, including JSON, XML, and HTML. Additionally, it has a range of features, such as headers, that allow you to customize your requests and responses. This means that you can easily send and receive data in the format that best suits your needs, making it easier to integrate with different systems and services.\n• Seamless Integration with React: Another significant advantage of using the fetch API in REST with React is that it integrates seamlessly with the React framework. React is a popular JavaScript library used to build user interfaces, and it has a range of features that make it easier to work with data. The fetch API is particularly well-suited to React, as it allows you to fetch data and update your application’s state without the need for additional libraries or frameworks.\n• Typescript Support: Finally, the fetch API also has excellent support for Typescript, a popular programming language used to build large-scale applications. Typescript provides developers with a range of features, such as static type checking, that can help prevent errors and make development more efficient. The fetch API works seamlessly with Typescript, providing a robust and reliable API for building complex applications.\n\nThere is more… check this tutorial in 6 steps on how to use REST API and fetch data in a React/Typescript application:\n\nStep 1: Set up a new React project Create a new React project using your preferred tool, such as create-react-app, and install the necessary dependencies for using Typescript with React, including the typescript and @types/react packages.\n\nStep 2: Create a Typescript interface for the data: Create a Typescript interface for the data that you will be fetching from the API. This will help ensure that the data is properly formatted and provide helpful type checking throughout your code. For example, if you were fetching a list of users, you could create an interface like this:\n\nStep 3: Create a function for fetching data Create a function that will fetch the data from the API using the built-in fetch function in JavaScript. This function should return a Promise that resolves to the data you are fetching. For example, if you were fetching a list of users from an API endpoint at , you could create a function like this:\n\nStep 4: Create a React component to display the data Create a React component that will display the data fetched from the API. This component should call the fetchUsers function and render the data using JSX. For example:\n\nStep 5: Add error handling to the component Add error handling to the component to handle any errors that may occur during the data fetch. This can be done using a try-catch block around the fetch call, or by checking the response status code and throwing an error if it is not in the 200 range. For example:\n\nStep 6: Render the component in your React app Finally, render the UserList component in your React app. You can do this by importing the component into your App component and adding it to the render method. For example:\n\nAnd that’s it! You now have a React component that can fetch data from a REST API using Typescript\n\nDid you like this publication? Feel free to chat! :)"
    }
]