[
    {
        "link": "https://geeksforgeeks.org/multidimensional-vectors-in-cpp",
        "document": "A multidimensional vector is a vector of vectors that allows us to create 2D, 3D, or higher-dimensional vectors in a similar way as multidimensional arrays but unlike arrays, multidimensional vectors can grow and shrink dynamically.\n\nLet's take a quick look at a simple example of a multidimensional array:\n\nExplanation: We created a 2D vector in which each element is a vector in itself.\n\nA multidimensional vector can be of any type depending on the dimensions, but the most commonly used multidimensional vectors are:\n\nIn this article, we will primarily discuss these two multidimensional vectors and how to use them in a C++ program.\n\nIn C++, 2D Vectors or Two-Dimensional Vectors are the vectors in which each element is a 1D vector of any type. It is generally used to store the information in the tabular form where each vector element represents a row in the table and each element in this vector represents a column.\n\nThe different syntax to create and initialize 2D vectors in C++ are as follows:\n\nThe below example demonstrates these methods of to create a vector:\n\nTo know more methods of initialization, refer to this article - Initialize 3D Vector in C++\n\nThe basic operations on 2D vectors have to be done by keeping in mind that each element is a vector.\n\nThe below example demonstrates how to perform these basic operations on a 2D vector\n\nIn C++, 3D Vectors or Three-Dimensional Vectors are vectors where each element is a 2D vector. These vectors are used to represent data in a 3D space which can be visualized as the space where each 2D vector can be thought of as a layer, and each element within it represents rows and columns.\n\nThe different syntax to create and initialize 3D vectors in C++ are as follows:\n\nAs we can see, the syntax of 3D vector is more complex than 2D vector and this complexity keep growing with additional dimensions. Let's look at a simple example to create a 3D vector.\n\nThe below table shows how to perform the basic operations such as insertion, deletion on 3D vectors:\n\nThe basic operations on 3D vectors must account for the fact that each element is a 2D vector.\n\nTo access an element, first access the 2D vector at the i-th index, then the row at the j-th index, and finally the k-th element in that row. Assign the accessed element a new value using the assignment operator. To insert an element at v[i][j][k], access the 2D vector at i-th index, then the row at j-th index, and use insert() to add an element at k-th index. To delete the element at v[i][j][k], access the 2D vector at i-th index, the row at j-th index, and use erase() to remove the element at k-th index. Traversal requires iterating through the 3D vector, each 2D vector (layer), and its individual rows and columns.\n\nThe following example demonstrates how to create a 3D vector and perform basic operations like accessing, updating, inserting, deleting, and traversing elements.\n\nThe below examples demonstrate some of the common operations and examples of multidimensional vectors in C++:"
    },
    {
        "link": "https://en.cppreference.com/w/cpp/container/vector",
        "document": "The elements are stored contiguously, which means that elements can be accessed not only through iterators, but also using offsets to regular pointers to elements. This means that a pointer to an element of a vector may be passed to any function that expects a pointer to an element of an array.\n\nThe storage of the vector is handled automatically, being expanded as needed. Vectors usually occupy more space than static arrays, because more memory is allocated to handle future growth. This way a vector does not need to reallocate each time an element is inserted, but only when the additional memory is exhausted. The total amount of allocated memory can be queried using capacity() function. Extra memory can be returned to the system via a call to shrink_to_fit()[1].\n\nReallocations are usually costly operations in terms of performance. The reserve() function can be used to eliminate reallocations if the number of elements is known beforehand.\n\nThe complexity (efficiency) of common operations on vectors is as follows:\n• Insertion or removal of elements at the end - amortized constant .\n• Insertion or removal of elements - linear in the distance to the end of the vector .\n\n(for other than bool) meets the requirements of Container, AllocatorAwareContainer(since C++11), SequenceContainer, ContiguousContainer(since C++17) and ReversibleContainer.\n\nAll member functions of are constexpr: it is possible to create and use objects in the evaluation of a constant expression. However, objects generally cannot be constexpr, because any dynamically allocated storage must be released in the same evaluation of constant expression.\n• is In libstdc++,is not available in C++98 mode.\n\nThe type of the elements. must meet the requirements of and . The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type is a complete type and meets the requirements of , but many member functions impose stricter requirements. The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type meets the requirements of Erasable, but many member functions impose stricter requirements. This container (but not its members) can be instantiated with an incomplete element type if the allocator satisfies the allocator completeness requirements. An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory. The type must meet the requirements of . if is not the same as .\n\nThe standard library provides a specialization of for the type bool, which may be optimized for space efficiency.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/2d-vectors-in-c-plus-plus",
        "document": "Also referred to as vector of vectors, 2D vectors in C++ form the basis of creating matrices, tables, or any other structures, dynamically. Before arriving on the topic of 2D vectors in C++, it is advised to go through the tutorial of using single-dimensional vectors in C++.\n\nIt would be impossible for us to use vectors in C++, if not for the header files that are included at the beginning of the program. To make use of 2D vectors, we include:\n\nInstead of including numerous kinds of Standard Template Libraries (STL) one by one, we can include all of them by:\n\nFirstly, we will learn certain ways of initializing a 2-D vector. The following code snippet explains the initialization of a 2-D vector when all the elements are already known.\n\nAfter running the above code, we get the following output:\n\nThe use of symbolizes that we are working on a vector of vectors. Each value inside the first set of braces, like and are vectors independently.\n\nSince we are working on a two-dimensional data structure, we require two loops for traversing the complete data structure, efficiently. The outer loop moves along the rows, whereas the inner loop traverses the columns.\n\nSpecifying the size for 2D Vector Initialization\n\n2D vectors can be of large sizes. We can not expect the programmer to feed-in every single value. Therefore, we can initialize a 2-D vector on the basis of the number of rows and columns.\n\nThe output would be:\n\nAccording to the standard initialization of a vector, , the first argument denotes the size of the vector whereas the second denotes the default value every cell holds.\n\nIn the above code snippet, we follow two steps of standard initialization:\n• - In this statement, we create a single-dimensional vector called , which has length defined by and default values as . It basically forms each row of our two-dimensional vector.\n• - In this statement, we create our complete two-dimensional vector, by defining every value of the 2-D vector as the created in the last statement.\n\nAfter understanding the above procedure, we can improve our initialization of 2D vectors in C++ by:\n\nThe above code, will provide the similar output as before, since we are doing the exact same thing, but in a single line of code.\n\nIf we remember correctly, the standard initialization looks somewhat like the above one. Creating a two-dimensional vector requires us to set the default value for every element as a single-dimensional vector.\n\nThe last method involves creating a 2-D vector without the knowledge of rows or columns. It is done by:\n\nThe above declaration creates an empty container capable of storing elements in the form of vectors.\n\nInstead of traversing a 2D vector using indices, C++ has a provision of iterators for every specific STL data structure.\n\nThe iterators come in handy when we use certain operations that require an argument for positioning. The two most used functions returning iterator values are:\n• - It returns an iterator to the first vector in a 2-D vector.\n• - It returns an iterator to the end of the 2-D vector.\n\nLet us look at some operations possible on a 2-D vector.\n\nTo add elements at the end of a two-dimensional vector, we use function.\n\nSince our container is a vector of vectors, it would only make sense to push complete vectors inside it. Therefore, the argument passed inside the function must be a vector.\n\nTo add a complete vector at a specific location, we use the function.\n\nThe function requires a positional argument as an iterator not as an integral index. It is followed by a vector that is supposed to be inserted at the specified location.\n\nRemoving elements from 2D vectors in C++\n\nOpposite to the , C++ provides function with the duty of removing the last element from the given vector.\n\nIn the context of this article, function would be responsible for removing the last vector from a 2-D vector.\n\nIn addition to the function, we have an function using which we can remove elements from a specified index.\n\nSimilar to the function, it requires a positional argument as an iterator. To remove all the vectors from the 2-D vector, function can be used.\n\nThe above functions might be enough to get comfortable while using 2-D vectors in C++.\n\nTwo-dimensional vectors in C++ are very easy to use, provided that the programmer is aware of the syntax involved. This kind of vector comes in handy when we solve problems related to matrices, graphs, and other two-dimensional objects.\n\nWe hope that this tutorial enlightened the reader on the topic of using 2-D vectors. Feel free to comment below for any queries related to the topic."
    },
    {
        "link": "https://geeksforgeeks.org/vector-in-cpp-stl",
        "document": "In C++, vector is a dynamic array that stores collection of elements same type in contiguous memory. It has the ability to resize itself automatically when an element is inserted or deleted.\n\nVector is defined as the std::vector class template inside the <vector> header file.\n\nwhere T is the type of elements and v is the name assigned to the vector.\n\nCreating a vector involves creating an instance of std::vector class. This requires us to provide the type of elements as template parameter.\n\nWe can also provide the values to be stored in the vector inside {} curly braces. This process is called initialization.\n\nIn the above example,\n• vector<int> v2(5, 9) creates a vector of size 5 where each element initialized to 9.\n\nMore ways to declare and initialize vectors are discussed in this article – 8 Ways to Initialize Vector in C++\n\nAn element can be inserted into a vector using vector insert() method which takes linear time. But for the insertion at the end, the vector push_back() method can be used. It is much faster, taking only constant time.\n\nMore ways to insert an element in the vector are discussed in the article – Different Ways to Add Elements in a Vector\n\nJust like arrays, vector elements can be accessed using their index inside the [] subscript operator. This method is fast but doesn’t check whether the given index exists in the vector or not. So, there is another member method vector at() for safely accessing elements.\n\nTo know more about accessing vector elements, refer to the article – Different Ways to Access Elements in Vector\n\nUpdating elements is very similar to the accessing except that we use an assignment operator to assign a new value. It uses the same methods: [] subscript operator and vector at().\n\nMore methods to update vector elements are discussed in this article – Different Ways to Update Vector Elements\n\nOne of the common problems with arrays was to keep a separate variable to store the size information. Vector provides the solution to this problem by providing size() method.\n\nVector in C++ can be traversed using indexes in a loop. The indexes start from 0 and go up to vector size – 1. To iterate through this range, we can use a loop and determine the size of the vector using the vector size()method.\n\nWe can also use a range-based loop for simple traversal. More ways to traverse vectors are discussed in this article – Different Ways to Iterate Through Vector\n\nAn element can be deleted from a vector using vector erase() but this method needs iterator to the element to be deleted. If only the value of the element is known, then find() function is used to find the position of this element.\n\nFor the deletion at the end, the vector pop_back() method can be used, and it is much faster, taking only constant time.\n\nTo know more about the deletion of an element in the vector, refer to this article – Different Ways to Remove Elements from Vector\n\nVector is one of the most frequently used containers in C++. It is used in many situations for different purposes. The following examples aim to help you master vector operations beyond the basics.\n\nThe below table lists the time complexity of the above operations on a vector:\n\nVectors can be passed to a function as arguments just like any other variable in C++. But it is recommended to pass the vector by reference so as to avoid the copying of all elements which can be expensive if the vector is large. Refer to this article to know more – Passing Vector to a Function\n\nVector internal working is very interesting and useful to select and optimize its usage. Understanding the internal memory management also helps in modifying the default mechanism of vector to suits our needs. Refer to this article to know more – Internal Working of Vector\n\nJust like arrays, we can also create multidimensional vectors in C++. Each element of multidimensional vector can be visualized as the collection of vectors with dimension one less that the current vector. For example, 2D vectors are the collection of 1D vectors, while 3D vectors are the collection of 2D vectors and so on.\n\nWith the addition of each dimension, the complexity of operations on the vectors also increases.\n\nRefer to this article to know more – Multidimensional Vectors in C++\n\nFollowing is the list of all member functions of std::vector class in C++:\n\nAdds an element to the end of the vector. Removes the last element of the vector. Returns the number of elements in the vector. Returns the maximum number of elements that the vector can hold. Changes the size of the vector. Checks if the vector is empty. Accesses the element at a specific position, with bounds checking. Accesses the first element of the vector. Accesses the last element of the vector. Returns an iterator pointing to the first element of the vector. Returns an iterator pointing to the past-the-end element of the vector. Returns a reverse iterator pointing to the last element of the vector. Returns a reverse iterator pointing to the element preceding the first element of the vector. Inserts elements at a specific position in the vector. Removes elements from a specific position or range in the vector. Swaps the contents of the vector with those of another vector. Removes all elements from the vector. Constructs and inserts an element in the vector. Constructs and inserts an element at the end of the vector. Assigns new values to the vector elements by replacing old ones. Returns the size of the storage space currently allocated to the vector. Requests that the vector capacity be at least enough to contain a specified number of elements. Returns a direct pointer to the memory array used internally by the vector to store its owned elements. Returns a copy of the allocator object associated with the vector."
    },
    {
        "link": "https://stackoverflow.com/questions/41325425/multidimensional-vectors-in-c",
        "document": "If you are able to use C++11, multidimensional arrays and vectors of vectors can be initialized in a similar manner.\n\nHowever, there are differences that must be understood to access the elements without running into undefined behavior.\n\nFor a multidimensional array, memory for the elements of the array is required to be allocated contiguously. For a vector of vector, the memory for the elements is most likely going to be disjoint.\n\nMemory for (most likely):\n\nAlso, it is possible to defined a vector of vectors in which the number of columns is not same for each row.\n\nIn a multidimensional array, the number of columns is guaranteed to be same for each row.\n\nGiven the above multidimensional array , will be a valid element and will be an invalid element. In the case of a vector of vectors, using the above line, is not a valid element and is a valid element."
    },
    {
        "link": "https://stackoverflow.com/questions/62792301/which-c-stl-data-structure-will-be-the-most-efficient-for-storing-unique-value",
        "document": "A simple and straightforward solution was suggested to you by @songyuanyao and @RahulGupta: Use a map - an std::map if you want to interate your value-counts in increasing order, or an std::unordered_map if you don't care about the order. This will be easy to write and maintain, and kind-of-ok in terms of the time of inserting or removing an element. Still, both of these map structures are quite slow , so you might rethink whether you even want a standard-library map implementation.\n\nAn alternative solution - which is more efficient in terms of space and time if you perform a lot of reads and few inserts/updates - is what @KonradRudolph suggested in a comment: or ; and make sure the is large enough that you don't exceed it, but as small as it can be to reduce the amount of time you need for reading the whole structure. These will use a lot less space than the maps, since there are no bucket-lists, no empty\n\nNote that the choice between a vector-of-pairs or a pair-of-vectors is a common dilemma in data structure design, and is also known as \"structure of arrays vs array of structs\", or SoA vs AoS. See a concrete example here on the site and there are many others. AoS is better when you usually access both fields, and need the corresponding values together; SoA is better when you often need just one field (e.g. you want to sum up the counts between some range of values; or you want to obtain the set of all prime values etc.) This also relates to the architecture of databases - row-oriented vs column-oriented, with the former being more appropriate for transaction processing and the latter for analytic workloads."
    },
    {
        "link": "https://geeksforgeeks.org/set-in-cpp-stl",
        "document": "In C++, sets are associative container which stores unique elements in some sorted order. By default, it is sorted ascending order of the keys, but this can be changes as per requirement. It provides fast insertion, deletion and search operations.\n\nExplanation: In the above program, we create a set with name s values {3, 5, 2, 1}.\n\nThe set container is defined as std::set class template inside <set> header file.\n• T: Data type of elements in the set.\n• s: Name assigned to the set.\n• comp : It is a binary predicate function that tells set how to compare two elements. It is used to sort set in custom order. It is optional and if not provided, set is sorted in increasing order.\n\nWe can declare and initialize a set in multiple ways as shown in the below code:\n\nExplanation: In this program, we create two sets:\n\nTo know more ways to initialize set in C++, refer to the article – Different Ways to Initialize Set\n\nHere are the basic operations that can be performed on a set:\n\nIn set, elements are added using the insert() or emplace() function. If the element already exists in the set, it will not be added again. We cannot specify the position to insert the element as it is automatically decided according to the order.\n\nIf you want to read more about this topic, then refer this article – Different Ways Insert Elements into Set\n\nWe can’t access elements of a set by index like in an array or vector. In set, we have to increment or decrement iterator obtained from begin() or end() methods respectively to access the element by position. This can also be done with the help of next() or advance() function.\n\nExplanation: In the above program, s.begin() returns an iterator to the first element of the set which is stored in it1. To access the third element, next() is used to move the iterator it1 by 2 positions and store it in it2. The *it1 and *it2 dereference the iterators to access the values at those positions.\n\nTo know more about accessing elements from set, refer this article – Different Ways to Access Elements of Set\n\nWe cannot change the value of elements once they are stored in the set.\n\nSet provides fast search by value operation using the find() member function. This function returns iterator the element if found, otherwise returns end() iterator.\n\nTo know more methods to search element in set, refer to this article – Check if Set Contains an Element\n\nJust like other containers, sets can be easily traversed using range-based for loop or using begin() and end() iterators.\n\nTo know more about on this topic, simple refer this article – Different Ways to Traverse a Set\n\nIn set, elements are removed from a set using the erase() function. We can erase elements either by value or by position.\n\nTo know more about on this topic, refer this article – Different Ways to Delete Elements from Set\n\nThe below table lists the time complexity of the above operations on set:\n\nThe following examples aim to help you master set operations beyond the basic operations.\n\nIn C++, set is an associative container that provides the implementation of Red-Black Tree. This data structure makes sure that elements are always stored in a sorted order. It also makes sure that insertion, deletion, and access operations take logarithmic time.\n\nFollowing is the primary differences between set and unordered_set in C++:\n• None Set stores elements in a sorted order and operations such as insertions, deletions, and accessing operations are takes logarithmic O(log n) in time complexity.\n• None Unordered set stores elements in an arbitrary order and insertion, deletion, and access operations are O(1) time due to the use of hashing.\n\nHere’s the list of all member functions of std::set:\n\nReturns an iterator pointing to the first element of the set. Returns an iterator pointing to the beyond of the last element of the set. Returns a reverse iterator pointing to the last element of the set. Returns a reverse iterator pointing to the element preceding the first element of the set. Returns the number of elements in the set Returns the maximum number of elements that the set can hold. Checks if the set is empty. Inserts function is used to insert an element into set. This function is used to remove an element from the set. Swaps the contents of the set with another set. Removes all elements from the set. This function is used to insert a new element into the set container. Insert multiple elements at the same time in set. Merge one set into another set. Returns the count of an elements. In set it always return 0 or 1. This function is used to find an element in the set. This function is used to whether a particular an element is present or not. Returns an iterator of pairs. The pair refers to the range that includes all the elements in the container which have a key equivalent to k. Find the first element in the set that is just greater than the given value. Find the first element in the set that is equal to or greater than the given value. Returns a copy of the comparison object used by the container."
    },
    {
        "link": "https://stackoverflow.com/questions/12826364/c-stdmap-or-stdset-efficiently-insert-duplicates",
        "document": "I have a bunch of data full of duplicates and I want to eliminate the duplicates. You know, e.g. [1, 1, 3, 5, 5, 5, 7] becomes [1, 3, 5, 7].\n\nIt looks like I can use either std::map or std::set to handle this. However I'm not sure whether it's faster to (a) simply insert all the values into the container, or (b) check whether they already exist in the container and only insert if they don't - are inserts very efficient? Even if there's a better way... can you suggest a fast way to do this?\n\nAnother question - if the data I'm storing in them isn't as trivial as integers, and instead is a custom class, how does the std::map manage to properly store (hash?) the data for fast access via operator[]?"
    },
    {
        "link": "https://mygreatlearning.com/blog/set-in-cpp",
        "document": "C++ has many valuable elements and tools that help us in competitive programming.\n\nOne such component is set present in the Standard Template Library (STL), which provides a way to efficiently store data in a sorted manner.\n\nThis guide, “Set in C++ – A Complete Reference,” dives into the detailed concept of using sets in C++, exploring their functionalities, syntax, and applications in programming.\n\nWhether you’re a professional coder looking to enhance your knowledge or a beginner eager to grasp the fundamentals, this reference will serve as your comprehensive companion in mastering sets in C++.\n\nWhat Is Set In C++?\n\nIn C++, a set is a Standard Template Library (STL) container that stores unique elements in a sorted order. Unlike arrays or vectors, set C++ does not allow duplicate elements, making them ideal for tasks where uniqueness is crucial.\n\nSets automatically arrange their elements in a specific order, typically ascending, using comparison functions. This ordered arrangement makes sets efficient for searching, insertion, and deletion operations.\n\nAdditionally, sets offer a variety of methods for manipulating and accessing their elements, making them a valuable tool in C++ programming, particularly for tasks involving data organization and retrieval.\n\nIn C++, sets are part of the Standard Template Library (STL) and are implemented through the std::set class template. Here’s the syntax:\n\nIn the above syntax:\n• DataType is the type of elements that the set will hold.\n• set_name is the name of the set.\n• The value represents the elements you want to insert or remove from the set.\n\nSets in C++ automatically order their elements based on their values and don’t allow duplicate elements.\n\nWhen To Use Sets?\n\nSets in C++ are particularly useful in scenarios where:\n\nIf you must store a collection of elements where each item must be unique, set c++ is the go-to choice. Whether it’s a list of unique identifiers, names, or any other data where duplication isn’t allowed, sets ensure no duplicates are present.\n\nC++ sets automatically arrange their elements in sorted order, making them efficient for tasks that require elements to be accessed or retrieved in a specific sequence. This ordered arrangement simplifies searching for elements and ensures that iteration over the set follows a predictable order.\n\nSets provide a fast and efficient way to check whether a particular element is present in the collection. This is especially beneficial when dealing with large datasets, as sets offer logarithmic time complexity for insertion, deletion, and search operations.\n\nSets support various set operations like intersection, union, and difference, which can be immensely helpful in tasks involving comparisons and computations among multiple sets.\n\nSome of the C++ set examples are shared below for better understanding:\n• Suppose you’re developing a program to manage a database of student records. Using sets in C++, you can ensure that each student’s ID is unique, preventing duplicate entries.\n• In a financial application, sets can be employed to maintain a sorted list of transactions. This facilitates efficient searching and retrieval of specific transactions based on criteria such as date or amount.\n• When dealing with geometric shapes in a graphics application, sets can help ensure each shape is unique, allowing for easy manipulation and comparison of different shapes.\n• Sets in C++ provide a versatile and efficient way to handle collections of unique elements while maintaining a sorted order. Whether working on data manipulation, algorithm design, or any other programming task, understanding when and how to use sets can significantly enhance your efficiency and productivity.\n\nSets in C++ store elements in a sorted order. This means the elements are automatically arranged in ascending order based on their values.\n\nAll elements in a set must have unique values. Duplicate values are not allowed within a set, ensuring that each element is distinct.\n\nOnce an element is added to a set, its value cannot be modified. While removing an element and adding a modified version of it is possible, the original value remains immutable within the set.\n\nSets in C++ typically utilize a binary search tree implementation for efficient searching. This implementation allows for fast retrieval of elements, especially in large datasets.\n\nA set’s values are unindexed, meaning each element has no specific index. Instead, elements are arranged solely based on their values within the set’s sorted order.\n\nGreat Tip To The Great Learners\n\nIf you need to store elements in an unsorted (random) order, you can use the unordered_set() container in C++. This container offers similar functionality to sets but does not maintain a specific order among its elements, providing a different approach to data storage based on hashing.\n\nJoin the ranks of elite programmers – Enroll in “Introduction to C++” now!\n\nHow To Create A Set In C++?\n\nTo create a set in C++, you can use the std::set class from the Standard Template Library (STL). Sets automatically order their elements and do not allow duplicates.\n\nHere’s a code example demonstrating how to create a set, along with an explanation and the expected output:\n• We include the necessary headers <iostream> and <set> to work with sets.\n• We create a set of integers named mySet using the std::set<int> syntax.\n• Elements are added to the set using the insert() method. Note that attempting to add duplicate elements (e.g., 3) will not change the set because sets do not allow duplicates.\n• We iterate through the set using a range-based for loop to print its elements.\n• The size of the set is obtained using the size() method and printed to the console.\n\nGreat Tip To The Great Learners\n\nWe cannot use the [ ] operator to add elements to a set. Doing so will result in an error.\n\nHow To Sort A Set In Descending Order C++?\n\nIn C++, by default, std::set orders its elements in ascending order. If you want to sort set in decreasing order C++, you can use the std::greater comparator with std::set. Here’s how you can do it:\n• We include the necessary headers <iostream> and <set> to work with sets.\n• We create a set of integers named mySet using the std::set<int, std::greater<int>> syntax, where std::greater<int> is a comparator that sorts elements in descending order.\n• Elements are added to the set using the insert() method.\n• When we iterate through the set, the elements are automatically sorted in descending order due to the comparator specified during the set’s creation.\n\nIf you are a beginner, accelerate your learning curve with our beginner’s guide: “C++ Tutorial for Beginners” blog!\n\nReturns the number of elements in the set.\n\nIn this example, a set of integers mySet is created, and three elements (10, 20, and 30) are inserted. The size() function is then used to retrieve the number of elements present in the set, which is 3. Finally, the size of the set is printed to the console.\n\nCheck if the set is empty. Returns true if the set contains no elements; otherwise, it is false.\n\nIn this example, a set of integers called mySet is created. The empty() function is then used to check if the set is empty. Since no elements have been inserted into the set, the function returns true, indicating that it is empty.\n\nInserts a new element with the specified value into the set.\n\nIn this example, a set of integers mySet is created, and three elements (10, 20, and 30) are inserted into it using the insert() function. The elements of the set are then printed to the console, showing that they are stored in sorted order.\n\nRemoves the element with the specified value from the set if it exists.\n\nThis example creates a set of integers mySet with elements 10, 20, 30, and 40. The erase() function is then used to remove the element with the value 20 from the set. After erasing, the remaining elements of the set are printed to the console, showing that 20 has been successfully removed from the set.\n\nSearches for the element with the specified value in the set. Returns an iterator to the element if found; otherwise, returns set::end().\n\nIn this example, a set of integers, mySet, is created with elements 10, 20, 30, and 40. The find() function is then used to search for the element with the value 20 in the set. Since the element is found, the function returns an iterator pointing to it. The result is printed to the console, indicating that element 20 is found in the set.\n\nRemoves all elements from the set, leaving it empty.\n\nIn this example, a set of integers, mySet, is created with elements 10, 20, 30, and 40. The clear() function removes all elements from the set, leaving it empty. After clearing, the size of the set is printed to the console, which shows that it is empty.\n\nReturn iterators pointing to the first and past-the-end elements of the set, respectively. These iterators can be used to traverse the set.\n\nIn this example, a set of integers, mySet, is created with elements 10, 20, 30, and 40. The begin() function returns an iterator pointing to the first element of the set, while the end() function returns an iterator pointing to the position just after the last element. Using these iterators, a loop is employed to iterate over the set’s elements and print them to the console.\n\nReturn iterators to the first element not less than (lower_bound) or greater than (upper_bound) a given value.\n\nThis example creates a set of integers mySet with elements 10, 20, 30, and 40. The lower_bound(20) function returns an iterator to the first element not less than 20, while the upper_bound(30) function returns an iterator to the first element greater than 30.\n\nUsing these iterators, a loop is employed to iterate over the elements between lower_bound and upper_bound (excluding upper_bound) and print them to the console.\n\nThese c++ set functions provide essential functionality for adding, removing, searching, and managing elements within a set in C++.\n\nAlso, Learn everything you need to know about C++ Functions\n\nSome Other Functions Of Set In C++\n\nBuild a stellar portfolio with these handpicked “C++ Projects To Work On In 2024“\n\nIn conclusion, “Set in C++ – A Complete Reference” offers a comprehensive guide to mastering sets in C++, providing essential knowledge for efficient data organization and manipulation.\n\nWhether you’re a beginner learning the basics or an experienced programmer seeking advanced techniques, this reference equips you with the skills to effectively leverage sets in your C++ projects.\n\nAdditionally, if you’re looking to expand your programming skills further, Great Learning offers two distinct courses: a Free C++ Tutorial Course and a Software Development Course.\n\nThe Free C++ Tutorial Course is an ideal starting point for learning C++ from scratch, covering fundamental concepts with practical examples.\n\nOn the other hand, the Software Development Course delves deeper into software engineering principles, equipping you with the expertise needed to excel in real-world software development projects.\n\nWhether aiming to enhance your programming proficiency or embark on a career in software development, Great Learning provides tailored courses to suit your learning goals."
    },
    {
        "link": "https://reddit.com/r/cpp/comments/tpm99u/will_stdset_and_stdunordered_set_implement_extra",
        "document": "In below link, I wrote a quick benchmark for maximum 32 unique positive numbers (unknown lower-bounds, unknown upper-bounds like {34,100,1000,21,22,23,...5,1231239}) accumulated over 1000 random numbers generated by rand() and modulo:\n\nAvx512 test (less than 10 cycles per insert): https://rextester.com/HGJ59369\n\nJust a simple array, possibly auto-vectorized, is 70% faster (400% if rand() is not included) than std::unordered_set when there are an influx of random duplicated numbers (but only 32 uniques total). Will C++ std::unordered_set implementations benefit from optimizations below?\n\n- hint parameter given at constructor so that it does \"insert\" operation faster depending on input pattern or the expected maximum unique values (and their lower-upper limits too)\n\n- execution policy such as par, par_unseq, unseq given at constructor to enable different optimizations\n\nI think this can be useful for gaining more performance for some particle-physics simulations where particles are computed for their collisions in spatial acceleration structures with maximum n number of particles at a time (so that an atom may not bind to 33 atoms at once) and they get (by parallel computations) some duplicated atom-id values in same list. Sorting takes extra time and std::set is literally 1-liner to filter any duplicates whether input is sorted or not.\n\nSo, will std::unordered_set or std::set get some extra buff in future, to be much faster for corner cases?"
    },
    {
        "link": "https://udacity.com/blog/2020/03/c-maps-explained.html",
        "document": "Looking to learn more about maps in C++ and how to use them? Then this article is for you. We cover the details on how exactly to use maps, present some use cases for them and explain when to avoid them entirely. Let’s dive in.\n\nWhat is a map in C++?\n\nA C++ map is a way to store a key-value pair. A map can be declared as follows:\n\nEach map entry consists of a pair: a key and a value. In this case, both the key and the value are defined as integers, but you can use other types as well: strings, vectors, types you define yourself, and more.\n\nThere are two main reasons why the map type can be valuable to C++ developers. First, a map allows fast access to the value using the key. This property is useful when building any kind of index or reference. Second, the map ensures that a key is unique across the entire data structure, which is an excellent technique for avoiding duplication of data.\n\nBy virtue of these two advantages, a map is a common choice if you’re developing, for instance, a trading application in which you need to store stock prices by ticker symbol. If you’re creating a weather application, a map would be an effective way to save and look up the current temperature in a set of cities around the world. In an e-commerce store, you’ll likely need a map to find products by identifiers or categories.\n\nHow do I use a map in C++?\n\nThe primary operations you’ll perform with a map are creating a new map, adding elements to and reading elements from a map, and iterating through every element in a map. Let’s take a look at each of these actions.\n\nThere are five ways to construct a map in C++, but two of them are much more commonly used than the others. The first way is to create an empty map, then add elements to it:\n\nIn this example, we create a map that uses integers as keys and strings as values. We use the pair construct to create a key-value pair on the fly and insert that into our map.\n\nThe second often-used option is to initialize the map to a list of values at declaration. This option has been available since the C++11 standard and therefore isn’t supported by older compilers, but it allows for clearer declaration:\n\nOther ways to create a map include copying an existing map, copying parts of an existing map (by indicating a start position and an end position for the copy) and moving elements from another map without creating an intermediate copy.\n\nIn order to access the elements of the map, you can use array-style square brackets syntax:\n\nAnother option, available as of C++11, is the at method:\n\nWhen inserting elements into a map, it’s common to use either the square brackets syntax or the insert method:\n\nIn some cases, you might need to walk through a map and retrieve all the values in it. You can do this by using an iterator—a pointer that facilitates sequential access to a map’s elements.\n\nAn iterator is bound to the shape of the map, so when creating an iterator you’ll need to specify which kind of map the iterator is for. Once you have an iterator, you can use it to access both keys and values in a map. Here’s what the code would look like:\n\nIn this example, the map contains pairs of <int, string>, so we create an iterator that matches that format. We use the sample_map.begin() method to point the iterator to where it should start, and indicate that the for loop should stop when we reach the sample_map.end() location—the end of the map.\n\nThe iterator provides an it->first function to access the first element in a key-value pair (the key), and then it->second can be used to access the value. So, using the example above, we would print out only the values from our sample map.\n\nWhen not to use a C++ map\n\nThe map in C++ is a great fit for quickly looking up values by key. However, searching the contents of a map by value requires iterating through an entire map. If you want to be able to find values in a map, iterating through it can be slow as a map gets large.\n\nThe Boost library offers a bi-directional map which performs better when searching for values often. This data structure isn’t included in the standard C++ library, so you’ll need to install the Boost library on each machine where you compile or run your program (dynamic linking), or alternatively include the Boost library inside your executable (static linking).\n\nIf you find yourself needing to search a map by value in a relatively simple program, it may be that a map is the wrong object to use. Consider using a C++ vector, queue, stack or other data structure which might end up making the program more straightforward and more efficient.\n\nDoes order matter in C++ maps?\n\nTo demonstrate whether order is important in C++ maps, we’ve slightly modified the above example to insert the element { 4, “four” } before inserting { 3, “three” }:\n\nWhen we run the program, the output is still the same as before, even though the order in which we add elements has changed!\n\nThis is because maps in C++ keep their elements ordered by key. Also, in C++ a map can’t contain duplicate items, so using a map is a way to simultaneously deduplicate and order a set of elements.\n\nIf you don’t care about the order of elements in a map, consider using an unordered_map element, which is faster at adding and accessing elements than a regular map.\n\nYou definitely can! Just make sure that the format of the map reflects your intentions:\n\nIn this example, the inner map object acts as a value in the outer map.\n\nIf you’d like to see the list of all available methods for a map object, check out the map reference. If you’re looking for more examples of map usage, consider reading the C++ map tutorial usage guide.\n\nIn this article, we walked you through what a C++ map is and how to use one. We showed you a few examples of adding elements, reading them and traversing the map.\n\nWould you like to learn more about C++? Sign up for our C++ Nanodegree program."
    },
    {
        "link": "https://stackoverflow.com/questions/7856453/accessing-map-value-by-index",
        "document": "If I have a structure like\n\nI know that the map sorts internally and I'm fine with this, I want to get a value in the map by index. I've tried myMap[0] but I get the error:\n\nI realise I could do something like this:\n\nBut surely this is hugely inefficient? Is there a better way?"
    },
    {
        "link": "https://en.cppreference.com/w/cpp/container/map",
        "document": "is a sorted associative container that contains key-value pairs with unique keys. Keys are sorted by using the comparison function . Search, removal, and insertion operations have logarithmic complexity. Maps are usually implemented as Red–black trees.\n\nIterators of iterate in ascending order of keys, where ascending is defined by the comparison that was used for construction. That is, given\n• and , dereferenceable iterators to , with .\n\nm.value_comp()(*it_l, *it_r) == true (least to greatest if using the default comparison).\n\nEverywhere the standard library uses the Compare requirements, uniqueness is determined by using the equivalence relation. In imprecise terms, two objects a and b are considered equivalent (not unique) if neither compares less than the other: !comp(a, b) && !comp(b, a).\n\nmeets the requirements of Container, AllocatorAwareContainer, AssociativeContainer and ReversibleContainer.\n\nAll member functions of are constexpr: it is possible to create and use objects in the evaluation of a constant expression. However, objects generally cannot be constexpr, because any dynamically allocated storage must be released in the same evaluation of constant expression.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://stackoverflow.com/questions/16075146/c-index-to-index-map",
        "document": "I have a list of IDs (integers). They are sorted in a really efficient way so that my application can easily handle them, for example\n\n(this sort is really important in my application).\n\nNow I am facing the problem of having to access certain values of an ID in another vector.\n\nFor example certain values for ID 9382 are located on someVectorB[30].\n\nI have been using\n\nBut now that I raised UNITS_MAX_SIZE to 400.000, I get page stack errors, and that tells me that I am doing something wrong. I think the entire approach is not really good.\n\nWhat should I use if I want to locate an ID in a different vector if the \"position\" is different?\n\nps: I am looking for something simple that can be easily read-in from a file and that can also easily be serialized to a file. That is why I have been using this brute-force approach before."
    },
    {
        "link": "https://geeksforgeeks.org/map-associative-containers-the-c-standard-template-library-stl",
        "document": "In C++, maps are associative containers that store data in the form of key value pairs sorted on the basis of keys. No two mapped values can have the same keys. By default, it stores data in ascending order of the keys, but this can be changes as per requirement.\n\nExplanation: In the above program, we created a map m of integer keys and string values. We inserted three key-value pairs into the map: {1, “Geeks”}, {2, “For”}, and {3, “Geeks”}. The map automatically sorts the keys in ascending order.\n\nThe map container is defined as std::map class template inside the <map> header file.\n• comp: Custom comparator function that defines how to compare two keys for sorting. It is optional and if not provided, sorts data in increasing order of the keys.\n\nWe can declare and initialize a map in different ways as shown in the below example:\n\nExample: In the above program,\n• map<int, string> m1 is an empty map with no elements.\n• map<int, string> m2 = {{1, “Geeks”}, {2, “For”}, {3, “Geeks”}} initialized to three key-value pairs using initializer list.\n\nTo see more ways to declare and initialize map, refer to this article – Different Ways to Initialize a Map\n\nBasic operations on map containers are shown below:\n\nElements can be inserted into a map using either [] operator or insert() method. If the element with the given key already exists, the insert() method skips the insertion but [] operator updates the associated value to the new value.\n\nWe cannot specify any particular position to insert element as map automatically sort the data according to the order. To know more ways to insert elements in a map, refer this article – Different Ways to Insert Elements in a Map\n\nMap elements can be accessed by using the corresponding key inside operator []. If the key exists, it will return the associated value but if the key doesn’t exist, it will create a new element with the given key and the default value. To avoid this, we can also use at() method for accessing elements with any modification.\n\nTo know more methods to access values in a map, refer to the article – Different Ways to Access a Value in a Map\n\nThe key of an already present elements cannot be modified in the map. But the associated value can be changed by first accessing the element and then using assignment operator to change the value.\n\nExplanation: In this program, expression m[0] = “Tweaks” updates the value associated with the key 0. Similarly, expression m.at(1) = “By” updates the value of the key 1.\n\nTo see more methods to update values in a map, refer to the article – Different Ways to Update Value of a Pair in Map\n\nMap provides fast element search by key using the find() member function. This function returns iterator the element if found, otherwise returns end() iterator.\n\nTo know more methods to search element in map, refer to this article – Check if Map Contains a Specific Key\n\nMaps can be easily traversed by using either range based for loop or using begin() and end() iterator with traditional loops.\n\nTo see more methods to traverse a map, refer to the article – Different Ways to Traverse a Map\n\nMap elements can be deleted from a map using erase() method by passing the key or an iterator.\n\nTo know more ways to delete elements in a map, refer this article – Different Ways to Delete Elements from Map\n\nThe below table lists the time complexity of the above operations on map:\n\nFollowing are some other commonly used operations on a map in C++:\n\nIn C++, map is an associative container that provides the built-in implementation of Red-Black Tree. It stores the elements in some sorted order on the basis of keys. Due do RB Trees, insertion, deletion, and search operations takes logarithmic O(log n) time.\n\nHere’s the list of all member functions of std::map:\n\nInsert elements with a particular key in the map container. Returns an iterator of pairs. The pair refers to the bounds of a range that includes all the elements in the container which have a key equivalent to k. Used to erase elements from the map. Returns an iterator pointing to the first element of the map. Returns an iterator pointing to the first element of the map. Returns a reverse iterator pointing to the element preceding the first element of the map Returns a reverse iterator pointing to the last element of the map. Returns an iterator to the element with key-value in the map if found, else returns the iterator to end. crbegin() returns a constant reverse iterator referring to the last element in the map container. crend() returns a constant reverse iterator pointing to the theoretical element before the first element in the map. cbegin() returns a constant iterator referring to the first element in the map container. cend() returns a constant iterator pointing to the element that is beyond the last element. Inserts the key with value in the map container. Returns the maximum number of elements a map can hold. Find the first element in the map that is just greater than the given key. Find the first element in the map that is equal to or greater than the given key. Inserts the key and its element in the map container with a given hint. Returns the object that determines how the elements in the map are ordered (‘<‘ by default). Returns the object that determines how the elements in the map are ordered (‘<‘ by default). Returns the number of elements in the map. Returns whether the map is empty. Removes all the elements from the map. at() function is used to the element associated with the key k. swap() function is used to exchange the contents of two maps but the maps must be of the same type, although sizes may differ."
    }
]