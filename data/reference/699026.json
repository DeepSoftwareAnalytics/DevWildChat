[
    {
        "link": "https://docs.aiogram.dev/en/stable/dispatcher/filters/command.html",
        "document": "# Bot token can be obtained via https://t.me/BotFather # All handlers should be attached to the Router (or Dispatcher) # Most event objects have aliases for API methods that can be called in events' context # For example if you want to answer to incoming message you can use `message.answer(...)` alias # and the target chat will be passed to :ref:`aiogram.methods.send_message.SendMessage` Handler will forward receive a message back to the sender By default, message handler will handle all message types (like a text, photo, sticker etc.) # But not all the types is supported to be copied so need to handle it # Initialize Bot instance with default bot properties which will be passed to all API calls"
    },
    {
        "link": "https://docs.aiogram.dev",
        "document": "# Bot token can be obtained via https://t.me/BotFather # All handlers should be attached to the Router (or Dispatcher) # Most event objects have aliases for API methods that can be called in events' context # For example if you want to answer to incoming message you can use `message.answer(...)` alias # and the target chat will be passed to :ref:`aiogram.methods.send_message.SendMessage` Handler will forward receive a message back to the sender By default, message handler will handle all message types (like a text, photo, sticker etc.) # But not all the types is supported to be copied so need to handle it # Initialize Bot instance with default bot properties which will be passed to all API calls"
    },
    {
        "link": "https://docs.aiogram.dev/en/dev-3.x/dispatcher/filters/command.html?highlight=command",
        "document": "This filter can be helpful for handling commands from the text messages.\n\nWorks only with events which have the ."
    },
    {
        "link": "https://docs.aiogram.dev/en/latest/dispatcher/filters/index.html",
        "document": "Filters is needed for routing updates to the specific handler. Searching of handler is always stops on first match set of filters are pass. By default, all handlers has empty set of filters, so all updates will be passed to first handler that has empty set of filters.\n\naiogram has some builtin useful filters or you can write own filters.\n\nand should return bool or dict. If the dictionary is passed as result of filter - resulted data will be propagated to the next filters and handler as keywords arguments. If you want to register own filters like builtin filters you will need to write subclass of this class with overriding the method and adding filter attributes. This method should be overridden. Accepts incoming event and should return boolean or dict. Also if you want to extend handler flags with using this filter you should implement this method For example if you need to make simple text filter:\n\nIn general, all filters can be combined in two ways If you specify multiple filters in a row, it will be checked with an “and” condition: Also, if you want to use two alternative ways to run the same handler (“or” condition) you can register the handler twice or more times as you like Also sometimes you will need to invert the filter result, for example you have an IsAdmin filter and you want to check if the user is not an admin An alternative way is to combine using special functions ( , , from module):"
    },
    {
        "link": "https://docs.aiogram.dev/en/dev-3.x/dispatcher/filters/command.html?highlight=Command",
        "document": "This filter can be helpful for handling commands from the text messages.\n\nWorks only with events which have the ."
    },
    {
        "link": "https://medium.com/sp-lutsk/exploring-finite-state-machine-in-aiogram-3-a-powerful-tool-for-telegram-bot-development-9cd2d19cfae9",
        "document": "In the realm of Telegram bot development, the quest for efficiency and robustness is an ongoing endeavor. With each iteration, developers seek tools and frameworks that streamline the development process while ensuring the scalability and maintainability of their bots. In this pursuit, the integration of Finite State Machines (FSMs) has emerged as a powerful technique, providing a structured approach to managing bot behavior. In this article, we delve into the integration of Finite State Machines within the Aiogram 3 framework, a powerful option for Telegram bot development in Python. Aiogram, renowned for its simplicity and flexibility, empowers developers to build feature-rich bots effortlessly. By using FSM, it can become even more seamless, offering developers a structured approach to handling complex bot behavior.\n\nA Finite State Machine (FSM) is a computational model used to describe the behavior of a system by dividing it into a finite number of states, along with transitions between these states based on certain conditions or events. At its core, an FSM consists of the following components:\n• States: These represent the distinct conditions or modes that the system can be in at any given time. Each state encapsulates a specific set of behaviors or actions that the system can perform while in that state.\n• Transitions: These define the conditions or events that trigger a change in state. When a transition occurs, the system moves from one state to another, potentially altering its behavior or internal configuration.\n• Inputs/Events: These are the stimuli or signals that drive the transitions between states. Inputs can come from various sources, such as user interactions, sensor readings, or external events. In Aiogram 3, the integration of Finite State Machines offers developers a remarkable opportunity to manage the intricate flow of user inputs with ease. By guiding users through a sequence of defined states and handling each state separately, FSMs empower developers to create Telegram bots that gracefully navigate through complex interaction scenarios. This capability allows for the systematic handling of user inputs, ensuring a seamless conversational experience for bot users.\n\nTo better comprehend the theoretical aspects of Finite State Machines (FSM) in Aiogram, let’s embark on a practical journey. Imagine we’re creating a form within our Telegram bot where we sequentially ask users a series of questions, concluding with a confirmation of the collected answers. In Aiogram, FSMs are represented as StatesGroups, serving as the foundation for organizing bot behavior into distinct states and managing transitions between them. The schema below illustrates the sequential flow of our form within the FSM framework: Starting with the creation of a StatesGroup, we establish a structured environment for managing the flow of user interactions. Each state within the StatesGroup corresponds to a specific stage in our form, guiding users through a sequence of questions and responses. As users progress through the form, transitions between states occur based on their inputs, ensuring a smooth and intuitive user experience. Now, let’s delve into the implementation details. Below, you’ll find the code snippet illustrating the creation of the StatesGroup with Aiogram: After defining the StatesGroup for our form, the next step is to establish handlers to manage user interactions. Typically, a conversation with the bot initiates with the /start command. Therefore, our first task is to handle this command and transition the user to the initial state of our form, Form.About.first_name. Below is a snippet showcasing the implementation of the handler for the /start command and the transition operation to the first state: We have added two buttons for this question — “Skip” and “Cancel”, we will cover them later. After the user answers the first question, we need to store the answer in the storage and move on to the next step. Code snippet to handler first state and transition to second state: In this handler, we’ve successfully stored the user’s input for the first question and will now progress to the next question. Additionally, we’ll incorporate an “Go back” button later, enabling users to make transition to the previous question. Following a consistent sequence, each subsequent handler will entail the same actions: saving the user’s response, transitioning to the subsequent step, and posing the subsequent question. Upon reaching the final state, Form.confirm, users will be presented with all collected information for review. With the implementation of the described logic, our bot is now equipped to traverse through all defined states, guiding users through each step of the form.\n\nIncorporating various options to enhance user flexibility during Finite State Machine (FSM) integration in Aiogram is crucial for providing a smoother user experience. Among these options is the ability to terminate the flow, facilitated by the addition of a “Cancel” button. This button should be accessible from any state within the FSM, necessitating a single handler to manage its functionality. This handler will be responsible for clearing the current state and sending an appropriate message to the user, indicating the cancellation of the flow. @form_router.message(Command(\"cancel\"))\n\n@form_router.message(F.text.casefold() == \"cancel\")\n\nasync def cancel_handler(message: Message, state: FSMContext) -> None:\n\n \"\"\"\n\n Allow user to cancel any action\n\n \"\"\"\n\n current_state = await state.get_state()\n\n if current_state is None:\n\n return To introduce the “Go back” button functionality, enabling users to transition to the previous state, we need to implement an additional tool — a list containing information about the states. For this, let’s outline a data structure representing the state information. Code snippet for this: Each element of the list will be represented as dataclass with state name, question for this state, in memory representative value, corresponding button (we will need it for future step) and keyboard buttons that need to be sent to user with state question. Code snippet for first state implementation in dataclass format: State(\n\n \"Form.About:first_name\",\n\n \"What's your first name?\",\n\n \"first_name\",\n\n \"First name\",\n\n [\n\n [KeyboardButton(text=\"Skip\")],\n\n [KeyboardButton(text=\"Cancel\")],\n\n ],\n\n), All following states will have similar structure, but with additional “Go back” button. Code snippet example for following states: State(\n\n \"Form.About:last_name\",\n\n \"What's your last name?\",\n\n \"last_name\",\n\n \"Last name\",\n\n [\n\n [KeyboardButton(text=\"Skip\"), KeyboardButton(text=\"Go back\")],\n\n [KeyboardButton(text=\"Cancel\")],\n\n ],\n\n), This list of states will allow us to track the state by name and manage all of its attributes to better understand it lets review code snippet for the “Go back” button handler: @form_router.message(Command(\"go back\"))\n\n@form_router.message(F.text.casefold() == \"go back\")\n\nasync def go_back_handler(message: Message, state: FSMContext) -> None:\n\n current_state = await state.get_state()\n\n logging.info(\"Going back from %r\", current_state)\n\n (\n\n previous_state,\n\n state_message,\n\n keyboard_buttons\n\n ) = get_previous_state(current_state)\n\n if previous_state is None:\n\n await message.answer(\n\n \"You are already at the first step.\",\n\n )\n\n else:\n\n await state.set_state(previous_state)\n\n await message.answer(\n\n state_message,\n\n reply_markup=ReplyKeyboardMarkup(\n\n keyboard=keyboard_buttons,\n\n resize_keyboard=True,\n\n ),\n\n ) In this handler we get the current_state and based on that we get the previous state information using the get_previous_state method. def get_previous_state(current_state: str) -> str:\n\n current_state_index = next(\n\n (i for i, obj in enumerate(STATES_LIST) if obj.state_name == current_state),\n\n None,\n\n )\n\n previous_state_index = current_state_index - 1\n\n if previous_state_index < 0:\n\n return None, None\n\n return (\n\n STATES_LIST[previous_state_index].state_name,\n\n STATES_LIST[previous_state_index].state_question,\n\n STATES_LIST[previous_state_index].keyboard_buttons,\n\n ) This method uses created STATES_LIST to receive current state (the state from which the user wants to go back) index and based on this returns information about previous state name, questions and keyboard buttons. After this we only need to set this state and send proper message to user. Implementation of this flow shown bellow.\n\nTransition to any state in flow Now when we can cancel flow and use transition to previous state we can try to implement even more complicated operations. For this lets implement confirmation for our form. Previously we have added “Approve” and “Disapprove” buttons for final step. Handler for “Approve” button is very simple. @form_router.message(Form.confirm, F.text.casefold() == \"approve\")\n\nasync def process_confirm(message: Message, state: FSMContext) -> None:\n\n await state.clear()\n\n await message.answer(\n\n \"Thank you for your Form!\",\n\n reply_markup=ReplyKeyboardRemove(),\n\n ) We will not save any customers data in this example, so all we need — close state and send appropriate message. To implement “Disapprove” function lets add another state — “confirm_reject”, after it our StatesGroup looks like this: Handler for “Disapprove” button will set this state and send message with proposition to change any of inputed data. @form_router.message(Form.confirm_reject, F.text.casefold() != \"cancel\")\n\nasync def process_reject(message: Message, state: FSMContext) -> None:\n\n required_state_index = next(\n\n (\n\n i\n\n for i, obj in enumerate(STATES_LIST)\n\n if obj.state_corresponding_button == message.text\n\n ),\n\n None,\n\n )\n\n if required_state_index is None:\n\n await message.answer(\n\n \"I don't understand you. Please, choose one of the options.\",\n\n )\n\n else:\n\n required_state = STATES_LIST[required_state_index]\n\n await state.update_data(reject=True)\n\n await state.set_state(required_state.state_name)\n\n await message.answer(\n\n required_state.state_question,\n\n reply_markup=ReplyKeyboardMarkup(\n\n keyboard=required_state.keyboard_buttons,\n\n resize_keyboard=True,\n\n ),\n\n ) In this handler firstly we validate if user selected one of available buttons, for this we are trying to find state by state_corresponding_button value in STATES_LIST. After this we need to receive required_state information, make transition to this step and send proper message. But logically — after user will answer to this question we should send him to confirmation step again, for this we need to add “reject” value to states data and also update our states handlers to handle this value. Updated “first_name” state handler @form_router.message(Form.about.first_name)\n\nasync def process_first_name(message: Message, state: FSMContext) -> None:\n\n await state.update_data(first_name=message.text)\n\n data = await state.get_data()\n\n reject = data.get(\"reject\", False)\n\n if reject:\n\n await update_on_reject(message, state)\n\n else:\n\n await state.set_state(Form.about.last_name)\n\n await message.answer(\n\n \"What's your last name?\",\n\n reply_markup=ReplyKeyboardMarkup(\n\n keyboard=[\n\n [\n\n KeyboardButton(text=\"Skip\"),\n\n KeyboardButton(text=\"Go back\")\n\n ],\n\n [KeyboardButton(text=\"Cancel\")],\n\n ],\n\n resize_keyboard=True,\n\n ),\n\n ) As you can see we added only if else statement to handler reject, in case if reject is equal to True we are calling update_on_reject method: This method will make transition to confirmation state and send confirmation message again. On our state schema this operation is illustrated in two lines, firstly we perform transition from “Confirmation” to “First name” (with red arrow) and then back to “Confirmation” (with purple arrow). In Telegram flow it will looks like this:"
    },
    {
        "link": "https://medium.com/@mohamedelayadi/introducing-async-states-the-state-management-library-845b1ebbd073",
        "document": "This post serves as first introduction to the state management toolbox: async-states. You will get an overall idea about how it works, how to use it and the API it offers.\n\nThis post is a part of the following blog post series:\n• async-states: vs react-query vs redux vs recoil\n• What is this ?\n\nWhat is this ?\n\nis a state management toolbox that works wherever you have a JavaScript runtime (it can be the browser, the server, workers…).\n\nThis library was designed to reduce the boilerplate needed to access and manipulate state in a given application: you may take full control over a state from anywhere in your app.\n\nThe key features of the library are:\n• Synchronous and asynchronous flows: Promises, async/await, generators, or even nothing\n• Very rich API that will support all your use cases (even subscriptions, websockets, timeouts, intervals…)\n\nYou can get an overall idea of the features in the library’s documentation.\n\nThere are several state managers out there, some say that a state manager is born every time you yawn, but not all state managers are created equal (All hail ).\n\nI’ve been in the puzzle of Javascript and state management for almost a decade now, and with react for 7 years, so I’ve basically seen(except for redux) all others being born and how they evolved over time. Yet, I always feel that something is missing in the puzzle.\n\nI started writing code back to 2010 and I used many languages and platforms, each one of has its own specifications, APIs and limitations. In the last years, I wrote A LOT of enterprise applications for different businesses and corporates, mainly using Java and JavaScript. This allowed me not only to have clear vision about the API to design and craft, but also how to push it to solve all the problems I once had manipulating state with UI.\n• Less code and more features\n• On-demand Cache and retry support, and even cache mutualization\n• Effects such as debounce and throttle\n• Subscribe and manipulate any state, from anywhere\n• And more importantly, all the previous aspects should work together!\n\nFollow along to see how is unique.\n\nHold your breath; this is a debounced-cancellable-cached — with cache control header — search-as-you-type that skips the pending state if the search answers in less than 300ms, and that stays in the pending state for at least 300ms to avoid UI flickering:\n\nTry it yourself in this codesandbox!\n\nLet’s speak first about the properties used in the previous example:\n• : The unique identifier of the state, you can connect to it from anywhere.\n• : This is the function that returns our state value (or throws it), and can be of any form and perform unbelievable tasks.\n• : If the request is fast enough, the status will be completely skipped.\n• : If your UI enters the pending state, keep that state for at least this duration, to avoid the UI flashing showing some indicator and immediately unmounting it if the request answers right after.\n• and : The effect to apply on , can be or for now.\n• : The cache config to apply. If no function is provided to tune the cache time per state, and if the data is an object like the object, the cache control header is attempted and would be taken automatically.\n\nIf you are into frontend development, you should know how delicate will be to implement all of these features to work together, and work consistently. But for the library, it doesn’t even depend on react or the render cycle.\n\nThis is the most basic usage of the library, and its power has nothing to do with this small example, take a look at the whole signature of if you are curious!\n\nYou can also use the core library with react directly: here is the previous example using rather than :\n\nTo use the library, you should get familiar with these concepts:\n• : The state used and provided by the library contains 4 properties: , , and . You can learn more about them in the docs.\n• : The function responsible for getting the state value is called a : it produces the state value. It might be a synchronous function, a function returning a promise, async/await syntax, generators or even a nullish value to manipulate the state on the fly. Read more in the docs.\n• : The source object is obtained from the library from several places, and it is a wrapper around the internal state instance of the library that allows full control: reading state, running producer, manipulating config, attaching events, cache replacement or even imperatively altering the state value. The most common way to create them is via function. It can be called everywhere, and if the requested state (by key) already exists, it will be used.\n\nAs of writing this post, the library’s object has the following shape:\n\nLike mentioned before, this is a wrapper around an internal state instance with much more properties, almost all of them are opt-in and not allocated by default unless you use the feature, from payload to subscription to anything else.\n\nThe library understands this source object and can decode it to retrieve the original state instance if needed, it was made to prevent developers from manipulating the state instance directly, and only a subset is provided that basically allows anything.\n\nFor the brevity of the post, I recommend checking the docs for the producer, we will here only discuss its signature and its power for now.\n\nHere is the type definition of the :\n\nWhere the are defined as:\n\nRead about them here.\n• Retrieve some context for the current run from either or\n• Access to the last succeeded state, this can be useful for any type of producers that use the previous succeeded state, like reducers and infinite lists.\n• Check if it was aborted to decide whether to continue work in a non-automatically abortable context such as promises or async/await syntax. The library has a “one” level generator-runner that automatically stops yielding once aborted.\n• and get the abort function of any other state that it has access to with the ability to perform cascading cancellations\n• Run and get a promise via\n• Run using callbacks when status change via\n• Select the current state of any other state by its or object\n• state updates after resolve; this is an optimization for subscription producers, like or intervals for example: Unless there is a new or was called explicitly, you can change the state from a producer by using the function without loosing that connexion.\n• its own run; if the producer didn’t step into the state when this function is called, it will be entirely bailed out.\n\nIf you’ve made it until here, congratulations! You should be aware of many of the library’s features.\n\nThe library can be used for many of your daily use cases;\n\nThe most common use case is data fetching; you will find yourself writing a lot code like this:\n\nThe library can manage synchronous states as well either if the producer is omitted or if it doesn’t return a Promise.\n\nIf the producer isn’t provided, the function will delegate the work the the function: It will update the state by the given value, if it was given a function, it will receive the current state. Consider the following example\n\ncan receive just a ‘s (string) key as parameter and do the rest for you! Test the previous example here.\n\nBy now, I bet you have a great understanding of how the library may solve all of your daily problems and give you a great boost of productivity and confidence.\n\nIn the next section we will see how the library works very well with react and how much power it gives in practice."
    },
    {
        "link": "https://github.com/aiogram/aiogram",
        "document": "aiogram is a modern and fully asynchronous framework for Telegram Bot API written in Python 3.8+ using asyncio and aiohttp.\n\nMake your bots faster and more powerful!\n• Has type hints (PEP 484) and can be used with mypy\n• Supports Telegram Bot API 8.3 and gets fast updates to the latest versions of the Bot API\n• Telegram Bot API integration code was autogenerated and can be easily re-generated when API gets updated\n\nIt is strongly advised that you have prior experience working with asyncio before beginning to use aiogram. If you have any questions, you can visit our community chats on Telegram:"
    },
    {
        "link": "https://linkedin.com/pulse/exploring-finite-state-machine-aiogram-3-powerful-tool-telegram-dbsae",
        "document": "\n• States: These represent the distinct conditions or modes that the system can be in at any given time. Each state encapsulates a specific set of behaviors or actions that the system can perform while in that state.\n• Transitions: These define the conditions or events that trigger a change in state. When a transition occurs, the system moves from one state to another, potentially altering its behavior or internal configuration.\n• Inputs/Events: These are the stimuli or signals that drive the transitions between states. Inputs can come from various sources, such as user interactions, sensor readings, or external events.\n\nIn this handler, we've successfully stored the user's input for the first question and will now progress to the next question. Additionally, we'll incorporate an \"Go back\" button later, enabling users to make transition to the previous question. Following a consistent sequence, each subsequent handler will entail the same actions: saving the user's response, transitioning to the subsequent step, and posing the subsequent question. Upon reaching the final state, Form.confirm, users will be presented with all collected information for review.\n\nIncorporating various options to enhance user flexibility during Finite State Machine (FSM) integration in Aiogram is crucial for providing a smoother user experience. Among these options is the ability to terminate the flow, facilitated by the addition of a \"Cancel\" button. This button should be accessible from any state within the FSM, necessitating a single handler to manage its functionality. This handler will be responsible for clearing the current state and sending an appropriate message to the user, indicating the cancellation of the flow.\n\nTransition to any state in flow"
    },
    {
        "link": "https://blog.pixelfreestudio.com/best-practices-for-handling-async-state-in-frontend-apps",
        "document": "Managing asynchronous state is one of the most crucial yet challenging aspects of frontend development. Asynchronous operations, such as fetching data from APIs, processing user inputs, or handling external resources, are core to modern web applications. However, dealing with async state brings its own set of complexities, from managing loading states and error handling to ensuring the UI remains responsive and consistent.\n\nIn this article, we’ll dive deep into the best practices for handling async state in frontend apps. Whether you’re building a small single-page application or a large-scale project, mastering async state will improve your application’s performance and make it more robust and user-friendly.\n\nAsync state refers to state that depends on or is affected by asynchronous operations. These operations might include data fetching, external API calls, or deferred calculations that don’t happen instantly. Unlike synchronous operations, which happen sequentially and immediately, async operations take time to complete. This means your application must handle different states: loading, success, and failure.\n\nFor example, consider a scenario where you need to fetch user data from an API. The application must manage the following states:\n\nLoading: When the request is in progress.\n\nSuccess: When the data has been successfully fetched.\n\nError: If something goes wrong during the request.\n\nHandling async state requires a clear strategy to ensure your app behaves predictably in all these situations.\n\nOne of the most critical aspects of managing async state is how the app handles loading states. Users should be informed that a process is happening behind the scenes, so they understand that the app is not frozen or unresponsive. Proper handling of loading states improves the user experience and reduces frustration.\n\nWhen an async operation is in progress, provide a clear indication to the user that something is loading. This could be as simple as a loading spinner, a progress bar, or a skeleton screen that mimics the layout of the content being loaded.\n\nIn this example, the loading state is managed using a variable. When the request is in progress, a loading message is shown, providing feedback to the user. This prevents the UI from appearing unresponsive.\n\nWhile it’s important to show a loading state, you should avoid blocking the entire UI with loading spinners, especially when users can still interact with other parts of the app. Consider using partial loaders (e.g., spinners inside a button or on specific content sections) rather than blocking the entire screen.\n\nThis technique keeps the user engaged and allows them to continue interacting with the app, even while waiting for async data to load.\n\nSkeleton screens are a great way to improve the perceived performance of your app. Instead of showing a generic loading spinner, skeleton screens display a placeholder that resembles the final UI layout. This creates a more visually appealing experience, as users can see the structure of the content they’re waiting for.\n\nIn this example, while the user data is being fetched, a skeleton UI is displayed, which mimics the structure of the final profile. This gives users a sense of progress even though the data is still loading.\n\nErrors are inevitable when dealing with async operations, and how you handle them can make or break the user experience. When something goes wrong—whether it’s a network issue, a server error, or an unexpected result—your app should gracefully manage the failure and give users clear feedback on what happened and what they can do next.\n\nWhen an error occurs, it’s essential to show an informative error message that tells users what went wrong and, if possible, what they can do to fix it. A generic “Something went wrong” message doesn’t provide much help. Instead, consider providing actionable steps or explanations.\n\nIn this example, if the API request fails, an error message is displayed. The user is informed that something went wrong, and the application doesn’t break or crash unexpectedly.\n\nImplementing a retry mechanism is a great way to handle temporary failures, such as network issues or timeouts. Rather than forcing the user to manually retry, you can automatically attempt to fetch the data again a few times before showing an error.\n\nHere, the application retries the API request up to three times before displaying an error message. Users can also manually retry the request by clicking the “Retry” button. This creates a more resilient experience and handles intermittent network issues more gracefully.\n\nAs your app grows, manually handling async state within individual components can become cumbersome. State management libraries like Redux, Recoil, or MobX offer structured approaches to managing async state across your application.\n\nUsing Redux with Thunks for Async Operations\n\nIn Redux, handling async operations is typically done with middleware like Redux Thunk. This allows you to dispatch asynchronous actions, keeping your async state management clean and centralized.\n\nHere’s an example of handling async state with Redux Thunk:\n\nIn this example, Redux handles the async state through actions and reducers. By centralizing the logic for fetching data, your app becomes more maintainable, especially as the number of async operations grows.\n\nIf you’re using Recoil (a state management library for React), managing async state is even more straightforward thanks to Recoil’s support for asynchronous atoms and selectors.\n\nRecoil’s can handle async requests directly, which simplifies the way you manage async state in React. The component that consumes this selector can handle loading and error states accordingly.\n\nFetching data repeatedly from the server can slow down your app and degrade the user experience. Implementing caching strategies can reduce the number of requests and improve performance. You can cache the fetched data either on the client-side or server-side.\n\nSWR and React Query are libraries that help manage data fetching, caching, and synchronization in React applications. Both libraries provide built-in caching mechanisms, reducing the need to manually handle cache logic.\n\nHere’s an example using SWR:\n\nSWR automatically caches the result of the fetch operation and will reuse the data unless it becomes stale or the request is invalidated. This reduces unnecessary API requests and improves performance, especially in data-heavy applications.\n\nReact’s Suspense is a feature designed to help manage async state and loading states more declaratively. While currently available for code splitting, Suspense for data fetching is expected to be a game-changer in managing async state more elegantly.\n\nHere’s an early example of how Suspense might be used:\n\nIn this future scenario, Suspense will handle async data fetching in a way that simplifies state management, removing the need to manually track loading and error states.\n\nAs your frontend application grows in complexity, managing asynchronous state becomes more challenging. While the basic best practices covered earlier can help with simple apps, advanced techniques and patterns are needed to maintain scalability, performance, and maintainability in larger projects. In this section, we’ll explore more advanced strategies to handle async state efficiently, reduce bugs, and ensure that your app can scale without introducing unnecessary complexity.\n\nWhen dealing with user input that triggers asynchronous requests (e.g., search queries, form submissions, or scroll events), sending a request with every keystroke or action can overwhelm the server and degrade performance. Debouncing and throttling are techniques that help reduce the frequency of requests by controlling how often they are sent.\n\nDebouncing: Delays the execution of a function until a specified time has passed since the last action. This is useful for search bars or input fields where you want to wait for the user to finish typing before making an API request.\n\nThrottling: Limits the number of times a function can be called over a specified time interval, ensuring the function executes at regular intervals, no matter how frequently it’s triggered. This is useful for handling events like scrolling or resizing.\n\nIn this example, the function only triggers after the user stops typing for 500 milliseconds, reducing the number of API requests.\n\nThrottling can be implemented using plain JavaScript for cases like scrolling events:\n\nThrottling ensures that even if the user scrolls rapidly, the handler is only executed at regular intervals.\n\nAsynchronous state management becomes even more powerful when you combine it with React’s Concurrent Mode and Suspense (when fully available for data fetching). Concurrent Mode allows React to work on multiple tasks simultaneously without blocking the user interface, resulting in more fluid and responsive apps.\n\nSuspense for Data Fetching is a feature that will allow developers to declaratively manage async state. This will allow you to automatically show a fallback (e.g., a loading spinner) while waiting for data to resolve, simplifying the logic for handling async states.\n\nWhile it’s not fully available yet for data fetching, here’s an example of how Suspense might work in the future with concurrent rendering:\n\nIn this example, React would suspend rendering until the component (which may include async data fetching) is ready. When Suspense for data fetching becomes widely available, it will further streamline async state management by allowing you to focus on declarative code rather than managing loading and error states manually.\n\nWhen managing asynchronous requests, especially in scenarios where the user triggers multiple requests in a short period, it’s essential to cancel pending requests to avoid race conditions. This prevents situations where old requests resolve after newer ones, leading to outdated data being displayed in the UI.\n\nMost modern APIs, including the Fetch API, support aborting requests using AbortController.\n\nHere’s an example of using AbortController to cancel an ongoing fetch request if a new request is triggered before the previous one completes:\n\nIn this example, if the prop changes before the fetch request completes, the previous request will be aborted, preventing any race conditions or outdated data from being displayed.\n\nWhen building apps that rely heavily on asynchronous data fetching, Server-Side Rendering (SSR) can significantly improve performance and SEO by rendering pages on the server and delivering fully rendered HTML to the client. This eliminates the need for the user to wait for JavaScript to load before seeing meaningful content.\n\nFrameworks like Next.js make it easy to handle async state with SSR by providing hooks like and , which allow you to fetch data on the server before sending the rendered page to the client.\n\nExample of SSR in Next.js\n\nIn this example, the user data is fetched on the server, ensuring that the page is fully rendered when delivered to the client, which improves load times and ensures that search engines can index the content.\n\nHandling async state effectively is critical to delivering a seamless user experience in modern frontend applications. By implementing best practices—such as clear loading states, graceful error handling, caching strategies, and using the right state management tools—you can build apps that are responsive, resilient, and easy to maintain.\n\nAt PixelFree Studio, we specialize in creating high-performance, user-friendly web applications. Whether you’re looking to optimize async state handling in an existing project or need help building a new app from the ground up, our team of experts can guide you every step of the way. Contact us today to learn more about how we can help you enhance your frontend development process!\n• The Impact of Network Latency on Web Performance\n• How to Use Asynchronous Loading for Faster Websites"
    },
    {
        "link": "https://aiosqlite.omnilib.dev",
        "document": "It replicates the standard module, but with async versions of all the standard connection and cursor methods, plus context managers for automatically closing connections and cursors:\n\nIt can also be used in the traditional, procedural manner:\n\naiosqlite also replicates most of the advanced features of :\n\naiosqlite allows interaction with SQLite databases on the main AsyncIO event loop without blocking execution of other coroutines while waiting for queries or data fetches. It does this by using a single, shared thread per connection. This thread executes all actions within a shared request queue to prevent overlapping actions. Connection objects are proxies to the real connections, contain the shared execution thread, and provide context managers to handle automatically closing connections. Cursors are similarly proxies to the real cursors, and provide async iterators to query results.\n\naiosqlite is copyright Amethyst Reese, and licensed under the MIT license. I am providing code in this repository to you under an open source license. This is my personal repository; the license you receive to my code is from me and not from my employer. See the LICENSE file for details."
    },
    {
        "link": "https://github.com/omnilib/aiosqlite",
        "document": "It replicates the standard module, but with async versions of all the standard connection and cursor methods, plus context managers for automatically closing connections and cursors:\n\nIt can also be used in the traditional, procedural manner:\n\naiosqlite also replicates most of the advanced features of :\n\naiosqlite is compatible with Python 3.8 and newer. You can install it from PyPI:\n\naiosqlite allows interaction with SQLite databases on the main AsyncIO event loop without blocking execution of other coroutines while waiting for queries or data fetches. It does this by using a single, shared thread per connection. This thread executes all actions within a shared request queue to prevent overlapping actions.\n\nConnection objects are proxies to the real connections, contain the shared execution thread, and provide context managers to handle automatically closing connections. Cursors are similarly proxies to the real cursors, and provide async iterators to query results.\n\naiosqlite is copyright Amethyst Reese, and licensed under the MIT license. I am providing code in this repository to you under an open source license. This is my personal repository; the license you receive to my code is from me and not from my employer. See the LICENSE file for details."
    },
    {
        "link": "https://medium.com/@zimyanin88/aiosqlite-async-sqlite-upgrade-with-decorators-15a6d703bbd6",
        "document": "aiosqlite is a high-performance asynchronous SQLite driver for Python. It provides two ways to connect to a database: through the cursor and through the context manager.\n\nThe most common way to connect to a database using aiosqlite is through the cursor. To do this, you first need to create a connection object. You can do this using the method:\n\nUse code with caution. Learn more\n\nOnce you have a connection object, you can create a cursor object. You can do this using the method:\n\nUse code with caution. Learn more\n\nThe cursor object provides a number of methods that you can use to interact with the database. For example, you can use the method to execute a SQL statement:\n\nUse code with caution. Learn more\n\nYou can also use the method to fetch all of the rows from a table:\n\nUse code with caution. Learn more\n\nOnce you are finished interacting with the database, you need to close the cursor object. You can do this using the method:\n\nUse code with caution. Learn more\n\nAnother way to connect to a database using aiosqlite is through the context manager. This is a more concise way to connect to the database, and it ensures that the connection is closed properly even if an exception is raised.\n\nTo connect to a database using the context manager, you can use the following code:\n\nUse code with caution. Learn more\n\nAs you can see, the code is much more concise when you use the context manager. Additionally, you don’t need to worry about closing the connection manually, because the context manager will do it for you.\n\nWhich method should you use?\n\nThe method that you use to connect to a database using aiosqlite depends on your specific needs. If you need to interact with the database multiple times, then you should use the cursor method. However, if you only need to interact with the database once, then you should use the context manager method."
    },
    {
        "link": "http://docs.sqlalchemy.org/en/latest/orm/extensions/asyncio.html",
        "document": "Support for Python asyncio. Support for Core and ORM usage is included, using asyncio-compatible dialects.\n\nThe asyncio extension requires Python 3 only. It also depends upon the greenlet library. This dependency is installed by default on common machine platforms including: For the above platforms, is known to supply pre-built wheel files. For other platforms, greenlet does not install by default; the current file listing for greenlet can be seen at Greenlet - Download Files. Note that there are many architectures omitted, including Apple M1. To install SQLAlchemy while ensuring the dependency is present regardless of what platform is in use, the setuptools extra may be installed as follows, which will include also instruct to install : Note that installation of on platforms that do not have a pre-built wheel file means that will be built from source, which requires that Python’s development libraries also be present.\n\nFor Core use, the function creates an instance of which then offers an async version of the traditional API. The delivers an via its and methods which both deliver asynchronous context managers. The can then invoke statements using either the method to deliver a buffered , or the method to deliver a streaming server-side : ... t1.insert(), [{\"name\": \"some name 1\"}, {\"name\": \"some name 2\"}] ... # select a Result, which will be delivered with buffered ... # for AsyncEngine created in function scope, close and Above, the method may be used to invoke special DDL functions such as that don’t include an awaitable hook. It’s advisable to invoke the method using when using the object in a scope that will go out of context and be garbage collected, as illustrated in the function in the above example. This ensures that any connections held open by the connection pool will be properly disposed within an awaitable context. Unlike when using blocking IO, SQLAlchemy cannot properly dispose of these connections within methods like or weakref finalizers as there is no opportunity to invoke . Failing to explicitly dispose of the engine when it falls out of scope may result in warnings emitted to standard out resembling the form within garbage collection. The also features a “streaming” API via the method that returns an object. This result object uses a server-side cursor and provides an async/await API, such as an async iterator:\n\nUsing events with the asyncio extension¶ The SQLAlchemy event system is not directly exposed by the asyncio extension, meaning there is not yet an “async” version of a SQLAlchemy event handler. However, as the asyncio extension surrounds the usual synchronous SQLAlchemy API, regular “synchronous” style event handlers are freely available as they would be if asyncio were not used. As detailed below, there are two current strategies to register events given asyncio-facing APIs:\n• None Events can be registered at the instance level (e.g. a specific instance) by associating the event with the attribute that refers to the proxied object. For example to register the event against an instance, use its attribute as target. Targets include:\n• None To register an event at the class level, targeting all instances of the same type (e.g. all instances), use the corresponding sync-style class. For example to register the event against the class, use the class as the target.\n• None To register at the level, combine an explicit with an using , and associate events with the . When working within an event handler that is within an asyncio context, objects like the continue to work in their usual “synchronous” way without requiring or usage; when messages are ultimately received by the asyncio database adapter, the calling style is transparently adapted back into the asyncio calling style. For events that are passed a DBAPI level connection, such as , the object is a pep-249 compliant “connection” object which will adapt sync-style calls into the asyncio driver. Some examples of sync style event handlers associated with async-facing API constructs are illustrated below:\n• In this example, we access the attribute of as the target for and : New DBAPI connection: <AdaptedConnection <asyncpg.connection.Connection object at 0x7f33f9b16960>> execute from event before execute!\n• In this example, we access as the target for : before commit! execute from event after commit!\n• For this use case, we make a as the event target, then assign it to the using the parameter: SQLAlchemy events by their nature take place within the interior of a particular SQLAlchemy process; that is, an event always occurs after some particular SQLAlchemy API has been invoked by end-user code, and before some other internal aspect of that API occurs. Contrast this to the architecture of the asyncio extension, which takes place on the exterior of SQLAlchemy’s usual flow from end-user API to DBAPI function. The flow of messaging may be visualized as follows: Where above, an API call always starts as asyncio, flows through the synchronous API, and ends as asyncio, before results are propagated through this same chain in the opposite direction. In between, the message is adapted first into sync-style API use, and then back out to async style. Event hooks then by their nature occur in the middle of the “sync-style API use”. From this it follows that the API presented within event hooks occurs inside the process by which asyncio API requests have been adapted to sync, and outgoing messages to the database API will be converted to asyncio transparently. Using awaitable-only driver methods in connection pool and other events¶ As discussed in the above section, event handlers such as those oriented around the event handlers receive a sync-style “DBAPI” connection, which is a wrapper object supplied by SQLAlchemy asyncio dialects to adapt the underlying asyncio “driver” connection into one that can be used by SQLAlchemy’s internals. A special use case arises when the user-defined implementation for such an event handler needs to make use of the ultimate “driver” connection directly, using awaitable only methods on that driver connection. One such example is the method supplied by the asyncpg driver. To accommodate this use case, SQLAlchemy’s class provides a method that allows an awaitable function to be invoked within the “synchronous” context of an event handler or other SQLAlchemy internal. This method is directly analogous to the method that allows a sync-style method to run under async. should be passed a function that will accept the innermost “driver” connection as a single argument, and return an awaitable that will be invoked by the method. The given function itself does not need to be declared as ; it’s perfectly fine for it to be a Python , as the return awaitable value will be invoked after being returned: Above, the object passed to the event handler is an instance of , which provides a DBAPI-like interface to an underlying async-only driver-level connection object. The method then provides access to an awaitable environment where the underlying driver level connection may be acted upon."
    },
    {
        "link": "https://pypi.org/project/aiosqlite",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    }
]