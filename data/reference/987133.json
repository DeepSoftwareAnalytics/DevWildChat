[
    {
        "link": "https://stackoverflow.com/questions/55014235/next-js-express-dynamic-routing-causes-page-reload",
        "document": "I have a blog application created with next js using an express custom browser. When i click on a Link to route to '/blog/article-1' it refreshes the page on arriving at that page. How do i avoid this?\n\nI have already checked the next.js docs and it has this implementation which uses the node http module. I implemented this code on express by copying some parts from the documentation example. However it still seems to cause a page reload when i go to the article page using a ."
    },
    {
        "link": "https://github.com/vercel/next.js/discussions/14379",
        "document": "To see all available qualifiers, see our documentation .\n\nSaved searches Use saved searches to filter your results more quickly\n\nWe read every piece of feedback, and take your input very seriously.\n\nYou signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    },
    {
        "link": "https://stackoverflow.com/questions/61130038/next-js-router-push-reloads-page-automatically",
        "document": "Is there a way to execute a Router.push() without reloading the page using Next.js?\n\nI am using a [...all].js main file for a page that based on the url renders different components, but i want to be able to move between them without triggering a full page reload - it is a multi-step form.\n\nIn other words, I want to be able to move between the steps of the form by also updating the URL from 'form/1' to 'form/2'"
    },
    {
        "link": "https://github.com/vercel/next.js/issues/49881",
        "document": "\n• I verified that the issue exists in the latest Next.js canary release\n\nWhich area(s) of Next.js are affected? (leave empty if unsure)\n\nLink to the code that reproduces this issue\n• navigate to localhost:3000 and open the console\n• edit anything (for example) the console log message in or and save the file\n• Go back to the webpage and you can notice the console.log statements caused by the rerendering of the components\n• As far as I can tell this only happens when there is a fetch inside a client component that has an async server component as a child. It also happens if you fetch the data using\n\nWhenever you fetch data in a Client Component that has an async Server Component as a child, hot reloading the files will cause infinite rerenders\n\nTo not have infinite rerenders\n\nWhich browser are you using? (if relevant)\n\nHow are you deploying your application? (if relevant)"
    },
    {
        "link": "https://reddit.com/r/nextjs/comments/12owxfa/dynamic_route_doesnt_work_with_browser_refresh",
        "document": "New to Nextjs, I'm trying to just use the dynamic route id to get the correct index out of an array. My code works when I click the link that takes me to this page, but if I refresh or use the browser back button to get back to it, it throws this error. As if its taking too long for the id to come back."
    },
    {
        "link": "https://docs.nestjs.com/techniques/performance",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/Nestjs_framework/comments/1droehw/express_vs_fastify",
        "document": "Based on recent researches about HTTP frameworks such as Express, Fastify, Koa, etc.. I see Fastify and Koa are way faster and better in performance than Express, but why do people keep using Express over Fastify?\n\nfrom my point of view is it due to Express offers more stability, and reliability in long term speaking?\n\nNestJS oficial page they even suggest you to use Fastify if you want to improve your app's performance, but it comes with Express by default. Many things doesn't seem to make sense to me tbh. In the picture attached below you can spot Fastify is 4x times faster, at request processing per second."
    },
    {
        "link": "https://medium.com/@Fcmam5/avoiding-nestjs-performance-bottlenecks-78fa2bc66372",
        "document": "I have been using NestJS for quite some time now. And as every JavaScript developer, I like to complain about it but I still love it, and I still have it as one of my go-to whenever I want to create any Node application.\n\nNestJS helps you enjoy a good developer experience, especially if you are a proponent of OOP, and/or you are working with people who are used to other frameworks like Angular, or coming from a Java/Spring background.\n\nNestJS implements its dependency injection framework, which allows an easy abstraction of dependencies making code easier to maintain, test, and swap third-party libraries.\n\nWith its powerful CLI, NestJS bootstraps applications in record time, it also comes with pre-configured modules, or installable plugins making it pleasant to work with and a powerful beginners-friendly tool.\n\nHowever, “With great power comes great responsibility” and NestJS is not an exception to Uncle Ben’s quote.\n\nNest’s “fancy” configuration is sometimes more fun to develop, but it sometimes causes performance bottlenecks. Especially when we start customizing things out of the framework’s way of doing them, then things can get ugly easily.\n\nHere are some of the things I learned over the last few years:\n\nThe Node.js community is active and continuously working on improving the ecosystem, and now thanks to a performance-focused team our beloved JavaScript runtime is getting faster and more performant.\n\nOne of the performance wins I could achieve was by simply bumping my runtime version from 14 to 16 and then to 18 while making little to no changes to my NestJS microservices code.\n\nSimilarly, the NestJS became more stable. With few breaking changes from v8.x to 10.x, I feel more comfortable keeping up with new major releases to benefit from the new performance improvements, CVE patches, and bug fixes.\n\nNestJS comes with a default logger which is used by default .\n\nand is not advised to be used in logging as it may behave synchronously and block the event loop, as the Node.js documentation states:\n\nGladly, the logger can be easily customized and replaced by dedicated logging libraries such as nestjs-pino and nest-winston which also offer more flexibility and better performance. NestJS documentation covers that well.\n\nHowever, even when using custom loggers there are some things to consider.\n\nEven if you use a custom logging library, you’d still have the first few logs printed in Nest’s standard standard form. As NestJS will start streaming application start logs before the logger is attached, that not only may lose crucial framework setup logs from being hidden from logging dashboards but also impact the startup time with few MS.\n\nFor example, I usually go for Pino (with nestjs-pino) as my logging library, my have:\n\nThis produces a mixed log format as the following:\n\nThe fix would be just buffering logs by setting to :\n\nThis makes sure all logs will be buffered until the custom logger is attached and then logged in its format ( in this case), so I would have something like:\n\nNote that for standalone applications you may need to flush log buffers manually.\n\nWe had a use case where we wanted to inject a correlation ID into our logs to keep track of what was happening in our application for a particular request.\n\nThe naïve approach I was about to use, was to implement a request-scoped instance of the logger, something like:\n\nThen I learned how bad that call was, I overlooked the fact that this approach means that I will be instantiating a new instance for each request, that would impact my application performance (see: injection-scopes#performance).\n\nThe learnings I got from that were:\n• To use a well-maintained library to do that for me.\n• To be more careful with Injection scopes.\n• Consider using async local storage for some use cases (recently added, thanks NestJS community!).\n\nFor example, nestjs-pino uses AsyncLocalStorage (previously relied on cls-hooked package).\n\nMade by Node.js maintainers who worked on performance, Fastify has proven its performance and it’s making its way to compete with Express to be the most popular Node.js framework.\n\nNestJS comes by default with Express platform, but it can be easily switched to Fastify, and the documentation did a great job explaining it on the “Performance (Fastify)” page.\n\nThe switch from Express to Fastify can be done easily if your codebase is not relying on Express-specific code (as it should be if done à la NestJS), you may only change req/res types from Fastify’s Request and FastifyReply interfaces and probably have to replace the usage of some packages like helmet to use helmet/fastify.\n\nOther things to consider\n\nRule #0: MEASURE!\n\nBefore blaming the framework, we should make sure that our code is performant, that our usage of third-party components is efficient, and that our database queries are efficient.\n\nThen we may start looking into other framework-related micro-optimizations:\n• Global pipes, middlewares, guards, and filters might not be always a good idea.\n\nThey sometimes run unnecessary code for endpoints that don’t need their transformations.\n• Use lazy loading if it’s relevant to your use case.\n\nLazy loading defers module registration by loading them asynchronously to decrease application startup time (which might make sense in a serverless environment).\n• If you are using the config module, and accessing environment variables using might be slow, cashing can be a solution, see: Cache environment variables.\n\nIt might be unfair to compare NestJS to Express, Hapi, Koa, or Fastify. We will find out that it’s either slow, has a bigger memory footprint, or uses more CPU. That makes sense.\n\nNestJS takes care of a lot of things by default to offer a good and “flexible” developer experience with its built-in libraries and configurations making micro-sacrifices of performance, which can be accepted.\n\nPremature optimization is evil, and if one really can spot performance decrease; Analysis must be done first, by applying the 20-80% rule, we may figure out that most performance hits are not directly related to the framework, but our code, our logic and the way we interact with third-parties.\n\nWe should first find the bottlenecks that are decreasing performance the most, fix them, monitor and then consider if it makes sense to push for more micro-optimizations."
    },
    {
        "link": "https://reddit.com/r/Nestjs_framework/comments/s17w78/is_nestjs_good_for_building_backend_from_scratch",
        "document": "I have been eyeing on Nest.js since 1+ year and wanted to know whether it is a good choice to build a backend from scratch in 2022 or say fastify/express and the ecosystem like passport.js, ORM etc. and deciding the folder structure and doing all by yourself is the way to go?\n\nI am interested in hearing from devs who have used Nest.js in production for high traffic/complex backend in microservice or monolith style (whatever it may be) and how was your experience and does it scale and handle the traffic well, are there any issues/limitations with Nest.js or any gotchas and would you recommend it over plain express/fastify app?"
    },
    {
        "link": "https://betterstack.com/community/guides/scaling-nodejs/fastify-express",
        "document": "For years, Express has been the go-to framework for Node.js, valued for its simplicity, flexibility, and vast ecosystem. It remains widely used, but its development slowed down long ago as applications grew in complexity, and its architecture has remained largely unchanged.\n\nFastify offers a different approach, focusing on efficiency, built-in validation, and structured plugins while keeping a familiar developer experience. If you’re comfortable with Express, Fastify might feel like a natural extension, providing optimizations that reduce overhead and improve performance.\n\nThe question isn’t about replacing Express but whether Fastify better suits your needs.\n\nIf you're facing performance bottlenecks or scaling challenges or want more structured validation, it’s worth exploring. Let’s break down the differences to help you decide.\n\nFastify is a web framework for Node.js that focuses on efficiency and low overhead. Like Express, it provides routing, middleware support, and request handling, but with some differences in approach.\n\nIt uses an event-driven architecture and schema-based validation, which can help optimize performance, especially for API-heavy applications.\n\nYou may find Fastify’s built-in validation and plugin system useful if you work with JSON-based APIs or microservices. It supports both callback-based and async/await syntax, making it adaptable to different coding styles.\n\nPicking the right framework affects speed, maintainability, and developer experience.\n\nExpress is a longtime favorite for its simplicity, while Fastify is a faster, more efficient alternative. Here’s a quick overview of how they compare:\n\nWhile both Express and Fastify are designed for handling HTTP requests, their routing syntax and structure differ significantly.\n\nExpress follows a middleware-driven approach, where routes are attached directly to the instance. Routes must explicitly call or to send responses.\n\nYou must explicitly call or to return responses.\n\nExpress does not provide built-in support for route prefixes. Instead, you must manually structure their routers:\n\nEach route must be manually prefixed, making API versioning less efficient.\n\nFastify follows a function-based approach where routes can directly return values, eliminating the need for .\n\nNo need for —Fastify automatically serializes the return value.\n\nFastify also allows applying a global prefix without modifying each route:\n\nWith that, let's look at how their performance.\n\nI ran benchmark tests on my machine using a simple \"Hello World\" application to compare the performance of Express and Fastify under the same conditions.\n\nExpress, while highly versatile and widely used, handled around 20,309 requests per second in my tests. While still a solid choice, its performance overhead can become a bottleneck for high-traffic applications.\n\nOn the other hand, Fastify, designed for speed and efficiency, significantly outperformed Express, processing around 114,195 requests per second—over 5.6× faster in this scenario.\n\nThese results align with Fastify's own benchmark tests , which consistently show Fastify outperforming Express in similar \"Hello World\" scenarios.\n\nIf your application demands high throughput, Fastify is the better choice.\n\nLifecycle hooks in web frameworks provide a structured way to intercept and manage different stages of request processing.\n\nExpress lacks distinct lifecycle hooks but uses middleware functions to achieve lifecycle control. Middleware can process requests globally or for specific routes.\n\nFastify, on the other hand, provides dedicated lifecycle hooks for fine-grained control over request/response handling. Hooks can be scoped globally to plugins or individual routes, ensuring modular and predictable behavior. Key hooks include:\n• : Executed when the request is received.\n• : Runs before the route handler for tasks like authentication.\n• : Executes after the response is sent (e.g., logging).\n\nBelow is an example of a hook that checks for an authentication token before processing a request:\n\nAs you can see, while Express middleware achieves the same goal, it’s not as clear in terms of what's happening compared to Fastify’s hook system.\n\nFastify's lifecycle hooks provide a more structured and intuitive way to manage request processing, making the flow easier to understand and optimize.\n\nA plugin system allows applications to be built in a modular way, where features can be encapsulated, reused, and extended without modifying the core application logic.\n\nExpress does not have a built-in plugin system. Instead, you typically use middleware functions or external modules to extend functionality.\n\nHowever, since everything is attached directly to the main app instance, there’s no built-in encapsulation, which can lead to conflicts in larger applications.\n\nHere’s how an Express-based \"plugin\" (really just a function that modifies the ) might look:\n\nIn this example, the function registers a user-related route and provides a simple user service. However, since Express lacks a built-in plugin system, all routes and services are attached directly to the instance, making it harder to isolate them in larger applications.\n\nNow, here’s how the main Express file integrates the plugin:\n\nIn contrast, Fastify’s plugin system makes building modular, reusable, and well-encapsulated components easy. Plugins can register routes, extend functionality, or inject shared services.\n\nThe API ensures everything stays neatly scoped, preventing conflicts and making scaling easy for monolithic and microservice architectures.\n\nHere’s an example of a Fastify plugin that provides a simple user service:\n\nNow, register this plugin in the main Fastify instance:\n\nError handling is crucial to any framework, ensuring that unexpected failures don’t crash the application and that meaningful responses are sent to clients.\n\nExpress relies on error-handling middleware, requiring errors to be explicitly passed using .\n\nIn Express 4 or earlier, errors in asynchronous middleware must be manually caught and forwarded to the error handler using , or they will go unhandled.\n\nIf you forget to call , the error won’t be handled properly.\n\nExpress 5 improves error handling by automatically forwarding async errors to the error handler—just like Fastify:\n\nFastify simplifies error handling with built-in mechanisms that automatically catch both synchronous and asynchronous errors. Unlike Express, Fastify provides scoped error handlers via , allowing custom error handling at both the global and plugin levels:\n• None Automatic error handling: Errors in routes or lifecycle hooks are automatically caught and passed to the error handler\n• None Scoped handlers: Use to define custom error handlers at the global or plugin level\n\nUnlike Express, Fastify’s automatic error propagation ensures that errors are always handled, reducing the chance of uncaught exceptions. Additionally, scoped error handlers allow modular error management, making debugging and scaling much easier.\n\nInput validation ensures that incoming data meets the expected format, reducing errors and security risks.\n\nExpress lacks built-in validation and requires external libraries like , , or to implement validation logic.\n\nWhile this approach is flexible, it introduces additional dependencies, increases boilerplate code, and may require manual handling of validation errors.\n\nHere’s an example of input validation in Express using :\n\nFastify takes a schema-based approach to validation, which is highly efficient and tightly integrated into the framework. By default, it uses Ajv for request validation and fast-json-stringify for response serialization.\n\nThis eliminates the need for external libraries while supporting schemas reuse across routes through the API. Fastify also supports advanced features like custom validators, shared schema definitions, and error handling.\n\nUnlike Express, Fastify's schema-based validation is built-in, reducing boilerplate and improving performance by leveraging compiled schemas for faster execution.\n\nFastify’s tight integration with JSON Schema and built-in validation engine makes it the better choice for applications that require structured, high-performance validation.\n\nExpress offers greater flexibility but at the cost of extra dependencies and manual error handling.\n\nLogging is essential in any application, helping developers monitor requests, debug issues, and maintain observability.\n\nExpress does not provide built-in logging and depends on third-party libraries like Morgan for request logging and Winston or Pino for general-purpose logging.\n\nHere’s an example of using Winston for logging in an Express application:\n\nSince Express lacks a built-in logging system, you must manually configure and manage logging libraries, increasing setup time and maintenance.\n\nFastify, on the other hand, integrates with Pino by default, enabling structured, high-performance logging with minimal setup.\n\nLogging is disabled by default but can be activated using .\n\nHere’s an example of Fastify’s built-in logging:\n\nFastify’s native Pino integration provides a structured, high-performance logging solution with minimal configuration, making it ideal for production-ready applications\n\nTypeScript provides type safety, better developer experience, and improved maintainability in large applications.\n\nExpress does not provide native TypeScript support and relies on the community-maintained package for type definitions.\n\nYou must manually apply typings for requests, responses, and middleware, which increases boilerplate code and makes type enforcement less seamless.\n\nHere’s an example of defining custom request typings in Express:\n\nConversely, Fastify has native TypeScript support built into its core. It provides better type inference, generics-based route validation, and automatic type safety across handlers, plugins, and lifecycle hooks.\n\nFor instance, Fastify allows defining a route with strict type-checking for query parameters:\n\nFastify also integrates seamlessly with JSON Schema-based validation and serialization. Using tools like TypeBox , you can define schemas and enforce types simultaneously:\n\nLifecycle hooks, such as and , are fully typed and context-aware, giving precise control over request handling.\n\nFor example, validating an header is straightforward:\n\nFastify’s first-class TypeScript support, generics-based request validation, and built-in schema integrations make it the better choice for type safety and maintainability.\n\nHTTP/2 improves performance, concurrency, and security over HTTP/1.1 by enabling features like multiplexing, header compression, and server push.\n\nExpress does not natively support HTTP/2, so external libraries like are required to enable it.\n\nHere’s how to set up HTTP/2 in Express using :\n\nSince Express was designed around HTTP/1, enabling HTTP/2 requires an external dependency and additional manual setup.\n\nOn the flip side, Fastify provides built-in HTTP/2 support, making setting up secure and high-performance connections easy without extra dependencies.\n\nIt supports both secure (HTTPS) and plaintext (insecure) configurations and can automatically fall back to HTTP/1 using ALPN negotiation when needed.\n\nHere is an example of a Fastify HTTP/2 Server:\n\nUnlike Express, Fastify’s HTTP/2 support is built into the core, making it a more streamlined and efficient choice for modern web applications.\n\nShould you switch to Fastify?\n\nIf you’re currently using Express, you might be wondering if it’s time to switch to Fastify. The answer depends on what you need from your framework and how you’re using Express.\n\nFastify is built for speed and efficiency, offering schema validation, built-in TypeScript support, and automatic error handling. If you're developing APIs, microservices, or performance-critical applications, Fastify can give your app a serious performance boost right out of the box.\n\nThat said, Express isn’t going anywhere. It remains one of the most popular and reliable Node.js frameworks. If you’ve been frustrated by Express’s slow progress in recent years, the good news is that things are finally changing. Express 5 is here, and the framework now has a clear roadmap for the future , including:\n• None Official TypeScript support – Automatically generated and tested types are on the way, making Express a better fit for modern TypeScript development.\n• None More modular design – Express is moving toward an API-first approach by removing templating and rendering from its core.\n• None Middleware improvements – Unused middleware will be phased out, and Express will integrate more native Node.js capabilities for better performance.\n• None Alignment with Node.js LTS schedules – Express updates will now follow Node.js’s long-term support (LTS) cycle, making upgrades more predictable.\n\nIf you love Express but have been worried about its future, these updates should reassure you that it’s evolving to meet modern development needs.\n\nIf you decide to transition to Fastify, you don’t need to rewrite your entire application overnight. Instead, you can migrate gradually while keeping your existing Express routes and middleware functional.\n\nFastify provides , a compatibility layer that allows Express middleware and applications to run inside Fastify. This lets you transition smoothly without breaking existing functionality.\n\nStart by installing the compatibility plugin with:\n\nOnce installed, you can register your existing Express app inside Fastify without significant changes. For example, if you have an existing Express router, you can wrap it in Fastify like this:\n\nThis allows all Express routes to remain functional while Fastify runs the core application. This means you can start using Fastify’s optimizations without losing existing functionality.\n\nIf your Express app uses middleware, you can register it inside Fastify using , but a better long-term approach is migrating middleware to Fastify’s built-in plugins. For example, instead of using and from Express, you can replace them with and , which integrate natively with Fastify’s lifecycle.\n\nThis removes unnecessary dependencies and improves performance. Over time, you can begin refactoring your Express routes to use Fastify’s optimized syntax. Instead of defining routes with and , Fastify allows direct return values, making the code cleaner and more efficient.\n\nIt can be refactored in Fastify like this:\n\nFastify automatically serializes JSON responses and eliminates the need for , making the migration easier and improving performance. To make the transition smoother, you can encapsulate Express logic inside a subsystem within Fastify. This allows specific parts of your application to run Express middleware while you refactor others into Fastify.\n\nThis approach ensures that different parts of your application can be migrated independently without breaking compatibility. Once all routes and middleware have been successfully transitioned, you can remove and fully embrace Fastify’s native features.\n\nFastify also simplifies route prefixing, making it more efficient than Express. In Express, route prefixes must be manually structured, such as defining and routes separately:\n\nFastify, on the other hand, allows prefixing routes at registration, making the process much cleaner:\n\nSince Fastify compiles routes at startup, its prefixing method improves performance while keeping the structure modular and maintainable.\n\nTo ensure a smooth migration, the best approach is to incrementally transition routes, replace middleware with native Fastify plugins, and move away from Express’s request-response handling in favor of Fastify’s return-based approach. Once the migration is complete, removing will finalize the transition, allowing you to take full advantage of Fastify’s performance optimizations, better request handling, and built-in scalability.\n\nThis article compared Fastify and Express to help you decide which fits your needs.\n\nFastify is great for performance, modern features, and built-in TypeScript support. Express remains widely used and flexible, now evolving with Express 5 after a long period without major updates.\n\nIf you need speed and built-in features, choose Fastify. If you prefer stability and a vast ecosystem, Express is still a solid choice."
    }
]