[
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/nio/channels/AsynchronousServerSocketChannel.html",
        "document": "An asynchronous server-socket channel is created by invoking the method of this class. A newly-created asynchronous server-socket channel is open but not yet bound. It can be bound to a local address and configured to listen for connections by invoking the method. Once bound, the method is used to initiate the accepting of connections to the channel's socket. An attempt to invoke the method on an unbound channel will cause a to be thrown.\n\nChannels of this type are safe for use by multiple concurrent threads though at most one accept operation can be outstanding at any time. If a thread initiates an accept operation before a previous accept operation has completed then an will be thrown.\n\nSocket options are configured using the method. Channels of this type support the following options:\n\nAdditional (implementation specific) options may also be supported."
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/nio/channels/ServerSocketChannel.html",
        "document": "A server-socket channel is created by invoking the method of this class. It is not possible to create a channel for an arbitrary, pre-existing . A newly-created server-socket channel is open but not yet bound. An attempt to invoke the method of an unbound server-socket channel will cause a to be thrown. A server-socket channel can be bound by invoking one of the methods defined by this class.\n\nSocket options are configured using the method. Server-socket channels support the following options:\n\nAdditional (implementation specific) options may also be supported.\n\nServer-socket channels are safe for use by multiple concurrent threads."
    },
    {
        "link": "https://github.com/openjdk-mirror/jdk7u-jdk/blob/master/src/share/classes/java/nio/channels/AsynchronousServerSocketChannel.java",
        "document": ""
    },
    {
        "link": "https://avaldes.com/java-nio-channels",
        "document": "Channels are conduits through which I/O transfers and buffers are either the sources or the targets of those data transfers. NIO Channels are like highways that efficiently transport data between byte buffers and the entity on the other end of the channel. A channel represents an open connection to an entity such as a file, a network socket, or an application that is capable of performing I/O operations such as reading or writing.\n\nChannels are able to operate in blocking or non-blocking modes. A channel in non-blocking mode allows input/output operation without blocking the thread that invoked it. However, as of Java 1.4 only stream-oriented channels, such as sockets can be placed in non-blocking mode. Now, with the advent of Java 1.7 new classes have been added supports non-blocking or asynchronous communication like AsynchronousFileChannel.\n\nIn Java 1.7 the following channel classes are available:\n\n AsynchronousChannelGroup, AsynchronousFileChannel, AsynchronousServerSocketChannel, AsynchronousSocketChannel, DatagramChannel, FileChannel, Pipe, SelectableChannel, ServerSocketChannel and SocketChannel\n• Channels can be either uni-directional or bi-directional\n• Some channels can be put into non-blocking mode (asynchronous)\n• Channels either transfer data into a buffer and pull data from a buffer\n\nAs you can see from above, the Channel interface has two methods which are available to all channel classes. The isOpen() method is used to see if the channel is open and the close() method is used to close an existing open channel.\n\nFileChannels are used for reading and writing data using file I/O. FileChannels cannot be created directly. An instance of FileChannel must be obtained by either using the getChannel() method or by calling open() method from either SocketChannel, ServerSocketChannel, DatagramChannel.\n\nSocket and Datagram channels have open() methods allowing you to open the channel directly.\n\nIn this example, we use FileOutputStream and the getChannel() method to obtain a FileChannel.\n\nI hope you enjoyed this tutorial. It was certainly a lot of fun putting it together and testing it out. Please continue to share the love and like us so that we can continue bringing you quality tutorials. Happy Coding!!!\n• Java NIO Tutorial\n\nIn this tutorial series we discuss the new features of Java NIO.\n• Java NIO Buffers\n\nThis post covers NIO Buffers in more detail and provides practical examples of using buffers in real world applications.\n• Java NIO Channels\n\nThis post covers NIO Channels in more detail and provides examples on network connections and Java I/O in relation to files.\n• Java NIO Selectors\n\nIn this tutorial we learn how to use the Selector class from the java.io.channels package library to build High-Performance I/O client-server using NIO.\n• Java NIO File Channel\n\nIn this tutorial we learn how to use the FileChannel class from the java.io.channels package library and provide working examples on all of the main methods.\n• Java NIO Socket Channel\n\nIn this tutorial we learn how to use the SocketChannel and how it is used for reading/writing stream oriented data and using TCP connection based protocol.\n• Java NIO DatagramChannel Tutorial\n\nIn this tutorial we learn how to use the DatagramChannel to allow developers to build high-performant data streaming applications that send and receive datagrams using a protocol called UDP.\n• Java NIO and NIO2 Path Tutorial\n\nThis tutorial will introduce the Path interface and many of its methods. The Path interface was made available as part of the Java SE 7 release in the Java NIO 2 File API.\n\nPlease Share Us on Social Media"
    },
    {
        "link": "https://stackoverflow.com/questions/843283/asynchronous-channel-close-in-java-nio",
        "document": "You have a major problem in your example.\n\nWith Java NIO, the thread doing the accept() must only be doing the accept(). Toy examples aside you are probably using Java NIO because of anticipated high number of connections. If you even think about doing the read in the same thread as the selects, the pending unaccepted selects will time out waiting for the connection to be established. By the time this one overwrought thread gets around to accepting the connection, the OS's on either side will have given up and the accept() will fail.\n\nOnly do the absolute minimum in the selection thread. Any more and you will just being rewriting the code until you do only the minimum.\n\nOnly in toy examples should the reading be handled on the main thread.\n• Each connection once established sends 24K bytes to a single server - i.e. a small web page, a tiny .jpg.\n• Slow down each connection slightly ( the connection is being established over a dialup, or the network is having a high-error/retry rate) - so the TCP/IP ACK takes longer than ideal (out of your control OS level thing)\n• Have some of your test connections, send a single bytes every 1 milliseconds. (this simulates a client that is having its own high load condition, so is generating the data at a very slow rate.) The thread has to spend almost the same amount of effort processing a single bytes as it does 24K bytes.\n• Have some connections be cut with no warning ( connection lost issues ).\n\nAs a practical matter, the connection needs to be established within 500ms -1500ms before the attempting machine drops the connection.\n\nAs a result of all these issues, a single thread will not be able to get all the connections set up fast enough before the machine on the other end gives up the connection attempt. The reads must be in a different thread. period.\n\n[Key Point] I forgot to really be clear about this. But the threads doing the reading will have their own Selector. The Selector used to establish the connection should not be used to listen for new data.\n\nAddition (in response to Gnarly's contention that no I/O actually occurs during the java call to read the stream.\n\nEach layer has a defined buffer size. Once that buffer is full, the IO is halted. For example, TCP/IP buffers have between 8K-64K buffers per connection. Once the TCP/IP buffer fills, the receiving computer tells the sending computer to stop. If receiving computer does not process the buffered bytes fast enough the sending computer will drop the connection.\n\nIf the receiving computer is processing the buffered bytes, the sender will continue to stream the bytes, while the java io read call is being made.\n\nFurthermore, realize that the first byte to arrive triggers the \"bytes available to be read\" on the selector. There is no guarantee as to how many have arrived.\n\nThe buffer sizes defined in the java code have no relationship to the buffer size of the OS."
    },
    {
        "link": "https://baeldung.com/java-nio-selector",
        "document": "In this article, we’ll explore the introductory parts of Java NIO’s Selector component.\n\nA selector provides a mechanism for monitoring one or more NIO channels and recognizing when one or more become available for data transfer.\n\nThis way, a single thread can be used for managing multiple channels, and thus multiple network connections.\n\nWith a selector, we can use one thread instead of several to manage multiple channels. Context-switching between threads is expensive for the operating system, and additionally, each thread takes up memory.\n\nTherefore, the fewer threads we use, the better. However, it’s important to remember that modern operating systems and CPU’s keep getting better at multitasking, so the overheads of multi-threading keep diminishing over time.\n\nHere, we’ll be dealing with how we can handle multiple channels with a single thread using a selector.\n\nNote also that selectors don’t just help you read data; they can also listen for incoming network connections and write data across slow channels.\n\nTo use the selector, we do not need any special set up. All the classes we need are in the core java.nio package and we just have to import what we need.\n\nAfter that, we can register multiple channels with a selector object. When I/O activity happens on any of the channels, the selector notifies us. This is how we can read from a large number of data sources on a single thread.\n\nAny channel we register with a selector must be a sub-class of SelectableChannel. These are a special type of channels that can be put in non-blocking mode.\n\nA selector may be created by invoking the static open method of the Selector class, which will use the system’s default selector provider to create a new selector:\n\nIn order for a selector to monitor any channels, we must register these channels with the selector. We do this by invoking the register method of the selectable channel.\n\nBut before a channel is registered with a selector, it must be in non-blocking mode:\n\nThis means that we cannot use FileChannels with a selector since they cannot be switched into non-blocking mode the way we do with socket channels.\n\nThe first parameter is the Selector object we created earlier, the second parameter defines an interest set, meaning what events we are interested in listening for in the monitored channel, via the selector.\n\nThere are four different events we can listen for, each is represented by a constant in the SelectionKey class:\n• Connect – when a client attempts to connect to the server. Represented by SelectionKey.OP_CONNECT\n• Accept – when the server accepts a connection from a client. Represented by SelectionKey.OP_ACCEPT\n• Read – when the server is ready to read from the channel. Represented by SelectionKey.OP_READ\n• Write – when the server is ready to write to the channel. Represented by SelectionKey.OP_WRITE\n\nThe returned object SelectionKey represents the selectable channel’s registration with the selector. We’ll look at it further in the following section.\n\nAs we saw in the previous section, when we register a channel with a selector, we get a SelectionKey object. This object holds data representing the registration of the channel.\n\nIt contains some important properties which we must understand well to be able to use the selector on the channel. We’ll look at these properties in the following subsections.\n\nAn interest set defines the set of events that we want the selector to watch out for on this channel. It is an integer value; we can get this information in the following way.\n\nFirst, we have the interest set returned by the SelectionKey‘s interestOps method. Then we have the event constant in SelectionKey we looked at earlier.\n\nWhen we AND these two values, we get a boolean value that tells us whether the event is being watched for or not:\n\nThe ready set defines the set of events that the channel is ready for. It is an integer value as well; we can get this information in the following way.\n\nWe’ve got the ready set returned by SelectionKey‘s readyOps method. When we AND this value with the events constants as we did in the case of interest set, we get a boolean representing whether the channel is ready for a particular value or not.\n\nAnother alternative and shorter way to do this is to use SelectionKey’s convenience methods for this same purpose:\n\nAccessing the channel being watched from the SelectionKey object is very simple. We just call the channel method:\n\nJust like getting a channel, it’s very easy to obtain the Selector object from the SelectionKey object:\n\nWe can attach an object to a SelectionKey. Sometimes we may want to give a channel a custom ID or attach any kind of Java object we may want to keep track of.\n\nAttaching objects is a handy way of doing it. Here is how you attach and get objects from a SelectionKey:\n\nAlternatively, we can choose to attach an object during channel registration. We add it as a third parameter to channel’s register method, like so:\n\nSo far, we have looked at how to create a selector, register channels to it and inspect the properties of the SelectionKey object which represents a channel’s registration to a selector.\n\nThis is only half of the process, now we have to perform a continuous process of selecting the ready set which we looked at earlier. We do selection using selector’s select method, like so:\n\nThis method blocks until at least one channel is ready for an operation. The integer returned represents the number of keys whose channels are ready for an operation.\n\nNext, we usually retrieve the set of selected keys for processing:\n\nThe set we have obtained is of SelectionKey objects, each key represents a registered channel which is ready for an operation.\n\nAfter this, we usually iterate over this set and for each key, we obtain the channel and perform any of the operations that appear in our interest set on it.\n\nDuring the lifetime of a channel, it may be selected several times as its key appears in the ready set for different events. This is why we must have a continuous loop to capture and process channel events as and when they occur.\n\nTo cement the knowledge we have gained in the previous sections, we’re going to build a complete client-server example.\n\nFor ease of testing out our code, we’ll build an echo server and an echo client. In this kind of setup, the client connects to the server and starts sending messages to it. The server echoes back messages sent by each client.\n\nWhen the server encounters a specific message, such as end, it interprets it as the end of the communication and closes the connection with the client.\n\nHere is our code for EchoServer.java:\n\nThis is what is happening; we create a Selector object by calling the static open method. We then create a channel also by calling its static open method, specifically a ServerSocketChannel instance.\n\nThis is because ServerSocketChannel is selectable and good for a stream-oriented listening socket.\n\nWe then bind it to a port of our choice. Remember we said earlier that before registering a selectable channel to a selector, we must first set it to non-blocking mode. So next we do this and then register the channel to the selector.\n\nWe don’t need the SelectionKey instance of this channel at this stage, so we will not remember it.\n\nJava NIO uses a buffer-oriented model other than a stream-oriented model. So socket communication usually takes place by writing to and reading from a buffer.\n\nWe, therefore, create a new ByteBuffer which the server will be writing to and reading from. We initialize it to 256 bytes, it’s just an arbitrary value, depending on how much data we plan to transfer to and fro.\n\nFinally, we perform the selection process. We select the ready channels, retrieve their selection keys, iterate over the keys, and perform the operations for which each channel is ready.\n\nWe do this in an infinite loop since servers usually need to keep running whether there is an activity or not.\n\nThe only operation a ServerSocketChannel can handle is an ACCEPT operation. When we accept the connection from a client, we obtain a SocketChannel object on which we can do read and writes. We set it to non-blocking mode and register it for a READ operation to the selector.\n\nDuring one of the subsequent selections, this new channel will become read-ready. We retrieve it and read it contents into the buffer. True to it’s as an echo server, we must write this content back to the client.\n\nWhen we desire to write to a buffer from which we have been reading, we must call the flip() method.\n\nWe finally set the buffer to write mode by calling the flip method and simply write to it.\n\nThe start() method is defined so that the echo server can be started as a separate process during unit testing.\n\nHere is our code for EchoClient.java:\n\nThe client is simpler than the server.\n\nWe use a singleton pattern to instantiate it inside the start static method. We call the private constructor from this method.\n\nIn the private constructor, we open a connection on the same port on which the server channel was bound and still on the same host.\n\nWe then create a buffer to which we can write and from which we can read.\n\nFinally, we have a sendMessage method which reads wraps any string we pass to it into a byte buffer which is transmitted over the channel to the server.\n\nWe then read from the client channel to get the message sent by the server. We return this as the echo of our message.\n\nInside a class called EchoTest.java, we are going to create a test case that starts the server, sends messages to the server, and only passes when the same messages are received back from the server. As a final step, the test case stops the server before completion.\n\nWe can now run the test:\n\nAs we saw earlier, calling selector.select() blocks the current thread until one of the watched channels becomes operation-ready. We can override this by calling selector.wakeup() from another thread.\n\nThe result is that the blocking thread returns immediately rather than continuing to wait, whether a channel has become ready or not.\n\nWe can demonstrate this using a CountDownLatch and tracking the code execution steps:\n\nIn this example, we use Java NIO’s Pipe class to open a channel for testing purposes. We track code execution steps in a thread-safe list. By analyzing these steps, we can see how selector.wakeup() releases the thread blocked by selector.select().\n\nIn this article, we have covered the basic usage of the Java NIO Selector component."
    },
    {
        "link": "https://stackoverflow.com/questions/9544703/java-how-to-communicate-with-multiple-clients-in-a-single-thread",
        "document": "I had to connect multiple server IP:PORTs and do request-response messaging. After implementing a traditional IO with multiple threads and a watchdog killing blocked sockets gave up. I made NIO implementation and this is my test application for future reference.\n\nI can open N connections with timeout, read reply with timeout, write command with timeout everything in a simple single threaded \"game loop\". If I needed concurrency I could spawn worker threads but not mandatory if application logic does not need it.\n\nServer is a custom telnet app, clients write a command and read text lines until a terminator line prompt is found. Terminator marks the end_of_response_packet."
    },
    {
        "link": "https://waitingforcode.com/java-i-o/handling-multiple-io-one-thread-nio-selector/read",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/25022585/how-to-use-selector-with-multiple-channelsnio",
        "document": "I am feeling that I am didn't understand a lot of details of following article but I am trying to invoke example at the end of the article.\n\nmy final code looks so:\n\nAs a result of this method invokation I see follwing stacktrace:\n\nIn debug I see that I cannot to enter into this loop:"
    },
    {
        "link": "https://geeksforgeeks.org/java-nio-channels-selector-class-in-java",
        "document": "A selector is a tool that helps you keep an eye on one or more NIO channels and figure out when they're ready to transfer data. In Java NIO, the Selector is a key player that looks at multiple Java NIO Channel instances and figures out which ones are good to go for actions like reading or writing.\n\nThis allows a single thread to handle many channels, making it easy to manage multiple network connections.\n\nUsing a selector helps us do more with fewer threads, just one instead of many. Frequent thread switching can burden the operating system and use up memory.\n• None The fewer threads we use, the more efficient our system gets.\n• None It's important to note that modern operating systems and CPUs are getting better at handling multiple tasks.\n• None helps reduce the resource needs of using many threads over time.\n\nSelectors can do more than just read data, they can also keep an eye on incoming network connections and make sending data through slower channels easier.\n\nYou can create a selector by simply using the open method of the Selector class. This method makes use of the system's default selector provider to generate a fresh selector\n\nFor a selector to monitor any channels, we must register these channels with the selector.\n\nThis is done by calling the register method of the SelectableChannel. However, the channel must be in non-blocking mode before registering it with the selector:\n\nThe second parameter defines an interest set, meaning what events we are interested in listening for in the monitored channel, via the selector.\n\nThere are four different events you can listen for:\n• Connect: when a client attempts to connect to the server(SelectionKey.OP_CONNECT).\n• Accept: when the server accepts a connection from a client(SelectionKey.OP_ACCEPT).\n• Read: when the server is ready to read from the channel(SelectionKey.OP_READ).\n• Write: when the server is ready to write to the channel(SelectionKey.OP_WRITE).\n\nAs you saw in the above section, when we register a Channel with a Selector the register() method returns a SelectionKey object. This SelectionKey object contains a few interesting properties:\n\nAn interest set specifies the events that the selector should monitor on a channel. This interest set is represented as an integer value, and we can retrieve this information as below.\n\nInitially, we obtain the interest set using the interestOps method of SelectionKey.\n\nWhen we use a bitwise AND operation on these two values, it yields a boolean value that indicates whether the event is being monitored or not.\n\nThe ready set is the set of operations the channel is ready for. We can access the ready set like below.\n\nWe can also use below four methods below instead, which all return a boolean.\n\nWe can access the channel from selectionKey as below:\n\nWe can obtain the selector object from selectionKey object as below:\n\nWe can attach an object to a SelectionKey. Here is how we can attach and get objects from a SelectionKey:\n\nOnce we have registered one or more channels with a Selector, we can use one of the select() methods. These methods provide us with the channels that are \"ready\" for the events we care about (such as connect, accept, read, or write).\n• None select() blocks unless one channel is ready for the events we registered for.\n• None select(long timeout) does the same as above except it blocks for a maximum of timeout milliseconds.\n• None selectNow() does not block at all. It returns immediately with whatever channels are ready.\n\nOnce we have called the select() methods and its return value has indicated that one or more channels are ready, you can access the ready channels via the selected key set, by calling the selectedKeys() method as below:\n\nWe have some more selector methods available mentioned with proper description and usage.\n\nLet's explore a couple of practical examples to see the Selector class in action.\n\nIn this example, we are going to use Java NIO Selector to monitor a single non-blocking SocketChannel for read operations. The steps are as follows:\n• None Register the SocketChannel with the Selector, specifying that you're interested in the OP_READ\n• selector.select() to wait for at least one registered channel to be ready for reading.\n\nIn this example, we have extended the usage of the Java NIO Selector to manage multiple channels, each with different I/O operations. The steps are as follows:\n• None Create and configure multiple channels according to your application needs.\n• None Register each channel with the Selector, specifying the specific I/O operation you're interested in for each channel.\n• selector.select() to efficiently wait for at least one of the registered channels to be ready for its specified operation (e.g., read or write).\n\nTo practice the knowledge we have learned in the previous sections, let's see a complete client-server example\n• None We’ll build an echo server and an echo client.\n• None In this kind of setup, the client connects to the server and starts sending messages to it.\n• None The server echoes messages sent by each client.\n\nWhen the server encounters a specific message, such as the end, it interprets it as the end of the communication and closes the connection with the client\n• None The code is a Java NIO implementation of an echo server\n• None Accepted connections are registered for reading, and data is echoed back to clients.\n\nIn this example we will create a NIOClient, using SocketChannel.\n\nExplanation of the above program:\n• None and connects to a server at localhost on port 5454.\n• None Prepares a message (\"Hello, NIO Server!\") and sends it to the server.\n• None Reads the server's response into a buffer and converts it to a String.\n\nThe java.nio.channels.Selector class is an important component for mastering non-blocking I/O in Java. By understanding how to create a Selector, work with SelectionKey objects, and leverage the select() method, we can significantly enhance the efficiency and responsiveness of our Java applications."
    }
]