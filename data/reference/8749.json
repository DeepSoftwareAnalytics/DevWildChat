[
    {
        "link": "https://pkg.go.dev/net/http",
        "document": "Get, Head, Post, and PostForm make HTTP (or HTTPS) requests: The caller must close the response body when finished with it: For control over HTTP client headers, redirect policy, and other settings, create a Client: For control over proxies, TLS configuration, keep-alives, compression, and other settings, create a Transport: Clients and Transports are safe for concurrent use by multiple goroutines and for efficiency should only be created once and re-used. ListenAndServe starts an HTTP server with a given address and handler. The handler is usually nil, which means to use DefaultServeMux. Handle and HandleFunc add handlers to DefaultServeMux: More control over the server's behavior is available by creating a custom Server: Starting with Go 1.6, the http package has transparent support for the HTTP/2 protocol when using HTTPS. Programs that must disable HTTP/2 can do so by setting [Transport.TLSNextProto] (for clients) or [Server.TLSNextProto] (for servers) to a non-nil, empty map. Alternatively, the following GODEBUG settings are currently supported: GODEBUG=http2client=0 # disable HTTP/2 client support GODEBUG=http2server=0 # disable HTTP/2 server support GODEBUG=http2debug=1 # enable verbose HTTP/2 debug logs GODEBUG=http2debug=2 # ... even more verbose, with frame dumps Please report any issues before disabling HTTP/2 support: https://golang.org/s/http2bug The http package's Transport and Server both automatically enable HTTP/2 support for simple configurations. To enable HTTP/2 for more complex configurations, to use lower-level HTTP/2 features, or to use a newer version of Go's http2 package, import \"golang.org/x/net/http2\" directly and use its ConfigureTransport and/or ConfigureServer functions. Manually configuring HTTP/2 via the golang.org/x/net/http2 package takes precedence over the net/http package's built-in HTTP/2 support.\n\nCanonicalHeaderKey returns the canonical format of the header key s. The canonicalization converts the first letter and any letter following a hyphen to upper case; the rest are converted to lowercase. For example, the canonical key for \"accept-encoding\" is \"Accept-Encoding\". If s contains a space or invalid header field bytes, it is returned without modifications. DetectContentType implements the algorithm described at https://mimesniff.spec.whatwg.org/ to determine the Content-Type of the given data. It considers at most the first 512 bytes of data. DetectContentType always returns a valid MIME type: if it cannot determine a more specific one, it returns \"application/octet-stream\". Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text. Error deletes the Content-Length header, sets Content-Type to “text/plain; charset=utf-8”, and sets X-Content-Type-Options to “nosniff”. This configures the header properly for the error message, in case the caller had set it up expecting a successful output. Handle registers the handler for the given pattern in DefaultServeMux. The documentation for ServeMux explains how patterns are matched. HandleFunc registers the handler function for the given pattern in DefaultServeMux. The documentation for ServeMux explains how patterns are matched. package main import ( \"io\" \"log\" \"net/http\" ) func main() { h1 := func(w http.ResponseWriter, _ *http.Request) { io.WriteString(w, \"Hello from a HandleFunc #1!\n\n\") } h2 := func(w http.ResponseWriter, _ *http.Request) { io.WriteString(w, \"Hello from a HandleFunc #2!\n\n\") } http.HandleFunc(\"/\", h1) http.HandleFunc(\"/endpoint\", h2) log.Fatal(http.ListenAndServe(\":8080\", nil)) } ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives. The handler is typically nil, in which case DefaultServeMux is used. package main import ( \"io\" \"log\" \"net/http\" ) func main() { // Hello world, the web server helloHandler := func(w http.ResponseWriter, req *http.Request) { io.WriteString(w, \"Hello, world!\n\n\") } http.HandleFunc(\"/hello\", helloHandler) log.Fatal(http.ListenAndServe(\":8080\", nil)) } ListenAndServeTLS acts identically to ListenAndServe, except that it expects HTTPS connections. Additionally, files containing a certificate and matching private key for the server must be provided. If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate, any intermediates, and the CA's certificate. package main import ( \"io\" \"log\" \"net/http\" ) func main() { http.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) { io.WriteString(w, \"Hello, TLS!\n\n\") }) // One can use generate_cert.go in crypto/tls to generate cert.pem and key.pem. log.Printf(\"About to listen on 8443. Go to https://127.0.0.1:8443/\") err := http.ListenAndServeTLS(\":8443\", \"cert.pem\", \"key.pem\", nil) log.Fatal(err) } MaxBytesReader is similar to io.LimitReader but is intended for limiting the size of incoming request bodies. In contrast to io.LimitReader, MaxBytesReader's result is a ReadCloser, returns a non-nil error of type *MaxBytesError for a Read beyond the limit, and closes the underlying reader when its Close method is called. MaxBytesReader prevents clients from accidentally or maliciously sending a large request and wasting server resources. If possible, it tells the ResponseWriter to close the connection after the limit has been reached. NotFound replies to the request with an HTTP 404 not found error. ParseHTTPVersion parses an HTTP version string according to RFC 7230, section 2.6. \"HTTP/1.0\" returns (1, 0, true). Note that strings without a minor version, such as \"HTTP/2\", are not valid. ParseTime parses a time header (such as the Date: header), trying each of the three formats allowed by HTTP/1.1: TimeFormat, time.RFC850, and time.ANSIC. ProxyFromEnvironment returns the URL of the proxy to use for a given request, as indicated by the environment variables HTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions thereof). Requests use the proxy from the environment variable matching their scheme, unless excluded by NO_PROXY. The environment values may be either a complete URL or a \"host[:port]\", in which case the \"http\" scheme is assumed. An error is returned if the value is a different form. A nil URL and nil error are returned if no proxy is defined in the environment, or a proxy should not be used for the given request, as defined by NO_PROXY. As a special case, if req.URL.Host is \"localhost\" (with or without a port number), then a nil URL and nil error will be returned. ProxyURL returns a proxy function (for use in a Transport) that always returns the same URL. Redirect replies to the request with a redirect to url, which may be a path relative to the request path. The provided code should be in the 3xx range and is usually StatusMovedPermanently, StatusFound or StatusSeeOther. If the Content-Type header has not been set, Redirect sets it to \"text/html; charset=utf-8\" and writes a small HTML body. Setting the Content-Type header to any value, including nil, disables that behavior. Serve accepts incoming HTTP connections on the listener l, creating a new service goroutine for each. The service goroutines read requests and then call handler to reply to them. The handler is typically nil, in which case DefaultServeMux is used. HTTP/2 support is only enabled if the Listener returns *tls.Conn connections and they were configured with \"h2\" in the TLS Config.NextProtos. ServeContent replies to the request using the content in the provided ReadSeeker. The main benefit of ServeContent over io.Copy is that it handles Range requests properly, sets the MIME type, and handles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since, and If-Range requests. If the response's Content-Type header is not set, ServeContent first tries to deduce the type from name's file extension and, if that fails, falls back to reading the first block of the content and passing it to DetectContentType. The name is otherwise unused; in particular it can be empty and is never sent in the response. If modtime is not the zero time or Unix epoch, ServeContent includes it in a Last-Modified header in the response. If the request includes an If-Modified-Since header, ServeContent uses modtime to decide whether the content needs to be sent at all. The content's Seek method must work: ServeContent uses a seek to the end of the content to determine its size. Note that *os.File implements the io.ReadSeeker interface. If the caller has set w's ETag header formatted per RFC 7232, section 2.3, ServeContent uses it to handle requests using If-Match, If-None-Match, or If-Range. If an error occurs when serving the request (for example, when handling an invalid range request), ServeContent responds with an error message. By default, ServeContent strips the Cache-Control, Content-Encoding, ETag, and Last-Modified headers from error responses. The GODEBUG setting httpservecontentkeepheaders=1 causes ServeContent to preserve these headers. ServeFile replies to the request with the contents of the named file or directory. If the provided file or directory name is a relative path, it is interpreted relative to the current directory and may ascend to parent directories. If the provided name is constructed from user input, it should be sanitized before calling ServeFile. As a precaution, ServeFile will reject requests where r.URL.Path contains a \"..\" path element; this protects against callers who might unsafely use filepath.Join on r.URL.Path without sanitizing it and then use that filepath.Join result as the name argument. As another special case, ServeFile redirects any request where r.URL.Path ends in \"/index.html\" to the same path, without the final \"index.html\". To avoid such redirects either modify the path or use ServeContent. Outside of those two special cases, ServeFile does not use r.URL.Path for selecting the file or directory to serve; only the file or directory provided in the name argument is used. ServeFileFS replies to the request with the contents of the named file or directory from the file system fsys. The files provided by fsys must implement io.Seeker. If the provided name is constructed from user input, it should be sanitized before calling ServeFileFS. As a precaution, ServeFileFS will reject requests where r.URL.Path contains a \"..\" path element; this protects against callers who might unsafely use filepath.Join on r.URL.Path without sanitizing it and then use that filepath.Join result as the name argument. As another special case, ServeFileFS redirects any request where r.URL.Path ends in \"/index.html\" to the same path, without the final \"index.html\". To avoid such redirects either modify the path or use ServeContent. Outside of those two special cases, ServeFileFS does not use r.URL.Path for selecting the file or directory to serve; only the file or directory provided in the name argument is used. ServeTLS accepts incoming HTTPS connections on the listener l, creating a new service goroutine for each. The service goroutines read requests and then call handler to reply to them. The handler is typically nil, in which case DefaultServeMux is used. Additionally, files containing a certificate and matching private key for the server must be provided. If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate, any intermediates, and the CA's certificate. SetCookie adds a Set-Cookie header to the provided ResponseWriter's headers. The provided cookie must have a valid Name. Invalid cookies may be silently dropped. StatusText returns a text for the HTTP status code. It returns the empty string if the code is unknown."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/how-to-make-http-requests-in-go",
        "document": "The author selected the Diversity in Tech Fund to receive a donation as part of the Write for DOnations program.\n\nWhen a program needs to communicate with another program, many developers will use HTTP. One of Go’s strengths is the breadth of its standard library, and HTTP is no exception. The Go package not only supports creating HTTP servers, but it can also make HTTP requests as a client.\n\nIn this tutorial, you will create a program that makes several types of HTTP requests to an HTTP server. First, you will make a request using the default Go HTTP client. Then, you will enhance your program to make a request with a body. Finally, you will customize your request to include an HTTP header and add a timeout that will trigger if your request takes too long.\n\nTo follow this tutorial, you will need:\n• Go version 1.16 or greater installed. To set this up, follow the How To Install Go tutorial for your operating system.\n• Experience creating an HTTP server in Go, which can be found in the tutorial, How To Make an HTTP Server in Go.\n• Familiarity with goroutines and reading channels. For more information, see the tutorial, How To Run Multiple Functions Concurrently in Go.\n• An understanding of how an HTTP request is composed and sent is recommended.\n\nThe Go package has a few different ways to use it as a client. You can use a common, global HTTP client with functions such as to quickly make an HTTP request with only a URL and a body, or you can create an to begin customizing certain aspects of the individual request. In this section, you will create an initial program using to make an HTTP request, and then you will update it to use an with the default HTTP client.\n\nIn the first iteration of your program, you’ll use the function to make a request to the HTTP server you run in your program. The function is useful because you don’t need any additional setup in your program to make a request. If you need to make a single quick request, may be the best option.\n\nTo start creating your program, you’ll need a directory to keep the program’s directory in. In this tutorial, you’ll use a directory named .\n\nFirst, make the directory and navigate to it:\n\nNext, make the directory for your project and navigate to it. In this case, use the directory :\n\nInside the directory, use , or your favorite editor, to open the file:\n\nIn the file, begin by adding these lines:\n\nYou add the name so that your program is compiled as a program you can run, and then include an statement with the various packages you’ll be using in this program. After that, you create a called with the value , which you’ll use as the port your HTTP server is listening on and the port your HTTP client will connect to.\n\nNext, create a function in the file and set up a goroutine to start an HTTP server:\n\nYour HTTP server is set up to use to print information about incoming requests whenever the root path is requested. It’s also set to listen on . Finally, once you start up the server goroutine, your program uses for a short amount of time. This sleep time allows the HTTP server the time it needs to start up and start serving responses to the request you’ll be making next.\n\nNow, also in the function, set up the request URL using to combine the hostname with the value the server is listening on. Then, use to make a request to that URL, as shown below:\n\nWhen the function is called, Go will make an HTTP request using the default HTTP client to the URL provided, then return either an or an value if the request fails. If the request fails, it will print the error and then exit your program using with an error code of . If the request succeeds, your program will print out that it got a response and the HTTP status code it received.\n\nSave and close the file when you’re done.\n\nTo run your program, use the command and provide the file to it:\n\nYou will see the following output:\n\nOn the first line of output, the server prints that it received a request from your client for the path. Then, the following two lines say that the client got a response back from the server and that the response’s status code was .\n\nThe function is useful for quick HTTP requests like the one you made in this section. However, provides a broader range of options for customizing your request.\n\nIn contrast to , the function provides you with greater control over the request, other than just the HTTP method and the URL being requested. You won’t be using additional features yet, but by using an now, you’ll be able to add those customizations later in this tutorial.\n\nIn your code, the first update is to change the HTTP server handler to return a fake JSON data response using . If this were a full HTTP server, this data would be generated using Go’s package. If you’d like to learn more about using JSON in Go, our How To Use JSON in Go tutorial is available. In addition, you will also need to include package as an import for use later in this update.\n\nNow, open your file again and update your program to start using an as shown below:\n\nNow, update your HTTP request code so that instead of using to make a request to the server, you use and ’s method:\n\nIn this update, you use the function to generate an value, or handle the error if the value can’t be created. Unlike the function, though, the function doesn’t send an HTTP request to the server right away. Since it doesn’t send the request right away, you can make any changes you’d like to the request before it’s sent.\n\nOnce the is created and configured, you use the method of to send the request to the server. The value is Go’s default HTTP client, the same you’ve been using with . This time, though, you’re using it directly to tell it to send your . The method of the HTTP client returns the same values you received from the function so that you can handle the response in the same way.\n\nAfter you’ve printed the request results, you use the function to read the HTTP response’s . The is an value, a combination of and , which means you can read the body’s data using anything that can read from an value. The function is useful because it will read from an until it either gets to the end of the data or encounters an . Then it will either return the data as a value you can print using , or the value it encountered.\n\nTo run your updated program, save your changes and use the command:\n\nThis time, your output should look very similar to before, but with one addition:\n\nIn the first line, you see that the server is still receiving a request to the path. The client also receives a response from the server, but it’s also reading and printing the of the server’s response. In a more complex program, you could then take the value you received as the body from the server and process it as JSON using the package.\n\nIn this section, you created a program with an HTTP server that you made HTTP requests to in various ways. First, you used the function to make a request to the server using only the server’s URL. Then, you updated your program to use to create an value. Once that was created, you used the method of Go’s default HTTP client, , to make the request and print the to the output.\n\nThe HTTP protocol uses more than just requests to communicate between programs, though. A request is useful when you want to receive information from the other program, but another HTTP method, the method, can be used when you want to send information from your program to the server.\n\nIn a REST API, a request is only used for retrieving information from the server, so for your program to fully participate in a REST API, your program also needs to support sending requests. A request is almost the inverse of a request, where the client sends data to the server in the request’s body.\n\nIn this section, you will update your program to send your request as a request instead of a request. Your request will include a request body, and you will update your server to print out more information about the requests you’re making from the client.\n\nTo start making these updates, open your file and add a few new packages that you’ll be using to your statement:\n\nThen, update your server handler function to print out various information about the request coming in, such as query string values, header values, and the request body:\n\nIn this update to the server’s HTTP request handler, you add a few more helpful statements to see information about the request coming in. You use to get a query string value named , and to get the value of a header called . You also use a loop with to print the name and value of each HTTP header the server received. This information can be useful for troubleshooting issues if your client or server isn’t acting the way you expect. Finally, you also used the function to read the HTTP request’s body in .\n\nAfter updating the server handler function, update the function’s request code so that it’s sending a request with a request body:\n\nIn your update to the function’s request, one of the new values you’re defining is the value. In this example, the value is represented as a instead of the standard because if you use the package to encode JSON data, it will give you a back instead of a .\n\nThe next value, the , is a that wraps the data. An body requires the value to be an , and ’s value doesn’t implement , so you wouldn’t be able to use it as a request body on its own. The value exists to provide that interface, so you can use the value as the request body.\n\nThe value is also updated to include an query string value, primarily to show how a query string value can also be included in the request URL along with other standard URL components.\n\nFinally, the function call is updated to use a method with , and the request body is included by updating the last parameter from a body to , the JSON data .\n\nOnce you’ve saved your changes, you can use to run your program:\n\nThe output will be longer than before because of your updates to the server to show additional information:\n\nThe first line from the server shows that your request is now coming through as a request to the path. The second line shows the value of the query string value you added to the request’s URL. The third line shows the value of the header the client sent, which happens to be empty in this request.\n\nThe fourth line may be slightly different from the output you see above. In Go, the order of a value is not guaranteed when you iterate over them using , so your headers from may print out in a different order. Depending on the Go version you’re using, you may also see a different version than the one above.\n\nFinally, the last change in the output is that the server is showing the request body it received from the client. The server could then use the package to parse the JSON data the client sent and formulate a response.\n\nIn this section, you updated your program to send an HTTP request instead of a request. You also updated your program to send a request body with data being read by a . Finally, you updated the server handler function to print out more information about the request your HTTP client is making.\n\nTypically in an HTTP request, the client or the server will tell the other the type of content it’s sending in the body. As you saw in the last output, though, your HTTP request didn’t include a header to tell the server how to interpret the body’s data. In the next section, you’ll make a few updates to customize your HTTP request, including setting a header to let the server know the type of data you’re sending.\n\nOver time, HTTP requests and responses have been used to send a greater variety of data between clients and servers. At one point, HTTP clients could assume the data they’re receiving from an HTTP server is HTML and have a good chance of being correct. Now, though, it could be HTML, JSON, music, video, or any number of other data types. To provide more information about the data being sent over HTTP, the protocol includes HTTP headers, and one of those important headers is the header. This header tells the server (or client, depending on the direction of the data) how to interpret the data it’s receiving.\n\nIn this section, you will update your program to set the header on your HTTP request so the server knows it’s receiving JSON data. You will also update your program to use an HTTP client other than Go’s default so that you can customize how the request is sent.\n\nTo make these updates, open your file again and update your function like so:\n\nIn this update, you access the headers using , and then set the value of the header on the request to . The media type is defined in the list of media types as the media type for JSON. This way, when the server receives your request, it knows to interpret the body as JSON and not, for example, XML.\n\nThe next update is to create your own instance in the variable. In this client, you set the value to 30 seconds. This is important because it says that any requests made with the client will give up and stop trying to receive a response after 30 seconds. Go’s default doesn’t specify a timeout, so if you make a request using that client, it will wait until it receives a response, is disconnected by the server, or your program ends. If you have many requests hanging around like this waiting for a response, you could be using a large number of resources on your computer. Setting a value limits how long a request will wait by the time you define.\n\nFinally, you updated your request to use the method of your variable. You don’t need to make any other changes here because you’ve been calling on an value the whole time. Go’s default HTTP client, , is just an that’s created by default. So, when you called , the function was calling the method for you, and when you updated your request to use , you were using that directly. The only difference now is that you created the value you’re using this time.\n\nNow, save your file and run your program using :\n\nYour output should be very similar to the previous output but with more information about the content type:\n\nYou’ll see there’s a value from the server for , and there’s a header being sent by the client. This is how you could have the same HTTP request path serving both a JSON and an XML API at the same time. By specifying the request’s content type, the server and the client can interpret the data differently.\n\nThis example doesn’t trigger the client timeout you configured, though. To see what happens when a request takes too long and the timeout is triggered, open your file and add a function call to your HTTP server handler function. Then, make the last for longer than the timeout you specified. In this case, you’ll set it for 35 seconds:\n\nNow, save your changes and run your program using :\n\nWhen you run it this time, it will take longer to exit than before because it won’t exit until after the HTTP request is finished. Since you added the , the HTTP request won’t complete until the 30-second timeout is reached:\n\nIn this program output, you see the server received the request and processed it, but when it reached the end of the HTTP handler function where your function call is, it started sleeping for 35 seconds. At the same time, the timeout for your HTTP request is counting down and reaches the limit of 30 seconds before the HTTP request finishes. This results in the method call failing with a error because the request’s 30-second deadline passed. Then, your program exits with a failure status code of using .\n\nIn this section, you updated your program to customize an HTTP request by adding a header to it. You also updated your program to create a new with a 30-second timeout, and then used that client to make an HTTP request. You also tested the 30-second timeout by adding a to your HTTP request handler. Finally, you also saw why it’s important to use your own values with timeouts set if you want to avoid many requests potentially idling forever.\n\nIn this tutorial, you created a new program with an HTTP server and used Go’s package to make HTTP requests to that server. First, you used the function to make a request to the server with Go’s default HTTP client. Then, you used with ’s method to make a request. Next, you updated your request to make it a request with a body using . Finally, you used the method on an ’s field to set a request’s header, and set a 30-second timeout on a request’s duration by creating your own HTTP client instead of using Go’s default client.\n\nThe package includes more than just the functionality you used in this tutorial. It also includes an function that can be used to make a request, similar to the function. The package also supports saving and retrieving cookies, among other features.\n\nThis tutorial is also part of the DigitalOcean How to Code in Go series. The series covers a number of Go topics, from installing Go for the first time to how to use the language itself."
    },
    {
        "link": "https://medium.com/@emonemrulhasan35/net-http-package-in-go-e178c67d87f1",
        "document": "In Go when we start to know about http things and stuff, we will get to know a package which is net/http. Then some questions arise in our mind. Like why do we need this? When will this package be beneficial for us? What are the functionalities of this package? Today I will discuss it in a short manner so that it seems to be understood easily.\n\nWhy do we need this?\n\nHTTP is the foundation of the World Wide Web, serving as the primary means of communication between clients (for example: web browsers) and servers. By using the net/http package, we can create HTTP servers, handle incoming requests, and send requests to other servers and also we can manage responses with respect to a request. It makes it easy for us to work with HTTP and makes it easy to create web applications and services.\n\nWhat can be achieved by net/http package?\n\nThis package provides many functionality to work with HTTP. Such as\n\nWith this package, we can create web servers that listen for incoming HTTP requests. We can define functions. They are called handlers, to handle those requests and generate appropriate responses. For different requests we need to define different handlers which will manage the request and will also give the response. We can specify routes to direct requests to specific handlers based on the requested URL. This allows us to build the core infrastructure for web applications.\n\nThe package enables us to access and process information from incoming HTTP requests, such as headers and the data sent in the request body. Similarly, we can construct and send HTTP requests to other servers, including setting headers, providing data in the request body, and processing the responses received. It means using this package we can do custom requests to other servers.\n\nMiddleware allows us to add additional functionality to our HTTP server’s request processing pipeline. For example, We can use logging middleware by which we can log requests and responses. We can use authorization middleware to ensure only authenticated users can access certain routes, or rate-limiting middleware to control the number of requests from a specific client.\n\nWe can use the “net/http” package to serve static files, such as HTML, CSS, JavaScript, and images, directly from our HTTP server. This is important for web applications that require delivering static assets to clients.\n\nWhen will this package be beneficial for us?\n\nThere will be some scenarios when this package can be beneficial for us. Such as\n\nIf we are building a web application or service in Go, the “net/http” package provides the necessary tools to create an HTTP server that can handle incoming requests and generate appropriate responses. We can define routes, process data, and serve dynamic content to clients.\n\nIf our application needs to interact with external HTTP APIs, the “net/http” package allows us to send HTTP requests to those APIs, process the responses, and work with the received data. We can retrieve data from external services and integrate it into our application.\n\nWhen building microservices in Go, the “net/http” package helps us create lightweight HTTP servers. These servers can communicate with each other over HTTP, forming a scalable and resilient microservices architecture. Each microservice can expose its functionality through HTTP endpoints, allowing them to work together seamlessly.\n\nSo, for summary we can say net/http packages provided below key features.\n\nWe can create an HTTP Server that will listen to incoming requests and how to handle those requests and what to do with those requests. The package provides two powerful functions for handling requests and responses. They are http.HandleFunc and HTTP.Handler. These are used to register different routes of the server.\n\nWe can create an HTTP client to send HTTP requests to remote servers and receive responses. The package provides the http.Client type for creating and configuring an HTTP client.\n\nThe package provides various structures and functions to handle HTTP requests. We can access information such as the request method, URL, headers, and request body. You can also write response data, set response headers, and handle different HTTP status codes.\n\nThe package allows us to define routes and route handlers for different URL patterns. We can use the http.HandleFunc function to register a handler function for a specific URL pattern. It means for a specific route we will make a specific http.Handlerfunc which will be registered in a handler. In the http.Handlerfunc we will define what to do with the request and what will be the response. For different routes we need to define different http.HandlerFunc and each of the http.Handlerfunc will be registered into different handler. Whenever a request is made, the route will hit the corresponding handler for which handler the route was defined. Alternatively, we can use the http.ServeMux type to create a custom router with more advanced routing capabilities.\n\nWe can use middleware to modify the behaviour of an HTTP server or client. Middleware functions can intercept requests and responses, perform additional processing, and pass the request to the next middleware or handler. The package provides the http.Handler interface that allows you to chain multiple middleware functions together.\n\nLet’s understand it easily, assume we have multiple handlers for multiple routes. We want whenever a request will be made from the client side, we need to give some data as response for that request. And data is stored in a remote server. We defined http.Handlerfunc for each of the handlers. Handlers perform request handling and managing response through handler function. We want the handler to take the request and after that the handler can modify the request or can’t. Then we will give the request to something(assume as middleware) and that will take the data from the remote server and give the data to the handler and the handler will send the response to the client. Don’t be confused between handler and handler function. Handler function is the definition for handling request and managing response and get registered in a handler. This example is simply given to take the idea but not exactly.\n\nThe package provides functions and types to work with HTTP cookies. We can set cookies in the response headers, read cookies from the request, and manipulate cookie values.\n\nExplanation: In this example, we create a simple HTTP server that listens on port 8086. The server responds with the “Hello, Emon!” message for any incoming request to the root (“/”) URL. The http.HandleFunc function is used to register a handler function for the root URL.\n\nExplanation: In this example, we extend the previous HTTP server example to handle multiple routes. The server responds with different messages based on the URL path. For the root (“/”) URL, it responds with “Hello, Emon!”, and for the “/users” URL, it responds with “Welcome to Emon’s blog!”.\n\nExplanation: In this example, we create an HTTP client using the http.Client type. The client makes a GET request to the “https://api.example.com/data\" URL and receives a response. The response body is read and printed to the console.\n\nExplanation: The provided code defines an HTTP handler function for the ‘/users’ route using the ‘http’ package. This function responds to incoming HTTP requests on that route, processing them according to the specific request method (e.g., GET or POST).\n\nThe handler function is designed to accept two arguments: ResponseWriter and Request. ResponseWriter is an interface that aids in sending data back to the client as a response, while Request is a structured data containing details about the incoming request, such as its HTTP method, URL, and headers.\n\nWithin the handler function, a switch statement is used to identify the request method and execute different code blocks based on the method type. If the method is GET, the function will handle the GET request accordingly. Alternatively, if the method is POST, it will handle the POST request accordingly.\n\nIn case the method is anything other than GET or POST, the handler will respond by sending an ‘Invalid request method’ message back to the client using the http.Error function, along with a StatusMethodNotAllowed HTTP status code."
    },
    {
        "link": "https://stackoverflow.com/questions/55210301/error-handling-with-http-newrequest-in-go",
        "document": "I was using to make a GET Request.\n\nI deliberately tried to tamper the API url just to check if my err handling works.\n\nBut its not working as expected . In err value is returned and I am unable to compare it.\n\nThe output is as below:\n\nBut I am expecting to print \"Wrong\"."
    },
    {
        "link": "https://golang.google.cn/pkg/net/http",
        "document": "Unless otherwise noted, these are defined in RFC 7231 section 4.3.\n\nHTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml\n\nDefaultMaxHeaderBytes is the maximum permitted size of the headers in an HTTP request. This can be overridden by setting [Server.MaxHeaderBytes].\n\nDefaultMaxIdleConnsPerHost is the default value of Transport's MaxIdleConnsPerHost.\n\nTimeFormat is the time format to use when generating times in HTTP headers. It is like time.RFC1123 but hard-codes GMT as the time zone. The time being formatted must be in UTC for Format to generate the correct format.\n\nFor parsing this time format, see ParseTime.\n\nTrailerPrefix is a magic prefix for [ResponseWriter.Header] map keys that, if present, signals that the map entry is actually for the response trailers, and not the response headers. The prefix is stripped after the ServeHTTP call finishes and the values are sent in the trailers.\n\nThis mechanism is intended only for trailers that are not known prior to the headers being written. If the set of trailers is fixed or known before the header is written, the normal Go trailers mechanism is preferred:\n\nErrors used by the HTTP server.\n\nDefaultClient is the default Client and is used by Get, Head, and Post.\n\nDefaultServeMux is the default ServeMux used by Serve.\n\nErrAbortHandler is a sentinel panic value to abort a handler. While any panic from ServeHTTP aborts the response to the client, panicking with ErrAbortHandler also suppresses logging of a stack trace to the server's error log.\n\nErrBodyReadAfterClose is returned when reading a Request or Response Body after the body has been closed. This typically happens when the body is read after an HTTP Handler calls WriteHeader or Write on its ResponseWriter.\n\nErrHandlerTimeout is returned on ResponseWriter Write calls in handlers which have timed out.\n\nErrLineTooLong is returned when reading request or response bodies with malformed chunked encoding.\n\nErrMissingFile is returned by FormFile when the provided file field name is either not present in the request or not a file field.\n\nErrNoCookie is returned by Request's Cookie method when a cookie is not found.\n\nErrNoLocation is returned by the Response.Location method when no Location header is present.\n\nErrSchemeMismatch is returned when a server returns an HTTP response to an HTTPS client.\n\nErrServerClosed is returned by the Server.Serve, ServeTLS, ListenAndServe, and ListenAndServeTLS methods after a call to Server.Shutdown or Server.Close.\n\nErrSkipAltProtocol is a sentinel error value defined by Transport.RegisterProtocol.\n\nErrUseLastResponse can be returned by Client.CheckRedirect hooks to control how redirects are processed. If returned, the next request is not sent and the most recent response is returned with its body unclosed.\n\nNoBody is an io.ReadCloser with no bytes. Read always returns EOF and Close always returns nil. It can be used in an outgoing client request to explicitly signal that a request has zero bytes. An alternative, however, is to simply set [Request.Body] to nil.\n\nCanonicalHeaderKey returns the canonical format of the header key s. The canonicalization converts the first letter and any letter following a hyphen to upper case; the rest are converted to lowercase. For example, the canonical key for \"accept-encoding\" is \"Accept-Encoding\". If s contains a space or invalid header field bytes, it is returned without modifications.\n\nDetectContentType implements the algorithm described at https://mimesniff.spec.whatwg.org/ to determine the Content-Type of the given data. It considers at most the first 512 bytes of data. DetectContentType always returns a valid MIME type: if it cannot determine a more specific one, it returns \"application/octet-stream\".\n\nError replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text.\n\nError deletes the Content-Length header, sets Content-Type to “text/plain; charset=utf-8”, and sets X-Content-Type-Options to “nosniff”. This configures the header properly for the error message, in case the caller had set it up expecting a successful output.\n\nHandle registers the handler for the given pattern in DefaultServeMux. The documentation for ServeMux explains how patterns are matched.\n\nHandleFunc registers the handler function for the given pattern in DefaultServeMux. The documentation for ServeMux explains how patterns are matched.\n\nListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case DefaultServeMux is used.\n\nListenAndServeTLS acts identically to ListenAndServe, except that it expects HTTPS connections. Additionally, files containing a certificate and matching private key for the server must be provided. If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate, any intermediates, and the CA's certificate.\n\nMaxBytesReader is similar to io.LimitReader but is intended for limiting the size of incoming request bodies. In contrast to io.LimitReader, MaxBytesReader's result is a ReadCloser, returns a non-nil error of type *MaxBytesError for a Read beyond the limit, and closes the underlying reader when its Close method is called.\n\nMaxBytesReader prevents clients from accidentally or maliciously sending a large request and wasting server resources. If possible, it tells the ResponseWriter to close the connection after the limit has been reached.\n\nNotFound replies to the request with an HTTP 404 not found error.\n\nParseHTTPVersion parses an HTTP version string according to RFC 7230, section 2.6. \"HTTP/1.0\" returns (1, 0, true). Note that strings without a minor version, such as \"HTTP/2\", are not valid.\n\nParseTime parses a time header (such as the Date: header), trying each of the three formats allowed by HTTP/1.1: TimeFormat, time.RFC850, and time.ANSIC.\n\nProxyFromEnvironment returns the URL of the proxy to use for a given request, as indicated by the environment variables HTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions thereof). Requests use the proxy from the environment variable matching their scheme, unless excluded by NO_PROXY.\n\nThe environment values may be either a complete URL or a \"host[:port]\", in which case the \"http\" scheme is assumed. An error is returned if the value is a different form.\n\nA nil URL and nil error are returned if no proxy is defined in the environment, or a proxy should not be used for the given request, as defined by NO_PROXY.\n\nAs a special case, if req.URL.Host is \"localhost\" (with or without a port number), then a nil URL and nil error will be returned.\n\nProxyURL returns a proxy function (for use in a Transport) that always returns the same URL.\n\nRedirect replies to the request with a redirect to url, which may be a path relative to the request path.\n\nThe provided code should be in the 3xx range and is usually StatusMovedPermanently, StatusFound or StatusSeeOther.\n\nIf the Content-Type header has not been set, Redirect sets it to \"text/html; charset=utf-8\" and writes a small HTML body. Setting the Content-Type header to any value, including nil, disables that behavior.\n\nServe accepts incoming HTTP connections on the listener l, creating a new service goroutine for each. The service goroutines read requests and then call handler to reply to them.\n\nThe handler is typically nil, in which case DefaultServeMux is used.\n\nHTTP/2 support is only enabled if the Listener returns *tls.Conn connections and they were configured with \"h2\" in the TLS Config.NextProtos.\n\nServeContent replies to the request using the content in the provided ReadSeeker. The main benefit of ServeContent over io.Copy is that it handles Range requests properly, sets the MIME type, and handles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since, and If-Range requests.\n\nIf the response's Content-Type header is not set, ServeContent first tries to deduce the type from name's file extension and, if that fails, falls back to reading the first block of the content and passing it to DetectContentType. The name is otherwise unused; in particular it can be empty and is never sent in the response.\n\nIf modtime is not the zero time or Unix epoch, ServeContent includes it in a Last-Modified header in the response. If the request includes an If-Modified-Since header, ServeContent uses modtime to decide whether the content needs to be sent at all.\n\nThe content's Seek method must work: ServeContent uses a seek to the end of the content to determine its size. Note that *os.File implements the io.ReadSeeker interface.\n\nIf the caller has set w's ETag header formatted per RFC 7232, section 2.3, ServeContent uses it to handle requests using If-Match, If-None-Match, or If-Range.\n\nIf an error occurs when serving the request (for example, when handling an invalid range request), ServeContent responds with an error message. By default, ServeContent strips the Cache-Control, Content-Encoding, ETag, and Last-Modified headers from error responses. The GODEBUG setting httpservecontentkeepheaders=1 causes ServeContent to preserve these headers.\n\nServeFile replies to the request with the contents of the named file or directory.\n\nIf the provided file or directory name is a relative path, it is interpreted relative to the current directory and may ascend to parent directories. If the provided name is constructed from user input, it should be sanitized before calling ServeFile.\n\nAs a precaution, ServeFile will reject requests where r.URL.Path contains a \"..\" path element; this protects against callers who might unsafely use filepath.Join on r.URL.Path without sanitizing it and then use that filepath.Join result as the name argument.\n\nAs another special case, ServeFile redirects any request where r.URL.Path ends in \"/index.html\" to the same path, without the final \"index.html\". To avoid such redirects either modify the path or use ServeContent.\n\nOutside of those two special cases, ServeFile does not use r.URL.Path for selecting the file or directory to serve; only the file or directory provided in the name argument is used.\n\nServeFileFS replies to the request with the contents of the named file or directory from the file system fsys. The files provided by fsys must implement io.Seeker.\n\nIf the provided name is constructed from user input, it should be sanitized before calling ServeFileFS.\n\nAs a precaution, ServeFileFS will reject requests where r.URL.Path contains a \"..\" path element; this protects against callers who might unsafely use filepath.Join on r.URL.Path without sanitizing it and then use that filepath.Join result as the name argument.\n\nAs another special case, ServeFileFS redirects any request where r.URL.Path ends in \"/index.html\" to the same path, without the final \"index.html\". To avoid such redirects either modify the path or use ServeContent.\n\nOutside of those two special cases, ServeFileFS does not use r.URL.Path for selecting the file or directory to serve; only the file or directory provided in the name argument is used.\n\nServeTLS accepts incoming HTTPS connections on the listener l, creating a new service goroutine for each. The service goroutines read requests and then call handler to reply to them.\n\nThe handler is typically nil, in which case DefaultServeMux is used.\n\nAdditionally, files containing a certificate and matching private key for the server must be provided. If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate, any intermediates, and the CA's certificate.\n\nSetCookie adds a Set-Cookie header to the provided ResponseWriter's headers. The provided cookie must have a valid Name. Invalid cookies may be silently dropped.\n\nStatusText returns a text for the HTTP status code. It returns the empty string if the code is unknown.\n\nA Client is an HTTP client. Its zero value (DefaultClient) is a usable client that uses DefaultTransport.\n\nThe [Client.Transport] typically has internal state (cached TCP connections), so Clients should be reused instead of created as needed. Clients are safe for concurrent use by multiple goroutines.\n\nA Client is higher-level than a RoundTripper (such as Transport) and additionally handles HTTP details such as cookies and redirects.\n\nWhen following redirects, the Client will forward all headers set on the initial Request except:\n• when forwarding sensitive headers like \"Authorization\", \"WWW-Authenticate\", and \"Cookie\" to untrusted targets. These headers will be ignored when following a redirect to a domain that is not a subdomain match or exact match of the initial domain. For example, a redirect from \"foo.com\" to either \"foo.com\" or \"sub.foo.com\" will forward the sensitive headers, but a redirect to \"bar.com\" will not.\n• when forwarding the \"Cookie\" header with a non-nil cookie Jar. Since each redirect may mutate the state of the cookie jar, a redirect may possibly alter a cookie set in the initial request. When forwarding the \"Cookie\" header, any mutated cookies will be omitted, with the expectation that the Jar will insert those mutated cookies with the updated values (assuming the origin matches). If Jar is nil, the initial cookies are forwarded without change.\n\nCloseIdleConnections closes any connections on its Transport which were previously connected from previous requests but are now sitting idle in a \"keep-alive\" state. It does not interrupt any connections currently in use.\n\nIf [Client.Transport] does not have a Client.CloseIdleConnections method then this method does nothing.\n\nDo sends an HTTP request and returns an HTTP response, following policy (such as redirects, cookies, auth) as configured on the client.\n\nAn error is returned if caused by client policy (such as CheckRedirect), or failure to speak HTTP (such as a network connectivity problem). A non-2xx status code doesn't cause an error.\n\nIf the returned error is nil, the Response will contain a non-nil Body which the user is expected to close. If the Body is not both read to EOF and closed, the Client's underlying RoundTripper (typically Transport) may not be able to re-use a persistent TCP connection to the server for a subsequent \"keep-alive\" request.\n\nThe request Body, if non-nil, will be closed by the underlying Transport, even on errors. The Body may be closed asynchronously after Do returns.\n\nOn error, any Response can be ignored. A non-nil Response with a non-nil error only occurs when CheckRedirect fails, and even then the returned [Response.Body] is already closed.\n\nGenerally Get, Post, or PostForm will be used instead of Do.\n\nIf the server replies with a redirect, the Client first uses the CheckRedirect function to determine whether the redirect should be followed. If permitted, a 301, 302, or 303 redirect causes subsequent requests to use HTTP method GET (or HEAD if the original request was HEAD), with no body. A 307 or 308 redirect preserves the original HTTP method and body, provided that the [Request.GetBody] function is defined. The NewRequest function automatically sets GetBody for common standard library body types.\n\nAny returned error will be of type *url.Error. The url.Error value's Timeout method will report true if the request timed out.\n\nGet issues a GET to the specified URL. If the response is one of the following redirect codes, Get follows the redirect after calling the [Client.CheckRedirect] function:\n\nAn error is returned if the [Client.CheckRedirect] function fails or if there was an HTTP protocol error. A non-2xx response doesn't cause an error. Any returned error will be of type *url.Error. The url.Error value's Timeout method will report true if the request timed out.\n\nWhen err is nil, resp always contains a non-nil resp.Body. Caller should close resp.Body when done reading from it.\n\nTo make a request with custom headers, use NewRequest and Client.Do.\n\nTo make a request with a specified context.Context, use NewRequestWithContext and Client.Do.\n\nHead issues a HEAD to the specified URL. If the response is one of the following redirect codes, Head follows the redirect after calling the [Client.CheckRedirect] function:\n\nTo make a request with a specified context.Context, use NewRequestWithContext and Client.Do.\n\nPost issues a POST to the specified URL.\n\nCaller should close resp.Body when done reading from it.\n\nIf the provided body is an io.Closer, it is closed after the request.\n\nTo set custom headers, use NewRequest and Client.Do.\n\nTo make a request with a specified context.Context, use NewRequestWithContext and Client.Do.\n\nSee the Client.Do method documentation for details on how redirects are handled.\n\nPostForm issues a POST to the specified URL, with data's keys and values URL-encoded as the request body.\n\nThe Content-Type header is set to application/x-www-form-urlencoded. To set other headers, use NewRequest and Client.Do.\n\nWhen err is nil, resp always contains a non-nil resp.Body. Caller should close resp.Body when done reading from it.\n\nSee the Client.Do method documentation for details on how redirects are handled.\n\nTo make a request with a specified context.Context, use NewRequestWithContext and Client.Do.\n\nThe CloseNotifier interface is implemented by ResponseWriters which allow detecting when the underlying connection has gone away.\n\nThis mechanism can be used to cancel long operations on the server if the client has disconnected before the response is ready.\n\nDeprecated: the CloseNotifier interface predates Go's context package. New code should use Request.Context instead.\n\nA ConnState represents the state of a client connection to a server. It's used by the optional [Server.ConnState] hook.\n\nA Cookie represents an HTTP cookie as sent in the Set-Cookie header of an HTTP response or the Cookie header of an HTTP request.\n\nParseCookie parses a Cookie header value and returns all the cookies which were set in it. Since the same cookie name can appear multiple times the returned Values can contain more than one value for a given key.\n\nParseSetCookie parses a Set-Cookie header value and returns a cookie. It returns an error on syntax error.\n\nString returns the serialization of the cookie for use in a Cookie header (if only Name and Value are set) or a Set-Cookie response header (if other fields are set). If c is nil or c.Name is invalid, the empty string is returned.\n\nValid reports whether the cookie is valid.\n\nA CookieJar manages storage and use of cookies in HTTP requests.\n\nImplementations of CookieJar must be safe for concurrent use by multiple goroutines.\n\nA Dir implements FileSystem using the native file system restricted to a specific directory tree.\n\nWhile the [FileSystem.Open] method takes '/'-separated paths, a Dir's string value is a directory path on the native file system, not a URL, so it is separated by filepath.Separator, which isn't necessarily '/'.\n\nNote that Dir could expose sensitive files and directories. Dir will follow symlinks pointing out of the directory tree, which can be especially dangerous if serving from a directory in which users are able to create arbitrary symlinks. Dir will also allow access to files and directories starting with a period, which could expose sensitive directories like .git or sensitive files like .htpasswd. To exclude files with a leading period, remove the files/directories from the server or create a custom FileSystem implementation.\n\nAn empty Dir is treated as \".\".\n\nOpen implements FileSystem using os.Open, opening files for reading rooted and relative to the directory d.\n\nA File is returned by a FileSystem's Open method and can be served by the FileServer implementation.\n\nThe methods should behave the same as those on an *os.File.\n\nA FileSystem implements access to a collection of named files. The elements in a file path are separated by slash ('/', U+002F) characters, regardless of host operating system convention. See the FileServer function to convert a FileSystem to a Handler.\n\nThis interface predates the fs.FS interface, which can be used instead: the FS adapter function converts an fs.FS to a FileSystem.\n\nFS converts fsys to a FileSystem implementation, for use with FileServer and NewFileTransport. The files provided by fsys must implement io.Seeker.\n\nThe Flusher interface is implemented by ResponseWriters that allow an HTTP handler to flush buffered data to the client.\n\nThe default HTTP/1.x and HTTP/2 ResponseWriter implementations support Flusher, but ResponseWriter wrappers may not. Handlers should always test for this ability at runtime.\n\nNote that even for ResponseWriters that support Flush, if the client is connected through an HTTP proxy, the buffered data may not reach the client until the response completes.\n\nHTTP2Config defines HTTP/2 configuration parameters common to both Transport and Server.\n\n[Handler.ServeHTTP] should write reply headers and data to the ResponseWriter and then return. Returning signals that the request is finished; it is not valid to use the ResponseWriter or read from the [Request.Body] after or concurrently with the completion of the ServeHTTP call.\n\nDepending on the HTTP client software, HTTP protocol version, and any intermediaries between the client and the Go server, it may not be possible to read from the [Request.Body] after writing to the ResponseWriter. Cautious handlers should read the [Request.Body] first, and then reply.\n\nExcept for reading the body, handlers should not modify the provided Request.\n\nIf ServeHTTP panics, the server (the caller of ServeHTTP) assumes that the effect of the panic was isolated to the active request. It recovers the panic, logs a stack trace to the server error log, and either closes the network connection or sends an HTTP/2 RST_STREAM, depending on the HTTP protocol. To abort a handler so the client sees an interrupted response but the server doesn't log an error, panic with the value ErrAbortHandler.\n\nAllowQuerySemicolons returns a handler that serves requests by converting any unescaped semicolons in the URL query to ampersands, and invoking the handler h.\n\nThis restores the pre-Go 1.17 behavior of splitting query parameters on both semicolons and ampersands. (See golang.org/issue/25192). Note that this behavior doesn't match that of many proxies, and the mismatch can lead to security issues.\n\nAllowQuerySemicolons should be invoked before Request.ParseForm is called.\n\nFileServer returns a handler that serves HTTP requests with the contents of the file system rooted at root.\n\nAs a special case, the returned file server redirects any request ending in \"/index.html\" to the same path, without the final \"index.html\".\n\nTo use the operating system's file system implementation, use http.Dir:\n\nTo use an fs.FS implementation, use http.FileServerFS instead.\n\nFileServerFS returns a handler that serves HTTP requests with the contents of the file system fsys. The files provided by fsys must implement io.Seeker.\n\nAs a special case, the returned file server redirects any request ending in \"/index.html\" to the same path, without the final \"index.html\".\n\nMaxBytesHandler returns a Handler that runs h with its ResponseWriter and [Request.Body] wrapped by a MaxBytesReader.\n\nNotFoundHandler returns a simple request handler that replies to each request with a “404 page not found” reply.\n\nRedirectHandler returns a request handler that redirects each request it receives to the given url using the given status code.\n\nThe provided code should be in the 3xx range and is usually StatusMovedPermanently, StatusFound or StatusSeeOther.\n\nStripPrefix returns a handler that serves HTTP requests by removing the given prefix from the request URL's Path (and RawPath if set) and invoking the handler h. StripPrefix handles a request for a path that doesn't begin with prefix by replying with an HTTP 404 not found error. The prefix must match exactly: if the prefix in the request contains escaped characters the reply is also an HTTP 404 not found error.\n\nTimeoutHandler returns a Handler that runs h with the given time limit.\n\nThe new Handler calls h.ServeHTTP to handle each request, but if a call runs for longer than its time limit, the handler responds with a 503 Service Unavailable error and the given message in its body. (If msg is empty, a suitable default message will be sent.) After such a timeout, writes by h to its ResponseWriter will return ErrHandlerTimeout.\n\nTimeoutHandler supports the Pusher interface but does not support the Hijacker or Flusher interfaces.\n\nThe HandlerFunc type is an adapter to allow the use of ordinary functions as HTTP handlers. If f is a function with the appropriate signature, HandlerFunc(f) is a Handler that calls f.\n\nA Header represents the key-value pairs in an HTTP header.\n\nThe keys should be in canonical form, as returned by CanonicalHeaderKey.\n\nAdd adds the key, value pair to the header. It appends to any existing values associated with key. The key is case insensitive; it is canonicalized by CanonicalHeaderKey.\n\nClone returns a copy of h or nil if h is nil.\n\nDel deletes the values associated with key. The key is case insensitive; it is canonicalized by CanonicalHeaderKey.\n\nGet gets the first value associated with the given key. If there are no values associated with the key, Get returns \"\". It is case insensitive; textproto.CanonicalMIMEHeaderKey is used to canonicalize the provided key. Get assumes that all keys are stored in canonical form. To use non-canonical keys, access the map directly.\n\nSet sets the header entries associated with key to the single element value. It replaces any existing values associated with key. The key is case insensitive; it is canonicalized by textproto.CanonicalMIMEHeaderKey. To use non-canonical keys, assign to the map directly.\n\nValues returns all values associated with the given key. It is case insensitive; textproto.CanonicalMIMEHeaderKey is used to canonicalize the provided key. To use non-canonical keys, access the map directly. The returned slice is not a copy.\n\nWriteSubset writes a header in wire format. If exclude is not nil, keys where exclude[key] == true are not written. Keys are not canonicalized before checking the exclude map.\n\nThe Hijacker interface is implemented by ResponseWriters that allow an HTTP handler to take over the connection.\n\nThe default ResponseWriter for HTTP/1.x connections supports Hijacker, but HTTP/2 connections intentionally do not. ResponseWriter wrappers may also not support Hijacker. Handlers should always test for this ability at runtime.\n\nMaxBytesError is returned by MaxBytesReader when its read limit is exceeded.\n\nDeprecated: Not all errors in the http package related to protocol errors are of type ProtocolError.\n\nProtocols is a set of HTTP protocols. The zero value is an empty set of protocols.\n• None HTTP1 is the HTTP/1.0 and HTTP/1.1 protocols. HTTP1 is supported on both unsecured TCP and secured TLS connections.\n• None HTTP2 is the HTTP/2 protcol over a TLS connection.\n• None UnencryptedHTTP2 is the HTTP/2 protocol over an unsecured TCP connection.\n\nPusher is the interface implemented by ResponseWriters that support HTTP/2 server push. For more background, see https://tools.ietf.org/html/rfc7540#section-8.2.\n\nA Request represents an HTTP request received by a server or to be sent by a client.\n\nThe field semantics differ slightly between client and server usage. In addition to the notes on the fields below, see the documentation for Request.Write and RoundTripper.\n\nNewRequestWithContext returns a new Request given a method, URL, and optional body.\n\nIf the provided body is also an io.Closer, the returned [Request.Body] is set to body and will be closed (possibly asynchronously) by the Client methods Do, Post, and PostForm, and Transport.RoundTrip.\n\nNewRequestWithContext returns a Request suitable for use with Client.Do or Transport.RoundTrip. To create a request for use with testing a Server Handler, either use the net/http/httptest.NewRequest function, use ReadRequest, or manually update the Request fields. For an outgoing client request, the context controls the entire lifetime of a request and its response: obtaining a connection, sending the request, and reading the response headers and body. See the Request type's documentation for the difference between inbound and outbound request fields.\n\nIf body is of type *bytes.Buffer, *bytes.Reader, or *strings.Reader, the returned request's ContentLength is set to its exact value (instead of -1), GetBody is populated (so 307 and 308 redirects can replay the body), and Body is set to NoBody if the ContentLength is 0.\n\nReadRequest reads and parses an incoming request from b.\n\nReadRequest is a low-level function and should only be used for specialized applications; most code should use the Server to read requests and handle them via the Handler interface. ReadRequest only supports HTTP/1.x requests. For HTTP/2, use golang.org/x/net/http2.\n\nAddCookie adds a cookie to the request. Per RFC 6265 section 5.4, AddCookie does not attach more than one Cookie header field. That means all cookies, if any, are written into the same line, separated by semicolon. AddCookie only sanitizes c's name and value, and does not sanitize a Cookie header already present in the request.\n\nBasicAuth returns the username and password provided in the request's Authorization header, if the request uses HTTP Basic Authentication. See RFC 2617, Section 2.\n\nClone returns a deep copy of r with its context changed to ctx. The provided ctx must be non-nil.\n\nClone only makes a shallow copy of the Body field.\n\nFor an outgoing client request, the context controls the entire lifetime of a request and its response: obtaining a connection, sending the request, and reading the response headers and body.\n\nContext returns the request's context. To change the context, use Request.Clone or Request.WithContext.\n\nThe returned context is always non-nil; it defaults to the background context.\n\nFor incoming server requests, the context is canceled when the client's connection closes, the request is canceled (with HTTP/2), or when the ServeHTTP method returns.\n\nCookie returns the named cookie provided in the request or ErrNoCookie if not found. If multiple cookies match the given name, only one cookie will be returned.\n\nCookies parses and returns the HTTP cookies sent with the request.\n\nCookiesNamed parses and returns the named HTTP cookies sent with the request or an empty slice if none matched.\n\nFormFile returns the first file for the provided form key. FormFile calls Request.ParseMultipartForm and Request.ParseForm if necessary.\n\nFormValue returns the first value for the named component of the query. The precedence order:\n\nFormValue calls Request.ParseMultipartForm and Request.ParseForm if necessary and ignores any errors returned by these functions. If key is not present, FormValue returns the empty string. To access multiple values of the same key, call ParseForm and then inspect [Request.Form] directly.\n\nMultipartReader returns a MIME multipart reader if this is a multipart/form-data or a multipart/mixed POST request, else returns nil and an error. Use this function instead of Request.ParseMultipartForm to process the request body as a stream.\n\nFor all requests, ParseForm parses the raw query from the URL and updates r.Form.\n\nFor POST, PUT, and PATCH requests, it also reads the request body, parses it as a form and puts the results into both r.PostForm and r.Form. Request body parameters take precedence over URL query string values in r.Form.\n\nIf the request Body's size has not already been limited by MaxBytesReader, the size is capped at 10MB.\n\nFor other HTTP methods, or when the Content-Type is not application/x-www-form-urlencoded, the request Body is not read, and r.PostForm is initialized to a non-nil, empty value.\n\nParseMultipartForm parses a request body as multipart/form-data. The whole request body is parsed and up to a total of maxMemory bytes of its file parts are stored in memory, with the remainder stored on disk in temporary files. ParseMultipartForm calls Request.ParseForm if necessary. If ParseForm returns an error, ParseMultipartForm returns it but also continues parsing the request body. After one call to ParseMultipartForm, subsequent calls have no effect.\n\nPathValue returns the value for the named path wildcard in the ServeMux pattern that matched the request. It returns the empty string if the request was not matched against a pattern or there is no such wildcard in the pattern.\n\nPostFormValue returns the first value for the named component of the POST, PUT, or PATCH request body. URL query parameters are ignored. PostFormValue calls Request.ParseMultipartForm and Request.ParseForm if necessary and ignores any errors returned by these functions. If key is not present, PostFormValue returns the empty string.\n\nProtoAtLeast reports whether the HTTP protocol used in the request is at least major.minor.\n\nReferer returns the referring URL, if sent in the request.\n\nReferer is misspelled as in the request itself, a mistake from the earliest days of HTTP. This value can also be fetched from the Header map as Header[\"Referer\"]; the benefit of making it available as a method is that the compiler can diagnose programs that use the alternate (correct English) spelling req.Referrer() but cannot diagnose programs that use Header[\"Referrer\"].\n\nSetBasicAuth sets the request's Authorization header to use HTTP Basic Authentication with the provided username and password.\n\nWith HTTP Basic Authentication the provided username and password are not encrypted. It should generally only be used in an HTTPS request.\n\nThe username may not contain a colon. Some protocols may impose additional requirements on pre-escaping the username and password. For instance, when used with OAuth2, both arguments must be URL encoded first with url.QueryEscape.\n\nSetPathValue sets name to value, so that subsequent calls to r.PathValue(name) return value.\n\nUserAgent returns the client's User-Agent, if sent in the request.\n\nWithContext returns a shallow copy of r with its context changed to ctx. The provided ctx must be non-nil.\n\nFor outgoing client request, the context controls the entire lifetime of a request and its response: obtaining a connection, sending the request, and reading the response headers and body.\n\nTo create a new request with a context, use NewRequestWithContext. To make a deep copy of a request with a new context, use Request.Clone.\n\nWrite writes an HTTP/1.1 request, which is the header and body, in wire format. This method consults the following fields of the request:\n\nIf Body is present, Content-Length is <= 0 and [Request.TransferEncoding] hasn't been set to \"identity\", Write adds \"Transfer-Encoding: chunked\" to the header. Body is closed after it is sent.\n\nWriteProxy is like Request.Write but writes the request in the form expected by an HTTP proxy. In particular, Request.WriteProxy writes the initial Request-URI line of the request with an absolute URI, per section 5.3 of RFC 7230, including the scheme and host. In either case, WriteProxy also writes a Host header, using either r.Host or r.URL.Host.\n\nResponse represents the response from an HTTP request.\n\nThe Client and Transport return Responses from servers once the response headers have been received. The response body is streamed on demand as the Body field is read.\n\nGet issues a GET to the specified URL. If the response is one of the following redirect codes, Get follows the redirect, up to a maximum of 10 redirects:\n\nAn error is returned if there were too many redirects or if there was an HTTP protocol error. A non-2xx response doesn't cause an error. Any returned error will be of type *url.Error. The url.Error value's Timeout method will report true if the request timed out.\n\nWhen err is nil, resp always contains a non-nil resp.Body. Caller should close resp.Body when done reading from it.\n\nGet is a wrapper around DefaultClient.Get.\n\nTo make a request with custom headers, use NewRequest and DefaultClient.Do.\n\nTo make a request with a specified context.Context, use NewRequestWithContext and DefaultClient.Do.\n\nHead issues a HEAD to the specified URL. If the response is one of the following redirect codes, Head follows the redirect, up to a maximum of 10 redirects:\n\nTo make a request with a specified context.Context, use NewRequestWithContext and DefaultClient.Do.\n\nPost issues a POST to the specified URL.\n\nCaller should close resp.Body when done reading from it.\n\nIf the provided body is an io.Closer, it is closed after the request.\n\nTo set custom headers, use NewRequest and DefaultClient.Do.\n\nSee the Client.Do method documentation for details on how redirects are handled.\n\nTo make a request with a specified context.Context, use NewRequestWithContext and DefaultClient.Do.\n\nPostForm issues a POST to the specified URL, with data's keys and values URL-encoded as the request body.\n\nThe Content-Type header is set to application/x-www-form-urlencoded. To set other headers, use NewRequest and DefaultClient.Do.\n\nWhen err is nil, resp always contains a non-nil resp.Body. Caller should close resp.Body when done reading from it.\n\nSee the Client.Do method documentation for details on how redirects are handled.\n\nTo make a request with a specified context.Context, use NewRequestWithContext and DefaultClient.Do.\n\nReadResponse reads and returns an HTTP response from r. The req parameter optionally specifies the Request that corresponds to this Response. If nil, a GET request is assumed. Clients must call resp.Body.Close when finished reading resp.Body. After that call, clients can inspect resp.Trailer to find key/value pairs included in the response trailer.\n\nCookies parses and returns the cookies set in the Set-Cookie headers.\n\nLocation returns the URL of the response's \"Location\" header, if present. Relative redirects are resolved relative to [Response.Request]. ErrNoLocation is returned if no Location header is present.\n\nProtoAtLeast reports whether the HTTP protocol used in the response is at least major.minor.\n\nWrite writes r to w in the HTTP/1.x server response format, including the status line, headers, body, and optional trailer.\n\nThis method consults the following fields of the response r:\n\nThe Response Body is closed after it is sent.\n\nA ResponseController is used by an HTTP handler to control the response.\n\nA ResponseController may not be used after the [Handler.ServeHTTP] method has returned.\n\nThe ResponseWriter should be the original value passed to the [Handler.ServeHTTP] method, or have an Unwrap method returning the original ResponseWriter.\n\nIf the ResponseWriter implements any of the following methods, the ResponseController will call them as appropriate:\n\nIf the ResponseWriter does not support a method, ResponseController returns an error matching ErrNotSupported.\n\nEnableFullDuplex indicates that the request handler will interleave reads from [Request.Body] with writes to the ResponseWriter.\n\nFor HTTP/1 requests, the Go HTTP server by default consumes any unread portion of the request body before beginning to write the response, preventing handlers from concurrently reading from the request and writing the response. Calling EnableFullDuplex disables this behavior and permits handlers to continue to read from the request while concurrently writing the response.\n\nFor HTTP/2 requests, the Go HTTP server always permits concurrent reads and responses.\n\nHijack lets the caller take over the connection. See the Hijacker interface for details.\n\nSetReadDeadline sets the deadline for reading the entire request, including the body. Reads from the request body after the deadline has been exceeded will return an error. A zero value means no deadline.\n\nSetting the read deadline after it has been exceeded will not extend it.\n\nSetWriteDeadline sets the deadline for writing the response. Writes to the response body after the deadline has been exceeded will not block, but may succeed if the data has been buffered. A zero value means no deadline.\n\nSetting the write deadline after it has been exceeded will not extend it.\n\nA ResponseWriter interface is used by an HTTP handler to construct an HTTP response.\n\nA ResponseWriter may not be used after [Handler.ServeHTTP] has returned.\n\nRoundTripper is an interface representing the ability to execute a single HTTP transaction, obtaining the Response for a given Request.\n\nA RoundTripper must be safe for concurrent use by multiple goroutines.\n\nDefaultTransport is the default implementation of Transport and is used by DefaultClient. It establishes network connections as needed and caches them for reuse by subsequent calls. It uses HTTP proxies as directed by the environment variables HTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions thereof).\n\nNewFileTransport returns a new RoundTripper, serving the provided FileSystem. The returned RoundTripper ignores the URL host in its incoming requests, as well as most other properties of the request.\n\nThe typical use case for NewFileTransport is to register the \"file\" protocol with a Transport, as in:\n\nNewFileTransportFS returns a new RoundTripper, serving the provided file system fsys. The returned RoundTripper ignores the URL host in its incoming requests, as well as most other properties of the request. The files provided by fsys must implement io.Seeker.\n\nThe typical use case for NewFileTransportFS is to register the \"file\" protocol with a Transport, as in:\n\nSameSite allows a server to define a cookie attribute making it impossible for the browser to send this cookie along with cross-site requests. The main goal is to mitigate the risk of cross-origin information leakage, and provide some protection against cross-site request forgery attacks.\n\nServeMux is an HTTP request multiplexer. It matches the URL of each incoming request against a list of registered patterns and calls the handler for the pattern that most closely matches the URL.\n\nPatterns can match the method, host and path of a request. Some examples:\n• \"/index.html\" matches the path \"/index.html\" for any host and method.\n• \"GET /static/\" matches a GET request whose path begins with \"/static/\".\n• \"example.com/\" matches any request to the host \"example.com\".\n• \"/b/{bucket}/o/{objectname...}\" matches paths whose first segment is \"b\" and whose third segment is \"o\". The name \"bucket\" denotes the second segment and \"objectname\" denotes the remainder of the path.\n\nIn general, a pattern looks like\n\nAll three parts are optional; \"/\" is a valid pattern. If METHOD is present, it must be followed by at least one space or tab.\n\nLiteral (that is, non-wildcard) parts of a pattern match the corresponding parts of a request case-sensitively.\n\nA pattern with no method matches every method. A pattern with the method GET matches both GET and HEAD requests. Otherwise, the method must match exactly.\n\nA pattern with no host matches every host. A pattern with a host matches URLs on that host only.\n\nA path can include wildcard segments of the form {NAME} or {NAME...}. For example, \"/b/{bucket}/o/{objectname...}\". The wildcard name must be a valid Go identifier. Wildcards must be full path segments: they must be preceded by a slash and followed by either a slash or the end of the string. For example, \"/b_{bucket}\" is not a valid pattern.\n\nNormally a wildcard matches only a single path segment, ending at the next literal slash (not %2F) in the request URL. But if the \"...\" is present, then the wildcard matches the remainder of the URL path, including slashes. (Therefore it is invalid for a \"...\" wildcard to appear anywhere but at the end of a pattern.) The match for a wildcard can be obtained by calling Request.PathValue with the wildcard's name. A trailing slash in a path acts as an anonymous \"...\" wildcard.\n\nThe special wildcard {$} matches only the end of the URL. For example, the pattern \"/{$}\" matches only the path \"/\", whereas the pattern \"/\" matches every path.\n\nFor matching, both pattern paths and incoming request paths are unescaped segment by segment. So, for example, the path \"/a%2Fb/100%25\" is treated as having two segments, \"a/b\" and \"100%\". The pattern \"/a%2fb/\" matches it, but the pattern \"/a/b/\" does not.\n\nIf two or more patterns match a request, then the most specific pattern takes precedence. A pattern P1 is more specific than P2 if P1 matches a strict subset of P2’s requests; that is, if P2 matches all the requests of P1 and more. If neither is more specific, then the patterns conflict. There is one exception to this rule, for backwards compatibility: if two patterns would otherwise conflict and one has a host while the other does not, then the pattern with the host takes precedence. If a pattern passed to ServeMux.Handle or ServeMux.HandleFunc conflicts with another pattern that is already registered, those functions panic.\n\nAs an example of the general rule, \"/images/thumbnails/\" is more specific than \"/images/\", so both can be registered. The former matches paths beginning with \"/images/thumbnails/\" and the latter will match any other path in the \"/images/\" subtree.\n\nAs another example, consider the patterns \"GET /\" and \"/index.html\": both match a GET request for \"/index.html\", but the former pattern matches all other GET and HEAD requests, while the latter matches any request for \"/index.html\" that uses a different method. The patterns conflict.\n\nConsider a ServeMux with a handler for a subtree, registered using a trailing slash or \"...\" wildcard. If the ServeMux receives a request for the subtree root without a trailing slash, it redirects the request by adding the trailing slash. This behavior can be overridden with a separate registration for the path without the trailing slash or \"...\" wildcard. For example, registering \"/images/\" causes ServeMux to redirect a request for \"/images\" to \"/images/\", unless \"/images\" has been registered separately.\n\nServeMux also takes care of sanitizing the URL request path and the Host header, stripping the port number and redirecting any request containing . or .. segments or repeated slashes to an equivalent, cleaner URL. Escaped path elements such as \"%2e\" for \".\" and \"%2f\" for \"/\" are preserved and aren't considered separators for request routing.\n\nThe pattern syntax and matching behavior of ServeMux changed significantly in Go 1.22. To restore the old behavior, set the GODEBUG environment variable to \"httpmuxgo121=1\". This setting is read once, at program startup; changes during execution will be ignored.\n• Wildcards are just ordinary literal path segments in 1.21. For example, the pattern \"/{x}\" will match only that path in 1.21, but will match any one-segment path in 1.22.\n• In 1.21, no pattern was rejected, unless it was empty or conflicted with an existing pattern. In 1.22, syntactically invalid patterns will cause ServeMux.Handle and ServeMux.HandleFunc to panic. For example, in 1.21, the patterns \"/{\" and \"/a{x}\" match themselves, but in 1.22 they are invalid and will cause a panic when registered.\n• In 1.22, each segment of a pattern is unescaped; this was not done in 1.21. For example, in 1.22 the pattern \"/%61\" matches the path \"/a\" (\"%61\" being the URL escape sequence for \"a\"), but in 1.21 it would match only the path \"/%2561\" (where \"%25\" is the escape for the percent sign).\n• When matching patterns to paths, in 1.22 each segment of the path is unescaped; in 1.21, the entire path is unescaped. This change mostly affects how paths with %2F escapes adjacent to slashes are treated. See https://go.dev/issue/21955 for details.\n\nHandle registers the handler for the given pattern. If the given pattern conflicts, with one that is already registered, Handle panics.\n\nHandleFunc registers the handler function for the given pattern. If the given pattern conflicts, with one that is already registered, HandleFunc panics.\n\nHandler returns the handler to use for the given request, consulting r.Method, r.Host, and r.URL.Path. It always returns a non-nil handler. If the path is not in its canonical form, the handler will be an internally-generated handler that redirects to the canonical path. If the host contains a port, it is ignored when matching handlers.\n\nThe path and host are used unchanged for CONNECT requests.\n\nHandler also returns the registered pattern that matches the request or, in the case of internally-generated redirects, the path that will match after following the redirect.\n\nIf there is no registered handler that applies to the request, Handler returns a “page not found” handler and an empty pattern.\n\nServeHTTP dispatches the request to the handler whose pattern most closely matches the request URL.\n\nA Server defines parameters for running an HTTP server. The zero value for Server is a valid configuration.\n\nClose immediately closes all active net.Listeners and any connections in state StateNew, StateActive, or StateIdle. For a graceful shutdown, use Server.Shutdown.\n\nClose does not attempt to close (and does not even know about) any hijacked connections, such as WebSockets.\n\nClose returns any error returned from closing the Server's underlying Listener(s).\n\nListenAndServe listens on the TCP network address s.Addr and then calls Serve to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.\n\nIf s.Addr is blank, \":http\" is used.\n\nListenAndServe always returns a non-nil error. After Server.Shutdown or Server.Close, the returned error is ErrServerClosed.\n\nListenAndServeTLS listens on the TCP network address s.Addr and then calls ServeTLS to handle requests on incoming TLS connections. Accepted connections are configured to enable TCP keep-alives.\n\nFilenames containing a certificate and matching private key for the server must be provided if neither the Server's TLSConfig.Certificates nor TLSConfig.GetCertificate are populated. If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate, any intermediates, and the CA's certificate.\n\nIf s.Addr is blank, \":https\" is used.\n\nListenAndServeTLS always returns a non-nil error. After Server.Shutdown or Server.Close, the returned error is ErrServerClosed.\n\nRegisterOnShutdown registers a function to call on Server.Shutdown. This can be used to gracefully shutdown connections that have undergone ALPN protocol upgrade or that have been hijacked. This function should start protocol-specific graceful shutdown, but should not wait for shutdown to complete.\n\nServe accepts incoming connections on the Listener l, creating a new service goroutine for each. The service goroutines read requests and then call s.Handler to reply to them.\n\nHTTP/2 support is only enabled if the Listener returns *tls.Conn connections and they were configured with \"h2\" in the TLS Config.NextProtos.\n\nServe always returns a non-nil error and closes l. After Server.Shutdown or Server.Close, the returned error is ErrServerClosed.\n\nServeTLS accepts incoming connections on the Listener l, creating a new service goroutine for each. The service goroutines perform TLS setup and then read requests, calling s.Handler to reply to them.\n\nFiles containing a certificate and matching private key for the server must be provided if neither the Server's TLSConfig.Certificates, TLSConfig.GetCertificate nor config.GetConfigForClient are populated. If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate, any intermediates, and the CA's certificate.\n\nServeTLS always returns a non-nil error. After Server.Shutdown or Server.Close, the returned error is ErrServerClosed.\n\nSetKeepAlivesEnabled controls whether HTTP keep-alives are enabled. By default, keep-alives are always enabled. Only very resource-constrained environments or servers in the process of shutting down should disable them.\n\nShutdown gracefully shuts down the server without interrupting any active connections. Shutdown works by first closing all open listeners, then closing all idle connections, and then waiting indefinitely for connections to return to idle and then shut down. If the provided context expires before the shutdown is complete, Shutdown returns the context's error, otherwise it returns any error returned from closing the Server's underlying Listener(s).\n\nWhen Shutdown is called, Serve, ListenAndServe, and ListenAndServeTLS immediately return ErrServerClosed. Make sure the program doesn't exit and waits instead for Shutdown to return.\n\nShutdown does not attempt to close nor wait for hijacked connections such as WebSockets. The caller of Shutdown should separately notify such long-lived connections of shutdown and wait for them to close, if desired. See Server.RegisterOnShutdown for a way to register shutdown notification functions.\n\nOnce Shutdown has been called on a server, it may not be reused; future calls to methods such as Serve will return ErrServerClosed.\n\nTransport is an implementation of RoundTripper that supports HTTP, HTTPS, and HTTP proxies (for either HTTP or HTTPS with CONNECT).\n\nBy default, Transport caches connections for future re-use. This may leave many open connections when accessing many hosts. This behavior can be managed using Transport.CloseIdleConnections method and the [Transport.MaxIdleConnsPerHost] and [Transport.DisableKeepAlives] fields.\n\nTransports should be reused instead of created as needed. Transports are safe for concurrent use by multiple goroutines.\n\nA Transport is a low-level primitive for making HTTP and HTTPS requests. For high-level functionality, such as cookies and redirects, see Client.\n\nTransport uses HTTP/1.1 for HTTP URLs and either HTTP/1.1 or HTTP/2 for HTTPS URLs, depending on whether the server supports HTTP/2, and how the Transport is configured. The DefaultTransport supports HTTP/2. To explicitly enable HTTP/2 on a transport, set [Transport.Protocols].\n\nResponses with status codes in the 1xx range are either handled automatically (100 expect-continue) or ignored. The one exception is HTTP status code 101 (Switching Protocols), which is considered a terminal status and returned by Transport.RoundTrip. To see the ignored 1xx responses, use the httptrace trace package's ClientTrace.Got1xxResponse.\n\nTransport only retries a request upon encountering a network error if the connection has been already been used successfully and if the request is idempotent and either has no body or has its [Request.GetBody] defined. HTTP requests are considered idempotent if they have HTTP methods GET, HEAD, OPTIONS, or TRACE; or if their Header map contains an \"Idempotency-Key\" or \"X-Idempotency-Key\" entry. If the idempotency key value is a zero-length slice, the request is treated as idempotent but the header is not sent on the wire.\n\nCancelRequest cancels an in-flight request by closing its connection. CancelRequest should only be called after Transport.RoundTrip has returned.\n\nDeprecated: Use Request.WithContext to create a request with a cancelable context instead. CancelRequest cannot cancel HTTP/2 requests. This may become a no-op in a future release of Go.\n\nCloseIdleConnections closes any connections which were previously connected from previous requests but are now sitting idle in a \"keep-alive\" state. It does not interrupt any connections currently in use.\n\nRegisterProtocol registers a new protocol with scheme. The Transport will pass requests using the given scheme to rt. It is rt's responsibility to simulate HTTP request semantics.\n\nRegisterProtocol can be used by other packages to provide implementations of protocol schemes like \"ftp\" or \"file\".\n\nIf rt.RoundTrip returns ErrSkipAltProtocol, the Transport will handle the Transport.RoundTrip itself for that one request, as if the protocol were not registered.\n\nFor higher-level HTTP client support (such as handling of cookies and redirects), see Get, Post, and the Client type.\n\nLike the RoundTripper interface, the error types returned by RoundTrip are unspecified."
    },
    {
        "link": "https://github.com/ebitengine/oto",
        "document": "On some platforms you will need a C/C++ compiler in your path that Go can use.\n• iOS: On newer macOS versions type on your terminal and a dialog with installation instructions will appear if you don't have it\n• If you get an error with clang use xcode instead\n• Linux and other Unix systems: Should be installed by default, but if not try GCC or Clang\n\nOto requires , but this is automatically linked.\n\nAdd them to \"Linked Frameworks and Libraries\" on your Xcode project.\n\nALSA is required. On Ubuntu or Debian, run this command:\n\nIn most cases this command must be run by root user or through command.\n\nBSD systems are not tested well. If ALSA works, Oto should work.\n\nThe two main components of Oto are a and . The context handles interactions with the OS and audio drivers, and as such there can only be one context in your program.\n\nFrom a context you can create any number of different players, where each player is given an that it reads bytes representing sounds from and plays.\n\nNote that a single must not be used by multiple players.\n\nThe following is an example of loading and playing an MP3 file:\n\nmain ( ) () { , . ( ) { ( . ()) } // Convert the pure bytes into a reader object that can be used with the mp3 decoder . ( ) , . ( ) { ( . ()) } // Prepare an Oto context (this will use your default audio device) that will // play all our sounds. Its configuration can't be changed later. oto. {} // Usually 44100 or 48000. Other values might cause distortions in Oto . // Number of channels (aka locations) to play sounds from. Either 1 or 2. // 1 is mono sound, and 2 is stereo (most speakers are stereo). . // Format of the source. go-mp3's format is signed 16bit integers. . . // Remember that you should **not** create more than one context , , . ( ) { ( . ()) } // It might take a bit for the hardware audio devices to be ready, so we wait on the channel. // Create a new 'player' that will handle our sound. Paused by default. . ( ) // Play starts playing the sound and returns without waiting for it (Play() is async). . () // We can wait for the sound to finish playing using something like this . () { . ( . ) } // Now that the sound finished playing, we can restart from the beginning (or go to any location in the sound) using seek // println(\"Player is now at position:\", newPos) // If you don't want the player/sound anymore simply close . () { ( . ()) } }\n\nThe above example loads the entire file into memory and then plays it. This is great for smaller files but might be an issue if you are playing a long song since it would take too much memory and too long to load.\n\nIn such cases you might want to stream the file. Luckily this is very simple, just use :\n\nmain ( ) () { // Open the file for reading. Do NOT close before you finish playing! , . ( ) { ( . ()) } // Decode file. This process is done as the file plays so it won't // load the whole thing into memory. , . ( ) { ( . ()) } // Close file only after you finish playing . () }\n\nThe only thing to note about streaming is that the file object must be kept alive, otherwise you might just play static.\n\nTo keep it alive not only must you be careful about when you close it, but you might need to keep a reference to the original file object alive (by for example keeping it in a struct).\n\nPlayers have their own internal audio data buffer, so while for example 200 bytes have been read from the that doesn't mean they were all played from the audio device.\n\nData is moved from io.Reader->internal buffer->audio device, and when the internal buffer moves data to the audio device is not guaranteed, so there might be a small delay. The amount of data in the buffer can be retrieved using .\n\nThe size of the underlying buffer of a player can also be set by type-asserting the player object:\n\nThis works because players implement a interface and a interface.\n\nCrosscompiling to macOS or Windows is as easy as setting or , respectively.\n\nTo crosscompile for other platforms, make sure the libraries for the target architecture are installed, and set as Go disables Cgo on crosscompiles by default."
    },
    {
        "link": "https://pkg.go.dev/github.com/ebitengine/oto/v3",
        "document": "On some platforms you will need a C/C++ compiler in your path that Go can use.\n• iOS: On newer macOS versions type on your terminal and a dialog with installation instructions will appear if you don't have it\n• If you get an error with clang use xcode instead\n• Linux and other Unix systems: Should be installed by default, but if not try GCC or Clang\n\nOto requires , but this is automatically linked.\n\nAdd them to \"Linked Frameworks and Libraries\" on your Xcode project.\n\nALSA is required. On Ubuntu or Debian, run this command:\n\nIn most cases this command must be run by root user or through command.\n\nBSD systems are not tested well. If ALSA works, Oto should work.\n\nThe two main components of Oto are a and . The context handles interactions with the OS and audio drivers, and as such there can only be one context in your program.\n\nFrom a context you can create any number of different players, where each player is given an that it reads bytes representing sounds from and plays.\n\nNote that a single must not be used by multiple players.\n\nThe following is an example of loading and playing an MP3 file:\n\nThe above example loads the entire file into memory and then plays it. This is great for smaller files but might be an issue if you are playing a long song since it would take too much memory and too long to load.\n\nIn such cases you might want to stream the file. Luckily this is very simple, just use :\n\nThe only thing to note about streaming is that the file object must be kept alive, otherwise you might just play static.\n\nTo keep it alive not only must you be careful about when you close it, but you might need to keep a reference to the original file object alive (by for example keeping it in a struct).\n\nPlayers have their own internal audio data buffer, so while for example 200 bytes have been read from the that doesn't mean they were all played from the audio device.\n\nData is moved from io.Reader->internal buffer->audio device, and when the internal buffer moves data to the audio device is not guaranteed, so there might be a small delay. The amount of data in the buffer can be retrieved using .\n\nThe size of the underlying buffer of a player can also be set by type-asserting the player object:\n\nThis works because players implement a interface and a interface.\n\nCrosscompiling to macOS or Windows is as easy as setting or , respectively.\n\nTo crosscompile for other platforms, make sure the libraries for the target architecture are installed, and set as Go disables Cgo on crosscompiles by default."
    },
    {
        "link": "https://dev.to/devfan/awesome-golang-audio-and-music-libraries-3lg1",
        "document": "Are you sure you want to hide this comment? It will become hidden in your post, but will still be visible via the comment's permalink."
    },
    {
        "link": "https://github.com/avelino/awesome-go",
        "document": "We use the Golang Bridge community Slack for instant communication, follow the form here to join.\n\nAwesome Go has no monthly fee, but we have employees who work hard to keep it running. With money raised, we can repay the effort of each person involved! You can see how we calculate our billing and distribution as it is open to the entire community. Want to be a supporter of the project click here.\n\nPlease take a quick gander at the contribution guidelines first. Thanks to all contributors; you rock!\n\nIf you see a package or project here that is no longer maintained or is not a good fit, please submit a pull request to improve this file. Thank you!\n• Ergo - An actor-based Framework with network transparency for creating event-driven architecture in Golang. Inspired by Erlang.\n• Goakt - Fast and Distributed Actor framework using protocol buffers as message for Golang.\n• ProtoActor - Proto Actor - Ultra fast distributed actors for Go, C# and Java/Kotlin.\n• chromem-go - Embeddable vector database for Go with Chroma-like interface and zero third-party dependencies. In-memory with optional persistence.\n• fun - The simplest but powerful way to use large language models (LLMs) in Go.\n• langchaingo - LangChainGo is a framework for developing applications powered by language models.\n• flac - Native Go FLAC encoder/decoder with support for FLAC streams.\n• id3v2 - ID3 decoding and encoding library for Go.\n• PortAudio - Go bindings for the PortAudio audio I/O library.\n• authboss - Modular authentication system for the web. It tries to remove as much boilerplate and \"hard things\" as possible so that each time you start a new web project in Go, you can plug it in, configure it, and start building your app without having to build an authentication system each time.\n• casbin - Authorization library that supports access control models like ACL, RBAC, and ABAC.\n• go-guardian - Go-Guardian is a golang library that provides a simple, clean, and idiomatic way to create powerful modern API and web authentication that supports LDAP, Basic, Bearer token, and Certificate based authentication.\n• go-jose - Fairly complete implementation of the JOSE working group's JSON Web Token, JSON Web Signatures, and JSON Web Encryption specs.\n• goiabada - An open-source authentication and authorization server supporting OAuth2 and OpenID Connect.\n• gologin - chainable handlers for login with OAuth1 and OAuth2 authentication providers.\n• gosession - This is quick session for net/http in GoLang. This package is perhaps the best implementation of the session mechanism, or at least it tries to become one.\n• goth - provides a simple, clean, and idiomatic way to use OAuth and OAuth2. Handles multiple providers out of the box.\n• jwt - Safe, simple, and fast JSON Web Tokens for Go.\n• jwt-auth - JWT middleware for Golang http servers with many configuration options.\n• jwt-go - A full featured implementation of JSON Web Tokens (JWT). This library supports the parsing and verification as well as the generation and signing of JWTs.\n• jwx - Go module implementing various JWx (JWA/JWE/JWK/JWS/JWT, otherwise known as JOSE) technologies\n• keto - Open Source (Go) implementation of \"Zanzibar: Google's Consistent, Global Authorization System\". Ships gRPC, REST APIs, newSQL, and an easy and granular permission language. Supports ACL, RBAC, and other access models.\n• loginsrv - JWT login microservice with pluggable backends such as OAuth2 (Github), htpasswd, osiam.\n• oauth2 - Successor of goauth2. Generic OAuth 2.0 package that comes with JWT, Google APIs, Compute Engine, and App Engine support.\n• oidc - Easy to use OpenID Connect client and server library written for Go and certified by the OpenID Foundation\n• openfga - Implementation of fine-grained authorization based on the \"Zanzibar: Google's Consistent, Global Authorization System\" paper. Backed by CNCF.\n• otpgo - Time-Based One-Time Password (TOTP) and HMAC-Based One-Time Password (HOTP) library for Go.\n• permissions - Library for keeping track of users, login states, and permissions. Uses secure cookies and bcrypt.\n• session - Go session management for web servers (including support for Google App Engine - GAE).\n• cometbft - A distributed, Byzantine fault-tolerant, deterministic state machine replication engine. It is a fork of Tendermint Core and implements the Tendermint consensus algorithm.\n• cosmos-sdk - A Framework for Building Public Blockchains in the Cosmos Ecosystem.\n• gno - A comprehensive smart contract suite built with Golang and Gnolang, a deterministic, purpose-built Go variant for blockchains.\n• go-ethereum - Official Go implementation of the Ethereum protocol.\n• gossamer - A Go implementation of the Polkadot Host.\n• kubo - A blockchain framework implemented in Go. It provides content-addressable storage which can be used for decentralized storage in DApps. It is based on the IPFS protocol.\n• solana-go - Go library to interface with Solana JSON RPC and WebSocket interfaces.\n• tendermint - High-performance middleware for transforming a state machine written in any programming language into a Byzantine Fault Tolerant replicated state machine using the Tendermint consensus and blockchain protocols.\n\nLibraries for building and working with bots.\n• arikawa - A library and framework for the Discord API.\n• echotron - An elegant and concurrent library for Telegram Bots in Go.\n• go-joe - A general-purpose bot library inspired by Hubot but written in Go.\n• go-sarah - Framework to build a bot for desired chat services including LINE, Slack, Gitter, and more.\n• go-tg - Generated from official docs Go client library for accessing Telegram Bot API, with batteries for building complex bots included.\n• larry - Larry 🐦 is a really simple Twitter bot generator that tweets random repositories from Github built in Go.\n• slack-bot - Ready to use Slack Bot for lazy developers: Custom commands, Jenkins, Jira, Bitbucket, Github...\n• slacker - Easy to use framework to create Slack bots.\n• telebot - Telegram bot framework is written in Go.\n• Tenyks - Service oriented IRC bot using Redis and JSON for messaging.\n• wayback - A bot for Telegram, Mastodon, Slack, and other messaging platforms archives webpages.\n\nLibraries and tools help with build automation.\n• gaper - Builds and restarts a Go project when it crashes or some watched file changes.\n• gilbert - Build system and task runner for Go projects.\n• gob - Gradle/Maven like build tool for Go projects.\n• mage - Mage is a make/rake-like build tool using Go.\n• realize - Go build a system with file watchers and live to reload. Run, build and watch file changes with custom paths.\n• asciigraph - Go package to make lightweight ASCII line graph ╭┈╯ in command line apps with no other dependencies.\n• bubbletea - Go framework to build terminal apps, based on The Elm Architecture.\n• ctc - The non-invasive cross-platform terminal color library does not need to modify the Print method.\n• go-ataman - Go library for rendering ANSI colored text templates in terminals.\n• go-colortext - Go library for color output in terminals.\n• go-palette - Go library that provides elegant and convenient style definitions using ANSI colors. Fully compatible & wraps the fmt library for nice terminal layouts.\n• lipgloss - Declaratively define styles for color, format and layout in the terminal.\n• marker - Easiest way to match and mark strings for colorful terminal outputs.\n• progressbar - Basic thread-safe progress bar that works in every OS.\n• pterm - A library to beautify console output on every platform with many combinable components.\n• simpletable - Simple tables in a terminal with Go.\n• spinner - Go package to easily provide a terminal spinner with options.\n• termdash - Go terminal dashboard based on termbox-go and inspired by termui.\n• termui - Go terminal dashboard based on termbox-go and inspired by blessed-contrib.\n• uitable - Library to improve readability in terminal apps using tabular data.\n• yacspin - Yet Another CLi Spinner package, for working with terminal spinners.\n• acmd - Simple, useful, and opinionated CLI package in Go.\n• argv - Go library to split command line string as arguments array using the bash syntax.\n• climax - Alternative CLI with \"human face\", in spirit of Go command.\n• cmd - Extends the standard package to support sub commands and more in idiomatic way.\n• command-chain - A go library for configure and run command chains - such as pipelining in unix shells.\n• commandeer - Dev-friendly CLI apps: sets up flags, defaults, and usage based on struct fields and tags.\n• complete - Write bash completions in Go + Go command bash completion.\n• console Closed-loop application library for Cobra commands, with oh-my-posh prompts, and more.\n• getopt - An accurate Go , validated against the GNU libc implementation.\n• go-getoptions - Go option parser inspired by the flexibility of Perl’s GetOpt::Long.\n• kingpin - Command line and flag parser supporting sub commands (superseded by ; see below).\n• mcli - A minimal but very powerful cli library for Go.\n• mkideal/cli - Feature-rich and easy to use command-line package based on golang struct tags.\n• mow.cli - Go library for building CLI applications with sophisticated flag and argument parsing and validation.\n• readline - Shell library with modern and easy to use UI features.\n• sand - Simple API for creating interpreters and so much more.\n• sflags - Struct based flags generator for flag, urfave/cli, pflag, cobra, kingpin, and other libraries.\n• subcmd - Another approach to parsing and running subcommands. Works alongside the standard package.\n• teris-io/cli - Simple and complete API for building command line interfaces in Go.\n• urfave/cli - Simple, fast, and fun package for building command line apps in Go (formerly codegangsta/cli).\n• version - Collects and displays CLI version information in multiple formats along with upgrade notice.\n• wmenu - Easy to use menu structure for cli applications that prompt users to make choices.\n• cleanenv - Minimalistic configuration reader (from files, ENV, and wherever you want).\n• config - Cloud native application configuration. Bind ENV to structs in only two lines.\n• config - configure your app using file, environment variables, or flags in two lines of code\n• configuration - Library for initializing configuration structs from env variables, files, flags and 'default' tag.\n• configure - Provides configuration through multiple sources, including JSON, flags and environment variables.\n• configuro - opinionated configuration loading & validation framework from ENV and Files focused towards 12-Factor compliant applications.\n• confiq - Structured data format to config struct decoder library for Go - supporting multiple data formats\n• confita - Load configuration in cascade from multiple backends into a struct.\n• conflate - Library/tool to merge multiple JSON/YAML/TOML files from arbitrary URLs, validation against a JSON schema, and application of default values defined in the schema.\n• env - Parse environment variables to Go structs (with defaults).\n• env - An environment utility package with support for unmarshaling into structs\n• envyaml - Yaml with environment variables reader. it helps to have secrets as environment variable but load them configs as structured Yaml.\n• fig - Tiny library for reading configuration from a file and from environment variables (with validation & defaults).\n• go-array - A Go package that read or set data from map, slice or json.\n• go-aws-ssm - Go package that fetches parameters from AWS System Manager - Parameter Store.\n• go-cfg - The library provides a unified way to read configuration data into a structure from various sources, such as env, flags, and configuration files (.json, .yaml, .toml, .env).\n• go-conf - Simple library for application configuration based on annotated structs. It supports reading the configuration from environment variables, config files and command line parameters.\n• go-ini - A Go package that marshals and unmarshals INI-files.\n• go-ssm-config - Go utility for loading configuration parameters from AWS SSM (Parameter Store).\n• go-up - A simple configuration library with recursive placeholders resolution and no magic.\n• GoCfg - Config manager with Struct Tags based contracts, custom value providers, parsers, and documentation generation. Customizable yet simple.\n• godotenv - Go port of Ruby's dotenv library (Loads environment variables from ).\n• GoLobby/Config - GoLobby Config is a lightweight yet powerful configuration manager for the Go programming language.\n• gone/jconf - Modular JSON configuration. Keep your config structs along with the code they configure and delegate parsing to submodules without sacrificing full config serialization.\n• gonfig - Tag-based configuration parser which loads values from different providers into typesafe struct.\n• harvester - Harvester, a easy to use static and dynamic configuration package supporting seeding, env vars and Consul integration.\n• hocon - Configuration library for working with the HOCON(a human-friendly JSON superset) format, supports features like environment variables, referencing other values, comments and multiple files.\n• ini - Go package to read and write INI files.\n• joshbetz/config - Small configuration library for Go that parses environment variables, JSON files, and reloads automatically on SIGHUP.\n• kelseyhightower/envconfig - Go library for managing configuration data from environment variables.\n• koanf - Light weight, extensible library for reading config in Go applications. Built in support for JSON, TOML, YAML, env, command line.\n• konf - The simplest API for reading/watching config from file, env, flag and clouds (e.g. AWS, Azure, GCP).\n• konfig - Composable, observable and performant config handling for Go for the distributed processing era.\n• kong - Command-line parser with support for arbitrarily complex command-line structures and additional sources of configuration such as YAML, JSON, TOML, etc (successor to ).\n• onion - Layer based configuration for Go, Supports JSON, TOML, YAML, properties, etcd, env, and encryption using PGP.\n• xdg - Go implementation of the XDG Base Directory Specification and XDG user directories.\n• xdg - Cross platform package that follows the XDG Standard.\n• yamagiconf - The \"safe subset\" of YAML for Go configs.\n\nTools for help with continuous integration.\n• Bencher - A suite of continuous benchmarking tools designed to catch performance regressions in CI.\n• dot - A minimal, local first continuous integration system that uses Docker to run jobs concurrently in stages.\n• drone - Drone is a Continuous Integration platform built on Docker, written in Go.\n• go-beautiful-html-coverage - A GitHub Action to track code coverage in your pull requests, with a beautiful HTML preview, for free.\n• go-fuzz-action - Use Go 1.18's built-in fuzz testing in GitHub Actions.\n• go-test-coverage - Tool and GitHub action which reports issues when test coverage is below set threshold.\n• gomason - Test, Build, Sign, and Publish your go binaries from a clean workspace.\n• muffet - Fast website link checker in Go, see alternatives.\n• overalls - Multi-Package go project coverprofile for tools like goveralls.\n• woodpecker - Woodpecker is a community fork of the Drone CI system.\n• go-libsass - Go wrapper to the 100% Sass compatible libsass project.\n• omniparser - A versatile ETL library that parses text input (CSV/txt/JSON/XML/EDI/X12/EDIFACT/etc) in streaming fashion and transforms data into JSON output using data-driven schema.\n• crunch - Go package implementing buffers for handling various datatypes easily.\n• go-ef - A Go implementation of the Elias-Fano encoding.\n• bloomfilter - Yet another Bloomfilter implementation in Go, compatible with Java's Guava library.\n• cuckoo-filter - Cuckoo filter: a comprehensive cuckoo filter, which is configurable and space optimized compared with other implements, and all features mentioned in original paper are available.\n• cuckoofilter - Cuckoo filter: a good alternative to a counting bloom filter implemented in Go.\n• go-datastructures - Collection of useful, performant, and thread-safe data structures.\n• gostl - Data structure and algorithm library for go, designed to provide functions similar to C++ STL.\n• iter - Go implementation of C++ STL iterators and algorithms.\n\nSee also Database for more complex key-value stores, and Trees for additional ordered map implementations.\n• cmap - a thread-safe concurrent map for go, support using as key and auto scale up shards.\n• go-shelve - A persistent, map-like object for the Go programming language. Supports multiple embedded key-value stores.\n• goradd/maps - Go 1.18+ generic map interface for maps; safe maps; ordered maps; ordered, safe maps; etc.\n• count-min-log - Go implementation Count-Min-Log sketch: Approximately counting with approximate counters (Like Count-Min sketch but using less memory).\n• genfuncs - Go 1.18+ generics package inspired by Kotlin's Sequence and Map.\n• go-rampart - Determine how intervals relate to each other.\n• go18ds - Go Data Structures using Go 1.18 generics.\n• gota - Implementation of dataframes, series, and data wrangling methods for Go.\n• hide - ID type with marshalling to/from hash to prevent sending IDs to clients.\n• nan - Zero allocation Nullable structures in one library with handy conversion functions, marshallers and unmarshallers.\n• null - Nullable Go types that can be marshalled/unmarshalled to/from JSON.\n• typ - Null Types, Safe primitive type conversion and fetching value from complex structures.\n• memlog - An easy to use, lightweight, thread-safe and append-only in-memory data structure inspired by Apache Kafka.\n• golang-set - Thread-Safe and Non-Thread-Safe high-performance sets for Go.\n• goset - A useful Set collection implementation for Go.\n• set - Simple set data structure implementation in Go using LinkedHashMap.\n• go-edlib - Go string comparison and edit distance algorithms library (Levenshtein, LCS, Hamming, Damerau levenshtein, Jaro-Winkler, etc.) compatible with Unicode.\n• levenshtein - Levenshtein distance and similarity metrics with customizable edit costs and Winkler-like bonus for common prefix.\n• levenshtein - Implementation to calculate levenshtein distance in Go.\n• parsefields - Tools for parse JSON-like logs for collecting unique fields and events.\n• hashsplit - Split byte streams into chunks, and arrange chunks into trees, with boundaries determined by content, not position.\n• treemap - Generic key-sorted map using a red-black tree under the hood.\n• ordered-concurrently - Go module that processes work concurrently and returns output in a channel in the order of input.\n• parapipe - FIFO Pipeline which parallels execution on each stage while maintaining the order of messages and results.\n• pipeline - An implementation of pipelines with fan-in and fan-out.\n\nData stores with expiring records, in-memory distributed data stores, or in-memory subsets of file-based databases.\n• coherence-go-client - Full implementation of Oracle Coherence cache API for Go applications using gRPC as network transport.\n• GCache - Cache library with support for expirable Cache, LFU, LRU and ARC.\n• gdcache - A pure non-intrusive cache library implemented by golang, you can use it to implement your own distributed cache.\n• go-cache - A flexible multi-layer Go caching library to deal with in-memory and shared cache by adopting Cache-Aside pattern.\n• go-freelru A GC-less, fast and generic LRU hashmap library with optional locking, sharding, eviction and expiration.\n• gocache - A complete Go cache library with multiple stores (memory, memcache, redis, ...), chainable, loadable, metrics cache and more.\n• gocache - A data race free Go ache library with high performance and auto pruge functionality\n• groupcache - Groupcache is a caching and cache-filling library, intended as a replacement for memcached in many cases.\n• imcache - A generic in-memory cache Go library. It supports expiration, sliding expiration, max entries limit, eviction callbacks and sharding.\n• otter - A high performance lockless cache for Go. Many times faster than Ristretto and friends.\n• pocache - Pocache is a minimal cache package which focuses on a preemptive optimistic caching strategy.\n• sturdyc - A caching library with advanced concurrency features designed to make I/O heavy applications robust and highly performant.\n• theine - High performance, near optimal in-memory cache with proactive TTL expiration and generics.\n• ttlcache - An in-memory cache with item expiration and generics.\n• ttlcache - In-memory key value storage with TTL for each record.\n• bbolt - An embedded key/value database for Go.\n• Bitcask - Bitcask is an embeddable, persistent and fast key-value (KV) database written in pure Go with predictable read/write performance, low latency and high throughput thanks to the bitcask on-disk layout (LSM+WAL).\n• buntdb - Fast, embeddable, in-memory key/value database for Go with custom indexing and spatial support.\n• Databunker - Personally identifiable information (PII) storage service built to comply with GDPR and CCPA.\n• goleveldb - Implementation of the LevelDB key/value database in Go.\n• hare - A simple database management system that stores each table as a text file of line-delimited JSON.\n• immudb - immudb is a lightweight, high-speed immutable database for systems and applications written in Go.\n• ledisdb - Ledisdb is a high performance NoSQL like Redis based on LevelDB.\n• levigo - Levigo is a Go wrapper for LevelDB.\n• libradb - LibraDB is a simple database with less than 1000 lines of code for learning.\n• Milvus - Milvus is a vector database for embedding management, analytics and search.\n• moss - Moss is a simple LSM key-value storage engine written in 100% Go.\n• nutsdb - Nutsdb is a simple, fast, embeddable, persistent key/value store written in pure Go. It supports fully serializable transactions and many data structures such as list, set, sorted set.\n• tidb - TiDB is a distributed SQL database. Inspired by the design of Google F1.\n• unitdb - Fast timeseries database for IoT, realtime messaging applications. Access unitdb with pubsub over tcp or websocket using github.com/unit-io/unitd application.\n• Vasto - A distributed high-performance key-value store. On Disk. Eventual consistent. HA. Able to grow or shrink without service interruption.\n• VictoriaMetrics - fast, resource-effective and scalable open source time series database. May be used as long-term remote storage for Prometheus. Supports PromQL.\n• atlas - A Database Toolkit. A CLI designed to help companies better work with their data.\n• avro - Discover SQL schemas and convert them to AVRO schemas. Query SQL records into AVRO bytes.\n• go-pg-migrations - A Go package to help write migrations with go-pg/pg.\n• goavro - A Go package that encodes and decodes Avro data.\n• goose - Database migration tool. You can manage your database's evolution by creating incremental SQL or Go scripts.\n• libschema - Define your migrations separately in each library. Migrations for open source libraries. MySQL & PostgreSQL.\n• migrator - MySQL database migrator designed to run migrations to your features and manage database schema update with intuitive go code.\n• schema - Library to embed schema migrations for database/sql-compatible databases inside your Go binaries.\n• skeema - Pure-SQL schema management system for MySQL, with support for sharding and external online schema change tools.\n• soda - Database migration, creation, ORM, etc... for MySQL, PostgreSQL, and SQLite.\n• sql-migrate - Database migration tool. Allows embedding migrations into the application using go-bindata.\n• sqlize - Database migration generator. Allows generate sql migration from model and existing sql by differ them.\n• dbbench - Database benchmarking tool with support for several databases and scripts.\n• gatewayd - Cloud-native database gateway and framework for building data-driven applications. Like API gateways, for databases.\n• go-mysql - Go toolset to handle MySQL protocol and replication.\n• octillery - Go package for sharding databases ( Supports every ORM or raw SQL ).\n• onedump - Database backup from different drivers to different destinations with one command and configuration.\n• prep - Use prepared SQL statements without changing your code.\n• pREST - Simplify and accelerate development, ⚡ instant, realtime, high-performance on any Postgres application, existing or new.\n• vitess - vitess provides servers and tools which facilitate scaling of MySQL databases for large scale web services.\n• wescale - WeScale is a database proxy designed to enhance the scalability, performance, security, and resilience of your applications.\n\nLibraries for building and using SQL.\n• dbq - Zero boilerplate database operations for Go.\n• Dotsql - Go library that helps you keep sql files in one place and use them with ease.\n• godbal - Database Abstraction Layer (dbal) for go. Support SQL builder and get result easily.\n• igor - Abstraction layer for PostgreSQL that supports advanced functionality and uses gorm-like syntax.\n• jet - Framework for writing type-safe SQL queries in Go, with ability to easily convert database query result into desired arbitrary object structure.\n• ormlite - Lightweight package containing some ORM-like features and helpers for sqlite databases.\n• ozzo-dbx - Powerful data retrieval methods as well as DB-agnostic query building capabilities.\n• qry - Tool that generates constants from files with raw SQL queries.\n• sg - A SQL Gen for generating standard SQLs(supports: CRUD) written in Go.\n• sq - Type-safe SQL builder and struct mapper for Go.\n• sqlingo - A lightweight DSL to build SQL in Go.\n• Squalus - Thin layer over the Go SQL package that makes it easier to perform queries.\n• Squirrel - Go library that helps you build SQL queries.\n• xo - Generate idiomatic Go code for databases based on existing schema definitions or custom queries supporting PostgreSQL, MySQL, SQLite, Oracle, and Microsoft SQL Server.\n• dynamo - A simple key-value abstraction to store algebraic and linked-data data types at AWS storage services: AWS DynamoDB and AWS S3.\n• gokv - Simple key-value store abstraction and implementations for Go (Redis, Consul, etcd, bbolt, BadgerDB, LevelDB, Memcached, DynamoDB, S3, PostgreSQL, MongoDB, CockroachDB and many more).\n• bgc - Datastore Connectivity for BigQuery for go.\n• go-adodb - Microsoft ActiveX Object DataBase driver for go that uses database/sql.\n• go-oci8 - Oracle driver for go that uses database/sql.\n• go-sqlite3 - SQLite3 driver for go that uses database/sql.\n• go-sqlite3 - This Go module is compatible with the database/sql driver. It allows embedding SQLite into your application, provides direct access to its C API, supports SQLite VFS, and also includes a GORM driver.\n• godror - Oracle driver for Go, using the ODPI-C driver.\n• pgx - PostgreSQL driver supporting features beyond those exposed by database/sql.\n• sqlite - Package sqlite is a sql/database driver using a CGo-free port of the C SQLite3 library.\n• asc - Datastore Connectivity for Aerospike for go.\n• go-mongox - A Go Mongo library based on the official driver, featuring streamlined document operations, generic binding of structs to collections, built-in CRUD, aggregation, automated field updates, struct validation, hooks, and plugin-based programming.\n• go-rejson - Golang client for redislabs' ReJSON module using Redigo golang client. Store and manipulate structs as JSON objects in redis with ease.\n• godscache - A wrapper for the Google Cloud Platform Go Datastore package that adds caching using memcached.\n• gomemcache - memcache client library for the Go programming language.\n• gomemcached - A binary Memcached client for Go with support for sharding using consistent hashing, along with SASL.\n• Kivik - Kivik provides a common Go and GopherJS client library for CouchDB, PouchDB, and similar databases.\n• mgm - MongoDB model-based ODM for Go (based on official MongoDB driver).\n• mgo - (unmaintained) MongoDB driver for the Go language that implements a rich and well tested selection of features under a very simple API following standard Go idioms.\n• mongo-go-driver - Official MongoDB driver for the Go language.\n• qmgo - The MongoDB driver for Go. It‘s based on official MongoDB driver but easier to use like Mgo.\n• redigo - Redigo is a Go client for the Redis database.\n• clickhouse-go - ClickHouse SQL client for Go with a compatibility.\n• elasticsql - Convert sql to elasticsearch dsl in Go.\n• go-elasticsearch - Official Elasticsearch client for Go.\n• goes - Library to interact with Elasticsearch.\n\nLibraries for working with dates and times.\n• carbon - Simple Time extension with a lot of util methods, ported from PHP Carbon library.\n• cronrange - Parses Cron-style time range expressions, checks if the given time is within any ranges.\n• date - Augments Time for working with dates, date ranges, time spans, periods, and time-of-day.\n• feiertage - Set of functions to calculate public holidays in Germany, incl. specialization on the states of Germany (Bundesländer). Things like Easter, Pentecost, Thanksgiving...\n• go-anytime - Parse dates/times like \"next dec 22nd at 3pm\" and ranges like \"from today until next thursday\" without knowing the format in advance.\n• go-persian-calendar - The implementation of the Persian (Solar Hijri) Calendar in Go (golang).\n• go-str2duration - Convert string to duration. Support time.Duration returned string and more.\n• go-sunrise - Calculate the sunrise and sunset times for a given location.\n• go-week - An efficient package to work with ISO8601 week dates.\n• gostradamus - A Go package for working with dates.\n• now - Now is a time toolkit for golang.\n• timespan - For interacting with intervals of time, defined as a start time and a duration.\n• timeutil - Useful extensions (Timedelta, Strftime, ...) to the golang's time package.\n\nPackages that help with building Distributed Systems.\n• bedrock - Provides a minimal, modular and composable foundation for quickly developing services and more use case specific frameworks in Go.\n• celeriac - Library for adding support for interacting and monitoring Celery workers, tasks and events in Go.\n• dragonboat - A feature complete and high performance multi-group Raft library in Go.\n• Dragonfly - Provide efficient, stable and secure file distribution and image acceleration based on p2p technology to be the best practice and standard solution in cloud native architectures.\n• drmaa - Job submission library for cluster schedulers based on the DRMAA standard.\n• dynatomic - A library for using DynamoDB as an atomic counter.\n• emitter-io - High performance, distributed, secure and low latency publish-subscribe platform built with MQTT, Websockets and love.\n• gleam - Fast and scalable distributed map/reduce system written in pure Go and Luajit, combining Go's high concurrency with Luajit's high performance, runs standalone or distributed.\n• glow - Easy-to-Use scalable distributed big data processing, Map-Reduce, DAG execution, all in pure Go.\n• go-doudou - A gossip protocol and OpenAPI 3.0 spec based decentralized microservice framework. Built-in go-doudou cli focusing on low-code and rapid dev can power up your productivity.\n• go-eagle - A Go framework for the API or Microservice with handy scaffolding tools.\n• go-health - Library for enabling asynchronous dependency health checks in your service.\n• go-kit - Microservice toolkit with support for service discovery, load balancing, pluggable transports, request tracking, etc.\n• go-sundheit - A library built to provide support for defining async service health checks for golang services.\n• go-zero - A web and rpc framework. It's born to ensure the stability of the busy sites with resilient design. Builtin goctl greatly improves the development productivity.\n• grpc-go - The Go language implementation of gRPC. HTTP/2 based RPC.\n• Kitex - A high-performance and strong-extensibility Golang RPC framework that helps developers build microservices. If the performance and extensibility are the main concerns when you develop microservices, Kitex can be a good choice.\n• Kratos - A modular-designed and easy-to-use microservices framework in Go.\n• micro - A distributed systems runtime for the cloud and beyond.\n• NATS - NATS is a simple, secure, and performant communications system for digital systems, services, and devices.\n• outboxer - Outboxer is a go library that implements the outbox pattern.\n• raft - Golang implementation of the Raft consensus protocol, by HashiCorp.\n• raft - Go implementation of the Raft consensus protocol, by CoreOS.\n• resgate - Realtime API Gateway for building REST, real time, and RPC APIs, where all clients are synchronized seamlessly.\n• sleuth - Library for master-less p2p auto-discovery and RPC between HTTP services (using ZeroMQ).\n• Tarmac - Framework for writing functions, microservices, or monoliths with WebAssembly\n• trpc-go - The Go language implementation of tRPC, which is a pluggable, high-performance RPC framework.\n• dyndns - Background Go process to regularly and automatically check your IP Address and make updates to (one or many) Dynamic DNS records for Google domains whenever your address changes.\n\nLibraries and tools that implement email creation and sending.\n• email - A robust and flexible email library for Go.\n• email-verifier - A Go library for email verification without sending any emails.\n• go-mail - A simple Go library for sending mails in Go.\n• go-message - Streaming library for the Internet Message Format and mail messages.\n• go-premailer - Inline styling for HTML mail in Go.\n• go-simple-mail - Very simple package to send emails with SMTP Keep Alive and two timeouts: Connect and Send.\n• mailchain - Send encrypted emails to blockchain addresses written in Go.\n• mailgun-go - Go library for sending mail with the Mailgun API.\n• MailHog - Email and SMTP testing with web and API interface.\n• mailx - Mailx is a library that makes it easier to send email via SMTP. It is an enhancement of the golang standard library .\n• smtpmock - Lightweight configurable multithreaded fake SMTP server. Mimic any SMTP behaviour for your test environment.\n• truemail-go - Configurable Golang email validator/verifier. Verify email via Regex, DNS, SMTP and even more.\n\nEmbedding other languages inside your go code.\n• binder - Go to Lua binding library, based on gopher-lua.\n• go-lua - Port of the Lua 5.2 VM to pure Go.\n• go-python - naive go bindings to the CPython C-API.\n• golua - Go bindings for Lua C API.\n• gopher-lua - Lua 5.1 VM and compiler written in Go.\n• metacall - Cross-platform Polyglot Runtime which supports NodeJS, JavaScript, TypeScript, Python, Ruby, C#, WebAssembly, Java, Cobol and more.\n• starlark-go - Go implementation of Starlark: Python-like language with deterministic evaluation and hermetic execution.\n• starlet - Go wrapper for starlark-go that simplifies script execution, offers data conversion, and useful Starlark libraries and extensions.\n• Wa/凹语言 - The Wa Programming Language embedded in Go.\n• emperror - Error handling tools and best practices for Go libraries and applications.\n• eris - A better way to handle, trace, and log errors in Go. Compatible with the standard error library and github.com/pkg/errors.\n• errlog - Hackable package that determines responsible source code for an error (and some other fast-debugging features). Pluggable to any logger in-place.\n• errors - Drop-in replacement for the standard library errors package and github.com/pkg/errors. Provides various error handling primitives.\n• errors - The most simple error wrapper with awesome performance and minimal memory overhead.\n• errors - Providing errors with a stack trace and optional structured details. Compatible with github.com/pkg/errors API but does not use it internally.\n• errors - Drop-in replacement for builtin Go errors. This is a minimal error handling package with custom error types, user friendly messages, Unwrap & Is. With very easy to use and straightforward helper functions.\n• errors - Go error library with error portability over the network.\n• errorx - A feature rich error package with stack traces, composition of errors and more.\n• exception - A simple utility package for exception handling with try-catch in Golang.\n• Fault - An ergonomic mechanism for wrapping errors in order to facilitate structured metadata and context for error values.\n• go-multierror - Go (golang) package for representing a list of errors as a single error.\n• multierr - Package for representing a list of errors as a single error.\n• checksum - Compute message digest, like MD5, SHA256, SHA1, CRC or BLAKE2s, for large files.\n• flop - File operations library which aims to mirror feature parity with GNU cp.\n• go-exiftool - Go bindings for ExifTool, the well-known library used to extract as much metadata as possible (EXIF, IPTC, ...) from files (pictures, PDF, office, ...).\n• go-wkhtmltopdf - A package to convert an HTML template to a PDF file.\n• gofs - A cross-platform real-time file synchronization tool out of the box.\n• gulter - A simple HTTP middleware to automatically handle all your file upload needs\n• gut/yos - Simple and reliable package for file operations like copy/move/diff/list on files, directories and symbolic links.\n• higgs - A tiny cross-platform Go library to hide/unhide files and directories.\n• pathtype - Treat paths as their own type instead of using strings.\n• skywalker - Package to allow one to concurrently go through a filesystem with ease.\n• todotxt - Go library for Gina Trapani's todo.txt files, supports parsing and manipulating of task lists in the todo.txt format.\n• vfs - A pluggable, extensible, and opinionated set of filesystem functionality for Go across a number of filesystem types such as os, S3, and GCS.\n• bbgo - A crypto trading bot framework written in Go. Including common crypto exchange API, standard indicators, back-testing and many built-in strategies.\n• fpdecimal - Fast and precise serialization and arithmetic for small fixed-point decimals\n• go-finance - Library of financial functions for time value of money (annuities), cash flow, interest rate conversions, bonds and depreciation calculations.\n• go-finance - Module to fetch exchange rates, check VAT numbers via VIES and check IBAN bank account numbers.\n• go-finnhub - Client for stock market, forex and crypto data from finnhub.io. Access real-time financial market data from 60+ stock exchanges, 10 forex brokers, and 15+ crypto exchanges.\n• ledger - A programmable financial ledger that provides a foundation for money-moving applications.\n• ofxgo - Query OFX servers and/or parse the responses (with example command-line client).\n• sleet - One unified interface for multiple Payment Service Providers (PsP) to process online payment.\n• swift - Offline validity check of IBAN (International Bank Account Number) and retrieval of BIC (for some countries).\n• udecimal - High performance, high precision, zero allocation fixed-point decimal library for financial applications.\n• bind - Bind form data to any Go values.\n• checker - Checker helps validating user input through rules defined in struct tags or directly through functions.\n• conform - Keeps user input in check. Trims, sanitizes & scrubs data based on struct tags.\n• form - Decodes url.Values into Go value(s) and Encodes Go value(s) into url.Values. Dual Array and Full map support.\n• forms - Framework-agnostic library for parsing and validating form/JSON data which supports multipart forms and files.\n• gbind - Bind data to any Go value. Can use built-in and custom expression binding capabilities; supports data validation\n• httpin - Decode an HTTP request into a custom struct, including querystring, forms, HTTP headers, etc.\n• qs - Go module for encoding structs into URL query parameters.\n• queryparam - Decode into usable struct values of standard or custom types.\n\nPackages to support functional programming in Go.\n• go-functional - Functional programming in Go using generics\n• go-underscore - Useful collection of helpfully functional Go collection utilities.\n• mo - Monads and popular FP abstractions, based on Go 1.18+ Generics (Option, Result, Either...).\n• underscore - Functional programming helpers for Go 1.18 and beyond.\n• valor - Generic option and result types that optionally contain a value.\n• ecs - Build your own Game-Engine based on the Entity Component System concept in Golang.\n• engo - Engo is an open-source 2D game engine written in Go. It follows the Entity-Component-System paradigm.\n• go-astar - Go implementation of the A* path finding algorithm.\n• go-sdl2 - Go bindings for the Simple DirectMedia Layer.\n• Harfang3D - 3D engine for the Go language, works on Windows and Linux (Harfang on Go.dev).\n• Pitaya - Scalable game server framework with clustering support and client libraries for iOS, Android, Unity and others through the C SDK.\n• raylib-go - Go bindings for raylib, a simple and easy-to-use library to learn videogames programming.\n• termloop - Terminal-based game engine for Go, built on top of Termbox.\n• copygen - Generate any code based on Go types, including type-to-type converters (copy code) without reflection by default.\n• GoWrap - Generate decorators for Go interfaces using simple templates.\n• oapi-codegen - This package contains a set of utilities for generating Go boilerplate code for services based on OpenAPI 3.0 API definitions.\n• geoserver - geoserver Is a Go Package For Manipulating a GeoServer Instance via the GeoServer REST API.\n• gismanager - Publish Your GIS Data(Vector Data) to PostGIS and Geoserver.\n• osm - Library for reading, writing and working with OpenStreetMap data and APIs.\n• S2 geojson - Convert geojson to s2 cells & demonstrating some S2 geometry features on map.\n• simplefeatures - simplesfeatures is a 2D geometry library that provides Go types that model geometries, as well as algorithms that operate on them.\n• Web-Mercator-Projection A project to easily use and convert LonLat, Point and Tile to display info, markers, etc, in a map using the Web Mercator Projection.\n\nTools for compiling Go to other languages and vice-versa.\n• c4go - Transpile C code to Go code.\n• go2hx - Compiler from Go to Haxe to Javascript/C++/Java/C#.\n• gopherjs - Compiler from Go to JavaScript.\n\nTools for managing and working with Goroutines.\n• ants - A high-performance and low-cost goroutine pool in Go.\n• async - An asynchronous task package with async/await style for Go.\n• async - An alternative sync library for Go (Future, Promise, Locks).\n• async - A safe way to execute functions asynchronously, recovering them in case of panic.\n• async-job - AsyncJob is an asynchronous queue job manager with light code, clear and speed.\n• channelify - Transform your function to return channels for easy and powerful parallel processing.\n• conc - is your toolbelt for structured concurrency in go, making common tasks easier and safer.\n• concurrency-limiter - Concurrency limiter with support for timeouts, dynamic priority and context cancellation of goroutines.\n• conexec - A concurrent toolkit to help execute funcs concurrently in an efficient and safe way. It supports specifying the overall timeout to avoid blocking and uses goroutine pool to improve efficiency.\n• execpool - A pool built around exec.Cmd that spins up a given number of processes in advance and attaches stdin and stdout to them when needed. Very similar to FastCGI or Apache Prefork MPM but works for any command.\n• go-accumulator - Solution for accumulation of events and their subsequent processing.\n• go-tools/multithreading - Manage a pool of goroutines using this lightweight library with a simple API.\n• go-waitgroup - Like with error handling and concurrency control.\n• go-workerpool - Inspired from Java Thread Pool, Go WorkerPool aims to control heavy Go Routines.\n• goccm - Go Concurrency Manager package limits the number of goroutines that allowed to run concurrently.\n• gohive - A highly performant and easy to use Goroutine pool for Go.\n• gollback - asynchronous simple function utilities, for managing execution of closures and callbacks.\n• gowl - Gowl is a process management and process monitoring tool at once. An infinite worker pool gives you the ability to control the pool and processes and monitor their status.\n• hands - A process controller used to control the execution and return strategies of multiple goroutines.\n• Hunch - Hunch provides functions like: , , , etc., that makes asynchronous flow control more intuitive.\n• kyoo - Provides an unlimited job queue and concurrent worker pools.\n• neilotoole/errgroup - Drop-in alternative to , limited to a pool of N worker goroutines.\n• oversight - Oversight is a complete implementation of the Erlang supervision trees.\n• pond - Minimalistic and High-performance goroutine worker pool written in Go.\n• pool - Limited consumer goroutine or unlimited goroutine pool for easier goroutine handling and cancellation.\n• routine - is a for go library. It encapsulates and provides some easy-to-use, non-competitive, high-performance context access interfaces, which can help you access coroutine context information more gracefully.\n• routine - go routine control with context, support: Main, Go, Pool and some useful Executors.\n• semaphore - Semaphore pattern implementation with timeout of lock/unlock operations based on channel and context.\n• workerpool - Goroutine pool that limits the concurrency of task execution, not the number of tasks queued.\n• app - Package to create apps with GO, HTML and CSS. Supports: MacOS, Windows in progress.\n• cimgui-go - Auto generated Go wrapper for Dear ImGui via cimgui.\n• Cogent Core - A framework for building 2D and 3D apps that run on macOS, Windows, Linux, iOS, Android, and the web.\n• fyne - Cross platform native GUIs designed for Go based on Material Design. Supports: Linux, macOS, Windows, BSD, iOS and Android.\n• gio - Gio is a library for writing cross-platform immediate mode GUI-s in Go. Gio supports all the major platforms: Linux, macOS, Windows, Android, iOS, FreeBSD, OpenBSD and WebAssembly.\n• go-sciter - Go bindings for Sciter: the Embeddable HTML/CSS/script engine for modern desktop UI development. Cross platform.\n• gowd - Rapid and simple desktop UI development with GO, HTML, CSS and NW.js. Cross platform.\n• qt - Qt binding for Go (support for Windows / macOS / Linux / Android / iOS / Sailfish OS / Raspberry Pi).\n• unison - A unified graphical user experience toolkit for Go desktop applications. macOS, Windows, and Linux are supported.\n• AppIndicator Go - Go bindings for libappindicator3 C library.\n• mac-activity-tracker - OSX library to notify about any (pluggable) activity on your machine.\n• robotgo - Go Native cross-platform GUI system automation. Control the mouse, keyboard and other.\n• systray - Cross platform Go library to place an icon and menu in the notification area.\n• trayhost - Cross-platform Go library to place an icon in the host operating system's taskbar.\n• zenity - Cross-platform Go library and CLI to create simple dialogs that interact graphically with the user.\n\nLibraries, tools, and tutorials for interacting with hardware.\n• arduino-cli - Official Arduino CLI and library. Can run standalone, or be incorporated into larger Go projects.\n• joystick - a polled API to read the state of an attached joystick.\n• bild - Collection of image processing algorithms in pure Go.\n• bimg - Small package for fast and efficient image processing using libvips.\n• cameron - An avatar generator for Go.\n• darkroom - An image proxy with changeable storage backends and image processing engines with focus on speed and resiliency.\n• go-cairo - Go binding for the cairo graphics library.\n• go-qrcode - Generate QR codes with personalized styles, allowing adjustments to color, block size, shape, and icons.\n• go-webcolors - Port of webcolors library from Python to Go.\n• go-webp - Library for encode and decode webp pictures, using libwebp.\n• gocv - Go package for computer vision using OpenCV 3.3+.\n• goimghdr - The imghdr module determines the type of image contained in a file for Go.\n• govips - A lightning fast image processing and resizing library for Go.\n• gowitness - Screenshoting webpages using go and headless chrome on command line.\n• imagick - Go binding to ImageMagick's MagickWand C API.\n• imagor - Fast, secure image processing server and Go library, using libvips.\n• mort - Storage and image processing server written in Go.\n• picfit - An image resizing server written in Go.\n• rez - Image resizing in pure Go and SIMD.\n• stegify - Go tool for LSB steganography, capable of hiding any file within an image.\n• transformimgs - Transformimgs resizes and optimises images for Web using next-generation formats.\n• webp-server - Simple and minimal image server capable of storing, resizing, converting and caching images.\n\nLibraries for programming devices of the IoT.\n• devices - Suite of libraries for IoT devices, experimental for x/exp/io.\n• eywa - Project Eywa is essentially a connection manager that keeps track of connected devices.\n• flogo - Project Flogo is an Open Source Framework for IoT Edge Apps & Integration.\n• gatt - Gatt is a Go package for building Bluetooth Low Energy peripherals.\n• gobot - Gobot is a framework for robotics, physical computing, and the Internet of Things.\n• huego - An extensive Philips Hue client library for Go.\n• cheek - A simple crontab like scheduler that aims to offer a KISS approach to job scheduling.\n• clockwerk - Go package to schedule periodic jobs using a simple, fluent syntax.\n• go-cron - Simple Cron library for go that can execute closures or functions at varying intervals, from once a second to once a year on a specific date and time. Primarily for web applications and long running daemons.\n• gocron - Easy and fluent Go job scheduling. This is an actively maintained fork of jasonlvhit/gocron.\n• gron - Define time-based tasks using a simple Go API and Gron’s scheduler will run them accordingly.\n• JobRunner - Smart and featureful cron job scheduler with job queuing and live monitoring built in.\n• sched - A job scheduler with the ability to fast-forward time.\n• tasks - An easy to use in-process scheduler for recurring tasks in Go.\n• ask - Easy access to nested values in maps and slices. Works in combination with encoding/json and other packages that \"Unmarshal\" arbitrary data into Go data-types.\n• ej - Write and read JSON from different sources succinctly.\n• epoch - Contains primitives for marshaling/unmarshalling Unix timestamp/epoch to/from build-in time.Time type in JSON.\n• fastjson - Fast JSON parser and validator for Go. No custom structs, no code generation, no reflection.\n• gabs - For parsing, creating and editing unknown or dynamic JSON in Go.\n• GJSON - Get a JSON value with one line of code.\n• go-jsonerror - Go-JsonError is meant to allow us to easily create json response errors that follow the JsonApi spec.\n• gojmapr - Get simple struct from complex json by json path.\n• gojson - Automatically generate Go (golang) struct definitions from example JSON.\n• htmljson - Rich rendering of JSON as HTML in Go.\n• jettison - Fast and flexible JSON encoder for Go.\n• json2go - Advanced JSON to Go struct conversion. Provides package that can parse multiple JSON documents and create struct to fit them all.\n• jsonapi-errors - Go bindings based on the JSON API errors reference.\n• jsondiff - JSON diff library for Go based on RFC6902 (JSON Patch).\n• jsongo - Fluent API to make it easier to create Json objects.\n• jsonhal - Simple Go package to make custom structs marshal into HAL compatible JSON responses.\n• jsonhandlers - JSON library to expose simple handlers that lets you easily read and write json from various sources.\n• jsonic - Utilities to handle and query JSON without defining structs in a type safe manner.\n• mapslice-json - Go MapSlice for ordered marshal/ unmarshal of maps in JSON.\n• mp - Simple cli email parser. It currently takes stdin and outputs JSON.\n• OjG - Optimized JSON for Go is a high performance parser with a variety of additional JSON tools including JSONPath.\n• omg.jsonparser - Simple JSON parser with validation by condition via golang struct fields tags.\n• ujson - Fast and minimal JSON parser and transformer that works on unstructured JSON.\n• vjson - Go package for validating JSON objects with declaring a JSON schema with fluent API.\n\nLibraries for generating and working with log files.\n• distillog - distilled levelled logging (think of it as stdlib + log levels).\n• glg - glg is simple and fast leveled logging library for Go.\n• go-cronowriter - Simple writer that rotate log files automatically based on current date and time, like cronolog.\n• go-log - Simple and configurable Logging in Go, with level, formatters and writers.\n• go-logger - Simple logger of Go Programs, with level handlers.\n• gomol - Multiple-output, structured logging for Go with extensible logging outputs.\n• httpretty - Pretty-prints your regular HTTP requests on your terminal for debugging (similar to http.DumpRequest).\n• journald - Go implementation of systemd Journal's native API for logging.\n• kemba - A tiny debug logging tool inspired by debug, great for CLI tools and applications.\n• lazyjournal - A TUI for reading and filtering logs from journalctl, file system, Docker and Podman containers, as well Kubernetes pods.\n• log - An O(1) logging system that allows you to connect one log to multiple writers (e.g. stdout, a file and a TCP connection).\n• log - Simple, configurable and scalable Structured Logging for Go.\n• log - Structured log interface for Go cleanly separates logging facade from its implementation.\n• log - A simple logging framework out of the box.\n• logur - An opinionated logger interface and collection of logging best practices with adapters and integrations for well-known libraries (logrus, go-kit log, zap, zerolog, etc).\n• logutils - Utilities for slightly better logging in Go (Golang) extending the standard logger.\n• logxi - 12-factor app logger that is fast and makes you happy.\n• mlog - Simple logging module for go, with 5 levels, an optional rotating logfile feature and stdout/stderr output.\n• noodlog - Parametrized JSON logging library which lets you obfuscate sensitive data and marshal any kind of content. No more printed pointers instead of values, nor escape chars for the JSON strings.\n• onelog - Onelog is a dead simple but very efficient JSON logger. It is the fastest JSON logger out there in all scenarios. Also, it is one of the logger with the lowest allocation.\n• ozzo-log - High performance logging supporting log severity, categorization, and filtering. Can send filtered log messages to various targets (e.g. console, network, mail).\n• rollingwriter - RollingWriter is an auto-rotate implementation with multi policies to provide log file rotation.\n• slf4g - Simple Logging Facade for Golang: Simple structured logging; but powerful, extendable and customizable, with huge amount of learnings from decades of past logging frameworks.\n• slog-formatter - Common formatters for slog and helpers to build your own.\n• spew - Implements a deep pretty printer for Go data structures to aid in debugging.\n• sqldb-logger - A logger for Go SQL database driver without modify existing *sql.DB stdlib usage.\n• stdlog - Stdlog is an object-oriented library providing leveled logging. It is very useful for cron jobs.\n• structy/log - A simple to use log system, minimalist but with features for debugging and differentiation of messages.\n• tail - Go package striving to emulate the features of the BSD tail program.\n• xlog - Plugin architecture and flexible log system for Go, with level ctrl, multiple log target and custom log format.\n• zax - Integrate Context with Zap logger, which leads to more flexibility in Go logging.\n• zl - High Developer Experience, zap based logger. It offers rich functionality but is easy to configure.\n• catboost-cgo - Fast, scalable, high performance Gradient Boosting on Decision Trees library. Golang using Cgo for blazing fast inference CatBoost Model.\n• CloudForest - Fast, flexible, multi-threaded ensembles of decision trees for machine learning in pure Go.\n• go-cluster - Go implementation of the k-modes and k-prototypes clustering algorithms.\n• go-featureprocessing - Fast and convenient feature processing for low latency machine learning in Go.\n• godist - Various probability distributions, and associated methods.\n• GoMLX - An accelerated Machine Learning framework for Go.\n• Goptuna - Bayesian optimization framework for black-box functions written in Go. Everything will be optimized.\n• gorgonia - graph-based computational library like Theano for Go that provides primitives for building various machine learning and neural network algorithms.\n• gorse - An offline recommender system backend based on collaborative filtering written in Go.\n• gosseract - Go package for OCR (Optical Character Recognition), by using Tesseract C++ library.\n• m2cgen - A CLI tool to transpile trained classic ML models into a native Go code with zero dependencies, written in Python with Go language support.\n• neural-go - Multilayer perceptron network implemented in Go, with training via backpropagation.\n• ocrserver - A simple OCR API server, seriously easy to be deployed by Docker and Heroku.\n• randomforest - Easy to use Random Forest library for Go.\n• shield - Bayesian text classifier with flexible tokenizers and storage backends for Go.\n• tfgo - Easy to use Tensorflow bindings: simplifies the usage of the official Tensorflow Go bindings. Define computational graphs in Go, load and execute models trained in Python.\n• ami - Go client to reliable queues based on Redis Cluster Streams.\n• APNs2 - HTTP/2 Apple Push Notification provider for Go — Send push notifications to iOS, tvOS, Safari and OSX apps.\n• Asynq - A simple, reliable, and efficient distributed task queue for Go built on top of Redis.\n• Beaver - A real time messaging server to build a scalable in-app notifications, multiplayer games, chat apps in web and mobile apps.\n• Centrifugo - Real-time messaging (Websockets or SockJS) server in Go.\n• Commander - A high-level event driven consumer/producer supporting various \"dialects\" such as Apache Kafka.\n• Confluent Kafka Golang Client - confluent-kafka-go is Confluent's Golang client for Apache Kafka and the Confluent Platform.\n• emitter - Emits events using Go way, with wildcard, predicates, cancellation possibilities and many other good wins.\n• Glue - Robust Go and Javascript Socket Library (Alternative to Socket.io).\n• Go-MediatR - A library for handling mediator patterns and simplified CQRS patterns within an event-driven architecture, inspired by csharp MediatR library.\n• go-nsq - the official Go package for NSQ.\n• go-res - Package for building REST/real-time services where clients are synchronized seamlessly, using NATS and Resgate.\n• Gollum - A n:m multiplexer that gathers messages from different sources and broadcasts them to a set of destinations.\n• gosd - A library for scheduling when to dispatch a message to a channel.\n• guble - Messaging server using push notifications (Google Firebase Cloud Messaging, Apple Push Notification services, SMS) as well as websockets, a REST API, featuring distributed operation and message-persistence.\n• hare - A user friendly library for sending messages and listening to TCP sockets.\n• hub - A Message/Event Hub for Go applications, using publish/subscribe pattern with support for alias like rabbitMQ exchanges.\n• hypermatch - A very fast and efficient Go library for matching events to a large set of rules\n• jazz - A simple RabbitMQ abstraction layer for queue administration and publishing and consuming of messages.\n• mangos - Pure go implementation of the Nanomsg (\"Scalability Protocols\") with transport interoperability.\n• melody - Minimalist framework for dealing with websocket sessions, includes broadcasting and automatic ping/pong handling.\n• Mercure - Server and library to dispatch server-sent updates using the Mercure protocol (built on top of Server-Sent Events).\n• messagebus - messagebus is a Go simple async message bus, perfect for using as event bus when doing event sourcing, CQRS, DDD.\n• NATS Go Client - Go client for the NATS messaging system.\n• rabbitroutine - Lightweight library that handles RabbitMQ auto-reconnect and publishing retries. The library takes into account the need to re-declare entities in RabbitMQ after reconnection.\n• RapidMQ - RapidMQ is a lightweight and reliable library for managing of the local messages queue.\n• redisqueue - redisqueue provides a producer and consumer of a queue that uses Redis streams.\n• rmqconn - RabbitMQ Reconnection. Wrapper over amqp.Connection and amqp.Dial. Allowing to do a reconnection when the connection is broken before forcing the call to the Close () method to be closed.\n• Watermill - Working efficiently with message streams. Building event driven applications, enabling event sourcing, RPC over messages, sagas. Can use conventional pub/sub implementations like Kafka or RabbitMQ, but also HTTP or MySQL binlog.\n• zmq4 - Go interface to ZeroMQ version 4. Also available for version 3 and version 2.\n• unioffice - Pure go library for creating and processing Office Word (.docx), Excel (.xlsx) and Powerpoint (.pptx) documents.\n• go-excel - A simple and light reader to read a relate-db-like excel as a table.\n• xlsx - Library to simplify reading the XML format used by recent version of Microsoft Excel in Go programs.\n• xlsx - Fast and safe way to read/update your existing Microsoft Excel files in Go programs.\n• boot-go - Component-based development with dependency injection using reflections for Go developers.\n• componego - A dependency injection framework based on components, allowing dynamic dependency replacement without duplicating code in tests.\n• dingo - A dependency injection toolkit for Go, based on Guice.\n• fx - A dependency injection based application framework for Go (built on top of dig).\n• GoLobby/Container - GoLobby Container is a lightweight yet powerful IoC dependency injection container for the Go programming language.\n• gontainer/gontainer - A YAML-based Dependency Injection container for GO. It supports dependencies' scopes, and auto-detection of circular dependencies. Gontainer is concurrent-safe.\n• HnH/di - DI container library that is focused on clean API and flexibility.\n• kinit - Customizable dependency injection container with the global mode, cascade initialization and panic-safe finalization.\n• linker - A reflection based dependency injection and inversion of control library with components lifecycle support.\n• cookiecutter-golang - A Go application boilerplate template for quick starting projects following production best practices.\n• go-blueprint - Allows users to spin up a quick Go project using a popular framework.\n• go-module - Template for a typical module written on Go.\n• go-sample - A sample layout for Go application projects with the real code.\n• go-todo-backend - Go Todo Backend example using modular project layout for product microservice.\n• gobase - A simple skeleton for golang application with basic setup for real golang application.\n• golang-standards/project-layout - Set of common historical and emerging project layout patterns in the Go ecosystem. Note: despite the org-name they do not represent official golang standards, see this issue for more information. Nonetheless, some may find the layout useful.\n• goxygen - Generate a modern Web project with Go and Angular, React, or Vue in seconds.\n• modern-go-application - Go application boilerplate and example applying modern practices.\n• nunu - Nunu is a scaffolding tool for building Go applications.\n• scaffold - Scaffold generates a starter Go project layout. Lets you focus on business logic implemented.\n• wangyoucao577/go-project-layout - Set of practices and discussions on how to structure Go project layout.\n• bexp - Go implementation of Brace Expansion mechanism to generate arbitrary strings.\n• gobeam/Stringy - String manipulation library to convert string to camel case, snake case, kebab case / slugify etc.\n• sttr - cross-platform, cli app to perform various operations on string.\n• xstrings - Collection of useful string functions ported from other languages.\n\nThese libraries were placed here because none of the other categories seemed to fit.\n• archives - a cross-platform, multi-format Go library for working with archives and compression formats with a unified API and as virtual file systems compatible with io/fs.\n• autoflags - Go package to automatically define command line flags from struct fields.\n• banner - Add beautiful banners into your Go applications.\n• basexx - Convert to, from, and between digit strings in various number bases.\n• bitio - Highly optimized bit-level Reader and Writer for Go.\n• captcha - Package captcha provides an easy to use, unopinionated API for captcha generation.\n• conv - Package conv provides fast and intuitive conversions across Go types.\n• faker - Random fake data and struct generator for Go.\n• go-commandbus - A slight and pluggable command-bus for Go.\n• go-openapi - Collection of packages to parse and utilize open-api schemas.\n• gopsutil - Cross-platform library for retrieving process and system utilization(CPU, Memory, Disks, etc).\n• gosms - Your own local SMS gateway in Go that can be used to send SMS.\n• gotoprom - Type-safe metrics builder wrapper library for the official Prometheus client.\n• gtree - Provide CLI, Package and Web for tree output and directories creation from Markdown or programmatically.\n• health - A simple and flexible health check library for Go.\n• healthcheck - An opinionated and concurrent health-check HTTP handler for RESTful services.\n• indigo - Distributed unique ID generator of using Sonyflake and encoded by Base58.\n• llvm - Library for interacting with LLVM IR in pure Go.\n• morse - Library to convert to and from morse code.\n• numa - NUMA is a utility library, which is written in go. It help us to write some NUMA-AWARED code.\n• persian - Some utilities for Persian language in go.\n• sandid - Every grain of sand on earth has its own ID.\n• shellwords - A Golang library to manipulate strings according to the word parsing rules of the UNIX Bourne shell.\n• shoutrrr - Notification library providing easy access to various messaging services like slack, mattermost, gotify and smtp among others.\n• stats - Monitors Go MemStats + System stats such as Memory, Swap and CPU and sends via UDP anywhere you want for logging etc...\n• varint - A faster varying length integer encoder/decoder than the one provided in the standard library.\n\nSee also Text Processing and Text Analysis.\n• guesslanguage - Functions to determine the natural language of a unicode text.\n• lingua-go - An accurate natural language detection library, suitable for long and short text alike. Supports detecting multiple languages in mixed-language text.\n• whatlanggo - Natural language detection package for Go. Supports 84 languages and 24 scripts (writing systems e.g. Latin, Cyrillic, etc).\n• golibstemmer - Go bindings for the snowball libstemmer library including porter 2.\n• gosentiwordnet - Sentiment analyzer using sentiwordnet lexicon in Go.\n• libtextcat - Cgo binding for libtextcat C library. Guaranteed compatibility with version 2.2.\n• nlp - Extract values from strings and fill your structs with nlp.\n• porter - This is a fairly straightforward port of Martin Porter's C implementation of the Porter stemming algorithm.\n• RAKE.go - Go port of the Rapid Automatic Keyword Extraction Algorithm (RAKE).\n• snowball - Snowball stemmer port (cgo wrapper) for Go. Provides word stem extraction functionality Snowball native.\n• spaGO - Self-contained Machine Learning and Natural Language Processing library in Go.\n• spelling-corrector - A spelling corrector for the Spanish language or create your own.\n• gojieba - This is a Go implementation of jieba which a Chinese word splitting algorithm.\n• gotokenizer - A tokenizer based on the dictionary and Bigram language models for Golang. (Now only support chinese segmentation)\n• gse - Go efficient text segmentation; support english, chinese, japanese and other.\n• MMSEGO - This is a GO implementation of MMSEG which a Chinese word splitting algorithm.\n• prose - Library for text processing that supports tokenization, part-of-speech tagging, named-entity extraction, and more. English only.\n• segment - Go library for performing Unicode Text Segmentation as described in Unicode Standard Annex #29\n• shamoji - The shamoji is word filtering package written in Go.\n• stemmer - Stemmer packages for Go programming language. Includes English and German stemmers.\n• textcat - Go package for n-gram based text categorization, with support for utf-8 and raw text.\n• ctxi18n - Context aware i18n with a short and consise API, pluralization, interpolation, and support. YAML locale definitions are based on Rails i18n.\n• go-i18n - Package and an accompanying tool to work with localized text.\n• iuliia-go - Transliterate Cyrillic → Latin in every possible way.\n• spreak - Flexible translation and humanization library for Go, based on the concepts behind gettext.\n• t - Another i18n pkg for golang, which follows GNU gettext style and supports .po/.mo files: , , etc. And it contains a cmd tool xtemplate, which can extract messages as a pot file from text/html template.\n• gounidecode - Unicode transliterator (also known as unidecode) for Go.\n• transliterator - Provides one-way string transliteration with supporting of language-specific transliteration rules.\n\nLibraries for working with various layers of the network.\n• arp - Package arp implements the ARP protocol, as described in RFC 826.\n• cidranger - Fast IP to CIDR lookup for Go.\n• dhcp6 - Package dhcp6 implements a DHCPv6 server, as described in RFC 3315.\n• dns - Go library for working with DNS.\n• easytcp - A light-weight TCP framework written in Go (Golang), built with message router. EasyTCP helps you build a TCP server easily fast and less painful.\n• ether - Cross-platform Go package for sending and receiving ethernet frames.\n• ethernet - Package ethernet implements marshaling and unmarshalling of IEEE 802.3 Ethernet II frames and IEEE 802.1Q VLAN tags.\n• fasthttp - Package fasthttp is a fast HTTP implementation for Go, up to 10 times faster than net/http.\n• fortio - Load testing library and command line tool, advanced echo server and web UI. Allows to specify a set query-per-second load and record latency histograms and other useful stats and graph them. Tcp, Http, gRPC.\n• ftp - Package ftp implements a FTP client as described in RFC 959.\n• fullproxy - A fully featured scriptable and daemon configurable proxy and pivoting toolkit with SOCKS5, HTTP, raw ports and reverse proxy protocols.\n• fwdctl - A simple and intuitive CLI to manage IPTables forwards in your Linux server.\n• gldap - gldap provides an ldap server implementation and you provide handlers for its ldap operations.\n• gmqtt - Gmqtt is a flexible, high-performance MQTT broker library that fully implements the MQTT protocol V3.1.1.\n• gnet - is a high-performance, lightweight, non-blocking, event-driven networking framework written in pure Go.\n• gNxI - A collection of tools for Network Management that use the gNMI and gNOI protocols.\n• go-getter - Go library for downloading files or directories from various sources using a URL.\n• go-multiproxy - Library for making HTTP requests through a pool of proxies offering fault tolerance, load balancing, automatic retries, cookie management, and more, via http.Get/Post replacement or http.Client RoundTripper drop-in\n• go-sse - Go client and server implementation of HTML server-sent events.\n• go-stun - Go implementation of the STUN client (RFC 3489 and RFC 5389).\n• gobgp - BGP implemented in the Go Programming Language.\n• gopacket - Go library for packet processing with libpcap bindings.\n• GoProxy - A library to create a customized HTTP/HTTPS proxy server using Go.\n• goshark - Package goshark use tshark to decode IP packet and create data struct to analyse packet.\n• HTTPLab - HTTPLabs let you inspect HTTP requests and forge responses.\n• iplib - Library for working with IP addresses (net.IP, net.IPNet), inspired by python ipaddress and ruby ipaddr\n• jazigo - Jazigo is a tool written in Go for retrieving configuration for multiple network devices.\n• llb - It's a very simple but quick backend for proxy servers. Can be useful for fast redirection to predefined domain with zero memory allocation and fast response.\n• mqttPaho - The Paho Go Client provides an MQTT client library for connection to MQTT brokers via TCP, TLS or WebSockets.\n• natiu-mqtt - A dead-simple, non-allocating, low level implementation of MQTT well suited for embedded systems.\n• nbio - Pure Go 1000k+ connections solution, support tls/http1.x/websocket and basically compatible with net/http, with high-performance and low memory cost, non-blocking, event-driven, easy-to-use.\n• netpoll - A high-performance non-blocking I/O networking framework, which focused on RPC scenarios, developed by ByteDance.\n• NFF-Go - Framework for rapid development of performant network functions for cloud and bare-metal (former YANFF).\n• peerdiscovery - Pure Go library for cross-platform local peer discovery using UDP multicast.\n• portproxy - Simple TCP proxy which adds CORS support to API's which don't support it.\n• psql-wire - PostgreSQL server wire protocol. Build your own server and start serving connections..\n• quic-go - An implementation of the QUIC protocol in pure Go.\n• raw - Package raw enables reading and writing data at the device driver level for a network interface.\n• sftp - Package sftp implements the SSH File Transfer Protocol as described in https://filezilla-project.org/specs/draft-ietf-secsh-filexfer-02.txt.\n• sslb - It's a Super Simples Load Balancer, just a little project to achieve some kind of performance.\n• tcpack - tcpack is an application protocol based on TCP to Pack and Unpack bytes stream in go program.\n• tspool - A TCP Library use worker pool to improve performance and protect your server.\n• tun2socks - A pure go implementation of tun2socks powered by gVisor TCP/IP stack.\n• vssh - Go library for building network and server automation over SSH protocol.\n• webrtc - A pure Go implementation of the WebRTC API.\n• winrm - Go WinRM client to remotely execute commands on Windows machines.\n• axios4go - A Go HTTP client library inspired by Axios, providing a simple and intuitive API for making HTTP requests.\n• azuretls-client - An easy-to-use HTTP client 100% in Go to spoof TLS/JA3 and HTTP2 fingerprint\n• fast-shot - Hit your API targets with rapid-fire precision using Go's fastest and simple HTTP Client.\n• go-cleanhttp - Get easily stdlib HTTP client, which does not share any state with other clients.\n• go-otelroundtripper - Go http.RoundTripper that emits open telemetry metrics for HTTP requests.\n• grequests - A Go \"clone\" of the great and famous Requests library.\n• heimdall - An enhanced http client with retry and hystrix capabilities.\n• httpretry - Enriches the default go HTTP client with retry functionality.\n• pester - Go HTTP client calls with retries, backoff, and concurrency.\n• req - Simple Go HTTP client with Black Magic (Less code and More efficiency).\n• request - HTTP client for golang. If you have experience about axios or requests, you will love it. No 3rd dependency.\n• requests - HTTP requests for Gophers. Uses context.Context and doesn't hide the underlying net/http.Client, making it compatible with standard Go APIs. Also includes testing tools.\n• resty - Simple HTTP and REST client for Go inspired by Ruby rest-client.\n• sling - Sling is a Go HTTP client library for creating and sending API requests.\n• tls-client - net/http.Client like HTTP Client with options to select specific client TLS Fingerprints to use for requests.\n\nLibraries for using OpenGL in Go.\n• gl - Go bindings for OpenGL (generated via glow).\n• goxjs/glfw - Go cross-platform glfw library for creating an OpenGL context and receiving events.\n• mathgl - Pure Go math package specialized for 3D math, with inspiration from GLM.\n• bob - SQL query builder and ORM/Factory generator for Go. Successor of SQLBoiler.\n• CQL - Built on top of GORM, adds compile-time verified queries based on auto-generated code.\n• ent - An entity framework for Go. Simple, yet powerful ORM for modeling and querying data.\n• go-store - Simple and fast Redis backed key-value store library for Go.\n• GORM - The fantastic ORM library for Golang, aims to be developer friendly.\n• gorp - Go Relational Persistence, ORM-ish library for Go.\n• grimoire - Grimoire is a database access layer and validation for golang. (Support: MySQL, PostgreSQL and SQLite3).\n• lore - Simple and lightweight pseudo-ORM/pseudo-struct-mapping environment for Go.\n• pop/soda - Database migration, creation, ORM, etc... for MySQL, PostgreSQL, and SQLite.\n• Prisma - Prisma Client Go, Typesafe database access for Go.\n• reform - Better ORM for Go, based on non-empty interfaces and code generation.\n• rel - Modern Database Access Layer for Golang - Testable, Extendable and Crafted Into a Clean and Elegant API.\n• SQLBoiler - ORM generator. Generate a featureful and blazing-fast ORM tailored to your database schema.\n• upper.io/db - Single interface for interacting with different data sources through the use of adapters that wrap mature database drivers.\n• XORM - Simple and powerful ORM for Go. (Support: MySQL, MyMysql, PostgreSQL, Tidb, SQLite3, MsSql and Oracle).\n\nOfficial tooling for dependency and package management\n• go modules - Modules are the unit of source code interchange and versioning. The go command has direct support for working with modules, including recording and resolving dependencies on other modules.\n• glide - Manage your golang vendor and vendored packages with ease. Inspired by tools like Maven, Bundler, and Pip.\n• godep - dependency tool for go, godep helps build packages reproducibly by fixing their dependencies.\n• goop - Simple dependency manager for Go (golang), inspired by Bundler.\n• gop - Build and manage your Go applications out of GOPATH.\n• govendor - Go Package Manager. Go vendor tool that works with the standard vendor file.\n• mvn-golang - plugin that provides way for auto-loading of Golang SDK, dependency management and start build environment in Maven project infrastructure.\n• syft - A CLI tool and Go library for generating a Software Bill of Materials (SBOM) from container images and filesystems.\n• go-instrument - Automatically add spans to all methods and functions.\n• pixie - No instrumentation tracing for Golang applications via eBPF.\n• statsviz - Live visualization of your Go application runtime statistics.\n• dasel - Query and update data structures using selectors from the command line. Comparable to jq/yq but supports JSON, YAML, TOML and XML with zero runtime dependencies.\n• gojsonq - A simple Go package to Query over JSON Data.\n• grapher - A GraphQL field builder utilizing Go generics with extra utilities and features.\n• graphql - GraphQL server with a focus on ease of use.\n• graphql-go - Implementation of GraphQL for Go.\n• jsonpath - A query library for retrieving part of JSON based on JSONPath syntax.\n• mql - Model Query Language (mql) is a query language for your database models.\n• rqp - Query Parser for REST API. Filtering, validations, both , operations are supported directly in the query.\n• copy - Package for fast copying structs of different types.\n• goenum - A common enumeration struct based on generics and reflection that allows you to quickly define enumerations and use a set of useful default methods.\n• gpath - Library to simplify access struct fields with Go's expression in reflection.\n• objwalker - Walk by go objects with reflection.\n• reflectutils - Helpers for working with reflection: struct tag parsing; recursive walking; fill value from string.\n• debme - Create an from an existing subdirectory.\n• embed - Package embed provides access to files embedded in the running Go program.\n• rebed - Recreate folder structures and files from Go 1.16's type\n• vfsgen - Generates a vfsdata.go file that statically implements the given virtual filesystem.\n• assocentity - Package assocentity returns the average distance from words to a given entity.\n• calendarheatmap - Calendar heatmap in plain Go inspired by Github contribution activity.\n• chart - Simple Chart Plotting library for Go. Supports many graphs types.\n• dataframe-go - Dataframes for machine-learning and statistics (similar to pandas).\n• go-estimate - State estimation and filtering algorithms in Go.\n• go-hep - A set of libraries and tools for performing High Energy Physics analyses with ease.\n• gograph - A golang generic graph library that provides mathematical graph-theory and algorithms.\n• gonum - Gonum is a set of numeric libraries for the Go programming language. It contains libraries for matrices, statistics, optimization, and more.\n• gonum/plot - gonum/plot provides an API for building and drawing plots in Go.\n• gosl - Go scientific library for linear algebra, FFT, geometry, NURBS, numerical methods, probabilities, optimisation, differential equations, and more.\n• GoStats - GoStats is an Open Source GoLang library for math statistics mostly used in Machine Learning domains, it covers most of the Statistical measures functions.\n• PiHex - Implementation of the \"Bailey-Borwein-Plouffe\" algorithm for the hexadecimal number Pi.\n• sparse - Go Sparse matrix formats for linear algebra supporting scientific and machine learning applications, compatible with gonum matrix libraries.\n• stats - Statistics package with common functions missing from the Golang standard library.\n• streamtools - general purpose, graphical tool for dealing with streams of data.\n• TextRank - TextRank implementation in Golang with extendable features (summarization, weighting, phrase extraction) and multithreading (goroutine) support.\n• topk - Sliding-window and regular top-K sketches, based on the HeavyKeeper algorithm.\n• triangolatte - 2D triangulation library. Allows translating lines and polygons (both based on points) to the language of GPUs.\n\nLibraries that are used to help make your application more secure.\n• age - A simple, modern and secure encryption tool (and Go library) with small explicit keys, no config options, and UNIX-style composability.\n• argon2-hashing - light wrapper around Go's argon2 package that closely mirrors with Go's standard library Bcrypt and simple-scrypt package.\n• BadActor - In-memory, application-driven jailer built in the spirit of fail2ban.\n• Cameradar - Tool and library to remotely hack RTSP streams from surveillance cameras.\n• CertMagic - Mature, robust, and powerful ACME client integration for fully-managed TLS certificate issuance and renewal.\n• dongle - A simple, semantic and developer-friendly golang package for encoding&decoding and encryption&decryption.\n• entpassgen - Entropy Password Generator with extensive command line arguments to generate random strings securely including digits, passwords, and passwords built using obscure dictionary words mixed with symbols and digits.\n• go-generate-password - Password generator that can be used on the cli or as a library.\n• go-yara - Go Bindings for YARA, the \"pattern matching swiss knife for malware researchers (and everyone else)\".\n• goArgonPass - Argon2 password hash and verification designed to be compatible with existing Python and PHP implementations.\n• goSecretBoxPassword - A probably paranoid package for securely hashing and encrypting passwords.\n• lego - Pure Go ACME client library and CLI tool (for use with Let's Encrypt).\n• memguard - A pure Go library for handling sensitive values in memory.\n• nacl - Go implementation of the NaCL set of API's.\n• passwap - Provides a unified implementation between different password hashing algorithms\n• secret - Prevent your secrets from leaking into logs, std* etc.\n• secure - HTTP middleware for Go that facilitates some quick security wins.\n• secureio - An keyexchanging+authenticating+encrypting wrapper and multiplexer for based on XChaCha20-poly1305, ECDH and ED25519.\n• teler-waf - teler-waf is a Go HTTP middleware that provide teler IDS functionality to protect against web-based attacks and improve the security of Go-based web applications. It is highly configurable and easy to integrate into existing Go applications.\n• themis - high-level cryptographic library for solving typical data security tasks (secure data storage, secure messaging, zero-knowledge proof authentication), available for 14 languages, best fit for multi-platform apps.\n• bambam - generator for Cap'n Proto schemas from go.\n• bel - Generate TypeScript interfaces from Go structs/interfaces. Useful for JSON RPC.\n• binstruct - Golang binary decoder for mapping data into the structure.\n• csvutil - High Performance, idiomatic CSV record encoding and decoding to native Go structures.\n• elastic - Convert slices, maps or any other unknown value across different types at run-time, no matter what.\n• fwencoder - Fixed width file parser (encoding and decoding library) for Go.\n• go-capnproto - Cap'n Proto library and parser for go.\n• go-codec - High Performance, feature-Rich, idiomatic encode, decode and rpc library for msgpack, cbor and json, with runtime-based OR code-generation support.\n• gogoprotobuf - Protocol Buffers for Go with Gadgets.\n• goprotobuf - Go support, in the form of a library and protocol compiler plugin, for Google's protocol buffers.\n• gotiny - Efficient Go serialization library, gotiny is almost as fast as serialization libraries that generate code.\n• mapstructure - Go library for decoding generic map values into native Go structures.\n• php_session_decoder - GoLang library for working with PHP session format and PHP Serialize/Unserialize functions.\n• pletter - A standard way to wrap a proto message for message brokers.\n• structomap - Library to easily and dynamically generate maps from static structures.\n• unitpacking - Library to pack unit vectors into as fewest bytes as possible.\n• algernon - HTTP/2 web server with built-in support for Lua, Markdown, GCSS and Amber.\n• Caddy - Caddy is an alternative, HTTP/2 web server that's easy to configure and use.\n• Clace - Clace makes internal tool deployment and management easy by implementing an app server for containerized webapps.\n• consul - Consul is a tool for service discovery, monitoring and configuration.\n• Engity's Bifröst - Highly customizable SSH server with several ways to authorize a user how to execute its session (local or in containers).\n• etcd - Highly-available key value store for shared configuration and service discovery.\n• Fider - Fider is an open platform to collect and organize customer feedback.\n• Flagr - Flagr is an open-source feature flagging and A/B testing service.\n• flipt - A self contained feature flag solution written in Go and Vue.js\n• go-proxy-cache - Simple Reverse Proxy with Caching, written in Go, using Redis.\n• lets-proxy2 - Reverse proxy for handle https with issue certificates in fly from lets-encrypt.\n• Moxy - Moxy is a simple mocker and proxy application server, you can create mock endpoints as well as proxy requests in case no mock exists for the endpoint.\n• pocketbase - PocketBase is a realtime backend in 1 file consisting of embedded database (SQLite) with realtime subscriptions, built-in auth management and much more.\n• riemann-relay - Relay to load-balance Riemann events and/or convert them to Carbon.\n• SFTPGo - Fully featured and highly configurable SFTP server with optional FTP/S and WebDAV support. It can serve local filesystem and Cloud Storage backends such as S3 and Google Cloud Storage.\n• wd-41 - A (w)eb (d)evelopment server with automatic live-reload on file changes.\n• Wish - Make SSH apps, just like that!\n\nLibraries and tools for stream processing and reactive programming.\n• goio - An implementation of IO, Stream, Fiber for Golang, inspired by awesome Scala libraries cats and fs2.\n• machine - Go library for writing and generating stream workers with built in metrics and traceability.\n\nLibraries and tools for templating and lexing.\n• ego - Lightweight templating language that lets you write templates in Go. Templates are translated into Go and compiled.\n• extemplate - Tiny wrapper around html/template to allow for easy file-based template inheritance.\n• fasttemplate - Simple and fast template engine. Substitutes template placeholders up to 10x faster than text/template.\n• gomponents - HTML 5 components in pure Go, that look something like this: .\n• got - A Go code generator inspired by Hero and Fasttemplate. Has include files, custom tag definitions, injected Go code, language translation, and more.\n• goview - Goview is a lightweight, minimalist and idiomatic template library based on golang html/template for building Go web application.\n• htmgo - build simple and scalable systems with go + htmx\n• maroto - A maroto way to create PDFs. Maroto is inspired in Bootstrap and uses gofpdf. Fast and simple.\n• quicktemplate - Fast, powerful, yet easy to use template engine. Converts templates into Go code and then compiles it.\n• Soy - Closure templates (aka Soy templates) for Go, following the official spec.\n• sprout - Useful template functions for Go templates.\n• tbd - A really simple way to create text templates with placeholders - exposes extra builtin Git repo metadata.\n• apitest - Simple and extensible behavioural testing library for REST based services or HTTP handlers that supports mocking external http calls and rendering of sequence diagrams.\n• assert - Basic Assertion Library used along side native go testing, with building blocks for custom assertions.\n• commander - Tool for testing cli applications on windows, linux and osx.\n• dbcleaner - Clean database for testing purpose, inspired by in Ruby.\n• dft - Lightweight, zero dependency docker containers for testing (or more).\n• embedded-postgres - Run a real Postgres database locally on Linux, OSX or Windows as part of another Go application or test.\n• gnomock - integration testing with real dependencies (database, cache, even Kubernetes or AWS) running in Docker, without mocks.\n• go-cmp - Package for comparing Go values in tests.\n• go-hit - Hit is an http integration test framework written in golang.\n• go-mysql-test-container - Golang MySQL testcontainer to help with MySQL integration testing.\n• go-vcr - Record and replay your HTTP interactions for fast, deterministic and accurate tests.\n• goblin - Mocha like testing framework of Go.\n• goc - Goc is a comprehensive coverage testing system for The Go Programming Language.\n• Gont - Go network testing toolkit for testing building complex network topologies using Linux namespaces.\n• gospecify - This provides a BDD syntax for testing your Go code. It should be familiar to anybody who has used libraries such as rspec.\n• gosuite - Brings lightweight test suites with setup/teardown facilities to by leveraging Go1.7's Subtests.\n• gotest.tools - A collection of packages to augment the go testing package and support common patterns.\n• Hamcrest - fluent framework for declarative Matcher objects that, when applied to input values, produce self-describing results.\n• httpexpect - Concise, declarative, and easy to use end-to-end HTTP and REST API testing.\n• is - Professional lightweight testing mini-framework for Go.\n• jsonassert - Package for verifying that your JSON payloads are serialized correctly.\n• omg.testingtools - The simple library for change a values of private fields for testing.\n• restit - Go micro framework to help writing RESTful API integration test.\n• schema - Quick and easy expression matching for JSON schemas used in requests and responses.\n• testcerts - Dynamically generate self-signed certificates and certificate authorities within your test functions.\n• testcontainers-go - A Go package that makes it simple to create and clean up container-based dependencies for automated integration/smoke tests. The clean, easy-to-use API enables developers to programmatically define containers that should be run as part of a test and clean up those resources when the test is done.\n• testfixtures - A helper for Rails' like test fixtures to test database applications.\n• Testify - Sacred extension to the standard go testing package.\n• testsql - Generate test data from SQL files before testing and clear it after finished.\n• trial - Quick and easy extendable assertions without introducing much boilerplate.\n• genmock - Go mocking system with code generator for building calls of the interface methods.\n• go-localstack - Tool for using localstack in AWS testing.\n• gomock - Mocking framework for the Go programming language.\n• govcr - HTTP mock for Golang: record and replay HTTP interactions for offline testing.\n• hoverfly - HTTP(S) proxy for recording and simulating REST/SOAP APIs with extensible middleware and easy-to-use CLI.\n• mooncake - A simple way to generate mocks for multiple purposes.\n• moq - Utility that generates a struct from any interface. The struct can be used in test code as a mock of the interface.\n• gofuzz - Library for populating go objects with random values.\n• cdp - Type-safe bindings for the Chrome Debugging Protocol that can be used with browsers or other debug targets that implement it.\n• chromedp - a way to drive/test Chrome, Safari, Edge, Android Webviews, and other browsers supporting the Chrome Debugging Protocol.\n• ggr - a lightweight server that routes and proxies Selenium WebDriver requests to multiple Selenium hubs.\n• playwright-go - browser automation library to control Chromium, Firefox and WebKit with a single API.\n• failpoint - An implementation of failpoints for Golang.\n\nSee also Natural Language Processing and Text Analysis.\n• go-humanize - Formatters for time, numbers, and memory size to human readable format.\n• gotabulate - Easily pretty-print your tabular data with Go.\n• sq - Convert data from SQL databases or document formats like CSV or Excel into formats such as JSON, Excel, CSV, HTML, Markdown, XML, and YAML.\n• textwrap - Wraps text at end of lines. Implementation of module from Python.\n• bafi - Universal JSON, BSON, YAML, XML translator to ANY format using templates.\n• bbConvert - Converts bbCode to HTML that allows you to add support for custom bbCode tags.\n• go-output-format - Output go structures into multiple formats (YAML/JSON/etc) in your command line app.\n• go-toml - Go library for the TOML format with query support and handy cli tools.\n• goldmark - A Markdown parser written in Go. Easy to extend, standard (CommonMark) compliant, well structured.\n• goq - Declarative unmarshalling of HTML using struct tags with jQuery syntax (uses GoQuery).\n• html-to-markdown - Convert HTML to Markdown. Even works with entire websites and can be extended through rules.\n• htmlquery - An XPath query package for HTML, lets you extract data or evaluate from HTML documents by an XPath expression.\n• htmlyaml - Rich rendering of YAML as HTML in Go\n• htree - Traverse, navigate, filter, and otherwise process trees of html.Node objects.\n• mxj - Encode / decode XML as JSON or map[string]interface{}; extract values with dot-notation paths and wildcards. Replaces x2j and j2x packages.\n• allot - Placeholder and wildcard text parsing for CLI tools and bots.\n• commonregex - A collection of common regular expressions for Go.\n• did - DID (Decentralized Identifiers) Parser and Stringer in Go.\n• editorconfig-core-go - Editorconfig file parser and manipulator for Go.\n• encdec - Package provides a generic interface to encoders and decoders.\n• go-nmea - NMEA parser library for the Go language.\n• go-querystring - Go library for encoding structs into URL query parameters.\n• godump - Pretty print any GO variable with ease, an alternative to Go's .\n• gofeed - Parse RSS and Atom feeds in Go.\n• ltsv - High performance LTSV (Labeled Tab Separated Value) reader for Go.\n• tokenizer - Parse any string, slice or infinite buffer to any tokens.\n• vdf - A Lexer and Parser for Valves Data Format (known as vdf) written in Go.\n• when - Natural EN and RU language date/time parser with pluggable rules.\n• xj2go - Convert xml or json to go struct.\n• genex - Count and expand Regular Expressions into all matching Strings.\n• regroup - Match regex expression named groups into go struct using struct tags and automatic parsing.\n• GoQuery - GoQuery brings a syntax and a set of features similar to jQuery to the Go language.\n• pagser - Pagser is a simple, extensible, configurable parse and deserialize html page to struct based on goquery and struct tags for golang crawler.\n• Tagify - Produces a set of tags from given source.\n• walker - Seamlessly fetch paginated data from any source. Simple and high performance API scraping included.\n• go-runewidth - Functions to get fixed width of the character or string.\n• go-zero-width - Zero-width character detection and removal for Go.\n• petrovich - Petrovich is the library which inflects Russian names to given grammatical case.\n• w2vgrep - A semantic grep tool using word embeddings to find semantically similar matches. For example, searching for \"death\" will find \"dead\", \"killing\", \"murder\".\n• airtable - Go client library for the Airtable API.\n• anaconda - Go client library for the Twitter 1.1 API.\n• aws-encryption-sdk-go - Unofficial Go SDK implementation of the AWS Encryption SDK.\n• aws-sdk-go - The official AWS SDK for the Go programming language.\n• bqwriter - High Level Go Library to write data into Google BigQuery at a high throughout.\n• brewerydb - Go library for accessing the BreweryDB API.\n• circleci - Go client library for interacting with CircleCI's API.\n• clarifai - Go client library for interfacing with the Clarifai API.\n• codeship-go - Go client library for interacting with Codeship's API v2.\n• coinpaprika-go - Go client library for interacting with Coinpaprika's API.\n• device-check-go - Go client library for interacting with iOS DeviceCheck API v1.\n• discordgo - Go bindings for the Discord Chat API.\n• disgo - Go API Wrapper for the Discord API.\n• facebook - Go Library that supports the Facebook Graph API.\n• geo-golang - Go Library to access Google Maps, MapQuest, Nominatim, OpenCage, Bing, Mapbox, and OpenStreetMap geocoding / reverse geocoding APIs.\n• github - Go library for accessing the GitHub REST API v3.\n• githubql - Go library for accessing the GitHub GraphQL API v4.\n• go-atlassian - Go library for accessing the Atlassian Cloud services (Jira, Jira Service Management, Jira Agile, Confluence, Admin Cloud)\n• go-aws-news - Go application and library to fetch what's new from AWS.\n• go-chronos - Go library for interacting with the Chronos Job Scheduler\n• go-here - Go client library around the HERE location based APIs.\n• go-hibp - Simple Go binding to the \"Have I Been Pwned\" APIs.\n• go-lark - An easy-to-use unofficial SDK for Feishu and Lark Open Platform.\n• go-marathon - Go library for interacting with Mesosphere's Marathon PAAS.\n• go-myanimelist - Go client library for accessing the MyAnimeList API.\n• go-openproject - Go client library for interacting with OpenProject API.\n• go-postman-collection - Go module to work with Postman Collections (compatible with Insomnia).\n• go-redoc - Embedded OpenAPI/Swagger documentation ui for Go using ReDoc.\n• go-restcountries - Go library for the REST Countries API.\n• go-salesforce - Go client library for interacting with the Salesforce REST API.\n• go-sophos - Go client library for the Sophos UTM REST API with zero dependencies.\n• go-swagger-ui - Go library containing precompiled Swagger UI for serving swagger json.\n• go-trending - Go library for accessing trending repositories and developers at Github.\n• go-unsplash - Go client library for the Unsplash.com API.\n• go-xkcd - Go client for the xkcd API.\n• go-yapla - Go client library for the Yapla v2.0 API.\n• GoFreeDB - Golang library providing common and simple database abstractions on top of Google Sheets.\n• golyrics - Golyrics is a Go library to fetch music lyrics data from the Wikia website.\n• gopensky - Go client implementation for OpenSKY Network live's API (airspace ADS-B and Mode S data).\n• gostorm - GoStorm is a Go library that implements the communications protocol required to write Storm spouts and Bolts in Go that communicate with the Storm shells.\n• hipchat - This project implements a golang client library for the Hipchat API.\n• hipchat (xmpp) - A golang package to communicate with HipChat over XMPP.\n• igdb - Go client for the Internet Game Database API.\n• ip2location-io-go - Go wrapper for the IP2Location.io API IP2Location.io.\n• lark - Feishu/Lark Open API Go SDK, Support ALL Open API and Event Callback.\n• lastpass-go - Go client library for the LastPass API.\n• mixpanel - Mixpanel is a library for tracking events and sending Mixpanel profile updates to Mixpanel from your go applications.\n• pushover - Go wrapper for the Pushover API.\n• rawg-sdk-go - Go library for the RAWG Video Games Database API\n• shopify - Go Library to make CRUD request to the Shopify API.\n• simples3 - Simple no frills AWS S3 Library using REST with V4 Signing written in Go.\n• smite - Go package to wraps access to the Smite game API.\n• steam - Go Library to interact with Steam game servers.\n• stripe - Go client for the Stripe API.\n• swag - No comments, simple go wrapper to create swagger 2.0 compatible APIs. Support most routing frameworks, such as built-in, gin, chi, mux, echo, httprouter, fasthttp and more.\n• textbelt - Go client for the textbelt.com txt messaging API.\n• Trello - Go wrapper for the Trello API.\n• TripAdvisor - Go wrapper for the TripAdvisor API.\n• tumblr - Go wrapper for the Tumblr v2 API.\n• uptimerobot - Go wrapper and command-line client for the Uptime Robot v2 API.\n• vl-go - Go client library around the VerifID identity verification layer API.\n• ynab - Go wrapper for the YNAB API.\n• zooz - Go client for the Zooz API.\n\nGeneral utilities and tools to make your life easier.\n• apm - Process manager for Golang applications with an HTTP API.\n• backscanner - A scanner similar to bufio.Scanner, but it reads and returns lines in reverse order, starting at a given position and going backward.\n• blank - Verify or remove blanks and whitespace from strings.\n• bleep - Perform any number of actions on any set of OS signals in Go.\n• changie - Automated changelog tool for preparing releases with lots of customization options.\n• circuit - An efficient and feature complete Hystrix like Go implementation of the circuit breaker pattern.\n• cmd - Library for executing shell commands on osx, windows and linux.\n• command - Command pattern for Go with thread safe serial and parallel dispatcher.\n• copy-pasta - Universal multi-workstation clipboard that uses S3 like backend for the storage.\n• countries - All you need when you are working with countries in Go.\n• create-go-app - A powerful CLI for create a new production-ready project with backend (Golang), frontend (JavaScript, TypeScript) & deploy automation (Ansible, Docker) by running one command.\n• cryptgo - Crytpgo is a TUI based application written purely in Go to monitor and observe cryptocurrency prices in real time!\n• cvt - Easy and safe convert any value to another type.\n• dive - A tool for exploring each layer in a Docker image.\n• dlog - Compile-time controlled logger to make your release smaller without removing debug calls.\n• EaseProbe - A simple, standalone, and lightWeight tool that can do health/status checking daemon, support HTTP/TCP/SSH/Shell/Client/... probes, and Slack/Discord/Telegram/SMS... notification.\n• equalizer - Quota manager and rate limiter collection for Go.\n• ergo - The management of multiple local services running over different ports made easy.\n• evaluator - Evaluate an expression dynamically based on s-expression. It's simple and easy to extend.\n• Failsafe-go - Fault tolerance and resilience patterns for Go.\n• filetype - Small package to infer the file type checking the magic numbers signature.\n• filter - provide filtering, sanitizing, and conversion of Go data.\n• generate - runs go generate recursively on a specified path or environment variable and can filter by regex.\n• ghokin - Parallelized formatter with no external dependencies for gherkin (cucumber, behat...).\n• gitbatch - manage your git repositories in one place.\n• gitcs - Git Commits Visualizer, CLI tool to visualize your Git commits on your local machine.\n• go-astitodo - Parse TODOs in your GO code.\n• go-bind-plugin - go:generate tool for wrapping symbols exported by golang plugins (1.8 only).\n• go-bsdiff - Pure Go bsdiff and bspatch libraries and CLI tools.\n• go-convert - Package go-convert enables you to convert a value into another type.\n• go-dry - DRY (don't repeat yourself) package for Go.\n• go-events - A go event and event'subscribe package, like wordpress hook functions.\n• go-funk - Modern Go utility library which provides helpers (map, find, contains, filter, chunk, reverse, ...).\n• go-health - Health package simplifies the way you add health check to your services.\n• go-httpheader - Go library for encoding structs into Header fields.\n• go-lambda-cleanup - A CLI for removing unused or previous versions of AWS Lambdas.\n• go-lock - go-lock is a lock library implementing read-write mutex and read-write trylock without starvation.\n• go-problemdetails - Go package for working with Problem Details.\n• go-trigger - Go-lang global event triggerer, Register Events with an id and trigger the event from anywhere from your project.\n• go-tripper - Tripper is a circuit breaker package for Go that allows you to circuit and control the status of circuits.\n• go-type - Library providing Go types for store/validation and transfer of ISO-4217, ISO-3166, and other types.\n• goctx - Get your context value with high performance.\n• godropbox - Common libraries for writing Go services/applications from Dropbox.\n• gofn - High performance utility functions written using Generics for Go 1.18+.\n• golog - Easy and lightweight CLI tool to time track your tasks.\n• goreleaser - Deliver Go binaries as fast and easily as possible.\n• goreporter - Golang tool that does static analysis, unit testing, code review and generate code quality report.\n• gotenv - Load environment variables from or any in Go.\n• graterm - Provides primitives to perform ordered (sequential/concurrent) GRAceful TERMination (aka shutdown) in Go application.\n• gubrak - Golang utility library with syntactic sugar. It's like lodash, but for golang.\n• handy - Many utilities and helpers like string handlers/formatters and validators.\n• hub - wrap git commands with additional functionality to interact with github from the terminal.\n• jet - Just Edit Text: a fast and powerful tool for finding and replacing file content and names using regular expressions.\n• jump - Jump helps you navigate faster by learning your habits.\n• just - Just a collection of useful functions for working with generic data structures.\n• koazee - Library inspired in Lazy evaluation and functional programming that takes the hassle out of working with arrays.\n• lancet - A comprehensive, efficient, and reusable util function library of go.\n• lets-go - Go module that provides common utilities for Cloud Native REST API development. Also contains AWS Specific utilities.\n• limiters - Rate limiters for distributed applications in Golang with configurable back-ends and distributed locks.\n• lo - A Lodash like Go library based on Go 1.18+ Generics (map, filter, contains, find...)\n• mani - CLI tool to help you manage multiple repositories.\n• mc - Minio Client provides minimal tools to work with Amazon S3 compatible cloud storage and filesystems.\n• mergo - Helper to merge structs and maps in Golang. Useful for configuration default values, avoiding messy if-statements.\n• minquery - MongoDB / mgo.v2 query that supports efficient pagination (cursors to continue listing documents where we left off).\n• moldova - Utility for generating random data based on an input template.\n• mongo-go-pagination - Mongodb Pagination for official mongodb/mongo-go-driver package which supports both normal queries and Aggregation pipelines.\n• mssqlx - Database client library, proxy for any master slave, master master structures. Lightweight and auto balancing in mind.\n• onecache - Caching library with support for multiple backend stores (Redis, Memcached, filesystem etc).\n• pointer - Package pointer contains helper routines for simplifying the creation of optional fields of basic type.\n• ptr - Package that provide functions for simplified creation of pointers from constants of basic types.\n• repeat - Go implementation of different backoff strategies useful for retrying operations and heartbeating.\n• rerun - Recompiling and rerunning go apps when source changes.\n• rest-go - A package that provide many helpful methods for working with rest api.\n• retry - The most advanced functional mechanism to perform actions repetitively until successful.\n• retry - A simple but highly configurable retry package for Go.\n• retry - Simple and easy retry mechanism package for Go.\n• retry - A pretty simple library to ensure your work to be done.\n• rospo - Simple and reliable ssh tunnels with embedded ssh server in Golang.\n• scan - Scan sql rows into any type powered by generics.\n• scany - Library for scanning data from a database into Go structs and more.\n• serve - A static http server anywhere you need.\n• sesh - Sesh is a CLI that helps you create and manage tmux sessions quickly and easily using zoxide.\n• sqlx - provides a set of extensions on top of the excellent built-in database/sql package.\n• throttle - Throttle is an object that will perform exactly one action per duration.\n• tik - Simple and easy timing wheel package for Go.\n• UNIS - Common Architecture™ for String Utilities in Go.\n• upterm - A tool for developers to share terminal/tmux sessions securely over the web. It’s perfect for remote pair programming, accessing computers behind NATs/firewalls, remote debugging, and more.\n• watchhttp - Run command periodically and expose latest STDOUT or its rich delta as HTTP endpoint.\n• xferspdy - Xferspdy provides binary diff and patch library in golang.\n• xpool - Yet another golang type safe object pool using generics.\n• gouid - Generate cryptographically secure random string IDs with just one allocation.\n• uuid - Generate, encode, and decode UUIDs v1 with fast or cryptographic-quality random node identifier.\n• uuid - Implementation of Universally Unique Identifier (UUID). Supports both creation and parsing of UUIDs. Actively maintained fork of satori uuid.\n• uuid - Go package for UUIDs based on RFC 4122 and DCE 1.1: Authentication and Security Services.\n• uuidcheck - A tiny, dependency-free Go library that validates UUIDs against standard RFC 4122 formatting, converts UUIDv7() into UTC timestamps.\n• xid - Xid is a globally unique id generator library, ready to be safely used directly in your server code.\n• govalidator - Validators and sanitizers for strings, numerics, slices and structs.\n• hvalid hvalid is a lightweight validation library written in Go language. It provides a custom validator interface and a series of common validation functions to help developers quickly implement data validation.\n• ozzo-validation - Supports validation of various data types (structs, strings, maps, slices, etc.) with configurable and extensible validation rules specified in usual code constructs instead of struct tags.\n• validate - Go package for data validation and filtering. support validate Map, Struct, Request(Form, JSON, url.Values, Uploaded Files) data and more features.\n• validate - This package provides a framework for writing validations for Go applications.\n• validator - Go Struct and Field validation, including Cross Field, Cross Struct, Map, Slice and Array diving.\n• Zog - A Zod inspired schema builder for runtime value parsing and validation. ⬆ back to top\n• cli - An open-source GitLab command line tool bringing GitLab's cool features to your command line.\n• froggit-go - Froggit-Go is a Go library, allowing to perform actions on VCS providers.\n• githooks - Per-repo and shared Git hooks with version control and auto update.\n• go-vcs - manipulate and inspect VCS repositories in Go.\n• hgo - Hgo is a collection of Go packages providing read-access to local Mercurial repositories.\n• go-astiav - Better C bindings for ffmpeg in GO.\n• go-astisub - Manipulate subtitles in GO (.srt, .stl, .ttml, .webvtt, .ssa/.ass, teletext, .smi, etc.).\n• go-astits - Parse and demux MPEG Transport Streams (.ts) natively in GO.\n• go-m3u8 - Parser and generator library for Apple m3u8 playlists. Actively maintained version of quangngotan95/go-m3u8 with improvements and latest HLS playlist parsing compatibility.\n• libvlc-go - Go bindings for libvlc 2.X/3.X/4.X (used by the VLC media player).\n• m3u8 - Parser and generator library of M3U8 playlists for Apple HLS.\n• mp4ff - Library and tools for working with MP4 files containing video, audio, subtitles, or metadata.\n• v4l - Video capture library for Linux, written in Go.\n• Atreugo - High performance and extensible micro web framework with zero memory allocations in hot paths.\n• Beego - beego is an open-source, high-performance web framework for the Go programming language.\n• Confetti Framework - Confetti is a Go web application framework with an expressive, elegant syntax. Confetti combines the elegance of Laravel and the simplicity of Go.\n• Don - A highly performant and simple to use API framework.\n• Flamingo - Framework for pluggable web projects. Including a concept for modules and offering features for DI, Configareas, i18n, template engines, graphql, observability, security, events, routing & reverse routing etc.\n• Flamingo Commerce - Providing e-commerce features using clean architecture like DDD and ports and adapters, that you can use to build flexible e-commerce applications.\n• Fuego - The framework for busy Go developers! Web framework generating OpenAPI 3 spec from source code.\n• Gin - Gin is a web framework written in Go! It features a martini-like API with much better performance, up to 40 times faster. If you need performance and good productivity.\n• Goa - Goa provides a holistic approach for developing remote APIs and microservices in Go.\n• GoFrame - GoFrame is a modular, powerful, high-performance and enterprise-class application development framework of Golang.\n• golamb - Golamb makes it easier to write API endpoints for use with AWS Lambda and API Gateway.\n• Gone - A lightweight dependency injection and web framework inspired by Spring.\n• goravel - A Laravel-inspired web framework with ORM, authentication, queue, task scheduling, and more built-in features.\n• Goyave - Feature-complete REST API framework aimed at clean code and fast development, with powerful built-in functionalities.\n• Hertz - A high-performance and strong-extensibility Go HTTP framework that helps developers build microservices.\n• hiboot - hiboot is a high performance web application framework with auto configuration and dependency injection support.\n• Huma - Framework for modern REST/GraphQL APIs with built-in OpenAPI 3, generated documentation, and a CLI.\n• iWF - iWF is an all-in-one platform for developing long-running business processes. It offers a convenient abstraction for utilizing databases, ElasticSearch, message queues, durable timers, and more, with a clean, simple, and user-friendly interface.\n• Lit - Highly performant declarative web framework for Golang, aiming for simplicity and quality of life.\n• Microservice - The framework for the creation of microservices, written in Golang.\n• patron - Patron is a microservice framework following best cloud practices with a focus on productivity.\n• Pnutmux - Pnutmux is a powerful Go web framework that uses regex for matching and handling HTTP requests. It offers features such as CORS handling, structured logging, URL parameters extraction, middlewares, and concurrency limiting.\n• Revel - High-productivity web framework for the Go language.\n• rk-boot - A bootstrapper library for building enterprise go microservice with Gin and gRPC quickly and easily.\n• WebGo - A micro-framework to build web apps with handler chaining, middleware, and context injection. With standard library-compliant HTTP handlers (i.e., )..\n• Yokai - Simple, modular, and observable Go framework for backend applications.\n• echo-middleware - Middleware for Echo framework with logging and metrics.\n• ln-paywall - Go middleware for monetizing APIs on a per-request basis with the Lightning Network (Bitcoin).\n• mid - Miscellaneous HTTP middleware features: idiomatic error return from handlers; receive/respond with JSON data; request tracing; and more.\n• rk-gin - Middleware for Gin framework with logging, metrics, auth, tracing etc.\n• rk-grpc - Middleware for gRPC with logging, metrics, auth, tracing etc.\n• gores - Go package that handles HTML, JSON, XML and etc. responses. Useful for RESTful APIs.\n• mediary - add interceptors to to allow dumping/shaping/tracing/... of requests/responses.\n• render - Go package for easily rendering JSON, XML, and HTML template responses.\n• renderer - Simple, lightweight and faster response (JSON, JSONP, XML, YAML, HTML, File) rendering package for Go.\n• rye - Tiny Go middleware library (with canned Middlewares) that supports JWT, CORS, Statsd, and Go 1.7 context.\n• stats - Go middleware that stores various information about your web application.\n• Bxog - Simple and fast HTTP router for Go. It works with routes of varying difficulty, length and nesting. And he knows how to create a URL from the received parameters.\n• fasthttprouter - High performance router forked from . The first router fit for .\n• gocraft/web - Mux and middleware package in Go.\n• Goji - Goji is a minimalistic and flexible HTTP request multiplexer with support for .\n• GoLobby/Router - GoLobby Router is a lightweight yet powerful HTTP router for the Go programming language.\n• GoRouter - GoRouter is a Server/API micro framework, HTTP request router, multiplexer, mux that provides request router with middleware supporting .\n• httprouter - High performance router. Use this and the standard http handlers to form a very high performance web framework.\n• httptreemux - High-speed, flexible tree-based HTTP router for Go. Inspiration from httprouter.\n• lars - Is a lightweight, fast and extensible zero allocation HTTP router for Go used to create customizable frameworks.\n• ozzo-routing - An extremely fast Go (golang) HTTP router that supports regular expression route matching. Comes with full support for building RESTful APIs.\n• pure - Is a lightweight HTTP router that sticks to the std \"net/http\" implementation.\n• xujiajun/gorouter - A simple and fast HTTP router for Go.\n• Extism Go SDK - Universal, cross-language WebAssembly framework for building plug-in systems and polyglot apps.\n• go-canvas - Library to use HTML5 Canvas, with all drawing within go code.\n• tinygo - Go compiler for small places. Microcontrollers, WebAssembly, and command-line tools. Based on LLVM.\n• vert - Interop between Go and JS values.\n• wasmbrowsertest - Run Go WASM tests in your browser.\n• webapi - Bindings for DOM and HTML generated from WebIDL.\n• webhook - Tool which allows user to create HTTP endpoints (hooks) that execute commands on the server.\n• webhooked - A webhook receiver on steroids: handle, secure, format and store a Webhook payload has never been easier.\n• gosddl - Converter from SDDL-string to user-friendly JSON. SDDL consist of four part: Owner, Primary Group, DACL, SACL.\n• Cadence-client - A framework for authoring workflows and activities running on top of the Cadence orchestration engine made by Uber.\n• go-dag - A framework developed in Go that manages the execution of workflows described by directed acyclic graphs.\n• XML-Comp - Simple command line XML comparer that generates diffs of folders, files and tags.\n\nLibraries and tools to implement Zero Trust architectures.\n• Cosign - Container Signing, Verification and Storage in an OCI registry.\n• in-toto - Go implementation of the in-toto (provides a framework to protect the integrity of the software supply chain) python reference implementation.\n• OpenZiti - A full, open source zero trust overlay network. Including numerous SDKs for numerous languages such as golang allowing you to embed zero trust principles directly into your applications. The OpenZiti Test Kitchen has numerous examples to draw inspiration from including a zero trust ssh client - zssh\n• Spire - SPIRE (the SPIFFE Runtime Environment) is a toolchain of APIs for establishing trust between software systems across a wide variety of hosting platforms.\n\nSource code analysis tools, also known as Static Application Security Testing (SAST) Tools.\n• apicompat - Checks recent changes to a Go project for backwards incompatible changes.\n• asty - Converts golang AST to JSON and JSON to AST.\n• blanket - blanket is a tool that helps you catch functions which don't have direct unit tests in your Go packages.\n• ChainJacking - Find which of your Go lang direct GitHub dependencies is susceptible to ChainJacking attack.\n• errcheck - Errcheck is a program for checking for unchecked errors in Go programs.\n• go-checkstyle - checkstyle is a style check tool like java checkstyle. This tool inspired by java checkstyle, golint. The style referred to some points in Go Code Review Comments.\n• go-cleanarch - go-cleanarch was created to validate Clean Architecture rules, like a The Dependency Rule and interaction between packages in your Go projects.\n• go-critic - source code linter that brings checks that are currently not implemented in other linters.\n• go-mod-outdated - An easy way to find outdated dependencies of your Go projects.\n• goimports - Tool to fix (add, remove) your Go imports automatically.\n• golangci-lint – A fast Go linters runner. It runs linters in parallel, uses caching, supports config, has integrations with all major IDE and has dozens of linters included.\n• golines - Formatter that automatically shortens long lines in Go code.\n• GoPlantUML - Library and CLI that generates text plantump class diagram containing information about structures and interfaces with the relationship among them.\n• gostatus - Command line tool, shows the status of repositories that contain Go packages.\n• lint - Run linters as part of go test.\n• php-parser - A Parser for PHP written in Go.\n• staticcheck - staticcheck is on steroids, applying a ton of static analysis checks you might be used to from tools like ReSharper for C#.\n• tickgit - CLI and go package for surfacing code comment TODOs (in any language) and applying a to identify the author.\n• todocheck - Static code analyser which links TODO comments in code with issues in your issue tracker.\n• usestdlibvars - A linter that detect the possibility to use variables/constants from the Go standard library.\n• wrapcheck - A linter to check that errors from external packages are wrapped.\n• coc-go language server extension for Vim/Neovim - This plugin adds gopls features to Vim/Neovim.\n• Go Doc - A Visual Studio Code extension for showing definition in output and generating go doc.\n• Go plugin for JetBrains IDEs - Go plugin for JetBrains IDEs.\n• gocode - Autocompletion daemon for the Go programming language.\n• goprofiling - This extension adds benchmark profiling support for the Go language to VS Code.\n• GoSublime - Golang plugin collection for the text editor SublimeText 3 providing code completion and other IDE-like features.\n• gounit-vim - Vim plugin for generating Go tests based on the function's or method's signature.\n• vscode-go - Extension for Visual Studio Code (VS Code) which provides support for the Go language.\n• Watch - Runs a command in an acme win on file changes.\n• envdoc - generate documentation for environment variables from Go source files.\n• gocontracts - brings design-by-contract to Go by synchronizing the code with the documentation.\n• godal - Generate orm models corresponding to golang by specifying sql ddl file, which can be used by gorm.\n• gotests - Generate Go tests from your source code.\n• gounit - Generate Go tests using your own templates.\n• options-gen - Functional options described by Dave Cheney's post \"Functional options for friendly APIs\".\n• re2dfa - Transform regular expressions into finite state machines and output Go source code.\n• TOML-to-Go - Translates TOML into a Go type in the browser instantly.\n• decouple - Find “overspecified” function parameters that could be generalized with interface types.\n• depth - Visualize dependency trees of any package by analyzing imports.\n• docs - Automatically generate RESTful API documentation for GO projects - aligned with Open API Specification standard.\n• go-callvis - Visualize call graph of your Go program using dot format.\n• go-size-analyzer - Analyze and visualize the size of dependencies in compiled Golang binaries, providing insight into their impact on the final build.\n• go-swagger - Swagger 2.0 implementation for go. Swagger is a simple yet powerful representation of your RESTful API.\n• godbg - Implementation of Rusts macro for quick and easy debugging during development.\n• gomodrun - Go tool that executes and caches binaries included in go.mod files.\n• gothanks - GoThanks automatically stars your go.mod github dependencies, sending this way some love to their maintainers.\n• igo - An igo to go transpiler (new language features for Go language!)\n• modver - Compare two versions of a Go module to check the version-number change required (major, minor, or patchlevel), according to semver rules.\n• MoniGO - A performance monitoring library for Go applications. It provides real-time insights into application performance! 🚀\n• OctoLinker - Navigate through go files efficiently with the OctoLinker browser extension for GitHub.\n• roumon - Monitor current state of all active goroutines via a command line interface.\n• rts - RTS: response to struct. Generates Go structs from server responses.\n• textra - Extract Go struct field names, types and tags for filtering and exporting.\n• typex - Examine Go types and their transitive dependencies, alternatively export results as TypeScript value objects (or types) declaration.\n• abbreviate - abbreviate is a tool turning long strings in to shorter ones with configurable separators, for example to embed branch names in to deployment stack IDs.\n• DepCharge - Helps orchestrating the execution of commands across the many dependencies in larger projects.\n• Docker - Open platform for distributed applications for developers and sysadmins.\n• docker-go-mingw - Docker image for building Go binaries for Windows with MinGW toolchain.\n• Dockerfile-Generator - A go library and an executable that produces valid Dockerfiles using various input channels.\n• dogo - Monitoring changes in the source file and automatically compile and run (restart).\n• drone-scp - Copy files and artifacts via SSH using a binary, docker or Drone CI.\n• easyssh-proxy - Golang package for easy remote execution through SSH and SCP downloading via .\n• Flannel - Flannel is a network fabric for containers, designed for Kubernetes.\n• ghorg - Quickly clone an entire org/users repositories into one directory - Supports GitHub, GitLab, Gitea, and Bitbucket.\n• gitea-github-migrator - Migrate all your GitHub repositories, issues, milestones and labels to your Gitea instance.\n• go-furnace - Hosting solution written in Go. Deploy your Application with ease on AWS, GCP or DigitalOcean.\n• go-rocket-update - A simple way to make self updating Go applications - Supports Github and Gitlab.\n• go-selfupdate - Enable your Go applications to self update.\n• gobrew - gobrew lets you easily switch between multiple versions of go.\n• gobrew - Go version manager. Super simple tool to install and manage Go versions. Install go without root. Gobrew doesn't require shell rehash.\n• Gogs - A Self Hosted Git Service in the Go Programming Language.\n• gonative - Tool which creates a build of Go that can cross compile to all platforms while still using the Cgo-enabled versions of the stdlib packages.\n• govvv - “go build” wrapper to easily add version information into Go binaries.\n• grapes - Lightweight tool designed to distribute commands over ssh with ease.\n• GVM - GVM provides an interface to manage Go versions.\n• Hey - Hey is a tiny program that sends some load to a web application.\n• httpref - httpref is a handy CLI reference for HTTP methods, status codes, headers, and TCP and UDP ports.\n• jcli - Jenkins CLI allows you manage your Jenkins as an easy way.\n• k3d - Little helper to run CNCF's k3s in Docker.\n• k6 - A modern load testing tool, using Go and JavaScript.\n• ko - Command line tool for building and deploying Go applications on Kubernetes\n• kool - Command line tool for managing Docker environments as an easy way.\n• kubeblocks - KubeBlocks is an open-source control plane that runs and manages databases, message queues and other data infrastructure on K8s.\n• kubeshark - API traffic analyzer for Kubernetes, inspired by Wireshark, purposely built for Kubernetes.\n• KubeVPN - KubeVPN offers a Cloud-Native Dev Environment that seamlessly connects to your Kubernetes cluster network.\n• KusionStack - A unified programmable configuration techstack to deliver modern app in 'platform as code' and 'infra as code' approach.\n• lstags - Tool and API to sync Docker images across different registries.\n• manssh - manssh is a command line tool for managing your ssh alias config easily.\n• Mantil - Go specific framework for building serverless applications on AWS that enables you to focus on pure Go code while Mantil takes care of the infrastructure.\n• Moby - Collaborative project for the container ecosystem to assemble container-based systems.\n• ostent - collects and displays system metrics and optionally relays to Graphite and/or InfluxDB.\n• Packer - Packer is a tool for creating identical machine images for multiple platforms from a single source configuration.\n• PipeCD - A GitOps-style continuous delivery platform that provides consistent deployment and operations experience for any applications.\n• podinfo - Podinfo is a tiny web application made with Go that showcases best practices of running microservices in Kubernetes. Podinfo is used by CNCF projects like Flux and Flagger for end-to-end testing and workshops.\n• Rodent - Rodent helps you manage Go versions, projects and track dependencies.\n• s3-proxy - S3 Proxy with GET, PUT and DELETE methods and authentication (OpenID Connect and Basic Auth).\n• s3gof3r - Small utility/library optimized for high speed transfer of large objects into and out of Amazon S3.\n• Scaleway-cli - Manage BareMetal Servers from Command Line (as easily as with Docker).\n• script - Making it easy to write shell-like scripts in Go for DevOps and system administration tasks.\n• sg - Benchmarks a set of HTTP endpoints (like ab), with possibility to use the response code and data between each call for specific server stress based on its previous response.\n• skm - SKM is a simple and powerful SSH Keys Manager, it helps you to manage your multiple SSH keys easily!\n• StatusOK - Monitor your Website and REST APIs.Get Notified through Slack, E-mail when your server is down or response time is more than expected.\n• tau - Easily build Cloud Computing Platforms with features like Serverless WebAssembly Functions, Frontend Hosting, CI/CD, Object Storage, K/V Database, and Pub-Sub Messaging.\n• terraform-provider-openapi - Terraform provider plugin that dynamically configures itself at runtime based on an OpenAPI document (formerly known as swagger file) containing the definitions of the APIs exposed.\n• traefik - Reverse proxy and load balancer with support for multiple backends.\n• trubka - A CLI tool to manage and troubleshoot Apache Kafka clusters with the ability of generically publishing/consuming protocol buffer and plain text events to/from Kafka.\n• uTask - Automation engine that models and executes business processes declared in yaml.\n• Vegeta - HTTP load testing tool and library. It's over 9000!\n• wait-for - Wait for something to happen (from the command line) before continuing. Easy orchestration of Docker services and other things.\n• Better Go Playground - Go playground with syntax highlight, code completion and other features.\n• blocky - Fast and lightweight DNS proxy as ad-blocker for local network with many features.\n• Chapar - Chapar is a a cross-platform Postman alternative built with go, aims to help developers to test their api endpoints. it support http and grpc protocols.\n• Circuit - Circuit is a programmable platform-as-a-service (PaaS) and/or Infrastructure-as-a-Service (IaaS), for management, discovery, synchronization and orchestration of services and hosts comprising cloud applications.\n• confd - Manage local application configuration files using templates and data from etcd or consul.\n• croc - Easily and securely send files or folders from one computer to another.\n• dp - Through SDK for data exchange with blockchain, developers can get easy access to DAPP development.\n• Duplicacy - A cross-platform network and cloud backup tool based on the idea of lock-free deduplication.\n• Gebug - A tool that makes debugging of Dockerized Go applications super easy by enabling Debugger and Hot-Reload features, seamlessly.\n• gfile - Securely transfer files between two computers, without any third party, over WebRTC.\n• Go Package Store - App that displays updates for the Go packages in your GOPATH.\n• goblin - Cloud builder for CLI's written in go lang\n• gocc - Gocc is a compiler kit for Go written in Go.\n• GoDocTooltip - Chrome extension for Go Doc sites, which shows function description as tooltip at function list.\n• Gokapi - Lightweight server to share files, which expire after a set amount of downloads or days. Similar to Firefox Send, but without public upload.\n• GoNB - Interactive Go programming with Jupyter Notebooks (also works in VSCode, Binder and Google's Colab).\n• Gor - Http traffic replication tool, for replaying traffic from production to stage/dev environments in real-time.\n• Guora - A self-hosted Quora like web application written in Go.\n• hotswap - A complete solution to reload your go code without restarting your server, interrupting or blocking any ongoing procedure.\n• ide - Browser accessible IDE. Designed for Go with Go.\n• JuiceFS - Distributed POSIX file system built on top of Redis and AWS S3.\n• Juju - Cloud-agnostic service deployment and orchestration - supports EC2, Azure, Openstack, MAAS and more.\n• lgo - Interactive Go programming with Jupyter. It supports code completion, code inspection and 100% Go compatibility.\n• limetext - Lime Text is a powerful and elegant text editor primarily developed in Go that aims to be a Free and open-source software successor to Sublime Text.\n• mockingjay - Fake HTTP servers and consumer driven contracts from one configuration file. You can also make the server randomly misbehave to help do more realistic performance tests.\n• Neo-cowsay - 🐮 cowsay is reborn. for a New Era.\n• Orbit - A simple tool for running commands and generating files from templates.\n• peg - Peg, Parsing Expression Grammar, is an implementation of a Packrat parser generator.\n• Plik - Plik is a temporary file upload system (Wetransfer like) in Go.\n• portal - Portal is a quick and easy command-line file transfer utility from any computer to another.\n• sake - sake is a command runner for local and remote hosts.\n• scc - Sloc Cloc and Code, a very fast accurate code counter with complexity calculations and COCOMO estimates.\n• shell2http - Executing shell commands via http server (for prototyping or remote control).\n• Snitch - Simple way to notify your team and many tools when someone has deployed any application via Tsuru.\n• sonic - Sonic is a Go Blogging Platform. Simple and Powerful.\n• Stack Up - Stack Up, a super simple deployment tool - just Unix - think of it like 'make' for a network of servers.\n• tinycare-tui - Small terminal app that shows git commits from the last 24 hours and week, current weather, some self care advice, a joke, and you current todo list tasks.\n• toxiproxy - Proxy to simulate network and system conditions for automated tests.\n• vaku - CLI & API for folder-based functions in Vault like copy, move, and search.\n• Wave Terminal - Wave is an open-source, AI-native terminal built for seamless developer workflows with inline rendering, a modern UI, and persistent sessions.\n• wellington - Sass project management tool, extends the language with sprite functions (like Compass).\n\nWhere to discover new Go libraries.\n• autobench - Framework to compare the performance between different Go versions.\n• go-benchmark-app - Powerful HTTP-benchmark tool mixed with Аb, Wrk, Siege tools. Gathering statistics and various parameters for benchmarks and comparison results.\n• go-benchmarks - Few miscellaneous Go microbenchmarks. Compare some language features to alternative approaches.\n• go-ml-benchmarks - benchmarks for machine learning inference in Go.\n• gocostmodel - Benchmarks of common basic operations for the Go language.\n• golang-sql-benchmark - Collection of benchmarks for popular Go database/SQL utilities.\n• gospeed - Go micro-benchmarks for calculating the speed of language constructs.\n• speedtest-resize - Compare various Image resize algorithms for the Go language.\n• 100 Go Mistakes: How to Avoid Them\n• Black Hat Go - Go programming for hackers and pentesters.\n• Build an Orchestrator in Go\n• Continuous Delivery in Go - This practical guide to continuous delivery shows you how to rapidly establish an automated pipeline that will improve your testing, code quality, and final product.\n• Creative DIY Microcontroller Project With TinyGo and WebAssembly - An introduction into the TinyGo compiler with projects involving Arduino and WebAssembly.\n• Effective Go: Elegant, efficient, and testable code - Unlock Go’s unique perspective on program design, and start writing simple, maintainable, and testable Go code.\n• For the Love of Go - An introductory book for Go beginners.\n• Go in Practice, Second Edition - Your practical guide on the ins-and-outs of Go development, covering the standard library and the most important tools from Go’s powerful ecosystem.\n• Know Go: Generics - A guide to understanding and using generics in Go.\n• Lets-Go - A step-by-step guide to creating fast, secure and maintanable web applications with Go.\n• Lets-Go-Further - Advanced patterns for building APIs and web applications in Go.\n• The Power of Go: Tests - A guide to testing in Go.\n• The Power of Go: Tools - A guide to writing command-line tools in Go.\n• Writing An Interpreter In Go - Book that introduces dozens of techniques for writing idiomatic, expressive, and efficient Go code that avoids common pitfalls.\n• An Introduction to Programming in Go\n• Build a blockchain from scratch in Go with gRPC - The foundational and practical guide for effectively learning and progressively building a blockchain from scratch in Go with gRPC.\n• Go 101 - A book focusing on Go syntax/semantics and all kinds of details.\n• Go AST Book (Chinese) - A book focusing on Go packages.\n• Go Faster - This book seeks to shorten your learning curve and help you become a proficient Go programmer, faster.\n• Go with the domain - A book showing how to apply DDD, Clean Architecture, and CQRS by practical refactoring.\n• How To Code in Go eBook - A 600 page introduction to Go aimed at first time developers.\n• Spaceship Go A Journey to the Standard Library\n• The Golang Standard Library by Example (Chinese)\n• Web Application with Go the Anti-Textbook\n• Free Gophers Pack - Gopher graphics pack by Maria Letta with illustrations and emotional characters in vector and raster.\n\nAdd the group of your city/country here (send PR)\n• Awesome Go @LibHunt - Your go-to Go Toolbox.\n• Awesome Remote Job - Curated list of awesome remote jobs. A lot of them are looking for Go hackers.\n• awesome-go-extra - Parse awesome-go README file and generate a new README file with repo info.\n• CodinGame - Learn Go by solving interactive tasks using small games as practical examples.\n• Go Blog - The official Go blog.\n• Go Code Club - A group of Gophers read and discuss a different Go project every week.\n• Go Community on Hashnode - Community of Gophers on Hashnode.\n• Go Forum - Forum to discuss Go.\n• Go Projects - List of projects on the Go community wiki.\n• Go Proverbs - Go Proverbs by Rob Pike.\n• Go Report Card - A report card for your Go package.\n• gocryforhelp - Collection of Go projects that needs help. Good place to start your open-source way in Go.\n• Golang News - Links and news about Go programming.\n• Golang Nugget - A weekly roundup of the best Go content, delivered to your inbox every Monday.\n• Golang Weekly - Each monday projects, tutorials and articles about Go.\n• Google Plus Community - The Google+ community for #golang enthusiasts.\n• Gopher Community Chat - Join Our New Slack Community For Gophers (Understand how it came).\n• justforfunc - Youtube channel dedicated to Go programming language tips and tricks, hosted by Francesc Campoy @francesc.\n• Learn Go Programming - Learn Go concepts with illustrations.\n• studygolang - The community of studygolang in China.\n• Trending Go repositories on GitHub today - Good place to find new Go libraries.\n• 50 Shades of Go - Traps, Gotchas, and Common Mistakes for New Golang Devs.\n• A Comprehensive Guide to Structured Logging in Go - Delve deep into the world of structured logging in Go with a specific focus on recently accepted slog proposal which aims to bring high performance structured logging with levels to the standard library.\n• A Tour of Go - Interactive tour of Go.\n• Build a Database in 1000 lines of code - Build a NoSQL Database From Zero in 1000 Lines of Code.\n• Build web application with Golang - Golang ebook intro how to build a web app with golang.\n• Building and Testing a REST API in Go with Gorilla Mux and PostgreSQL - We’ll write an API with the help of the powerful Gorilla Mux.\n• Building Go Web Applications and Microservices Using Gin - Get familiar with Gin and find out how it can help you reduce boilerplate code and build a request handling pipeline.\n• CodeCrafters Golang Track - Achieve mastery in advanced Go by building your own Redis, Docker, Git, and SQLite. Featuring goroutines, systems programming, file I/O, and more.\n• Design Patterns in Go - Collection of programming design patterns implemented in Go.\n• Games With Go - A video series teaching programming and game development.\n• Go By Example - Hands-on introduction to Go using annotated example programs.\n• Go in 7 days - Learn everything about Go in 7 days (from a Nodejs developer).\n• go-patterns - Curated list of Go design patterns, recipes and idioms.\n• goapp - An opinionated guideline to structure & develop a Go web application/service.\n• Golang for Node.js Developers - Examples of Golang compared to Node.js for learning.\n• Golang Tutorial Guide - A List of Free Courses to Learn the Go Programming Language.\n• Golangbot - Tutorials to get started with programming in Go.\n• GopherCoding - Collection of code snippets and tutorials to help tackle every day issues.\n• GopherSnippets - Code snippets with tests and testable examples for the Go programming language.\n• Gosamples - Collection of code snippets that let you solve everyday code problems.\n• GraphQL with Go - Learn how to create a Go GraphQL server and client with code generation. Also includes creating REST endpoints.\n• Hackr.io - Learn Go from the best online golang tutorials submitted & voted by the golang programming community.\n• Hex Monscape - Getting started guidelines in writing maintainable code using Hexagonal Architecture.\n• How to Benchmark: dbq vs sqlx vs GORM - Learn how to benchmark in Go. As a case-study, we will benchmark dbq, sqlx and GORM.\n• How To Deploy a Go Web Application with Docker - Learn how to use Docker for Go development and how to build production Docker images.\n• How to Implement Role-Based Access Control (RBAC) Authorization in Golang - A guide to implementing Role-Based Access Control (RBAC) in Golang, including code examples, covering various methods to secure app endpoints with role-based authorization.\n• How to Use Godog for Behavior-driven Development in Go - Get started with Godog — a Behavior-driven development framework for building and testing Go applications.\n• Learn Go with 1000+ Exercises - Learn Go with thousands of examples, exercises, and quizzes.\n• Learn Go with TDD - Learn Go with test-driven development.\n• Learning Go by examples - Series of articles in order to learn Golang language by concrete applications as example.\n• Microservices with Go - Dive deep into building microservices using Go, including gRPC.\n• package main - YouTube channel about Programming in Go.\n• Programming with Google Go - Coursera Specialization to learn about Go from scratch.\n• Scaling Go Applications - Everything about building, deploying and scaling Go applications in production.\n• The world’s easiest introduction to WebAssembly with Golang\n• Understanding Go in a visual way - Learn Go visually\n• W3basic Go Tutorials - W3Basic provides an in-depth tutorial and well-organized content to learn Golang programming.\n• Your basic Go - Huge collection of tutorials and how to's.\n• The Go Developer Roadmap - A visual roadmap that new Go developers can follow through to help them learn Go.\n• The Go Learning Path - A guided learning path containing a mix of free and premium resources.\n• The Go Skill Tree - A structured learning path that combines both free and premium resources."
    },
    {
        "link": "https://pkg.go.dev/github.com/hajimehoshi/oto/v2",
        "document": "On some platforms you will need a C/C++ compiler in your path that Go can use.\n• iOS: On newer macOS versions type on your terminal and a dialog with installation instructions will appear if you don't have it\n• If you get an error with clang use xcode instead\n• Linux and other Unix systems: Should be installed by default, but if not try GCC or Clang\n\nOto requires , but this is automatically linked.\n\nAdd them to \"Linked Frameworks and Libraries\" on your Xcode project.\n\nALSA is required. On Ubuntu or Debian, run this command:\n\nIn most cases this command must be run by root user or through command.\n\nBSD systems are not tested well. If ALSA works, Oto should work.\n\nThe two main components of Oto are a and . The context handles interactions with the OS and audio drivers, and as such there can only be one context in your program.\n\nFrom a context you can create any number of different players, where each player is given an that it reads bytes representing sounds from and plays.\n\nNote that a single must not be used by multiple players.\n\nThe following is an example of loading and playing an MP3 file:\n\nThe above example loads the entire file into memory and then plays it. This is great for smaller files but might be an issue if you are playing a long song since it would take too much memory and too long to load.\n\nIn such cases you might want to stream the file. Luckily this is very simple, just use :\n\nThe only thing to note about streaming is that the file object must be kept alive, otherwise you might just play static.\n\nTo keep it alive not only must you be careful about when you close it, but you might need to keep a reference to the original file object alive (by for example keeping it in a struct).\n\nPlayers have their own internal audio data buffer, so while for example 200 bytes have been read from the that doesn't mean they were all played from the audio device.\n\nData is moved from io.Reader->internal buffer->audio device, and when the internal buffer moves data to the audio device is not guaranteed, so there might be a small delay. The amount of data in the buffer can be retrieved using .\n\nThe size of the underlying buffer of a player can also be set by type-asserting the player object:\n\nThis works because players implement a interface and a interface.\n\nCrosscompiling to macOS or Windows is as easy as setting or , respectively.\n\nTo crosscompile for other platforms, make sure the libraries for the target architecture are installed, and set as Go disables Cgo on crosscompiles by default."
    }
]