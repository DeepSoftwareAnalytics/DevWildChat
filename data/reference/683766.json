[
    {
        "link": "https://stackoverflow.com/questions/46789095/react-component-position-styling-best-practice",
        "document": "I wanted to get an understanding on what people would consider best practice for layout of their react components, and if the layout styling should or should not be tightly coupled within the component itself.\n\nSay I have a custom component that will be reused many times within the application, there may be times when I was them to be stacked Vertically down the page, with , whereas there may be cases I would like them spread out horizontally across the page with\n\nIt doesn't feel right if I were to have s, or other layout attributes tightly coupled with the component? I would have thought that I should be able to render by component in isolation, without it having positional styling coupled along with it?"
    },
    {
        "link": "https://stackoverflow.com/questions/55263077/how-to-set-absolute-positionning-in-react-component",
        "document": "i'm trying to create a custom button for my portfolio.\n\nThis button will be animated, the top part sliding in from left and the bottom part sliding in from right when hovered.\n\nAt the center of it will be the Category linked to this button.\n\nHow can i set my text in the center for every that i will create ? I can't use \"position: absolute\" property cause the reference would be the webpage and not the position where the custom component is declared..."
    },
    {
        "link": "https://zudemwango.medium.com/advanced-react-native-css-layout-techniques-9a6c4d59d9c7",
        "document": "As a mobile app developer one of the most crucial aspects of your job is ensuring that the layout of your app is visually appealing and intuitive for users. In React-Native there are a variety of layout options available including flexbox and absolute positioning. In this article, we will dive into advanced layout technique options in React-Native to create visually stunning and user-friendly apps. Whether you are a senior developer or just starting out in the field, these techniques will help you take your layout skills to the next level. So let’s get started!\n\nFlexbox is a powerful layout tool that can be used in React-Native to arrange elements in a container. It works by setting a parent element as a flex container and then defining the layout of its child elements as flex items.\n\nTo set the default flex-direction for a container you can use the flex-direction style property. This property can be set to either ‘row’, ‘column’, ‘row-reverse’ or ‘column-reverse’. Note: The default flex-direction for mobile is set to ‘column’, for example:\n\nWith the red element on the left, the blue element in the middle and the green element on the right, a row of three elements will be produced.\n\nYou can use the alignItems and justifyContent style attributes to align objects inside a flex container. While justifyContent regulates the alignment of items along the main axis, alignItems controls the alignment of items along the cross axis. You can set these properties to “flex-start,” “flex-end,” “center,” “stretch,” or “space-between.”\n\nFor instance, in the flex container from the previous example, to center the elements:\n\nWith a little practice, you’ll be a pro at using flexbox in no time!\n\nYou can begin investigating some of the more complex methods accessible once you’ve mastered the fundamentals of utilizing flexbox in React-Native.\n\nThe flexGrow and flexShrink style properties can be used as one such method. You may manage how big flex objects are in relation to one another within a container by using these parameters.\n\nThe amount of growth that a flex item should experience in comparison to the other things in the container is determined by the flexGrow attribute. Any positive number, with a higher number signifying more growth, can be used as the value. Consider this:\n\nWith the red element taking up 1/6 of the available space, the blue element taking up 1/3 of the available space, and the green element taking up 1/2 of the available space, this will result in a row of three elements.\n\nSimilar in operation, the flexShrink property specifies how much a flex item should contract when not enough room is present in the container. Any positive number, with a higher value signifying more shrinkage, may likewise be used.\n\nYou may design intricate and responsive layouts in React-Native by combining flexGrow and flexShrink with additional flexbox features.\n\nSpeaking of responsive layouts, media queries are another sophisticated flexbox method you may utilize. When designing for various platforms and devices, media queries make it possible to specify distinct styles for various screen sizes and resolutions.\n\nYou must obtain the width and height of the device screen using the Dimensions module in React-Native before you can utilize media queries. Then, dependent on the size of the screen, you may apply several styles using an if statement.\n\nHere’s an illustration of how you may use media queries in React-Native to make a responsive layout:\n\nIn this illustration, a parent container element is accompanied by three child elements (item1, item2, and item3). The width of the device screen is obtained using the Dimensions module, and depending on that width, several styles are then applied using an if statement. The three child items will be shown in a row if the screen is wider than 500 pixels. Only the first two child items will be shown on screens 500 pixels wide or less.\n\nThis example shows how to develop a responsive layout in React-Native that adapts to various screen sizes using media queries and the Dimensions module.\n\nWith these advanced flexbox techniques at your disposal, you’ll be able to create flexible and responsive layouts in React-Native like a pro!\n\nIn addition to utilizing flexbox for layout in React-Native, you can also utilize absolute positioning to place elements on the screen. The precise coordinates of an element within its parent container can be specified by using absolute positioning.\n\nYou must specify the position style attribute for the element you wish to place to “absolute” in order to use absolute positioning in React-Native. The distance between the element and each of the container’s boundaries can then be specified using the top, left, right, and bottom style parameters.\n\nThis will produce a red element that is 20 pixels away from its parent container’s top and left boundaries.\n\nIt’s vital to keep in mind that while employing absolute placement, the element will be out of the document’s natural flow and, if necessary, will overlap other elements. When constructing overlays or pop-ups, this can be helpful, but if not handled wisely, it can potentially provide unexpected outcomes.\n\nSetting the parent container’s position style property to “relative” will help you use absolute positioning. As opposed to the entire screen, you will now be able to arrange items relative to the parent container.\n\nInstead of being placed on the screen’s edges in this example, the red element will be placed 20 pixels from the top and left edges of the blue container.\n\nAbsolute positioning can be an effective technique in React-Native for designing exact layouts, but it must be used carefully to prevent layout problems. You can use absolute positioning efficiently in your projects with a little practice.\n\nFlexbox and absolute positioning in React-Native are two layout approaches that you may want to combine once you’ve mastered them. However, it’s necessary to be aware of the advantages and disadvantages of combining different layout strategies. This can be a great way to produce intricate and subtle layouts.\n\nOne way to combine layout methods is to use flexbox to organize elements in a container and absolute positioning to precisely position individual elements within that container.\n\nIn this example, the outer container uses flexbox to organize the elements in a column and align them to the center of the screen. The inner elements use absolute positioning to place themselves in the top left, top right, bottom left, and bottom right corners of the screen.\n\nNote that in this example, the outer container should have 100% height and width in order to cover the entire screen; otherwise, the absolute positioning might not work as expected. It's important to keep in mind that using absolute positioning to place elements can make your layout less responsive, so you might need to use media queries or other methods to adjust the positioning according to the screen size.\n\nDespite your best efforts, you could occasionally still run across layout problems in your React-Native apps. Layout problems, such as pieces that don’t align properly or unexpected overlaps, can be annoying to deal with. Here, we’ll look at several React-Native layout problems that are frequently encountered and discuss solutions.\n\nThe incorrect alignment of items within a container is a typical layout problem. This can be brought on by a number of problems, such as improper usage of the flexbox attributes or absolute placement.\n\nTry the next actions to resolve this problem:\n• Make sure your flexbox properties are set appropriately by checking them. Is the right flexDirection configured? Are the justifyContent and alignItems settings correctly set?\n• Make sure your absolute positioning properties are configured properly by checking them. Are the properties for top, left, right, and bottom set to the appropriate values?\n• Make sure the elements are correctly positioned by checking their size and measurements. The width and height properties should be set correctly, right?\n• Look for any nested containers that might be interfering with how the elements are laid out. Use the proper layout principles and properties in the nested containers.\n\nUnexpected overlaps between elements are another prevalent problem with the layout. Incorrect use of z-index values or absolute positioning can be the cause of this.\n\nTry the next actions to resolve this problem:\n• Make sure your absolute positioning properties are configured properly by checking them. Are the properties for top, left, right, and bottom set to the appropriate values?\n• Make sure the elements’ z-index values are accurately set by checking them. Higher values stack on top of lower values according to the z-index value, which controls how elements are stacked. To prevent overlap, ensure that the z-index values are adjusted appropriately\n• Look for any nested containers that might be interfering with how the elements are laid out. Use the proper layout principles and properties in the nested containers.\n\nThese are only a few illustrations of typical React-Native layout problems and solutions. You can rapidly find and correct layout errors in your projects with a little effort.\n\nThere are a few general guidelines you can abide by in addition to these troubleshooting techniques to make debugging layout difficulties easier:\n• Use the console and React-Native debugger to inspect elements and log values. This can assist you in determining the issue’s underlying cause.\n• For a real-time layout inspection of your app, use the React-Native Inspector tool. You can visualize the layout and spot any problems using this.\n• Use good layout design techniques, such as keeping your layout clean and uncomplicated and testing your layouts across many platforms and devices.\n\nWe’ve looked at a number of advanced layout strategies in React-Native in this post, including the use of flexbox, absolute positioning, and media queries. In order to design intricate and responsive layouts, we’ve also looked at how to combine and fix various strategies.\n\nThe layout of your React-Native app should be taken into account as early as possible in the design process because it greatly affects both the user experience and the overall success of your project. You’ll be well-equipped to design aesthetically pleasing and understandable layouts for your app with the sophisticated layout strategies described in this tutorial.\n\nRemember to keep practicing and experimenting with various strategies as you build your layout abilities to determine which ones are most effective for your projects. You’ll quickly become an expert at designing beautiful and functional layouts with a little practice and experimentation!"
    },
    {
        "link": "https://reddit.com/r/reactjs/comments/11x486h/best_way_to_style_react_apps_and_why",
        "document": "A community for discussing anything related to the React UI framework and its ecosystem. Join the Reactiflux Discord (reactiflux.com) for additional React discussion and help."
    },
    {
        "link": "https://matthewmacfarquhar.medium.com/styling-react-components-e5cbc8ee093d",
        "document": "I have been reading this book on React 18 and its best practices. As I go through this book, I will distill the core pieces of the most interesting tid-bits in this series of articles on React. In this article we will talk about a couple options we can take to style components in React and avoid polluting the global namespace with a bunch of styles which may clash. React offers three solutions for this: Inline styles, CSS modules and the Styled Components library.\n\nThe first option we have is inline styles, this is quite a departure from a conventional separation of concerns line of thinking we have all grown up with that mandates that markup is in an html, logic is in js scripts and styling is in a css file.\n\nHowever, just as React has pushed back on the logic+markup separation, they have also recommended using inline styles over storing styles in some other css file.\n\nThis allows us to do some cool things that we could not do normally if the CSS lived in its own file. For example, dynamically changing styles based on a component state like below.\n\nIf you wanted to emulate this, you would need to manually update the DOM node’s fontSize style property on each change. In this case inline React styles are at a huge advantage!\n\nHowever, inline styles do not allow pseudo-selector like :hover or media queries, so if you need some of those functionalities you would have to hack together a work around.\n\nAnother difficult problem with inline styles is that they make it hard to debug styling bugs, since each inline has its own style object we cannot use dev tools to easily change all the styling of a shared class at once.\n\nCSS modules are an option to write styles in a .css file BUT keep them locally scoped instead of global by transforming the readable styling class name into a hash which is unique across all class names in our project.\n\nTo use CSS modules, we need to set up Webpack and add some css and style loaders.\n\nThis Webpack has instructions for .module.css files to load them up and name the classes with the local className, two dashes and then a hash, this makes it much easier to find and debug our css classes from DevTools.\n\nWe need to declare the .css file as a type of importable file.\n\nAnd we will create our style sheet.\n\nWe can do everything we can in a regular style sheet AND we have an added feature of composable classes where we can build up css classes by inheriting the styles of other ones.\n\nNow, in our entry file (index.tsx), we can directly import and use our style module like so.\n\nThere is definitely a lot more overhead to get CSS modules working when compared with inlined components, BUT we get the full power of CSS and we can get some useful class names generated by Webpack to help debugging.\n\nUnfortunately we have lost the dynamic style updates based on state that we had with inlined components.\n\nOur last option is to use the styled components library. This library allows us to create styled DOM objects as JS objects and then use them in our code. We can use template strings to define the style which allows us to inject JS logic into the styles like we had done with inlined styling.\n\nWith this approach we get\n• The full power of CSS (e.x. pseudo-elements and media queries)\n• A shared className amongst the DOM nodes created using the styled component\n\nThe only major thing we miss that CSS modules provides is the ability to inject local readable class names with ease (Note: the styled-components library claims they can actually support this using babel https://styled-components.com/docs/tooling#babel-plugin but it was not as easily configurable as setting it up for CSS modules was).\n\nMy only other issue with the styled-component library is that that writing CSS in a template string is annoying, mostly because my IDE will not flag bugs I may be writing.\n\nIn this article, we explored three different ways to style react components. In my opinion, the obvious winner is the styled-components library which offers the JS interpolated styles of inline components + the full scope of CSS features we get by using CSS modules and shared classNames amongst like components. My only — small — gripe is the UX for writing these styled-component CSSs in a string is annoying."
    },
    {
        "link": "https://legacy.reactjs.org/docs/components-and-props.html",
        "document": "Components let you split the UI into independent, reusable pieces, and think about each piece in isolation. This page provides an introduction to the idea of components. You can find a detailed component API reference here.\n\nConceptually, components are like JavaScript functions. They accept arbitrary inputs (called “props”) and return React elements describing what should appear on the screen.\n\nThe simplest way to define a component is to write a JavaScript function:\n\nThis function is a valid React component because it accepts a single “props” (which stands for properties) object argument with data and returns a React element. We call such components “function components” because they are literally JavaScript functions.\n\nYou can also use an ES6 class to define a component:\n\nThe above two components are equivalent from React’s point of view.\n\nFunction and Class components both have some additional features that we will discuss in the next sections.\n\nPreviously, we only encountered React elements that represent DOM tags:\n\nHowever, elements can also represent user-defined components:\n\nWhen React sees an element representing a user-defined component, it passes JSX attributes and children to this component as a single object. We call this object “props”.\n\nFor example, this code renders “Hello, Sara” on the page:\n\nTry it on CodePen\n\nLet’s recap what happens in this example:\n• We call with the element.\n• React calls the component with as the props.\n• Our component returns a element as the result.\n\nComponents can refer to other components in their output. This lets us use the same component abstraction for any level of detail. A button, a form, a dialog, a screen: in React apps, all those are commonly expressed as components.\n\nFor example, we can create an component that renders many times:\n\nTry it on CodePen\n\nTypically, new React apps have a single component at the very top. However, if you integrate React into an existing app, you might start bottom-up with a small component like and gradually work your way to the top of the view hierarchy.\n\nDon’t be afraid to split components into smaller components.\n\nFor example, consider this component:\n\nTry it on CodePen\n\nIt accepts (an object), (a string), and (a date) as props, and describes a comment on a social media website.\n\nThis component can be tricky to change because of all the nesting, and it is also hard to reuse individual parts of it. Let’s extract a few components from it.\n\nFirst, we will extract :\n\nThe doesn’t need to know that it is being rendered inside a . This is why we have given its prop a more generic name: rather than .\n\nWe recommend naming props from the component’s own point of view rather than the context in which it is being used.\n\nWe can now simplify a tiny bit:\n\nNext, we will extract a component that renders an next to the user’s name:\n\nThis lets us simplify even further:\n\nTry it on CodePen\n\nExtracting components might seem like grunt work at first, but having a palette of reusable components pays off in larger apps. A good rule of thumb is that if a part of your UI is used several times ( , , ), or is complex enough on its own ( , , ), it is a good candidate to be extracted to a separate component.\n\nWhether you declare a component as a function or a class, it must never modify its own props. Consider this function:\n\nSuch functions are called “pure” because they do not attempt to change their inputs, and always return the same result for the same inputs.\n\nIn contrast, this function is impure because it changes its own input:\n\nReact is pretty flexible but it has a single strict rule:\n\nAll React components must act like pure functions with respect to their props.\n\nOf course, application UIs are dynamic and change over time. In the next section, we will introduce a new concept of “state”. State allows React components to change their output over time in response to user actions, network responses, and anything else, without violating this rule."
    },
    {
        "link": "https://react.dev/learn",
        "document": "Welcome to the React documentation! This page will give you an introduction to 80% of the React concepts that you will use on a daily basis.\n• How to create and nest components\n• How to add markup and styles\n• How to render conditions and lists\n• How to respond to events and update the screen\n• How to share data between components React apps are made out of components. A component is a piece of the UI (user interface) that has its own logic and appearance. A component can be as small as a button, or as large as an entire page. Now that you’ve declared , you can nest it into another component: Welcome to my app\n\n Notice that starts with a capital letter. That’s how you know it’s a React component. React component names must always start with a capital letter, while HTML tags must be lowercase. Have a look at the result:\n\nThe keywords specify the main component in the file. If you’re not familiar with some piece of JavaScript syntax, MDN and javascript.info have great references. The markup syntax you’ve seen above is called JSX. It is optional, but most React projects use JSX for its convenience. All of the tools we recommend for local development support JSX out of the box. JSX is stricter than HTML. You have to close tags like . Your component also can’t return multiple JSX tags. You have to wrap them into a shared parent, like a or an empty wrapper: Hello there. How do you do?\n\n If you have a lot of HTML to port to JSX, you can use an online converter. In React, you specify a CSS class with . It works the same way as the HTML attribute: Then you write the CSS rules for it in a separate CSS file: React does not prescribe how you add CSS files. In the simplest case, you’ll add a tag to your HTML. If you use a build tool or a framework, consult its documentation to learn how to add a CSS file to your project. JSX lets you put markup into JavaScript. Curly braces let you “escape back” into JavaScript so that you can embed some variable from your code and display it to the user. For example, this will display : You can also “escape into JavaScript” from JSX attributes, but you have to use curly braces instead of quotes. For example, passes the string as the CSS class, but reads the JavaScript variable value, and then passes that value as the attribute: You can put more complex expressions inside the JSX curly braces too, for example, string concatenation:\n\nIn the above example, is not a special syntax, but a regular object inside the JSX curly braces. You can use the attribute when your styles depend on JavaScript variables. In React, there is no special syntax for writing conditions. Instead, you’ll use the same techniques as you use when writing regular JavaScript code. For example, you can use an statement to conditionally include JSX: If you prefer more compact code, you can use the conditional operator. Unlike , it works inside JSX: When you don’t need the branch, you can also use a shorter logical syntax: All of these approaches also work for conditionally specifying attributes. If you’re unfamiliar with some of this JavaScript syntax, you can start by always using . You will rely on JavaScript features like loop and the array function to render lists of components. For example, let’s say you have an array of products: Inside your component, use the function to transform an array of products into an array of items: Notice how has a attribute. For each item in a list, you should pass a string or a number that uniquely identifies that item among its siblings. Usually, a key should be coming from your data, such as a database ID. React uses your keys to know what happened if you later insert, delete, or reorder the items.\n\nYou can respond to events by declaring event handler functions inside your components: Notice how has no parentheses at the end! Do not call the event handler function: you only need to pass it down. React will call your event handler when the user clicks the button. Often, you’ll want your component to “remember” some information and display it. For example, maybe you want to count the number of times a button is clicked. To do this, add state to your component. Now you can declare a state variable inside your component: You’ll get two things from : the current state ( ), and the function that lets you update it ( ). You can give them any names, but the convention is to write . The first time the button is displayed, will be because you passed to . When you want to change state, call and pass the new value to it. Clicking this button will increment the counter: React will call your component function again. This time, will be . Then it will be . And so on. If you render the same component multiple times, each will get its own state. Click each button separately:\n\nNotice how each button “remembers” its own state and doesn’t affect other buttons. Functions starting with are called Hooks. is a built-in Hook provided by React. You can find other built-in Hooks in the API reference. You can also write your own Hooks by combining the existing ones. Hooks are more restrictive than other functions. You can only call Hooks at the top of your components (or other Hooks). If you want to use in a condition or a loop, extract a new component and put it there. In the previous example, each had its own independent , and when each button was clicked, only the for the button clicked changed: The first updates its to However, often you’ll need components to share data and always update together. To make both components display the same and update together, you need to move the state from the individual buttons “upwards” to the closest component containing all of them. In this example, it is : Initially, ’s state is and is passed down to both children On click, updates its state to and passes it down to both children Now when you click either button, the in will change, which will change both of the counts in . Here’s how you can express this in code. First, move the state up from into : Then, pass the state down from to each , together with the shared click handler. You can pass information to using the JSX curly braces, just like you previously did with built-in tags like : The information you pass down like this is called props. Now the component contains the state and the event handler, and passes both of them down as props to each of the buttons. Finally, change to read the props you have passed from its parent component: When you click the button, the handler fires. Each button’s prop was set to the function inside , so the code inside of it runs. That code calls , incrementing the state variable. The new value is passed as a prop to each button, so they all show the new value. This is called “lifting state up”. By moving state up, you’ve shared it between components."
    },
    {
        "link": "https://geeksforgeeks.org/reactjs-functional-components",
        "document": "In ReactJS, functional components are a core part of building user interfaces. They are simple, lightweight, and powerful tools for rendering UI and handling logic. Functional components can accept props as input and return JSX that describes what the component should render.\n\nReactJS functional components are JavaScript functions that return a JSX element, which is a template used to define the component’s structure. JSX looks similar to HTML, but it has a special syntax that lets it be converted into JavaScript code.\n• Stateless (before hooks) : Originally, functional components were stateless and used only for rendering UI based on props.\n• Simpler Syntax: They are defined as JavaScript functions, leading to cleaner and more readable code.\n• No, this keyword: Unlike class components, functional components do not have a this context.\n• Hooks: With hooks, functional components can manage state and side effects, making them just as powerful as class components.\n\nIn the example above:\n• None MyComp is a functional component that takes props as an argument.\n• None It returns a JSX element (<div>Hello, {props.name}!</div>), which will be rendered to the screen.\n\nWhen a functional component receives input and is rendered, React uses props and updates the virtual DOM to ensure the UI reflects the current state.\n\nHere’s a breakdown of how this process works:\n• Props: Functional components receive input data through props, which are objects containing key-value pairs.\n• Processing Props: After receiving props, the component processes them and returns a JSX element that defines the component’s structure and content.\n• Virtual DOM: When the component is rendered, React creates a virtual DOM tree that represents the current state of the application.\n• Re-rendering: If the component’s props or state change, React updates the virtual DOM tree accordingly and triggers the component to re-render.\n• Simplicity: Functional components are simpler and easier to read than class components, making them ideal for small to medium-sized projects.\n• Performance: Functional components are faster than class components because they don’t use the this keyword, which can slow down rendering.\n• Testability: Functional components are easier to test because they are stateless and don’t rely on lifecycle methods.\n• Reusability: Functional components can be reused across multiple projects, making them a great choice for building component libraries.\n\nWhen to Use ReactJS Functional Components\n\nFunctional components should be used whenever possible because they are simpler, easier to test, and more performant than class components. However, there are a few cases where functional components may not be suitable:\n• Stateful components: Functional components cannot hold state on their own. Therefore, if you need to maintain state within your component, you may need to use a class component.\n• Lifecycle methods: If you need to use lifecycle methods such as componentDidMount, componentDidUpdate, or componentWillUnmount, you will need to use a class component.\n\nHow to Pass Props to a ReactJS Functional Component\n\nProps are used to pass data from a parent component to a child component. Props are read-only and allow you to make a component dynamic by passing different values into it.\n• None In the App.js component, we are passing a name prop to the Greeting component.\n• None In Greeting.js, the name prop is accessed using props.name, and it is used to dynamically display the greeting message.\n\nAre functional components better than class components?"
    },
    {
        "link": "https://react.dev/learn/thinking-in-react",
        "document": "React can change how you think about the designs you look at and the apps you build. When you build a user interface with React, you will first break it apart into pieces called components. Then, you will describe the different visual states for each of your components. Finally, you will connect your components together so that the data flows through them. In this tutorial, we’ll guide you through the thought process of building a searchable product data table with React. Imagine that you already have a JSON API and a mockup from a designer. The JSON API returns some data that looks like this: The mockup looks like this: To implement a UI in React, you will usually follow the same five steps. Start by drawing boxes around every component and subcomponent in the mockup and naming them. If you work with a designer, they may have already named these components in their design tool. Ask them! Depending on your background, you can think about splitting up a design into components in different ways:\n• Programming—use the same techniques for deciding if you should create a new function or object. One such technique is the single responsibility principle, that is, a component should ideally only do one thing. If it ends up growing, it should be decomposed into smaller subcomponents.\n• CSS—consider what you would make class selectors for. (However, components are a bit less granular.)\n• Design—consider how you would organize the design’s layers. If your JSON is well-structured, you’ll often find that it naturally maps to the component structure of your UI. That’s because UI and data models often have the same information architecture—that is, the same shape. Separate your UI into components, where each component matches one piece of your data model. There are five components on this screen:\n\nIf you look at (lavender), you’ll see that the table header (containing the “Name” and “Price” labels) isn’t its own component. This is a matter of preference, and you could go either way. For this example, it is a part of because it appears inside the ’s list. However, if this header grows to be complex (e.g., if you add sorting), you can move it into its own component. Now that you’ve identified the components in the mockup, arrange them into a hierarchy. Components that appear within another component in the mockup should appear as a child in the hierarchy: Now that you have your component hierarchy, it’s time to implement your app. The most straightforward approach is to build a version that renders the UI from your data model without adding any interactivity… yet! It’s often easier to build the static version first and add interactivity later. Building a static version requires a lot of typing and no thinking, but adding interactivity requires a lot of thinking and not a lot of typing. To build a static version of your app that renders your data model, you’ll want to build components that reuse other components and pass data using props. Props are a way of passing data from parent to child. (If you’re familiar with the concept of state, don’t use state at all to build this static version. State is reserved only for interactivity, that is, data that changes over time. Since this is a static version of the app, you don’t need it.) You can either build “top down” by starting with building the components higher up in the hierarchy (like ) or “bottom up” by working from components lower down (like ). In simpler examples, it’s usually easier to go top-down, and on larger projects, it’s easier to go bottom-up.\n\nAfter building your components, you’ll have a library of reusable components that render your data model. Because this is a static app, the components will only return JSX. The component at the top of the hierarchy ( ) will take your data model as a prop. This is called one-way data flow because the data flows down from the top-level component to the ones at the bottom of the tree. At this point, you should not be using any state values. That’s for the next step! Step 3: Find the minimal but complete representation of UI state To make the UI interactive, you need to let users change your underlying data model. You will use state for this. Think of state as the minimal set of changing data that your app needs to remember. The most important principle for structuring state is to keep it DRY (Don’t Repeat Yourself). Figure out the absolute minimal representation of the state your application needs and compute everything else on-demand. For example, if you’re building a shopping list, you can store the items as an array in state. If you want to also display the number of items in the list, don’t store the number of items as another state value—instead, read the length of your array. Now think of all of the pieces of data in this example application:\n• The search text the user has entered\n• The value of the checkbox Which of these are state? Identify the ones that are not:\n• Does it remain unchanged over time? If so, it isn’t state.\n• Is it passed in from a parent via props? If so, it isn’t state.\n• Can you compute it based on existing state or props in your component? If so, it definitely isn’t state! Let’s go through them one by one again:\n• The original list of products is passed in as props, so it’s not state.\n• The search text seems to be state since it changes over time and can’t be computed from anything.\n• The value of the checkbox seems to be state since it changes over time and can’t be computed from anything.\n• The filtered list of products isn’t state because it can be computed by taking the original list of products and filtering it according to the search text and value of the checkbox. This means only the search text and the value of the checkbox are state! Nicely done! There are two types of “model” data in React: props and state. The two are very different:\n• Props are like arguments you pass to a function. They let a parent component pass data to a child component and customize its appearance. For example, a can pass a prop to a .\n• State is like a component’s memory. It lets a component keep track of some information and change it in response to interactions. For example, a might keep track of state. Props and state are different, but they work together. A parent component will often keep some information in state (so that it can change it), and pass it down to child components as their props. It’s okay if the difference still feels fuzzy on the first read. It takes a bit of practice for it to really stick! Step 4: Identify where your state should live After identifying your app’s minimal state data, you need to identify which component is responsible for changing this state, or owns the state. Remember: React uses one-way data flow, passing data down the component hierarchy from parent to child component. It may not be immediately clear which component should own what state. This can be challenging if you’re new to this concept, but you can figure it out by following these steps! For each piece of state in your application:\n• Identify every component that renders something based on that state.\n• Find their closest common parent component—a component above them all in the hierarchy.\n• Decide where the state should live:\n• Often, you can put the state directly into their common parent.\n• You can also put the state into some component above their common parent.\n• If you can’t find a component where it makes sense to own the state, create a new component solely for holding the state and add it somewhere in the hierarchy above the common parent component. In the previous step, you found two pieces of state in this application: the search input text, and the value of the checkbox. In this example, they always appear together, so it makes sense to put them into the same place. Now let’s run through our strategy for them:\n• Identify components that use state:\n• needs to filter the product list based on that state (search text and checkbox value).\n• needs to display that state (search text and checkbox value).\n• Find their common parent: The first parent component both components share is .\n• Decide where the state lives: We’ll keep the filter text and checked state values in . So the state values will live in . Add state to the component with the Hook. Hooks are special functions that let you “hook into” React. Add two state variables at the top of and specify their initial state: Then, pass and to and as props: You can start seeing how your application will behave. Edit the initial value from to in the sandbox code below. You’ll see both the search input text and the table update:\n\nNotice that editing the form doesn’t work yet. There is a console error in the sandbox above explaining why: You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. In the sandbox above, and read the and props to render the table, the input, and the checkbox. For example, here is how populates the input value: However, you haven’t added any code to respond to the user actions like typing yet. This will be your final step. Currently your app renders correctly with props and state flowing down the hierarchy. But to change the state according to user input, you will need to support data flowing the other way: the form components deep in the hierarchy need to update the state in . React makes this data flow explicit, but it requires a little more typing than two-way data binding. If you try to type or check the box in the example above, you’ll see that React ignores your input. This is intentional. By writing , you’ve set the prop of the to always be equal to the state passed in from . Since state is never set, the input never changes. You want to make it so whenever the user changes the form inputs, the state updates to reflect those changes. The state is owned by , so only it can call and . To let update the ’s state, you need to pass these functions down to : Inside the , you will add the event handlers and set the parent state from them:"
    },
    {
        "link": "https://reactnative.dev/docs/intro-react",
        "document": "React Native runs on React, a popular open source library for building user interfaces with JavaScript. To make the most of React Native, it helps to understand React itself. This section can get you started or can serve as a refresher course.\n\nWe’re going to cover the core concepts behind React:\n\nIf you want to dig deeper, we encourage you to check out React’s official documentation.\n\nThe rest of this introduction to React uses cats in its examples: friendly, approachable creatures that need names and a cafe to work in. Here is your very first Cat component:\n\nHere is how you do it: To define your component, first use JavaScript’s to import React and React Native’s Core Component:\n\nYou can think of components as blueprints. Whatever a function component returns is rendered as a React element. React elements let you describe what you want to see on the screen.\n\nHere the component will render a element:\n\nYou can export your function component with JavaScript’s for use throughout your app like so:\n\nNow take a closer look at that statement. is using a kind of JavaScript syntax that makes writing elements convenient: JSX.\n\nReact and React Native use JSX, a syntax that lets you write elements inside JavaScript like so: . The React docs have a comprehensive guide to JSX you can refer to learn even more. Because JSX is JavaScript, you can use variables inside it. Here you are declaring a name for the cat, , and embedding it with curly braces inside .\n\nAny JavaScript expression will work between curly braces, including function calls like :\n\nYou can think of curly braces as creating a portal into JS functionality in your JSX!\n\nYou’ve already met React Native’s Core Components. React lets you nest these components inside each other to create new components. These nestable, reusable components are at the heart of the React paradigm.\n\nFor example, you can nest and inside a below, and React Native will render them together:\n\nYou can render this component multiple times and in multiple places without repeating your code by using :\n\nAny component that renders other components is a parent component. Here, is the parent component and each is a child component.\n\nYou can put as many cats in your cafe as you like. Each renders a unique element—which you can customize with props.\n\nProps is short for “properties”. Props let you customize React components. For example, here you pass each a different for to render:\n\nMost of React Native’s Core Components can be customized with props, too. For example, when using , you pass it a prop named to define what image it shows:\n\nhas many different props, including , which accepts a JS object of design and layout related property-value pairs.\n\nYou can build many things with props and the Core Components , , and ! But to build something interactive, you’ll need state.\n\nWhile you can think of props as arguments you use to configure how components render, state is like a component’s personal data storage. State is useful for handling data that changes over time or that comes from user interaction. State gives your components memory!\n\nThe following example takes place in a cat cafe where two hungry cats are waiting to be fed. Their hunger, which we expect to change over time (unlike their names), is stored as state. To feed the cats, press their buttons—which will update their state.\n\nYou can add state to a component by calling React’s Hook. A Hook is a kind of function that lets you “hook into” React features. For example, is a Hook that lets you add state to function components. You can learn more about other kinds of Hooks in the React documentation.\n\nFirst, you will want to import from React like so:\n\nThen you declare the component’s state by calling inside its function. In this example, creates an state variable:\n• it creates a “state variable” with an initial value—in this case the state variable is and its initial value is\n• it creates a function to set that state variable’s value—\n\nIt doesn’t matter what names you use. But it can be handy to think of the pattern as .\n\nNext you add the Core Component and give it an prop:\n\nNow, when someone presses the button, will fire, calling the . This sets the state variable to . When is false, the ’s prop is set to and its also changes:\n\nNow that you’ve covered both React and React Native’s Core Components, let’s dive deeper on some of these core components by looking at handling ."
    }
]