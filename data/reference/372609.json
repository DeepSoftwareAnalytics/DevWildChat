[
    {
        "link": "https://docs.python.org/3/howto/sorting.html",
        "document": "Python lists have a built-in method that modifies the list in-place. There is also a built-in function that builds a new sorted list from an iterable.\n\nIn this document, we explore the various techniques for sorting data using Python.\n\nA simple ascending sort is very easy: just call the function. It returns a new sorted list: You can also use the method. It modifies the list in-place (and returns to avoid confusion). Usually it’s less convenient than - but if you don’t need the original list, it’s slightly more efficient. Another difference is that the method is only defined for lists. In contrast, the function accepts any iterable.\n\nBoth and have a key parameter to specify a function (or other callable) to be called on each list element prior to making comparisons. \"This is a test string from Andrew\" ['a', 'Andrew', 'from', 'is', 'string', 'test', 'This'] The value of the key parameter should be a function (or other callable) that takes a single argument and returns a key to use for sorting purposes. This technique is fast because the key function is called exactly once for each input record. A common pattern is to sort complex objects using some of the object’s indices as keys. For example: The same technique works for objects with named attributes. For example: Objects with named attributes can be made by a regular class as shown above, or they can be instances of or a named tuple.\n\nThe key function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster. The module has , , and a function. Using those functions, the above examples become simpler and faster: The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age: The module provides another helpful tool for making key-functions. The function can reduce the arity of a multi-argument function making it suitable for use as a key-function.\n\nSorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. Notice how the two records for blue retain their original order so that is guaranteed to precede . This wonderful property lets you build complex sorts in a series of sorting steps. For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: This can be abstracted out into a wrapper function that can take a list and tuples of field and order to sort them on multiple passes. The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset.\n\nThis idiom is called Decorate-Sort-Undecorate after its three steps:\n• None First, the initial list is decorated with new values that control the sort order.\n• None Second, the decorated list is sorted.\n• None Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list, but including it gives two benefits:\n• None The sort is stable – if two items have the same key, their order will be preserved in the sorted list.\n• None The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. Now that Python sorting provides key-functions, this technique is not often needed.\n\nUnlike key functions that return an absolute value for sorting, a comparison function computes the relative ordering for two inputs. For example, a balance scale compares two samples giving a relative ordering: lighter, equal, or heavier. Likewise, a comparison function such as will return a negative value for less-than, zero if the inputs are equal, or a positive value for greater-than. It is common to encounter comparison functions when translating algorithms from other languages. Also, some libraries provide comparison functions as part of their API. For example, is a comparison function. To accommodate those situations, Python provides to wrap the comparison function to make it usable as a key function:\n• None For locale aware sorting, use for a key function or for a comparison function. This is necessary because “alphabetical” sort orderings can vary across cultures even if the underlying alphabet is the same.\n• None The reverse parameter still maintains sort stability (so that records with equal keys retain the original order). Interestingly, that effect can be simulated without the parameter by using the builtin function twice:\n• None The sort routines use when making comparisons between two objects. So, it is easy to add a standard sort order to a class by defining an method: However, note that can fall back to using if is not implemented (see for details on the mechanics). To avoid surprises, PEP 8 recommends that all six comparison methods be implemented. The decorator is provided to make that task easier.\n• None Key functions need not depend directly on the objects being sorted. A key function can also access external resources. For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names:"
    },
    {
        "link": "https://docs.python.org/3.10/howto/sorting.html",
        "document": "Python lists have a built-in method that modifies the list in-place. There is also a built-in function that builds a new sorted list from an iterable.\n\nIn this document, we explore the various techniques for sorting data using Python.\n\nA simple ascending sort is very easy: just call the function. It returns a new sorted list: You can also use the method. It modifies the list in-place (and returns to avoid confusion). Usually it’s less convenient than - but if you don’t need the original list, it’s slightly more efficient. Another difference is that the method is only defined for lists. In contrast, the function accepts any iterable.\n\nBoth and have a key parameter to specify a function (or other callable) to be called on each list element prior to making comparisons. \"This is a test string from Andrew\" ['a', 'Andrew', 'from', 'is', 'string', 'test', 'This'] The value of the key parameter should be a function (or other callable) that takes a single argument and returns a key to use for sorting purposes. This technique is fast because the key function is called exactly once for each input record. A common pattern is to sort complex objects using some of the object’s indices as keys. For example: The same technique works for objects with named attributes. For example:\n\nThe key-function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster. The module has , , and a function. Using those functions, the above examples become simpler and faster: The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age:\n\nSorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. Notice how the two records for blue retain their original order so that is guaranteed to precede . This wonderful property lets you build complex sorts in a series of sorting steps. For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: This can be abstracted out into a wrapper function that can take a list and tuples of field and order to sort them on multiple passes. The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset.\n\nThe Old Way Using Decorate-Sort-Undecorate¶ This idiom is called Decorate-Sort-Undecorate after its three steps:\n• None First, the initial list is decorated with new values that control the sort order.\n• None Second, the decorated list is sorted.\n• None Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list, but including it gives two benefits:\n• None The sort is stable – if two items have the same key, their order will be preserved in the sorted list.\n• None The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. Now that Python sorting provides key-functions, this technique is not often needed.\n\nThe Old Way Using the cmp Parameter¶ Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no builtin and took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the magic method). In Py2.x, sort allowed an optional function which can be called for doing the comparisons. That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than. For example, we can do: Or you can reverse the order of comparison with: When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function. The following wrapper makes that easy to do: To convert to a key function, just wrap the old comparison function: In Python 3.2, the function was added to the module in the standard library."
    },
    {
        "link": "https://docs.python.org/3/library/functions.html",
        "document": "The Python interpreter has a number of functions and types built into it that are always available. They are listed here in alphabetical order.\n\nOpen file and return a corresponding file object. If the file cannot be opened, an is raised. See Reading and Writing Files for more examples of how to use this function. file is a path-like object giving the pathname (absolute or relative to the current working directory) of the file to be opened or an integer file descriptor of the file to be wrapped. (If a file descriptor is given, it is closed when the returned I/O object is closed unless closefd is set to .) mode is an optional string that specifies the mode in which the file is opened. It defaults to which means open for reading in text mode. Other common values are for writing (truncating the file if it already exists), for exclusive creation, and for appending (which on some Unix systems, means that all writes append to the end of the file regardless of the current seek position). In text mode, if encoding is not specified the encoding used is platform-dependent: is called to get the current locale encoding. (For reading and writing raw bytes use binary mode and leave encoding unspecified.) The available modes are: open for writing, truncating the file first open for exclusive creation, failing if the file already exists open for writing, appending to the end of file if it exists The default mode is (open for reading text, a synonym of ). Modes and open and truncate the file. Modes and open the file with no truncation. As mentioned in the Overview, Python distinguishes between binary and text I/O. Files opened in binary mode (including in the mode argument) return contents as objects without any decoding. In text mode (the default, or when is included in the mode argument), the contents of the file are returned as , the bytes having been first decoded using a platform-dependent encoding or using the specified encoding if given. Python doesn’t depend on the underlying operating system’s notion of text files; all the processing is done by Python itself, and is therefore platform-independent. buffering is an optional integer used to set the buffering policy. Pass 0 to switch buffering off (only allowed in binary mode), 1 to select line buffering (only usable when writing in text mode), and an integer > 1 to indicate the size in bytes of a fixed-size chunk buffer. Note that specifying a buffer size this way applies for binary buffered I/O, but (i.e., files opened with ) would have another buffering. To disable buffering in , consider using the flag for . When no buffering argument is given, the default buffering policy works as follows:\n• None Binary files are buffered in fixed-size chunks; the size of the buffer is chosen using a heuristic trying to determine the underlying device’s “block size” and falling back on . On many systems, the buffer will typically be 4096 or 8192 bytes long.\n• None “Interactive” text files (files for which returns ) use line buffering. Other text files use the policy described above for binary files. encoding is the name of the encoding used to decode or encode the file. This should only be used in text mode. The default encoding is platform dependent (whatever returns), but any text encoding supported by Python can be used. See the module for the list of supported encodings. errors is an optional string that specifies how encoding and decoding errors are to be handled—this cannot be used in binary mode. A variety of standard error handlers are available (listed under Error Handlers), though any error handling name that has been registered with is also valid. The standard names include:\n• None to raise a exception if there is an encoding error. The default value of has the same effect.\n• None ignores errors. Note that ignoring encoding errors can lead to data loss.\n• None causes a replacement marker (such as ) to be inserted where there is malformed data.\n• None will represent any incorrect bytes as low surrogate code units ranging from U+DC80 to U+DCFF. These surrogate code units will then be turned back into the same bytes when the error handler is used when writing data. This is useful for processing files in an unknown encoding.\n• None is only supported when writing to a file. Characters not supported by the encoding are replaced with the appropriate XML character reference .\n• None (also only supported when writing) replaces unsupported characters with escape sequences. newline determines how to parse newline characters from the stream. It can be , , , , and . It works as follows:\n• None When reading input from the stream, if newline is , universal newlines mode is enabled. Lines in the input can end in , , or , and these are translated into before being returned to the caller. If it is , universal newlines mode is enabled, but line endings are returned to the caller untranslated. If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated.\n• None When writing output to the stream, if newline is , any characters written are translated to the system default line separator, . If newline is or , no translation takes place. If newline is any of the other legal values, any characters written are translated to the given string. If closefd is and a file descriptor rather than a filename was given, the underlying file descriptor will be kept open when the file is closed. If a filename is given closefd must be (the default); otherwise, an error will be raised. A custom opener can be used by passing a callable as opener. The underlying file descriptor for the file object is then obtained by calling opener with (file, flags). opener must return an open file descriptor (passing as opener results in functionality similar to passing ). The following example uses the dir_fd parameter of the function to open a file relative to a given directory: 'This will be written to somedir/spamspam.txt' The type of file object returned by the function depends on the mode. When is used to open a file in a text mode ( , , , , etc.), it returns a subclass of (specifically ). When used to open a file in a binary mode with buffering, the returned class is a subclass of . The exact class varies: in read binary mode, it returns an ; in write binary and append binary modes, it returns an , and in read/write mode, it returns an . When buffering is disabled, the raw stream, a subclass of , , is returned. See also the file handling modules, such as , (where is declared), , , , and . The and arguments may have been modified or inferred from the original call.\n• None used to be raised, it is now an alias of .\n• None is now raised if the file opened in exclusive creation mode ( ) already exists.\n• None The file is now non-inheritable.\n• None If the system call is interrupted and the signal handler does not raise an exception, the function now retries the system call instead of raising an exception (see PEP 475 for the rationale).\n• None On Windows, opening a console buffer may return a subclass of other than . Changed in version 3.11: The mode has been removed.\n\nReturn a proxy object that delegates method calls to a parent or sibling class of type. This is useful for accessing inherited methods that have been overridden in a class. The object_or_type determines the method resolution order to be searched. The search starts from the class right after the type. For example, if of object_or_type is and the value of type is , then searches . The attribute of the class corresponding to object_or_type lists the method resolution search order used by both and . The attribute is dynamic and can change whenever the inheritance hierarchy is updated. If the second argument is omitted, the super object returned is unbound. If the second argument is an object, must be true. If the second argument is a type, must be true (this is useful for classmethods). When called directly within an ordinary method of a class, both arguments may be omitted (“zero-argument ”). In this case, type will be the enclosing class, and obj will be the first argument of the immediately enclosing function (typically ). (This means that zero-argument will not work as expected within nested functions, including generator expressions, which implicitly create nested functions.) There are two typical use cases for super. In a class hierarchy with single inheritance, super can be used to refer to parent classes without naming them explicitly, thus making the code more maintainable. This use closely parallels the use of super in other programming languages. The second use case is to support cooperative multiple inheritance in a dynamic execution environment. This use case is unique to Python and is not found in statically compiled languages or languages that only support single inheritance. This makes it possible to implement “diamond diagrams” where multiple base classes implement the same method. Good design dictates that such implementations have the same calling signature in every case (because the order of calls is determined at runtime, because that order adapts to changes in the class hierarchy, and because that order can include sibling classes that are unknown prior to runtime). For both use cases, a typical superclass call looks like this: # This does the same thing as: In addition to method lookups, also works for attribute lookups. One possible use case for this is calling descriptors in a parent or sibling class. Note that is implemented as part of the binding process for explicit dotted attribute lookups such as . It does so by implementing its own method for searching classes in a predictable order that supports cooperative multiple inheritance. Accordingly, is undefined for implicit lookups using statements or operators such as . Also note that, aside from the zero argument form, is not limited to use inside methods. The two argument form specifies the arguments exactly and makes the appropriate references. The zero argument form only works inside a class definition, as the compiler fills in the necessary details to correctly retrieve the class being defined, as well as accessing the current instance for ordinary methods. For practical suggestions on how to design cooperative classes using , see guide to using super()."
    },
    {
        "link": "http://python-reference.readthedocs.io/en/latest/docs/functions/sorted.html",
        "document": "In general, the key and reverse conversion processes are much faster than specifying an equivalent cmp function. This is because cmp is called multiple times for each list element while key and reverse touch each element only once. Use functools.cmp_to_key() to convert an old-style cmp function to a key function. For sorting examples and a brief sorting tutorial, see Sorting HowTo."
    },
    {
        "link": "https://docs.python.org/3.9/howto/sorting.html",
        "document": "Python lists have a built-in method that modifies the list in-place. There is also a built-in function that builds a new sorted list from an iterable.\n\nIn this document, we explore the various techniques for sorting data using Python.\n\nA simple ascending sort is very easy: just call the function. It returns a new sorted list: You can also use the method. It modifies the list in-place (and returns to avoid confusion). Usually it’s less convenient than - but if you don’t need the original list, it’s slightly more efficient. Another difference is that the method is only defined for lists. In contrast, the function accepts any iterable.\n\nBoth and have a key parameter to specify a function (or other callable) to be called on each list element prior to making comparisons. \"This is a test string from Andrew\" ['a', 'Andrew', 'from', 'is', 'string', 'test', 'This'] The value of the key parameter should be a function (or other callable) that takes a single argument and returns a key to use for sorting purposes. This technique is fast because the key function is called exactly once for each input record. A common pattern is to sort complex objects using some of the object’s indices as keys. For example: The same technique works for objects with named attributes. For example:\n\nThe key-function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster. The module has , , and a function. Using those functions, the above examples become simpler and faster: The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age:\n\nSorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. Notice how the two records for blue retain their original order so that is guaranteed to precede . This wonderful property lets you build complex sorts in a series of sorting steps. For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: This can be abstracted out into a wrapper function that can take a list and tuples of field and order to sort them on multiple passes. The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset.\n\nThe Old Way Using Decorate-Sort-Undecorate¶ This idiom is called Decorate-Sort-Undecorate after its three steps:\n• None First, the initial list is decorated with new values that control the sort order.\n• None Second, the decorated list is sorted.\n• None Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list, but including it gives two benefits:\n• None The sort is stable – if two items have the same key, their order will be preserved in the sorted list.\n• None The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. Now that Python sorting provides key-functions, this technique is not often needed.\n\nThe Old Way Using the cmp Parameter¶ Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no builtin and took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the magic method). In Py2.x, sort allowed an optional function which can be called for doing the comparisons. That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than. For example, we can do: Or you can reverse the order of comparison with: When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function. The following wrapper makes that easy to do: To convert to a key function, just wrap the old comparison function: In Python 3.2, the function was added to the module in the standard library."
    },
    {
        "link": "https://docs.python.org/3/library/os.path.html",
        "document": "Source code: Lib/genericpath.py, Lib/posixpath.py (for POSIX) and Lib/ntpath.py (for Windows).\n\nThis module implements some useful functions on pathnames. To read or write files see , and for accessing the filesystem see the module. The path parameters can be passed as strings, or bytes, or any object implementing the protocol.\n\nUnlike a Unix shell, Python does not do any automatic path expansions. Functions such as and can be invoked explicitly when an application desires shell-like path expansion. (See also the module.)\n\nSince different operating systems have different path name conventions, there are several versions of this module in the standard library. The module is always the path module suitable for the operating system Python is running on, and therefore usable for local paths. However, you can also import and use the individual modules if you want to manipulate a path that is always in one of the different formats. They all have the same interface:\n\nOn Unix and Windows, return the argument with an initial component of or replaced by that user’s home directory. On Unix, an initial is replaced by the environment variable if it is set; otherwise the current user’s home directory is looked up in the password directory through the built-in module . An initial is looked up directly in the password directory. On Windows, will be used if set, otherwise a combination of and will be used. An initial is handled by checking that the last directory component of the current user’s home directory matches , and replacing it if so. If the expansion fails or if the path does not begin with a tilde, the path is returned unchanged. Changed in version 3.8: No longer uses on Windows.\n\nJoin one or more path segments intelligently. The return value is the concatenation of path and all members of *paths, with exactly one directory separator following each non-empty part, except the last. That is, the result will only end in a separator if the last part is either empty or ends in a separator. If a segment is an absolute path (which on Windows requires both a drive and a root), then all previous segments are ignored and joining continues from the absolute path segment. On Windows, the drive is not reset when a rooted path segment (e.g., ) is encountered. If a segment is on a different drive or is an absolute path, all previous segments are ignored and the drive is reset. Note that since there is a current directory for each drive, represents a path relative to the current directory on drive ( ), not . Changed in version 3.6: Accepts a path-like object for path and paths."
    },
    {
        "link": "https://geeksforgeeks.org/python-os-path-isdir-method",
        "document": "OS module in Python provides functions for interacting with the operating system. OS comes under Python’s standard utility modules. This module provides a portable way of using operating system-dependent functionality.\n\nos.path module is a sub-module of the OS module in Python used for common path name manipulation.\n\nos.path.isdir() method in Python checks whether the specified path is a directory or not. This method follows the symbolic link, which means if the specified path is a symbolic link pointing to an existing directory then the method will return True.\n\nThis method returns a Boolean value of class bool. This method returns True if the specified path is an existing directory, otherwise returns False.\n\nExample 2: Check if the path is a directory using a symbolic link\n\nWe have covered how to use os.path.isdir() method of OS module to check if the given path is a directory or not. Python isdir() method returns true if the given path is a directory otherwise returns false.\n\nIt is useful to check for directories before performing any operations on it. We have explained isdir() method in very easy words, with examples of Python programs. You can easily learn and practice isdir() method using this guide."
    },
    {
        "link": "https://stackoverflow.com/questions/68318658/what-is-fast-way-to-check-isdir-in-python",
        "document": "In my project, my program check very many dir and files.\n\nfirst, i try this. lower is my code snippet.\n\nI know, it's not right. directory name can include '.'!\n\nIt's right. but, upper code is terribly slow!\n\nfirst code use 0.48 sec. but second use 17 sec...\n\nI change [os.path.join] -> [path_dir + '\\' + filename]. It takes 15 sec. it's too slow, too.\n\nI know os.path.isdir is problem. lower is test.\n\ntest_func2 use just 0.003 sec, but test_func1 use 3 sec!\n\nWhat is the fast way to check isDir?\n\nTarget OS is windows 10. I don't need cross-flatform. just window."
    },
    {
        "link": "https://stackoverflow.com/questions/42969616/whats-the-difference-between-and-when-using-os-path-isdir",
        "document": "I'm new to python. And something is confusing me today. Under the path , there are several folds. I edit a python script under this path, and run the code:\n\nBut when I put the script in fold which is under the path ,and run code:\n\nDid they have the difference?"
    },
    {
        "link": "https://docs.python.org/3/library/os.html",
        "document": "This module provides a portable way of using operating system dependent functionality. If you just want to read or write a file see , if you want to manipulate paths, see the module, and if you want to read all the lines in all the files on the command line see the module. For creating temporary files and directories see the module, and for high-level file and directory handling see the module.\n\nNotes on the availability of these functions:\n• None The design of all built-in operating system dependent modules of Python is such that as long as the same functionality is available, it uses the same interface; for example, the function returns stat information about path in the same format (which happens to have originated with the POSIX interface).\n• None Extensions peculiar to a particular operating system are also available through the module, but using them is of course a threat to portability.\n• None All functions accepting path or file names accept both bytes and string objects, and result in an object of the same type, if a path or file name is returned.\n• None On VxWorks, os.popen, os.fork, os.execv and os.spawn*p* are not supported.\n• None On WebAssembly platforms, Android and iOS, large parts of the module are not available or behave differently. APIs related to processes (e.g. , ) and resources (e.g. ) are not available. Others like and are emulated or stubs. WebAssembly platforms also lack support for signals (e.g. , )."
    }
]