[
    {
        "link": "https://docs.python.org/3/library/zipfile.html",
        "document": "The ZIP file format is a common archive and compression standard. This module provides tools to create, read, write, append, and list a ZIP file. Any advanced use of this module will require an understanding of the format, as defined in PKZIP Application Note.\n\nThis module does not currently handle multi-disk ZIP files. It can handle ZIP files that use the ZIP64 extensions (that is ZIP files that are more than 4 GiB in size). It supports decryption of encrypted files in ZIP archives, but it currently cannot create an encrypted file. Decryption is extremely slow as it is implemented in native Python rather than C.\n\nThe module defines the following items:\n\nOpen a ZIP file, where file can be a path to a file (a string), a file-like object or a path-like object. The mode parameter should be to read an existing file, to truncate and write a new file, to append to an existing file, or to exclusively create and write a new file. If mode is and file refers to an existing file, a will be raised. If mode is and file refers to an existing ZIP file, then additional files are added to it. If file does not refer to a ZIP file, then a new ZIP archive is appended to the file. This is meant for adding a ZIP archive to another file (such as ). If mode is and the file does not exist at all, it is created. If mode is or , the file should be seekable. compression is the ZIP compression method to use when writing the archive, and should be , , or ; unrecognized values will cause to be raised. If , or is specified but the corresponding module ( , or ) is not available, is raised. The default is . If allowZip64 is (the default) zipfile will create ZIP files that use the ZIP64 extensions when the zipfile is larger than 4 GiB. If it is will raise an exception when the ZIP file would require ZIP64 extensions. The compresslevel parameter controls the compression level to use when writing files to the archive. When using or it has no effect. When using integers through are accepted (see for more information). When using integers through are accepted (see for more information). The strict_timestamps argument, when set to , allows to zip files older than 1980-01-01 at the cost of setting the timestamp to 1980-01-01. Similar behavior occurs with files newer than 2107-12-31, the timestamp is also set to the limit. When mode is , metadata_encoding may be set to the name of a codec, which will be used to decode metadata such as the names of members and ZIP comments. If the file is created with mode , or and then without adding any files to the archive, the appropriate ZIP structures for an empty archive will be written to the file. ZipFile is also a context manager and therefore supports the statement. In the example, myzip is closed after the statement’s suite is finished—even if an exception occurs: metadata_encoding is an instance-wide setting for the ZipFile. It is not currently possible to set this on a per-member basis. This attribute is a workaround for legacy implementations which produce archives with names in the current locale encoding or code page (mostly on Windows). According to the .ZIP standard, the encoding of metadata may be specified to be either IBM code page (default) or UTF-8 by a flag in the archive header. That flag takes precedence over metadata_encoding, which is a Python-specific extension. Changed in version 3.2: Added the ability to use as a context manager. Changed in version 3.3: Added support for and compression. Changed in version 3.4: ZIP64 extensions are enabled by default. Changed in version 3.5: Added support for writing to unseekable streams. Added support for the mode. Changed in version 3.6: Previously, a plain was raised for unrecognized compression values. Changed in version 3.11: Added support for specifying member name encoding for reading metadata in the zipfile’s directory and file headers. Close the archive file. You must call before exiting your program or essential records will not be written. Return a object with information about the archive member name. Calling for a name not currently contained in the archive will raise a . Return a list containing a object for each member of the archive. The objects are in the same order as their entries in the actual ZIP file on disk if an existing archive was opened. Return a list of archive members by name. Access a member of the archive as a binary file-like object. name can be either the name of a file within the archive or a object. The mode parameter, if included, must be (the default) or . pwd is the password used to decrypt encrypted ZIP files as a object. is also a context manager and therefore supports the statement: With mode the file-like object ( ) is read-only and provides the following methods: , , , , , , . These objects can operate independently of the ZipFile. With , a writable file handle is returned, which supports the method. While a writable file handle is open, attempting to read or write other files in the ZIP file will raise a . In both cases the file-like object has also attributes , which is equivalent to the name of a file within the archive, and , which is or depending on the input mode. When writing a file, if the file size is not known in advance but may exceed 2 GiB, pass to ensure that the header format is capable of supporting large files. If the file size is known in advance, construct a object with set, and use that as the name parameter. The , and methods can take a filename or a object. You will appreciate this when trying to read a ZIP file that contains members with duplicate names. Changed in version 3.6: Removed support of . Use for reading compressed text files in universal newlines mode. Changed in version 3.6: can now be used to write files into the archive with the option. Changed in version 3.6: Calling on a closed ZipFile will raise a . Previously, a was raised. Changed in version 3.13: Added attributes and for the writeable file-like object. The value of the attribute for the readable file-like object was changed from to . Extract a member from the archive to the current working directory; member must be its full name or a object. Its file information is extracted as accurately as possible. path specifies a different directory to extract to. member can be a filename or a object. pwd is the password used for encrypted files as a object. Returns the normalized path created (a directory or new file). If a member filename is an absolute path, a drive/UNC sharepoint and leading (back)slashes will be stripped, e.g.: becomes on Unix, and becomes on Windows. And all components in a member filename will be removed, e.g.: becomes . On Windows illegal characters ( , , , , , , and ) replaced by underscore ( ). Changed in version 3.6: Calling on a closed ZipFile will raise a . Previously, a was raised. Extract all members from the archive to the current working directory. path specifies a different directory to extract to. members is optional and must be a subset of the list returned by . pwd is the password used for encrypted files as a object. Never extract archives from untrusted sources without prior inspection. It is possible that files are created outside of path, e.g. members that have absolute filenames starting with or filenames with two dots . This module attempts to prevent that. See note. Changed in version 3.6: Calling on a closed ZipFile will raise a . Previously, a was raised. Print a table of contents for the archive to . Return the bytes of the file name in the archive. name is the name of the file in the archive, or a object. The archive must be open for read or append. pwd is the password used for encrypted files as a object and, if specified, overrides the default password set with . Calling on a ZipFile that uses a compression method other than , , or will raise a . An error will also be raised if the corresponding compression module is not available. Changed in version 3.6: Calling on a closed ZipFile will raise a . Previously, a was raised. Read all the files in the archive and check their CRC’s and file headers. Return the name of the first bad file, or else return . Changed in version 3.6: Calling on a closed ZipFile will raise a . Previously, a was raised. Write the file named filename to the archive, giving it the archive name arcname (by default, this will be the same as filename, but without a drive letter and with leading path separators removed). If given, compress_type overrides the value given for the compression parameter to the constructor for the new entry. Similarly, compresslevel will override the constructor if given. The archive must be open with mode , or . The ZIP file standard historically did not specify a metadata encoding, but strongly recommended CP437 (the original IBM PC encoding) for interoperability. Recent versions allow use of UTF-8 (only). In this module, UTF-8 will automatically be used to write the member names if they contain any non-ASCII characters. It is not possible to write member names in any encoding other than ASCII or UTF-8. Archive names should be relative to the archive root, that is, they should not start with a path separator. If (or , if is not given) contains a null byte, the name of the file in the archive will be truncated at the null byte. A leading slash in the filename may lead to the archive being impossible to open in some zip programs on Windows systems. Changed in version 3.6: Calling on a ZipFile created with mode or a closed ZipFile will raise a . Previously, a was raised. Write a file into the archive. The contents is data, which may be either a or a instance; if it is a , it is encoded as UTF-8 first. zinfo_or_arcname is either the file name it will be given in the archive, or a instance. If it’s an instance, at least the filename, date, and time must be given. If it’s a name, the date and time is set to the current date and time. The archive must be opened with mode , or . If given, compress_type overrides the value given for the compression parameter to the constructor for the new entry, or in the zinfo_or_arcname (if that is a instance). Similarly, compresslevel will override the constructor if given. When passing a instance as the zinfo_or_arcname parameter, the compression method used will be that specified in the compress_type member of the given instance. By default, the constructor sets this member to . Changed in version 3.6: Calling on a ZipFile created with mode or a closed ZipFile will raise a . Previously, a was raised. Create a directory inside the archive. If zinfo_or_directory is a string, a directory is created inside the archive with the mode that is specified in the mode argument. If, however, zinfo_or_directory is a instance then the mode argument is ignored. The archive must be opened with mode , or . The following data attributes are also available: The level of debug output to use. This may be set from (the default, no output) to (the most output). Debugging information is written to . The comment associated with the ZIP file as a object. If assigning a comment to a instance created with mode , or , it should be no longer than 65535 bytes. Comments longer than this will be truncated.\n\nConstruct a Path object from a zipfile (which may be a instance or suitable for passing to the constructor). specifies the location of this Path within the zipfile, e.g. ‘dir/file.txt’, ‘dir/’, or ‘’. Defaults to the empty string, indicating the root. The class does not sanitize filenames within the ZIP archive. Unlike the and methods, it is the caller’s responsibility to validate or sanitize filenames to prevent path traversal vulnerabilities (e.g., filenames containing “..” or absolute paths). When handling untrusted archives, consider resolving filenames using and checking against the target directory with . Path objects expose the following features of objects: Path objects are traversable using the operator or . Invoke on the current path. Allows opening for read or write, text or binary through supported modes: ‘r’, ‘w’, ‘rb’, ‘wb’. Positional and keyword arguments are passed through to when opened as text and ignored otherwise. is the parameter to . Changed in version 3.9: Added support for text and binary modes for open. Default mode is now text. Changed in version 3.11.2: The parameter can be supplied as a positional argument without causing a . As it could in 3.9. Code needing to be compatible with unpatched 3.10 and 3.11 versions must pass all arguments, included, as keywords. Enumerate the children of the current directory. Return if the current context references a file or directory in the zip file. The last dot-separated portion of the final component, if any. This is commonly called the file extension. The final path component, without its suffix. Read the current file as unicode text. Positional and keyword arguments are passed through to (except , which is implied by the context). Changed in version 3.11.2: The parameter can be supplied as a positional argument without causing a . As it could in 3.9. Code needing to be compatible with unpatched 3.10 and 3.11 versions must pass all arguments, included, as keywords. Return a new Path object with each of the other arguments joined. The following are equivalent: Changed in version 3.10: Prior to 3.10, was undocumented and accepted exactly one parameter. The zipp project provides backports of the latest path object functionality to older Pythons. Use in place of for early access to changes.\n\nThe module provides a simple command-line interface to interact with ZIP archives. If you want to create a new ZIP archive, specify its name after the option and then list the filename(s) that should be included: If you want to extract a ZIP archive into the specified directory, use the option: For a list of the files in a ZIP archive, use the option: Test whether the zipfile is valid or not. Specify encoding of member names for , and .\n\nThe extraction in zipfile module might fail due to some pitfalls listed below. Decompression may fail due to incorrect password / CRC checksum / ZIP format or unsupported compression method / decryption. Exceeding limitations on different file systems can cause decompression failed. Such as allowable characters in the directory entries, length of the file name, length of the pathname, size of a single file, and number of files, etc. The lack of memory or disk volume would lead to decompression failed. For example, decompression bombs (aka ZIP bomb) apply to zipfile library that can cause disk volume exhaustion. Interruption during the decompression, such as pressing control-C or killing the decompression process may result in incomplete decompression of the archive. Not knowing the default extraction behaviors can cause unexpected decompression results. For example, when extracting the same archive twice, it overwrites files without asking."
    },
    {
        "link": "https://stackoverflow.com/questions/5710867/downloading-and-unzipping-a-zip-file-without-writing-to-disk",
        "document": "I have managed to get my first python script to work which downloads a list of .ZIP files from a URL and then proceeds to extract the ZIP files and writes them to disk.\n\nI am now at a loss to achieve the next step.\n\nMy primary goal is to download and extract the zip file and pass the contents (CSV data) via a TCP stream. I would prefer not to actually write any of the zip or extracted files to disk if I could get away with it.\n\nHere is my current script which works but unfortunately has to write the files to disk."
    },
    {
        "link": "https://stackoverflow.com/questions/3451111/unzipping-files-in-python",
        "document": "is a somewhat low-level library. Unless you need the specifics that it provides, you can get away with 's higher-level functions and .\n\nis already described in this answer. As for :\n\ndetects the compression format automatically from the \"extension\" of ( , , etc), and so does . Also, and can be any path-like objects (e.g. pathlib.Path instances) since Python 3.7."
    },
    {
        "link": "https://sqlpad.io/tutorial/python-zipfile",
        "document": "The Python module is an essential tool for working with ZIP archives, which are collections of files compressed together to save space or to bundle multiple files into a single package for easy transportation. This module is part of Python's standard library, so it's readily available to use without the need for external packages. The functionality provided by allows you to create, read, extract, and modify ZIP files within your Python scripts.\n\nThe module in Python enables you to interact with ZIP archives programmatically. This subtopic will guide you through the basics of the module, showcasing how to use it with practical code examples.\n\nTo get started with the module, you don't need to install anything extra since it's included in Python's standard library. Here's a simple example of how you can create a ZIP file:\n\nIn this example, we're using a context manager ( statement) to ensure that the ZIP file is properly closed after we're done with it. The method adds the specified file to the ZIP archive.\n\nNow, let's say you want to extract all files from a ZIP archive:\n\nHere, method extracts all files into the directory . If the directory does not exist, it will be created.\n\nTo read the contents of a file within a ZIP archive without extracting it, you can do the following:\n\nIn this code, method returns a file-like object that you can read from, similar to Python's built-in function.\n\nThe practical applications of the module are vast. You can use it to package logs, distribute software, prepare files for upload, or even to compress data for machine learning datasets. As you gain familiarity with this module, you'll find it an indispensable tool in your Python programming toolkit.### Real-world Applications of zipfile\n\nThe Python module is incredibly versatile and finds its use in a variety of real-world applications. Here are some examples where the module becomes an essential tool:\n\nMany businesses use Python scripts to automate the backup of their important data. By using the module, a script can compress multiple files and directories into a single ZIP file, which can then be moved to a backup location. This not only saves space but also makes the transfer and storage process more efficient.\n\nWhen sharing multiple files or large datasets, it's common to compress them into a ZIP archive to reduce file size and consolidate files into a single package. This is particularly useful when sending data over the internet or distributing software packages.\n\nData scientists and analysts often receive large sets of compressed data. The module allows them to programmatically extract and process data without manual intervention.\n\nThese examples only scratch the surface of what's possible with the module. From automating mundane tasks to enabling the efficient distribution and processing of data, the module is a powerful ally in the Python programmer's arsenal. Its ease of use and the ubiquity of ZIP files make it an indispensable tool for various applications in the modern computing landscape.### Advantages of Using zipfile in Python\n\nThe Python module is a powerful ally for developers needing to work with ZIP archives. Below are some of the compelling advantages that make it a go-to choice.\n\nPython's module is designed with simplicity in mind. Even beginners can quickly learn how to perform basic operations such as creating, extracting, or inspecting ZIP files. Here's a simple example that demonstrates creating a ZIP file:\n\nOne of the biggest advantages is that is part of the Python Standard Library, which means you don't need to install any external packages to use it. This makes your code more portable and reduces compatibility issues.\n\nZIP files are ubiquitous and can be used across different operating systems. With , you can create and extract ZIP files that are compatible with Windows, macOS, and Linux, facilitating easy data exchange.\n\nprovides support for different compression methods, including the commonly used DEFLATE algorithm. This can save disk space and reduce the size of data being transmitted over a network.\n\nYou have the flexibility to extract or archive only specific files from a ZIP, which can be very useful when dealing with large archives or when you need to process only particular files.\n\nsupports creating password-protected ZIP files, which adds a layer of security when sharing sensitive data.\n\nWhen working with large files, allows you to read and write data in chunks, which means you don't need to load the entire file into memory. This is especially important for applications running on devices with limited memory.\n\nBy incorporating these advantages into your workflow, you can manage ZIP archives effectively, ensuring data integrity and efficiency in your Python projects.\n\nBefore we dive into the intricacies of handling zip files in Python, let's set the stage by understanding the foundational step of installing and importing the zipfile module.\n\nThe zipfile module is part of Python's standard library, which means it comes pre-installed with Python and you do not need to install it separately. This is convenient because you can start working with zip files right away without any additional setup.\n\nTo begin using the zipfile module in your Python script, you need to import it. Here's how you do it:\n\nSimple as that! With the module imported, you now have access to all the functions and classes needed to create, read, update, and extract zip files. Let's look at some practical usage of the zipfile module.\n\nTo create a new zip file, you can use with the 'w' mode. Here's a sample code snippet that demonstrates how to create a zip file and add files to it:\n\nIn this example, is the name of the new zip file we're creating, and specifies that we're opening the file in write mode. We then use a context manager ( statement), which ensures that the file is properly closed after we're done. is used to add individual files to the zip archive.\n\nExtracting files is just as straightforward. You can extract all files or individual files using the and methods:\n\nSometimes, you might want to read the contents of a file within a zip archive without extracting it. The zipfile module allows you to do that:\n\nIn this case, is used to read the contents of directly from the zip file. The method is then used to read the file's contents and print them to the console.\n\nBy following these examples, you should now have a good understanding of how to install and import the zipfile module, and perform some basic operations. Remember, the goal is to get comfortable with the process of working with zip files in Python, so feel free to experiment with the code and create your own examples to solidify your understanding.### Creating a New Zip File\n\nCreating a new zip file with Python's module is both straightforward and versatile, allowing you to compress files for efficient storage and transfer. Here's how to get started.\n• Import the zipfile Module\n\nBefore you can work with zip files in Python, you need to ensure that the module is available. It's included in Python's standard library, so there's no need to install it separately. You can import it using the following line of code:\n• Specify the Files to Zip\n\nDecide which files you want to include in your zip archive. For this example, let's assume you have two files named and in the same directory as your script.\n• Create a New Zip Archive\n\nUse the class to create a new zip file. You need to specify the name of the zip file and the mode. To create a new archive, use the 'w' mode, which stands for write: In this code, the statement is used as a context manager, which ensures that resources are managed properly and the file is properly closed after its block of code runs. The method adds the specified files to the archive.\n• Add Compression (Optional)\n\nThe module supports different compression methods. The most common is , which uses the deflate compression algorithm. To use this, you must pass the compression method as a parameter when creating the object: This code will create a zip archive with compressed contents, resulting in a smaller file size.\n• Add Files from Different Directories (Optional)\n\nIf you want to add files from various directories, you need to provide the full path to each file. Optionally, you can set the parameter in the method to specify the name that should be used within the archive: This places in a folder named and in a folder named within the zip archive.\n\nBy following these steps, you'll be able to create your own zip files in Python, tailor them to your needs, and understand the basics of file compression. Whether you're looking to save space or securely share multiple files, the module provides a robust solution.### Extracting Files from a Zip Archive\n\nThe module in Python provides a straightforward method for extracting files from a zip archive. Whether you need to retrieve a single file or the entire contents, the module equips you with the tools to accomplish the task with ease. Let's dive into the practical aspects of extracting files from a zip archive.\n\nTo extract all files from a zip archive, you can use the method. Here's a simple example:\n\nThis script opens the zip file, , and extracts all its contents into the directory.\n\nIf you're interested in extracting a specific file, you can use the method, which requires the file's name within the zip archive:\n\nThis snippet will extract only from to the directory.\n\nImagine you're automating the process of downloading and extracting monthly reports. You can use the module to unzip the reports as soon as they are downloaded, like so:\n\nBy using this method, you can streamline the process of managing report archives, freeing up your time for data analysis rather than file management.\n\nThe module's extraction methods are not only powerful but also simple to use, making it an essential tool in your Python programming toolkit. Whether handling simple tasks or automating complex workflows, knowing how to extract files from zip archives can significantly enhance your productivity.### Reading Data from Zip Files\n\nReading data from zip files is a common task when dealing with compressed archives. The Python module provides tools for reading files within a zip archive without having to extract them to the filesystem. This is particularly useful when you want to access file data on-the-fly, or when working in environments with limited disk space.\n\nHow to Read Data Directly from a Zip File\n\nTo read data from a zip file, you need to open the archive using the class and then access individual files within the archive. Here's how you do it:\n\nThe method of the object returns a file-like object which can be read similar to a regular file in Python.\n\nIf you are only interested in a particular file, you can open just that file directly:\n\nIf the file you are reading is a text file, you may want to read it as a string instead of bytes. You can decode the bytes using the appropriate encoding, usually 'utf-8':\n\nImagine you have a zip archive of log files that you want to analyze. Instead of extracting all files, which could take up a lot of disk space, you can read each file's contents directly from the archive, process the data, and collect the results. This method is efficient and keeps your workspace tidy.\n\nRemember, when reading large files, it might be more memory-efficient to read the file in chunks or lines. Here's an example of reading a file line by line within a zip archive:\n\nHere, would be a function you define to handle each line from the log file. Reading data from zip files in this way is powerful and can save time and resources, making it an essential skill for Python developers working with archives.\n\nWhen working with zip files in Python, it's often necessary to know what's inside them before performing other operations. This is where navigating zip archives comes into play. This section will guide you through the process of listing the contents of a zip file, checking for specific files, and retrieving metadata, which are all crucial steps in effectively managing zip archives.\n\nTo list the contents of a zip file, you'll use the class from the module. The method of a object returns a list of all the file names (and directory names) contained within the zip file. Let's see how this works with an example.\n\nSuppose you have a zip archive named 'example.zip' and you want to list all of its contents. Here's how you can do it:\n\nThis simple script first imports the class. It then opens 'example.zip' in read mode ( ). The context manager ( statement) is used to ensure that the zip file is properly closed after we're done with it, avoiding potential resource leaks.\n\nOnce the zip file is open, we call the method to retrieve a list of its contents and then iterate over this list to print each item. The output will show you all the entries in the zip file, including files and directories.\n\nNow, let's consider a real-world application of listing contents. Imagine you are working on an application that processes batches of images that come packaged in zip files. Before processing, you need to ensure that the zip contains only image files. Here's how you can do that:\n\nIn the above code, we first define a set of valid image file extensions. We then check that every file in the zip archive ends with one of these extensions. This check helps you avoid processing invalid files.\n\nBy learning how to list and inspect the contents of zip archives, you can create Python scripts that are robust and capable of handling various types of zip files. It's a fundamental skill for any Python developer working with file archives.### Checking for Specific Files in a Zip Archive\n\nWhen working with zip archives, you often need to know whether a particular file exists within it. This is especially useful when you want to verify the contents without extracting everything or when you're looking for a specific file to process. Python's zipfile module provides straightforward ways to check for the presence of files in a zip archive. Let's walk through how you can do this.\n\nFirst, you will need to open the zip archive using the class. Once you have an instance of a , you can use the method to get a list of all the files in the archive. With the list of file names, you can simply check if the specific file name you're looking for is in that list.\n\nHere's a practical example of how to check for a specific file in a zip archive:\n\nIn the code above, we used a context manager ( statement), which is a good practice as it ensures that the zip file is properly closed after we're done with it, even if an error occurs. The method returns all the names of the files in the archive, which we then use to check for the presence of .\n\nAnother approach, if you're working with larger zip files and are only interested in a single file, is to use the method, which will return a object for the specified file if it exists or raise a if it doesn't. This can be more efficient since you don't need to retrieve the entire list of files.\n\nHere's how you might use :\n\nIn this example, if is not in the archive, a will be caught by the block, and a message is printed to indicate that the file does not exist.\n\nUnderstanding how to check for specific files in a zip archive will help you manage your zip files more efficiently, as you can quickly identify whether the file you need is present without extracting unnecessary data. This can be particularly useful in applications where you're dealing with a large number of archives and need to find specific information quickly.### Retrieving Metadata of Zip Archive Contents\n\nWhen working with zip archives, it's often necessary to retrieve metadata about the files contained within. Metadata can include information such as file names, sizes, timestamps, and compression type. This data can help you to display contents to users, decide which files to extract, or even determine how to process files programmatically.\n\nLet's dive into how to get this metadata using Python's zipfile module. To do this, we'll use the class and its and methods. The method returns a list of class objects for all members of the archive, while returns a object for the member .\n\nHere's how you can use these methods to retrieve and display metadata for each file in a zip archive:\n\nIn the example above, is used to gather metadata on all files, while targets a particular file. objects carry all the metadata you need. For instance, gives the name of the file, is the original file size before compression, and is the size after compression, which can be handy for assessing the efficiency of the compression.\n\nThe attribute is a tuple containing year, month, day, hour, minute, and second, which tells you when the file was last modified. The can be used to check if the file is encrypted (though zipfile only supports reading encrypted files, not creating them).\n\nLastly, indicates the method used for compression—commonly for the standard Deflate method.\n\nUnderstanding the metadata of files within a zip archive is key when you need to process files differently based on certain attributes or when you want to give users an insight into the contents of the archive before they decide to download or extract it.\n\nBy leveraging the zipfile module's metadata retrieval capabilities, you can create programs that not only manipulate zip files but also interact with their contents in a sophisticated and informed manner.\n\nWhen dealing with sensitive or private data, it's common to secure zip archives with a password. Fortunately, the Python module provides a straightforward way to handle password-protected zip files. This functionality is essential for scenarios where data security is a concern, such as when storing user data or sharing confidential documents.\n\nPassword protection in zip files is a method to encrypt the contents and prevent unauthorized access. Python's module allows us to create and extract password-protected zip files using the standard ZipCrypto or the more secure AES encryption methods, though the latter requires additional libraries like .\n\nLet's dive into some code examples to illustrate how to work with password-protected zip files in Python.\n\nIn this example, we're setting a password for the zip file by calling the method. Remember, passwords in Python must be bytes or encoded strings, which is why we use a byte string ( ).\n\nHere, we use the method and provide the argument which is the password for the zip file. The files will be extracted to the 'extracted_files/' directory.\n\nThe method is used to access a specific file within the zip archive. You need to provide the password to read the content of the protected file.\n\nWhen working with password-protected files, it's crucial to handle potential errors, such as providing an incorrect password or attempting to process an unsupported encryption method. Always wrap your code in try-except blocks to handle these exceptions gracefully.\n\nIn practice, password-protected zip files ensure an extra layer of security. They're useful for sending sensitive information over email, storing personal data, or just keeping your files safe from prying eyes on shared systems.\n\nRemember that the built-in encryption provided by is not foolproof and can be vulnerable to attacks. For highly sensitive data, consider using more robust encryption methods or additional security measures.### Using Compression Methods\n\nWhen working with the module in Python, you have the option to choose different compression methods. This can be particularly useful when you want to manage the size of the resulting zip file. Python's module supports three types of compression methods:\n• - This is the default method that does not compress the files. It's essentially just packaging the files into a zip container without reducing their size.\n• - This method uses the Deflate compression algorithm, which is a good choice for reducing file size while maintaining a balance between compression speed and efficiency.\n• - This method uses the Bzip2 compression algorithm, which can offer better compression ratios than Deflate. However, it might be slower and is not universally supported across all systems.\n• - This uses the LZMA algorithm, providing a high compression ratio but can be slower than Bzip2 and Deflate.\n\nTo use these compression methods, you must first ensure that your Python environment supports them. is widely supported, while and may require additional libraries.\n\nHere's how you can create a new zip file with a specific compression method:\n\nIn the above example, we create three different zip files, each using a different compression method. We're using a context manager ( statement) to ensure the zip file is properly closed after we're done working with it.\n\nRemember, when extracting files from an archive created with BZIP2 or LZMA compression, the user's system must also support these algorithms. Otherwise, they might not be able to open the zip file.\n\nPractical applications of using different compression methods include scenarios where disk space is limited, or where files need to be transferred over a network. By choosing the right compression method, you can significantly reduce the file size, which leads to faster upload and download times and less storage use.\n\nKeep in mind that the trade-off for higher compression is often slower compression and decompression times. When choosing a compression method, consider the nature of the files you're compressing (text files compress very well with Deflate, while binary files like images might not see much size reduction) and the importance of the resulting file size versus the speed of compression.### Handling Large Zip Files with zipfile\n\nWorking with large zip files can be challenging, especially when it comes to memory usage and performance. The module in Python provides a set of tools that make it easier to handle such files efficiently. When dealing with large zip files, you want to avoid loading the entire file into memory. Instead, you should work with streams or use the module's ability to read and write to files incrementally.\n\nLet's explore how you can handle large zip files using the module.\n\nWhen you need to read a large zip file, you can do so incrementally using the method of a object. This method allows you to read a file within the zip archive in chunks, rather than loading the entire file into memory at once.\n\nHere's an example of how to read a large file from a zip archive incrementally:\n\nWhen creating a zip file that will contain large files, you can write to the zip file incrementally. By writing chunks of data at a time, you reduce the memory footprint of your program.\n\nHere's how you can write a large file to a zip archive incrementally:\n\nThe method allows you to write data directly to a zip archive, which can be useful for adding content that's generated on-the-fly. However, when working with large data, it's better to write to a temporary file first, then add that file to the archive, as shown in the previous example.\n\nBy following these practices, you can work with large zip files in Python without running into memory issues. This is particularly useful when you're working with file uploads in web applications, batch processing systems, or any scenario where you're likely to encounter large zip files. Remember to always close your files and archives to prevent any resource leaks, and take advantage of Python's context managers for cleaner and safer code.\n\nThe zipfile module in Python is a powerful toolkit for handling ZIP archives. It allows you to read from, write to, write, create, and modify ZIP files using a straightforward and accessible API. Among the various classes and methods provided by this module, the class is the cornerstone, offering a range of capabilities that are essential for working with ZIP files.\n\nThe ZipFile Class and Its Methods\n\nThe class is the main interface to ZIP files. It provides methods to create, read, write, and list the contents of ZIP archives. Let's dive into the practical usage of this class with code examples:\n\nIn the above examples, we've used the context manager with the statement to ensure that the object is correctly closed after its suite finishes. The class supports various modes of operation, similar to the built-in function used for file operations. The modes are:\n• : Read mode. Used when the ZIP file is opened for reading.\n• : Write mode. If the ZIP file does not exist, it is created. If it does exist, its contents are erased.\n• : Append mode. Used to add files to an existing ZIP file.\n\nHere are some of the key methods of the class:\n• : Adds a file to the ZIP file. The parameter specifies the alternative name for the file in the archive. can define the compression algorithm, like .\n• : Writes a string to the ZIP file as a file. This is useful for creating archives with files that are not physically present on the disk.\n• : Returns the bytes of the file named in the archive. can be used if the ZIP file is password protected.\n• : Extracts a member from the archive to the current working directory or to the given path. The member can be a filename or a object.\n• : Extracts all members from the archive to the current working directory or to the given path. The list can limit the files to extract.\n• : Returns a list of archive members by name.\n\nPractical application of these methods can be seen in scenarios like batch processing of files, creating backups, or distributing a collection of files in a compressed format. For example, you could use the class to bundle log files at the end of a day's server operation, extract the contents of a ZIP received via an API, or even create an archive of images for easy sharing.\n\nBy mastering the class methods, you unlock the potential to work with ZIP archives efficiently in your Python applications.### The ZipInfo Class and Its Attributes\n\nThe class is a less frequently discussed but incredibly useful component of the module in Python. It represents information about a single item within a zip file. Think of it like a card in a library catalog; it doesn't contain the book itself, but it tells you everything about the book—its title, author, where it's located, and so on. In the zip file context, these 'books' are the individual files, and 'ZipInfo' tells us their names, sizes, timestamps, and more.\n\nLet's dive into with some practical examples to better understand its attributes and how to use them:\n\nIn the example above, we used the method to obtain a list of objects from our zip file. For each object, we can access attributes such as: - : The name of the file within the zip archive. - : The original file size (before compression). - : The size of the file after compression. - : A tuple representing the year, month, day, hour, minute, and second the file was last modified. - : A field storing information such as file permissions and whether the file is a directory or a regular file. - : A method that returns if the object represents a directory within the archive, and otherwise.\n\nThe class can be very powerful when you have to manipulate or inspect zip archives. For instance, if you're creating a backup tool, you might want to check the modification dates of files to determine if they need to be updated in the archive. Or, if you're developing a file manager application, you might display the file permissions to the user.\n\nUnderstanding the class and its attributes enables you to work with zip files in a more granular and controlled manner, providing insights into the contents of your archives without having to extract them first. As you work with zip files, you'll find that the class is a valuable tool in your Python programming toolkit.### Understanding the Context Manager in zipfile\n\nThe context manager is a nifty feature in Python that allows you to manage resources efficiently. It's often used with the statement, which ensures that resources are properly acquired and released, making your code cleaner and more readable. When it comes to the module, using a context manager is crucial for handling zip files without having to worry about closing them manually.\n\nThe basic idea is that when you open a file or, in this case, a zip archive using the context manager, it will automatically take care of opening and closing the file for you. This means that even if an error occurs while processing the file, the context manager will ensure the file is closed properly, thus preventing any resource leaks.\n\nHere's how you can use the context manager with the module:\n\nIn the first block, we're creating a new zip file named and adding two text files to it. The statement ensures that is properly closed after we've added the files.\n\nIn the second block, we're extracting all the contents of to a folder named . Again, there's no need to close the zip file manually; it's all handled by the context manager.\n\nFinally, we're reading data from that's within . Notice that we're using a nested statement here. This is because we're dealing with two resources that need managing: the zip file itself and the file we're reading from within the archive. The context manager makes sure both are closed after use.\n\nUsing the context manager with the module is not only a best practice but also a way to write more robust and error-resistant code. It's a simple yet powerful tool that's especially useful when working with files in Python.\n\nWhen working with files and archives in Python, it's important to anticipate and handle potential errors that could occur during the execution of your code. The module is no exception, and it includes a number of specific exceptions that can be raised during operations like reading, writing, and extracting zip files. Handling these exceptions properly can make your code more robust and user-friendly.\n\nIn the module, there are several exceptions that are commonly encountered. Below are some of these exceptions, along with code examples that demonstrate how to handle them in practical applications.\n\nThis exception is raised when a file that does not appear to be a zip file is passed to the constructor. It's a subclass of .\n\nThis exception is raised when trying to create a ZIP file that would require ZIP64 functionality but ZIP64 is not enabled.\n\nWhen you attempt to read or extract files from a zip archive, and the specified file does not exist, Python raises a .\n\nis raised when you don't have the proper permissions to read from or write to a file or directory.\n\nHandling these exceptions gracefully in your code allows you to provide clear error messages to users, and take appropriate action when something goes wrong. This can include logging the error, prompting the user for a different file or directory, or attempting to repair a corrupted zip file.\n\nRemember to always test your error handling code thoroughly. It's easy to overlook edge cases when dealing with file I/O, so make sure you cover scenarios like missing files, read/write permissions, and unexpected file contents during your testing.### Best Practices for Handling zipfile Errors\n\nWhen working with files, and more specifically with zip archives in Python, it's inevitable that you'll encounter errors and exceptions. Handling these errors gracefully is crucial to ensure your application is robust and user-friendly. The Python module comes with several built-in exceptions that you can catch and manage. Below, we'll walk through some of the best practices for handling errors, complete with code examples.\n\nPython's module defines several specific exceptions like , , and 's own (note the capitalization difference, as is deprecated). It's good practice to catch the most specific exceptions where possible, rather than using a broad clause.\n\nBefore attempting to open a zip file, you can use the function to check if the file is indeed a zip file. This can prevent some errors from occurring.\n\nWhen trying to read or extract files, you may encounter a . Catch this to provide a clear message to the user or to take alternative actions.\n\nIf your application needs to handle zip files larger than 2GB, you must open the with the flag. However, if you still encounter a error, it's because the flag is not set and the file size exceeds the limit.\n\nUse Finally or Context Managers to Clean Up\n\nWhen an error occurs, it's essential to release resources such as file handles. Using a statement, which creates a context manager, ensures that the file is properly closed even if an error occurs.\n\nWhile catching errors, make sure to convert them into user-friendly messages. This can be crucial for applications with a non-technical user base.\n\nBy anticipating potential issues and catching specific exceptions, you can create a more robust and user-friendly application. Remember to always test error handling paths to ensure they work as expected.### Introduction to Python zipfile Module\n\nThe Python zipfile module is a powerful tool for working with zip archives. It allows you to create, extract, read, and manipulate zip files using Python. This module is especially useful when dealing with large amounts of data that need to be compressed for efficient storage or transmission. By understanding the zipfile module, you can leverage its capabilities to streamline the handling of zip files in your Python applications.\n\nTo read data from a zip file in Python, you can use the module's class. It provides methods to read the contents of the files in the archive without having to extract them first. Here's how you can read data from a zip file:\n\nThis code snippet demonstrates how to open a zip file and read individual files contained within it without extracting them to disk.\n\nWhen working with zip archives, it's often useful to get metadata about the files contained within. The module allows you to retrieve information such as file names, sizes, and modification dates. Here's an example:\n\nThis code block will loop through all the files in the zip archive and print out their names, sizes, and last modified dates.\n\nFor handling large zip files, the module can be used to read and write data in chunks to avoid memory issues. Here's a way to do that:\n\nIn this snippet, we're writing a large file to a zip archive in 4 KB chunks to ensure that we don't run out of memory, which is crucial when dealing with large files.\n\nThe ZipFile Class and Its Methods\n\nThe class is the centerpiece of the module. It provides a range of methods to interact with zip files. Here's a quick overview:\n\nThis example shows how to create a new zip file and add files to it, and then extract all files from the zip archive.\n\nWhen working with files, you may encounter errors, and handling these gracefully is a part of robust programming. Here's how you might debug issues when using the module:\n\nIn this code, we are handling several common exceptions that can occur when working with zip files. By catching and responding to different error types, we can provide more informative feedback and take appropriate actions.\n\nCreating a zip archive with several files is straightforward using the module:\n\nThis example demonstrates how to archive multiple files into a single zip file. It iterates over a list of file names, adding each one to the zip archive.\n\nWith these examples and explanations, you should now have a good grasp of the module and how to use it for various tasks related to zip archives in Python. Remember to handle exceptions carefully and test your code with different types of zip files to ensure it's robust and reliable.\n\nCreating a zip archive with multiple files is a common task that can help you organize, compress, and easily share a collection of files or folders. Whether you're archiving documents, bundling code files, or preparing assets for distribution, Python's module makes it straightforward. Let's dive into a practical example of how to do this.\n\nTo start, you'll need to have Python installed on your system. The module is included in Python's standard library, so there's no need to install it separately.\n\nFirst, you'll want to import the module:\n\nNext, decide which files you want to include in your zip archive. For this example, let's assume we have a directory named with several files we want to archive.\n\nNow, we'll create a new zip file and add files to it:\n\nIn this code, we use the context manager to ensure the zip file is properly closed after we're done working with it. We open our zip file in write mode ( ). Then we loop over our list of files and add each one to the zip file using the method. The parameter is optional, but it lets you specify a different name for the file within the archive if you want to.\n\nIf you're working with directories and want to include all files in a directory, you can use to iterate through the directory and add files accordingly:\n\nIn this enhanced example, generates the file names in a directory tree by walking either top-down or bottom-up. For each directory in the tree, it yields a 3-tuple .\n\nRemember, if you're working with larger files or a significant number of files, it might be a good idea to add some progress feedback to the user or use compression to reduce the size of the resulting archive. You can specify different compression methods, such as , when writing files to the zip archive.\n\nBy following these examples, you'll be able to create zip archives with multiple files using Python's module with ease. This can be incredibly useful for batch processing files, preparing backups, or even automating distribution of digital goods. Happy zipping!### Extracting Selective Files from a Zip Archive\n\nSometimes, you might not need to extract every file from a ZIP archive. Instead, you might only need to extract specific files based on certain criteria, such as file type, file name, or a particular directory structure within the ZIP file. The module in Python allows you to selectively extract files, which can be incredibly useful for saving time and disk space.\n\nLet's walk through an example where we have a ZIP archive and we want to extract only files from it. The following code snippet demonstrates how to achieve this:\n\nIn this example, we first import the module and define the ZIP file name and the pattern of the file types we want to extract. We then open the ZIP file in read mode using the statement, which ensures that the file is properly closed after we're done with it. This is an example of using a context manager.\n\nWe use the method to retrieve all the file names inside the ZIP file and iterate over them using a loop. For each file, we check if it ends with using the method. If it does, we call the method, specifying the file to extract and the target directory where the file will be placed.\n\nAfter running the loop, we print a confirmation that the selected files have been extracted. This script will create a new directory named if it doesn't exist and place all files inside it.\n\nThis is a simple example, but you can expand upon it by using more complex file patterns or extracting based on other criteria. For instance, you could extract only files from a specific subdirectory within the ZIP file, or files that were modified before or after a certain date.\n\nRemember, working with files can sometimes lead to errors, such as trying to extract a file that doesn't exist or encountering a corrupted ZIP archive. It's good practice to include error handling in your scripts to account for such scenarios, ensuring your program doesn't crash unexpectedly.### Updating Files in an Existing Zip Archive\n\nUpdating files in an existing zip archive is akin to sprucing up a well-organized digital filing cabinet. Just like in the physical world, where you might replace an old document with a newer version, with Python's module, you can update contents without having to create an entirely new zip file. This functionality is particularly useful for managing dynamic datasets or distributing software updates.\n\nTo update a file in a zip archive, we essentially need to create a temporary archive, copy all files from the original archive to the temporary one except the file(s) we want to update, add the updated file(s), and then replace the old archive with the new one. There isn't a direct update function in the module, so we have to get a bit creative. Here's a step-by-step example:\n\nIn this example, we define a function that takes the path of the zip file to be updated ( ), the name of the file within the zip that needs updating ( ), and the path to the new file that should replace the old one ( ).\n\nThe is a context manager that creates a temporary directory that is automatically cleaned up when the context is exited. We use this to avoid leaving any unnecessary files or directories on the filesystem.\n\nWe open the original zip file in read mode and create a new temporary zip file. We loop through all the files in the original zip and write them to the new zip unless it's the file we want to replace. After copying the existing files, we open the new zip in append mode ( ) and add the new file. Finally, we replace the old zip file with the new one using .\n\nRemember, when working with files, it's essential to handle file paths and operations carefully to avoid accidental data loss. Always back up important data before performing operations like these.\n\nThis process allows you to keep your zip archive up-to-date, which is very handy for applications that need to distribute updates or manage collections of files that change frequently.### Tips for Working Efficiently with zipfile\n\nWhen working with the module in Python, knowing a few tips and tricks can significantly optimize your workflow and make your code more efficient and robust. Let's dive into some practical advice that can help you get the most out of the zipfile functionalities.\n\nUsing context managers is not just a good practice for file handling in Python, but it's especially beneficial when working with zip files. It ensures that the zip file is properly closed after its operations, even if an error occurs. This helps in preventing file corruption and resource leaks.\n\nWhen extracting files, it's crucial to validate the paths to avoid potential security risks such as directory traversal attacks. Always check that the extracted files are going to a designated directory.\n\nSometimes you might not need to extract files to work with them; you can read them directly from the archive. This can save time and disk space.\n\nCompress Only When Necessary\n\nCompression can be resource-intensive. If you're dealing with files that are already compressed (like JPG or MP3), you might want to store them without additional compression to save processing time.\n\nWhen adding or extracting multiple files, it's more efficient to perform these operations in batches rather than one at a time. This is particularly true for creating zip archives.\n\nUse the Object for More Control\n\nThe class can be used to set various attributes of the files inside the archive, such as timestamps or file permissions, before adding them to the zip file.\n\nBy following these tips, you can work with zip files in Python more efficiently and safely. Remember to always handle files carefully, especially when dealing with user inputs or extracting files to your system. And as always, context managers are your friend when it comes to managing resources effectively."
    },
    {
        "link": "https://geeksforgeeks.org/unzipping-files-in-python",
        "document": "In this article we will see how to unzip the files in python we can achieve this functionality by using zipfile module in Python.\n\nZIP file is a file format that is used for compressing multiple files together into a single file. It is used in an archive file format that supports lossless data compression and reduces storage requirements it also improves data transfer over standard connections. Zip files make the task of sharing multiple files easy by comprising them into one. The ZipFile class contains extractall() and extract() methods which are used for unzipping the files.\n\nThe extractall() method is used to extract all the files present in the zip file to the current working directory. Files can also be extracted to a different location bypassing the path parameter.\n\nThe extract() method is used to Extract a member from the zip to the current working directory. The file can also be extracted to a different location bypassing the path parameter.\n\nExample 1: Extracting all the files present in the zip\n\nImport the zipfile module Create a zip file object using ZipFile class. Call the extractall() method on zip file object and pass the path where the files needed to be extracted and Extracting the specific file present in the zip.\n\nExample 2: Extracting the specific file present in the zip\n\nImport the zipfile module Create a zip file object using ZipFile class. Call the extract() method on the zip file object and pass the name of the file to be extracted and the path where the file needed to be extracted and Extracting the specific file present in the zip."
    },
    {
        "link": "https://stackoverflow.com/questions/3362600/how-to-send-email-attachments",
        "document": "I am having problems understanding how to email an attachment using Python. I have successfully emailed simple messages with the smtplib . Could someone please explain how to send an attachment in an email. I know there are other posts online but as a Python beginner I find them hard to understand.\n\nBecause there are many answers here for Python 3, but none which show how to use the overhauled library from Python 3.6, here is a quick copy+paste from the current examples documentation. (I have abridged it somewhat to remove frills like guessing the correct MIME type.) Modern code which targets Python >3.5 should no longer use the API (including the various , , etc classes) or the even older mumbo jumbo. from email.message import EmailMessage import smtplib from pathlib import Path msg = EmailMessage() msg[\"Subject\"] = \"Our family reunion\" msg[\"From\"] = \"me <[email protected]>\" msg[\"To\"] = \"recipient <[email protected]>\" # definitely don't mess with the .preamble msg.set_content(\"Hello, victim! Look at these pictures\") picpath = Path(\"path/to/attachment.png\") with picpath.open(\"rb\") as fp: msg.add_attachment( fp.read(), maintype=\"image\", subtype=\"png\", filename=picpath.name) # Notice how smtplib now includes a send_message() method with smtplib.SMTP(\"localhost\") as s: s.send_message(msg) The modern API is now quite a bit more versatile and logical than the older version of the library. There are still a few kinks around the presentation in the documentation (it's not obvious how to change the of an attachment, for example; and the discussion of the module is probably too obscure for most newcomers) and fundamentally, you still need to have some sort of idea of what the MIME structure should look like (though the library now finally takes care of a lot of the nitty-gritty around that). Perhaps see What are the \"parts\" in a multipart email? for a brief introduction. Using as your SMTP server obviously only works if you actually have an SMTP server running on your local computer. Properly getting email off your system is a fairly complex separate question. For simple requirements, probably use your existing email account and your provider's email server (search for examples of using port 587 with Google, Yahoo, or whatever you have - what exactly works depends somewhat on the provider; some will only support port 465, or legacy port 25 which is however now by and large impossible to use on public-facing servers because of spam filtering).\n\nNone of the currently given answers here will work correctly with non-ASCII symbols in filenames with clients like GMail, Outlook 2016, and others that don't support RFC 2231 (e.g., see here). The Python 3 code below is adapted from some other stackoverflow answers (sorry, didn't save the origin links) and odoo/openerp code for Python 2.7 (see ir_mail_server.py). It works correctly with GMail and others, and also uses SSL. import smtplib, ssl from os.path import basename from email.mime.base import MIMEBase from mimetypes import guess_type from email.encoders import encode_base64 from email.mime.multipart import MIMEMultipart from email.mime.text import MIMEText from email.utils import COMMASPACE, formatdate from email.charset import Charset def try_coerce_ascii(string_utf8): \"\"\"Attempts to decode the given utf8-encoded string as ASCII after coercing it to UTF-8, then return the confirmed 7-bit ASCII string. If the process fails (because the string contains non-ASCII characters) returns ``None``. \"\"\" try: string_utf8.encode('ascii') except UnicodeEncodeError: return return string_utf8 def encode_header_param(param_text): \"\"\"Returns an appropriate RFC 2047 encoded representation of the given header parameter value, suitable for direct assignation as the param value (e.g. via Message.set_param() or Message.add_header()) RFC 2822 assumes that headers contain only 7-bit characters, so we ensure it is the case, using RFC 2047 encoding when needed. :param param_text: unicode or utf-8 encoded string with header value :rtype: string :return: if ``param_text`` represents a plain ASCII string, return the same 7-bit string, otherwise returns an ASCII string containing the RFC2047 encoded text. \"\"\" if not param_text: return \"\" param_text_ascii = try_coerce_ascii(param_text) return param_text_ascii if param_text_ascii\\ else Charset('utf8').header_encode(param_text) smtp_server = '<someserver.com>' smtp_port = 465 # Default port for SSL sender_email = '<[email protected]>' sender_password = '<PASSWORD>' receiver_emails = ['<[email protected]>', '<[email protected]>'] subject = 'Test message' message = \"\"\"\\ Hello! This is a test message with attachments. This message is sent from Python.\"\"\" files = ['<path1>/файл1.pdf', '<path2>/файл2.png'] # Create a secure SSL context context = ssl.create_default_context() msg = MIMEMultipart() msg['From'] = sender_email msg['To'] = COMMASPACE.join(receiver_emails) msg['Date'] = formatdate(localtime=True) msg['Subject'] = subject msg.attach(MIMEText(message)) for f in files: mimetype, _ = guess_type(f) mimetype = mimetype.split('/', 1) with open(f, \"rb\") as fil: part = MIMEBase(mimetype[0], mimetype[1]) part.set_payload(fil.read()) encode_base64(part) filename_rfc2047 = encode_header_param(basename(f)) # The default RFC 2231 encoding of Message.add_header() works in Thunderbird but not GMail # so we fix it by using RFC 2047 encoding for the filename instead. part.set_param('name', filename_rfc2047) part.add_header('Content-Disposition', 'attachment', filename=filename_rfc2047) msg.attach(part) with smtplib.SMTP_SSL(smtp_server, smtp_port, context=context) as server: server.login(sender_email, sender_password) server.sendmail(sender_email, receiver_emails, msg.as_string())\n\nHad a bit of a hussle in getting my script to send generic attachments but after a bit of work doing research and skimming through articles on this post, I finally came up with the following # to query: import sys import ast from datetime import datetime import smtplib import mimetypes from email.mime.application import MIMEApplication from email.mime.multipart import MIMEMultipart from email import encoders from email.message import Message from email.mime.audio import MIMEAudio from email.mime.base import MIMEBase from email.mime.image import MIMEImage from email.mime.text import MIMEText from dotenv import load_dotenv, dotenv_values load_dotenv() # load environment variables from .env ''' sample .env file # .env file SECRET_KEY=\"gnhfpsjxxxxxxxx\" DOMAIN=\"GMAIL\" TOP_LEVEL_DOMAIN=\"COM\" EMAIL=\"CHESERExxxxxx@${DOMAIN}.${TOP_LEVEL_DOMAIN}\" TO_ADDRESS = (\"[email protected]\",\"[email protected]\")#didn't use this in the code but you can load recipients from here ''' import smtplib tls_port = 587 ssl_port = 465 smtp_server_domain_names = {'GMAIL': ('smtp.gmail.com', tls_port, ssl_port), 'OUTLOOK': ('smtp-mail.outlook.com', tls_port, ssl_port), 'YAHOO': ('smtp.mail.yahoo.com', tls_port, ssl_port), 'AT&T': ('smtp.mail.att.net', tls_port, ssl_port), } # todo: Ability to choose mail server provider # auto read in from the dictionary the respective mail server address and the tls and ssl ports class Bimail: def __init__(self, subject, recipients): self.subject = subject self.recipients = recipients self.htmlbody = '' self.mail_username = 'will be loaded from .env file' self.mail_password = 'loaded from .env file as well' self.attachments = [] # Creating an smtp object # todo: if gmail passed in use gmail's dictionary values def setup_mail_client(self, domain_key_to_use=\"GMAIL\", email_servers_domains_dict=smtp_server_domain_names): \"\"\" :param report_pdf: :type to_address: str \"\"\" smtpObj = None encryption_status = True config = dotenv_values(\".env\") # check if the domain_key exists from within the available email-servers-domains dict file passed in # else throw an error # read environment file to get the Domain to be used if f\"{domain_key_to_use}\" in email_servers_domains_dict.keys(): # if the key is found do the following # 1.extract the domain,tls,ssl ports from email_servers dict for use in program try: values_tuple = email_servers_domains_dict.get(f\"{domain_key_to_use}\") ssl_port = values_tuple[2] tls_port = values_tuple[1] smtp_server = values_tuple[0] smtpObj = smtplib.SMTP(smtp_server, tls_port) print(f\"Success connect with tls on {tls_port}\") print('Awaiting for connection encryption via startttls()') encryption_status = False except: print(f\"Failed connection via tls on port {tls_port}\") try: smtpObj = smtplib.SMTP_SSL(smtp_server, ssl_port) print(f\"Success connect with ssl on {ssl_port}\") encryption_status = True except: print(f\"Failed connection via ssl on port {ssl_port}\") finally: print(\"Within Finally block\") if not smtpObj: print(\"Failed!!! no Internet connection\") else: # if connection channel is unencrypted via the use of tls encrypt it if not encryption_status: status = smtpObj.starttls() if status[0] == 220: print(\"Successfully Encrypted tls channel\") print(\"Successfully Connected!!!! Requesting Login\") # Loading .env file values to config variable #load Login Creds from ENV File self.mail_username = f'{config.get(\"EMAIL\")}' self.mail_password = f'{cofig.get(\"SECRET_KEY\")}' status = smtpObj.login(self.mail_usernam,self.mail_password) if status[0] == 235: print(\"Successfully Authenticated User to xxx account\") success = self.send(smtpObj, f'{config.get(\"EMAIL\")}') if not bool(success): print(f\"Success in Sending Mail to {success}\") print(\"Disconnecting from Server INstance\") quit_result = smtpObj.quit() else: print(f\"Failed to Post {success}!!!\") print(f\"Quiting anyway !!!\") quit_result = smtpObj.quit() else: print(\"Application Specific Password is Required\") else: print(\"World\") def send(self,smtpObj,from_address): msg = MIMEMultipart('alternative') msg['From'] = from_address msg['Subject'] = self.subject msg['To'] = \", \".join(self.recipients) # to must be array of the form ['[email protected]'] msg.preamble = \"preamble goes here\" # check if there are attachments if yes, add them if self.attachments: self.attach(msg) # add html body after attachments msg.attach(MIMEText(self.htmlbody, 'html')) # send print(f\"Attempting Email send to the following addresses {self.recipients}\") result = smtpObj.sendmail(from_address, self.recipients,msg.as_string()) return result def htmladd(self, html): self.htmlbody = self.htmlbody + '<p></p>' + html def attach(self, msg): for f in self.attachments: ctype, encoding = mimetypes.guess_type(f) if ctype is None or encoding is not None: ctype = \"application/octet-stream\" maintype, subtype = ctype.split(\"/\", 1) if maintype == \"text\": fp = open(f) # Note: we should handle calculating the charset attachment = MIMEText(fp.read(), _subtype=subtype) fp.close() elif maintype == \"image\": fp = open(f, \"rb\") attachment = MIMEImage(fp.read(), _subtype=subtype) fp.close() elif maintype == \"ppt\": fp = open(f, \"rb\") attachment = MIMEApplication(fp.read(), _subtype=subtype) fp.close() elif maintype == \"audio\": fp = open(f, \"rb\") attachment = MIMEAudio(fp.read(), _subtype=subtype) fp.close() else: fp = open(f, \"rb\") attachment = MIMEBase(maintype, subtype) attachment.set_payload(fp.read()) fp.close() encoders.encode_base64(attachment) attachment.add_header(\"Content-Disposition\", \"attachment\", filename=f) attachment.add_header('Content-ID', '<{}>'.format(f)) msg.attach(attachment) def addattach(self, files): self.attachments = self.attachments + files # example below if __name__ == '__main__': # subject and recipients mymail = Bimail('Sales email ' + datetime.now().strftime('%Y/%m/%d'), ['[email protected]', '[email protected]']) # start html body. Here we add a greeting. mymail.htmladd('Good morning, find the daily summary below.') # Further things added to body are separated by a paragraph, so you do not need to worry about newlines for new sentences # here we add a line of text and an html table previously stored in the variable mymail.htmladd('Daily sales') mymail.addattach(['htmlsalestable.xlsx']) # another table name + table mymail.htmladd('Daily bestsellers') mymail.addattach(['htmlbestsellertable.xlsx']) # add image chart title mymail.htmladd('Weekly sales chart') # attach image chart mymail.addattach(['saleschartweekly.png']) # refer to image chart in html mymail.htmladd('<img src=\"cid:saleschartweekly.png\"/>') # attach another file mymail.addattach(['MailSend.py']) # send! mymail.setup_mail_client( domain_key_to_use=\"GMAIL\",email_servers_domains_dict=smtp_server_domain_names)"
    },
    {
        "link": "https://medium.com/@abdullahzulfiqar653/sending-emails-with-attachments-using-python-32b908909d73",
        "document": "Sending emails is a common practice in nearly every software application. That’s why sending files as attachments is prevalent; it allows us to easily share data and documents via email. Many of you may be seeking guidance on how to send a file attachment via email, which is why you’re reading my article. In this article, I will explain how to send an email with a attachment.\n\nCSV, XLSX, or TXT are common file extensions that we frequently use in our daily work routines. They’re handy for sharing data such as reports or lists. When you attach a file to an email, you can easily send this data to someone else.\n\nSending emails with attachments is a common task, which is why Python provides built-in email libraries. We will utilize these libraries along with smtplib to send emails.\n\nBefore we start, ensure you have the following requirements ready:\n\n1 — Python should be installed on your system.\n\n2 — You should have valid email account with SMTP server details.\n\nI am using Gmail SMTP for this example, which is quite generic. You can use your email as the username for Gmail SMTP, and for the password, you’ll need to create an app-specific password from your Gmail account. To create an app password, follow this link. Then, in the “How you sign in to Google” section, navigate to 2-Step Verification, where you can create your app password.\n\nWriting code and sending emails using the code below:\n\n\n\n# All imports below are part of python built packages no need to install any exras\n\n\n\n# smtplib provides functionality to send emails using SMTP.\n\nimport smtplib\n\n# MIMEMultipart send emails with both text content and attachments.\n\nfrom email.mime.multipart import MIMEMultipart\n\n# MIMEText for creating body of the email message.\n\nfrom email.mime.text import MIMEText\n\n# MIMEApplication attaching application-specific data (like CSV files) to email messages.\n\nfrom email.mime.application import MIMEApplication\n\n\n\nsubject = \"Email Subject\"\n\nbody = \"This is the body of the text message\"\n\nsender_email = \"your_mail@gmail.com\"\n\nrecipient_email = \"reciever_mail@gmail.com\"\n\nsender_password = \"Valid password here\"\n\nsmtp_server = 'smtp.gmail.com'\n\nsmtp_port = 465\n\npath_to_file = 'example.csv'\n\n\n\n# MIMEMultipart() creates a container for an email message that can hold\n\n# different parts, like text and attachments and in next line we are\n\n# attaching different parts to email container like subject and others.\n\nmessage = MIMEMultipart()\n\nmessage['Subject'] = subject\n\nmessage['From'] = sender_email\n\nmessage['To'] = recipient_email\n\nbody_part = MIMEText(body)\n\nmessage.attach(body_part)\n\n\n\n# section 1 to attach file\n\nwith open(path_to_file,'rb') as file:\n\n # Attach the file with filename to the email\n\n message.attach(MIMEApplication(file.read(), Name=\"example.csv\"))\n\n\n\n# secction 2 for sending email\n\nwith smtplib.SMTP_SSL(smtp_server, smtp_port) as server:\n\n server.login(sender_email, sender_password)\n\n server.sendmail(sender_email, recipient_email, message.as_string())\n\nIn the above example, remember to modify the SMTP server if you’re using a different one. Also, in the ‘file’ variable, I’ve set it as ‘example.csv’ assuming the file is in the same directory as the Python script. However, if your file is located elsewhere, be sure to specify the complete path to the file you want to send as an attachment.\n• = sender’s email means if its you then your email\n• = set server which you are using\n• = SMTP port, set it to 465 if using gmail smtp\n\nBecause these variables contain sensitive data, I highly recommend supplying them from environment variables.\n\nexplanation about import statement and lines after is already explained using comments in the code but last 2 sections of code where we using with expression are not explained so check the explanation below:\n• This code snippet opens a file located at a specified path in “read binary” mode (‘rb’). Then, it reads the contents of the file and attaches it to an email message. The attached file is given the name “example.csv”.\n• This code connects to an email server securely (using SSL), logs in with the sender’s email and password, and then sends an email from the sender to the recipient.\n\nsending emails with attachments using Python is a straightforward process. By following the steps outlined in this guide, you can easily share data and documents with others via email. Remember to handle sensitive information, such as SMTP credentials, with care. With Python’s built-in libraries and a few lines of code, you can automate the process of sending emails with attachments, making it efficient and convenient for various tasks."
    },
    {
        "link": "https://realpython.com/python-send-email",
        "document": "You probably found this tutorial because you want to send emails using Python. Perhaps you want to receive email reminders from your code, send a confirmation email to users when they create an account, or send emails to members of your organization to remind them to pay their dues. Sending emails manually is a time-consuming and error-prone task, but it’s easy to automate with Python.\n\nIn this tutorial you’ll learn how to:\n• Set up a secure connection using and\n• Send emails with HTML content and attachments using the package\n• Use the Yagmail package to send email through your Gmail account using only a few lines of code\n\nYou’ll find a few transactional email services at the end of this tutorial, which will come in useful when you want to send a large number of emails.\n\nPython comes with the built-in module for sending emails using the Simple Mail Transfer Protocol (SMTP). uses the RFC 821 protocol for SMTP. The examples in this tutorial will use the Gmail SMTP server to send emails, but the same principles apply to other email services. Although the majority of email providers use the same connection ports as the ones in this tutorial, you can run a quick Google search to confirm yours. To get started with this tutorial, set up a Gmail account for development, or set up an SMTP debugging server that discards emails you send and prints them to the command prompt instead. Both options are laid out for you below. A local SMTP debugging server can be useful for fixing any issues with email functionality and ensuring your email functions are bug-free before sending out any emails. If you decide to use a Gmail account to send your emails, I highly recommend setting up a throwaway account for the development of your code. This is because you’ll have to adjust your Gmail account’s security settings to allow access from your Python code, and because there’s a chance you might accidentally expose your login details. Also, I found that the inbox of my testing account rapidly filled up with test emails, which is reason enough to set up a new Gmail account for development. A nice feature of Gmail is that you can use the sign to add any modifiers to your email address, right before the sign. For example, mail sent to and will both arrive at . When testing email functionality, you can use this to emulate multiple addresses that all point to the same inbox. To set up a Gmail address for testing your code, do the following:\n• Turn Allow less secure apps to ON. Be aware that this makes it easier for others to gain access to your account. If you don’t want to lower the security settings of your Gmail account, check out Google’s documentation on how to gain access credentials for your Python script, using the OAuth2 authorization framework. You can test email functionality by running a local SMTP debugging server, using the module that comes pre-installed with Python. Rather than sending emails to the specified address, it discards them and prints their content to the console. Running a local debugging server means it’s not necessary to deal with encryption of messages or use credentials to log in to an email server. You can start a local SMTP debugging server by typing the following in Command Prompt: On Linux, use the same command preceded by . Any emails sent through this server will be discarded and shown in the terminal window as a object for each line: b'Hello there, here is a test email' For the rest of the tutorial, I’ll assume you’re using a Gmail account, but if you’re using a local debugging server, just make sure to use as your SMTP server and use port 1025 rather than port 465 or 587. Besides this, you won’t need to use or encrypt the communication using SSL/TLS.\n\nBefore we dive into sending emails with HTML content and attachments, you’ll learn to send plain-text emails using Python. These are emails that you could write up in a simple text editor. There’s no fancy stuff like text formatting or hyperlinks. You’ll learn that a bit later. When you send emails through Python, you should make sure that your SMTP connection is encrypted, so that your message and login credentials are not easily accessed by others. SSL (Secure Sockets Layer) and TLS (Transport Layer Security) are two protocols that can be used to encrypt an SMTP connection. It’s not necessary to use either of these when using a local debugging server. There are two ways to start a secure connection with your email server:\n• Start an SMTP connection that is secured from the beginning using .\n• Start an unsecured SMTP connection that can then be encrypted using . In both instances, Gmail will encrypt emails using TLS, as this is the more secure successor of SSL. As per Python’s Security considerations, it is highly recommended that you use from the module. This will load the system’s trusted CA certificates, enable host name checking and certificate validation, and try to choose reasonably secure protocol and cipher settings. If you want to check the encryption for an email in your Gmail inbox, go to More → Show original to see the encryption type listed under the Received header. is Python’s built-in module for sending emails to any Internet machine with an SMTP or ESMTP listener daemon. I’ll show you how to use first, as it instantiates a connection that is secure from the outset and is slightly more concise than the alternative. Keep in mind that Gmail requires that you connect to port 465 if using , and to port 587 when using . The code example below creates a secure connection with Gmail’s SMTP server, using the of to initiate a TLS-encrypted connection. The default context of validates the host name and its certificates and optimizes the security of the connection. Make sure to fill in your own email address instead of : Using makes sure that the connection is automatically closed at the end of the indented code block. If is zero, or not specified, will use the standard port for SMTP over SSL (port 465). It’s not safe practice to store your email password in your code, especially if you intend to share it with others. Instead, use to let the user type in their password when running the script, as in the example above. If you don’t want your password to show on your screen when you type it, you can import the module and use instead for blind input of your password. Instead of using to create a connection that is secure from the outset, we can create an unsecured SMTP connection and encrypt it using . To do this, create an instance of , which encapsulates an SMTP connection and allows you access to its methods. I recommend defining your SMTP server and port at the beginning of your script to configure them easily. The code snippet below uses the construction , rather than the format which we used in the previous example. To make sure that your code doesn’t crash when something goes wrong, put your main code in a block, and let an block print any error messages to : # Try to log in to server and send email To identify yourself to the server, (SMTP) or (ESMTP) should be called after creating an object, and again after . This function is implicitly called by and if needed, so unless you want to check the SMTP service extensions of the server, it is not necessary to use or explicitly. After you initiated a secure SMTP connection using either of the above methods, you can send your email using , which pretty much does what it says on the tin: I recommend defining the email addresses and message content at the top of your script, after the imports, so you can change them easily: This message is sent from Python.\"\"\" The string starts with followed by two newlines ( ). This ensures shows up as the subject of the email, and the text following the newlines will be treated as the message body. The code example below sends a plain-text email using : This message is sent from Python.\"\"\" For comparison, here is a code example that sends a plain-text email over an SMTP connection secured with . The lines may be omitted, as they are called implicitly by and , if required: This message is sent from Python.\"\"\"\n\nPython’s built-in package allows you to structure more fancy emails, which can then be transferred with as you have done already. Below, you’ll learn how use the package to send emails with HTML content and attachments. If you want to format the text in your email (bold, italics, and so on), or if you want to add any images, hyperlinks, or responsive content, then HTML comes in very handy. Today’s most common type of email is the MIME (Multipurpose Internet Mail Extensions) Multipart email, combining HTML and plain-text. MIME messages are handled by Python’s module. For a detailed description, check the documentation. As not all email clients display HTML content by default, and some people choose only to receive plain-text emails for security reasons, it is important to include a plain-text alternative for HTML messages. As the email client will render the last multipart attachment first, make sure to add the HTML message after the plain-text version. In the example below, our objects will contain the HTML and plain-text versions of our message, and the instance combines these into a single message with two alternative rendering options: # Create the plain-text and HTML version of your message # The email client will try to render the last part first In this example, you first define the plain-text and HTML message as string literals, and then store them as / objects. These can then be added in this order to the message and sent through your secure connection with the email server. Remember to add the HTML message after the plain-text alternative, as email clients will try to render the last subpart first. In order to send binary files to an email server that is designed to work with textual data, they need to be encoded before transport. This is most commonly done using , which encodes binary data into printable ASCII characters. The code example below shows how to send an email with a PDF file as an attachment: \"An email with attachment from Python\" \"This is an email with attachment sent from Python\" # In same directory as script # Email client can usually download this automatically as attachment # Encode file in ASCII characters to send by email # Add attachment to message and convert message to string # Log in to server using secure context and send email The message accepts parameters in the form of RFC5233-style key/value pairs, which are stored in a dictionary and passed to the method of the base class. Check out the documentation for Python’s module to learn more about using MIME classes.\n\nImagine you want to send emails to members of your organization, to remind them to pay their contribution fees. Or maybe you want to send students in your class personalized emails with the grades for their recent assignment. These tasks are a breeze in Python. An easy starting point for sending multiple personalized emails is to create a CSV (comma-separated values) file that contains all the required personal information. (Make sure not to share other people’s private information without their consent.) A CSV file can be thought of as a simple table, where the first line often contains the column headers. Below are the contents of the file , which I saved in the same folder as my Python code. It contains the names, addresses, and grades for a set of fictional people. I used constructions to make sure all emails end up in my own inbox, which in this example is my@gmail.com: When creating a CSV file, make sure to separate your values by a comma, without any surrounding whitespaces. The code example below shows you how to open a CSV file and loop over its lines of content (skipping the header row). To make sure that the code works correctly before you send emails to all your contacts, I’ve printed for each contact, which we can later replace with functionality that actually sends out emails: In the example above, using makes sure that your file closes at the end of the code block. makes it easy to read a CSV file line by line and extract its values. The line skips the header row, so that the following line for name, email, grade in reader: splits subsequent rows at each comma, and stores the resulting values in the strings , and for the current contact. If the values in your CSV file contain whitespaces on either or both sides, you can remove them using the method. You can put personalized content in a message by using to fill in curly-bracket placeholders. For example, \"hi {name}, you {result} your assignment\".format(name=\"John\", result=\"passed\") will give you \"hi John, you passed your assignment\" . As of Python 3.6, string formatting can be done more elegantly using f-strings, but these require the placeholders to be defined before the f-string itself. In order to define the email message at the beginning of the script, and fill in placeholders for each contact when looping over the CSV file, the older method is used. With this in mind, you can set up a general message body, with placeholders that can be tailored to individuals. The following code example lets you send personalized emails to multiple contacts. It loops over a CSV file with for each contact, as in the example above. The general message is defined in the beginning of the script, and for each contact in the CSV file its and placeholders are filled in, and a personalized email is sent out through a secure connection with the Gmail server, as you saw before:\n\nThere are multiple libraries designed to make sending emails easier, such as Envelopes, Flanker and Yagmail. Yagmail is designed to work specifically with Gmail, and it greatly simplifies the process of sending emails through a friendly API, as you can see in the code example below: \"Hello there from Yagmail\" This code example sends an email with a PDF attachment in a fraction of the lines needed for our example using and . When setting up Yagmail, you can add your Gmail validations to the keyring of your OS, as described in the documentation. If you don’t do this, Yagmail will prompt you to enter your password when required and store it in the keyring automatically.\n\nIf you plan to send a large volume of emails, want to see email statistics, and want to ensure reliable delivery, it may be worth looking into transactional email services. Although all of the following services have paid plans for sending large volumes of emails, they also come with a free plan so you can try them out. Some of these free plans are valid indefinitely and may be sufficient for your email needs. Below is an overview of the free plans for some of the major transactional email services. Clicking on the provider name will take you to the pricing section of their website. 40,000 emails for your first 30 days, then 100/day You can run a Google search to see which provider best fits your needs, or just try out a few of the free plans to see which API you like working with most."
    },
    {
        "link": "https://pythonroadmap.com/blog/send-email-attachments-with-python",
        "document": "Before we get started, you'll need to have the following prerequisites in place:\n• A working Python environment, such as Anaconda or Python.org\n• A valid email address and password for an email service provider, such as Gmail or Yahoo\n• Basic understanding of how to send emails with Python\n\nTo send email attachments we need two built-in python libraries : and .\n• library is used to create and format email messages and attachments to them\n• library is used to send email messages via SMTP(Simple Mail Transfer Protocol). SMTP is the protocol used to send emails, regardless of the language you are using.\n\nLet's start by opening a new Python file and writing the following code:\n\nNext, we'll specify our email credentials, such as your email address, password, and the SMTP server settings for your email service provider (e.g. Gmail, Yahoo, Outlook etc). Here's an example of how to set up a Gmail account:\n\nThese credentials will be latest passed on to the specified SMTP server and port. Note, if you're using a different email provider, you'll need to use the appropriate SMTP server settings. Here are the SMTP settings for some popular email providers :\n\nTo create an email message with attachments, we'll need to import the class we imported earlier from library. Let's create a simple email with a a short subject, body, and one attachment:\n\nIn this example, we created an email message with the subject 'Re: Hello, World!', with body \"Hello, this is a test email with an attachment.\". We have also added one attachment named \"attachment.txt\" using the method, this method reads the file data and sets the attachment's content type to \"text/plain.\"\n\nOnce we are done with the above steps, let's now send out email with attachment using library.\n\nHere we first created a SMTP server object using class. This object then makes a secure connection to the SMTP server, logs in with the credentials we specified earlier. We then send the email message using .\n\nLet's discuss some widely used cases that will be helpful while working with email attachments :\n\nTo add multiple attachments to your email message, simply call multiple times with different filenames and file data.\n\nThe and arguments for determine the content type of the attachment. Here are some common content types:\n\nIf you're working with large attachments, you may run into memory issues when reading the file data into memory with . To avoid this, you can use the method to iterate over the attachment data in chunks.\n\nUsing HTML in Your Email Message\n\nMost of the times we want to send fancy HTML templates as emails instead of boring-looking plaintext emails. To achieve this, simply set the message content to an HTML string using .\n\nHow do I handle errors when sending email attachments with Python?\n\n Using Python's exception handling you can catch and handle these errors. Based on the severity, you can log and retry on your exceptions as well.\n\nDepending on the error you can use exception handling to catch and handle these errors. You can add logging, retries as well to help diagnose and retry for failures.\n\nWhat file types can I send as email attachments with Python?\n\n You can send any file type including binaries as email attachments with Python. Remember, some mail servers may block the attachments if the file size, type is a potential security concern.\n\nCan I use Python to receive email attachments?\n\n Yes, to receive email with attachments in Python you can use library. You can then list or get emails, download attachments etc.\n\nHow can I ensure the security of email attachments sent with Python?\n\n Security for email and its attachments are dependent on the email service provider. Make sure you use a secure email service provider, keep strong passwords etc.\n\nHow do I test my email attachments to make sure they work?\n\n You can test by sending test emails with attachments to yourself or other mock email services like mailosaur or mailtrap. You can also test email attachments with varying attachment size etc.\n\nThat's all! In this blog post we saw how we can send email attachments with python easily using the and libraries. Feel free to reach out or comment below for your doubts. Happy emailing!"
    },
    {
        "link": "https://stackoverflow.com/questions/71709672/how-to-send-a-complete-email-using-smtplib-python",
        "document": "I am trying to send an email using Python .\n\nMy objective is to include the below info in email\n• None Paste the contents of a table in message body\n• None Write a few lines about the table (as text) in message body # not works. instead stores as an attachment\n\nSo, I tried the below code\n\nThe problem in my code is that it creates a text file (containing the message \"Hi, How are you\") and sends as an attachment?\n\nBut I want \"Hi, How are you\" as a text message in the main Outlook message window."
    },
    {
        "link": "https://docs.python.org/3/library/xml.etree.elementtree.html",
        "document": "The module implements a simple and efficient API for parsing and creating XML data.\n\nThis is a short tutorial for using ( in short). The goal is to demonstrate some of the building blocks and basic concepts of the module. XML is an inherently hierarchical data format, and the most natural way to represent it is with a tree. has two classes for this purpose - represents the whole XML document as a tree, and represents a single node in this tree. Interactions with the whole document (reading and writing to/from files) are usually done on the level. Interactions with a single XML element and its sub-elements are done on the level. We’ll be using the fictive XML document as the sample data for this section: We can import this data by reading from a file: parses XML from a string directly into an , which is the root element of the parsed tree. Other parsing functions may create an . Check the documentation to be sure. As an , has a tag and a dictionary of attributes: It also has children nodes over which we can iterate: Children are nested, and we can access specific child nodes by index: Not all elements of the XML input will end up as elements of the parsed tree. Currently, this module skips over any XML comments, processing instructions, and document type declarations in the input. Nevertheless, trees built using this module’s API rather than parsing from XML text can have comments and processing instructions in them; they will be included when generating XML output. A document type declaration may be accessed by passing a custom instance to the constructor. Most parsing functions provided by this module require the whole document to be read at once before returning any result. It is possible to use an and feed data into it incrementally, but it is a push API that calls methods on a callback target, which is too low-level and inconvenient for most needs. Sometimes what the user really wants is to be able to parse XML incrementally, without blocking operations, while enjoying the convenience of fully constructed objects. The most powerful tool for doing this is . It does not require a blocking read to obtain the XML data, and is instead fed with data incrementally with calls. To get the parsed XML elements, call . Here is an example: The obvious use case is applications that operate in a non-blocking fashion where the XML data is being received from a socket or read incrementally from some storage device. In such cases, blocking reads are unacceptable. Because it’s so flexible, can be inconvenient to use for simpler use-cases. If you don’t mind your application blocking on reading XML data but would still like to have incremental parsing capabilities, take a look at . It can be useful when you’re reading a large XML document and don’t want to hold it wholly in memory. Where immediate feedback through events is wanted, calling method can help reduce delay; please make sure to study the related security notes. has some useful methods that help iterate recursively over all the sub-tree below it (its children, their children, and so on). For example, : finds only elements with a tag which are direct children of the current element. finds the first child with a particular tag, and accesses the element’s text content. accesses the element’s attributes: More sophisticated specification of which elements to look for is possible by using XPath. provides a simple way to build XML documents and write them to files. The method serves this purpose. Once created, an object may be manipulated by directly changing its fields (such as ), adding and modifying attributes ( method), as well as adding new children (for example with ). Let’s say we want to add one to each country’s rank, and add an attribute to the rank element: Our XML now looks like this: We can remove elements using . Let’s say we want to remove all countries with a rank higher than 50: # using root.findall() to avoid removal during traversal Note that concurrent modification while iterating can lead to problems, just like when iterating and modifying Python lists or dicts. Therefore, the example first collects all matching elements with , and only then iterates over the list of matches. Our XML now looks like this: The function also provides a convenient way to create new sub-elements for a given element: If the XML input has namespaces, tags and attributes with prefixes in the form get expanded to where the prefix is replaced by the full URI. Also, if there is a default namespace, that full URI gets prepended to all of the non-prefixed tags. Here is an XML example that incorporates two namespaces, one with the prefix “fictional” and the other serving as the default namespace: One way to search and explore this XML example is to manually add the URI to every tag or attribute in the xpath of a or : A better way to search the namespaced XML example is to create a dictionary with your own prefixes and use those in the search functions: These two approaches both output:\n\nThis module provides limited support for XPath expressions for locating elements in a tree. The goal is to support a small subset of the abbreviated syntax; a full XPath engine is outside the scope of the module. Here’s an example that demonstrates some of the XPath capabilities of the module. We’ll be using the XML document from the Parsing XML section: # All 'neighbor' grand-children of 'country' children of the top-level # Nodes with name='Singapore' that have a 'year' child # 'year' nodes that are children of nodes with name='Singapore' # All 'neighbor' nodes that are the second child of their parent For XML with namespaces, use the usual qualified notation: # All dublin-core \"title\" tags in the document Selects all child elements with the given tag. For example, selects all child elements named , and selects all grandchildren named in all children named . selects all tags in the given namespace, selects tags named in any (or no) namespace, and only selects tags that are not in a namespace. Changed in version 3.8: Support for star-wildcards was added. Selects all child elements, including comments and processing instructions. For example, selects all grandchildren named . Selects the current node. This is mostly useful at the beginning of the path, to indicate that it’s a relative path. Selects all subelements, on all levels beneath the current element. For example, selects all elements in the entire tree. Selects the parent element. Returns if the path attempts to reach the ancestors of the start element (the element was called on). Selects all elements that have the given attribute. Selects all elements for which the given attribute has the given value. The value cannot contain quotes. Selects all elements for which the given attribute does not have the given value. The value cannot contain quotes. Selects all elements that have a child named . Only immediate children are supported. Selects all elements whose complete text content, including descendants, equals the given . Selects all elements whose complete text content, including descendants, does not equal the given . Selects all elements that have a child named whose complete text content, including descendants, equals the given . Selects all elements that have a child named whose complete text content, including descendants, does not equal the given . Selects all elements that are located at the given position. The position can be either an integer (1 is the first position), the expression (for the last position), or a position relative to the last position (e.g. ). Predicates (expressions within square brackets) must be preceded by a tag name, an asterisk, or another predicate. predicates must be preceded by a tag name.\n\nCanonicalization is a way to normalise XML output in a way that allows byte-by-byte comparisons and digital signatures. It reduces the freedom that XML serializers have and instead generates a more constrained XML representation. The main restrictions regard the placement of namespace declarations, the ordering of attributes, and ignorable whitespace. This function takes an XML data string (xml_data) or a file path or file-like object (from_file) as input, converts it to the canonical form, and writes it out using the out file(-like) object, if provided, or returns it as a text string if not. The output file receives text, not bytes. It should therefore be opened in text mode with encoding. The configuration options are as follows:\n• None strip_text: set to true to strip whitespace before and after text content\n• None rewrite_prefixes: set to true to replace namespace prefixes by “n{number}”\n• None qname_aware_tags: a set of qname aware tag names in which prefixes should be replaced in text content (default: empty)\n• None qname_aware_attrs: a set of qname aware attribute names in which prefixes should be replaced in text content (default: empty)\n• None exclude_attrs: a set of attribute names that should not be serialised\n• None exclude_tags: a set of tag names that should not be serialised In the option list above, “a set” refers to any collection or iterable of strings, no ordering is expected. Comment element factory. This factory function creates a special element that will be serialized as an XML comment by the standard serializer. The comment string can be either a bytestring or a Unicode string. text is a string containing the comment string. Returns an element instance representing a comment. Note that skips over comments in the input instead of creating comment objects for them. An will only contain comment nodes if they have been inserted into to the tree using one of the methods. Writes an element tree or element structure to sys.stdout. This function should be used for debugging only. The exact output format is implementation dependent. In this version, it’s written as an ordinary XML file. elem is an element tree or an individual element. Changed in version 3.8: The function now preserves the attribute order specified by the user. Parses an XML section from a string constant. Same as . text is a string containing XML data. parser is an optional parser instance. If not given, the standard parser is used. Returns an instance. Parses an XML document from a sequence of string fragments. sequence is a list or other sequence containing XML data fragments. parser is an optional parser instance. If not given, the standard parser is used. Returns an instance. Appends whitespace to the subtree to indent the tree visually. This can be used to generate pretty-printed XML output. tree can be an Element or ElementTree. space is the whitespace string that will be inserted for each indentation level, two space characters by default. For indenting partial subtrees inside of an already indented tree, pass the initial indentation level as level. Check if an object appears to be a valid element object. element is an element instance. Return if this is an element object. Parses an XML section into an element tree incrementally, and reports what’s going on to the user. source is a filename or file object containing XML data. events is a sequence of events to report back. The supported events are the strings , , , , and (the “ns” events are used to get detailed namespace information). If events is omitted, only events are reported. parser is an optional parser instance. If not given, the standard parser is used. parser must be a subclass of and can only use the default as a target. Returns an iterator providing pairs; it has a attribute that references the root element of the resulting XML tree once source is fully read. The iterator has the method that closes the internal file object if source is a filename. Note that while builds the tree incrementally, it issues blocking reads on source (or the file it names). As such, it’s unsuitable for applications where blocking reads can’t be made. For fully non-blocking parsing, see . only guarantees that it has seen the “>” character of a starting tag when it emits a “start” event, so the attributes are defined, but the contents of the text and tail attributes are undefined at that point. The same applies to the element children; they may or may not be present. If you need a fully populated element, look for “end” events instead. Changed in version 3.8: The and events were added. Parses an XML section into an element tree. source is a filename or file object containing XML data. parser is an optional parser instance. If not given, the standard parser is used. Returns an instance. PI element factory. This factory function creates a special element that will be serialized as an XML processing instruction. target is a string containing the PI target. text is a string containing the PI contents, if given. Returns an element instance, representing a processing instruction. Note that skips over processing instructions in the input instead of creating PI objects for them. An will only contain processing instruction nodes if they have been inserted into to the tree using one of the methods. Registers a namespace prefix. The registry is global, and any existing mapping for either the given prefix or the namespace URI will be removed. prefix is a namespace prefix. uri is a namespace uri. Tags and attributes in this namespace will be serialized with the given prefix, if at all possible. Subelement factory. This function creates an element instance, and appends it to an existing element. The element name, attribute names, and attribute values can be either bytestrings or Unicode strings. parent is the parent element. tag is the subelement name. attrib is an optional dictionary, containing element attributes. extra contains additional attributes, given as keyword arguments. Returns an element instance. Generates a string representation of an XML element, including all subelements. element is an instance. encoding is the output encoding (default is US-ASCII). Use to generate a Unicode string (otherwise, a bytestring is generated). method is either , or (default is ). xml_declaration, default_namespace and short_empty_elements has the same meaning as in . Returns an (optionally) encoded string containing the XML data. Changed in version 3.8: Added the xml_declaration and default_namespace parameters. Changed in version 3.8: The function now preserves the attribute order specified by the user. Generates a string representation of an XML element, including all subelements. element is an instance. encoding is the output encoding (default is US-ASCII). Use to generate a Unicode string (otherwise, a bytestring is generated). method is either , or (default is ). xml_declaration, default_namespace and short_empty_elements has the same meaning as in . Returns a list of (optionally) encoded strings containing the XML data. It does not guarantee any specific sequence, except that . Changed in version 3.8: Added the xml_declaration and default_namespace parameters. Changed in version 3.8: The function now preserves the attribute order specified by the user. Parses an XML section from a string constant. This function can be used to embed “XML literals” in Python code. text is a string containing XML data. parser is an optional parser instance. If not given, the standard parser is used. Returns an instance. Parses an XML section from a string constant, and also returns a dictionary which maps from element id:s to elements. text is a string containing XML data. parser is an optional parser instance. If not given, the standard parser is used. Returns a tuple containing an instance and a dictionary.\n\nDefault loader. This default loader reads an included resource from disk. href is a URL. parse is for parse mode either “xml” or “text”. encoding is an optional text encoding. If not given, encoding is . Returns the expanded resource. If the parse mode is , this is an instance. If the parse mode is , this is a string. If the loader fails, it can return or raise an exception. This function expands XInclude directives in-place in tree pointed by elem. elem is either the root or an instance to find such element. loader is an optional resource loader. If omitted, it defaults to . If given, it should be a callable that implements the same interface as . base_url is base URL of the original file, to resolve relative include file references. max_depth is the maximum number of recursive inclusions. Limited to reduce the risk of malicious content explosion. Pass to disable the limitation. Changed in version 3.9: Added the base_url and max_depth parameters. Element class. This class defines the Element interface, and provides a reference implementation of this interface. The element name, attribute names, and attribute values can be either bytestrings or Unicode strings. tag is the element name. attrib is an optional dictionary, containing element attributes. extra contains additional attributes, given as keyword arguments. A string identifying what kind of data this element represents (the element type, in other words). These attributes can be used to hold additional data associated with the element. Their values are usually strings but may be any application-specific object. If the element is created from an XML file, the text attribute holds either the text between the element’s start tag and its first child or end tag, or , and the tail attribute holds either the text between the element’s end tag and the next tag, or . For the XML data the a element has for both text and tail attributes, the b element has text and tail , the c element has text and tail , and the d element has text and tail . To collect the inner text of an element, see , for example . Applications may store arbitrary objects in these attributes. A dictionary containing the element’s attributes. Note that while the attrib value is always a real mutable Python dictionary, an ElementTree implementation may choose to use another internal representation, and create the dictionary only if someone asks for it. To take advantage of such implementations, use the dictionary methods below whenever possible. The following dictionary-like methods work on the element attributes. Resets an element. This function removes all subelements, clears all attributes, and sets the text and tail attributes to . Returns the attribute value, or default if the attribute was not found. Returns the element attributes as a sequence of (name, value) pairs. The attributes are returned in an arbitrary order. Returns the elements attribute names as a list. The names are returned in an arbitrary order. Set the attribute key on the element to value. The following methods work on the element’s children (subelements). Adds the element subelement to the end of this element’s internal list of subelements. Raises if subelement is not an . Appends subelements from an iterable of elements. Raises if a subelement is not an . Finds the first subelement matching match. match may be a tag name or a path. Returns an element instance or . namespaces is an optional mapping from namespace prefix to full name. Pass as prefix to move all unprefixed tag names in the expression into the given namespace. Finds all matching subelements, by tag name or path. Returns a list containing all matching elements in document order. namespaces is an optional mapping from namespace prefix to full name. Pass as prefix to move all unprefixed tag names in the expression into the given namespace. Finds text for the first subelement matching match. match may be a tag name or a path. Returns the text content of the first matching element, or default if no element was found. Note that if the matching element has no text content an empty string is returned. namespaces is an optional mapping from namespace prefix to full name. Pass as prefix to move all unprefixed tag names in the expression into the given namespace. Inserts subelement at the given position in this element. Raises if subelement is not an . Creates a tree iterator with the current element as the root. The iterator iterates over this element and all elements below it, in document (depth first) order. If tag is not or , only elements whose tag equals tag are returned from the iterator. If the tree structure is modified during iteration, the result is undefined. Finds all matching subelements, by tag name or path. Returns an iterable yielding all matching elements in document order. namespaces is an optional mapping from namespace prefix to full name. Creates a text iterator. The iterator loops over this element and all subelements, in document order, and returns all inner text. Creates a new element object of the same type as this element. Do not call this method, use the factory function instead. Removes subelement from the element. Unlike the find* methods this method compares elements based on the instance identity, not on tag value or contents. objects also support the following sequence type methods for working with subelements: , , , . Caution: Elements with no subelements will test as . In a future release of Python, all elements will test as regardless of whether subelements exist. Instead, prefer explicit or elem is not None tests.: \"element not found, or element has no subelements\" Changed in version 3.12: Testing the truth value of an Element emits . Prior to Python 3.8, the serialisation order of the XML attributes of elements was artificially made predictable by sorting the attributes by their name. Based on the now guaranteed ordering of dicts, this arbitrary reordering was removed in Python 3.8 to preserve the order in which attributes were originally parsed or created by user code. In general, user code should try not to depend on a specific ordering of attributes, given that the XML Information Set explicitly excludes the attribute order from conveying information. Code should be prepared to deal with any ordering on input. In cases where deterministic XML output is required, e.g. for cryptographic signing or test data sets, canonical serialisation is available with the function. In cases where canonical output is not applicable but a specific attribute order is still desirable on output, code should aim for creating the attributes directly in the desired order, to avoid perceptual mismatches for readers of the code. In cases where this is difficult to achieve, a recipe like the following can be applied prior to serialisation to enforce an order independently from the Element creation: ElementTree wrapper class. This class represents an entire element hierarchy, and adds some extra support for serialization to and from standard XML. element is the root element. The tree is initialized with the contents of the XML file if given. Replaces the root element for this tree. This discards the current contents of the tree, and replaces it with the given element. Use with care. element is an element instance. Same as , starting at the root of the tree. Same as , starting at the root of the tree. Same as , starting at the root of the tree. Returns the root element for this tree. Creates and returns a tree iterator for the root element. The iterator loops over all elements in this tree, in section order. tag is the tag to look for (default is to return all elements). Same as , starting at the root of the tree. Loads an external XML section into this element tree. source is a file name or file object. parser is an optional parser instance. If not given, the standard parser is used. Returns the section root element. Writes the element tree to a file, as XML. file is a file name, or a file object opened for writing. encoding is the output encoding (default is US-ASCII). xml_declaration controls if an XML declaration should be added to the file. Use for never, for always, for only if not US-ASCII or UTF-8 or Unicode (default is ). default_namespace sets the default XML namespace (for “xmlns”). method is either , or (default is ). The keyword-only short_empty_elements parameter controls the formatting of elements that contain no content. If (the default), they are emitted as a single self-closed tag, otherwise they are emitted as a pair of start/end tags. The output is either a string ( ) or binary ( ). This is controlled by the encoding argument. If encoding is , the output is a string; otherwise, it’s binary. Note that this may conflict with the type of file if it’s an open file object; make sure you do not try to write a string to a binary stream and vice versa. Changed in version 3.8: The method now preserves the attribute order specified by the user. This is the XML file that is going to be manipulated: Example of changing the attribute “target” of every link in first paragraph: # Finds first occurrence of tag p in body QName wrapper. This can be used to wrap a QName attribute value, in order to get proper namespace handling on output. text_or_uri is a string containing the QName value, in the form {uri}local, or, if the tag argument is given, the URI part of a QName. If tag is given, the first argument is interpreted as a URI, and this argument is interpreted as a local name. instances are opaque. Generic element structure builder. This builder converts a sequence of start, data, end, comment and pi method calls to a well-formed element structure. You can use this class to build an element structure using a custom XML parser, or a parser for some other XML-like format. element_factory, when given, must be a callable accepting two positional arguments: a tag and a dict of attributes. It is expected to return a new element instance. The comment_factory and pi_factory functions, when given, should behave like the and functions to create comments and processing instructions. When not given, the default factories will be used. When insert_comments and/or insert_pis is true, comments/pis will be inserted into the tree if they appear within the root element (but not outside of it). Flushes the builder buffers, and returns the toplevel document element. Returns an instance. Adds text to the current element. data is a string. This should be either a bytestring, or a Unicode string. Closes the current element. tag is the element name. Returns the closed element. Opens a new element. tag is the element name. attrs is a dictionary containing element attributes. Returns the opened element. Creates a comment with the given text. If is true, this will also add it to the tree. Creates a process instruction with the given target name and text. If is true, this will also add it to the tree. In addition, a custom object can provide the following methods: Handles a doctype declaration. name is the doctype name. pubid is the public identifier. system is the system identifier. This method does not exist on the default class. Is called whenever the parser encounters a new namespace declaration, before the callback for the opening element that defines it. prefix is for the default namespace and the declared namespace prefix name otherwise. uri is the namespace URI. Is called after the callback of an element that declared a namespace prefix mapping, with the name of the prefix that went out of scope. A C14N 2.0 writer. Arguments are the same as for the function. This class does not build a tree but translates the callback events directly into a serialised form using the write function. This class is the low-level building block of the module. It uses for efficient, event-based parsing of XML. It can be fed XML data incrementally with the method, and parsing events are translated to a push API - by invoking callbacks on the target object. If target is omitted, the standard is used. If encoding is given, the value overrides the encoding specified in the XML file. Changed in version 3.8: Parameters are now keyword-only. The html argument is no longer supported. Finishes feeding data to the parser. Returns the result of calling the method of the target passed during construction; by default, this is the toplevel document element. Feeds data to the parser. data is encoded data. Triggers parsing of any previously fed unparsed data, which can be used to ensure more immediate feedback, in particular with Expat >=2.6.0. The implementation of temporarily disables reparse deferral with Expat (if currently enabled) and triggers a reparse. Disabling reparse deferral has security consequences; please see for details. Note that has been backported to some prior releases of CPython as a security fix. Check for availability of using if used in code running across a variety of Python versions. calls target's method for each opening tag, its method for each closing tag, and data is processed by method . For further supported callback methods, see the class. calls target's method . can be used not only for building a tree structure. This is an example of counting the maximum depth of an XML file: # The target object of the parser # We do not need to do anything with data. # Called when all data has been parsed. A pull parser suitable for non-blocking applications. Its input-side API is similar to that of , but instead of pushing calls to a callback target, collects an internal list of parsing events and lets the user read from it. events is a sequence of events to report back. The supported events are the strings , , , , and (the “ns” events are used to get detailed namespace information). If events is omitted, only events are reported. Feed the given bytes data to the parser. Triggers parsing of any previously fed unparsed data, which can be used to ensure more immediate feedback, in particular with Expat >=2.6.0. The implementation of temporarily disables reparse deferral with Expat (if currently enabled) and triggers a reparse. Disabling reparse deferral has security consequences; please see for details. Note that has been backported to some prior releases of CPython as a security fix. Check for availability of using if used in code running across a variety of Python versions. Signal the parser that the data stream is terminated. Unlike , this method always returns . Any events not yet retrieved when the parser is closed can still be read with . Return an iterator over the events which have been encountered in the data fed to the parser. The iterator yields pairs, where event is a string representing the type of event (e.g. ) and elem is the encountered object, or other context value as follows.\n• None : (this may change in a future version) Events provided in a previous call to will not be yielded again. Events are consumed from the internal queue only when they are retrieved from the iterator, so multiple readers iterating in parallel over iterators obtained from will have unpredictable results. only guarantees that it has seen the “>” character of a starting tag when it emits a “start” event, so the attributes are defined, but the contents of the text and tail attributes are undefined at that point. The same applies to the element children; they may or may not be present. If you need a fully populated element, look for “end” events instead. Changed in version 3.8: The and events were added. XML parse error, raised by the various parsing methods in this module when parsing fails. The string representation of an instance of this exception will contain a user-friendly error message. In addition, it will have the following attributes available: A numeric error code from the expat parser. See the documentation of for the list of error codes and their meanings. A tuple of line, column numbers, specifying where the error occurred."
    },
    {
        "link": "https://datacamp.com/tutorial/python-xml-elementtree",
        "document": "Master the basics of data analysis with Python in just four hours. This online course will introduce the Python interface and explore popular packages."
    },
    {
        "link": "https://stackoverflow.com/questions/4722794/parsing-an-xml-file-using-element-tree",
        "document": "I have a large number of .xml files (about 70) and i need to extract some co-ordinates from them. Apparently the best way to do this is to parse the xml file using element tree. I am new to python (very very new!) and am having a difficult time understanding all of the documentation which comes with element tree! I was wondering if anyone had any code where they have used element tree or if anyone could explain to me how to go about it.. Thank you!\n\nThis is a sample from my XML file..\n\nI need to extract the lower and upper corner co-ordinates (lowerCorner/upperCorner)\n\nUpdate: Here is my full script:\n\nI am now getting the error:\n\nand now i am REALLY confused because i am able to access these files with a different script which is almost exactly the same as this one!!"
    },
    {
        "link": "https://scrapingant.com/blog/python-parse-xml",
        "document": "Parsing XML (eXtensible Markup Language) in Python is a fundamental task for many developers, given XML's widespread use in data storage and transmission. Python offers a variety of libraries for XML parsing, each catering to different needs and use cases. Understanding the strengths and limitations of these libraries is crucial for efficient and effective XML processing. This guide explores both standard and third-party libraries, providing code samples and detailed explanations to help you choose the right tool for your project.\n\nPython's standard library includes modules like , , and , each designed for specific parsing requirements. For more advanced needs, third-party libraries like , , and offer enhanced performance, leniency in parsing malformed XML, and ease of use.\n\nThis comprehensive guide also delves into best practices for XML parsing in Python, addressing performance optimization, handling large files, and ensuring robust error handling and validation. By the end of this guide, you will be equipped with the knowledge to handle XML parsing tasks efficiently and securely, regardless of the complexity or size of the XML documents you encounter.\n\nPython's standard library offers several modules for XML parsing, each with its own strengths and use cases:\n\nThe ElementTree API is a lightweight and efficient way to parse XML in Python. It provides a simple, Pythonic interface for working with XML data (Python documentation).\n\nElementTree is suitable for most XML parsing tasks and is often the go-to choice for its simplicity and performance.\n\nThe minidom module implements a minimal DOM interface for XML parsing (Python documentation). While it's less efficient than ElementTree, it can be useful for small XML documents or when DOM compatibility is required.\n\nSAX (Simple API for XML) is an event-driven parser that doesn't load the entire XML document into memory (Python documentation). This makes it suitable for processing very large XML files or streams.\n\nWhile the standard library modules are sufficient for many tasks, third-party libraries can offer additional features, better performance, or easier-to-use APIs:\n\nlxml is a fast, feature-rich library for processing XML and HTML (lxml documentation). It combines the speed and features of libxml2 and libxslt with the simplicity of the ElementTree API.\n\nlxml is particularly useful for its XPath support, XSLT capabilities, and schema validation features. It's often the best choice for complex XML processing tasks or when performance is critical.\n\nWhile primarily known for HTML parsing, BeautifulSoup can also handle XML documents (BeautifulSoup documentation). It’s particularly useful for its forgiving nature when dealing with malformed XML.\n\nBeautifulSoup is a good choice when working with potentially malformed XML or when you need a more lenient parser.\n\nuntangle is a simple library that converts XML to Python objects, making it very easy to navigate XML structures (untangle documentation).\n\nuntangle is ideal for quick and dirty XML parsing tasks where you don't need advanced features and want a very simple API.\n\nLearn more about Python libraries for web scraping with Python in the following article Web Scraping with Python.\n\nWhen choosing an XML parsing library, performance can be a crucial factor. Here's a comparison of parsing speeds for a 10MB XML file:\n\nThese numbers are approximate and can vary based on the specific XML structure and parsing task. lxml consistently outperforms other libraries, especially for large XML files.\n\nWhen parsing XML from untrusted sources, security is a critical concern. XML parsing can be vulnerable to various attacks, including billion laughs attacks and external entity expansion (OWASP XML Security Cheat Sheet).\n\nThe standard library XML parsers in Python are vulnerable to these attacks by default. For secure XML parsing, consider using the defusedxml library (defusedxml documentation), which provides safe replacements for all of Python's standard library XML parsers:\n\nWhen using third-party libraries like lxml, be sure to disable entity resolution and other potentially dangerous features when parsing untrusted XML:\n\nThe choice of XML parsing library depends on your specific requirements:\n• For very large XML files or memory-constrained environments, use xml.sax.\n• For complex XML processing, XPath support, or high performance, use lxml.\n• For lenient parsing of potentially malformed XML, use BeautifulSoup.\n• For quick and easy XML-to-object conversion, use untangle.\n\nAlways consider the trade-offs between ease of use, performance, feature set, and security when selecting an XML parsing library for your Python project.\n\nDiscover the best Python libraries for XML parsing, including xml.etree.ElementTree, lxml, BeautifulSoup, and more. Learn how to use each with code examples and performance comparisons.\n\nWhen it comes to XML parsing in Python, selecting the appropriate parser is crucial for optimal performance and functionality. The choice largely depends on the size of the XML files and the specific requirements of your project.\n• None\n• Use or its C implementation (default in Python 3.3+) for efficient parsing (Python documentation).\n• These built-in Python XML parsers offer a good balance of speed and ease of use for most applications.\n• None\n• Consider using , a fast and feature-rich Python library that combines the power of libxml2 and libxslt (lxml documentation).\n• is particularly efficient for parsing large XML documents and provides additional functionality like XPath support.\n• None\n• Utilize event-driven parsing with or to process XML data without loading the entire document into memory (xml.parsers.expat documentation).\n\nTo enhance XML parsing performance in Python, consider implementing the following best practices:\n• None Use iterative parsing: Employ iterative parsing techniques to process large XML files efficiently. For example, with : This approach allows processing of elements as they are parsed, reducing memory usage (Stack Overflow discussion).\n• None Clear unnecessary elements: When using iterative parsing, clear processed elements to free up memory: This technique prevents memory buildup during parsing of large XML files.\n• None Use XPath for efficient querying: Leverage XPath expressions for precise and efficient element selection, especially when working with complex XML structures: XPath queries can significantly reduce the amount of code needed for element selection and improve performance (lxml XPath documentation).\n• None Implement partial parsing: For scenarios where only specific parts of the XML document are needed, use partial parsing to improve efficiency: This approach allows processing of only relevant elements, reducing unnecessary parsing overhead.\n\nWhen dealing with XML files exceeding 1GB in size, special considerations are necessary:\n• None Stream parsing: Utilize streaming parsers like or to process the XML file in chunks, avoiding the need to load the entire document into memory: This method allows processing of extremely large XML files without memory constraints (Python documentation).\n• None This approach allows processing of large XML files in smaller, memory-friendly portions.\n\nImplementing robust error handling and validation is crucial for reliable XML parsing:\n• None Use try-except blocks: Wrap parsing operations in try-except blocks to handle potential exceptions gracefully: This practice ensures that your application can handle parsing errors without crashing.\n• None Implement XML schema validation: Use XML Schema Definition (XSD) to validate XML documents before parsing: XML schema validation ensures that the parsed XML adheres to the expected structure and data types (lxml validation documentation).\n• None Handle encoding issues: Be prepared to handle different XML encodings by specifying the correct encoding or using Unicode: This approach helps prevent encoding-related parsing errors, especially when dealing with XML files from various sources.\n\nBy following these best practices, developers can significantly improve the efficiency, reliability, and performance of XML parsing in Python, even when working with large and complex XML documents.\n\nIn conclusion, parsing XML in Python can range from simple to complex tasks depending on the requirements of your project. The standard libraries like , , and offer robust solutions for most common XML parsing needs, while third-party libraries like , , and provide additional features and performance enhancements for more demanding tasks.\n\nWhen choosing an XML parser, consider the size of your XML files, memory constraints, and the specific functionalities you need. For instance, is ideal for typical use cases due to its simplicity and efficiency, whereas excels in performance and advanced XML processing capabilities, including XPath and XSLT support (lxml documentation). For handling potentially malformed XML, is a forgiving option, and offers a straightforward approach for quick XML-to-object conversion (BeautifulSoup documentation, untangle documentation).\n\nAdhering to best practices such as iterative parsing, clearing unnecessary elements, and employing XML schema validation can significantly improve the efficiency and reliability of your XML parsing tasks. Additionally, when dealing with untrusted XML sources, always consider security implications and use safe parsing methods, like those provided by the library (defusedxml documentation).\n\nBy leveraging the right tools and techniques, you can ensure that your XML parsing in Python is both efficient and secure, enabling you to handle a wide range of XML processing scenarios effectively."
    },
    {
        "link": "https://python.readthedocs.io/fr/latest/library/xml.etree.elementtree.html",
        "document": "The module implements a simple and efficient API for parsing and creating XML data.\n\nThis is a short tutorial for using ( in short). The goal is to demonstrate some of the building blocks and basic concepts of the module. XML is an inherently hierarchical data format, and the most natural way to represent it is with a tree. has two classes for this purpose - represents the whole XML document as a tree, and represents a single node in this tree. Interactions with the whole document (reading and writing to/from files) are usually done on the level. Interactions with a single XML element and its sub-elements are done on the level. We’ll be using the following XML document as the sample data for this section: We can import this data by reading from a file: parses XML from a string directly into an , which is the root element of the parsed tree. Other parsing functions may create an . Check the documentation to be sure. As an , has a tag and a dictionary of attributes: Children are nested, and we can access specific child nodes by index: Not all elements of the XML input will end up as elements of the parsed tree. Currently, this module skips over any XML comments, processing instructions, and document type declarations in the input. Nevertheless, trees built using this module’s API rather than parsing from XML text can have comments and processing instructions in them; they will be included when generating XML output. A document type declaration may be accessed by passing a custom instance to the constructor. Most parsing functions provided by this module require the whole document to be read at once before returning any result. It is possible to use an and feed data into it incrementally, but it is a push API that calls methods on a callback target, which is too low-level and inconvenient for most needs. Sometimes what the user really wants is to be able to parse XML incrementally, without blocking operations, while enjoying the convenience of fully constructed objects. The most powerful tool for doing this is . It does not require a blocking read to obtain the XML data, and is instead fed with data incrementally with calls. To get the parsed XML elements, call . Here is an example: The obvious use case is applications that operate in a non-blocking fashion where the XML data is being received from a socket or read incrementally from some storage device. In such cases, blocking reads are unacceptable. Because it’s so flexible, can be inconvenient to use for simpler use-cases. If you don’t mind your application blocking on reading XML data but would still like to have incremental parsing capabilities, take a look at . It can be useful when you’re reading a large XML document and don’t want to hold it wholly in memory. has some useful methods that help iterate recursively over all the sub-tree below it (its children, their children, and so on). For example, : finds only elements with a tag which are direct children of the current element. finds the first child with a particular tag, and accesses the element’s text content. accesses the element’s attributes: More sophisticated specification of which elements to look for is possible by using XPath. provides a simple way to build XML documents and write them to files. The method serves this purpose. Once created, an object may be manipulated by directly changing its fields (such as ), adding and modifying attributes ( method), as well as adding new children (for example with ). Let’s say we want to add one to each country’s rank, and add an attribute to the rank element: We can remove elements using . Let’s say we want to remove all countries with a rank higher than 50: The function also provides a convenient way to create new sub-elements for a given element: If the XML input has namespaces, tags and attributes with prefixes in the form get expanded to where the prefix is replaced by the full URI. Also, if there is a default namespace, that full URI gets prepended to all of the non-prefixed tags. Here is an XML example that incorporates two namespaces, one with the prefix “fictional” and the other serving as the default namespace: One way to search and explore this XML example is to manually add the URI to every tag or attribute in the xpath of a or : A better way to search the namespaced XML example is to create a dictionary with your own prefixes and use those in the search functions: See http://effbot.org/zone/element-index.htm for tutorials and links to other docs.\n\nThis module provides limited support for XPath expressions for locating elements in a tree. The goal is to support a small subset of the abbreviated syntax; a full XPath engine is outside the scope of the module. Here’s an example that demonstrates some of the XPath capabilities of the module. We’ll be using the XML document from the Parsing XML section: # All 'neighbor' grand-children of 'country' children of the top-level # Nodes with name='Singapore' that have a 'year' child # 'year' nodes that are children of nodes with name='Singapore' # All 'neighbor' nodes that are the second child of their parent Selects all child elements with the given tag. For example, selects all child elements named , and selects all grandchildren named in all children named . Selects the current node. This is mostly useful at the beginning of the path, to indicate that it’s a relative path. Selects all subelements, on all levels beneath the current element. For example, selects all elements in the entire tree. Selects the parent element. Returns if the path attempts to reach the ancestors of the start element (the element was called on). Selects all elements for which the given attribute has the given value. The value cannot contain quotes. Selects all elements that have a child named . Only immediate children are supported. Selects all elements that have a child named whose complete text content, including descendants, equals the given . Selects all elements that are located at the given position. The position can be either an integer (1 is the first position), the expression (for the last position), or a position relative to the last position (e.g. ). Predicates (expressions within square brackets) must be preceded by a tag name, an asterisk, or another predicate. predicates must be preceded by a tag name.\n\nComment element factory. This factory function creates a special element that will be serialized as an XML comment by the standard serializer. The comment string can be either a bytestring or a Unicode string. text is a string containing the comment string. Returns an element instance representing a comment. Note that skips over comments in the input instead of creating comment objects for them. An will only contain comment nodes if they have been inserted into to the tree using one of the methods. Writes an element tree or element structure to sys.stdout. This function should be used for debugging only. The exact output format is implementation dependent. In this version, it’s written as an ordinary XML file. elem is an element tree or an individual element. Parses an XML section from a string constant. Same as . text is a string containing XML data. Returns an instance. Parses an XML document from a sequence of string fragments. sequence is a list or other sequence containing XML data fragments. parser is an optional parser instance. If not given, the standard parser is used. Returns an instance. Checks if an object appears to be a valid element object. element is an element instance. Returns a true value if this is an element object. Parses an XML section into an element tree incrementally, and reports what’s going on to the user. source is a filename or file object containing XML data. events is a sequence of events to report back. The supported events are the strings , , and (the “ns” events are used to get detailed namespace information). If events is omitted, only events are reported. parser is an optional parser instance. If not given, the standard parser is used. parser must be a subclass of and can only use the default as a target. Returns an iterator providing pairs. Note that while builds the tree incrementally, it issues blocking reads on source (or the file it names). As such, it’s unsuitable for applications where blocking reads can’t be made. For fully non-blocking parsing, see . only guarantees that it has seen the “>” character of a starting tag when it emits a “start” event, so the attributes are defined, but the contents of the text and tail attributes are undefined at that point. The same applies to the element children; they may or may not be present. If you need a fully populated element, look for “end” events instead. Parses an XML section into an element tree. source is a filename or file object containing XML data. parser is an optional parser instance. If not given, the standard parser is used. Returns an instance. PI element factory. This factory function creates a special element that will be serialized as an XML processing instruction. target is a string containing the PI target. text is a string containing the PI contents, if given. Returns an element instance, representing a processing instruction. Note that skips over processing instructions in the input instead of creating comment objects for them. An will only contain processing instruction nodes if they have been inserted into to the tree using one of the methods. Registers a namespace prefix. The registry is global, and any existing mapping for either the given prefix or the namespace URI will be removed. prefix is a namespace prefix. uri is a namespace uri. Tags and attributes in this namespace will be serialized with the given prefix, if at all possible. Subelement factory. This function creates an element instance, and appends it to an existing element. The element name, attribute names, and attribute values can be either bytestrings or Unicode strings. parent is the parent element. tag is the subelement name. attrib is an optional dictionary, containing element attributes. extra contains additional attributes, given as keyword arguments. Returns an element instance. Generates a string representation of an XML element, including all subelements. element is an instance. encoding is the output encoding (default is US-ASCII). Use to generate a Unicode string (otherwise, a bytestring is generated). method is either , or (default is ). short_empty_elements has the same meaning as in . Returns an (optionally) encoded string containing the XML data. Nouveau dans la version 3.4: The short_empty_elements parameter. Generates a string representation of an XML element, including all subelements. element is an instance. encoding is the output encoding (default is US-ASCII). Use to generate a Unicode string (otherwise, a bytestring is generated). method is either , or (default is ). short_empty_elements has the same meaning as in . Returns a list of (optionally) encoded strings containing the XML data. It does not guarantee any specific sequence, except that . Nouveau dans la version 3.4: The short_empty_elements parameter. Parses an XML section from a string constant. This function can be used to embed “XML literals” in Python code. text is a string containing XML data. parser is an optional parser instance. If not given, the standard parser is used. Returns an instance. Parses an XML section from a string constant, and also returns a dictionary which maps from element id:s to elements. text is a string containing XML data. parser is an optional parser instance. If not given, the standard parser is used. Returns a tuple containing an instance and a dictionary. Element class. This class defines the Element interface, and provides a reference implementation of this interface. The element name, attribute names, and attribute values can be either bytestrings or Unicode strings. tag is the element name. attrib is an optional dictionary, containing element attributes. extra contains additional attributes, given as keyword arguments. A string identifying what kind of data this element represents (the element type, in other words). These attributes can be used to hold additional data associated with the element. Their values are usually strings but may be any application-specific object. If the element is created from an XML file, the text attribute holds either the text between the element’s start tag and its first child or end tag, or , and the tail attribute holds either the text between the element’s end tag and the next tag, or . For the XML data the a element has for both text and tail attributes, the b element has text and tail , the c element has text and tail , and the d element has text and tail . To collect the inner text of an element, see , for example . A dictionary containing the element’s attributes. Note that while the attrib value is always a real mutable Python dictionary, an ElementTree implementation may choose to use another internal representation, and create the dictionary only if someone asks for it. To take advantage of such implementations, use the dictionary methods below whenever possible. The following dictionary-like methods work on the element attributes. Resets an element. This function removes all subelements, clears all attributes, and sets the text and tail attributes to . Returns the attribute value, or default if the attribute was not found. Returns the element attributes as a sequence of (name, value) pairs. The attributes are returned in an arbitrary order. Returns the elements attribute names as a list. The names are returned in an arbitrary order. Set the attribute key on the element to value. The following methods work on the element’s children (subelements). Adds the element subelement to the end of this element’s internal list of subelements. Raises if subelement is not an . Appends subelements from a sequence object with zero or more elements. Raises if a subelement is not an . Finds the first subelement matching match. match may be a tag name or a path. Returns an element instance or . namespaces is an optional mapping from namespace prefix to full name. Finds all matching subelements, by tag name or path. Returns a list containing all matching elements in document order. namespaces is an optional mapping from namespace prefix to full name. Finds text for the first subelement matching match. match may be a tag name or a path. Returns the text content of the first matching element, or default if no element was found. Note that if the matching element has no text content an empty string is returned. namespaces is an optional mapping from namespace prefix to full name. Inserts subelement at the given position in this element. Raises if subelement is not an . Creates a tree iterator with the current element as the root. The iterator iterates over this element and all elements below it, in document (depth first) order. If tag is not or , only elements whose tag equals tag are returned from the iterator. If the tree structure is modified during iteration, the result is undefined. Finds all matching subelements, by tag name or path. Returns an iterable yielding all matching elements in document order. namespaces is an optional mapping from namespace prefix to full name. Creates a text iterator. The iterator loops over this element and all subelements, in document order, and returns all inner text. Creates a new element object of the same type as this element. Do not call this method, use the factory function instead. Removes subelement from the element. Unlike the find* methods this method compares elements based on the instance identity, not on tag value or contents. objects also support the following sequence type methods for working with subelements: , , , . Caution: Elements with no subelements will test as . This behavior will change in future versions. Use specific or test instead. \"element not found, or element has no subelements\" ElementTree wrapper class. This class represents an entire element hierarchy, and adds some extra support for serialization to and from standard XML. element is the root element. The tree is initialized with the contents of the XML file if given. Replaces the root element for this tree. This discards the current contents of the tree, and replaces it with the given element. Use with care. element is an element instance. Same as , starting at the root of the tree. Same as , starting at the root of the tree. Same as , starting at the root of the tree. Returns the root element for this tree. Creates and returns a tree iterator for the root element. The iterator loops over all elements in this tree, in section order. tag is the tag to look for (default is to return all elements). Same as , starting at the root of the tree. Loads an external XML section into this element tree. source is a file name or file object. parser is an optional parser instance. If not given, the standard parser is used. Returns the section root element. Writes the element tree to a file, as XML. file is a file name, or a file object opened for writing. encoding is the output encoding (default is US-ASCII). xml_declaration controls if an XML declaration should be added to the file. Use for never, for always, for only if not US-ASCII or UTF-8 or Unicode (default is ). default_namespace sets the default XML namespace (for “xmlns”). method is either , or (default is ). The keyword-only short_empty_elements parameter controls the formatting of elements that contain no content. If (the default), they are emitted as a single self-closed tag, otherwise they are emitted as a pair of start/end tags. The output is either a string ( ) or binary ( ). This is controlled by the encoding argument. If encoding is , the output is a string; otherwise, it’s binary. Note that this may conflict with the type of file if it’s an open file object; make sure you do not try to write a string to a binary stream and vice versa. Nouveau dans la version 3.4: The short_empty_elements parameter. This is the XML file that is going to be manipulated: Example of changing the attribute “target” of every link in first paragraph: [<Element 'a' at 0xb77ec2ac>, <Element 'a' at 0xb77ec1cc>] QName wrapper. This can be used to wrap a QName attribute value, in order to get proper namespace handling on output. text_or_uri is a string containing the QName value, in the form {uri}local, or, if the tag argument is given, the URI part of a QName. If tag is given, the first argument is interpreted as a URI, and this argument is interpreted as a local name. instances are opaque. Generic element structure builder. This builder converts a sequence of start, data, and end method calls to a well-formed element structure. You can use this class to build an element structure using a custom XML parser, or a parser for some other XML-like format. element_factory, when given, must be a callable accepting two positional arguments: a tag and a dict of attributes. It is expected to return a new element instance. Flushes the builder buffers, and returns the toplevel document element. Returns an instance. Adds text to the current element. data is a string. This should be either a bytestring, or a Unicode string. Closes the current element. tag is the element name. Returns the closed element. Opens a new element. tag is the element name. attrs is a dictionary containing element attributes. Returns the opened element. In addition, a custom object can provide the following method: Handles a doctype declaration. name is the doctype name. pubid is the public identifier. system is the system identifier. This method does not exist on the default class. This class is the low-level building block of the module. It uses for efficient, event-based parsing of XML. It can be fed XML data incrementally with the method, and parsing events are translated to a push API - by invoking callbacks on the target object. If target is omitted, the standard is used. The html argument was historically used for backwards compatibility and is now deprecated. If encoding is given, the value overrides the encoding specified in the XML file. Obsolète depuis la version 3.4: The html argument. The remaining arguments should be passed via keyword to prepare for the removal of the html argument. Finishes feeding data to the parser. Returns the result of calling the method of the target passed during construction; by default, this is the toplevel document element. Obsolète depuis la version 3.2: Define the method on a custom TreeBuilder target. Feeds data to the parser. data is encoded data. calls target‘s method for each opening tag, its method for each closing tag, and data is processed by method . calls target‘s method . can be used not only for building a tree structure. This is an example of counting the maximum depth of an XML file: # The target object of the parser # We do not need to do anything with data. A pull parser suitable for non-blocking applications. Its input-side API is similar to that of , but instead of pushing calls to a callback target, collects an internal list of parsing events and lets the user read from it. events is a sequence of events to report back. The supported events are the strings , , and (the “ns” events are used to get detailed namespace information). If events is omitted, only events are reported. Feed the given bytes data to the parser. Signal the parser that the data stream is terminated. Unlike , this method always returns . Any events not yet retrieved when the parser is closed can still be read with . Return an iterator over the events which have been encountered in the data fed to the parser. The iterator yields pairs, where event is a string representing the type of event (e.g. ) and elem is the encountered object. Events provided in a previous call to will not be yielded again. Events are consumed from the internal queue only when they are retrieved from the iterator, so multiple readers iterating in parallel over iterators obtained from will have unpredictable results. only guarantees that it has seen the “>” character of a starting tag when it emits a “start” event, so the attributes are defined, but the contents of the text and tail attributes are undefined at that point. The same applies to the element children; they may or may not be present. If you need a fully populated element, look for “end” events instead. XML parse error, raised by the various parsing methods in this module when parsing fails. The string representation of an instance of this exception will contain a user-friendly error message. In addition, it will have the following attributes available: A numeric error code from the expat parser. See the documentation of for the list of error codes and their meanings. A tuple of line, column numbers, specifying where the error occurred."
    }
]