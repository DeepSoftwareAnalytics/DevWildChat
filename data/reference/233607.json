[
    {
        "link": "https://keil.com/download/docs/350.asp",
        "document": "Modified Anytime In the Last 7 Days In the Last 14 Days In the Last 30 Days In the Last 90 Days In the Last 6 Months\n\nThe STM32 GPIO example program shows how to configure and use the GPIO ports of STMicroelectronics STM32F103xx microcontroller.\n\n \n\n Pins PB8..PB15 (LEDs) are configured as output and pins PA0 (S2) and PC13 (S3) are configured as input. By pressing buttons S2 or S3 the lit LED moves to the left or to the right.\n\n \n\n The configuration of the clocks and the GPIO ports is done using the Configuration Wizard in file STM32_Init.c.\n\n \n\n Two µVision targets are available:\n• Simulator where the program runs in the software simulator. A debug script (gpio.ini) is used to simulate the buttons S2, S3.\n• MCBSTM32 where the program runs from internal Flash located on the microcontroller. The example is tesed with the Keil Evaluation Board MCBSTM32."
    },
    {
        "link": "https://stilllot2learn.wordpress.com/2018/10/12/getting-started-with-stm32f10x-gpio",
        "document": "Its been a while(more than 8 months since my last post) since I had written any post in this blog. I had decided to learn some real embedded development. So, I purchased a blue pill board featuring a STM32F10x microcontroller. I am from a computer science background, but like many Indian students, did not concentrate on learning anything in college except for java and C#. I have been working as a embedded systems test engineer and most of my work involves performing integration and black box testing on safety critical avionics systems. I always lacked the “hardware knowledge” of how these systems work and my work always revolved around the software part of these systems. I wanted to know more about how the whole system works and how the software and hardware are interfaced and their working in a real world scenario. In past, I had worked on Arduino but that is just simple and abstracts all the hardware access into simple functions and libraries that we can use. Now, that I have a lot of spare time, I have decided to learn how to program the microcontrollers and basic electronics used with it. I’ll be sharing my journey learning embedded development and occasional android development when I do IOT projects. To make my self comfortable with embedded development I am following this particular book by Mr. Geoffrey Brown from Indiana University.\n\nYou can find this book in the below link.\n\nBefore we get started, I’ll list all the things we need to program the blue pill and the hardware used in this demo.\n\nI have linked the hardware required to Amazon. If you would purchase it through my link,it would help contribute to my future projects. The prices are as it is if you buy directly from Amazon.\n\nI am using System Workbench for STM32 IDE to code and program. This is available for free in the below link.\n\nTo setup the stlink V2 debugger with blue pill board, follow this link.\n\nEventhough, the above link about using it in linux environment, all we need to know is the pin connections between stlinkv2 and blue pill. Rest will be handled by the System workbench for STM32.\n\nIn this post, we will do a basic setup which involves using two switches to control the onboard LED in the blue pill board. The switches I had scavenged from an old scanner.\n\nHere is the circuit for the connections. I am noob at Fritzing software so excuse the poor layout.\n\nI recommend reading first 90 pages of the book to understand why we are using RCC functions and how we are configuring the GPIO port Pins to act as inputs and outputs.\n\nHere is the code.\n\nWe need to include these three header files. The “stm32f10x.h” is the header file for our STM32 Microcontroller. It has all the definitions and register mappings. This is the first line of hardware interface to work with the Microcontroller. It is basically a file containing macros which is mapped to various address of the peripherals, registers and memory. This include file makes our life easier and removes the need to working with various register and peripheral addresses directly.\n\nWe will be using Standard peripheral library that is supplied by ST, the manufacturer of STM32 controllers. These library will have the drivers written for all the peripherals and functionality that STM32 has to offer. “stm32f10x_gpio.h” is one such driver for GPIO(General Purpose Input/output) peripherals. These are by far the easiest peripherals to use. These are basically hardware pins of the Microcontroller which does not have a special functionality yet. These are to be used my the user.\n\n“stm43f10x_rcc.h” relates to Reset and clock control. All peripherals need a clock signal to work. It tells the Microcontroller in what periods to read/write data.\n\nUsually prototypes needs to be declared in .h header files. Since we are writing a very small program, I have included it in the main.c file. This is basically telling the compiler what the function initializeGPIOPorts() should take as input and what type it should output. Not having prototype can cause Issues later in the program because without declaration, the input is taken as integer type and there can be error introduced when calling the function later in the program.\n\nFor STM32 line of devices, there is three steps to use any peripherals. First is to enable the clock for the peripheral, second is set the control register of the peripheral, and lastly set the speed. In the bluepill, the microcontroller used is STM32F1032C8T6, which is a medium density microcontroller offering speeds upto 72MHz, 64k of Flash and 20k of SRAM. In order to understand the use of the above function we need to check the architecture of the microcontroller and how it is interfaced with its peripherals. If you see the system architecture, the GPIO peripherals are connected via APB2 bridge of AHB system bus. So, we are calling the RCC_APB2PeriphClockCmd function and supplying the GPIOB port to be enable the clock for the peripheral.\n\nThe datatype GPIO_InitTypeDef is available in the “stm32f10x_gpio.h” header file. It is just a structure carrying three fields namely pin, mode and speed. GPIO_StructInit just initialize the supplied structure to default values.\n\nThe code is straight forward. GPIO_Mode denotes whether the pin should be output or input. GPIO_Pin denotes which pin of the Port C has to be used. GPIO_Speed denotes what speed the pin should sample the data.\n\nThe GPIO_Init function has to be called in order to setup the port. This function will write to control registers for the specified port. The parameter GPIOB, GPIOC are defined in the “stm32f10x.h” header file.\n\nJust calling our function in which we had set up our pin configuration.\n\nWhile(1) is just an infinite loop. Whatever logic comes inside this loop will be executed infinite times.\n\nThe above condition reads the pin 12 and pin 13 state of Port B in which we had connected the switch. If the input is HIGH in either or both of this pins, then the Port C pin 13 will be set to HIGH(Bit_SET), else The pin 13 of port c will be set to LOW(Bit_RESET).\n\nThat’s all folks. See you next post!"
    },
    {
        "link": "https://engineersgarage.com/accessing-ports-of-stm32-microcontroller",
        "document": "Lets now do a practical. I am going to access the stm32f103 port-b and write to its pins 0 and 1 using ODR register. At the output i connected 2 leds so the output binary pattern can easily be recognized. Since 2 pins are used so the binary pattern will be 00, 01,10 and 11. If you don;t know how to initialize the stm32 gpio pins and ports here is a simple tutorial on initialing the stm32f103 microcontroller pins using stm32cubemx and generating code for keil arm ide. After initializing the pins using stm32cubemx and generating code for keil arm. Its time to add the user code. The code will be like this."
    },
    {
        "link": "https://community.st.com/t5/stm32-mcus-embedded-software/errors-while-compiling-stm32f10x-standard-peripheral-library-in/td-p/707217",
        "document": "I’m encountering multiple errors and warnings when trying to compile a project using the STM32F10x Standard Peripheral Library in Keil uVision. The specific errors are related to assert_param being undeclared and numerous UTF-8 warnings in comments.\n\ncall to undeclared function 'assert_param'; ISO C99 and later do not support implicit function declarations [-Wimplicit-function-declaration]\n\ninvalid UTF-8 in comment [-Winvalid-utf8] in stm32f10x.h\n\nIt seems like the compiler isn't recognizing the assert_param macro, which is leading to multiple errors. I’ve ensured that the stm32f10x_conf.h file includes the necessary header files, but the issue persists.\n\nHas anyone experienced similar issues or can provide guidance on resolving these errors?"
    },
    {
        "link": "https://keil.com/dd/docs/datashts/st/stm32f10xxx.pdf",
        "document": ""
    },
    {
        "link": "https://community.st.com/t5/stm32-mcus-motor-control/stspin-based-motor-controller-acceleration-and-deacceleration/td-p/655795",
        "document": "I have STSPIN32F0 Based Board for PMSM motor Drive. This Motor Works for Water Pump Application. we have Created 5 step in start up sequence using MC workbench. Motor Rotate as per Profile upto start up sequence Complete. But as soon as Motor Switch to Close Loop it start to rotate on Full Speed Suddenly and that create problem in actual application for us(some time motor stall hear OR we receive Speed Feed Back error sometime). we need to set some acceleration time. after switching to close loop it will take some time to get high RPM. Also same thing we need when we send a STOP Command, Motor deaccelerate slowly and then Stop.\n\nWe can't find any solution we are trying from many days, Please let me know that how can i implement above function of acceleration and deacceleration in MC workbench Generated Code.\n\nwe are using sensor less FOC drive with single shunt measurement.\n\nI am using keil IDE for Coding.."
    },
    {
        "link": "https://wiki.st.com/stm32mcu/wiki/STM32StepByStep:Getting_started_with_Motor_Control",
        "document": "There are 1 incomplete or pending task to finish installation of Semantic MediaWiki . An administrator or user with sufficient rights can complete it. This should be done before adding new data to avoid inconsistencies.\n\nThis message will disappear after all relevant tasks have been resolved.\n\n\n\n\n\n The first part of the tutorial:\n\n\n\n This tutorial enables you to use ST Motor Profiler and after applying it you can:\n• Connect the motor-control Nucleo pack to your computer.\n\nThe second part of the tutorial:\n\n\n\n This tutorial enables you to use STM32 Motor Control SDK and after applying it you can:\n• Generate the code to start the motor\n\nFor the second part of the tutorial:\n\n\n\nConfigure your first motor application using ST Motor Profiler\n\nGet the installation file from this link and unzip it. Then just execute the .exe file so that the installation starts.\n\n Once the installation is done the software is installed on your computer.\n\n The ST Motor Profiler is automatically installed with the STM32 motor-control software Development kit on your computer.\n\n Once the installation is done, it gets installed automatically with the MotorControl Workbench while following the installation steps.\n\n\n\nConnect the package to the computer\n\nIn this tutorial, we are working on the P-NUCLEO-IHM03 motor-control Nucleo pack composed of NUCLEO-G431RB as command board and X-NUCLEO-IHM16M1 as power board.\n\nTo start our application we should set up the boards and the power source, and finally connect it to the computer.\n\n After setting up the boards and motor properly, launch the Motor Profiler application.\n• The first step to do is to select the boards we are using by clicking on Select Boards button\n• None By referring to the user manual, the following parameters regarding the motor characteristics can be defined and set in the appropriate cases:\n• After defining the values, the next step is to click on the Connect button and check the motor working correctly.\n\n\n\nFirst, ST Motor Profiler creates the following ST-Link checklist to load the added parameters to the software created for the board:\n\n \n\n\n\nAfter finishing the connection between the boards and the computer, it is now the time to start the test.\n\nWhen clicking, the motor starts rotating at a high speed and the electrical, as well as the mechanical models, gets established as shown in the following photo, and if there is any fault it is mentioned on the right of the window.\n\n\n\nAfter checking that the motor is connected and working properly, the next step is to make it work while controlling its speed.\n• Click on the Play button and the following window appears.\n• By moving the cursor, the speed can be monitored\n\n\n\n \n\n \n\nNow you are able to:\n• Set and properly use the ST motor-control Nucleo pack\n• Control the acceleration of the motor\n\nFor the installation of the MotorControl Workbench, please follow the steps mentioned in the previous part of the tutorial.\n\nSince the pack used is P-Nucleo-IHM03 it is mandatory to select the appropriate boards used.\n\n First step to do so is to click on New Project and to select the NUCLEO-G431RB as control board & X-NUCLEO-IHM16M1 as power board, then click on OK as enumerated in the next photo:\n\n \n\n\n\nAfter finishing selecting the pack's boards, another window appears that allows the user to check the details and set the values of the different characteristics.\n\n\n\nLater, just click on the generate file button presented in the photo below, and save the project in the appropriate directory. \n\n\n\n Then a window that allows to choose the IDE to use, and the drive type appears. Just click on Generate and after the software finishes generating the .ioc file, do not change any parameter, just click on Run STM32CubeMX.\n\n\n\n \n\n\n\n The .ioc file is open now and the next step is to simply generate the code in the STM32CubeIDE and do not forget to update the project information in the Project Manager section.\n\n\n\nOnce the code is generated, the only step to do is to connect the pack and to debug the program.\n\n The program has been installed on the command board and once clicking on the user button, the engine rotates correctly.\n\n\n\nStart the motor and rotate the engine with a delay\n\nIn this part, the target work is to start the motor and make it stop with a delay fixed by the user. \n\n The first steps are the same as the previous part until the code generation.\n\nThen, add the following code to the while loop in the main file:\n\nIn this part, the motor control is based on the direction control.\n\nIt is devided into two parts, the first one is the management of the MotorControl Workbench and the second concerns the programming part.\n\n\n\nAfter launching MotorControl Workbench, select the appropriate boards and pack. Later generate a project as presented in the previous parts.\n\nOnce generating the project file, click on Firmware Drive Management and then select Drive Setting. \n\n \n\n\n\n A popup appears, to control the orientation of the motor, select Position Control of the Control mode from the Default settings section.\n\n \n\n Then, generate code as presented in the Start the first application part.\n\nNow, to manage the direction of the motor, add the following code\n\n In the declaration part:\n\nLater add the following code in the While loop:\n\nWith x is the angle that we want to direct the motor and the second variable that is set to 0 here represents the time set to reach the position desired.\n\nIn this example, we want to motor to keep moving with adding 0.175 to the angle x at every cycle of the loop. \n\nAfter finish adding the code, build and debug the program generated and see the motor changing its direction.\n\nNow you may:\n• Start your first application using MotorControl Workbench\n• Specify the delay needed between the start and the stop"
    },
    {
        "link": "https://vexforum.com/t/how-to-write-code-to-accelerate-and-decelerate-drive-train-code-for-autonomous/96673",
        "document": "Structural engineer with an interest in competitive robotics."
    },
    {
        "link": "https://wiki.stmicroelectronics.cn/stm32mcu/wiki/STM32MotorControl:6-step_Firmware_Algorithm",
        "document": "This document describes the software library that implements the 6-step algorithm, also known as a trapezoidal algorithm, contained in the X-CUBE-MCSDK[1] STM32 motor control software development kits (SDKs) designed for, and to be used with, STM32 microcontrollers. The 6-step library allows the control of a 3-phase permanent magnet (PMSM) or brushless direct current motor (BLDC). It can be used to quickly evaluate ST microcontrollers, complete ST application platforms, and save time when developing motor control algorithms to be run on ST microcontrollers. It is written in the C language and implements the core motor control algorithms, as well as sensor reading/decoding algorithms and sensor-less algorithms for rotor position reconstruction.\n\nThe library can be customized to suit user application parameters (motor, sensors, power stage, control stage, pin-out assignment) and provides a ready-to-use application programming interface (API). A PC graphical user interface (GUI), the ST motor control workbench, allows complete and easy customization of the library. Thanks to this, the user can run a motor in a noticeably brief time.\n\nA set of ready-to-use examples is provided to explain the use of the motor control API and its most commonly used features.\n\nThese projects usually provide the UART interface that allows convenient real-time fine-tuning of the motor control subsystem with a remote-control tool, the STM32 motor control monitor.\n\nThe STM32 motor control SDK is delivered as an expansion pack for the STM32CubeMX tool, and the 6-step library is based on the STM32Cube firmware libraries.\n\nThe list of supported STM32 microcontrollers is provided in the release note delivered with the SDK.\n\nA brushless three-phase motor is composed as shown in Figure 1 of a fixed element, called the stator, made of a set of three windings, meaning phases, connected at one side and a moving element containing an internal permanent magnet called the rotor. The rotor may have several pole pairs regularly distributed around the stator.\n\nIn 6-step driving, the electrical cycle is divided into six commutation steps. At each step, the bus voltage is connected to one of the three-phase windings of the motor, while the ground is connected to a second winding, forcing a current flowing through these two windings and generating a stator magnetic field as shown in Figure 2. The third winding remains floating.\n\nThe orientation of the stator magnetic field is changed, energizing the windings in the sequence shown in Figure 3.\n\nSince the rotor has a permanent magnetic field, the rotating stator magnetic field creates a torque that moves the rotor. The maximum torque is obtained when the electrical angle between the rotor and the stator is 90°. The orientation of the stator magnetic field is changed thanks to the 6-step commutation that keeps the motor spinning, as explained in Figure 4.\n\nThe 6-step firmware reveals the position of the motor rotor every 60 electrical degrees (in sensor-less or sensored mode). Based on this information, it computes the time for the next step commutation and calculates the duty cycles for the PWM signals that drive the output power transistors. These transistors control the motor phase voltages, allowing them to reach a target speed.\n\nThe 6-step firmware can be viewed as a set of components, each with a different task.\n\nThe following list describes the components shown in Figure 5:\n• Speed and position feedback component: BEMF sensing is used with the sensors-less driving mode while Hall sensors are exploited with the sensor driving mode.\n• Pulse computation component (voltage mode – VM or current mode - CM) is used. A proportional-integral (PI) controller algorithm is employed for the speed loop control.\n• Time computation component: it manages the step change and applies the configuration of the timers set by the step update component.\n• Step update component: it updates the configuration of the timers, hence the proper energization of the phases, according to the selected driving mode (standard with synchronous rectification).\n\nThe motor speed is controlled by directly varying the duty cycle of the pulse width modulated voltages applied to the motor phases.\n\nThe motor speed is controlled by limiting the peak of the current flowing through the active phases.\n\nThis driving mode exploits the presence of an amplifier A and a comparator C. The current is controlled by setting the duty cycle of a PWM generated by a timer (REF timer) used as the reference voltage of the comparator C. The output of the comparator triggers the switch-off of the PWMs connected to the motor phases when the amplified sense resistor voltage is greater than the reference voltage.\n\nIn the sensor-less mode, the position of the rotor is obtained by detecting the zero-crossing of the Back Electro-Motive Force sensed at the floating phase. This is commonly done using an ADC as shown in Figure 7. When the magnetic field of the rotor crosses the high impedance phase, the corresponding BEMF voltage changes its sign (zero-crossing). The BEMF voltage can be scaled at the ADC input, thanks to a resistor network controlled by a GPIO. When the GPIO output is low, the resistor network divides the voltage coming from the motor phase.\n\nIn this driving mode, the positioning of the rotor is obtained by reading the digital signals coming from the Hall sensors (connected to three GPIOs).\n\nDuring the alignment time, the position of the rotor is acquired, and the motor windings are energized accordingly. When a sensor commutation is detected, new status is acquired. At the same time, the step is changed and the PWMs updated accordingly.\n\nThe STM32 motor control firmware is the heart of the SDK. It provides all the software components needed to control 3-phase motors using the 6-step strategy and integrates these components into an MC subsystem. It offers a versatile set of interfaces that custom applications can use to drive motors according to their needs.\n\nFigure 8 shows the architecture of the STM32 motor control firmware.\n\nThe firmware consists of the three following functional sets:\n• The 6-step Library contains software components that implement the motor control features.\n• The UI Library contains software components that deal with the communication between the MC firmware subsystem and either the user or an offloaded application.\n• The motor control cockpit integrates all these software components into a MC firmware subsystem and implements the regulation loops.\n\nThe 6-step MC library is a collection of software components. Each component implements a feature involved in MC such as the speed and position sensing, PID regulator, or motor control algorithms.\n\nFor some features, the library provides several components, each containing a different implementation. This allows to efficiently support various hardware configurations. Then, the components to use are chosen depending on the characteristics of the user’s application and are integrated into a motor control firmware subsystem.\n\nFigure 9 summarizes the features provided by the 6-step library as components. The list of most of the components in the 6-step library and their specificities are described in Section 5.1.\n\nThe user interface library or UI library contains software components that deal with the communication between the MC firmware subsystem and the outside world using a serial port. This library is used to allow the STM32 MC WB to connect to the Application and control it with its Monitor feature.\n\nThe motor control cockpit integrates the software components into a motor control firmware subsystem and implements the regulation loops. It instantiates, configures, and interfaces the firmware components selected in the 6-step library and the user interface library for the user’s application. The code of the MC cockpit is generated by STM32Cube according to the characteristics of the application. Thanks to this generation the code of the cockpit only contains what is needed and is thus easily readable.\n\nThe motor control firmware subsystem is the firmware library that results from the configuration and generation of a firmware project with the STM32 MC WB / STM32CubeMx pair. Users then build their final application on top of this subsystem, adding their code that uses one of the provided APIs (see below).\n\nFigure 10 provides an overview of this subsystem showing optional and mandatory functional blocks as well as how they interact with one another. Note that only the most important blocks and interactions are shown for the sake of clarity. This figure highlights three sets of functional blocks: the 6-step loop, the reference computation loop and the safety loop. Each of them is made up of one or more components that implement a specific feature of the algorithm.\n\nThe 6-step loop is the core of the algorithm. It aims to compute the phase voltages and produce the resulting duty cycles to apply to the transistors driving the motor’s phases. It performs the correlation between electrical angle and 6-step tables and updates the timer registers accordingly determining the step change.\n\nThe 6-step loop is executed at a high rate, the PWM frequency or its multiple (according to the 6-step loop execution time set by the user). Higher the rate higher the accuracy of the electrical angle control at the expense of a higher computation load. This might be limiting for lower-end microcontrollers.\n\nThe purpose of the Reference computation loop, as its name suggests, is to compute the duty cycle references based on targets coming from the application. Usually, the application provides a reference expressed in a way that matches its needs: a speed reference or ramp. The reference computation loop first converts the application target into a phase voltage duty cycle or reference current duty cycle which is then used to generate motor windings PWMs and optionally a current reference PWM.\n\nThis process is in force when the motor control subsystem is executing in closed-loop mode.\n\nHowever, this is not the only operating mode. Indeed, depending on the chosen Speed and Position Feedback technology, a rev-up phase may be needed that will take over that process until the rotor Position estimation is judged reliable. This is the purpose of the Rev-up Control component.\n\nIn addition, some applications may require that the motor control stays in open-loop mode. This case is handled by the open-loop control component that is executed instead of the normal-regulation process.\n\nAll these cases fall in the basket of the Reference computation loop that is executed at a medium rate, typically on the SysTick interrupt.\n\nThe last set of functional blocks is the Safety loop. This set is called a loop because it consists of functions that get executed periodically. They all deal with features that aim at reacting to conditions that may endanger the system from a hardware point of view: Over and under-voltage protection, overheating protection, and overcurrent protection. In the case of overcurrent protection, the STM32 motor control firmware is designed to exploit hardware mechanisms implemented in the STM32 MCUs such as the Timer Break input that accelerate the system reaction to an overcurrent situation.\n\nThe Safety loop is executed at the same rate as the Reference computation loop – that is at a medium rate, usually with the SysTick interrupt.\n\nMost of the motor control firmware is organized as a set of software components. A component is a self-contained software unit that defines:\n• A structure with the data needed to fulfill the feature that the component is designed to provide.\n• A set of functions operating on instances of the structure and that implement that feature.\n\nThe data placed in the structure of a component are the parameters that characterize this component and that tune its behavior. They fully describe the state of the component. In the motor control firmware, a type is defined to hold these data together. Variables of this type are used as handles on instances of the component.\n\nThe way this principle is used is very straightforward. Where a feature is needed, the component that matches this feature is selected and a variable of the structure’s type is defined. The variable is then initialized with the feature’s parameters as defined for the application. This is done when the motor control firmware subsystem is initialized by the MC_boot() function.\n\nFinally, during the operation of the motor control firmware subsystem, the functions defined for the component are called where and when needed to benefit from the feature it provides. These functions provide the component’s feature. To perform their task, they expect a pointer on a handle of the component’s structure as the first argument so that they have access to the state, and the settings of the instance of the component they work for.\n\nThe notion of components makes it easy to offer several implementations of a given feature. For such cases, a generic component is defined for the feature. Its handle contains the data common to the feature whatever its actual implementation is, and its functions operate on these data. In addition, the prototypes of the functions that each component implementing the feature need to provide are defined. These functions are the interface of the components.\n\nThen, these implementing components reuse and extend the handle of the generic component into their own and implement the functions needed to fulfill the feature. This allows for simplified integration and an easy replacement of implementation by another.\n\nAn example of this situation is the set of Speed and Position Feedback components. A generic component is defined, represented by the SpeednPosFdbk_Handle_t handle structure, defined in the speed_pos_fdbk.h file. The handle of this generic component only contains the data purely related to the speed and the position of the motor’s rotor such as the current mechanical and electrical angles, the conversion factor between them, and the limits within which the feature is to be used. And its functions are only about setting and getting these data. Two actual implementations are provided, one that uses Hall effect sensors and one that implements the feature using a bemf sensing-based algorithm. Each of these two implementations defines its handle that extends SpeednPosFdbk_Handle_t and each defines interface functions based on the same prototypes.\n\nThe following sections present an overview of all the components offered by the STM32 MC SDK. For a complete description, refer to the STM32 motor control firmware reference manual.\n\nThe PWM component is responsible for:\n• applying the desired voltage on the three phases,\n• managing the triggering of the ADC (sensor-less mode only).\n\nA timer peripheral is used to generate the PWM signals and to trigger the measurement of the ADC at the right time. This mechanism is detailed in Section 5.1.2.\n\nConcretely, the main task of this component is to enable and disable the outputs and apply the voltages to the proper phases following the 6-step sequence and the driving modes described here below.\n\nThis task begins when the motor is started and ends when it is stopped. In addition, these components also play a role in other matters such as the boot capacitor charging which requires switching the low sides transistors on, and the overcurrent protection. Each PWM handles the Timer interrupts that are relevant to its operation. It expects these interrupts to be configured with a given priority level and it defines its functions to handle them.\n\nThe Application shall tamper neither with the priorities of these interrupts nor with the order in which they are served in the interrupt handler.\n\nThe 6-step library provides all the components needed to support 6-pwm and 3-pwm (plus 3 enable GPIOs) devices. The selection of the component that matches the device topology in use by the application is performed through the STM32 MC WB.\n\nThese implementations are built on a generic PWM generation component that they extend and that provides the functions and data common to all of them. This base component cannot be used as-is since it does not provide a complete implementation of the features. Rather, its handle structure (PWMC_Handle_t) is reused by all the PWM generation-specific implementations.\n\nThe functions, that the generic PWM generation component provides, form the API of the PWM generation feature. Calling those results in calling functions of the component implementing the feature.\n\nBesides the standard driving mode (one phase with PWM applied, one phase floating, and one phase to ground), three additional driving modes are implemented: Mid-Step alignment, fast demagnetization, and quasi-synchronous rectification.\n\nThese additional modes are implemented in each of the specific PWM generation components. They are explained in detail in the following sections.\n\nIn sensor-less driving mode, the motor is first aligned at a predefined and known rotor position before starting the acceleration phase. To minimize the mechanical vibrations and make the start-up smoother, the alignment position is chosen to be in the middle between adjacent steps. Therefore, instead of the standard 6-step phase polarization table the following one is used, based on the initial step of the sequence and spinning direction. None of the three phases is floating.\n\nWhen the microcontroller switches from one step to the next, the non-excited winding needs a certain demagnetization time. During this time, the current in the winding continues in the same direction but decreases to zero. To accelerate the demagnetization, the PWM signal must be applied to the low-side switch during the step when the demagnetizing current is flowing from the bridge to the motor phases. Refer to Table 4 for a description of the firmware implementation.\n\nThe fast demagnetization driving mode can be enabled before the project generation or in the Motor Pilot application. When enabled, the fast demagnetization configuration is applied during the whole step in sensored mode and during only the demagnetization period in sensor-less mode.\n\nBy default, the power stage is driven by the algorithm in fast decay mode.\n\nAt the start of the OFF-time, both the power MOS of the energized phases are switched off and the current recirculates through the two opposite freewheeling diodes. The current decays with a high di/dt since the voltage across the coil is the power-supply voltage. After the deadtime, the low-side MOS and the high-side MOS in parallel with the conducting diode are turned on in synchronous rectification mode (see Figure 13).\n\nIn applications where the motor current is low, the load current may decay completely to zero and rise in the opposite direction.\n\nTo avoid this, the quasi-synchronous rectification option may be enabled: The lower power MOS is not turned on preventing the current to reverse (see Figure 14). This driving mode is available only with the devices supporting the 6-pwm configuration and, similarly to the fast demagnetization option, it can be activated in the Motor Pilot application.\n\nThe quasi-synchronous rectification and the fast demagnetization modes are incompatible one another.\n\nThese components provide the speed and the angular position of the rotor of a motor (both electrical and mechanical). While the angular position is crucial to perform properly the step-change at the right time, the rotor speed measurement is needed to close the speed loop.\n\nTwo implementations of the Speed and Position Feedback feature are provided by the STM32 motor control firmware. One uses sensors embedded in some motors (Hall sensors). The other one provides an estimation of the speed and the position of the rotor based on the sensing of the Back-EMF of the motor.\n\nThese two implementations are built on a generic Speed and Position Feedback component – named the Speed and Position Feedback component – which they extend, and which provides common data to all of them. In addition to that, also the sensing of the Back-EMF is deployed in several components, each of them dedicated to a specific microcontroller family.\n\nAn additional implementation is also present in the firmware: the Virtual Speed and Position Feedback component. This component is only used during the rev-up phase of the motor, while Back_EMF-based implementations are used for closed-loop mode.\n\nBack-EMF sensing components take full ownership of the ADC peripherals they use. The application can use the ADC channels left free by the motor control subsystem, but it may not interface with these channels directly. The Application shall use the functions of the Regular Conversion Manager (RCM) component. Refer to the Reference Documentation of the MC SDK for a complete description.\n\nFigure 15 shows the synchronization strategy between the TIM1 PWM output and the ADC. Normally the A/D converter peripheral is configured so that it is triggered by the falling edge of TIM1_CH4 during the decay time (PWM-OFF time).\n\nThe interrupt triggered by the end of the injected channel conversion manages the polling of the converted value and its evaluation for the estimation of the rotor position.\n\nThe Back-EMF waveform of a brushless motor changes along with the rotor position and speed and is in a trapezoidal shape. Figure 16 shows the waveform of the current and back-EMF for one electrification period, where the solid line denotes the current (Ripples are ignored for the sake of simplicity). The dashed line represents the back electro-motive force and the horizontal coordinate represents the electric perspective of motor rotation.\n\nThe middle of every two phase-switching points corresponds to one point whose back electro-motive force polarity is changed, the zero-crossing point. Once the zero-crossing point is identified, the phase-switching moment is set after an electrical delay of 30°.\n\nTwo different strategies are available for the identification of the zero-crossing point:\n• Back-EMF sensing during the OFF time.\n• Back-EMF sensing during the ON time.\n\nBack-EMF sensing during the OFF time\n\nThis kind of detection can be used with both the driving modes, current and voltage modes. The principle is the one described in Figure 15 where the ADC conversion is triggered during the OFF time of the PWM. At the beginning of every 6-step commutation, the ADC channel corresponding to the floating phase is selected. After a masking period corresponding to the demagnetization period of the floating phase, during which the Back-EMF reading is not reliable, the converted values are compared with a threshold to determine the Back-EMF polarity change. Once the zero-crossing point is detected a delay of 30° electrical degrees, based on the current measured speed, is programmed on a timer, whose update triggers finally the step commutation. Comparison thresholds can be set independently on the direction of change of the Back-EMF (increasing or decreasing).\n\nNote: To avoid damaging the devices, as shown in Figure 17, the minimum of the back-EMF reading is limited by the protection diodes present on the board\n\nBack-EMF sensing during the ON time\n\nThis kind of detection can be used with the voltage driving mode only where the duty cycle is fixed and does not change along the step. The principle is the one described in Figure 18 where the ADC conversion is triggered during the ON time of the PWM. At the beginning of every 6-step commutation, the ADC channel corresponding to the floating phase is selected. After a masking period corresponding to the demagnetization period of the floating phase, during which the Back-EMF reading is not reliable, thanks to a resistor network that allows estimating the voltage of the center-tap point (the common point of the three motor phases), the converted values are compared with a threshold that is ideally half of the Bus voltage.\n\nThe threshold is set considering a resistor dividing network that rescales the phase voltage to the ADC input range. Once the crossing point based on the current measured speed is programmed on a timer, whose update triggers finally the step commutation. In some cases, the resistor dividing network may include diodes to protect the ADC inputs from overvoltage. The above threshold is then replaced by the following one:\n\nWhile the Back-EMF sensing during the OFF time is normally performed in sensor-less mode, the user is allowed to enable or disable the sensing during the ON time when the voltage drive mode is selected.\n\nWhen both sensing techniques are used, the algorithm automatically switches between one another based on the PWM duty cycle allowing it to reach close to 100% duty cycle.\n\nNote: Zero-crossing detection thresholds (both with back-emf rising and falling) during the pwm on-time are usually close to half of the bus voltage. Since they are not dynamically calculated by the firmware, user is advised to manually tune and change them through the Workbench user interface if bus voltage is different from the nominal one. Otherwise, \"over-current\" or \"speed feedback\" errors may rise.\n\nThe STM32 motor control firmware provides components to report the value of the bus voltage. A measurement of the bus voltage is, of course, needed for features like the under or over voltage Protection.\n\nTwo implementations of a bus voltage sensing component are available. One that uses an ADC channel and two big resistors to measure the voltage (the Resistor Divider Bus Voltage Sensor). The second one only reports a configured value (the Virtual Bus Voltage Sensor).\n\nFor its measurements, the resistor divider bus voltage sensor implementation uses a channel of the ADC configured for the current feedback of motor 1, thanks to the regular conversion API. Refer to Section 5.2.4 for more details.\n\nThe STM32 motor control firmware provides one component to report the motor control subsystem’s temperature. This component – the NTC Temperature Sensor – acts both as a real temperature sensor that uses an ADC channel to measure the temperature from a probe and as a virtual temperature sensor that reports a configured temperature value.\n\nThis section presents some of the drive regulation components that are delivered with the firmware. For complete information on all these components, refer to the STM32 Motor Control Reference Manual.\n\nThe PID component provides an implementation of a proportional–integral–derivative controller. This component is primarily used by the reference computation loop in the speed controller.\n\nIt comes in two flavors: a full PID using all three terms and a simpler one that only uses the Proportional and Integral terms. The motor control subsystem uses the latter one.\n\nThe Revup component is responsible for starting the motor. Its task begins when the motor is started open-loop and ends when the current control loop can be closed.\n\n1. It produces the duty cycle reference from the speed reference submitted by the application. As such, it manages the ramps programmed by the application\n\n2. It regulates this speed reference thanks to a PID component.\n\nThe motor control cockpit plays a significant role in a motor control subsystem. It configures and integrates a few components selected for the MC application. And, in addition, it provides the implementation of the 6-step algorithm, reference computation, and safety loops that match the designed application.\n\nAs such, it must support a vast diversity of configurations that lead to a potentially huge and cumbersome source code. To avoid this issue and to provide a code that is as simple as possible, most of the cockpit’s code is generated from the application’s characteristics. Thanks to this generation, only these portions of the code that are needed for the MC system are present in the MC cockpit’s source code.\n\nDespite its changing nature, the code of the MC cockpit is organized in a sole and structured way.\n\nThis section lists the most important source files that make the MC cockpit. Refer to the STM32 MC SDK reference documentation (delivered with the SDK) for a complete list of these files and their documentation.\n\nThe motorcontrol.c file mainly contains a function MX_MotorControl_Init() which is used by the application generated by STM32CubeMX to initialize the MC subsystem. Its motorcontrol.h companion file is only useful to the CubeMX generated main.c file to get the prototype of the function it calls.\n\nSuch files contain the definition and implementation of the high-level Application Programming Interface that the application can use to control the motors. See Section 6.1 for a description of this API. As such, mc_api.h is the file that applications need to include to use it.\n\nThe mc_config.c file contains the structures and the data used to configure all the components used by the MC subsystem. The mc_config.h file exports the names of the structures for the application to use as the Lower Level API as described in Section 6.2.\n\nThe mc_parameters.c file contains structures and data that contain constant parameters for the MC subsystem. Its role is similar to the mc_config.c file except that its content can be fully placed in flash memory since it is constant. The mc_parameters.h file exports the names of the structures for the application to read them in the scope of the Lower Level API as described in Section 6.2.\n\nThis file contains type definitions that are used across the motor control subsystem. In addition, it includes all relevant STM32 Cube LL header files that are needed for the motor control subsystem.\n\nA series of files is generated, containing many constants – defined as C preprocessor symbols – which are set to the values that are meaningful to the MC subsystem and that are used in its code. Some of these files are dedicated to some STM32 family and are only present if the chosen MCU is part of this family. The list of these files:\n\nThe motor control subsystem provides handlers for the interrupts that it uses. These are defined in files that depend on the chosen STM32 family (stm32g4xx_mc_it.c for G4xx microcontroller family).\n\nThis file contains the implementation of the core of the MC cockpit. It contains the code of the loops described at the beginning of Section 5. More information on them is given below.\n\nThe code of each of the three loops that are at the heart of the MC firmware subsystem is distributed into “Task” functions.\n\nThe 6-step loop is implemented in the TSK_HighFrequencyTask() function. This function is executed at the PWM frequency rate (that is: once every PWM Period, see Section 5.1.1 PWM generation component). The PWM frequency is the highest in the motor control subsystem. It is executed in the handler of the interrupt that occurs at each timer update.\n\nThe main task of this function is to translate the electrical angle into the 6-step sequence and update the PWM duty cycles that are to be programmed in the PWM Timer channels. Hence, the time this function must operate is limited as it needs to complete before the next timer-update event, when new PWM duty cycles are taken into account. Failing to execute in this lapse of time results in the 6-step execution error.\n\nThe Reference computation loop is implemented in the function TSK_MediumFrequencyTaskM1(). This function needs to be invoked periodically at a frequency that is typically lower than that of the TSK_HighFrequencyTask(). In the STM32 motor control firmware subsystem, the functions are called on the SysTick interrupt.\n\nThe Safety loop is implemented by the TSK_SafetyTask() function. This function calls one of TSK_SafetyTask_PWMOFF() or TSK_SafetyTask_LSON() depending on the chosen over-voltage protection. TSK_SafetyTask() is invoked periodically at the same frequency as the reference computation loop and on the same interrupt.\n\nThe MC subsystem reports the faults that it detects to the application. On the fault detection, the MC firmware first executes actions to place the motor hardware subsystem in a safe state, and then it enters a fault state. These actions always result in the faulty motor being stopped.\n\nThe faults that are detected are the following:\n\nThe handling of faults in the MC firmware involves two states of the MC state machine. When a fault is detected, the MC state machine enters the FAULT_NOW state, which indicates that a fault condition currently exists. On entering this state, the PWM output is immediately cut off. The MC state machine remains in this state as long as the fault condition remains valid, meaning as long as the condition that led to declaring the fault is true. When the no-fault condition is not active anymore, the MC state machine switches to the FAULT_OVER state and will remain in that state until the application acknowledges them. On the acknowledgment of the Faults, the MC state machine goes back to the IDLE state and the subsystem is ready to start the motor again (see Section 5.3.3).\n\nThere are situations where the application needs to use free channels of the ADC peripheral used by the MC subsystem for phase Back-EMF measurement. As described in Configuring peripherals with STM32CubeMX these ADC channels can be configured with STM32CubeMX.\n\nHowever, the application must not use these channels directly. It may rather use the API functions described in Programming a regular conversion on a Motor Control ADC, Retrieving the result of a Motor Control ADC regular conversion, and Retrieving the state of a Motor Control ADC regular conversion. Indeed, the instants when the phase Back-EMF measurements are to be made must be set within the PWM period. In the firmware, injected conversions are used and external triggers coming from the PWM timer start them.\n\nHence, the Application cannot use injected conversions on these ADC peripherals as they are reserved for motor control, and they must avoid disturbing the injected conversion. The purpose of the APIs mentioned here is to allow the application to perform regular ADC conversions without disturbing the motor control subsystem. Getting a conversion done with them is a three-step process:\n\n1. The MC_ProgramRegularConversion() function is called to request an ADC regular conversion on the given channel and with the given conversion time. The motor control subsystem then schedules the requested conversion that will occur right after the next injected conversion, when there is no risk of collision.\n\n2. The Application can then call the MC_GetRegularConversionState() function to determine if the requested conversion is completed.\n\n3. Finally, the Application calls the MC_GetRegularConversionValue() to retrieve the converted value.\n\nNote: The motor control subsystem will only accept one conversion at a time. So, the application may use the MC_GetRegularConversionState() to determine if the conversion can be handled. In addition, all conversion requests must be performed inside routines with the same priority level.\n\nThe MC firmware subsystem maintains a state machine for the motor that it controls. The tasks executed on the motor, and the API functions that can be called, are depending on the current state of the state machine.\n\nFigure 19 details the full MC state machine. States are indicated in the blue circles while possible transitions between the states are marked with the arrows.\n\nThe actual state machine may be simpler depending on the configured application. Indeed, some states are only needed in specific cases. For instance, the states about motor acceleration and closed-loop switch-over are only useful if the sensor-less mode is used.\n\nThe state machine is never directly changed by the application. Its management is handled by the Reference computation loop, which is in the TSK_MediumFrequencyTaskM1() function.\n\nThe motor control API, also referred to as the MC API, is the main and most straightforward interface offered to applications for controlling the motors driven by the STM32 MC subsystem.\n\nFor the sake of simplicity, the MC API offers one set of functions restricting the number of parameters these functions expect to the bare minimum.\n\nThe main purpose of this API is to start, stop the motors, and control their rotation. The control of the rotation of a motor is achieved by programming a speed reference that the PID regulator of the motor control subsystem maintains. Such a reference must be set before starting a motor.\n\nThe speed reference is programmed as a ramp that moves the actual reference from its current value to its target value in a given time.\n\nA programmed reference or ramp is executed at once if the motor is spinning and steady (its state machine is in the RUN state). Otherwise, it is buffered until the state machine of the motor reaches the RUN state. Only one reference or ramp can be programmed at a time, the last one replacing the previous.\n\nIn addition to the rotation controlling functions, the MC API also provides functions to get the values of various parameters and state variables of the MC subsystem such as the mechanical or electrical speed for instance.\n\nA brief description of the main functions of the MC API is given here along with the usage principles. A complete definition is available in the STM32 MC SDK Reference Manual.\n\nStarts the target motor. *Before calling this function, a Speed ramp or a duty cycle reference must have been set.\n\nStops the target motor. If the target motor is not spinning, this function does nothing. Otherwise, the PWM outputs are switched off, whether the MC subsystem is in a close loop or still in the rev-up phase.\n\nPrograms a speed ramp on the target motor. If the target motor is in the RUN state – that is: the motor is spinning and steady – the ramp is executed immediately. Otherwise, it is buffered until this state is reached.\n\nA speed ramp takes the motor from its rotation speed at the start of the ramp to the hFinalSpeed target speed of the ramp in the hDurations duration.\n\nStops the execution of the current speed ramp of the target motor.\n\nReturns true if the last submitted ramp for the target motor is completed, false otherwise.\n\nReturns the duty cycle reference applied to the output phases.\n\nReturns the state of the last submitted command for the target motor. “Command” means a speed ramp or a duty cycle reference setting.\n\nThe returned state is an MCI_CommandState_t enumerable value:\n• MCI_COMMAND_NOT_ALREADY_EXECUTED: A command is buffered but its execution is not completed yet;\n• MCI_COMMAND_EXECUTED_SUCCESFULLY: Execution of the last buffered command is completed successfully;\n• MCI_COMMAND_EXECUTED_UNSUCCESFULLY: Execution of the last buffered command is completed unsuccessfully.\n\nRetrieving the control mode of the motor\n\nReturns the control mode for the target motor. The available return states are MCM_TORQUE_MODE (open-loop operation) and MCM_SPEED_MODE (closed-loop operation).\n\nRetrieving the drive mode of the motor\n\nReturns the drive mode for the target motor. It can be either VM (voltage mode) or CM (current mode).\n\nRetrieving the direction of rotation of the motor\n\nReturns the direction imposed by the last command on the target motor. The returned value is either 1 or -1.\n\nReturns true if the speed sensor of the target motor provides reliable values.\n\nReturns the last computed average mechanical rotor speed for the target Motor, expressed in dHz (Tenth of Hertz).\n\nReturns the electrical angle of the rotor of the motor.\n\nAcknowledges MC faults pending on the target motor. This function returns true if faults were indeed pending and false otherwise. Refer to Section 5.3.1 for more information on MC fault management.\n\nReturns a bit field showing faults that have occurred since the MC state machine of the target motor was moved to the FAULT_NOW state. Refer to Section 5.3.1 for more information on MC fault management and Section 5.3.3 for a description of the MC state machine.\n\nReturns a bit field showing all current faults on the target motor. Refer to Section 5.3.1 for more information on MC fault management.\n\nRetrieving the state of the motor control state machine\n\nReturns the current state of the target motor state machine. Refer to Section 5.3.3 for a description of the MC state machine and of the values of the State_t enumerable.\n\nThe low-level application programming interface provided by the MC firmware allows applications that need finer control over the internals of the MC subsystem. This API consists of all the components that are instantiated to form the subsystem. These components can be addressed by the application thanks to their handles. These handles are defined in the mc_config.c file and can be accessed by including the mc_config.h file. For more information, see the STM32 MC SDK reference manual delivered with the SDK."
    },
    {
        "link": "https://keil.com/pr/article/1154.htm",
        "document": "Plano, TX: STMicroelectronics has extended its library of functions supporting vector control of electric motors using the 32-bit STM32 microcontroller (MCU). The library includes new turnkey algorithms supporting single-shunt sensorless control, control of IPM (Internal Permanent Magnet) motors, and field-weakening controls for PMSM motors.\n\nThe additional library functions will allow faster time-to-market, lower BOM costs, optimal motor selection and a larger operating envelope in future generations of appliances, industrial drives, pumps, HVAC systems, vending and cash machines, and electric vehicles.\n• The evaluation version of MDK can be used to build the library with market leading performance and code density\n• MDK can connect to the Segger J-Link included on the STM3210B-MCKIT hardware development kit in order to run and debug motor-control applications\n\nAbout STMicroelectronics\n\n STMicroelectronics is a global leader in developing and delivering semiconductor solutions across the spectrum of microelectronics applications. An unrivalled combination of silicon and system expertise, manufacturing strength, Intellectual Property (IP) portfolio and strategic partners positions the Company at the forefront of System-on-Chip (SoC) technology and its products play a key role in enabling today's convergence markets. The Company's shares are traded on the New York Stock Exchange, on Euronext Paris and on the Milan Stock Exchange. In 2007, the Company's net revenues were $10.0 billion. Further information on ST can be found at www.st.com.\n\n\n\n About Keil\n\nKeil, an ARM® company, makes C compilers, macro assemblers, real-time kernels, debuggers, simulators, integrated environments and evaluation boards for ARM7TM/ARM9TM/Cortex-M3TM, XC16x/C16x/ST10, 251 and 8051 processor-based microcontroller families. Products available from Keil include embedded development tools, evaluation software, product updates, application notes, example code and technical support. More information on Keil is available at www.keil.com."
    }
]