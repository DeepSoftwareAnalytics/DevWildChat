[
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/awt/image/BufferedImage.html",
        "document": ". Returns a of objects that are the immediate sources, not the sources of these immediate sources, of image data for this\n\nSets a rectangular region of the image to the contents of the specified , which is assumed to be in the same coordinate space as the ."
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/index.html?java/awt/image/BufferedImage.html",
        "document": "JavaScript is disabled on your browser.\n\nThis document is designed to be viewed using the frames feature. If you see this message, you are using a non-frame-capable web client. Link to Non-frame version."
    },
    {
        "link": "https://tutorialspoint.com/java_dip/java_buffered_image.htm",
        "document": "Java class is a subclass of Image class. It is used to handle and manipulate the image data. A is made of ColorModel of image data. All objects have an upper left corner coordinate of (0, 0).\n\nThis class supports three types of constructors.\n\nThe first constructor constructs a new with a specified ColorModel and Raster.\n\nThe second constructor constructs a of one of the predefined image types.\n\nThe third constructor constructs a of one of the predefined image types: TYPE_BYTE_BINARY or TYPE_BYTE_INDEXED.\n\nThe following example demonstrates the use of java class that draw some text on the screen using Graphics Object −\n\nWhen you execute the given code, the following output is seen −"
    },
    {
        "link": "https://stackoverflow.com/questions/30875461/read-in-bufferedimage-pixel-values-then-manipulate-each-one-and-write-to-file",
        "document": "I am currently trying to read in an image pixel by pixel and change each colored pixel to the rgb value of (100,100,100). For whatever reason when I check the values of each pixel one the image is saved it has all the colored pixels as (46,46,46) instead.\n\nHere is the original image\n\nAfter running my program this is the image it gives to me\n\nHere is the code\n\nI have no clue why it doesn't set the pixels to the expected rgb value. I eventually want to be able to basically increment the rgb color as I move down rows and columns in the x and y so what the final image will look like is it will start off dark in the top left corner and then have a fade out effect as you get from that side to the bottom right corner."
    },
    {
        "link": "https://stackoverflow.com/questions/32414617/how-to-decide-which-bufferedimage-image-type-to-use",
        "document": "Java BufferedImage class has a long list of class variables known as the image type which can be used as an argument for the BufferedImage constructor.\n\nHowever, Java docs did a minimal explanation what these image types are used for and how would it affect the BufferedImage to be created.\n• None How would an image type affect the BufferedImage to be created? Does it control the number of bits used to store various colors (Red,Green,Blue) and its transparency?\n• None Which image type should we use if we just want to create\n\nI read the description in the Java Doc many times, but just couldn't figure out how should we use it. For example, this one:\n\nRepresents an image with 8-bit RGB color components, corresponding to a Windows- or Solaris- style BGR color model, with the colors Blue, Green, and Red packed into integer pixels. There is no alpha. The image has a DirectColorModel. When data with non-opaque alpha is stored in an image of this type, the color data must be adjusted to a non-premultiplied form and the alpha discarded, as described in the AlphaComposite documentation."
    },
    {
        "link": "https://stackoverflow.com/questions/12518496/drawing-a-graphical-histogram",
        "document": "I am working on a project and I would like to display a single line histogram that looks like a bar graph except each line in the bar graph represents a pixel and its greyscale value.\n\nI have a array full of greyscale values, I just need to put them into this histogram and have it display the lines which will represent the values.. sort of like this\n\nAnd below is the code loading the array... I just need to get some code that will use those greyscale values and represent them as bars like above.\n\nI know I have to do something like...\n\nBut I don't know where to go from there or how to draw my graph."
    },
    {
        "link": "https://stackoverflow.com/questions/3734500/custom-painting-of-jpanel",
        "document": "I'm not very good at this and I hope to get some help from people who understands the issue a lot more that I do.\n\nSo here's the deal. In my application there is background JPanel with Image drawn over it. Then there is a small JPanel which I'm trying to create custom painting for. I wanted to have JPanel with rounded corners and semi-transparent background so I modified paintComponent method to fill semi-transparent rounded rectangle. But when I place components inside like say JComboBox, the list of items appears and I click somewhere else to close it JPanel paints itself in original way making it semitransparent all around but with small rectangle painted with original grey background color. I see that it has to do something with invoking paintComponent on its parrent or paintChildren but I don't know how to organize those methods or where to put them. I also have proble with transparent colors overlaping each other.\n\nHere is an example source code:\n\nI hope some of will help me out :-) thanks\n\nEDIT: I found out that JComboBox (and its pop-up menu) draws correctly if pop-up menu overlaps outside the JPanel that contains JComboBox and has the custom paintComponent method."
    },
    {
        "link": "https://docs.oracle.com/javase/tutorial/uiswing/painting/index.html",
        "document": "The Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nThis lesson describes custom painting in Swing. Many programs will get by just fine without writing their own painting code; they will simply use the standard GUI components that are already available in the Swing API. But if you need specific control over how your graphics are drawn, then this lesson is for you. We will explore custom painting by creating a simple GUI application that draws a shape in response to the user's mouse activity. By intentionally keeping its design simple, we can focus on the underlying painting concepts, which in turn will relate to other GUI applications that you develop in the future.\n\nThis lesson explains each concept in steps as you construct the demo application. It presents the code as soon as possible with a minimum amount of background reading. Custom painting in Swing is similar to custom painting in AWT, but since we do not recommend writing your applications entirely with the AWT, its painting mechanism is not specifically discussed here. You may find it useful to read this lesson followed by the in-depth discussion in the article, Painting in AWT and Swing."
    },
    {
        "link": "http://ptolemy.berkeley.edu/ptolemyII/ptII11.0/ptII/doc/codeDoc/ptolemy/plot/Histogram.html",
        "document": "A histogram plotter. The plot can be configured and data can be provided either through a file with commands or through direct invocation of the public methods of the class. To read a file or a URL, use the read() method.\n\nWhen calling the public methods, in most cases the changes will not be visible until paint() has been called. To request that this be done, call repaint(). One exception is addPoint(), which makes the affect of the new point visible immediately (or nearly immediately) if the plot is visible on the screen.\n\nThe ASCII format for the file file contains any number commands, one per line. Unrecognized commands and commands with syntax errors are ignored. Comments are denoted by a line starting with a pound sign \"#\". The recognized commands include those supported by the base class, plus a few more. The commands are case insensitive, but are usually capitalized. The number of data sets to be plotted does not need to be specified. Data sets are added as needed. Each dataset is identified with a color (see the base class).\n\nThe appearance of the histogram can be altered by the following commands:\n\nTheis a real number specifying the width of the bars as a fraction of the bin width. It usually has a value less than or equal to one, and defaults to 0.5. Theis a real number specifying how much the bar of thedata set is offset from the previous one. This allows bars to \"peek out\" from behind the ones in front. It defaults to 0.15. Note that the frontmost data set will be the first one.\n\nThe width of each bin of the histogram can be specified using:\n\nThis is given in whatever units the data has. By default, each bin is centered at, whereis the width of the bin andis an integer. That bin represents values in the range (). The alignment of the bins can be changed with the following command:If this method is used with argument, then each bin is centered at, and represents values in the range (). So for example, if, then each bin represents values fromto (+ 1)for some integer. The default offset is 0.5, half the default bin width.\n\nTo specify data to be plotted, start a data set with the following command:\n\nHere,is a label that will appear in the legend. It is not necessary to enclose the string in quotation marks. To start a new dataset without giving it a name, use:In this case, no item will appear in the legend. New datasets are plottedthe previous ones. The data itself is given by a sequence of numbers, one per line. The numbers are specified as strings that can be parsed by the Double parser in Java. It is also possible to specify the numbers using all the formats accepted by the Plot class, so that the same data may be plotted by both classes. Thedata is ignored, and only thedata is used to calculate the histogram."
    },
    {
        "link": "https://docs.oracle.com/javase/tutorial/uiswing/painting/step2.html",
        "document": "The Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nNext, we will add a custom drawing surface to the frame. For this we will create a subclass of (a generic lightweight container) which will supply the code for rendering our custom painting.\n\nClick the Launch button to run SwingPaintDemo2 using Java™ Web Start (download JDK 7 or later). Alternatively, to compile and run the example yourself, consult the example index.\n\nThe first change you will notice is that we are now importing a number of additional classes, such as , , and . Since some of the older AWT classes are still used in modern Swing applications, it is normal to see the package in a few of the import statements. We have also defined a custom subclass, called , which comprises the majority of the new code.\n\nThe class definition has a constructor that sets a black border around its edges. This is a subtle detail that might be difficult to see at first (if it is, just comment out the invocation of and then recompile.) also overrides , which returns the desired width and height of the panel (in this case 250 is the width, 200 is the height.) Because of this, the class no longer needs to specify the size of the frame in pixels. It simply adds the panel to the frame and then invokes .\n\nThe method is where all of your custom painting takes place. This method is defined by and then overridden by your subclasses to provide their custom behavior. Its sole parameter, a object, exposes a number of methods for drawing 2D shapes and obtaining information about the application's graphics environment. In most cases the object that is actually received by this method will be an instance of (a subclass), which provides support for sophisticated 2D graphics rendering.\n\nMost of the standard Swing components have their look and feel implemented by separate \"UI Delegate\" objects. The invocation of passes the graphics context off to the component's UI delegate, which paints the panel's background. For a closer look at this process, see the section entitled \"Painting and the UI Delegate\" in the aforementioned SDN article.\n• Now that you have drawn some custom text to the screen, try minimizing and restoring the application as you did before.\n• Obscure a part of the text with another window, then move that window out of the way to re-expose the custom text. In both cases, the painting subsystem will determine that the component is damaged and will ensure that your method is invoked."
    }
]