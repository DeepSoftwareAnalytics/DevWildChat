[
    {
        "link": "https://geeksforgeeks.org/program-calculate-value-ncr",
        "document": "Given two numbers n and r, The task is to find the value of nC Combinations represent the number of ways to choose r elements from a set of n distinct elements, without regard to the order in which they are selected. The formula for calculating combinations is :\n\nInput: n = 5, r = 2\n\nOutput: 10 \n\nExplanation: The value of 5C is calculated as 5! / (5−2)! * 2!​ = 10. Input: n = 2, r = 4\n\nOutput: 0\n\nExplanation: Since r is greater than n, thus 2C = 0 Input: n = 5, r = 0\n\nOutput: 1\n\nExplanation: The value of 5C is calculated as 5!/(5−0)!*0! = 5!/5!*0! = 1.\n\nThis approach calculates the binomial coefficient nCr using the factorial formula. It first computes the factorial of a given number by multiplying all integers from 1 to that number. To find nCr, it calculates the factorial of n, r, and (n – r) separately, then applies the formula n! / (r!(n-r)!) to determine the result. Since factorial values grow rapidly, this method is inefficient for large values due to integer overflow and excessive computations.\n\nThe idea is to use a recursive function to calculate the value of nC . The base cases are:\n• None if r is greater than n, return 0 (there are no combinations possible)\n• None if r is 0 or r is n, return 1 (there is only 1 combination possible in these cases) For other values of n and r, the function calculates the value of nC by adding the number of combinations possible by including the current element and the number of combinations possible by not including the current element.\n\nLogarithmic formula for nCr is an alternative to the factorial formula that avoids computing factorials directly and it’s more efficient for large values of n and r. It uses the identity log(n!) = log(1) + log(2) + … + log(n) to express the numerator and denominator of the nCr in terms of sums of logarithms which allows to calculate the nCr using the Logarithmic operations. This approach is faster and very efficient. The logarithmic formula for nCr is: nC = exp( log(n!) – log(r!) – log((n-r)!) )\n\n// Calculates the binomial coefficient nCr using the logarithmic formula // If r is greater than n, return 0 // If r is 0 or equal to n, return 1 // the numerator and denominator using loop // and subtract the logarithm of (i+1) // Calculates the binomial coefficient nCr using the logarithmic formula // If r is greater than n, return 0 // If r is 0 or equal to n, return 1 // Calculate the logarithmic sum of the numerator and denominator using loop // Add the logarithm of (n-i) and subtract the logarithm of (i+1) // Calculates the binomial coefficient nCr using the logarithmic formula // If r is greater than n, return 0 // If r is 0 or equal to n, return 1 // Calculate the logarithmic sum of the numerator and denominator using loop // Add the logarithm of (n-i) and subtract the logarithm of (i+1) # Calculates the binomial coefficient nCr using the logarithmic formula # If r is greater than n, return 0 # If r is 0 or equal to n, return 1 # Calculate the logarithmic sum of the numerator and denominator using loop # Add the logarithm of (n-i) and subtract the logarithm of (i+1) // Calculates the binomial coefficient nCr using the logarithmic formula // If r is greater than n, return 0 // If r is 0 or equal to n, return 1 // Calculate the logarithmic sum of the numerator and denominator using loop // Add the logarithm of (n-i) and subtract the logarithm of (i+1)"
    },
    {
        "link": "https://stackoverflow.com/questions/26560726/python-binomial-coefficient",
        "document": "This binomial coefficient program works but when I input two of the same number which is supposed to equal to 1 or when y is greater than x it is supposed to equal to 0.\n\nThis question is old but as it comes up high on search results I will point out that has two functions for computing the binomial coefficients:\n• import scipy.special # the two give the same results scipy.special.binom(10, 5) # 252.0 scipy.special.comb(10, 5) # 252.0 scipy.special.binom(300, 150) # 9.375970277281882e+88 scipy.special.comb(300, 150) # 9.375970277281882e+88 # ...but with `exact == True` scipy.special.comb(10, 5, exact=True) # 252 scipy.special.comb(300, 150, exact=True) # 393759702772827452793193754439064084879232655700081358920472352712975170021839591675861424 Note that uses Python integers, and therefore it can handle arbitrarily large results! Speed-wise, the three versions give somewhat different results: num = 300 %timeit [[scipy.special.binom(n, k) for k in range(n + 1)] for n in range(num)] # 52.9 ms ± 107 µs per loop (mean ± std. dev. of 7 runs, 10 loops each) %timeit [[scipy.special.comb(n, k) for k in range(n + 1)] for n in range(num)] # 183 ms ± 814 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)each) %timeit [[scipy.special.comb(n, k, exact=True) for k in range(n + 1)] for n in range(num)] # 180 ms ± 649 µs per loop (mean ± std. dev. of 7 runs, 10 loops each) (and for , the binomial coefficients are too large to be represented correctly using numbers, as shown above).\n\nSo, this question comes up first if you search for \"Implement binomial coefficients in Python\". Only this answer in its second part contains an efficient implementation which relies on the multiplicative formula. This formula performs the bare minimum number of multiplications. The function below does not depend on any built-ins or imports: def fcomb0(n, k): ''' Compute the number of ways to choose $k$ elements out of a pile of $n.$ Use an iterative approach with the multiplicative formula: $$\\frac{n!}{k!(n - k)!} = \\frac{n(n - 1)\\dots(n - k + 1)}{k(k-1)\\dots(1)} = \\prod_{i = 1}^{k}\\frac{n + 1 - i}{i}$$ Also rely on the symmetry: $C_n^k = C_n^{n - k},$ so the product can be calculated up to $\\min(k, n - k).$ :param n: the size of the pile of elements :param k: the number of elements to take from the pile :return: the number of ways to choose k elements out of a pile of n ''' # When k out of sensible range, should probably throw an exception. # For compatibility with scipy.special.{comb, binom} returns 0 instead. if k < 0 or k > n: return 0 if k == 0 or k == n: return 1 total_ways = 1 for i in range(min(k, n - k)): total_ways = total_ways * (n - i) // (i + 1) return total_ways Finally, if you need even larger values and do not mind trading some accuracy, Stirling's approximation is probably the way to go.\n\nI recommend using dynamic programming (DP) for computing binomial coefficients. In contrast to direct computation, it avoids multiplication and division of large numbers. In addition to recursive solution, it stores previously solved overlapping sub-problems in a table for fast look-up. The code below shows bottom-up (tabular) DP and top-down (memoized) DP implementations for computing binomial coefficients. def binomial_coeffs1(n, k): #top down DP if (k == 0 or k == n): return 1 if (memo[n][k] != -1): return memo[n][k] memo[n][k] = binomial_coeffs1(n-1, k-1) + binomial_coeffs1(n-1, k) return memo[n][k] def binomial_coeffs2(n, k): #bottom up DP for i in range(n+1): for j in range(min(i,k)+1): if (j == 0 or j == i): memo[i][j] = 1 else: memo[i][j] = memo[i-1][j-1] + memo[i-1][j] #end if #end for #end for return memo[n][k] def print_array(memo): for i in range(len(memo)): print('\\t'.join([str(x) for x in memo[i]])) #main n = 5 k = 2 print(\"top down DP\") memo = [[-1 for i in range(6)] for j in range(6)] nCk = binomial_coeffs1(n, k) print_array(memo) print(\"C(n={}, k={}) = {}\".format(n,k,nCk)) print(\"bottom up DP\") memo = [[-1 for i in range(6)] for j in range(6)] nCk = binomial_coeffs2(n, k) print_array(memo) print(\"C(n={}, k={}) = {}\".format(n,k,nCk)) Note: the size of the memo table is set to a small value (6) for display purposes, it should be increased if you are computing binomial coefficients for large n and k.\n\nA bit shortened multiplicative variant given by PM 2Ring and alisianoi. Works with python 3 and doesn't require any packages. def comb(n, k): # Remove the next two lines if out-of-range check is not needed if k < 0 or k > n: return None x = 1 for i in range(min(k, n - k)): x = x*(n - i)//(i + 1) return x from functools import reduce def comb(n, k): return (None if k < 0 or k > n else reduce(lambda x, i: x*(n - i)//(i + 1), range(min(k, n - k)), 1)) The division is done right after multiplication not to accumulate high numbers. EDIT: I decided to add an explanation to this old question. As mentioned in other answers there are ready-to-use library methods like math.comb(n, k), scipy.special.comb(), or scipy.special.binom(). However, the original question was about the actual implementation. While it is possible to use formulas blindly, calculated factorials likely become very large and require big integer arithmetic very quickly. Instead, it makes more sense to rearrange the operands: Because the multiplication of k consecutive positive integers is always divisible by , the partial calculation result is always an integer never exceeds the actual value of . So, the solution by @assafsha that uses the multiplicative formula, unnecessarily converts components to float. Solutions, using factorials and the direct formula from a schoolbook unnecessarily use big integer arithmetic. The solution with recursion unnecessarily use (potentially large amount of) stack and the user may end up with the out-of-memory error. This is because Python doesn't have tail recursion optimization.\n\nFor those of you interested, here is the CPython implementation in mathmodule.c. The basic recursive formula (no memoization) is This is a repeated use of the identity C(n, k) = (n/k) * C(n-1, k-1). The rationale given is that Karatsuba multiplication, a divide-and-conquer algorithm, runs faster multiplying numbers about the same size (therefore the choice of j). /* Calculate P(n, k) or C(n, k) using recursive formulas. * It is more efficient than sequential multiplication thanks to * Karatsuba multiplication. */ static PyObject * perm_comb(PyObject *n, unsigned long long k, int iscomb) { if (k == 0) { return PyLong_FromLong(1); } if (k == 1) { return Py_NewRef(n); } /* P(n, k) = P(n, j) * P(n-j, k-j) */ /* C(n, k) = C(n, j) * C(n-j, k-j) // C(k, j) */ unsigned long long j = k / 2; PyObject *a, *b; a = perm_comb(n, j, iscomb); if (a == NULL) { return NULL; } PyObject *t = PyLong_FromUnsignedLongLong(j); if (t == NULL) { goto error; } n = PyNumber_Subtract(n, t); Py_DECREF(t); if (n == NULL) { goto error; } b = perm_comb(n, k - j, iscomb); Py_DECREF(n); if (b == NULL) { goto error; } Py_SETREF(a, PyNumber_Multiply(a, b)); Py_DECREF(b); if (iscomb && a != NULL) { b = perm_comb_small(k, j, 1); if (b == NULL) { goto error; } Py_SETREF(a, PyNumber_FloorDivide(a, b)); Py_DECREF(b); } return a; error: Py_DECREF(a); return NULL; } There is also a specialization for small n, using some pre-computed values. Pre-computed factorials in general are useful if computing many binomial coefficients, including mod p. /* Number of permutations and combinations. * P(n, k) = n! / (n-k)! * C(n, k) = P(n, k) / k! */ /* Calculate C(n, k) for n in the 63-bit range. */ static PyObject * perm_comb_small(unsigned long long n, unsigned long long k, int iscomb) { assert(k != 0); /* For small enough n and k the result fits in the 64-bit range and can * be calculated without allocating intermediate PyLong objects. */ if (iscomb) { /* Maps k to the maximal n so that 2*k-1 <= n <= 127 and C(n, k) * fits into a uint64_t. Exclude k = 1, because the second fast * path is faster for this case.*/ static const unsigned char fast_comb_limits1[] = { 0, 0, 127, 127, 127, 127, 127, 127, // 0-7 127, 127, 127, 127, 127, 127, 127, 127, // 8-15 116, 105, 97, 91, 86, 82, 78, 76, // 16-23 74, 72, 71, 70, 69, 68, 68, 67, // 24-31 67, 67, 67, // 32-34 }; if (k < Py_ARRAY_LENGTH(fast_comb_limits1) && n <= fast_comb_limits1[k]) { /* comb(n, k) fits into a uint64_t. We compute it as comb_odd_part << shift where 2**shift is the largest power of two dividing comb(n, k) and comb_odd_part is comb(n, k) >> shift. comb_odd_part can be calculated efficiently via arithmetic modulo 2**64, using three lookups and two uint64_t multiplications. */ uint64_t comb_odd_part = reduced_factorial_odd_part[n] * inverted_factorial_odd_part[k] * inverted_factorial_odd_part[n - k]; int shift = factorial_trailing_zeros[n] - factorial_trailing_zeros[k] - factorial_trailing_zeros[n - k]; return PyLong_FromUnsignedLongLong(comb_odd_part << shift); } /* Maps k to the maximal n so that 2*k-1 <= n <= 127 and C(n, k)*k * fits into a long long (which is at least 64 bit). Only contains * items larger than in fast_comb_limits1. */ static const unsigned long long fast_comb_limits2[] = { 0, ULLONG_MAX, 4294967296ULL, 3329022, 102570, 13467, 3612, 1449, // 0-7 746, 453, 308, 227, 178, 147, // 8-13 }; if (k < Py_ARRAY_LENGTH(fast_comb_limits2) && n <= fast_comb_limits2[k]) { /* C(n, k) = C(n, k-1) * (n-k+1) / k */ unsigned long long result = n; for (unsigned long long i = 1; i < k;) { result *= --n; result /= ++i; } return PyLong_FromUnsignedLongLong(result); } } else { /* Maps k to the maximal n so that k <= n and P(n, k) * fits into a long long (which is at least 64 bit). */ static const unsigned long long fast_perm_limits[] = { 0, ULLONG_MAX, 4294967296ULL, 2642246, 65537, 7133, 1627, 568, // 0-7 259, 142, 88, 61, 45, 36, 30, 26, // 8-15 24, 22, 21, 20, 20, // 16-20 }; if (k < Py_ARRAY_LENGTH(fast_perm_limits) && n <= fast_perm_limits[k]) { if (n <= 127) { /* P(n, k) fits into a uint64_t. */ uint64_t perm_odd_part = reduced_factorial_odd_part[n] * inverted_factorial_odd_part[n - k]; int shift = factorial_trailing_zeros[n] - factorial_trailing_zeros[n - k]; return PyLong_FromUnsignedLongLong(perm_odd_part << shift); } /* P(n, k) = P(n, k-1) * (n-k+1) */ unsigned long long result = n; for (unsigned long long i = 1; i < k;) { result *= --n; ++i; } return PyLong_FromUnsignedLongLong(result); } } /* For larger n use recursive formulas: * * P(n, k) = P(n, j) * P(n-j, k-j) * C(n, k) = C(n, j) * C(n-j, k-j) // C(k, j) */ unsigned long long j = k / 2; PyObject *a, *b; a = perm_comb_small(n, j, iscomb); if (a == NULL) { return NULL; } b = perm_comb_small(n - j, k - j, iscomb); if (b == NULL) { goto error; } Py_SETREF(a, PyNumber_Multiply(a, b)); Py_DECREF(b); if (iscomb && a != NULL) { b = perm_comb_small(k, j, 1); if (b == NULL) { goto error; } Py_SETREF(a, PyNumber_FloorDivide(a, b)); Py_DECREF(b); } return a; error: Py_DECREF(a); return NULL; }"
    },
    {
        "link": "https://geeksforgeeks.org/binomial-coefficient-dp-9",
        "document": "Given an integer values n and k, the task is to find the value of Binomial Coefficient C(n, k).\n• None C(n, k) can be defined as the coefficient of x^k in the expansion of (1 + x)^n.\n• None A binomial coefficient C(n, k) also gives the number of ways, disregarding order, that k objects can be chosen from among n objects more formally, the number of k-element subsets (or k-combinations) of a n-element set.\n\nUsing recursion – O(2 ^ n) Time and O(n) Space\n\n// k can not be grater then k so we return 0 here // base condition when k and n are equal or k = 0 // k can not be grater then k so we return 0 here // base condition when k and n are equal or k = 0 // k can not be grater then k so we // base condition when k and n are # k can not be grater then k so we # base condition when k and n are equal // k can not be grater then k so we // base condition when k and n are // k can not be grater then k so we // base condition when k and n are equal\n\n) – O(n * k) Time and O(n * k) Space\n\nIt should be noted that the above function computes the same subproblems again and again. And have two properties of Dynamic Programming: The value of C(n, k)depends on the optimal solutions of the subproblemsC(n-1, k-1) and C(n-1, k). By adding these optimal substrutures, we can efficiently calculate the total value of C(n, k). While applying a recursive approach in this problem, we notice that certain subproblems are computed multiple times. Recursion tree for n = 5 and k = 2. The function C(3, 1) is called two times. For large values of n, there will be many common subproblems.\n\nThe Binomial Coefficient C(n, k) is computed recursively, but to avoid redundant calculations, dynamic programming with memoization is used. A 2D table stores previously computed values, allowing efficient lookups instead of recalculating. If a value is already computed, it is returned directly; otherwise, it is computed recursively and stored for future use.\n\n// k can not be grater then k so we // base condition when k and n are // Check if pair n and k is already // calculated then return it from here // Recurvie add the value and store to memorize table // k cannot be greater than n so we return 0 here // base condition when k and n are equal or k = 0 // Check if pair n and k is already // calculated then return it from here // Recursive add the value and store to memo table # k cannot be greater than n so we return 0 here # base condition when k and n are equal or k = 0 # Check if pair n and k is already # calculated then return it from here # Recursive add the value and store to memo table \\ // k cannot be greater than n so we // base condition when k and n are // Check if pair n and k is already // calculated then return it from here // Recursive add the value and store to memo table // k cannot be greater than n so we // base condition when k and n are // Check if pair n and k is already // calculated then return it from here // Recursive add the value and store to memo table\n\nUsing Bottom-Up DP (Tabulation) – O(n * k) Time and O(n * k) Space\n\nUsing Space Optimized DP – O(n * k) Time and O(k) Space\n\nIn the previous approach using dynamic programming, we derived a relation between states as follows: We do not need to maitain whole matrix for this. We can just maintain one array of length k and add dp[j-1] every time to dp[j];\n• dp[j] in reverse order, using the previous values from the same array.\n• None Program to calculate value of nCr"
    },
    {
        "link": "https://stackoverflow.com/questions/3025162/statistics-combinations-in-python",
        "document": "I need to compute combinatorials (nCr) in Python but cannot find the function to do that in , or libraries. Something like a function of the type: I need the number of possible combinations, not the actual combinations, so does not interest me. Finally, I want to avoid using factorials, as the numbers I'll be calculating the combinations for can get too big and the factorials are going to be monstrous. This seems like a REALLY easy to answer question, however I am being drowned in questions about generating all the actual combinations, which is not what I want."
    },
    {
        "link": "https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.comb.html",
        "document": "The number of combinations of N things taken k at a time.\n\nThis is often expressed as “N choose k”.\n\nFor integers, if exact is False, then floating point precision is used, otherwise the result is computed exactly. Deprecated since version 1.14.0: is deprecated for non-integer N and k and will raise an error in SciPy 1.16.0 If repetition is True, then the number of combinations with repetition is computed.\n• None If N < 0, or k < 0, then 0 is returned.\n• None If k > N and repetition=False, then 0 is returned."
    },
    {
        "link": "https://geeksforgeeks.org/python-math-factorial-function",
        "document": ""
    },
    {
        "link": "https://docs.python.org/3/library/math.html",
        "document": "This module provides access to the mathematical functions defined by the C standard.\n\nThese functions cannot be used with complex numbers; use the functions of the same name from the module if you require support for complex numbers. The distinction between functions which support complex numbers and those which don’t is made since most users do not want to learn quite as much mathematics as required to understand complex numbers. Receiving an exception instead of a complex result allows earlier detection of the unexpected complex number used as a parameter, so that the programmer can determine how and why it was generated in the first place.\n\nThe following functions are provided by this module. Except when explicitly noted otherwise, all return values are floats.\n\nReturn the number of ways to choose k items from n items without repetition and without order. Evaluates to when and evaluates to zero when . Also called the binomial coefficient because it is equivalent to the coefficient of k-th term in polynomial expansion of . Raises if either of the arguments are not integers. Raises if either of the arguments are negative. Return n factorial as an integer. Raises if n is not integral or is negative. Changed in version 3.10: Floats with integral values (like ) are no longer accepted. Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is . without arguments returns . Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using . Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is . without arguments returns . Return the number of ways to choose k items from n items without repetition and with order. Evaluates to when and evaluates to zero when . If k is not specified or is , then k defaults to n and the function returns . Raises if either of the arguments are not integers. Raises if either of the arguments are negative.\n\nReturn the ceiling of x, the smallest integer greater than or equal to x. If x is not a float, delegates to , which should return an value. Return the absolute value of x. Return the floor of x, the largest integer less than or equal to x. If x is not a float, delegates to , which should return an value. Fused multiply-add operation. Return , computed as though with infinite precision and range followed by a single round to the format. This operation often provides better accuracy than the direct expression . This function follows the specification of the fusedMultiplyAdd operation described in the IEEE 754 standard. The standard leaves one case implementation-defined, namely the result of and . In these cases, returns a NaN, and does not raise any exception. Return the floating-point remainder of , as defined by the platform C library function . Note that the Python expression may not return the same result. The intent of the C standard is that be exactly (mathematically; to infinite precision) equal to for some integer n such that the result has the same sign as x and magnitude less than . Python’s returns a result with the sign of y instead, and may not be exactly computable for float arguments. For example, is , but the result of Python’s is , which cannot be represented exactly as a float, and rounds to the surprising . For this reason, function is generally preferred when working with floats, while Python’s is preferred when working with integers. Return the fractional and integer parts of x. Both results carry the sign of x and are floats. Note that has a different call/return pattern than its C equivalents: it takes a single argument and return a pair of values, rather than returning its second return value through an ‘output parameter’ (there is no such thing in Python). Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference , where is the closest integer to the exact value of the quotient . If is exactly halfway between two consecutive integers, the nearest even integer is used for . The remainder thus always satisfies . Special cases follow IEEE 754: in particular, is x for any finite x, and and raise for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating point, the result of this operation is always exactly representable: no rounding error is introduced. Return x with the fractional part removed, leaving the integer part. This rounds toward 0: is equivalent to for positive x, and equivalent to for negative x. If x is not a float, delegates to , which should return an value. For the , , and functions, note that all floating-point numbers of sufficiently large magnitude are exact integers. Python floats typically carry no more than 53 bits of precision (the same as the platform C double type), in which case any float x with necessarily has no fractional bits.\n\nReturn a float with the magnitude (absolute value) of x but the sign of y. On platforms that support signed zeros, returns -1.0. Return the mantissa and exponent of x as the pair . m is a float and e is an integer such that exactly. If x is zero, returns , otherwise . This is used to “pick apart” the internal representation of a float in a portable way. Note that has a different call/return pattern than its C equivalents: it takes a single argument and return a pair of values, rather than returning its second return value through an ‘output parameter’ (there is no such thing in Python). Return if the values a and b are close to each other and otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. If no errors occur, the result will be: . rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass . The default tolerance is , which assures that the two values are the same within about 9 decimal digits. rel_tol must be nonnegative and less than . abs_tol is the absolute tolerance; it defaults to and it must be nonnegative. When comparing to , is computed as , which is for any nonzero and rel_tol less than . So add an appropriate positive abs_tol argument to the call. The IEEE 754 special values of , , and will be handled according to IEEE rules. Specifically, is not considered close to any other value, including . and are only considered close to themselves. Return if x is neither an infinity nor a NaN, and otherwise. (Note that is considered finite.) Return if x is a positive or negative infinity, and otherwise. Return if x is a NaN (not a number), and otherwise. Return . This is essentially the inverse of function . Return the floating-point value steps steps after x towards y. If x is equal to y, return y, unless steps is zero.\n• None goes up: towards positive infinity.\n• None goes down: towards minus infinity.\n• None goes towards zero.\n• None goes away from zero. Return the value of the least significant bit of the float x:\n• None If x is a NaN (not a number), return x.\n• None If x is equal to zero, return the smallest positive denormalized representable float (smaller than the minimum positive normalized float, ).\n• None If x is equal to the largest positive representable float, return the value of the least significant bit of x, such that the first float smaller than x is .\n• None Otherwise (x is a positive finite number), return the value of the least significant bit of x, such that the first float bigger than x is . ULP stands for “Unit in the Last Place”. See also and .\n\nReturn e raised to the power x, where e = 2.718281… is the base of natural logarithms. This is usually more accurate than or . Return e raised to the power x, minus 1. Here e is the base of natural logarithms. For small floats x, the subtraction in can result in a significant loss of precision; the function provides a way to compute this quantity to full precision: With one argument, return the natural logarithm of x (to base e). With two arguments, return the logarithm of x to the given base, calculated as . Return the natural logarithm of 1+x (base e). The result is calculated in a way which is accurate for x near zero. Return the base-2 logarithm of x. This is usually more accurate than . returns the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros. Return the base-10 logarithm of x. This is usually more accurate than . Return x raised to the power y. Exceptional cases follow the IEEE 754 standard as far as possible. In particular, and always return , even when x is a zero or a NaN. If both x and y are finite, x is negative, and y is not an integer then is undefined, and raises . Unlike the built-in operator, converts both its arguments to type . Use or the built-in function for computing exact integer powers. Changed in version 3.11: The special cases and were changed to return instead of raising , for consistency with IEEE 754.\n\nReturn the Euclidean distance between two points p and q, each given as a sequence (or iterable) of coordinates. The two points must have the same dimension. Return an accurate floating-point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums. The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating-point summation. Return the Euclidean norm, . This is the length of the vector from the origin to the point given by the coordinates. For a two dimensional point , this is equivalent to computing the hypotenuse of a right triangle using the Pythagorean theorem, . Changed in version 3.8: Added support for n-dimensional points. Formerly, only the two dimensional case was supported. Changed in version 3.10: Improved the algorithm’s accuracy so that the maximum error is under 1 ulp (unit in the last place). More typically, the result is almost always correctly rounded to within 1/2 ulp. Calculate the product of all the elements in the input iterable. The default start value for the product is . When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. Return the sum of products of values from two iterables p and q. Raises if the inputs do not have the same length. For float and mixed int/float inputs, the intermediate products and sums are computed with extended precision.\n\nThe mathematical constant π = 3.141592…, to available precision. The mathematical constant e = 2.718281…, to available precision. The mathematical constant τ = 6.283185…, to available precision. Tau is a circle constant equal to 2π, the ratio of a circle’s circumference to its radius. To learn more about Tau, check out Vi Hart’s video Pi is (still) Wrong, and start celebrating Tau day by eating twice as much pie! A floating-point positive infinity. (For negative infinity, use .) Equivalent to the output of . A floating-point “not a number” (NaN) value. Equivalent to the output of . Due to the requirements of the IEEE-754 standard, and are not considered to equal to any other numeric value, including themselves. To check whether a number is a NaN, use the function to test for NaNs instead of or . Example: Changed in version 3.11: It is now always available. CPython implementation detail: The module consists mostly of thin wrappers around the platform C math library functions. Behavior in exceptional cases follows Annex F of the C99 standard where appropriate. The current implementation will raise for invalid operations like or (where C99 Annex F recommends signaling invalid operation or divide-by-zero), and for results that overflow (for example, ). A NaN will not be returned from any of the functions above unless one or more of the input arguments was a NaN; in that case, most functions will return a NaN, but (again following C99 Annex F) there are some exceptions to this rule, for example or . Note that Python makes no effort to distinguish signaling NaNs from quiet NaNs, and behavior for signaling NaNs remains unspecified. Typical behavior is to treat all NaNs as though they were quiet. Complex number versions of many of these functions."
    },
    {
        "link": "https://geeksforgeeks.org/factorial-in-python",
        "document": "Not many people know, but python offers a direct function that can compute the factorial of a number without writing the whole code for computing factorial.\n\nThis method is defined in “math” module of python. Because it has C type internal implementation, it is fast.\n\nmath.factorial(x)\n\nParameters :\n\nx : The number whose factorial has to be computed. \n\nReturn value :\n\n \n\nExceptions : \n\n Raises Value error if number is negative or non-integral.\n• If given number is Negative :\n• If given number is Non – Integral Value :"
    },
    {
        "link": "https://w3schools.com/python/ref_math_factorial.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://unstop.com/blog/factorial-program-in-python",
        "document": "The factorial of a number is the product of all preceding non-negative integers and itself in descending order. Ways to find the factorial of a number in Python include loops, recursion, built-in functions, etc.\n\nFactorial is a mathematical operation representing the product of all positive integers up to a given number. It is denoted by an exclamation mark (!). For example, the factorial of 5 (denoted as 5!) is calculated as 5 × 4 × 3 × 2 × 1 = 120. Factorials are widely used in permutations, combinations, and other mathematical computations.\n\nThere are many techniques you can use to write a factorial program in Python language. These include the iterative approach, recursion, and other optimized approaches using libraries like math and NumPy. In this article, we will explore various methods to calculate factorials in Python, starting with the basics.\n\nThe process of calculating the factorial of a number involves multiplying a sequence of descending positive integers from the respective number. That is, the factorial of a non-negative integer n is the product of all positive integers less than or equal to n.\n\nWhy 0!=1? The definition of 0!=1 is a convention that simplifies various mathematical expressions, particularly in combinatorics and series expansions. This definition ensures that formulas and equations work correctly even when n=0.\n\nAlgorithm Of Program To Find Factorial Of A Number In Python\n\nThe algorithm to find the factorial of a number can be implemented in various ways, but a common and straightforward method is to use an iterative approach. Below are the steps (as also illustrated in the flowchart) to find the factorial of a number in Python:\n• Initialize the Result: Start by initialising a variable, say the result with the value 1. This will store the final factorial value.\n• Iterate Through Numbers: Use a loop to iterate through all numbers from 1 to the given number n.\n• Multiply and Update Result: In each iteration, multiply the current value of the result by the current number in the loop.\n• Return the Result: After the loop completes, the variable result will hold the factorial of the number n.\n\nThe pseudocode provides a high-level description of the algorithm without the syntax of a specific programming language. Below is the pseudocode for finding the factorial of a number using an iterative approach:\n\nFactorial Program In Python Using For Loop\n\nTo find the factorial of a number using a for loop in Python, we start by initializing a result variable to 1. This variable will store the cumulative product of numbers from 1 to the given number n. We then use a for loop to iterate through each integer from 1 to n, multiplying the current value of the result by the loop counter in each iteration.\n\nThis iterative multiplication effectively computes the factorial by successively updating the result. Once the loop completes, the result variable contains the factorial of n. The Python program example below illustrates this approach to calculate and print the factorial.\n\nIn the Python code example-\n• We define a function named factorial_iterative, which calculates the factorial of a given number n iteratively.\n• We first initialize a variable result inside the function with the value 1. This variable will hold the final factorial value.\n• Then, we use a for loop to iterate over the range from 1 to n inclusive. In each iteration, we multiply the result variable by the current value of i (the loop variable).\n• After the loop completes iterations, the variable result contains the factorial of n, which the function returns.\n• In the main part, we initialize a variable number with the value 6.\n• Next, we call the factorial_iterative() function inside the print() function, passing the variable number as an argument.\n• This function call and print() function displays the factorial of number with a descriptive message.\n\nRecursion is a programming technique where a function calls itself to solve smaller instances of the same problem. To find the factorial of a number using recursion, we define a function that calls itself with a smaller argument until it reaches the base case, which is when the argument becomes 0.\n\nIn the recursive approach to find the factorial of a number, we define:\n• Base Case: The factorial of 0 is defined as 1.\n• Recursive Case: For any other number n, the factorial is calculated as n×(n−1)\n• The def keyword marks the beginning of the function with the name factorial_recursive and takes a parameter n.\n• The if-else statement condition n==0 uses the relational operator to check if n is equal to 0. This is the base case.\n• The return statements stipulate what the function will return given if the condition is met.\n• The expression n*factorial_recursive(n-1) is the recursive step, which returns n multiplied by the result of calling itself with n - 1, reducing the problem size with each call until reaching the base case.\n\nLet's look at a simple Python program example to understand how to use recursion for factorial calculations.\n\nIn the simple Python code example-\n• We define a function named factorial_recursive that takes n as a parameter and calculates its factorial recursively.\n• In the function, we have an if-else statement that defines the base case and the recursive step.\n• The if condition (base case) checks if n equals 0, i.e., n==0. If true, the function returns 1. This is because the factorial of 0 is defined as 1.\n• If the condition is false, we proceed to the recursive step where the function returns the product of n and the factorial of n-1, achieved by calling factorial_recursive(n - 1).\n• The function keeps calling itself with decreasing values of n until it reaches the base case.\n• Once the base case is reached, the function returns values back up the call stack, each time multiplying n with the result of the factorial of n-1.\n• In the main segment of the code, we initialize a variable n with the value 5 and then call the factorial_recursive function.\n• The function calculates the factorial of the number 5, which we then print using the print() function.\n\nFactorial Program In Python Using While Loop\n\nTo find the factorial of a number using a while loop in Python, we initialize a result variable to 1 to store the cumulative product of the numbers. We also initialize a counter variable to 1, which will be used to iterate through the numbers from 1 to the given number n.\n\nUsing a while loop, we repeatedly multiply the result by the counter variable and then increment the counter until it exceeds n. The example Python program below showcases this approach.\n\nIn the example Python code-\n• We define a function named factorial_while that takes a parameter n and calculates its factorial using a while loop.\n• Inside the function, we initialize variables result and i to value 1. The former will store the final factorial value and the latter will serve as a counter for the loop.\n• Then, we use a while loop that continues as long as i is less than or equal to n.\n• In every iteration, we multiply the result variable by the current value of i, and then increment i by 1 to move to the next number.\n• When the loop completes its iterations, the result variable will contain the factorial of n, which the function returns.\n• In the main part, we initialize a variable number with the value 5 and call the factorial_while() function, passing the number as an argument.\n• This function calculates the factorial, which we print using the print() function and f-strings.\n\nThe if-else statement helps execute one of the two code blocks depending upon whether the if-condition is met. Using an if-else statement to find the factorial of a number typically involves a recursive approach.\n\nIn this method, the function calls itself with a decremented value of the original number until it reaches the base case. The base case is when the input number is zero, and the factorial of zero is defined as one. Each recursive call multiplies the current number by the result of the factorial of the previous number. The Python program sample below illustrates this approach for a better understanding.\n• We begin by defining a function named factorial_recursive , that takes a number n as parameter and calculates its factorial recursively.\n• Inside the function, we use an if-else statement to check the base case. In case the if-condition n==0 is true, the function returns 1 because the factorial of 0 is defined as 1.\n• If the condition is false, we proceed to the recursive step. Here, we return the product of n and the factorial of n-1, achieved by calling factorial_recursive(n - 1).\n• The function keeps calling itself with decreasing values of n until it reaches the base case where n is 0.\n• Once the base case is reached, the function returns values back up the call stack, each time multiplying n with the result of the factorial of n-1.\n• For the example usage in the main part, we initialize a variable number with the value 4.\n• Then, we call the factorial_recursive() function that calculates the factorial of the number 4.\n• We print this result with a descriptive string message using the print() function.\n\nThe math Module | Factorial Program In Python Using Built-In Factorial() Function\n\nThe Math library in Python contains a built-in function for computing factorials called the factorial() function. Naturally, in this method we must import the math module and use the function math.factorial().\n\nThis is one of the most straightforward and efficient ways to calculate the factorial of a number, as it abstracts away the implementation details and is highly optimized. The sample Python program presents how this approach works.\n\nWe begin the sample Python code by importing the math module, which provides access to mathematical functions. Then-\n• We define a function named factorial_builtin that takes a number n as a parameter and calculates its factorial using the built-in math.factorial function.\n• Inside the function, we simply return the result of calling the math.factorial() function passing the parameter n as an argument.\n• The math.factorial function handles the calculation of the factorial internally.\n• To showcase, in the main part, we initialize a variable number with value 5 and then call the factorial_builtin() function.\n• We then print the factorial calculated to the output console using the print() function.\n\nPython Program to Find Factorial of a Number Using Ternary Operator(One Line Solution)\n\nIn Python, a ternary operator provides a way to condense an if-else statement into a single line. This technique can be utilized to create a concise recursive function for calculating the factorial of a number. The ternary operator will handle the base case and the recursive step within one line of code. The syntax for this operator is given below, followed by a basic Python program example.\n• return 1 if n == 0 else n * factorial_ternary(n - 1): Uses the ternary operator to return 1 if n is equal to 0; otherwise, returns n multiplied by the result of factorial_ternary(n - 1).\n\nIn the basic Python code example-\n• We define a function named factorial_ternary, which calculates the factorial of the parameter number n using a ternary operator and recursion.\n• In the function, we use the ternary operator to check the base condition n==0. If this is true, then the ternary operator returns 1.\n• If the condition is false, it returns n multiplied by the factorial of n-1, which is achieved by calling factorial_ternary(n - 1).\n• This recursive approach continues until it reaches the base case where n is 0.\n• Once the base case is reached, the function starts returning values back up the call stack, each time multiplying n with the result of the factorial of n-1.\n• In the main part, we initialize a variable number with the value 3 and then call the factorial_ternary() function.\n• The factorial is printed to the console using f-strings inside a print() function.\n\nThe prime factorization method for finding the factorial of a number involves breaking down the number into its prime factors and then counting the occurrences of each prime factor. Since factorial involves multiplying consecutive numbers, the prime factors of the factorial can be derived from the prime numbers less than or equal to the given number.\n\nWe can write a factorial program in Python by counting the occurrences of each prime factor in the range [2, n].\n\nIn this sample factorial program in Python-\n• We begin by defining a function named factorial_prime_factorization, which calculates the factorial of a given number n using prime factorization.\n• Inside this function, there's another nested function named prime_factors that computes the prime factors of a given number.\n• Inside, we initialize an empty dictionary named factors to store the prime factors and their respective counts.\n• We then set a divisor to 2 and use a while loop that iterates until the square of the divisor is less than or equal to the input number.\n• During each iteration, an if-else statement checks if the number is divisible by the divisor. If it is, we update the factors dictionary accordingly and reduce the number by dividing it by the divisor.\n• If the number is not divisible by the current divisor, we increment the divisor by 1.\n• After the loop, we have another if-statement, which checks if the remaining number is greater than 1. If it is, we update the factors dictionary accordingly.\n• The prime_factors function returns the dictionary containing the prime factors and their counts.\n• Moving back to the outer function, we create another empty dictionary prime_factors_count to store the prime factors and their respective counts for all numbers from 2 to n.\n• Then, we use a set of nested for loops to iterate through the range from 2 to n, where the outer loop computes the prime factors for each number using the prime_factors() function and the inner loop updates prime_factors_count accordingly.\n• Next, we initialize a variable factorial with the value 1 and then use a for loop to calculate the factorial using the prime factors stored in prime_factors_count.\n• The loop iterates through the items of prime_factors_count, multiplying the factorial by each prime factor raised to its respective count (using the exponent operator).\n• Finally, the function returns the calculated factorial stored inside the variable factorial.\n• Lastly, we initialize a variable number with the value 5 and calculate and print its factorial using the factorial_prime_factorization() and print() functions.\n\nThe NumPy library in Python offers multiple efficient numerical operations on arrays, etc. We can leverage its capabilities to compute the factorial of a number using the numpy.prod() function. This method involves creating an array containing the integers from 1 to the given number and then using the numpy.prod() function to calculate their product.\n\nThe numpy.prod() function efficiently computes the product of array elements along a specified axis, providing a succinct and optimized solution for calculating factorials. Look at the simple Python example below, which illustrates this approach.\n\nIn the Python example code, we first import the NumPy library as np, which provides support for mathematical operations on arrays and matrices.\n• We then define a function named factorial_numpy(), which calculates the factorial of a given number n using NumPy.\n• Inside the function, we create an array named numbers containing integers from 1 to n using the arrange() function, i.e., np.arange(1, n + 1).\n• Next, we use the np.prod() function from NumPy to calculate the product of all elements in the numbers array, which effectively computes the factorial.\n• The result is stored in a variable named factorial, which the function then returns.\n• Lastly, we initialize a variable called number with the value 5 and calculate its factorial using the factorial_numpy() function.\n\nHere is a detailed complexity analysis of the different methods used to write a factorial program in Python programming language:\n\nFactorial of a number is the product of all preceding integers and the respective number itself. There are many ways to write a factorial program in Python, including iterative loops, recursive functions, and built-in functions like math.factorial() and numpy.prod(). Python provides flexibility to suit different needs. Factors such as input size, performance requirements, and code readability guide the selection of the most appropriate method. Despite the diversity of approaches, the factorial operation remains a foundational tool in mathematics and programming, supporting various algorithms and computations in Python applications.\n\nQ. What is a factorial, and why is it used?\n\nA factorial of a non-negative integer n is the product of all positive integers less than or equal to n. It is denoted by n!. Factorials are commonly used in mathematics and computer science for various purposes, such as combinatorial problems, probability calculations, and algorithmic solutions.\n\nQ. What are the limitations of using recursion to calculate factorials?\n\nRecursive methods for calculating factorials can be elegant and concise, but they may have limitations, particularly for large inputs. Recursive functions rely on the call stack, and deep recursion may lead to stack overflow errors, especially with large input values. As a result, iterative or built-in function-based approaches may be preferred when writing a factorial program in Python language in terms of efficiency and scalability.\n\nQ. In what scenarios should I use built-in functions like math.factorial() or libraries like NumPy for factorial calculations?\n\nInbuilt functions like math.factorial() and libraries like NumPy offer optimized implementations for factorial calculations, suitable for general-purpose numerical computing tasks. They are particularly useful when working with large numbers or performing computations on arrays or matrices containing factorial-related operations. These functions provide efficient, reliable, and well-tested solutions, making them suitable for a wide range of applications.\n\nQ. How can I handle large factorial results in Python?\n\nPython's integers are of arbitrary precision, meaning they can grow as large as the memory allows. However, when working with extremely large numbers, performance and memory usage can become concerns. You can use libraries like math module or NumPy, which are optimized for large-number computations. Additionally, you can consider using the gmpy2 library for specialised applications, which provides enhanced performance for large integer arithmetic.\n\nQ. Are there any optimizations for computing factorials efficiently?\n\nYes, there are optimizations that can improve the efficiency of calculations in a factorial program in Python. For example, memoization in recursive functions can reduce redundant computations by caching previously calculated results. Additionally, leveraging mathematical properties of factorials, such as prime factorization, can lead to more efficient algorithms for computing factorials, especially for large inputs like when writing a factorial program in Python.\n\nYou might also be interested in reading the following:\n• Convert Int To String In Python | Learn 6 Methods With Examples\n• How To Reverse A String In Python? 10 Easy Ways With Examples"
    }
]