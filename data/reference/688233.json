[
    {
        "link": "https://docs.python.org/3/library/os.html",
        "document": "This module provides a portable way of using operating system dependent functionality. If you just want to read or write a file see , if you want to manipulate paths, see the module, and if you want to read all the lines in all the files on the command line see the module. For creating temporary files and directories see the module, and for high-level file and directory handling see the module.\n\nNotes on the availability of these functions:\n• None The design of all built-in operating system dependent modules of Python is such that as long as the same functionality is available, it uses the same interface; for example, the function returns stat information about path in the same format (which happens to have originated with the POSIX interface).\n• None Extensions peculiar to a particular operating system are also available through the module, but using them is of course a threat to portability.\n• None All functions accepting path or file names accept both bytes and string objects, and result in an object of the same type, if a path or file name is returned.\n• None On VxWorks, os.popen, os.fork, os.execv and os.spawn*p* are not supported.\n• None On WebAssembly platforms, Android and iOS, large parts of the module are not available or behave differently. APIs related to processes (e.g. , ) and resources (e.g. ) are not available. Others like and are emulated or stubs. WebAssembly platforms also lack support for signals (e.g. , )."
    },
    {
        "link": "https://geeksforgeeks.org/python-os-listdir-method",
        "document": "The os.listdir() method in Python is used to get the list of all files and directories in the specified directory. If we don’t specify any directory, then a list of files and directories in the current working directory will be returned.\n\nBelow are some examples of Python os.listdir() method of the OS module:\n\nIn this example, the code uses os.listdir() to obtain a list of files and directories in the root directory (“/”). It then prints the obtained list. The output includes the files and directories present in the specified root Directory.\n\nIn this example, the code utilizes os.listdir() method to obtain a list of files and directories in the current working directory os.getcwd() method. It then prints the obtained list, providing information about the files and directories present in the current working directory.\n\nList All Files and Directories When No Path is Specified\n\nIn this example, the code uses os.listdir() to obtain a list of files and directories in the current working directory. It then prints the obtained list, providing information about the files and directories present in the current working directory. If no path is specified, it defaults to the current working directory.\n\nWhat do you understand by os.listdir() Method?"
    },
    {
        "link": "https://docs.python.org/3/library/filesys.html",
        "document": "The modules described in this chapter deal with disk files and directories. For example, there are modules for reading the properties of files, manipulating paths in a portable way, and creating temporary files. The full list of modules in this chapter is:\n\nOperating system interfaces, including functions to work with files at a lower level than Python file objects. Python’s built-in I/O library, including both abstract classes and some concrete classes such as file I/O. The standard way to open files for reading and writing with Python."
    },
    {
        "link": "https://geeksforgeeks.org/os-module-python-examples",
        "document": "The OS module in Python provides functions for interacting with the operating system. OS comes under Python’s standard utility modules. This module provides a portable way of using operating system-dependent functionality.\n\nThe *os* and *os.path* modules include many functions to interact with the file system.\n\nHere we will discuss some important functions of the Python os module :\n• None Listing out Files and Directories with Python\n\nConsider Current Working Directory(CWD) as a folder, where Python is operating. Whenever the files are called only by their name, Python assumes that it starts in the CWD which means that name-only reference will be successful only if the file is in the Python’s CWD.\n\nTo get the location of the current working directory os.getcwd() is used.\n\nExample: This code uses the ‘ module to get and print the current working directory (CWD) of the Python script. It retrieves the CWD using the ‘ and then prints it to the console.\n\nTo change the current working directory(CWD) os.chdir() method is used. This method changes the CWD to a specified path. It only takes a single argument as a new directory path.\n\nExample: The code checks and displays the current working directory (CWD) twice: before and after changing the directory up one level using . It provides a simple example of how to work with the current working directory in Python.\n\nThere are different methods available in the OS module for creating a directory. These are –\n\nBy using os.mkdir() method in Python is used to create a directory named path with the specified numeric mode. This method raises FileExistsError if the directory to be created already exists.\n\nExample: This code creates two directories: “GeeksforGeeks” within the “D:/Pycharm projects/” directory and “Geeks” within the “D:/Pycharm projects” directory.\n• None The first directory is created using the method without specifying the mode.\n• None The second directory is created using the same method, but a specific mode ( ) is provided, which grants read and write permissions.\n• None The code then prints messages to indicate that the directories have been created.\n\nos.makedirs() method in Python is used to create a directory recursively. That means while making leaf directory if any intermediate-level directory is missing, os.makedirs() method will create them all.\n\nExample: This code creates two directories, “Nikhil” and “c”, within different parent directories. It uses the function to ensure that parent directories are created if they don’t exist.\n\nIt also sets the permissions for the “c” directory. The code prints messages to confirm the creation of these directories\n\nListing out Files and Directories with Python\n\nThere is os.listdir() method in Python is used to get the list of all files and directories in the specified directory. If we don’t specify any directory, then the list of files and directories in the current working directory will be returned.\n\nExample: This code lists all the files and directories in the root directory (“/”). It uses the function to get the list of files and directories in the specified path and then prints the results.\n\nOS module provides different methods for removing directories and files in Python. These are –\n\nos.remove() method in Python is used to remove or delete a file path. This method can not remove or delete a directory. If the specified path is a directory then OSError will be raised by the method.\n\nExample: Suppose the file contained in the folder are:\n\n\n\nThis code removes a file named “file1.txt” from the specified location “D:/Pycharm projects/GeeksforGeeks/Authors/Nikhil/”. It uses the function to delete the file at the specified path.\n\nos.rmdir() method in Python is used to remove or delete an empty directory. OSError will be raised if the specified path is not an empty directory.\n\nExample: Suppose the directories are\n\nThis code attempts to remove a directory named “Geeks” located at “D:/Pycharm projects/”.\n\nIt uses the function to delete the directory. If the directory is empty, it will be removed. If it contains files or subdirectories, you may encounter an error.\n\nThis function gives the name of the operating system dependent module imported. The following names have currently been registered: ‘posix’, ‘nt’, ‘os2’, ‘ce’, ‘java’ and ‘riscos’.\n\nNote: It may give different output on different interpreters, such as ‘posix’ when you run the code here.\n\nAll functions in this module raise OSError in the case of invalid or inaccessible file names and paths, or other arguments that have the correct type, but are not accepted by the operating system. os.error is an alias for built-in OSError exception.\n\nThis code reads the contents of a file named ‘GFG.txt’. It uses a ‘try…except‘ block to handle potential errors, particularly the ‘IOError‘ that may occur if there’s a problem reading the file.\n\nIf an error occurs, it will print a message saying, “Problem reading: GFG.txt.”\n\nThis method opens a pipe to or from command. The return value can be read or written depending on whether the mode is ‘r’ or ‘w’. \n\nSyntax:\n\nParameters mode & bufsize are not necessary parameters, if not provided, default ‘r’ is taken for mode.\n\nThis code opens a file named ‘GFG.txt’ in write mode, writes “Hello” to it, and then reads and prints its contents. The use of is not recommended, and standard file operations are used for these tasks.\n\nNote: Output for popen() will not be shown, there would be direct changes into the file.\n\nClose file descriptor fd. A file opened using open(), can be closed by close()only. But file opened through os.popen(), can be closed with close() or os.close(). If we try closing a file opened with open(), using os.close(), Python would throw TypeError.\n\nNote: The same error may not be thrown, due to the non-existent file or permission privilege.\n\nA file old.txt can be renamed to new.txt, using the function os.rename(). The name of the file changes only if, the file exists and the user has sufficient privilege permission to change the file.\n\nA file name “GFG.txt” exists, thus when os.rename() is used the first time, the file gets renamed.\n\nUpon calling the function os.rename() second time, file “New.txt” exists and not “GFG.txt” thus Python throws FileNotFoundError.\n\nUsing the Os module we can remove a file in our system using the os.remove() method. To remove a file we need to pass the name of the file as a parameter.\n\nThe OS module provides us a layer of abstraction between us and the operating system.\n\nWhen we are working with os module always specify the absolute path depending upon the operating system the code can run on any os but we need to change the path exactly. If you try to remove a file that does not exist you will get FileNotFoundError.\n\nThis method will check whether a file exists or not by passing the name of the file as a parameter. OS module has a sub-module named PATH by using which we can perform many more functions.\n\nAs in the above code, the file does not exist it will give output False. If the file exists it will give us output True.\n\nIn os.path.getsize() function, python will give us the size of the file in bytes. To use this method we need to pass the name of the file as a parameter.\n\nWhat is the OS module in Python?\n\nWhat is an OS package?\n\nWhat is OS name in Python?\n\nWhat is the OS process in Python?"
    },
    {
        "link": "https://canardanalytics.com/blog/file-and-folder-operations-os-module",
        "document": "Python's module provides a set of functions to allow you to interact with your operating system. The module is a part of Python's standard utility modules which means that it is bundled with any clean Python install. It is most commonly used to interact with your file system; specifying paths, creating and deleting folders, or renaming files. Part of the power of the module is that for many of its common uses it is operating system independent. This means that you can develop on a Windows PC and deploy to a Linux machine without having to rewrite the sections of code dealing with filepaths (Windows and Linux specify paths differently).\n\nThis tutorial will walk through some of the more often used functionality that the module offers. Let's get started.\n\nIn order to use the module you'll first need to import it. This should be placed along with the rest of your imports at the start of your script.\n\nThe concept of a current working directory (cwd) in the context of running a python programme is one that tends to confuse many developers who are starting out. It is not a difficult concept to master but in order to understand the working directory you must first be comfortable with the concept of files and directories (folders).\n\nA directory is simply a file, whose contents are a collection of other files. This structures provides a way to organise files and folders in order to create an orderly and logical structure. As the name implies, the current working directory is simply the directory in which the files that you are currently working with are sitting. You can think of the File Explorer window as a current working directory.\n\nPerhaps an even better way to visualise the cwd is to think of a terminal prompt.\n\nAs you navigate through the file system you are changing the current working directory. If you want to access files within the current working directory you do not need to include the entire path from the root but rather just the name of the file within the current working directory.\n\nThis works the same with when using the module. Every process has a current directory which it inherits from it's parent process. This doesn't have to be the directory in which the program you are running is located.\n\nIn Python the current working directory is returned as a string using the function. You can then change the current working directory with .\n\nNow we change the current working directory using the method:\n\nAll files and folders within the current working directory can be easily accessed by simply referring to their name rather than the absolute or root path to the file or directory.\n\nIn our example the current working directory has two files.\n\nThe module is a very powerful way to work with and manipulate paths within your Python application. One of the many reasons to use the module is the fact that it is operating system independent and so will work whether you are working in a Windows environment or a Linux environment.\n\nThe function takes two or more string paths and intelligently joins them to form a single filepath that is valid on all operating systems.\n\nIn the next example let's create a path that will join a folder located in the current working directory to a file within the folder.\n\nWhen you look at the result you should notice that the file path is given relative to the current working directory.\n\nIf you want the full path to the file then you can use .\n\nCheck Whether the Path Exists using os.path.exists\n\nUse to check whether the specified path exists or not. The result is a boolean, either or .\n\nSince the folder does not yet exist we can use the module to create it.\n\nIf the folder/directory does not exist then you can create it using .\n\nThe file extension can be extracted from a filepath with the function. The output is a tuple such that . The extension will either be empty or begin with a single period and contain at most one period."
    },
    {
        "link": "https://pillow.readthedocs.io/en/stable/reference/Image.html",
        "document": "The module provides a class with the same name which is used to represent a PIL image. The module also provides a number of factory functions, including functions to load images from files, and to create new images.\n\nInstances of the class have the following attributes: The filename or path of the source file. Only images created with the factory function have a filename attribute. If the input is a file like object, the filename attribute is set to an empty string. The file format of the source file. For images created by the library itself (via a factory function, or by running a method on an existing image), this attribute is set to . Image mode. This is a string specifying the pixel format used by the image. Typical values are “1”, “L”, “RGB”, or “CMYK.” See Modes for a full list. Image size, in pixels. The size is given as a 2-tuple (width, height). Colour palette table, if any. If mode is “P” or “PA”, this should be an instance of the class. Otherwise, it should be set to . A dictionary holding data associated with the image. This dictionary is used by file handlers to pass on various non-image information read from the file. See documentation for the various file handlers for details. Most methods ignore the dictionary when returning new images; since the keys are not standardized, it’s not possible for a method to know if the operation affects the dictionary. If you need the information later on, keep a reference to the info dictionary returned from the open method. Unless noted elsewhere, this dictionary does not affect saving files. if this image has more than one frame, or otherwise. This attribute is only defined by image plugins that support animated images. Plugins may leave this attribute undefined if they don’t support loading animated images, even if the given format supports animated images. Given that this attribute is not present for all images use to check if Pillow is aware of multiple frames in an image regardless of its format. The number of frames in this image. This attribute is only defined by image plugins that support animated images. Plugins may leave this attribute undefined if they don’t support loading animated images, even if the given format supports animated images. Given that this attribute is not present for all images use to check the number of frames that Pillow is aware of in an image regardless of its format. Determine if an image has transparency data, whether in the form of an alpha channel, a palette with an alpha channel, or a “transparency” key in the info dictionary. Note the image might still appear solid, if all of the values shown within are opaque."
    },
    {
        "link": "https://pillow.readthedocs.io/en/stable/handbook/overview.html",
        "document": "The Python Imaging Library adds image processing capabilities to your Python interpreter.\n\nThis library provides extensive file format support, an efficient internal representation, and fairly powerful image processing capabilities.\n\nThe core image library is designed for fast access to data stored in a few basic pixel formats. It should provide a solid foundation for a general image processing tool.\n\nLet’s look at a few possible uses of this library.\n\nThe Python Imaging Library is ideal for image archival and batch processing applications. You can use the library to create thumbnails, convert between file formats, print images, etc. The current version identifies and reads a large number of formats. Write support is intentionally restricted to the most commonly used interchange and presentation formats.\n\nThe current release includes Tk and interfaces, as well as a that can be used with PythonWin and other Windows-based toolkits. Many other GUI toolkits come with some kind of PIL support. For debugging, there’s also a method which saves an image to disk, and calls an external display utility.\n\nThe library contains basic image processing functionality, including point operations, filtering with a set of built-in convolution kernels, and colour space conversions. The library also supports image resizing, rotation and arbitrary affine transforms. There’s a histogram method allowing you to pull some statistics out of an image. This can be used for automatic contrast enhancement, and for global statistical analysis."
    },
    {
        "link": "https://geeksforgeeks.org/python-pil-image-thumbnail-method",
        "document": "PIL is the Python Imaging Library which provides the python interpreter with image editing capabilities. The module provides a class with the same name which is used to represent a PIL image. The module also provides a number of factory functions, including functions to load images from files, and to create new images.\n\nMake this image into a thumbnail. This method modifies the image to contain a thumbnail version of itself, no larger than the given size. This method calculates an appropriate thumbnail size to preserve the aspect of the image, calls the method to configure the file reader (where applicable), and finally resizes the image.\n\nNote that this function modifies the Image object in place. If you need to use the full resolution image as well, apply this method to a of the original image.\n\nAnother Example:Here used another image."
    },
    {
        "link": "https://realpython.com/image-processing-with-the-python-pillow-library",
        "document": "Python Pillow allows you to manipulate images and perform basic image processing tasks. As a fork of the Python Imaging Library (PIL), Pillow supports image formats like JPEG, PNG, and more, enabling you to read, edit, and save images. With Python Pillow, you can crop, resize, rotate, and apply filters to images, making it a versatile tool for image manipulation.\n\nPillow is often used for high-level image processing tasks and exploratory work. While not the fastest library, it offers a gentle learning curve and a comprehensive set of features for basic to intermediate image processing needs. You can enhance its capabilities by integrating it with NumPy for pixel-level manipulations and creating animations.\n\nBy the end of this tutorial, you’ll understand that:\n• Python Pillow is used for image manipulation and basic image processing.\n• Pillow offers reasonable speed for its intended use cases.\n• PIL is the original library, while Pillow is its actively maintained fork.\n• You read an image in Python Pillow using from the PIL module.\n• Pillow is used for its ease of use, versatility, and integration with NumPy.\n\nWith these insights, you’re ready to dive into the world of image processing with Python Pillow. You’ll use several images in this tutorial, which you can download from the tutorial’s image repository:\n\nWith these images in hand, you’re now ready to get started with Pillow.\n\nThe Python Pillow library is a fork of an older library called PIL. PIL stands for Python Imaging Library, and it’s the original library that enabled Python to deal with images. PIL was discontinued in 2011 and only supports Python 2. To use its developers’ own description, Pillow is the friendly PIL fork that kept the library alive and includes support for Python 3. There’s more than one module in Python to deal with images and perform image processing. If you want to deal with images directly by manipulating their pixels, then you can use NumPy and SciPy. Other popular libraries for image processing are OpenCV, scikit-image, and Mahotas. Some of these libraries are faster and more powerful than Pillow. However, Pillow remains an important tool for dealing with images. It provides image processing features that are similar to ones found in image processing software such as Photoshop. Pillow is often the preferred option for high-level image processing tasks that don’t require more advanced image processing expertise. It’s also often used for exploratory work when dealing with images. Pillow also has the advantage of being widely used by the Python community, and it doesn’t have the same steep learning curve as some of the other image processing libraries. You’ll need to install the library before you can use it. You can install Pillow using within a virtual environment: Now that you’ve installed the package, you’re ready to start familiarizing yourself with the Python Pillow library and perform basic manipulations of images. The Module and Class in Pillow The main class defined in Pillow is the class. When you read an image using Pillow, the image is stored in an object of type . For the code in this section, you’ll need the image file named (image credit), which you can find in the image repository for this tutorial: Get Images: Click here to get access to the images that you’ll manipulate and process with Pillow. You can place this image file in the project folder that you’re working in. When exploring images with Pillow, it’s best to use an interactive REPL environment. You’ll start by opening the image that you just downloaded: You might expect to import from Pillow instead of from PIL. You did install , after all, not . However, Pillow is a fork of the PIL library. Therefore, you’ll still need to use when importing into your code. You call the function to read the image from the file and to read the image into memory so that the file can now be closed. You use a statement to create a context manager to ensure the file is closed as soon as it’s no longer needed. In this example, the object is a JPEG image-specific type that’s a subclass of the class, as you confirm with the call to . Note that both the class and the module where the class is defined share the same name, . You can display the image using : The method saves the image as a temporary file and displays it using your operating system’s native software for dealing with images. When you run the code above, you’ll see the following image displayed: On some systems, calling will block the REPL until you close the image. This depends on the operating system and the default image viewing software that you’re using. You’ll need to be familiar with three key properties when dealing with images in the Python Pillow library. You can explore these using the class attributes , , and : The format of an image shows what type of image you’re dealing with. In this case, the format of the image is . The size shows the width and height of the image in pixels. The mode of this image is . You’ll learn more about modes shortly. Often, you may need to crop and resize images. The class has two methods that you can use to perform these operations, and : The argument to must be a 4-tuple that defines the left, upper, right, and bottom edges of the region that you wish to crop. The coordinate system used in Pillow assigns the coordinates (0, 0) to the pixel in the upper-left corner. This is the same coordinate system that’s usually used for two-dimensional arrays. The 4-tuple represents the following section of the image: The new image that returns in the code above has a size of pixels. The cropped image shows only one of the buildings from the original picture: In the code above, you also change the resolution of the cropped image using , which needs a tuple as a required argument. The tuple that you use as an argument defines the new width and height of the image in pixels. In the example above, you’re setting the new width and height to a quarter of their original values using the floor division operator ( ) and the attributes and . The final call to displays the cropped and resized image: There are additional optional parameters that you can use with to control how the image is resampled. Alternatively, you can achieve similar scaling using : The argument determines the factor by which you scale the image down. If you prefer to set a maximum size rather than a scaling factor, then you can use . The size of the thumbnail will be smaller than or equal to the size that you set. Note: The method changes the object in place and doesn’t return a new object. However, , , and all return a new object. Not all methods in the Pillow library behave in the same way. Once you’re happy with your returned image, you can save any of the objects to file using : Once you call the method, it creates the image files in your project folder. In this example, one of the images is a JPEG image and the other is a PNG image. The extension that you use as a filname automatically determines the file format, or you can specify the format as an additional optional argument. You can manipulate the image beyond cropping and resizing. Another common requirement is to rotate or flip the image. You can use the method for some transformations. Go ahead and carry on with the same REPL session that you started in the previous section: This code displays the following image: There are seven options that you can pass as arguments to :\n• : Flips the image left to right, resulting in a mirror image\n• : Rotates the image by 270 degrees counterclockwise, which is the same as 90 degrees clockwise\n• : Transposes the rows and columns using the top-left pixel as the origin, with the top-left pixel being the same in the transposed image as in the original image\n• : Transposes the rows and columns using the bottom-left pixel as the origin, with the bottom-left pixel being the one that remains fixed between the original and modified versions All the rotation options above define rotations in steps of 90 degrees. If you need to rotate an image by another angle, then you can use : This method call rotates the image by 45 degrees counterclockwise, giving the following image: The object returned is the same size as the original . Therefore, the corners of the image are missing in this display. You can change this behavior using the named parameter: This method returns a larger image that fully contains the rotated image: You can customize the rotation further with additional optional parameters. You can now change the size and orientation of an image. In the next section, you’ll learn about different types of images in the Python Pillow library. Bands and Modes of an Image in the Python Pillow Library An image is a two-dimensional array of pixels, where each pixel corresponds to a color. Each pixel can be represented by one or more values. For example, in an RGB image, each pixel is represented by three values corresponding to the red, green, and blue values for that pixel. Therefore, the object for an RBG image contains three bands, one for each color. An RGB image of size pixels is represented by a array of values. RGBA images also include the alpha value, which contains information about the transparency for each pixel. An RGBA image has four bands, one for each of the colors and a fourth one containing the alpha values. Each band has the same dimensions as the image dimensions. Therefore, an RGBA image of size pixels is represented by a array of values. The mode of an image describes what type of image you’re working with. Pillow supports most standard modes, including black-and-white (binary), grayscale, RGB, RGBA, and CMYK. You can see the full list of supported modes in the Pillow documentation on modes. You can find out how many bands are in an object using the method, and you can convert between modes using . Now you’ll use the image named (image credit) from the image repository for this tutorial: This image’s mode is also RGB. You can convert this image into other modes. This code uses the same REPL session that you started in the previous sections: You call twice to convert the RGB image into a CMYK and a grayscale version. The CMYK image looks similar to the original image but is encoded using the mode that’s common for printed material rather than digital displays. The conversion to grayscale gives the following output: The outputs from the calls to confirm that there are three bands in the RGB image, four bands in the CMYK image, and one band in the grayscale image. You can separate an image into its bands using and combine separate bands back into an object using . When you use , the method returns all the bands as separate objects. You can confirm this by displaying the string representation of one of the objects returned: The mode of the object that returns is , indicating this is a grayscale image, or an image that only displays the luminance values of each pixel. Now, you can create three new RGB images showing the red, green, and blue channels separately using , which is a function in the module: The first argument in determines the mode of the image that you want to create. The second argument contains the individual bands that you want to merge into a single image. The red band alone, stored in the variable , is a grayscale image with mode L. To create the image showing only the red channel, you merge the red band from the original image with green and blue bands that only contain zeros. To create a band containing zeros everywhere, you use the method. This method needs a function as an argument. The function that you use determines how each point transforms. In this case, you use a function to map each point to . When you merge the red band with green and blue bands containing zeros, you get an RGB image called . Therefore, the RGB image that you create only has non-zero values in the red channel, but because it’s still an RGB image, it’ll display in color. You also repeat a similar process to obtain and , which contain RGB images with the green and blue channels from the original image. The code displays the following three images: The red image contains a strong signal in the pixels that represent the strawberry, because these pixels are mostly red. The green and blue channels show these pixels as dark because they have small values. The exceptions are those pixels that represent the reflection of the light on the surface of the strawberry as these pixels are nearly white. Creating the side-by-side displays shown in this tutorialShow/Hide In this tutorial, when there are several images output in the code that need to be displayed next to one another to make comparisons easier, the images are displayed side by side rather than as separate images. These side-by-side displays were created using Pillow itself. You can use the function , shown below, to merge several images into a single display: The first parameter in uses the unpacking operator ( ) so that any number of objects of type can be used as input arguments. The keyword parameter can be set to if you want to tile the images vertically rather than horizontally. This function assumes that all images have the same size. The overall size of the display is calculated from the size of the images and the number of images used. You then create a new object with the same mode as the original images and with the size of the overal display. The loop pastes the images that you input when you call the function into the final display. The function returns the final object containing all the images side by side. The image in the main article showing the three color channels for the strawberry image was obtained by calling the function as follows: This function was used to generate all the displays that show more than one image in this tutorial.\n\nYou’ve learned how to crop and rotate images, resize them, and extract color bands from color images. However, none of the actions that you’ve taken so far have made any changes to the content of the image. In this section, you’ll learn about image processing features in the Python Pillow library. You’ll use the module in Pillow. One of the methods that’s used in image processing is image convolution using kernels. The aim of this tutorial is not to give a detailed explanation of image processing theory. If you’re interested in the science of image processing, one of the best resources that you can use is Digital Image Processing by Gonzalez and Woods. In this section, you’ll learn the basics of how you can use convolution kernels to perform image processing. But what’s a convolution kernel? A kernel is a matrix: You can consider a simple image to understand the process of convolution using kernels. The image has a size of pixels and contains a vertical line and a dot. The line is four pixels wide, and the dot consists of a pixel square. The image below is enlarged for display purposes: You can place the kernel anywhere on the image and use the location of the kernel’s central cell as a reference. The diagram below is a representation of the top-left portion of the image: The elements in this diagram represent different aspects of the image and the kernel:\n• The white squares represent pixels in the image that have a value of .\n• The red squares represent pixels in the image that have a value of . These make up the dot in the image shown above.\n• Each purple region represents the kernel. This kernel consists of a region, and each cell in the kernel has a value of . The diagram shows the kernel in three different positions labeled 1, 2, and 3. A new image can be created as a result of the convolution of the image with the kernel. You can understand the convolution process through the following steps:\n• Locate kernel: Consider one of the kernel locations and look at the image pixels covered by the kernel’s nine cells.\n• Multiply kernel and pixel values: Multiply the values in each of the kernel’s cells with the corresponding pixel values in the image. You’ll have nine values from the nine multiplications.\n• Sum results of multiplications: Add those nine values together. The result will be the value of the pixel in the new image that has the same coordinates as the kernel’s center pixel.\n• Repeat for all pixels: Repeat the process for every pixel in the image, moving the kernel each time so that the kernel’s central cell corresponds to a different image pixel each time. You can see this process with the three kernel positions labeled 1, 2, and 3 in diagram above. Consider the kernel position labeled 1. The position of this kernel is , which is the position of its central cell because it’s in the fourth row (index = ) and the third column (index = ). Each image pixel in the region covered by the kernel has a value of zero. Therefore, all the multiplications from step 2 will be zero, and their addition will also be zero. The new image will have a value of zero at pixel . The scenario is different for the other kernel positions shown. Next, consider the kernel labeled 2, located at . One of the image pixels overlapping this is not zero. The multiplication of this pixel value with the kernel value will give . The eight remaining multiplications are still zero because the image pixels are zero. Therefore, the value of the pixel at position in the new image will be . The third kernel position illustrated above is at . There are four non-zero image pixels overlapping with this kernel. Each one has a value of , so the multiplication result will again be for each of those pixel positions. The overall result for this kernel position is . The new image will have this value at . The diagram and the discussion above only consider three kernel positions. The convolution process repeats this process for every possible kernel position in the image. This gives a value for each pixel position in the new image. The result of the convolution is shown on the right in the following image, with the original image on the left: The kernel that you used is a box blur kernel. The factor of is there so that the overall weighting of the kernel is . The result of the convolution is a blurred version of the original image. There are other kernels that perform different functions, including different blurring methods, edge detection, sharpening, and more. The Python Pillow library has several built-in kernels and functions that’ll perform the convolution described above. You don’t need to understand the math of filtering through convolution to use these filters, but it always helps to know what’s happening behind the scenes when using these tools. The next sections will look at the kernels and image filtering capabilities available in the module in Pillow. You’ll return to using the image of the buildings that you used at the beginning of this tutorial. You can start a new REPL session for this section: In addition to , you also import the module from Pillow. You can use the method to apply filtering to the image. This method needs a convolution kernel as its argument, and you can use one of the several kernels available in the module in Pillow. The first set of filters that you’ll learn about deal with blurring, sharpening, and smoothing an image. You can blur the image using the predefined filter: The displayed image is a blurred version of the original one. You can zoom in to observe the difference in more detail using and then display the images again using : The two cropped images show the difference between the two versions: You can customize the type and amount of blurring that you need using or : You can see the three blurred images below, shown in the same order as in the code above: The filter is similar to the one described in the previous section introducing convolution kernels. The argument is the radius of the box blur filter. In the earlier section discussing kernels, the box blur filter that you used was a filter. This means that it had a radius of , because the filter extends by one pixel from the center. The blurred images show that the box blur filter with a radius of produces an image that’s more blurred than the image generated by the box blur filter with radius . You can also use the filter, which uses a Gaussian blur kernel. The Gaussian kernel puts more weight on the pixels at the center of the kernel than those at the edges, and this leads to smoother blurring than what’s obtained with the box blur. For this reason, Gaussian blurring can give better results in many cases. What if you want to sharpen an image? In that case, you can use the filter and compare the result with the original image: You’re comparing a cropped version of both images showing a small portion of the building. The sharpened image is on the right: Perhaps instead of sharpening an image, you need to smooth it. You can achieve this by passing as an argument for : Below, you can see the original image on the left and the smoothed image on the right: You’ll see an application of the smooth filter in the next section, in which you’ll learn about more filters in the module. These filters act on the edges of objects in the image. When you look at an image, it’s relatively easy to determine the edges of objects within that image. It’s also possible for an algorithm to detect edges automatically using edge detection kernels. The module in Pillow has a predefined kernel to achieve this. In this section, you’ll use the image of the buildings again and convert it to grayscale before you apply the edge detection filter. You can carry on with the REPL session from the previous section: The result is an image showing the edges from the original image: This filter identifies the edges in the image. You can obtain a better outcome by applying the filter before finding the edges: You can see a comparison of the original grayscale image and the two edge detection results below. The version with smoothing before edge detection is shown at the bottom: You can also enhance the edges of the original image with the filter: You used the smoothed version of the grayscale image to enhance the edges. A portion of the original grayscale image and the image with the edges enhanced are shown side by side below. The image with edge enhancement is on the right: Another predefined filter in that deals with object edges is . You can pass it as an argument to as you did with the other filters in this section: You’re using the smoothed, grayscale version as a starting point for this filter. You can see the embossed image below, which shows a different effect using the edges in the image: In this section, you’ve learned about several filters available in the module that you can apply to images. There are other filters that you can use to process images. You can see a list of all the filters available in the documentation.\n\nImage Segmentation and Superimposition: An Example In this section, you’ll use the image files named (image credit) and (image credit), which you can find in the image repository for this tutorial: Get Images: Click here to get access to the images that you’ll manipulate and process with Pillow. You can use the Python Pillow library to extract the cat from the first image and place it on the floor of the monastery courtyard. You’ll use a number of image processing techniques to achieve this. You’ll start by working on . You’ll need to remove the picture of the cat from the background using image segmentation techniques. In this example, you’ll segment the image using thresholding techniques. First, you can crop the image to a smaller one to remove some of the background. You can start a new REPL session for this project: The cropped image contains the cat and some of the background that’s too close to the cat for you to crop it: Each pixel in a color image is represented digitally by three numbers corresponding to the red, green, and blue values of that pixel. Thresholding is the process of converting all the pixels to either the maximum or minimum value depending on whether they’re higher or lower than a certain number. It’s easier to do this on a grayscale image: You achieve thresholding by calling to convert each pixel in the grayscale image into either or . The conversion depends on whether the value in the grayscale image is greater or smaller than the threshold value. The threshold value in this example is . The figure below shows the grayscale image and the result from the thresholding process: In this example, all the points in the grayscale image that had a pixel value greater than are converted to white, and all other pixels are changed to black. You can change the sensitivity of the thresholding process by varying the threshold value. Thresholding can be used to segment images when the object to segment is distinct from the background. You can achieve better results with versions of the original image that have higher contrast. In this example, you can achieve higher contrast by thresholding the blue channel of the original image rather than the grayscale image, because the dominant colors in the background are brown and green colors, which have a weak blue component. You can extract the red, green, and blue channels from the color image as you did earlier: The red, green, and blue channels are shown below, from left to right. All three are displayed as grayscale images: The blue channel has a higher contrast between the pixels representing the cat and those representing the background. You can use the blue channel image to threshold: You use a threshold value of in this example. You also convert the image into a binary mode using as an argument to . The pixels in a binary image can only have the values of or . Note: When dealing with certain image formats, such as JPEG, that rely on lossy compression, the images may vary slightly depending on which JPEG decoders you’re using. Different operating systems often come with different default JPEG decoders. Therefore, the results that you get when processing images may vary depending on the operating system and JPEG decoder that you’re using. You may need to slightly adjust the threshold value if your results do not match the ones shown in this tutorial. The result of thresholding is the following: You can identify the cat in this black-and-white image. However, you’d like to have an image in which all the pixels that correspond to the cat are white and all other pixels are black. In this image, you still have black regions in the area which corresponds to the cat, such as where the eyes, nose and mouth are, and you also still have white pixels elsewhere in the image. You can use the image processing techniques called erosion and dilation to create a better mask that represents the cat. You’ll learn about these two techniques in the next section. You can look at the image file called , which you can download from the repository linked to this tutorial: The left-hand side of this binary image shows a white dot on a black background, while the right-hand side shows a black hole in a solid white section. Erosion is the process of removing white pixels from the boundaries in an image. You can achieve this in a binary image by using as an argument for the method. This filter replaces the value of a pixel with the minimum value of the nine pixels in the array centered around the pixel. In a binary image, this means that a pixel will have the value of zero if any of its neighboring pixels are zero. You can see the effect of erosion by applying several times to the image. You should continue with the same REPL session as in the previous section: You’ve applied the filter three times using a loop. This code gives the following output: The dot has shrunk but the hole has grown as a result of erosion. Dilation is the opposite process to erosion. White pixels are added to the boundaries in a binary image. You can achieve dilation by using , which converts a pixel to white if any of its neighbors are white. You can apply dilation to the same image containing a dot and a hole, which you can open and load again: The dot has now grown bigger, and the hole has shrunk: You can use erosion and dilation together to fill in holes and remove small objects from a binary image. Using the image with a dot and hole, you can perform ten erosion cycles to remove the dot, followed by ten dilation cycles to restore the hole to its original size: You perform ten erosion cycles with the first loop. The image at this stage is the following: The dot has disappeared, and the hole is larger than it was in the original image. The second loop performs ten dilation cycles, which return the hole to its original size: However, the dot is no longer present in the image. The erosions and dilations have modified the image to keep the hole but remove the dot. The number of erosions and dilations needed depends on the image and what you want to achieve. Often, you’ll need to find the right combination through trial and error. You can define functions to perform several cycles of erosion and dilation: These functions make it easier to experiment with erosion and dilation for an image. You’ll use these functions in the next section as you continue working on placing the cat into the monastery. You can use a sequence of erosions and dilations on the threshold image that you obtained earlier to remove parts of the mask that don’t represent the cat and to fill in any gaps in the region containing the cat. Once you’ve experimented with erosion and dilation, you’ll be able to use educated guesses in a trial-and-error process to find the best combination of erosions and dilations to achieve the ideal mask. Starting with the image , which you obtained earlier, you can start with a series of erosions to remove the white pixels that represent the background in the original image. You should continue working in the same REPL session as in the previous sections: The eroded threshold image no longer contains white pixels representing the background of the image: However, the remaining mask is smaller than the overall outline of the cat and has holes and gaps within it. You can perform dilations to fill the gaps: The fifty-eight cycles of dilation filled all the holes in the mask to give the following image: However, this mask is too big. You can therefore finish the process with a series of erosions: The result is a mask that you can use to segment the image of the cat: You can avoid the sharp edges of a binary mask by blurring this mask. You’ll have to convert it from a binary image into a grayscale image first: The filter returns the following mask: The mask now looks like a cat! Now you’re ready to extract the image of the cat from its background: First, you create a blank image with the same size as . You create a new object from by using and setting all values to zero. Next, you use the function in to create an image made up from both and using to determine which parts of each image are used. The composite image is shown below: You’ve segmented the image of the cat and extracted the cat from its background. You can go a step further and paste the segmented image of the cat into the image of the monastery courtyard from the image repository for this tutorial: You’ve used to paste an image onto another one. This method can be used with three arguments:\n• The first argument is the image that you want to paste in. You’re resizing the image to one-fifth of its size using the integer division operator ( ).\n• The second argument is the location in the main image where you want to paste the second picture. The tuple includes the coordinates within the main image where you want to place the top-left corner of the image that you’re pasting in.\n• The third argument provides the mask that you wish to use if you don’t want to paste the entire image. You’ve used the mask that you obtained from the process of thresholding, erosion, and dilation to paste the cat without its background. The output is the following image: You’ve segmented the cat from one image and placed it into another image to show the cat sitting quietly in the monastery courtyard rather than in the field where it was sitting in the original image. Your final task in this example is to add the Real Python logo as a watermark to the image. You can get the image file with the Real Python logo from the repository accompanying this tutorial: Get Images: Click here to get access to the images that you’ll manipulate and process with Pillow. You should continue working in the same REPL session: This is the full-size logo in color: You can change the image to grayscale and threshold it using to transform it into a black-and-white image. You also reduce its size and transform it into a contour image: The output shows the contour from the Real Python logo. The contour is ideal for using as a watermark on your image: To use this as a watermark, you’ll need to reverse the colors so that the background is black and only the outline that you want to keep is white. You can achieve this using again: You’ve converted the pixels that had a value of and assigned them the value , converting them from white to black pixels. You set the remaining pixels to white. The reversed outline logo is shown below: Your final step is to paste this outline onto the image of the cat sitting in the monastery courtyard. You can use again: The first argument in indicates the image that you wish to paste in, and the third argument represents the mask. In this case, you’re using the same image as a mask because the image is a binary image. The second argument provides the top-left coordinates of the region where you want to paste the image. The watermark has a rectangular outline, which is a result of the contour filter that you used earlier. If you prefer to remove this outline, you can crop the image using . This is an exercise that you can try on your own.\n\nPillow has an extensive selection of built-in functions and filters. However, there are times when you need to go further and manipulate images beyond the features that are already available in Pillow. You can manipulate the image further with the help of NumPy. NumPy is a very popular Python library for dealing with numeric arrays, and it’s an ideal tool to use with Pillow. You can learn more about NumPy in NumPy Tutorial: Your First Steps Into Data Science in Python. When you convert an image into a NumPy array, you can perform any transformations that you require directly on the pixels in the array. Once you’ve completed your processing in NumPy, you can convert the array back into an object using Pillow. You need to install NumPy for this section: Now that you’ve installed NumPy, you’re ready to use Pillow and NumPy to spot the difference between two images. Using NumPy to Subtract Images From Each Other See if you can spot the differences between the following two images: This isn’t a hard one! However, you decide to cheat and write a Python program to solve the puzzle for you. You can download the image files and (image credit) from the repository accompanying this tutorial: Get Images: Click here to get access to the images that you’ll manipulate and process with Pillow. Your first step is to read the images using Pillow and convert them to NumPy arrays: Since and are objects of type , you can manipulate them using all the tools that you have available in NumPy. You can subtract one array from the other to show the pixels that differ between the two images: When you subtract an array from another one of the same size, the result is another array with the same shape as the original arrays. You can convert this array into an image using in Pillow: The result of subtracting one NumPy array from another and converting into a Pillow is the difference image shown below: The difference image only shows three regions from the original image. These regions highlight the differences between the two images. You can also see some noise surrounding the cloud and the fence, which is due to small changes in the original JPEG compression in the region surrounding these items. You can go further and create images from scratch using NumPy and Pillow. You can start by creating a grayscale image. In this example, you’ll create a simple image containing a square, but you can create more elaborate images in the same way: You create an array of size containing zeros everywhere. Next, you set the value of a set of pixels at the center of the array to . You can index NumPy arrays using both rows and columns. In this example, the first slice, , represents the rows to . The second slice, , which follows the comma, represents the columns to . You can use to convert the NumPy array into an object of type . The output from the code above is shown below: You’ve created a grayscale image containing a square. The mode of the image is inferred automatically when you use . In this case, mode is used, which corresponds to an image with 32-bit floating-point pixels. You can convert this to a simpler grayscale image with 8-bit pixels if you wish: You can also go further and create a color image. You can repeat the process above to create three images, one corresponding to the red channel, another to the green, and a final one corresponding to the blue channel: You create an object from each NumPy array and convert the images to mode , which represents grayscale. Now, you can combine these three separate images into one RGB image using : The first argument in is the mode of the image output. The second argument is a sequence with the individual single-band images. This code creates the following image: You’ve combined the separate bands into an RGB color image. In the next section, you’ll go a step further and create a GIF animation using NumPy and Pillow. In the previous section, you created a color image containing three overlapping squares of different colors. In this section, you’ll create an animation showing those three squares merging into a single white square. You’ll create several versions of the images containing three squares, and the location of the squares will vary slightly between successive images: You create an empty list called , which you’ll use to store the various images that you generate. Within the loop, you create NumPy arrays for the red, green, and blue channels, as you did in the previous section. The array containing the green layer is always the same and represents a square in the center of the image. The red square starts in a position displaced to the top-left of the center. In each successive frame, the red square moves closer to the center until it reaches the center in the final iteration of the loop. The blue square is initially shifted toward the bottom-right then moves towards the center with each iteration. Note that in this example, you’re iterating over , which means that the variable increases in steps of two. You learned earlier that you can save an object to file using . You can use the same function to save to a GIF file that includes a sequence of images. You call on the first image in the sequence, which is the first image that you stored in the list : The first argument in is the filename for the file that you want to save. The extension in the filename tells what file format it needs to output. You also include two keyword arguments in :\n• ensures that all the images in the sequence are saved, and not just the first one.\n• allows you to append the remaining images in the sequence to the GIF file. This code saves to file, and you can then open the GIF file with any image software. The GIF should loop by default, but on some systems you’ll need to add the keyword argument to to make sure the GIF loops. The animation that you get is the following one: The three squares with different colors merge into a single white square. Can you create your own animation using different shapes and different colors?"
    },
    {
        "link": "https://tutorialspoint.com/python_pillow/python_pillow_creating_thumbnails.htm",
        "document": "Thumbnails are typically used for displaying image previews or smaller representations of the original image. They are useful for optimizing web pages and improving the loading speed of image-heavy applications. Pillow provides a convenient way to generate thumbnails from images. Here are some key points about thumbnails in Pillow.\n• None Preservation of Aspect Ratio − When creating a thumbnail Pillow maintains the aspect ratio of the original image. This means that the width and height of the thumbnail are adjusted in proportion to the original image so the image does not appear distorted.\n• None Reduced File Size − Thumbnails are smaller in size compared to the original image. This reduction in size is useful for optimizing web pages or displaying images in constrained spaces such as in galleries or lists.\n• None Convenience − It simplifies the process of creating thumbnails. It resizes the image while preserving the aspect ratio and it provides an easy way to save the resized image to a file.\n• None Quality Control − We can control the quality of the thumbnail using various parameters such as the size, filter type for resizing and compression settings if we are saving the thumbnail in a compressed format like JPEG.\n\nIn pillow we have the method namely thumbnail() which allows us to specify the dimensions and shape for the thumbnail image. We can create the thumbnails in two different shapes one is square and the other is circle.\n\nIn this chapter we are going to see how to create a square thumbnail by using the thumbnail() method of the pillow library.\n\nThe syntax and parameters for thumbnail() method is as follows.\n• None size (required) − This parameter specifies the dimensions i.e. width and height for the thumbnail as a tuple (width, height). We can also specify just one dimension and the other dimension will be automatically calculated to maintain the aspect ratio.\n• None resample (optional) − This parameter defines the resampling filter to use when resizing the image. It can be one of the following constants −\n• None Image.BOX − Box sampling, which is similar to the nearest-neighbor but generally gives slightly smoother results.\n\nIn this example we are creating the square thumbnail by using the thumbnail() method by specifying the width and height parameters of the thumbnail to the resize parameter.\n\nHere is another example of creating a square thumbnail with width 100 and height as 100 by using the thumbnail() module.\n\nIn the above section, we have gone through what is thumbnail and how to create the square thumbnail using the pillow thumbnail() method. Now, we are going to see the circle thumbnail creation. Circle thumbnails means the thumbnail will be in the circle shape.\n\nThe syntax and parameters of the thumbnail() method for creating the circle thumbnail are same as the square thumbnail.\n\nHere are the steps to be followed to create the circular thumbnail.\n• None Import the necessary modules Image and ImageDraw from the Pillow library.\n• None Use the Image.open() method to load the original image.\n• None Determine the dimensions of the original image using the size attribute.\n• None Create a new object from the mask image using the ImageDraw.Draw() method.\n• None Draw an ellipse on the mask image using the draw.ellipse() method. Centering the image to the center of the ellipse.\n• None Create a new image with the same dimensions as the original image with a transparent background using the Image.new() method.\n• None Use the save() method to save the circle thumbnail image.\n• None Use the show() method to display the created circle thumbnail image.\n\nIn this example we are creating the circular thumbnail by using the thumbnail() method of the pillow library.\n\nImage to be used"
    },
    {
        "link": "https://realpython.com/python-f-strings",
        "document": "Python f-strings offer a concise and efficient way to interpolate variables, objects, and expressions directly into strings. By prefixing a string with or , you can embed expressions within curly braces ( ), which are evaluated at runtime.\n\nThis makes f-strings faster and more readable compared to older approaches like the modulo ( ) operator or the string method. Additionally, f-strings support advanced string formatting using Python’s string format mini-language.\n\nBy the end of this tutorial, you’ll understand that:\n• An f-string in Python is a string literal prefixed with or , allowing for the embedding of expressions within curly braces .\n• To include dynamic content in an f-string, place your expression or variable inside the braces to interpolate its value into the string.\n• An f-string error in Python often occurs due to syntax issues, such as unmatched braces or invalid expressions within the string.\n• Python 3.12 improved f-strings by allowing nested expressions and the use of backslashes.\n\nThis tutorial will guide you through the features and advantages of f-strings, including interpolation and formatting. By familiarizing yourself with these features, you’ll be able to effectively use f-strings in your Python projects.\n\nBefore Python 3.6, you had two main tools for interpolating values, variables, and expressions inside string literals: You’ll get a refresher on these two string interpolation tools in the following sections. You’ll also learn about the string formatting capabilities that these tools offer in Python. The modulo operator ( ) was the first tool for string interpolation and formatting in Python and has been in the language since the beginning. Here’s what using this operator looks like in practice: In this quick example, you use the operator to interpolate the value of your variable into a string literal. The interpolation operator takes two operands:\n• A string literal containing one or more conversion specifiers\n• The object or objects that you’re interpolating into the string literal The conversion specifiers work as replacement fields. In the above example, you use the combination of characters as a conversion specifier. The symbol marks the start of the specifier, while the letter is the conversion type and tells the operator that you want to convert the input object into a string. If you want to insert more than one object into your target string, then you can use a tuple. Note that the number of objects in the tuple must match the number of format specifiers in the string: In this example, you use a tuple of values as the right-hand operand to . Note that you’ve used a string and an integer. Because you use the specifier, Python converts both objects to strings. You can also use dictionaries as the right-hand operand in your interpolation expressions. To do this, you need to create conversion specifiers that enclose key names in parentheses: This syntax provides a readable approach to string interpolation with the operator. You can use descriptive key names instead of relying on the positional order of values. When you use the operator for string interpolation, you can use conversion specifiers. They provide some string formatting capabilities that take advantage of conversion types, conversion flags, and some characters like the period ( ) and the asterisk ( ). Consider the following example: In the first example, you use the conversion specifier to represent currency values. The letter tells the operator to convert to a floating-point number. The part defines the precision to use when converting the input. In the second example, you use to align the age value five positions to the right. Note: Formatting with the modulo operator is inspired by formatting used in C and many other programming languages. Even though the operator provides a quick way to interpolate and format strings, it has a few issues that lead to common errors. For example, it’s difficult to interpolate tuples in your strings: : not all arguments converted during string formatting In this example, the operator fails to display the tuple of data because it interprets the tuple as two separate values. You can fix this issue by wrapping the data in a single-item tuple: This syntax fixes the issue, and now your string successfully shows the tuple of data. However, the syntax is hard to read, understand, and remember, isn’t it? Another issue with the operator is its limited formatting capabilities and the lack of support for Python’s string formatting mini-language, which provides a powerful tool to format your strings. The method is an improvement compared to the operator because it fixes a couple of issues and supports the string formatting mini-language. With , curly braces delimit the replacement fields: For the method to work, you must provide replacement fields using curly brackets. If you use empty brackets, then the method interpolates its arguments into the target string based on position. You can manually specify the interpolation order by referencing the position of each argument to using zero-based indices. For example, the code below switches the arguments to in the target string: In this example, you use numeric indices to manually define the order in which you want to interpolate the values that you pass as arguments to . You can also use keyword arguments in the call to the method and enclose the argument names in your replacement fields: This example showcases how interpolates keyword arguments by their names into the target string. This construct considerably improves your code’s readability compared to the previous example and to the examples using the operator. Finally, the method allows you to use dictionaries to provide the values that you want to interpolate into your strings: In this example, you use a dictionary containing the data to interpolate. Then, you use the dictionary unpacking operator ( ) to provide the arguments to . The method supports format specifiers. These are strings that you insert into replacement fields to format the values that you want to interpolate. Consider the following examples: In the first example, you use the format specifier. This specifier tells to format the input value as a floating-point number with a precision of two. This way, you can represent currency values. In the second example, you use the format specifier. In this case, you’re telling to format the input value using the symbol as a filler character. The symbol centers the input value by inserting symbols on both sides to reach thirty characters. Format specifiers provide a remarkable improvement over the limited formatting capabilities of the operator. These specifiers have a straightforward syntax that makes up the string formatting mini-language. Thankfully, f-strings also support the string formatting mini-language, which is another cool feature of theirs. So, you won’t have to use if you don’t need to. In the upcoming sections, you’ll write a few more examples of formatting strings using the mini-language with f-strings.\n\nDoing String Interpolation With F-Strings in Python F-strings joined the party in Python 3.6 with PEP 498. Also called formatted string literals, f-strings are string literals that have an before the opening quotation mark. They can include Python expressions enclosed in curly braces. Python will replace those expressions with their resulting values. So, this behavior turns f-strings into a string interpolation tool. In the following sections, you’ll learn about f-strings and use them to interpolate values, objects, and expressions in your string literals. F-strings make the string interpolation process intuitive, quick, and concise. The syntax is similar to what you used with , but it’s less verbose. You only need to start your string literal with a lowercase or uppercase and then embed your values, objects, or expressions in curly brackets at specific places: Look how readable and concise your string is now that you’re using the f-string syntax. You don’t need operators or methods anymore. You just embed the desired objects or expressions in your string literal using curly brackets. It’s important to note that Python evaluates f-strings at runtime. So, in this example, both and are interpolated into the string literal when Python runs the line of code containing the f-string. Python can only interpolate these variables because you defined them before the f-string, which means that they must be in scope when Python evaluates the f-string. You can embed almost any Python expression in an f-string. This allows you to do some nifty things. You could do something pretty straightforward, like the following: When Python runs this f-string, it multiplies by and immediately interpolates the resulting value into the final string. The example above is quite basic. However, f-strings are more powerful than that. You could also use other Python expressions, including function and method calls, and even comprehensions or other more complex expressions: In the first f-string, you embed a call to the string method in the first replacement field. Python runs the method call and inserts the uppercased name into the resulting string. In the second example, you create an f-string that embeds a list comprehension. The comprehension creates a new list of powers of .\n\nThe expressions that you embed in an f-string are evaluated at runtime. Then, Python formats the result using the special method under the hood. This method supports the string formatting protocol. This protocol underpins both the method, which you already saw, and the built-in function: The function takes a value and a format specifier as arguments. Then, it applies the specifier to the value to return a formatted value. The format specifier must follow the rules of the string formatting mini-language. Just like the method, f-strings also support the string formatting mini-language. So, you can use format specifiers in your f-strings too: Note that the format specifiers in these examples are the same ones that you used in the section on . In this case, the embedded expression comes before the format specifier, which always starts with a colon. This syntax makes the string literals readable and concise. You can create a wide variety of format specifiers. Some common formats include currencies, dates, and the representation of numeric values. Consider the following examples of string formatting: \"Comma as thousand separators and two decimals: 'Comma as thousand separators and two decimals: 1,234,567.99' These examples show how flexible the format specifiers can be. You can use them to create almost any string format. Note how in the second example, you’ve used curly brackets to embed variables or expressions in your format specifiers. This possibility allows you to create dynamic specifiers, which is pretty cool. In the last example, you format a which can be formatted with special date format specifiers.\n\nSo far, you’ve learned that f-strings provide a quick and readable way to interpolate values, objects, and expressions into string literals. They also support the string formatting mini-language, so you can create format specifiers to format the objects that you want to insert into your strings. In the following sections, you’ll learn about a few additional features of f-strings that may be relevant and useful in your day-to-day coding. Using an Object’s String Representations in F-Strings Python’s f-strings support two flags with special meaning in the interpolation process. These flags are closely related to how Python manages the string representation of objects. These flags are: Interpolates the string representation from the method Interpolates the string representation from the method The special method generally provides a user-friendly string representation of an object, while the method returns a developer-friendly representation. To illustrate how these methods work under the hood, consider the following class: This class has two instance attributes, and . The method returns a string that consists of an informative message for users of your class. This message should be useful for end users rather than developers. Note: To dive deeper into the and methods, check out When Should You Use. vs in Python? In contrast, the method returns a string that’s a developer-friendly representation of the object. In short, the representation tells the developer how the current instance was created. Ideally, the developer should be able to copy this string representation and create an equivalent object. How does this discussion about string representation affect f-strings? When you create your f-strings, you can choose which string representation to use with the and flags: In the first f-string, you use the tag to interpolate the string representation that returns. In the second f-string, you use the flag to interpolate the developer-friendly string representation of your current object. These two flags are pretty relevant for you as a Python developer. Depending on your code’s intended audience, you can decide which one to use. In general, it should be the one that provides more value to your users. It’s important to note that the operator also supports equivalent conversion types, and , which work the same as the and flags in f-strings. F-strings have another cool feature that can be useful, especially during your debugging process. The feature helps you self-document some of your expressions. For example, say that you’re dealing with a minor bug or issue in your code, and you want to know the value of a variable at a given moment in the code’s execution. For this quick check, you can insert a call to like the following: You can use a variable name followed by an equal sign ( ) in an f-string to create a self-documented expression. When Python runs the f-string, it builds an expression-like string containing the variable’s name, the equal sign, and the variable’s current value. This f-string feature is useful for inserting quick debugging checks in your code. Note that the whitespaces around the equal sign aren’t required but they are reflected in the output: Even though the whitespaces aren’t required, they can improve your code’s readability and the output’s format. F-strings are a bit faster than both the modulo operator ( ) and the method. That’s another cool characteristic. In the script below, you use the module to measure the execution time that it takes to build a string using the modulo operator, the method, and an f-string: In this script, the function takes care of measuring the execution time of the three different string interpolation tools. The function inside the loop runs each interpolation tool a million times and returns the total execution time. Then, the function prints the result to the screen. Note how your f-string in the call to takes advantage of format specifiers to conveniently format the code’s output. If you run the script from your command line, then you’ll get an output similar to the following. Of course, the numbers will be different for you: This output shows that f-strings are a bit faster than the operator and the method, which is the slowest tool because of all the required function calls. So, f-strings are readable, concise, and also fast.\n\nNow that you’ve learned why f-strings are great, you’re probably eager to get out there and start using them in your code. However, you need to know that f-strings up to Python 3.11 have a few limitations regarding the expressions that you can embed in curly brackets and a few other details. Fortunately, Python 3.12 lifted those limitations by removing the old f-string parser and providing a new implementation of f-strings based on the PEG parser of Python 3.9. In the following sections, you’ll learn about the limitations and how Python 3.12 fixed them. Python supports several different types of quotation marks as delimiters in string literals. You can use single ( ) and double quotes ( ). You can also use triple single ( ) and triple double quotes ( ). All these string delimiters work for f-strings as well. This feature allows you to insert quotation marks in f-strings. It also lets you introduce string literals in the embedded expressions and even create nested f-strings. A typical use case of using different quotation marks in an f-string is when you need to use an apostrophe or access a dictionary key in an embedded expression: In this example, you have a dictionary with a person’s data. To define the f-string, you use double quotes. To access the dictionary key, you use single quotes. In the contraction, you use a single quote as an apostrophe. So, where’s the quote-related limitation of f-strings up to Python 3.11? The problem is that you can’t reuse quotation marks in an f-string: In this example, when you try to reuse double quotes to access the dictionary key, your f-string fails, and Python raises a exception. Fortunately, the new f-strings in Python 3.12 solved this issue, allowing you to reuse quotes: In this example, you reuse the double quotes in your embedded expressions, and the f-string works correctly. The limitation is gone. However, it may not be clear if reusing quotations in this example is cleaner than differentiating nested strings with different quotation marks. There’s another f-string limitation that’s closely related to quotation marks. You can only nest as many f-strings as there are quote delimiters in Python: The number of nesting levels in an f-string up to Python 3.11 is limited by the available string delimiters, which are , , , and . So, you only have four delimiters that you can use to differentiate your levels of nesting. In Python 3.12, this limitation is removed because you can reuse quotation marks: Before the new f-string implementation, there was no formal limit on how many levels of nesting you could have. However, the fact that you couldn’t reuse string quotes imposed a natural limit on the allowed levels of nesting in f-string literals. Starting with Python 3.12, you can reuse quotes, so there are no limits for nesting f-strings. Another limitation of f-strings before 3.12 is that you can’t use backslash characters in embedded expressions. Consider the following example, where you try to concatenate strings using the newline ( ) escape sequence: In this example, you get a because f-strings don’t allow backslash characters inside expressions delimited by curly brackets. Again, the new f-string implementation that comes with Python 3.12 solves the issue: The new f-string implementation lifted the limitation of using backslash characters in embedded expressions, so you can now use escape sequences in your f-strings. F-strings up to Python 3.11 don’t allow you to use the symbol in embedded expressions. Because of that, you can’t insert comments in embedded expressions. If you try to do it, then you’ll get a syntax error: When you use to introduce a comment in an f-string, you get a . Fortunately, the new f-strings in Python 3.12 also fix this problem: Now you can add inline comments if you ever need to clarify something in the embedded expressions of an f-string. Another improvement is that you can add line breaks inside the curly braces, similar to what you can do inside parentheses outside f-strings. You don’t even need to use the triple-quoted multiline strings to do this. Python’s new PEG parser opens the door to many improvements in the language. From the user’s perspective, one of the most valuable improvements is that you now have better error messages. These enhanced error messages weren’t available for f-strings up to Python 3.11 because they didn’t use the PEG parser. So, the error messages related to f-strings were less specific and clear. Python 3.12 came along to fix this issue, too. Take a look at the following example, which compares the error message for an incorrect f-string in both 3.11 and 3.12: File , line File , line : f-string: expecting '=', or '!', or ':', or '}' The error message in the first example is generic and doesn’t point to the exact location of the error within the offending line. Additionally, the expression is surrounded by parentheses, which adds noise to the problem because the original code doesn’t include parentheses. In Python 3.12, the error message is more verbose. It signals the exact location of the problem in the affected line. Additionally, the exception message provides some suggestions that might help you fix the issue. In this specific example, the suggestions aren’t that useful because they focus on an operator that’s possibly wrong. However, having the exact location where the problem happened gives you a strong clue. You have a missing operand in the embedded expression.\n\nEven though f-strings are a pretty cool and popular Python feature, they’re not the one-size-fits-all solution. Sometimes the modulo operator ( ) or the method provides a better solution. Sometimes, they’re your only option. It all depends on your specific use case. In the following sections, you’ll learn about a few situations where f-strings may not be the best option. To kick things off, you’ll start with a use case that’s closely related to your code’s readability. That’s when you want to interpolate values from a dictionary into a given string. Interpolating dictionary values into a string may be a common requirement in your code. Because you now know that f-strings are neat, you may think of using them for this task. You end up with a piece of code that looks like the following: That’s great! The code works just fine. However, it doesn’t look clean because of all those dictionary key lookups embedded in the string. The f-string looks cluttered and may be hard to read. How about using the method? Here’s a new version of your code: In this example, you use direct names instead of dictionary lookups in the replacement fields. The only additional requirement is that you need to use the dictionary unpacking operator ( ) in the call to . Now, the string looks cleaner and is also a bit shorter than the version using an f-string. As an additional gain, it’s important to note that the number of replacement fields in the string doesn’t have to match the number of keys in the input dictionary. The method will ignore unnecessary keys. You also have the option of using the modulo operator, though: This time, the string is even shorter. You use direct names in the replacement fields and don’t have to use the dictionary unpacking operator because the modulo operator unpacks the dictionary for you. However, some may say that the replacement fields aren’t that readable and that the modulo operator has limited formatting capabilities. So, what version do you prefer? Share your thoughts in the comments! Providing logging messages is a common example of those use cases where you shouldn’t use f-strings or . The module runs string interpolation lazily to optimize performance according to the selected logging level. For example, you may have a hundred debugging messages but only ten warning messages in your code. If you use an f-string or the method to construct your logging messages, then Python will interpolate all the strings regardless of the logging level that you’ve chosen. However, if you use the operator and provide the values to interpolate as arguments to your logging functions, then you’ll optimize the interpolation process. The module will only interpolate those strings that belong to the current and higher logging levels. Consider the following example: In this example, you use the modulo operator syntax to create the logging message. Then, you pass the value that you want to interpolate as an argument to the logging functions. Because is the default logging level, only the messages at this level and higher will be logged. That’s why the function doesn’t generate any output. In the above call to , the string interpolation never happens because you’re using a higher logging level. However, if you use like in the code below, then the interpolation will always happen: If you call a million times inside a loop, then Python will eagerly evaluate its argument, and the interpolation will happen a million times. This behavior will add performance overhead to your code. That’s why the module does the interpolation lazily. The lazy nature of how does string formatting can make a difference, and it’s only possible using the modulo operator. Using any string interpolation tool is a bad idea when you’re building SQL queries with dynamic parameters. In this scenario, interpolation tools invite SQL injection attacks. To illustrate the problem, say that you’re working with a PostgresSQL database using the Psycopg 2 adapter, and you want to run a query to get all the users with a given role or set of privileges. You come up with one of the following queries: All of these strings directly insert the query parameter into the final query without any validation or security check. If you run any of these queries using the method, then the database won’t be able to perform any security checks on the parameters, which makes your code prone to SQL injection attacks. Note: The code in the above example doesn’t run because of the missing library and the assumption of a certain database structure and setup. It’s a demonstrative code example only. To avoid the risk of SQL injection, you can use the operator syntax to build the query template and then provide the query parameter as the second argument to the method in a tuple or list: In this example, you use the operator syntax to create the query template. Then, you provide the parameters as an independent argument to . In this case, the database system will use the specified type and value of when executing the query. This practice offers protection against SQL injection. Note: You should only use the modulo operator syntax in the string literal that represents the query template. You shouldn’t use the operator and the actual sequence of parameters to build the final query. Just let do the hard work and build the final query for you in a safer way. In short, you must avoid using any string interpolation tool to build dynamic queries beforehand. Instead, use the operator syntax to build the query template and pass the query parameters to in a sequence. When you want to provide internationalization and localization in a Python project, the method is the way to go: You can support multiple languages using string templates. Then, you can handle localized string formatting based on the user’s locale. The method will allow you to dynamically interpolate the appropriate strings depending on the user’s language selection.\n\nIf you’re working on porting a legacy codebase to modern Python, and one of your goals is to convert all your strings into f-strings, then you can use the project. This tool allows you to convert traditional strings into f-strings quickly. To use , you need to install it first: This command downloads and installs in your current Python environment. Once you have it installed, you can use the command against your code files. For example, say that you have the following Python file: If you want to update this file and start using f-strings instead of the operator, then you can just run the following command: This command tells to update the content of your file by replacing strings that use the operator and the method with equivalent f-strings. Note that this command will modify your files in place. So, after running the command, will look something like the following: That’s cool, isn’t it? You can also run against a complete directory containing a large Python codebase. It’ll scan every file and convert the old strings into f-strings. So, the tool is quite useful if you’re modernizing your codebase."
    },
    {
        "link": "https://geeksforgeeks.org/formatted-string-literals-f-strings-python",
        "document": "Python offers a powerful feature called f-strings (formatted string literals) to simplify string formatting and interpolation. f-strings is introduced in Python 3.6 it provides a concise and intuitive way to embed expressions and variables directly into strings. The idea behind f-strings is to make string interpolation simpler.\n\nHow to use f-strings in Python\n\nTo create an f-string, prefix the string with the letter “ f ”. The string itself can be formatted in much the same way that you would with str.format(). F-strings provide a concise and convenient way to embed Python expressions inside string literals for formatting.\n\nIn the below example, we have used the f-string inside a print() method to print a string. We use curly braces to use a variable value inside f-strings, so we define a variable ‘val’ with ‘Geeks’ and use this inside as seen in the code below ‘val’ with ‘Geeks’. Similarly, we use the ‘name’ and the variable inside a second print statement.\n\nIn this example, we have printed today’s date using the datetime module in Python with f-string. For that firstly, we import the datetime module after that we print the date using f-sting. Inside f-string ‘today’ assigned the current date and %B, %d, and %Y represents the full month, day of month, and year respectively.\n\nNote: F-strings are faster than the two most commonly used string formatting mechanisms, which are % formatting and str.format().\n\nTo use any type of quotation marks with the f-string in Python we have to make sure that the quotation marks used inside the expression are not the same as quotation marks used with the f-string.\n\nWe can also evaluate expressions with f-strings in Python. To do so we have to write the expression inside the curly braces in f-string and the evaluated result will be printed as shown in the below code’s output.\n\nErrors while using f-string in Python\n\nIn Python f-string, Backslash Cannot be used in format string directly.\n\nHowever, we can put the backslash into a variable as a workaround though :\n\nWe cannot use comments inside F-string expressions. It will give an error:\n\nIf we want to show curly braces in the f-string’s output then we have to use double curly braces in the f-string. Note that for each single pair of braces, we need to type double braces as seen in the below code.\n\nWhile working with dictionaries, we have to make sure that if we are using double quotes (“) with the f-string then we have to use single quote (‘) for keys inside the f-string in Python and vice-versa. Otherwise, it will throw a syntax error.\n\nUsing the same type of quotes for f-string and key\n\nWhat are f-strings in Python?\n\nHow to use\n\nHow to use F-string in JSON Python?\n\nCan we use F-string in input Python?\n\nWhat is the alternative to F-string in Python?"
    },
    {
        "link": "https://stackoverflow.com/questions/42097052/can-i-import-pythons-3-6s-formatted-string-literals-f-strings-into-older-3-x",
        "document": "The new Python 3.6 f-strings seem like a huge jump in string usability to me, and I would love to jump in and adopt them whole heartedly on new projects which might be running on older interpreters. 2.7, 3.3-3.5 support would be great but at the very least I would like to use these in Python 3.5 code bases. How can I import 3.6's formatted string literals for use by older interpreters?\n\nI understand that formatted string literals like are not breaking changes, so would not be included in a call. But the change is not back-ported (AFAIK) I would need to be sure that whatever new code I write with f-strings is only ran on Python 3.6+ which is a deal breaker for a lot of projects."
    },
    {
        "link": "https://builtin.com/data-science/python-f-string",
        "document": "If you’ve been practicing Python for a while, you likely use to create strings in Python.\n\nThere’s nothing wrong with that. After all, our first line of Python code was a simple . That said, if you want to take your Python strings to the next level, you should use f-strings.\n\nF-string was introduced in Python 3.6 and provides a better way to format strings. In this guide, we’ll see how to format strings in Python using f-string. We’ll also learn how to add variables, comma separators, right/left padding with zeros, dates and more.\n\nHow to Format With Python F-String\n\nTo follow this tutorial, make sure you have Python 3.6 or above. Otherwise, f-strings won’t work.\n\nF-string provides a better syntax for adding variables to strings.\n\nLet’s print two messages using f-string in Python. To do that, we have to add the in front of the that we use to create regular strings. We also have to add to insert a variable in our string.\n\nAs you can see, using f-string to add variables is simpler than using regular strings and the operator.\n\nF-string also makes debugging easier too. Instead of printing the variable name and its value, as we did above for the , we only need to write this inside the f-string:\n\nNow, let’s see more advanced formatting. For the following sections, we’ll be using the syntax below:\n\nMore on Python: 5 Types of Arguments in Python Function Definitions\n\nHow to Align With Python F-String\n\nThere are very few occasions when you’d need to align a word or text to the right or left, but this is the foundation to fully understanding how to add zeros to the left or right of a number. F-string is very useful when formatting numbers.\n\nAlign to the Right\n\nSay we have a number, and we want to align it to the right. We can do that using the syntax above. In this case, we only need to add the element.\n\nIf we want to add six blank spaces and align our text to the right, we only need to add a width of eight. The default behavior is to align the text to the right.\n\nIf we want to be more specific, we can add the , which indicates that the text should be aligned to the right.\n\nNow, let’s align our text to the left using as our padding character.\n\nTo complete the width of eight, we added six “_” using the code above.\n\nHow to Pad With Zeros Using Python F-Strings\n\nNow, it’s time to use what we’ve learned in the previous section to format numbers with zeros to the left/right.\n\nAs we’ve seen before, we can pick the padding character. In this case, we’ll choose the as our padding character to have five decimals in our float below.\n\nThis is cool, but sometimes using the makes things complicated because we have to calculate the final width of our number after adding the zeros.\n\nIt’s simpler to think of the number of decimals we want instead. We can get this using from the syntax shown before. Let’s add zeros until we have five decimals.\n\nIn the code above, represents the precision and stands for floating point numbers.\n\nNow, let’s add zeros to the left. This is very useful when we need to create customized formats using numbers.\n\nSay we want to obtain the following format: , and we have regular numbers from one-to-nine. In this case, we’ll need to add zeros to the left of the month and day.\n\nHere are the two ways to do this with f-string.\n\nHow to Round Float With Python F-Strings\n\nWhen it comes to rounding float numbers to “n” decimals, it’s more practical to use the with type.\n\nLet’s round the number below to one decimal.\n\nMore on Python: 10 Python Cheat Sheets Every Developer Should Know\n\nNow, let’s round the number and add the sign.\n\nWe can also add a comma as a thousands separator. We only need to add .\n\nHow to Date Format With Python F-Strings\n\nLast but not least, we can import and use the special characters inside our f-string to get proper date formatting.\n\nHere’s a cheat sheet with more characters that you can use to format date variables in Python."
    },
    {
        "link": "https://w3schools.com/python/python_string_formatting.asp",
        "document": "F-String was introduced in Python 3.6, and is now the preferred way of formatting strings.\n\nBefore Python 3.6 we had to use the method.\n\nF-string allows you to format selected parts of a string.\n\nTo specify a string as an f-string, simply put an in front of the string literal, like this:\n\nTo format values in an f-string, add placeholders , a placeholder can contain variables, operations, functions, and modifiers to format the value.\n\nA placeholder can also include a modifier to format the value.\n\nA modifier is included by adding a colon followed by a legal formatting type, like which means fixed point number with 2 decimals:\n\nYou can also format a value directly without keeping it in a variable:\n\nYou can perform Python operations inside the placeholders.\n\nYou can do math operations:\n\nYou can perform math operations on variables:\n\nYou can perform statements inside the placeholders:\n\nYou can execute functions inside the placeholder:\n\nThe function does not have to be a built-in Python method, you can create your own functions and use them:\n\nAt the beginning of this chapter we explained how to use the modifier to format a number into a fixed point number with 2 decimals.\n\nThere are several other modifiers that can be used to format values:\n\nHere is a list of all the formatting types.\n\nBefore Python 3.6 we used the method to format strings.\n\nThe method can still be used, but f-strings are faster and the preferred way to format strings.\n\nThe next examples in this page demonstrates how to format strings with the method.\n\nThe method also uses curly brackets as placeholders , but the syntax is slightly different:\n\nYou can add parameters inside the curly brackets to specify how to convert the value:\n\nCheck out all formatting types in our String format() Reference.\n\nIf you want to use more values, just add more values to the format() method:\n\nYou can use index numbers (a number inside the curly brackets ) to be sure the values are placed in the correct placeholders:\n\nAlso, if you want to refer to the same value more than once, use the index number:\n\nYou can also use named indexes by entering a name inside the curly brackets , but then you must use names when you pass the parameter values :"
    }
]