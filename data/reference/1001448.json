[
    {
        "link": "https://khronos.org/opengl/wiki/General_OpenGL:_Transformations",
        "document": "I can't get transformations to work. Where can I learn more about matrices?\n\nA thorough explanation of basic matrix math and linear algebra is beyond the scope of this FAQ. These concepts are taught in high school math classes in the United States.\n\nIf you understand the basics, but just get confused (a common problem even for the experienced!), read through Steve Baker's review of matrix concepts and his article on Euler angles.\n\nFor programming purposes, OpenGL matrices are 16-value arrays with base vectors laid out contiguously in memory. The translation components occupy the 13th, 14th, and 15th elements of the 16-element matrix.\n\nColumn-major versus row-major is purely a notational convention. Note that post-multiplying with column-major matrices produces the same result as pre-multiplying with row-major matrices. The OpenGL Specification and the OpenGL Reference Manual both use column-major notation. You can use any notation, as long as it's clearly stated.\n\nSadly, the use of column-major format in the spec and blue book has resulted in endless confusion in the OpenGL programming community. Column-major notation suggests that matrices are not laid out in memory as a programmer would expect.\n\nA summary of Usenet postings on the subject can be found here.\n\nThe short answer: Anything you want them to be.\n\nDepending on the contents of your geometry database, it may be convenient for your application to treat one OpenGL coordinate unit as being equal to one millimeter or one parsec or anything in between (or larger or smaller).\n\nOpenGL also lets you specify your geometry with coordinates of differing values. For example, you may find it convenient to model an airplane's controls in centimeters, its fuselage in meters, and a world to fly around in kilometers. OpenGL's ModelView matrix can then scale these different coordinate systems into the same eye coordinate space.\n\nIt's the application's responsibility to ensure that the Projection and ModelView matrices are constructed to provide an image that keeps the viewer at an appropriate distance, with an appropriate field of view, and keeps the zNear and zFar clipping planes at an appropriate range. An application that displays molecules in micron scale, for example, would probably not want to place the viewer at a distance of 10 feet with a 60 degree field of view.\n\nHow are coordinates transformed? What are the different coordinate spaces?\n\nObject Coordinates are transformed by the ModelView matrix to produce Eye Coordinates.\n\nEye Coordinates are transformed by the Projection matrix to produce Clip Coordinates.\n\nClip Coordinate X, Y, and Z are divided by Clip Coordinate W to produce Normalized Device Coordinates.\n\nNormalized Device Coordinates are scaled and translated by the viewport parameters to produce Window Coordinates.\n\nObject coordinates are the raw coordinates you submit to OpenGL with a call to glVertex*() or glVertexPointer(). They represent the coordinates of your object or other geometry you want to render.\n\nMany programmers use a World Coordinate system. Objects are often modeled in one coordinate system, then scaled, translated, and rotated into the world you're constructing. World Coordinates result from transforming Object Coordinates by the modelling transforms stored in the ModelView matrix. However, OpenGL has no concept of World Coordinates. World Coordinates are purely an application construct.\n\nEye Coordinates result from transforming Object Coordinates by the ModelView matrix. The ModelView matrix contains both modelling and viewing transformations that place the viewer at the origin with the view direction aligned with the negative Z axis.\n\nClip Coordinates result from transforming Eye Coordinates by the Projection matrix. Clip Coordinate space ranges from -Wc to Wc in all three axes, where Wc is the Clip Coordinate W value. OpenGL clips all coordinates outside this range.\n\nPerspective division performed on the Clip Coordinates produces Normalized Device Coordinates, ranging from -1 to 1 in all three axes.\n\nWindow Coordinates result from scaling and translating Normalized Device Coordinates by the viewport. The parameters to glViewport() and glDepthRange() control this transformation. With the viewport, you can map the Normalized Device Coordinate cube to any location in your window and depth buffer.\n\nFor more information, see the OpenGL Specification, Figure 2.6.\n\nHow do I transform only one object in my scene or give each object its own transform?\n\nOpenGL provides matrix stacks specifically for this purpose. In this case, use the ModelView matrix stack.\n\nA typical OpenGL application first sets the matrix mode with a call to glMatrixMode(GL_MODELVIEW) and loads a viewing transform, perhaps with a call to gluLookAt(). More information is available on gluLookAt().\n\nThen the code renders each object in the scene with its own transformation by wrapping the rendering with calls to glPushMatrix() and glPopMatrix(). For example:\n\nThe above code renders a cylinder rotated 90 degrees around the X-axis. The ModelView matrix is restored to its previous value after the glPopMatrix() call. Similar call sequences can render subsequent objects in the scene.\n\nHow do I draw 2D controls over my 3D rendering?\n\nThe basic strategy is to set up a 2D projection for drawing controls. You can do this either on top of your 3D rendering or in overlay planes. If you do so on top of a 3D rendering, you'll need to redraw the controls at the end of every frame (immediately before swapping buffers). If you draw into the overlay planes, you only need to redraw the controls if you're updating them.\n\nTo set up a 2D projection, you need to change the Projection matrix. Normally, it's convenient to set up the projection so one world coordinate unit is equal to one screen pixel, as follows:\n\ngluOrtho2D() sets up a Z range of -1 to 1, so you need to use one of the glVertex2*() functions to ensure your geometry isn't clipped by the zNear or zFar clipping planes.\n\nNormally, the ModelView matrix is set to the identity when drawing 2D controls, though you may find it convenient to do otherwise (for example, you can draw repeated controls with interleaved translation matrices).\n\nIf exact pixelization is required, you might want to put a small translation in the ModelView matrix, as shown below:\n\nIf you're drawing on top of a 3D-depth buffered image, you'll need to somehow disable depth testing while drawing your 2D geometry. You can do this by calling glDisable(GL_DEPTH_TEST) or glDepthFunc (GL_ALWAYS). Depending on your application, you might also simply clear the depth buffer before starting the 2D rendering. Finally, drawing all 2D geometry with a minimum Z coordinate is also a solution.\n\nAfter the 2D projection is established as above, you can render normal OpenGL primitives to the screen, specifying their coordinates with XY pixel addresses (using OpenGL-centric screen coordinates, with (0,0) in the lower left).\n\nHow do I bypass OpenGL matrix transformations and send 2D coordinates directly for rasterization?\n\nThere isn't a mode switch to disable OpenGL matrix transformations. However, if you set either or both matrices to the identity with a glLoadIdentity() call, typical OpenGL implementations are intelligent enough to know that an identity transformation is a no-op and will act accordingly.\n\nMore detailed information on using OpenGL as a rasterization-only API is in the OpenGL Game Developer’s FAQ.\n\nWhat are the pros and cons of using absolute versus relative coordinates?\n\nSome OpenGL applications may need to render the same object in multiple locations in a single scene. OpenGL lets you do this two ways:\n• Use “absolute coordinates\". Maintain multiple copies of each object, each with its own unique set of vertices. You don't need to change the ModelView matrix to render the object at the desired location.\n• Use “relative coordinates\". Keep only one copy of the object, and render it multiple times by pushing the ModelView matrix stack, setting the desired transform, sending the geometry, and popping the stack. Repeat these steps for each object.\n\nIn general, frequent changes to state, such as to the ModelView matrix, can negatively impact your application’s performance. OpenGL can process your geometry faster if you don't wrap each individual primitive in a lot of changes to the ModelView matrix.\n\nHowever, sometimes you need to weigh this against the memory savings of replicating geometry. Let's say you define a doorknob with high approximation, such as 200 or 300 triangles, and you're modeling a house with 50 doors in it, all of which have the same doorknob. It's probably preferable to use a single doorknob display list, with multiple unique transform matrices, rather than use absolute coordinates with 10-15K triangles in memory.\n\nAs with many computing issues, it's a trade-off between processing time and memory that you'll need to make on a case-by-case basis.\n\nHow can I draw more than one view of the same scene?\n\nYou can draw two views into the same window by using the glViewport() call. Set glViewport() to the area that you want the first view, set your scene’s view, and render. Then set glViewport() to the area for the second view, again set your scene’s view, and render.\n\nYou need to be aware that some operations don't pay attention to the glViewport, such as SwapBuffers and glClear(). SwapBuffers always swaps the entire window. However, you can restrain glClear() to a rectangular window by using the scissor rectangle.\n\nYour application might only allow different views in separate windows. If so, you need to perform a MakeCurrent operation between the two renderings. If the two windows share a context, you need to change the scene’s view as described above. This might not be necessary if your application uses separate contexts for each window.\n\nHow do I transform my objects around a fixed coordinate system rather than the object's local coordinate system?\n\nIf you rotate an object around its Y-axis, you'll find that the X- and Z-axes rotate with the object. A subsequent rotation around one of these axes rotates around the newly transformed axis and not the original axis. It's often desirable to perform transformations in a fixed coordinate system rather than the object’s local coordinate system.\n\nThe OpenGL Game Developer’s FAQ contains information on using quaternions to store rotations, which may be useful in solving this problem.\n\nThe root cause of the problem is that OpenGL matrix operations postmultiply onto the matrix stack, thus causing transformations to occur in object space. To affect screen space transformations, you need to premultiply. OpenGL doesn't provide a mode switch for the order of matrix multiplication, so you need to premultiply by hand. An application might implement this by retrieving the current matrix after each frame. The application multiplies new transformations for the next frame on top of an identity matrix and multiplies the accumulated current transformations (from the last frame) onto those transformations using glMultMatrix().\n\nYou need to be aware that retrieving the ModelView matrix once per frame might have a detrimental impact on your application’s performance. However, you need to benchmark this operation, because the performance will vary from one implementation to the next.\n\nWhat are the pros and cons of using glFrustum() versus gluPerspective()? Why would I want to use one over the other?\n\nglFrustum() and gluPerspective() both produce perspective projection matrices that you can use to transform from eye coordinate space to clip coordinate space. The primary difference between the two is that glFrustum() is more general and allows off-axis projections, while gluPerspective() only produces symmetrical (on-axis) projections. Indeed, you can use glFrustum() to implement gluPerspective(). However, aside from the layering of function calls that is a natural part of the GLU interface, there is no performance advantage to using matrices generated by glFrustum() over gluPerspective().\n\nSince glFrustum() is more general than gluPerspective(), you can use it in cases when gluPerspective() can't be used. Some examples include projection shadows, tiled renderings, and stereo views.\n\nTiled rendering uses multiple off-axis projections to render different sections of a scene. The results are assembled into one large image array to produce the final image. This is often necessary when the desired dimensions of the final rendering exceed the OpenGL implementation's maximum viewport size.\n\nIn a stereo view, two renderings of the same scene are done with the view location slightly shifted. Since the view axis is right between the “eyes”, each view must use a slightly off-axis projection to either side to achieve correct visual results.\n\nHow can I make a call to glFrustum() that matches my call to gluPerspective()?\n\nThe field of view (fov) of your glFrustum() call is:\n\nSince bottom == -top for the symmetrical projection that gluPerspective() produces, then:\n\nNote: fov must be in radians for the above formulae to work with the C math library. If you have comnputer your fov in degrees (as in the call to gluPerspective()), then calculate top as follows:\n\nThe left and right parameters are simply functions of the top, bottom, and aspect:\n\nThe OpenGL Reference Manual (where do I get this?) shows the matrices produced by both functions.\n\nThis question usually means, \"How do I draw a quad that fills the entire OpenGL viewport?\" There are many ways to do this.\n\nThe most straightforward method is to set the desired color, set both the Projection and ModelView matrices to the identity, and call glRectf() or draw an equivalent GL_QUADS primitive. Your rectangle or quad's Z value should be in the range of –1.0 to 1.0, with –1.0 mapping to the zNear clipping plane, and 1.0 to the zFar clipping plane.\n\nAs an example, here's how to draw a full-screen quad at the zNear clipping plane:\n\nYour application might want the quad to have a maximum Z value, in which case 1 should be used for the Z value instead of -1.\n\nWhen painting a full-screen quad, it might be useful to mask off some buffers so that only specified buffers are touched. For example, you might mask off the color buffer and set the depth function to GL_ALWAYS, so only the depth buffer is painted. Also, you can set masks to allow the stencil buffer to be set or any combination of buffers.\n\nHow can I find the screen coordinates for a given object-space coordinate?\n\nYou can use the GLU library gluProject() utility routine if you only need to find it for a few vertices. For a large number of coordinates, it can be more efficient to use the Feedback mechanism.\n\nTo use gluProject(), you'll need to provide the ModelView matrix, projection matrix, viewport, and input object space coordinates. Screen space coordinates are returned for X, Y, and Z, with Z being normalized (0 <= Z <= 1).\n\nHow can I find the object-space coordinates for a pixel on the screen?\n\nThe GLU library provides the gluUnProject() function for this purpose.\n\nYou'll need to read the depth buffer to obtain the input screen coordinate Z value at the X,Y location of interest. This can be coded as follows:\n\nNote that x and y are OpenGL-centric with (0,0) in the lower-left corner.\n\nYou'll need to provide the screen space X, Y, and Z values as input to gluUnProject() with the ModelView matrix, Projection matrix, and viewport that were current at the time the specific pixel of interest was rendered.\n\nHow do I find the coordinates of a vertex transformed only by the ModelView matrix?\n\nIt's often useful to obtain the eye coordinate space value of a vertex (i.e., the object space vertex transformed by the ModelView matrix). You can obtain this by retrieving the current ModelView matrix and performing simple vector / matrix multiplication.\n\nHow do I calculate the object-space distance from the viewer to a given point?\n\nTransform the point into eye-coordinate space by multiplying it by the ModelView matrix. Then simply calculate its distance from the origin. (If this doesn't work, you may have incorrectly placed the view transform on the Projection matrix stack.)\n\nAs with any OpenGL call, you must have a context current with a window or drawable in order for glGet*() function calls to work.\n\nHow do I keep my aspect ratio correct after a window resize?\n\nIt depends on how you are setting your projection matrix. In any case, you'll need to know the new dimensions (width and height) of your window. How to obtain these depends on which platform you're using. In GLUT, for example, the dimensions are passed as parameters to the reshape function callback.\n\nThe following assumes you're maintaining a viewport that's the same size as your window. If you are not, substitute viewportWidth and viewportHeight for windowWidth and windowHeight.\n\nIf you're using gluPerspective() to set your Projection matrix, the second parameter controls the aspect ratio. When your program catches a window resize, you'll need to change your Projection matrix as follows:\n\nIf you're using glFrustum(), the aspect ratio varies with the width of the view volume to the height of the view volume. You might maintain a 1:1 aspect ratio with the following window resize code:\n\nglOrtho() and gluOrtho2D() are similar to glFrustum().\n\nOpenGL doesn't have a mode switch to change from right- to left-handed coordinates. However, you can easily obtain a left-handed coordinate system by multiplying a negative Z scale onto the ModelView matrix. For example:\n\nHow can I transform an object so that it points at or follows another object or point in my scene?\n\nYou need to construct a matrix that transforms from your object's local coordinate system into a coordinate system that faces in the desired direction. See this example code to see how this type of matrix is created.\n\nIf you merely want to render an object so that it always faces the viewer, you might consider simply rendering it in eye-coordinate space with the ModelView matrix set to the identity.\n\nHow can I transform an object with a given yaw, pitch, and roll?\n\nThe upper left 3x3 portion of a transformation matrix is composed of the new X, Y, and Z axes of the post-transformation coordinate space.\n\nIf the new transform is a roll, compute new local Y and X axes by rotating them \"roll\" degrees around the local Z axis. Do similar calculations if the transform is a pitch or yaw. Then simply construct your transformation matrix by inserting the new local X, Y, and Z axes into the upper left 3x3 portion of an identity matrix. This matrix can be passed as a parameter to glMultMatrix().\n\nFurther rotations should be computed around the new local axes. This will inevitably require rotation about an arbitrary axis, which can be confusing to inexperienced 3D programmers. This is a basic concept in linear algebra.\n\nMany programmers apply all three transformations -- yaw, pitch, and roll -- at once as successive glRotate() calls about the X, Y, and Z axes. This has the disadvantage of creating gimbal lock, in which the result depends on the order of glRotate() calls.\n\nRender your scene twice, once as it is reflected in the mirror, then once from the normal (non-reflected) view. Example code demonstrates this technique.\n\nFor axis-aligned mirrors, such as a mirror on the YZ plane, the reflected scene can be rendered with a simple scale and translate. Scale by -1.0 in the axis corresponding to the mirror's normal, and translate by twice the mirror's distance from the origin. Rendering the scene with these transforms in place will yield the scene reflected in the mirror. Use the matrix stack to restore the view transform to its previous value.\n\nNext, clear the depth buffer with a call to glClear(GL_DEPTH_BUFFER_BIT). Then render the mirror. For a perfectly reflecting mirror, render into the depth buffer only. Real mirrors are not perfect reflectors, as they absorb some light. To create this effect, use blending to render a black mirror with an alpha of 0.05. glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA) is a good blending function for this purpose.\n\nFinally, render the non-reflected scene. Since the entire reflected scene exists in the color buffer, and not just the portion of the reflected scene in the mirror, you will need to touch all pixels to overwrite areas of the reflected scene that should not be visible.\n\nHow can I do my own perspective scaling?\n\nOpenGL multiplies your coordinates by the ModelView matrix, then by the Projection matrix to get clip coordinates. It then performs the perspective divide to obtain normalized device coordinates. It's the perspective division step that creates a perspective rendering, with geometry in the distance appearing smaller than the geometry in the foreground. The perspective division stage is accomplished by dividing your XYZ clipping coordinate values by the clipping coordinate W value, such as:\n\nTo do your own perspective correction, you need to obtain the clipping coordinate W value. The feedback buffer provides homogenous coordinates with XYZ in device coordinates and W in clip coordinates. You might also glGetFloatv(GL_CURRENT_RASTER_POSITION,…) and the W value will again be in clipping coordinates, while XYZ are in device coordinates."
    },
    {
        "link": "https://reddit.com/r/opengl/comments/lyrwe4/scaling_transformationmodel_matrix_while_using",
        "document": "Okay so I have a 3D game with which I'm using a perspective projection. I created a new shader just for rendering 2D ui stuff such as text (on textured quads). This works well except for when I want to scale the text using a transformation/model matrix. If I do the following:\n\nand pass the matrix model to the text shader, and in the text vertex shader do:\n\nthen it MOVES the vertices of the quads that I want to draw. The quad does get scaled to the scale I gave it (2.f in the x y axis), but the quad also moves to a different place than I want it to be.\n\nI'm assuming this is because I'm using an orthographic projection for the 2D text.\n\nWhat is the correct way to scale quads while using an orthographic projection?"
    },
    {
        "link": "https://stackoverflow.com/questions/15626351/simple-textured-quad-rotation-in-opengl-es-2-0",
        "document": "As I'm not getting far with this, I added view/projection matrix from the Google demo - please see code below: If anyone can point out where I'm going wrong it really would be appreciated, as I'm still getting a blank screen when I put \"\"gl_position = a_position * uMVPMatrix;\" + into my vertex shader (with \"gl_position = a_position;\" + my quad is displayed at least.......)\n\nRoutine that sets texture and does (or is supposed to do) rotation (This is in my Quad class\n\nI've now removed all rotation related stuff and am now just attempting to get a static quad to display after applying the uMVPMatrix in the vertex shader. But still nothing :-(\n\nIf I simply change that line back to the 'default' :\n\nThen I at least get my textured quad displayed (Obviously no rotation and I would expect that).\n\nAlso just to point out, that mvpMatrix is definately being received intact into the setTexture method is valid (contains the same data as appears when I log the contents of mvpMatrix from the Google developers code). I'm not sure how to check if the shader is receiving it intact? I have no reason to believe it isn't though.\n\nReally do appreciate and and all help - I must be going very wrong somewhere but I just can't spot it. Thank you!\n\nEDIT 2: Having added a bounty to this question, I would just like to know how how to rotate my textured quad sprite (2D) keeping the code I have to render it as a base. (ie, what do I need to add to it in order to rotate and why). Thanks!"
    },
    {
        "link": "https://learnopengl.com/Getting-started/Transformations",
        "document": "We now know how to create objects, color them and/or give them a detailed appearance using textures, but they're still not that interesting since they're all static objects. We could try and make them move by changing their vertices and re-configuring their buffers each frame, but that's cumbersome and costs quite some processing power. There are much better ways to an object and that's by using (multiple) objects. This doesn't mean we're going to talk about Kung Fu and a large digital artificial world.\n\nMatrices are very powerful mathematical constructs that seem scary at first, but once you'll grow accustomed to them they'll prove extremely useful. When discussing matrices, we'll have to make a small dive into some mathematics and for the more mathematically inclined readers I'll post additional resources for further reading.\n\nHowever, to fully understand transformations we first have to delve a bit deeper into vectors before discussing matrices. The focus of this chapter is to give you a basic mathematical background in topics we will require later on. If the subjects are difficult, try to understand them as much as you can and come back to this chapter later to review the concepts whenever you need them.\n\nIn its most basic definition, vectors are directions and nothing more. A vector has a and a (also known as its strength or length). You can think of vectors like directions on a treasure map: 'go left 10 steps, now go north 3 steps and go right 5 steps'; here 'left' is the direction and '10 steps' is the magnitude of the vector. The directions for the treasure map thus contains 3 vectors. Vectors can have any dimension, but we usually work with dimensions of 2 to 4. If a vector has 2 dimensions it represents a direction on a plane (think of 2D graphs) and when it has 3 dimensions it can represent any direction in a 3D world.\n\nBelow you'll see 3 vectors where each vector is represented with as arrows in a 2D graph. Because it is more intuitive to display vectors in 2D (rather than 3D) you can think of the 2D vectors as 3D vectors with a coordinate of . Since vectors represent directions, the origin of the vector does not change its value. In the graph below we can see that the vectors \\(\\color{red}{\\bar{v}}\\) and \\(\\color{blue}{\\bar{w}}\\) are equal even though their origin is different:\n\nWhen describing vectors mathematicians generally prefer to describe vectors as character symbols with a little bar over their head like \\(\\bar{v}\\). Also, when displaying vectors in formulas they are generally displayed as follows: \\[\\bar{v} = \\begin{pmatrix} \\color{red}x \\\\ \\color{green}y \\\\ \\color{blue}z \\end{pmatrix} \\]\n\nBecause vectors are specified as directions it is sometimes hard to visualize them as positions. If we want to visualize vectors as positions we can imagine the origin of the direction vector to be and then point towards a certain direction that specifies the point, making it a (we could also specify a different origin and then say: 'this vector points to that point in space from this origin'). The position vector would then point to on the graph with an origin of . Using vectors we can thus describe directions and positions in 2D and 3D space.\n\nJust like with normal numbers we can also define several operations on vectors (some of which you've already seen).\n\nA is a single digit. When adding/subtracting/multiplying or dividing a vector with a scalar we simply add/subtract/multiply or divide each element of the vector by the scalar. For addition it would look like this: \\[ \\begin{pmatrix} \\color{red}1 \\\\ \\color{green}2 \\\\ \\color{blue}3 \\end{pmatrix} + x \\rightarrow \\begin{pmatrix} \\color{red}1 \\\\ \\color{green}2 \\\\ \\color{blue}3 \\end{pmatrix} + \\begin{pmatrix} x \\\\ x \\\\ x \\end{pmatrix} = \\begin{pmatrix} \\color{red}1 + x \\\\ \\color{green}2 + x \\\\ \\color{blue}3 + x \\end{pmatrix} \\] Where \\(+\\) can be \\(+\\),\\(-\\),\\(\\cdot\\) or \\(\\div\\) where \\(\\cdot\\) is the multiplication operator.\n\nNegating a vector results in a vector in the reversed direction. A vector pointing north-east would point south-west after negation. To negate a vector we add a minus-sign to each component (you can also represent it as a scalar-vector multiplication with a scalar value of ): \\[-\\bar{v} = -\\begin{pmatrix} \\color{red}{v_x} \\\\ \\color{blue}{v_y} \\\\ \\color{green}{v_z} \\end{pmatrix} = \\begin{pmatrix} -\\color{red}{v_x} \\\\ -\\color{blue}{v_y} \\\\ -\\color{green}{v_z} \\end{pmatrix} \\]\n\nAddition of two vectors is defined as addition, that is each component of one vector is added to the same component of the other vector like so: \\[\\bar{v} = \\begin{pmatrix} \\color{red}1 \\\\ \\color{green}2 \\\\ \\color{blue}3 \\end{pmatrix}, \\bar{k} = \\begin{pmatrix} \\color{red}4 \\\\ \\color{green}5 \\\\ \\color{blue}6 \\end{pmatrix} \\rightarrow \\bar{v} + \\bar{k} = \\begin{pmatrix} \\color{red}1 + \\color{red}4 \\\\ \\color{green}2 + \\color{green}5 \\\\ \\color{blue}3 + \\color{blue}6 \\end{pmatrix} = \\begin{pmatrix} \\color{red}5 \\\\ \\color{green}7 \\\\ \\color{blue}9 \\end{pmatrix} \\] Visually, it looks like this on vectors and , where the second vector is added on top of the first vector's end to find the end point of the resulting vector (head-to-tail method):\n\nJust like normal addition and subtraction, vector subtraction is the same as addition with a negated second vector: \\[\\bar{v} = \\begin{pmatrix} \\color{red}{1} \\\\ \\color{green}{2} \\\\ \\color{blue}{3} \\end{pmatrix}, \\bar{k} = \\begin{pmatrix} \\color{red}{4} \\\\ \\color{green}{5} \\\\ \\color{blue}{6} \\end{pmatrix} \\rightarrow \\bar{v} + -\\bar{k} = \\begin{pmatrix} \\color{red}{1} + (-\\color{red}{4}) \\\\ \\color{green}{2} + (-\\color{green}{5}) \\\\ \\color{blue}{3} + (-\\color{blue}{6}) \\end{pmatrix} = \\begin{pmatrix} -\\color{red}{3} \\\\ -\\color{green}{3} \\\\ -\\color{blue}{3} \\end{pmatrix} \\]\n\nSubtracting two vectors from each other results in a vector that's the difference of the positions both vectors are pointing at. This proves useful in certain cases where we need to retrieve a vector that's the difference between two points.\n\nTo retrieve the length/magnitude of a vector we use the that you may remember from your math classes. A vector forms a triangle when you visualize its individual and component as two sides of a triangle:\n\nSince the length of the two sides are known and we want to know the length of the tilted side \\(\\color{red}{\\bar{v}}\\) we can calculate it using the Pythagoras theorem as: \\[||\\color{red}{\\bar{v}}|| = \\sqrt{\\color{green}x^2 + \\color{blue}y^2} \\] Where \\(||\\color{red}{\\bar{v}}||\\) is denoted as the length of vector \\(\\color{red}{\\bar{v}}\\). This is easily extended to 3D by adding \\(z^2\\) to the equation.\n\nIn this case the length of vector equals: \\[||\\color{red}{\\bar{v}}|| = \\sqrt{\\color{green}4^2 + \\color{blue}2^2} = \\sqrt{\\color{green}16 + \\color{blue}4} = \\sqrt{20} = 4.47 \\] Which is .\n\nThere is also a special type of vector that we call a . A unit vector has one extra property and that is that its length is exactly 1. We can calculate a unit vector \\(\\hat{n}\\) from any vector by dividing each of the vector's components by its length: \\[\\hat{n} = \\frac{\\bar{v}}{||\\bar{v}||}\\] We call this a vector. Unit vectors are displayed with a little roof over their head and are generally easier to work with, especially when we only care about their directions (the direction does not change if we change a vector's length).\n\nMultiplying two vectors is a bit of a weird case. Normal multiplication isn't really defined on vectors since it has no visual meaning, but we have two specific cases that we could choose from when multiplying: one is the denoted as \\(\\bar{v} \\cdot \\bar{k}\\) and the other is the denoted as \\(\\bar{v} \\times \\bar{k}\\).\n\nThe dot product of two vectors is equal to the scalar product of their lengths times the cosine of the angle between them. If this sounds confusing take a look at its formula: \\[\\bar{v} \\cdot \\bar{k} = ||\\bar{v}|| \\cdot ||\\bar{k}|| \\cdot \\cos \\theta \\] Where the angle between them is represented as theta (\\(\\theta\\)). Why is this interesting? Well, imagine if \\(\\bar{v}\\) and \\(\\bar{k}\\) are unit vectors then their length would be equal to 1. This would effectively reduce the formula to: \\[\\hat{v} \\cdot \\hat{k} = 1 \\cdot 1 \\cdot \\cos \\theta = \\cos \\theta\\] Now the dot product only defines the angle between both vectors. You may remember that the cosine or cos function becomes when the angle is 90 degrees or when the angle is 0. This allows us to easily test if the two vectors are or to each other using the dot product (orthogonal means the vectors are at a to each other). In case you want to know more about the or the functions I'd suggest the following Khan Academy videos about basic trigonometry.\n\nSo how do we calculate the dot product? The dot product is a component-wise multiplication where we add the results together. It looks like this with two unit vectors (you can verify that both their lengths are exactly ): \\[ \\begin{pmatrix} \\color{red}{0.6} \\\\ -\\color{green}{0.8} \\\\ \\color{blue}0 \\end{pmatrix} \\cdot \\begin{pmatrix} \\color{red}0 \\\\ \\color{green}1 \\\\ \\color{blue}0 \\end{pmatrix} = (\\color{red}{0.6} * \\color{red}0) + (-\\color{green}{0.8} * \\color{green}1) + (\\color{blue}0 * \\color{blue}0) = -0.8 \\] To calculate the degree between both these unit vectors we use the inverse of the cosine function \\(cos^{-1}\\) and this results in degrees. We now effectively calculated the angle between these two vectors. The dot product proves very useful when doing lighting calculations later on.\n\nThe cross product is only defined in 3D space and takes two non-parallel vectors as input and produces a third vector that is orthogonal to both the input vectors. If both the input vectors are orthogonal to each other as well, a cross product would result in 3 orthogonal vectors; this will prove useful in the upcoming chapters. The following image shows what this looks like in 3D space:\n\nUnlike the other operations, the cross product isn't really intuitive without delving into linear algebra so it's best to just memorize the formula and you'll be fine (or don't, you'll probably be fine as well). Below you'll see the cross product between two orthogonal vectors A and B: \\[\\begin{pmatrix} \\color{red}{A_{x}} \\\\ \\color{green}{A_{y}} \\\\ \\color{blue}{A_{z}} \\end{pmatrix} \\times \\begin{pmatrix} \\color{red}{B_{x}} \\\\ \\color{green}{B_{y}} \\\\ \\color{blue}{B_{z}} \\end{pmatrix} = \\begin{pmatrix} \\color{green}{A_{y}} \\cdot \\color{blue}{B_{z}} - \\color{blue}{A_{z}} \\cdot \\color{green}{B_{y}} \\\\ \\color{blue}{A_{z}} \\cdot \\color{red}{B_{x}} - \\color{red}{A_{x}} \\cdot \\color{blue}{B_{z}} \\\\ \\color{red}{A_{x}} \\cdot \\color{green}{B_{y}} - \\color{green}{A_{y}} \\cdot \\color{red}{B_{x}} \\end{pmatrix} \\] As you can see, it doesn't really seem to make sense. However, if you just follow these steps you'll get another vector that is orthogonal to your input vectors.\n\nNow that we've discussed almost all there is to vectors it is time to enter the matrix! A matrix is a rectangular array of numbers, symbols and/or mathematical expressions. Each individual item in a matrix is called an of the matrix. An example of a 2x3 matrix is shown below: \\[\\begin{bmatrix} 1 & 2 & 3 \\\\ 4 & 5 & 6 \\end{bmatrix}\\] Matrices are indexed by where is the row and is the column, that is why the above matrix is called a 2x3 matrix (3 columns and 2 rows, also known as the of the matrix). This is the opposite of what you're used to when indexing 2D graphs as . To retrieve the value 4 we would index it as (second row, first column).\n\nMatrices are basically nothing more than that, just rectangular arrays of mathematical expressions. They do have a very nice set of mathematical properties and just like vectors we can define several operations on matrices, namely: addition, subtraction and multiplication.\n\nMatrix addition and subtraction between two matrices is done on a per-element basis. So the same general rules apply that we're familiar with for normal numbers, but done on the elements of both matrices with the same index. This does mean that addition and subtraction is only defined for matrices of the same dimensions. A 3x2 matrix and a 2x3 matrix (or a 3x3 matrix and a 4x4 matrix) cannot be added or subtracted together. Let's see how matrix addition works on two 2x2 matrices: \\[\\begin{bmatrix} \\color{red}1 & \\color{red}2 \\\\ \\color{green}3 & \\color{green}4 \\end{bmatrix} + \\begin{bmatrix} \\color{red}5 & \\color{red}6 \\\\ \\color{green}7 & \\color{green}8 \\end{bmatrix} = \\begin{bmatrix} \\color{red}1 + \\color{red}5 & \\color{red}2 + \\color{red}6 \\\\ \\color{green}3 + \\color{green}7 & \\color{green}4 + \\color{green}8 \\end{bmatrix} = \\begin{bmatrix} \\color{red}6 & \\color{red}8 \\\\ \\color{green}{10} & \\color{green}{12} \\end{bmatrix} \\] The same rules apply for matrix subtraction: \\[\\begin{bmatrix} \\color{red}4 & \\color{red}2 \\\\ \\color{green}1 & \\color{green}6 \\end{bmatrix} - \\begin{bmatrix} \\color{red}2 & \\color{red}4 \\\\ \\color{green}0 & \\color{green}1 \\end{bmatrix} = \\begin{bmatrix} \\color{red}4 - \\color{red}2 & \\color{red}2 - \\color{red}4 \\\\ \\color{green}1 - \\color{green}0 & \\color{green}6 - \\color{green}1 \\end{bmatrix} = \\begin{bmatrix} \\color{red}2 & -\\color{red}2 \\\\ \\color{green}1 & \\color{green}5 \\end{bmatrix} \\]\n\nA matrix-scalar product multiples each element of the matrix by a scalar. The following example illustrates the multiplication: \\[\\color{green}2 \\cdot \\begin{bmatrix} 1 & 2 \\\\ 3 & 4 \\end{bmatrix} = \\begin{bmatrix} \\color{green}2 \\cdot 1 & \\color{green}2 \\cdot 2 \\\\ \\color{green}2 \\cdot 3 & \\color{green}2 \\cdot 4 \\end{bmatrix} = \\begin{bmatrix} 2 & 4 \\\\ 6 & 8 \\end{bmatrix}\\] Now it also makes sense as to why those single numbers are called scalars. A scalar basically scales all the elements of the matrix by its value. In the previous example, all elements were scaled by .\n\nSo far so good, all of our cases weren't really too complicated. That is, until we start on matrix-matrix multiplication.\n\nMultiplying matrices is not necessarily complex, but rather difficult to get comfortable with. Matrix multiplication basically means to follow a set of pre-defined rules when multiplying. There are a few restrictions though:\n• You can only multiply two matrices if the number of columns on the left-hand side matrix is equal to the number of rows on the right-hand side matrix.\n• Matrix multiplication is not that is \\(A \\cdot B \n\neq B \\cdot A\\).\n\nLet's get started with an example of a matrix multiplication of 2 matrices: \\[ \\begin{bmatrix} \\color{red}1 & \\color{red}2 \\\\ \\color{green}3 & \\color{green}4 \\end{bmatrix} \\cdot \\begin{bmatrix} \\color{blue}5 & \\color{purple}6 \\\\ \\color{blue}7 & \\color{purple}8 \\end{bmatrix} = \\begin{bmatrix} \\color{red}1 \\cdot \\color{blue}5 + \\color{red}2 \\cdot \\color{blue}7 & \\color{red}1 \\cdot \\color{purple}6 + \\color{red}2 \\cdot \\color{purple}8 \\\\ \\color{green}3 \\cdot \\color{blue}5 + \\color{green}4 \\cdot \\color{blue}7 & \\color{green}3 \\cdot \\color{purple}6 + \\color{green}4 \\cdot \\color{purple}8 \\end{bmatrix} = \\begin{bmatrix} 19 & 22 \\\\ 43 & 50 \\end{bmatrix} \\] Right now you're probably trying to figure out what the hell just happened? Matrix multiplication is a combination of normal multiplication and addition using the left-matrix's rows with the right-matrix's columns. Let's try discussing this with the following image:\n\nWe first take the upper row of the left matrix and then take a column from the right matrix. The row and column that we picked decides which output value of the resulting matrix we're going to calculate. If we take the first row of the left matrix the resulting value will end up in the first row of the result matrix, then we pick a column and if it's the first column the result value will end up in the first column of the result matrix. This is exactly the case of the red pathway. To calculate the bottom-right result we take the bottom row of the first matrix and the rightmost column of the second matrix.\n\nTo calculate the resulting value we multiply the first element of the row and column together using normal multiplication, we do the same for the second elements, third, fourth etc. The results of the individual multiplications are then summed up and we have our result. Now it also makes sense that one of the requirements is that the size of the left-matrix's columns and the right-matrix's rows are equal, otherwise we can't finish the operations!\n\nThe result is then a matrix that has dimensions of ( ) where is equal to the number of rows of the left-hand side matrix and is equal to the columns of the right-hand side matrix.\n\nDon't worry if you have difficulties imagining the multiplications inside your head. Just keep trying to do the calculations by hand and return to this page whenever you have difficulties. Over time, matrix multiplication becomes second nature to you.\n\nLet's finish the discussion of matrix-matrix multiplication with a larger example. Try to visualize the pattern using the colors. As a useful exercise, see if you can come up with your own answer of the multiplication and then compare them with the resulting matrix (once you try to do a matrix multiplication by hand you'll quickly get the grasp of them). \\[ \\begin{bmatrix} \\color{red}4 & \\color{red}2 & \\color{red}0 \\\\ \\color{green}0 & \\color{green}8 & \\color{green}1 \\\\ \\color{blue}0 & \\color{blue}1 & \\color{blue}0 \\end{bmatrix} \\cdot \\begin{bmatrix} \\color{red}4 & \\color{green}2 & \\color{blue}1 \\\\ \\color{red}2 & \\color{green}0 & \\color{blue}4 \\\\ \\color{red}9 & \\color{green}4 & \\color{blue}2 \\end{bmatrix} = \\begin{bmatrix} \\color{red}4 \\cdot \\color{red}4 + \\color{red}2 \\cdot \\color{red}2 + \\color{red}0 \\cdot \\color{red}9 & \\color{red}4 \\cdot \\color{green}2 + \\color{red}2 \\cdot \\color{green}0 + \\color{red}0 \\cdot \\color{green}4 & \\color{red}4 \\cdot \\color{blue}1 + \\color{red}2 \\cdot \\color{blue}4 + \\color{red}0 \\cdot \\color{blue}2 \\\\ \\color{green}0 \\cdot \\color{red}4 + \\color{green}8 \\cdot \\color{red}2 + \\color{green}1 \\cdot \\color{red}9 & \\color{green}0 \\cdot \\color{green}2 + \\color{green}8 \\cdot \\color{green}0 + \\color{green}1 \\cdot \\color{green}4 & \\color{green}0 \\cdot \\color{blue}1 + \\color{green}8 \\cdot \\color{blue}4 + \\color{green}1 \\cdot \\color{blue}2 \\\\ \\color{blue}0 \\cdot \\color{red}4 + \\color{blue}1 \\cdot \\color{red}2 + \\color{blue}0 \\cdot \\color{red}9 & \\color{blue}0 \\cdot \\color{green}2 + \\color{blue}1 \\cdot \\color{green}0 + \\color{blue}0 \\cdot \\color{green}4 & \\color{blue}0 \\cdot \\color{blue}1 + \\color{blue}1 \\cdot \\color{blue}4 + \\color{blue}0 \\cdot \\color{blue}2 \\end{bmatrix} \\\\ = \\begin{bmatrix} 20 & 8 & 12 \\\\ 25 & 4 & 34 \\\\ 2 & 0 & 4 \\end{bmatrix}\\]\n\nAs you can see, matrix-matrix multiplication is quite a cumbersome process and very prone to errors (which is why we usually let computers do this) and this gets problematic real quick when the matrices become larger. If you're still thirsty for more and you're curious about some more of the mathematical properties of matrices I strongly suggest you take a look at these Khan Academy videos about matrices.\n\nAnyways, now that we know how to multiply matrices together, we can start getting to the good stuff.\n\nUp until now we've had our fair share of vectors. We used them to represent positions, colors and even texture coordinates. Let's move a bit further down the rabbit hole and tell you that a vector is basically a matrix where is the vector's number of components (also known as an vector). If you think about it, it makes a lot of sense. Vectors are just like matrices an array of numbers, but with only 1 column. So, how does this new piece of information help us? Well, if we have a matrix we can multiply this matrix with our vector, since the columns of the matrix are equal to the number of rows of the vector, thus matrix multiplication is defined.\n\nBut why do we care if we can multiply matrices with a vector? Well, it just so happens that there are lots of interesting 2D/3D transformations we can place inside a matrix, and multiplying that matrix with a vector then transforms that vector. In case you're still a bit confused, let's start with a few examples and you'll soon see what we mean.\n\nIn OpenGL we usually work with transformation matrices for several reasons and one of them is that most of the vectors are of size 4. The most simple transformation matrix that we can think of is the . The identity matrix is an matrix with only 0s except on its diagonal. As you'll see, this transformation matrix leaves a vector completely unharmed: \\[ \\begin{bmatrix} \\color{red}1 & \\color{red}0 & \\color{red}0 & \\color{red}0 \\\\ \\color{green}0 & \\color{green}1 & \\color{green}0 & \\color{green}0 \\\\ \\color{blue}0 & \\color{blue}0 & \\color{blue}1 & \\color{blue}0 \\\\ \\color{purple}0 & \\color{purple}0 & \\color{purple}0 & \\color{purple}1 \\end{bmatrix} \\cdot \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\\\ 4 \\end{bmatrix} = \\begin{bmatrix} \\color{red}1 \\cdot 1 \\\\ \\color{green}1 \\cdot 2 \\\\ \\color{blue}1 \\cdot 3 \\\\ \\color{purple}1 \\cdot 4 \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\\\ 4 \\end{bmatrix} \\] The vector is completely untouched. This becomes obvious from the rules of multiplication: the first result element is each individual element of the first row of the matrix multiplied with each element of the vector. Since each of the row's elements are 0 except the first one, we get: \\(\\color{red}1\\cdot1 + \\color{red}0\\cdot2 + \\color{red}0\\cdot3 + \\color{red}0\\cdot4 = 1\\) and the same applies for the other 3 elements of the vector.\n\nWhen we're scaling a vector we are increasing the length of the arrow by the amount we'd like to scale, keeping its direction the same. Since we're working in either 2 or 3 dimensions we can define scaling by a vector of 2 or 3 scaling variables, each scaling one axis ( , or ).\n\nLet's try scaling the vector \\(\\color{red}{\\bar{v}} = (3,2)\\). We will scale the vector along the x-axis by , thus making it twice as narrow; and we'll scale the vector by along the y-axis, making it twice as high. Let's see what it looks like if we scale the vector by as \\(\\color{blue}{\\bar{s}}\\):\n\nKeep in mind that OpenGL usually operates in 3D space so for this 2D case we could set the z-axis scale to , leaving it unharmed. The scaling operation we just performed is a scale, because the scaling factor is not the same for each axis. If the scalar would be equal on all axes it would be called a .\n\nLet's start building a transformation matrix that does the scaling for us. We saw from the identity matrix that each of the diagonal elements were multiplied with its corresponding vector element. What if we were to change the s in the identity matrix to s? In that case, we would be multiplying each of the vector elements by a value of and thus effectively uniformly scale the vector by 3. If we represent the scaling variables as \\( (\\color{red}{S_1}, \\color{green}{S_2}, \\color{blue}{S_3}) \\) we can define a scaling matrix on any vector \\((x,y,z)\\) as: \\[\\begin{bmatrix} \\color{red}{S_1} & \\color{red}0 & \\color{red}0 & \\color{red}0 \\\\ \\color{green}0 & \\color{green}{S_2} & \\color{green}0 & \\color{green}0 \\\\ \\color{blue}0 & \\color{blue}0 & \\color{blue}{S_3} & \\color{blue}0 \\\\ \\color{purple}0 & \\color{purple}0 & \\color{purple}0 & \\color{purple}1 \\end{bmatrix} \\cdot \\begin{pmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} \\color{red}{S_1} \\cdot x \\\\ \\color{green}{S_2} \\cdot y \\\\ \\color{blue}{S_3} \\cdot z \\\\ 1 \\end{pmatrix} \\] Note that we keep the 4th scaling value . The component is used for other purposes as we'll see later on.\n\nis the process of adding another vector on top of the original vector to return a new vector with a different position, thus moving the vector based on a translation vector. We've already discussed vector addition so this shouldn't be too new.\n\nJust like the scaling matrix there are several locations on a 4-by-4 matrix that we can use to perform certain operations and for translation those are the top-3 values of the 4th column. If we represent the translation vector as \\((\\color{red}{T_x},\\color{green}{T_y},\\color{blue}{T_z})\\) we can define the translation matrix by: \\[\\begin{bmatrix} \\color{red}1 & \\color{red}0 & \\color{red}0 & \\color{red}{T_x} \\\\ \\color{green}0 & \\color{green}1 & \\color{green}0 & \\color{green}{T_y} \\\\ \\color{blue}0 & \\color{blue}0 & \\color{blue}1 & \\color{blue}{T_z} \\\\ \\color{purple}0 & \\color{purple}0 & \\color{purple}0 & \\color{purple}1 \\end{bmatrix} \\cdot \\begin{pmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} x + \\color{red}{T_x} \\\\ y + \\color{green}{T_y} \\\\ z + \\color{blue}{T_z} \\\\ 1 \\end{pmatrix} \\] This works because all of the translation values are multiplied by the vector's column and added to the vector's original values (remember the matrix-multiplication rules). This wouldn't have been possible with a 3-by-3 matrix.\n\nWith a translation matrix we can move objects in any of the 3 axis directions ( , , ), making it a very useful transformation matrix for our transformation toolkit.\n\nThe last few transformations were relatively easy to understand and visualize in 2D or 3D space, but rotations are a bit trickier. If you want to know exactly how these matrices are constructed I'd recommend that you watch the rotation items of Khan Academy's linear algebra videos.\n\nFirst let's define what a rotation of a vector actually is. A rotation in 2D or 3D is represented with an . An angle could be in degrees or radians where a whole circle has 360 degrees or 2 PI radians. I prefer explaining rotations using degrees as we're generally more accustomed to them. Most rotation functions require an angle in radians, but luckily degrees are easily converted to radians: \n\n \n\n \n\n Where equals (rounded) . Rotating half a circle rotates us 360/2 = 180 degrees and rotating 1/5th to the right means we rotate 360/5 = 72 degrees to the right. This is demonstrated for a basic 2D vector where \\(\\color{red}{\\bar{v}}\\) is rotated 72 degrees to the right, or clockwise, from \\(\\color{green}{\\bar{k}}\\):\n\nRotations in 3D are specified with an angle and a . The angle specified will rotate the object along the rotation axis given. Try to visualize this by spinning your head a certain degree while continually looking down a single rotation axis. When rotating 2D vectors in a 3D world for example, we set the rotation axis to the z-axis (try to visualize this).\n\nUsing trigonometry it is possible to transform vectors to newly rotated vectors given an angle. This is usually done via a smart combination of the and functions (commonly abbreviated to and ). A discussion of how the rotation matrices are generated is out of the scope of this chapter.\n\nA rotation matrix is defined for each unit axis in 3D space where the angle is represented as the theta symbol \\(\\theta\\).\n\nUsing the rotation matrices we can transform our position vectors around one of the three unit axes. To rotate around an arbitrary 3D axis we can combine all 3 them by first rotating around the X-axis, then Y and then Z for example. However, this quickly introduces a problem called . We won't discuss the details, but a better solution is to rotate around an arbitrary unit axis e.g. (note that this is a unit vector) right away instead of combining the rotation matrices. Such a (verbose) matrix exists and is given below with \\((\\color{red}{R_x}, \\color{green}{R_y}, \\color{blue}{R_z})\\) as the arbitrary rotation axis: \\[\\begin{bmatrix} \\cos \\theta + \\color{red}{R_x}^2(1 - \\cos \\theta) & \\color{red}{R_x}\\color{green}{R_y}(1 - \\cos \\theta) - \\color{blue}{R_z} \\sin \\theta & \\color{red}{R_x}\\color{blue}{R_z}(1 - \\cos \\theta) + \\color{green}{R_y} \\sin \\theta & 0 \\\\ \\color{green}{R_y}\\color{red}{R_x} (1 - \\cos \\theta) + \\color{blue}{R_z} \\sin \\theta & \\cos \\theta + \\color{green}{R_y}^2(1 - \\cos \\theta) & \\color{green}{R_y}\\color{blue}{R_z}(1 - \\cos \\theta) - \\color{red}{R_x} \\sin \\theta & 0 \\\\ \\color{blue}{R_z}\\color{red}{R_x}(1 - \\cos \\theta) - \\color{green}{R_y} \\sin \\theta & \\color{blue}{R_z}\\color{green}{R_y}(1 - \\cos \\theta) + \\color{red}{R_x} \\sin \\theta & \\cos \\theta + \\color{blue}{R_z}^2(1 - \\cos \\theta) & 0 \\\\ 0 & 0 & 0 & 1 \\end{bmatrix}\\] A mathematical discussion of generating such a matrix is out of the scope of this chapter. Keep in mind that even this matrix does not completely prevent gimbal lock (although it gets a lot harder). To truly prevent Gimbal locks we have to represent rotations using , that are not only safer, but also more computationally friendly. However, a discussion of quaternions is out of this chapter's scope.\n\nThe true power from using matrices for transformations is that we can combine multiple transformations in a single matrix thanks to matrix-matrix multiplication. Let's see if we can generate a transformation matrix that combines several transformations. Say we have a vector and we want to scale it by 2 and then translate it by . We need a translation and a scaling matrix for our required steps. The resulting transformation matrix would then look like: \\[Trans . Scale = \\begin{bmatrix} \\color{red}1 & \\color{red}0 & \\color{red}0 & \\color{red}1 \\\\ \\color{green}0 & \\color{green}1 & \\color{green}0 & \\color{green}2 \\\\ \\color{blue}0 & \\color{blue}0 & \\color{blue}1 & \\color{blue}3 \\\\ \\color{purple}0 & \\color{purple}0 & \\color{purple}0 & \\color{purple}1 \\end{bmatrix} . \\begin{bmatrix} \\color{red}2 & \\color{red}0 & \\color{red}0 & \\color{red}0 \\\\ \\color{green}0 & \\color{green}2 & \\color{green}0 & \\color{green}0 \\\\ \\color{blue}0 & \\color{blue}0 & \\color{blue}2 & \\color{blue}0 \\\\ \\color{purple}0 & \\color{purple}0 & \\color{purple}0 & \\color{purple}1 \\end{bmatrix} = \\begin{bmatrix} \\color{red}2 & \\color{red}0 & \\color{red}0 & \\color{red}1 \\\\ \\color{green}0 & \\color{green}2 & \\color{green}0 & \\color{green}2 \\\\ \\color{blue}0 & \\color{blue}0 & \\color{blue}2 & \\color{blue}3 \\\\ \\color{purple}0 & \\color{purple}0 & \\color{purple}0 & \\color{purple}1 \\end{bmatrix} \\] Note that we first do a translation and then a scale transformation when multiplying matrices. Matrix multiplication is not commutative, which means their order is important. When multiplying matrices the right-most matrix is first multiplied with the vector so you should read the multiplications from right to left. It is advised to first do scaling operations, then rotations and lastly translations when combining matrices otherwise they may (negatively) affect each other. For example, if you would first do a translation and then scale, the translation vector would also scale!\n\nRunning the final transformation matrix on our vector results in the following vector: \\[\\begin{bmatrix} \\color{red}2 & \\color{red}0 & \\color{red}0 & \\color{red}1 \\\\ \\color{green}0 & \\color{green}2 & \\color{green}0 & \\color{green}2 \\\\ \\color{blue}0 & \\color{blue}0 & \\color{blue}2 & \\color{blue}3 \\\\ \\color{purple}0 & \\color{purple}0 & \\color{purple}0 & \\color{purple}1 \\end{bmatrix} . \\begin{bmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} \\color{red}2x + \\color{red}1 \\\\ \\color{green}2y + \\color{green}2 \\\\ \\color{blue}2z + \\color{blue}3 \\\\ 1 \\end{bmatrix} \\] Great! The vector is first scaled by two and then translated by .\n\nNow that we've explained all the theory behind transformations, it's time to see how we can actually use this knowledge to our advantage. OpenGL does not have any form of matrix or vector knowledge built in, so we have to define our own mathematics classes and functions. In this book we'd rather abstract from all the tiny mathematical details and simply use pre-made mathematics libraries. Luckily, there is an easy-to-use and tailored-for-OpenGL mathematics library called GLM.\n\nGLM stands for OpenGL Mathematics and is a header-only library, which means that we only have to include the proper header files and we're done; no linking and compiling necessary. GLM can be downloaded from their website. Copy the root directory of the header files into your includes folder and let's get rolling.\n\nMost of GLM's functionality that we need can be found in 3 headers files that we'll include as follows:\n\nLet's see if we can put our transformation knowledge to good use by translating a vector of by (note that we define it as a with its homogeneous coordinate set to :\n\nWe first define a vector named using GLM's built-in vector class. Next we define a and explicitly initialize it to the identity matrix by initializing the matrix's diagonals to ; if we do not initialize it to the identity matrix the matrix would be a null matrix (all elements ) and all subsequent matrix operations would end up a null matrix as well.\n\nThe next step is to create a transformation matrix by passing our identity matrix to the function, together with a translation vector (the given matrix is then multiplied with a translation matrix and the resulting matrix is returned). \n\n Then we multiply our vector by the transformation matrix and output the result. If we still remember how matrix translation works then the resulting vector should be which is . This snippet of code outputs so the translation matrix did its job.\n\nLet's do something more interesting and scale and rotate the container object from the previous chapter:\n\nFirst we scale the container by on each axis and then rotate the container degrees around the Z-axis. GLM expects its angles in radians so we convert the degrees to radians using . Note that the textured rectangle is on the XY plane so we want to rotate around the Z-axis. Keep in mind that the axis that we rotate around should be a unit vector, so be sure to normalize the vector first if you're not rotating around the X, Y, or Z axis. Because we pass the matrix to each of GLM's functions, GLM automatically multiples the matrices together, resulting in a transformation matrix that combines all the transformations.\n\nThe next big question is: how do we get the transformation matrix to the shaders? We shortly mentioned before that GLSL also has a type. So we'll adapt the vertex shader to accept a uniform variable and multiply the position vector by the matrix uniform:\n\nWe added the uniform and multiplied the position vector with the transformation matrix before passing it to . Our container should now be twice as small and rotated degrees (tilted to the left). We still need to pass the transformation matrix to the shader though:\n\nWe first query the location of the uniform variable and then send the matrix data to the shaders using with as its postfix. The first argument should be familiar by now which is the uniform's location. The second argument tells OpenGL how many matrices we'd like to send, which is . The third argument asks us if we want to transpose our matrix, that is to swap the columns and rows. OpenGL developers often use an internal matrix layout called which is the default matrix layout in GLM so there is no need to transpose the matrices; we can keep it at . The last parameter is the actual matrix data, but GLM stores their matrices' data in a way that doesn't always match OpenGL's expectations so we first convert the data with GLM's built-in function .\n\nWe created a transformation matrix, declared a uniform in the vertex shader and sent the matrix to the shaders where we transform our vertex coordinates. The result should look something like this:\n\nPerfect! Our container is indeed tilted to the left and twice as small so the transformation was successful. Let's get a little more funky and see if we can rotate the container over time, and for fun we'll also reposition the container at the bottom-right side of the window. To rotate the container over time we have to update the transformation matrix in the render loop because it needs to update each frame. We use GLFW's time function to get an angle over time:\n\nKeep in mind that in the previous case we could declare the transformation matrix anywhere, but now we have to create it every iteration to continuously update the rotation. This means we have to re-create the transformation matrix in each iteration of the render loop. Usually when rendering scenes we have several transformation matrices that are re-created with new values each frame.\n\nHere we first rotate the container around the origin and once it's rotated, we translate its rotated version to the bottom-right corner of the screen. Remember that the actual transformation order should be read in reverse: even though in code we first translate and then later rotate, the actual transformations first apply a rotation and then a translation. Understanding all these combinations of transformations and how they apply to objects is difficult to understand. Try and experiment with transformations like these and you'll quickly get a grasp of it.\n\nIf you did things right you should get the following result:\n\nAnd there you have it. A translated container that's rotated over time, all done by a single transformation matrix! Now you can see why matrices are such a powerful construct in graphics land. We can define an infinite amount of transformations and combine them all in a single matrix that we can re-use as often as we'd like. Using transformations like this in the vertex shader saves us the effort of re-defining the vertex data and saves us some processing time as well, since we don't have to re-send our data all the time (which is quite slow); all we need to do is update the transformation uniform.\n\nIf you didn't get the right result or you're stuck somewhere else, take a look at the source code and the updated shader class.\n\nIn the next chapter we'll discuss how we can use matrices to define different coordinate spaces for our vertices. This will be our first step into 3D graphics!\n• Essence of Linear Algebra: great video tutorial series by Grant Sanderson about the underlying mathematics of transformations and linear algebra.\n• Matrix Multiplication XYZ: check out this amazing interactive visual tool for showcasing matrix multiplication. Trying a few of these should help solidify your understanding.\n• Using the last transformation on the container, try switching the order around by first rotating and then translating. See what happens and try to reason why this happens: solution.\n• Try drawing a second container with another call to but place it at a different position using transformations only. Make sure this second container is placed at the top-left of the window and instead of rotating, scale it over time (using the function is useful here; note that using will cause the object to invert as soon as a negative scale is applied): solution."
    },
    {
        "link": "https://stackoverflow.com/questions/19966525/glm-keeps-providing-choppy-transformation-and-rotations",
        "document": "Here's some debugging help so as not to stay buried in the comments:\n• None When the timestep is over some given threshold that you determine is enough to cause a \"jump\", pause the program.\n• None If the bug is coming from big time steps, track which functions take what amount of time and see if any take an unusual amount of time. i. If you have a profiler, use it here. ii. If not, record the time before and after each function and calculate the duration. Sum up these timesteps at the end of each frame so you can still find that total delta time that would indicate a jump.\n• None If you trace back your bug to some library/system/other call that you have no control over, make sure you're passing those functions (and really all functions) good data. i. Are you getting away with using corrupt memory somewhere? ii. Does bug only apply only to rotations? What about translations / scales? iii. Does this bug happen if you just run your program with trying OpenGL things? It could be an error with, say, your windowing, where you're missing some update call or something trivial like that."
    },
    {
        "link": "https://reddit.com/r/opengl/comments/o895kh/help_recalculating_aabb_boundingboxes",
        "document": "I'm new to openGL and i have a problem.\n\nI created a bounding using this code i found on the internet:\n\nAnd it works perfectly when I render a model at (0, 0, 0);But as soon as I move the object, the bounding boxes are not aligned to the model anymore.\n\nI've read on a topic that, for each frame i need to re-calculate the hitbox position by multiplying every vertex of my model by his matrix, but i dont know how to do that.\n\nI've tried this but it doesnt works:\n\nAnd when i want to move an object, i do this:"
    },
    {
        "link": "https://stackoverflow.com/questions/6053522/how-to-recalculate-axis-aligned-bounding-box-after-translate-rotate",
        "document": "When I first load my object I calculate the initial AABB with the maximum and minimum (x,y,z) points. But this is in object space and the object moves around the world and more importantly, rotates.\n\nHow do I recalculate the new AABB every time the object is translated/rotated? This happens basically in every frame. Is it going to be a very intensive operation to recalculate the new AABB every frame? If so, what would be the alternative?\n\nI know AABBs will make my collision detection less accurate, but it's easier to implement the collision detection code than OBBs and I want to take this one step at a time.\n\nHere's my current code after some insight from the answers below:\n\nBut it doesn't work as it should... What I'm doing wrong?"
    },
    {
        "link": "https://reddit.com/r/opengl/comments/qwf9pf/how_to_align_a_bounding_box_to_an_object",
        "document": "I have a bounding box which was computed from a mesh/model's max and min vertices as normally would in 3D space. I want the bounding box to be aligned to a model's orientation. by orientation i meant the position, right, up and look/forward vector of the object, I dont have the angle rotations of the axis just the orientation vectors\n\nHow can I do it?"
    },
    {
        "link": "https://stackoverflow.com/questions/34619341/can-axis-aligned-bounding-boxes-be-recalculated-after-rotation-of-object-using-t",
        "document": "I have my axis aligned bounding boxes expressed as 2 3D vectors, one holding the left-down-back point (minimum) and one the right-up-front point (maximum).\n\nAfter rotating the object in any direction, the aabb that encompasses it must, be recalculated to fit good. Take this image for example:\n\nCan this be calculated using the two starting points that i have and the angle + direction of the rotation(s)? If so how? What is the most efficient way?\n\nP.S. I am using glm for my math, so any ready way to do this using glm would be really useful!"
    },
    {
        "link": "https://gamedev.net/forums/topic/551119-calculating-axis-aligned-bounding-boxes-after-rotation",
        "document": "Is there an efficient method to calculate a new axis aligned bounding box after an AABB has been affected by a rotation transformation? The first method that came to mind was to calculate the position of all 8 vertices of the AABB (3D), transform them, and then generate a new AABB from minimum and maximum points. There's no doubt a much better method though. I have another question that I'm curious about; Suppose you have an object of arbitrary shape that is enclosed in the smallest AABB that can hold it. You then apply a sequence of arbitrary transformations to the object (skew, non-uniform scaling, etc) and also to the AABB, which results in it not being axis aligned or rectangular anymore. You then create a new AABB to enclose the distorted AABB. Would the new AABB be guaranteed to be the smallest AABB that can hold the new object? The idea is to apply transformations to an object and recalculate it's AABB without needing to do O(n) comparisons on the object's vertices.\n\nIs there an efficient method to calculate a new axis aligned bounding box after an AABB has been affected by a rotation transformation? The first method that came to mind was to calculate the position of all 8 vertices of the AABB (3D), transform them, and then generate a new AABB from minimum and maximum points. There's no doubt a much better method though. Yes, it can be done more straightforwardly.\n\n\n\nBasically, once you've rotated your AABB, you have an OBB. There's a simple formula for computing the interval of projection of an OBB with respect to a given axis (I'm not going to type it out at the moment, but just ask if need this formula). To compute the AABB corresponding to an OBB, simply project the OBB (using the aforementioned formula) onto the 3 (or 2 in 2-d) cardinal axes to yield the min and max extents of the AABB.\n\n\n\nNote that the projection formula simplifies considerably when the input axes are cardinal axes, so an actual implementation of this algorithm will usually be both simple and efficient. Yes, it can be done more straightforwardly.Basically, once you've rotated your AABB, you have an OBB. There's a simple formula for computing the interval of projection of an OBB with respect to a given axis (I'm not going to type it out at the moment, but just ask if need this formula). To compute the AABB corresponding to an OBB, simply project the OBB (using the aforementioned formula) onto the 3 (or 2 in 2-d) cardinal axes to yield the min and max extents of the AABB.Note that the projection formula simplifies considerably when the input axes are cardinal axes, so an actual implementation of this algorithm will usually be both simple and efficient.\n\nThanks. But it looks like I'm going to have to loop over the vertices to recalculate the AABB after each transform anyway. At least I only need to do so when rotating the object. Seems that it's trivial to update an AABB if the object was merely scaled/translated.\n\nWell, yeah, translation and scaling don't change the furthest vertices along each axis.\n\n\n\nHmm, if the shape of the object is likely to remain unchanged for sufficient periods of time, it may be worthwhile coming up with an algorithm to create a list of vertices with the ones not capable of being part of a bounding box pruned. Shouldn't be too difficult.\n\nAlso, if you know in advance that your objects do not have excessively large differences in size along different axes (eg the object is likely to be roughly the same length along each axis), then you could encapsulate the rotation in the bounding box (eg use \"bounding cubes\" that are the size of the longest extent of the object along each axis - note that to allow for free rotation this extent would have to be extracted as Euclidean distance between the furthest vertices in the object, not as Manhattan distance along the longest axis!) or - and this might make your collision tests considerably faster - simply use bounding spheres (or at least use them as a method for primary collision tests).\n\n\n\nMy personal experience tells me you should only go into the trouble of using rotated bounding boxes if you're dealing with dynamic geometry whose extents cannot be foreseen and/or very complex geometry in which case you'll probably also want to split up the object into smaller sections (in which case in turn it might be easier to use AABBs), each of which has its own bounding box (as life goes I'd say this is most probably not the case for real-time applications such as games, but rather raytracing purposes, which usually innately assume you'll be dealing with complex geometry).\n\n\n\nOr it might be just that you want to get this working for practice in which case my post is irrelevant and you can ignore it :)\n\nActually I'm making a level editor and calculating bounding boxes is a way of simplifying certain tasks. One of which is detecting/preventing objects from being dragged or scaled outside of the boundaries of the map. AABBs should make this easy to do for translation and scaling, but since rotations are more complicated to handle, I might use bounding spheres as well, which should give me a good approximation of whether a rotated object (about any axis/origin) is still inside the map.\n\nIn what way are you finding them difficult (I never actually needed the myself TBH)? Because of the calculations to compute the the bounding boxes or the collisions themselves?\n\n\n\nAnd I would still consider splitting complicated objects up into a number of smaller BB's.\n\n\n\nPS - what about using a \"soft edge\" in your level editor? Eg when the object's bounding sphere enters the soft edge (which is still part of the map), the editor just says \"object too close to the edge of the map\". Could be far easier to handle.\n\nFor translation and scaling, I perform collision detection with the edge of the scene, in real time as the object is being dragged around. This is always a constant time operation, even when more than one object is selected at once, as I just merge their AABBs. Rotation requires checking every vertex of the objects against the boundaries, every time the objects move. i.e. many times per second as the object is rotated around.\n\nThe translation and scaling collision detection prevents the user from dragging the objects out of bounds, without interrupting the movement process. In my opinion it's the least annoying way of enforcing this restriction. While the object is being rotated, I won't prevent it from going out of bounds, however I plan to detect this and provide some sort of feedback - i.e. a red glow, which indicates that the transform will not be accepted if the user \"drops\" the object there."
    }
]