[
    {
        "link": "https://docs.espressif.com/projects/arduino-esp32/en/latest/api/wifi.html",
        "document": "The Wi-Fi API provides support for the 802.11b/g/n protocol driver. This API includes:\n• None Station mode (STA mode or Wi-Fi client mode). ESP32 connects to an access point\n• None AP mode (aka Soft-AP mode or Access Point mode). Devices connect to the ESP32 In this mode, the ESP32 is configured as an Access Point (AP) and it’s capable of receiving incoming connections from other devices (stations) by providing a Wi-Fi network. This mode can be used for serving an HTTP or HTTPS server inside the ESP32, for example. The STA mode is used to connect the ESP32 to a Wi-Fi network, provided by an Access Point. This is the mode to be used if you want to connect your project to the Internet.\n\nHere are the common APIs that are used for both modes, AP and STA. Registers a caller-supplied function to be called when Wi-Fi events occur. Several forms are available. A similar set of functions are available to remove callbacks: In all cases, the subscribing function accepts an optional event type to invoke the callback only for that specific event; with the default , the callback will be invoked for all Wi-Fi events. Any callback function is given the event type in a parameter. Some of the possible callback function formats also take an (or use which includes both ID and info) which is a union of structs with additional information about different event types. See WiFiGeneric.h for the list of event types and “info” substructures, and also see a full example of event handling: events example. Event callback functions are invoked on a separate thread (FreeRTOS task) independent of the main application thread that runs and . Callback functions must therefore be thread-safe; they must not access shared/global variables directly without locking, and must only call similarly thread-safe functions. Some core operations like are thread-safe but many functions are not. Notably, and are not thread-safe and should never be invoked from a callback thread. Sets the name the DHCP client uses to identify itself. In a typical network setup this will be the name that shows up in the Wi-Fi router’s device list. The hostname must be no longer than 32 characters. If the hostname is never specified, a default one will be assigned based on the chip type and MAC address. The current hostname (default or custom) may be retrieved: The function must be called BEFORE Wi-Fi is started with , , , or . To change the name, reset Wi-Fi with , then proceed with and restart WiFi from scratch. This function is used to set the memory allocation mode for the Wi-Fi buffers.\n• None Set to use the Wi-Fi buffers memory allocation as static.\n• None Set to set the buffers memory allocation to dynamic. The use of dynamic allocation is recommended to save memory and reduce resources usage. However, the dynamic performs slightly slower than the static allocation. Use static allocation if you want to have more performance and if your application is multi-tasking. By default, the memory allocation will be set to dynamic if this function is not being used. Configures the Dual antenna functionality. This function should be used only on the ESP32-WROOM-DA module or any other ESP32 with RF switch.\n• None Configure the GPIO number for the antenna 1 connected to the RF switch (default on ESP32-WROOM-DA)\n• None Configure the GPIO number for the antenna 2 connected to the RF switch (default on ESP32-WROOM-DA)\n• None Set the RX antenna mode. See wifi_rx_ant_t for the options.\n• None Set the TX antenna mode. See wifi_tx_ant_t for the options. Return if the configuration was successful. For the you can use the following configuration:\n• None Selects the antenna 1 for all RX activity.\n• None Selects the antenna 2 for all RX activity. For the you can use the following configuration:\n• None Selects the antenna 1 for all TX activity.\n• None Selects the antenna 2 for all TX activity.\n\nThe allows you to add more than one option for the AP connection while running as a station. To add the AP, use the following function. You can add multiple AP’s and this library will handle the connection. After adding the AP’s, run by the following function. To see how to use the , take a look at the example available.\n\nWiFiAccessPoint.ino creates a WiFi access point and provides a web server on it. 2. Point your web browser to http://192.168.4.1/H to turn the LED on or http://192.168.4.1/L to turn it off Run raw TCP \"GET /H\" and \"GET /L\" on PuTTY terminal with 192.168.4.1 as IP address and 80 as port // Set the GPIO pin where you connected your test LED or comment this line out if your dev board has a built-in LED // Set these to your desired credentials. // You can remove the password parameter if you want the AP to be open. // a valid password must have more than 7 characters // make a String to hold incoming data from the client // if there's bytes to read from the client, // print it out the serial monitor // if the byte is a newline character // if the current line is blank, you got two newline characters in a row. // that's the end of the client HTTP request, so send a response: // HTTP headers always start with a response code (e.g. HTTP/1.1 200 OK) // and a content-type so the client knows what's coming, then a blank line: // the content of the HTTP response follows the header: >here</a> to turn ON the LED.<br>\" >here</a> to turn OFF the LED.<br>\" // The HTTP response ends with another blank line: // break out of the while loop: // if you got a newline, then clear currentLine: // if you got anything else but a carriage return character, // add it to the end of the currentLine // Check to see if the client request was \"GET /H\" or \"GET /L\": // GET /H turns the LED on // GET /L turns the LED off Go to thingspeak.com and create an account if you don't have one already. After logging in, click on the \"New Channel\" button to create a new channel for your data. This is where your data will be stored and displayed. Fill in the Name, Description, and other fields for your channel as desired, then click the \"Save Channel\" button. Take note of the \"Write API Key\" located in the \"API keys\" tab, this is the key you will use to send data to your channel. Replace the channelID from tab \"Channel Settings\" and privateKey with \"Read API Keys\" from \"API Keys\" tab. Replace the host variable with the thingspeak server hostname \"api.thingspeak.com\" Upload the sketch to your ESP32 board and make sure that the board is connected to the internet. The ESP32 should now send data to your Thingspeak channel at the intervals specified by the loop function. Go to the channel view page on thingspeak and check the \"Field1\" for the new incoming data. You can use the data visualization and analysis tools provided by Thingspeak to display and process your data in various ways. Please note, that Thingspeak accepts only integer values. You can later check the values at https://thingspeak.com/channels/2005329 Please note that this public channel can be accessed by anyone and it is possible that more people will write their values. // Change this to your WiFi SSID // Change this to your WiFi password // This should not be changed // This should not be changed // Change this to your channel ID // Change this to your Write API key // Change this to your Read API key // The default example accepts one data filed named \"field1\" // For your own server you can ofcourse create more of them. // Number of results to be read // Field number which will be read out // We start by connecting to a WiFi network // Read all the lines of the reply from server and print them to Serial 6 ARDUINO_EVENT_WIFI_STA_AUTHMODE_CHANGE < the auth mode of AP connected by ESP32 station changed 8 ARDUINO_EVENT_WIFI_STA_LOST_IP < ESP32 station lost IP and the IP is reset to 0 // WARNING: This function is called from a separate FreeRTOS task (thread)! \"Lost IP address and IP address is reset to 0\" // WARNING: This function is called from a separate FreeRTOS task (thread)! // Examples of different ways to register wifi events; // these handlers will be called from another thread."
    },
    {
        "link": "https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/network/esp_wifi.html",
        "document": "Various security modes for the above (WPA, WPA2, WPA3, etc.)\n\nStation/AP-coexistence mode (ESP32 is concurrently an access point and a station connected to another access point).\n\nAP mode (aka Soft-AP mode or Access Point mode). Stations connect to the ESP32.\n\nStation mode (aka STA mode or Wi-Fi client mode). ESP32 connects to an access point.\n\nThe Wi-Fi libraries provide support for configuring and monitoring the ESP32 Wi-Fi networking functionality. This includes configuration for:\n\nSeveral application examples demonstrating the functionality of Wi-Fi library are provided in wifi directory of ESP-IDF repository. Please check the README for more details.\n\nInitialize WiFi Allocate resource for WiFi driver, such as WiFi control structure, RX/TX buffer, WiFi NVS structure etc. This WiFi also starts WiFi task. 1. This API must be called before all other WiFi API can be called 2. Always use WIFI_INIT_CONFIG_DEFAULT macro to initialize the configuration to default values, this can guarantee all the fields get correct value when more fields are added into wifi_init_config_t in future release. If you want to set your own initial values, overwrite the default values which are set by WIFI_INIT_CONFIG_DEFAULT. Please be notified that the field 'magic' of wifi_init_config_t should always be WIFI_INIT_CONFIG_MAGIC! config -- pointer to WiFi initialized configuration structure; can point to a temporary variable. Deinit WiFi Free all resource allocated in esp_wifi_init and stop WiFi task. 1. This API should be called if you want to remove WiFi driver from the system\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n• None others: refer to error code in esp_err.h\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init Start WiFi according to current configuration If mode is WIFI_MODE_STA, it creates station control block and starts station If mode is WIFI_MODE_AP, it creates soft-AP control block and starts soft-AP If mode is WIFI_MODE_APSTA, it creates soft-AP and station control block and starts soft-AP and station If mode is WIFI_MODE_NAN, it creates NAN control block and starts NAN.\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n• None ESP_ERR_INVALID_ARG: It doesn't normally happen, the function called inside the API was passed invalid argument, user should check if the wifi related config is correct Stop WiFi If mode is WIFI_MODE_STA, it stops station and frees station control block If mode is WIFI_MODE_AP, it stops soft-AP and frees soft-AP control block If mode is WIFI_MODE_APSTA, it stops station/soft-AP and frees station/soft-AP control block If mode is WIFI_MODE_NAN, it stops NAN and frees NAN control block.\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init This function will reset settings made using the following APIs:\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init 1. This API only impact WIFI_MODE_STA or WIFI_MODE_APSTA mode 2. If station interface is connected to an AP, call esp_wifi_disconnect to disconnect. 3. The scanning triggered by esp_wifi_scan_start() will not be effective until connection between device and the AP is established. If device is scanning and connecting at the same time, it will abort scanning and return a warning message and error number ESP_ERR_WIFI_STATE. 4. This API attempts to connect to an Access Point (AP) only once. To enable reconnection in case of a connection failure, please use the 'failure_retry_cnt' feature in the 'wifi_sta_config_t'. Users are suggested to implement reconnection logic in their application for scenarios where the specified AP does not exist, or reconnection is desired after the device has received a disconnect event.\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n• None ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start\n• None ESP_ERR_WIFI_SSID: SSID of AP which station connects is invalid\n• None ESP_ERR_WIFI_NOT_INIT: WiFi was not initialized by esp_wifi_init\n• None ESP_ERR_WIFI_NOT_STARTED: WiFi was not started by esp_wifi_start Currently this API is just an stub API. deauthenticate all stations or associated id equals to aid aid -- when aid is 0, deauthenticate all stations, otherwise deauthenticate station whose associated id is aid\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n• None ESP_ERR_WIFI_NOT_STARTED: WiFi was not started by esp_wifi_start If this API is called, the found APs are stored in WiFi driver dynamic allocated memory. And then can be freed in esp_wifi_scan_get_ap_records(), esp_wifi_scan_get_ap_record() or esp_wifi_clear_ap_list(), so call any one to free the memory once the scan is done. The values of maximum active scan time and passive scan time per channel are limited to 1500 milliseconds. Values above 1500ms may cause station to disconnect from AP and are not recommended.\n• None config -- configuration settings for scanning, if set to NULL default settings will be used of which default values are show_hidden:false, scan_type:active, scan_time.active.min:0, scan_time.active.max:120 miliseconds, scan_time.passive:360 miliseconds\n• None block -- if block is true, this API will block the caller until the scan is done, otherwise it will return immediately\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n• None ESP_ERR_WIFI_NOT_STARTED: WiFi was not started by esp_wifi_start\n• None others: refer to error code in esp_err.h\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n• None ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start Get number of APs found in last scan. This API can only be called when the scan is completed, otherwise it may get wrong value. number -- [out] store number of APs found in last scan\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n• None ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start Get AP list found in last scan. This API will free all memory occupied by scanned AP list.\n• None number -- [inout] As input param, it stores max AP number ap_records can hold. As output param, it receives the actual AP number this API returns.\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n• None ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start Get one AP record from the scanned AP list. Different from esp_wifi_scan_get_ap_records(), this API only gets one AP record from the scanned AP list each time. This API will free the memory of one AP record, if the user doesn't get all records in the scannned AP list, then needs to call esp_wifi_clear_ap_list() to free the remaining memory. ap_record -- [out] pointer to one AP record\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n• None ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start\n• None ESP_FAIL: scan APs is NULL, means all AP records fetched or no AP found This API will free all memory occupied by scanned AP list. When the obtained AP list fails, AP records must be cleared,otherwise it may cause memory leakage.\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n• None ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start\n• None ESP_ERR_INVALID_ARG: It doesn't normally happen, the function called inside the API was passed invalid argument, user should check if the wifi related config is correct Get information of AP to which the device is associated with. When the obtained country information is empty, it means that the AP does not carry country information ap_info -- the wifi_ap_record_t to hold AP information sta can get the connected ap's phy mode info through the struct member phy_11b，phy_11g，phy_11n，phy_lr in the wifi_ap_record_t struct. For example, phy_11b = 1 imply that ap support 802.11b mode\n• None ESP_ERR_WIFI_NOT_CONNECT: The station is in disconnect status Set protocol type of specified interface The default protocol is (WIFI_PROTOCOL_11B|WIFI_PROTOCOL_11G|WIFI_PROTOCOL_11N). if CONFIG_SOC_WIFI_HE_SUPPORT, the default protocol is (WIFI_PROTOCOL_11B|WIFI_PROTOCOL_11G|WIFI_PROTOCOL_11N|WIFI_PROTOCOL_11AX). Support 802.11b or 802.11bg or 802.11bgn or 802.11bgnax or LR mode\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n• None others: refer to error codes in esp_err.h Get the current protocol bitmap of the specified interface.\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n• None others: refer to error codes in esp_err.h Set the bandwidth of specified interface. 1. API return false if try to configure an interface that is not enabled 2. WIFI_BW_HT40 is supported only when the interface support 11N\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n• None others: refer to error codes in esp_err.h Get the bandwidth of specified interface. 1. API return false if try to get a interface that is not enable\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init 1. This API should be called after esp_wifi_start() and before esp_wifi_stop() 2. When device is in STA mode, this API should not be called when STA is scanning or connecting to an external AP 3. When device is in softAP mode, this API should not be called when softAP has connected to external STAs 4. When device is in STA+softAP mode, this API should not be called when in the scenarios described above 5. The channel info set by this API will not be stored in NVS. So If you want to remeber the channel used before wifi stop, you need to call this API again after wifi start, or you can call to store the channel info in NVS.\n• None primary -- for HT20, primary is the channel number, for HT40, primary is the primary channel\n• None second -- for HT20, second is ignored, for HT40, second is the second channel\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n• None ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start Get the primary/secondary channel of device. 1. API return false if try to get a interface that is not enable\n• None second -- [out] store current second channel\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init 1. It is discouraged to call this API since this doesn't validate the per-country rules, it's up to the user to fill in all fields according to local regulations. Please use esp_wifi_set_country_code instead. 3. The third octet of country code string is one of the following: ' ', 'O', 'I', 'X', otherwise it is considered as ' '. 4. When the country policy is WIFI_COUNTRY_POLICY_AUTO, the country info of the AP to which the station is connected is used. E.g. if the configured country info is {.cc=\"US\", .schan=1, .nchan=11} and the country info of the AP to which the station is connected is {.cc=\"JP\", .schan=1, .nchan=14} then the country info that will be used is {.cc=\"JP\", .schan=1, .nchan=14}. If the station disconnected from the AP the country info is set back to the country info of the station automatically, {.cc=\"US\", .schan=1, .nchan=11} in the example. 5. When the country policy is WIFI_COUNTRY_POLICY_MANUAL, then the configured country info is used always. 6. When the country info is changed because of configuration or because the station connects to a different external AP, the country IE in probe response/beacon of the soft-AP is also changed. 7. The country configuration is stored into flash. 8. When this API is called, the PHY init data will switch to the PHY init data type corresponding to the country info.\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init 1. This API can only be called when the interface is disabled 2. Above mentioned interfaces have different MAC addresses, do not set them to be the same. 3. The bit 0 of the first byte of MAC address can not be 1. For example, the MAC address can set to be \"1a:XX:XX:XX:XX:XX\", but can not be \"15:XX:XX:XX:XX:XX\".\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n• None others: refer to error codes in esp_err.h Get mac of specified interface.\n• None mac -- [out] store mac of the interface ifx\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init Register the RX callback function in the promiscuous mode. Each time a packet is received, the registered callback function will be called.\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init en -- [out] store the current status of promiscuous mode\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init The default filter is to filter all packets except WIFI_PKT_MISC\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init filter -- [out] store the current status of promiscuous filter\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init Enable subtype filter of the control packet in promiscuous mode. The default filter is to filter none control packet. filter -- the subtype of the control packet filtered in promiscuous mode.\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init Get the subtype filter of the control packet in promiscuous mode. filter -- [out] store the current status of subtype filter of the control packet in promiscuous mode\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init Set the configuration of the STA, AP or NAN. 1. This API can be called only when specified interface is enabled, otherwise, API fail 2. For station configuration, bssid_set needs to be 0; and it needs to be 1 only when users need to check the MAC address of the AP. 3. ESP devices are limited to only one channel, so when in the soft-AP+station mode, the soft-AP will adjust its channel automatically to be the same as the channel of the station. 4. The configuration will be stored in NVS for station and soft-AP\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n• None others: refer to the error code in esp_err.h Get configuration of specified interface.\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init Get STAs associated with soft-AP. sta -- [out] station list ap can get the connected sta's phy mode info through the struct member phy_11b，phy_11g，phy_11n，phy_lr in the wifi_sta_info_t struct. For example, phy_11b = 1 imply that sta support 802.11b mode\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init Get AID of STA connected with soft-AP.\n• None aid -- [out] Store the AID corresponding to STA mac\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init 1. The default value is WIFI_STORAGE_FLASH\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n• None enable -- If true, specified IE is enabled. If false, specified IE is removed.\n• None type -- Information Element type. Determines the frame type to associate with the IE.\n• None idx -- Index to set or clear. Each IE type can be associated with up to two elements (indices 0 & 1).\n• None vnd_ie -- Pointer to vendor specific element data. First 6 bytes should be a header with fields matching vendor_ie_data_t. If enable is false, this argument is ignored and can be NULL. Data does not need to remain valid after the function returns.\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init()\n• None ESP_ERR_INVALID_ARG: Invalid argument, including if first byte of vnd_ie is not WIFI_VENDOR_IE_ELEMENT_ID (0xDD) or second byte is an invalid length.\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init 1. Maximum power before wifi startup is limited by PHY init data bin. 2. The value set by this API will be mapped to the max_tx_power of the structure wifi_country_t variable. 4. Param power unit is 0.25dBm, range is [8, 84] corresponding to 2dBm - 20dBm. 5. Relationship between set value and actual value. As follows: {set value range, actual value} = {{[8, 19],8}, {[20, 27],20}, {[28, 33],28}, {[34, 43],34}, {[44, 51],44}, {[52, 55],52}, {[56, 59],56}, {[60, 65],60}, {[66, 71],66}, {[72, 79],72}, {[80, 84],80}}.\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n• None ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start\n• None ESP_ERR_INVALID_ARG: invalid argument, e.g. parameter is out of range\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n• None ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start Set mask to enable or disable some WiFi events. 1. Mask can be created by logical OR of various WIFI_EVENT_MASK_ constants. Events which have corresponding bit set in the mask will not be delivered to the system event handler. 3. There may be lots of stations sending probe request data around. Don't unmask this event unless you need to receive probe request data.\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init Currently only support for sending beacon/probe request/probe response/action and non-QoS data frame\n• None ifx -- interface if the Wi-Fi mode is Station, the ifx should be WIFI_IF_STA. If the Wi-Fi mode is SoftAP, the ifx should be WIFI_IF_AP. If the Wi-Fi mode is Station+SoftAP, the ifx should be WIFI_IF_STA or WIFI_IF_AP. If the ifx is wrong, the API returns ESP_ERR_WIFI_IF.\n• None len -- the length of raw buffer, the len must be <= 1500 Bytes and >= 24 Bytes\n• None en_sys_seq -- indicate whether use the internal sequence number. If en_sys_seq is false, the sequence in raw buffer is unchanged, otherwise it will be overwritten by WiFi driver with the system sequence number. Generally, if esp_wifi_80211_tx is called before the Wi-Fi connection has been set up, both en_sys_seq==true and en_sys_seq==false are fine. However, if the API is called after the Wi-Fi connection has been set up, en_sys_seq must be true, otherwise ESP_ERR_INVALID_ARG is returned.\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n• None ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start or promiscuous mode is not enabled\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n• None ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start or promiscuous mode is not enabled\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init Get the TSF time In Station mode or SoftAP+Station mode if station is not connected or station doesn't receive at least one beacon after connected, will return 0. Enabling power save may cause the return value inaccurate, except WiFi modem sleep interface -- The interface whose tsf_time is to be retrieved. Set the inactive time of the STA or AP. 1. For Station, If the station does not receive a beacon frame from the connected SoftAP during the inactive time, disconnect from SoftAP. Default 6s. 2. For SoftAP, If the softAP doesn't receive any data from the connected STA during inactive time, the softAP will force deauth the STA. Default is 300s. 3. The inactive time configuration is not stored into flash\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n• None ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start\n• None ESP_ERR_INVALID_ARG: invalid argument, For Station, if sec is less than 3. For SoftAP, if sec is less than 10. Get inactive time of specified interface.\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n• None ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start Set RSSI threshold, if average rssi gets lower than threshold, WiFi task will post event WIFI_EVENT_STA_BSS_RSSI_LOW. If the user wants to receive another WIFI_EVENT_STA_BSS_RSSI_LOW event after receiving one, this API needs to be called again with an updated/same RSSI threshold. rssi -- threshold value in dbm between -100 to 10 Note that in some rare cases where signal strength is very strong, rssi values can be slightly positive.\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init Start an FTM Initiator session by sending FTM request If successful, event WIFI_EVENT_FTM_REPORT is generated with the result of the FTM procedure. 1. Use this API only in Station mode. 2. If FTM is initiated on a different channel than Station is connected in or internal SoftAP is started in, FTM defaults to a single burst in ASAP mode. This API works only on FTM Initiator Set offset in cm for FTM Responder. An equivalent offset is calculated in picoseconds and added in TOD of FTM Measurement frame (T1). Use this API only in AP mode before performing FTM as responder offset_cm -- T1 Offset to be added in centimeters 1. To get the FTM report, user first needs to allocate a buffer of size (sizeof(wifi_ftm_report_entry_t) * num_entries) where the API will fill up to num_entries valid FTM measurements in the buffer. Total number of entries can be found in the event WIFI_EVENT_FTM_REPORT as ftm_report_num_entries 2. The internal FTM report is freed upon use of this API which means the API can only be used once afer every FTM session initiated 3. Passing the buffer as NULL merely frees the FTM report\n• None report -- Pointer to the buffer for receiving the FTM report\n• None num_entries -- Number of FTM report entries to be filled in the report Enable or disable 11b rate of specified interface. 1. This API should be called after esp_wifi_init() and before esp_wifi_start(). 2. Only when really need to disable 11b rate call this API otherwise don't call this. Set wake interval for connectionless modules to wake up periodically. 1. Only one wake interval for all connectionless modules. 2. This configuration could work at connected status. When ESP_WIFI_STA_DISCONNECTED_PM_ENABLE is enabled, this configuration could work at disconnected status. 3. Event WIFI_EVENT_CONNECTIONLESS_MODULE_WAKE_INTERVAL_START would be posted each time wake interval starts. 4. Recommend to configure interval in multiples of hundred. (e.g. 100ms) 5. Recommend to configure interval to ESP_WIFI_CONNECTIONLESS_INTERVAL_DEFAULT_MODE to get stable performance at coexistence mode. wake_interval -- Milliseconds after would the chip wake up, from 1 to 65535. Request extra reference of Wi-Fi radio. Wi-Fi keep active state(RF opened) to be able to receive packets. Please pair the use of with .\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n• None ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start Release extra reference of Wi-Fi radio. Wi-Fi go to sleep state(RF closed) if no more use of radio. Please pair the use of with .\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n• None ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start 1. When ieee80211d_enabled, the country info of the AP to which the station is connected is used. E.g. if the configured country is US and the country info of the AP to which the station is connected is JP then the country info that will be used is JP. If the station disconnected from the AP the country info is set back to the country info of the station automatically, US in the example. 2. When ieee80211d_enabled is disabled, then the configured country info is used always. 3. When the country info is changed because of configuration or because the station connects to a different external AP, the country IE in probe response/beacon of the soft-AP is also changed. 4. The country configuration is stored into flash. 5. When this API is called, the PHY init data will switch to the PHY init data type corresponding to the country info. 7. When country code \"01\" (world safe mode) is set, SoftAP mode won't contain country IE. 8. The default country is \"01\" (world safe mode) and ieee80211d_enabled is TRUE. 9. The third octet of country code string is one of the following: ' ', 'O', 'I', 'X', otherwise it is considered as ' '.\n• None ieee80211d_enabled -- 802.11d is enabled or not\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init\n• None ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init 1. This API should be called after esp_wifi_init() and before esp_wifi_start(). 2. Can not set 80211 tx rate under 11AX protocol, you can use esp_wifi_config_80211_tx instead. Config 80211 tx rate and phymode of specified interface. 1. This API should be called after esp_wifi_init() and before esp_wifi_start(). This API should be called after esp_wifi_set_config() and before esp_wifi_start(). Get the Association id assigned to STA by AP. aid = 0 if station is not connected to AP. Get the negotiated phymode after connection. This API should be called after esp_wifi_start(). enabled -- Dynamic carrier sense is enabled or not. Get the rssi information of AP to which the device is associated with. 1. This API should be called after station connected to AP. 2. Use this API only in WIFI_MODE_STA or WIFI_MODE_APSTA mode. rssi -- store the rssi info received from last beacon.\n\nThis field is used for getting WiFi maximum transmitting power, call esp_wifi_set_max_tx_power to set the maximum transmitting power. maximum active scan time per channel, units: millisecond, values above 1500ms may cause station to disconnect from AP and are not recommended. passive scan time per channel, units: millisecond, values above 1500ms may cause station to disconnect from AP and are not recommended. enable to scan AP whose SSID is hidden an unsigned integer whose value is the BSS Color of the BSS corresponding to the AP indicate if an AID assignment rule based on the BSS color indicate if the use of BSS color is disabled signal strength of AP. Note that in some rare cases where signal strength is very strong, rssi values can be slightly positive antenna used to receive beacon from AP bit: 0 flag to identify if 11b mode is enabled or not bit: 1 flag to identify if 11g mode is enabled or not bit: 2 flag to identify if 11n mode is enabled or not bit: 3 flag to identify if low rate is enabled or not bit: 4 flag to identify if 11ax mode is enabled or not bit: 5 flag to identify if WPS is supported or not bit: 6 flag to identify if FTM is supported in responder mode bit: 7 flag to identify if FTM is supported in initiator mode The minimum rssi to accept in the fast scan mode The weakest authmode to accept in the fast scan mode Note: Incase this value is not set and password is set as per WPA2 standards(password len >= 8), it will be defaulted to WPA2 and device won't connect to deprecated WEP/WPA networks. Please set authmode threshold as WIFI_AUTH_WEP/WIFI_AUTH_WPA_PSK to connect to WEP/WPA networks Deprecated variable. Device will always connect in PMF mode if other device also advertizes PMF capability. Advertizes that Protected Management Frame is required. Device will not associate to non-PMF capable devices. SSID of soft-AP. If ssid_len field is 0, this must be a Null terminated string. Otherwise, length is set according to ssid_len. Auth mode of soft-AP. Do not support AUTH_WEP, AUTH_WAPI_PSK and AUTH_OWE in soft-AP mode. When the auth mode is set to WPA2_PSK, WPA2_WPA3_PSK or WPA3_PSK, the pairwise cipher will be overwritten with WIFI_CIPHER_TYPE_CCMP. Broadcast SSID or not, default 0, broadcast the SSID Max number of stations allowed to connect in Beacon interval which should be multiples of 100. Unit: TU(time unit, 1 TU = 1024 us). Range: 100 ~ 60000. Default value: 100 Channel Switch Announcement Count. Notify the station that the channel will switch after the csa_count beacon intervals. Range: 1 ~ 30. Default value: 3 Pairwise cipher of SoftAP, group cipher will be derived using this. Cipher values are valid starting from WIFI_CIPHER_TYPE_TKIP, enum values before that will be considered as invalid and default cipher suites(TKIP+CCMP) will be used. Valid cipher suites in softAP mode are WIFI_CIPHER_TYPE_TKIP, WIFI_CIPHER_TYPE_CCMP and WIFI_CIPHER_TYPE_TKIP_CCMP. do all channel scan or fast scan whether set MAC address of target AP or not. Generally, station_config.bssid_set needs to be 0; and it needs to be 1 only when users need to check the MAC address of the AP. channel of target AP. Set to 1~13 to scan starting from the specified channel before connecting to AP. If the channel of AP is unknown, set it to 0. Listen interval for ESP32 station to receive beacon when WIFI_PS_MAX_MODEM is set. Units: AP beacon intervals. Defaults to 3 if set to 0. sort the connect AP in the list by rssi or security mode When scan_threshold is set, only APs which have an auth mode that is more secure than the selected auth mode and a signal stronger than the minimum RSSI will be used. Configuration for Protected Management Frame. Will be advertised in RSN Capabilities in RSN IE. Whether Radio Measurements are enabled for the connection Whether BSS Transition Management is enabled for the connection Whether MBO is enabled for the connection Whether FT is enabled for the connection Whether OWE is enabled for the connection Number of connection retries station will do before moving to next AP. scan_method should be set as WIFI_ALL_CHANNEL_SCAN to use this config. Note: Enabling this may cause connection time to increase incase best AP doesn't behave properly. Whether DCM max.constellation for transmission and reception is set. Indicate the max.constellation for DCM in TB PPDU the STA supported. 0: not supported. 1: BPSK, 2: QPSK, 3: 16-QAM. The default value is 3. Indicate the max.constellation for DCM in both Data field and HE-SIG-B field the STA supported. 0: not supported. 1: BPSK, 2: QPSK, 3: 16-QAM. The default value is 3. Whether to support HE-MCS 0 to 9. The default value is 0. Whether to disable support for operation as an SU beamformee. Whether to disable support the transmission of SU feedback in an HE TB sounding sequence. Whether to disable support the transmission of partial-bandwidth MU feedback in an HE TB sounding sequence. Whether to disable support the transmission of CQI feedback in an HE TB sounding sequence. Password identifier for H2E. this needs to be null terminated string Device's preference value to serve as NAN Master Scan time in seconds while searching for a NAN cluster Description of STA associated with AP. bit: 0 flag to identify if 11b mode is enabled or not bit: 1 flag to identify if 11g mode is enabled or not bit: 2 flag to identify if 11n mode is enabled or not bit: 3 flag to identify if low rate is enabled or not bit: 4 flag to identify if 11ax mode is enabled or not List of stations associated with the Soft-AP. number of stations in the list (other entries are invalid) The first bytes of the Information Element will match this header. Payload follows. Should be set to WIFI_VENDOR_IE_ELEMENT_ID (0xDD) Length of all bytes in the element data following this field. Minimum 4. Payload. Length is equal to value in 'length' field, minus 4. Received packet radio metadata header, this is the common header at the beginning of all promiscuous mode RX callback buffers. PHY rate encoding of the packet. Only valid for non HT(11bg) packet Protocol of the reveived packet, 0: non HT(11bg) packet; 1: HT(11n) packet; 3: VHT(11ac) packet Modulation Coding Scheme. If is HT(11n) packet, shows the modulation, range from 0 to 76(MSC0 ~ MCS76) Set to 1 indicates that channel estimate smoothing is recommended. Set to 0 indicates that only per-carrierindependent (unsmoothed) channel estimate is recommended. Set to 0 indicates that PPDU is a sounding PPDU. Set to 1indicates that the PPDU is not a sounding PPDU. sounding PPDU is used for channel estimation by the request receiver Forward Error Correction(FEC). Flag is set for 11n packets which are LDPC the number of subframes aggregated in AMPDU primary channel on which this packet is received secondary channel on which this packet is received. 0: none; 1: above; 2: below timestamp. The local time when this packet is received. It is precise only if modem sleep or light sleep is not enabled. unit: microsecond antenna number from which this packet is received. 0: WiFi antenna 0; 1: WiFi antenna 1 state of the packet. 0: no error; others: error numbers which are not public Data or management payload. Length of payload is described by rx_ctrl.sig_len. Type of content determined by packet type argument of callback. Mask for filtering different packet types in promiscuous mode. OR of one or more filter values WIFI_PROMIS_FILTER_* enable to generate htlft data by averaging lltf and ht_ltf data when receiving HT packet. Otherwise, use ht_ltf data directly. Default enabled enable to turn on channel filter to smooth adjacent sub-carrier. Disable it to keep independence of adjacent sub-carrier. Default enabled manually scale the CSI data by left shifting or automatically scale the CSI data. If set true, please set the shift bits. false: automatically. true: manually. Default false manually left shift bits of the scale of the CSI data. The range of the left shift bits is 0~15 first four bytes of the CSI data is invalid or not, true indicates the first four bytes is invalid due to hardware limition Whether this GPIO is connected to external antenna switch The GPIO number that connects to external antenna switch The configurations of GPIOs that connect to external antenna switch Default antenna mode for receiving, it's ignored if rx_ant_mode is not WIFI_ANT_MODE_AUTO WiFi antenna mode for transmission, it can be set to WIFI_ANT_MODE_AUTO only if rx_ant_mode is set to WIFI_ANT_MODE_AUTO No. of FTM frames requested in terms of 4 or 8 bursts (allowed values - 0(No pref), 16, 24, 32, 64) Requested period between FTM bursts in 100's of milliseconds (allowed values 0(No pref) - 100) True - Using esp_wifi_ftm_get_report to get FTM report, False - Using ftm_report_data from WIFI_EVENT_FTM_REPORT to get FTM report MAC address of the station connected to Soft-AP the aid that soft-AP gives to the station connected to MAC address of the station disconnects to soft-AP the aid that soft-AP gave to the station disconnects to MAC address of the station which send probe request old home channel of the device old second channel of the device new home channel of the device new second channel of the device MAC address of the station trying to connect to Soft-AP Time of departure of FTM frame from FTM Responder in pSec Time of arrival of FTM frame at FTM Initiator in pSec Time of departure of ACK from FTM Initiator in pSec Time of arrival of ACK at FTM Responder in pSec Pointer to FTM Report, should be freed after use. Note: Highly recommended to use API esp_wifi_ftm_get_report to get the report instead of using this Number of entries in the FTM Report data Indicates whether publisher's service ID needs to be updated Using ERSU to send frame, ERSU is a transmission mode related to 802.11 ax. ERSU is always used in long distance transmission, and its frame has lower rate compared with SU mode\n\nThis function enables Extensible Authentication Protocol (EAP) authentication for the Wi-Fi station mode. When EAP authentication is enabled, the ESP device will attempt to authenticate with the configured EAP credentials when connecting to a secure Wi-Fi network. Before calling this function, ensure that the Wi-Fi configuration and EAP credentials (such as username and password) have been properly set using the appropriate configuration APIs. This function disables Extensible Authentication Protocol (EAP) authentication for the Wi-Fi station mode. When EAP authentication is disabled, the ESP device will not attempt to authenticate using EAP credentials when connecting to a secure Wi-Fi network. Disabling EAP authentication may cause the device to connect to the Wi-Fi network using other available authentication methods, if configured using esp_wifi_set_config().\n• None ESP_ERR_INVALID_STATE: EAP client is in an invalid state for disabling. This function sets the identity to be used during PEAP/TTLS authentication.\n• None identity -- [in] Pointer to the identity data.\n• None len -- [in] Length of the identity data (limited to 1~127 bytes). This function clears the identity that was previously set for the EAP client. After calling this function, the EAP client will no longer use the previously configured identity during the authentication process. This function sets the username to be used during PEAP/TTLS authentication.\n• None username -- [in] Pointer to the username data.\n• None len -- [in] Length of the username data (limited to 1~127 bytes).\n• None ESP_ERR_INVALID_ARG: Failed due to an invalid argument (len <= 0 or len >= 128). This function clears the previously set username for the EAP client. This function sets the password to be used during PEAP/TTLS authentication.\n• None password -- [in] Pointer to the password data.\n• None len -- [in] Length of the password data (len > 0). This function clears the previously set password for the EAP client. This function sets the new password to be used during MSCHAPv2 authentication. The new password is used to substitute the old password when an eap-mschapv2 failure request message with error code ERROR_PASSWD_EXPIRED is received.\n• None new_password -- [in] Pointer to the new password data.\n• None len -- [in] Length of the new password data.\n• None ESP_OK: The new password was set successfully. This function clears the previously set new password for the EAP client. This function sets the Certificate Authority (CA) certificate to be used during EAP authentication. The CA certificate is passed to the EAP client module through a global pointer.\n• None ca_cert -- [in] Pointer to the CA certificate data.\n• None ca_cert_len -- [in] Length of the CA certificate data. This function clears the CA certificate that was previously set for the EAP client. After calling this function, the EAP client will no longer use the previously configured CA certificate during the authentication process. This function sets the client certificate and private key to be used during authentication. Optionally, a private key password can be provided for encrypted private keys. 1. The client certificate, private key, and private key password are provided as pointers to the respective data arrays. 2. The client_cert, private_key, and private_key_password should be zero-terminated.\n• None client_cert -- [in] Pointer to the client certificate data.\n• None client_cert_len -- [in] Length of the client certificate data.\n• None private_key -- [in] Pointer to the private key data.\n• None private_key_len -- [in] Length of the private key data (limited to 1~4096 bytes).\n• None private_key_password -- [in] Pointer to the private key password data (optional).\n• None private_key_passwd_len -- [in] Length of the private key password data (can be 0 for no password).\n• None ESP_OK: The certificate, private key, and password (if provided) were set successfully. Clear the previously set client certificate and private key for EAP authentication. This function clears the client certificate and private key that were previously set for the EAP client. After calling this function, the EAP client will no longer use the previously configured certificate and private key during the authentication process. This function enables or disables the time check for EAP client certificates. When disabled, the certificates' expiration time will not be checked during the authentication process. disable -- [in] True to disable EAP client certificates time check, false to enable it. This function retrieves the current status of the EAP client certificates time check. disable -- [out] Pointer to a boolean variable to store the disable status.\n• None ESP_OK: The status of EAP client certificates time check was retrieved successfully. This function sets the phase 2 method to be used during EAP-TTLS authentication. type -- [in] The type of phase 2 method to be used (e.g., EAP, MSCHAPv2, MSCHAP, PAP, CHAP). This function enables or disables the 192-bit Suite-B certification checks during EAP-TLS authentication. Suite-B is a set of cryptographic algorithms which generally are considered more secure. enable -- [in] True to enable 192-bit Suite-B certification checks, false to disable it. EAP-FAST requires a PAC file that contains the client's credentials. 1. For files read from the file system, length has to be decremented by 1 byte. 2. Disabling the ESP_WIFI_MBEDTLS_TLS_CLIENT config is required to use EAP-FAST.\n• None pac_file -- [in] Pointer to the PAC file buffer.\n• None pac_file_len -- [in] Length of the PAC file buffer.\n• None ESP_OK: The PAC file for EAP-FAST authentication was set successfully. EAP-FAST supports Fast Provisioning, where clients can be authenticated faster using precomputed keys (PAC). This function allows configuring parameters for Fast Provisioning. 1. Disabling the ESP_WIFI_MBEDTLS_TLS_CLIENT config is required to use EAP-FAST.\n• None ESP_OK: The parameters for EAP-FAST Phase 1 authentication were set successfully. Use the default certificate bundle for EAP authentication. By default, the EAP client uses a built-in certificate bundle for server verification. Enabling this option allows the use of the default certificate bundle. use_default_bundle -- [in] True to use the default certificate bundle, false to use a custom bundle.\n• None ESP_OK: The option to use the default certificate bundle was set successfully."
    },
    {
        "link": "https://randomnerdtutorials.com/esp32-useful-wi-fi-functions-arduino",
        "document": "This article is a compilation of useful Wi-Fi functions for the ESP32. We’ll cover the following topics: scan Wi-Fi networks, connect to a Wi-Fi network, get Wi-Fi connection strength, check connection status, reconnect to the network after a connection is lost, Wi-Fi status, Wi-Fi modes, get the ESP32 IP address, set a fixed IP address and more.\n\nThis is not a novelty. There are plenty of examples of how to handle Wi-Fi with the ESP32. However, we thought it would be useful to compile some of the most used and practical Wi-Fi functions for the ESP32.\n\nHere’s a list of what will be covered in this tutorial (you can click on the links to go to the corresponding section):\n• None Reconnect to Wi-Fi after connection is lost;\n\nThe first thing you need to do to use the ESP32 Wi-Fi functionalities is to include the WiFi.h library in your code, as follows:\n\nThis library is automatically “installed” when you install the ESP32 add-on in your Arduino IDE. If you don’t have the ESP32 installed, you can follow the next tutorial:\n\nIf you prefer to use VS Code + PaltformIO, you just need to start a new project with an ESP32 board to be able to use the WiFi.h library and its functions.\n\nThe ESP32 board can act as Wi-Fi Station, Access Point or both. To set the Wi-Fi mode, use WiFi.mode() and set the desired mode as argument:\n\nWhen the ESP32 is set as a Wi-Fi station, it can connect to other networks (like your router). In this scenario, the router assigns a unique IP address to your ESP board. You can communicate with the ESP using other devices (stations) that are also connected to the same network by referring to the ESP unique IP address.\n\nThe router is connected to the internet, so we can request information from the internet using the ESP32 board like data from APIs (weather data, for example), publish data to online platforms, use icons and images from the internet or include JavaScript libraries to build web server pages.\n\nSet the ESP32 as a Station and Connect to Wi-Fi Network\n\nGo to “Connect to Wi-Fi Network” to learn how to set the ESP32 as station and connect it to a network.\n\nIn some cases, this might not be the best configuration – when you don’t have a network nearby and want you still want to connect to the ESP to control it. In this scenario, you must set your ESP board as an access point.\n\nWhen you set your ESP32 board as an access point, you can be connected using any device with Wi-Fi capabilities without connecting to your router. When you set the ESP32 as an access point, you create its own Wi-Fi network, and nearby Wi-Fi devices (stations) can connect to it, like your smartphone or computer. So, you don’t need to be connected to a router to control it.\n\nThis can be also useful if you want to have several ESP32 devices talking to each other without the need for a router.\n\nBecause the ESP32 doesn’t connect further to a wired network like your router, it is called soft-AP (soft Access Point). This means that if you try to load libraries or use firmware from the internet, it will not work. It also doesn’t work if you make HTTP requests to services on the internet to publish sensor readings to the cloud or use services on the internet (like sending an email, for example).\n\nSet the ESP32 as an Access Point\n\nTo set the ESP32 as an access point, set the Wi-Fi mode to access point:\n\nAnd then, use the softAP() method as follows:\n\nssid is the name you want to give to the ESP32 access point, and the password variable is the password for the access point. If you don’t want to set a password, set it to NULL.\n\nThere are also other optional parameters you can pass to the softAP() method. Here are all the parameters:\n• : name for the access point – maximum of 63 characters;\n• : minimum of 8 characters; set to if you want the access point to be open;\n\nWe have a complete tutorial explaining how to set up the ESP32 as an access point:\n• How to Set an ESP32 Access Point (AP) for Web Server\n\nThe ESP32 can be set as a Wi-Fi station and access point simultaneously. Set its mode to WIFI_AP_STA.\n\nThe ESP32 can scan nearby Wi-Fi networks within its Wi-Fi range. In your Arduino IDE, go to File > Examples > WiFi > WiFiScan. This will load a sketch that scans Wi-Fi networks within the range of your ESP32 board.\n\nThis can be useful to check if the Wi-Fi network you’re trying to connect is within the range of your board or other applications. Your Wi-Fi project may not often work because it may not be able to connect to your router due to insufficient Wi-Fi strength.\n\nYou can upload it to your board and check the available networks as well as the RSSI (received signal strength indicator).\n\nAfter the scanning, you can access the parameters about each network.\n\nWiFi.RSSI() returns the RSSI of that network. RSSI stands for Received Signal Strength Indicator. It is an estimated measure of power level that an RF client device is receiving from an access point or router.\n\nFinally, WiFi.encryptionType() returns the network encryption type. That specific example puts a * in the case of open networks. However, that function can return one of the following options (not just open networks):\n\nTo connect the ESP32 to a specific Wi-Fi network, you must know its SSID and password. Additionally, that network must be within the ESP32 Wi-Fi range (to check that, you can use the previous example to scan Wi-Fi networks).\n\nYou can use the following function to connect the ESP32 to a Wi-Fi network initWiFi():\n\nThe ssid and password variables hold the SSID and password of the network you want to connect to.\n\nThen, you simply need to call the initWiFi() function in your setup().\n\nLet’s take a quick look on how this function works.\n\nFirst, set the Wi-Fi mode. If the ESP32 will connected to another network (access point/hotspot) it must be in station mode.\n\nThen, use WiFi.begin() to connect to a network. You must pass as arguments the network SSID and its password:\n\nConnecting to a Wi-Fi network can take a while, so we usually add a while loop that keeps checking if the connection was already established by using WiFi.status(). When the connection is successfully established, it returns WL_CONNECTED.\n\nTo get the status of the Wi-Fi connection, you can use WiFi.status(). This returns one of the following values that correspond to the constants on the table:\n\nTo get the WiFi connection strength, you can simply call WiFi.RSSI() after a WiFi connection.\n\nInsert your network credentials and upload the code.\n\nOpen the Serial Monitor and press the ESP32 on-board RST button. It will connect to your network and print the RSSI (received signal strength indicator).\n\nWhen the ESP32 is set as a Wi-Fi station, it can connect to other networks (like your router). In this scenario, the router assigns a unique IP address to your ESP32 board. To get your board’s IP address, you need to call WiFi.localIP() after establishing a connection with your network.\n\nInstead of getting a randomly assigned IP address, you can set an available IP address of your preference to the ESP32 using WiFi.config().\n\nOutside the setup() and loop() functions, define the following variables with your own static IP address and corresponding gateway IP address. By default, the following code assigns the IP address 192.168.1.184 that works in the gateway 192.168.1.1.\n\nThen, in the setup() you need to call the WiFi.config() method to assign the configurations to your ESP32.\n\nThe primaryDNS and secondaryDNS parameters are optional and you can remove them.\n\nWe recommend reading the following tutorial to learn how to set a static IP address:\n\nTo disconnect from a previously connected Wi-Fi network, use WiFi.disconnect():\n\nTo reconnect to Wi-Fi after a connection is lost, you can use WiFi.reconnect() to try to reconnect to the previously connected access point:\n\nOr, you can call WiFi.disconnect() followed by WiFi.begin(ssid,password).\n\nAlternatively, you can also try to restart the ESP32 with ESP.restart() when the connection is lost.\n\nYou can add something like the snippet below to your loop() that checks once in a while if the board is connected.\n\nDon’t forget to declare the previousMillis and interval variables. The interval corresponds to the period of time between each check in milliseconds (for example 30 seconds):\n\nThis example shows how to connect to a network and checks every 30 seconds if it is still connected. If it isn’t, it disconnects and tries to reconnect again.\n\nYou can read our guide: [SOLVED] Reconnect ESP32 to Wi-Fi Network After Lost Connection.\n\nAlternatively, you can also use WiFi Events to detect that the connection was lost and call a function to handle what to do when that happens (see the next section).\n\nThe ESP32 can handle all the following Wi-Fi events (check the source code):\n\nFor a complete example on how to use those events, in your Arduino IDE, go to File > Examples > WiFi > WiFiClientEvents.\n\nWith Wi-Fi Events, you don’t need to be constantly checking the Wi-Fi state. When a certain event happens, it automatically calls the corresponding handling function.\n\nWi-Fi events can be useful to detect that a connection was lost and try to reconnect right after (use the SYSTEM_EVENT_AP_STADISCONNECTED event). Here’s a sample code:\n\nIn this example we’ve added three Wi-Fi events: when the ESP32 connects, when it gets an IP address, and when it disconnects: ARDUINO_EVENT_WIFI_STA_CONNECTED, ARDUINO_EVENT_WIFI_STA_GOT_IP, ARDUINO_EVENT_WIFI_STA_DISCONNECTED.\n\nWhen the ESP32 station connects to the access point (ARDUINO_EVENT_WIFI_STA_CONNECTED event), the WiFiStationConnected() function will be called:\n\nThe WiFiStationConnected() function simply prints that the ESP32 connected to an access point (for example, your router) successfully. However, you can modify the function to do any other task (like light up an LED to indicate that it is successfully connected to the network).\n\nWhen the ESP32 gets its IP address, the WiFiGotIP() function runs.\n\nThat function simply prints the IP address on the Serial Monitor.\n\nWhen the ESP32 loses the connection with the access point (ARDUINO_EVENT_WIFI_STA_DISCONNECTED), the WiFiStationDisconnected() function is called.\n\nThat function prints a message indicating that the connection was lost and tries to reconnect:\n\nThe ESP32 WiFiMulti allows you to register multiple networks (SSID/password combinations). The ESP32 will connect to the Wi-Fi network with the strongest signal (RSSI). If the connection is lost, it will connect to the next network on the list. This requires that you include the WiFiMulti.h library (you don’t need to install it, it comes by default with the ESP32 package).\n\nTo learn how to use WiFiMulti, read the following tutorial:\n• ESP32 WiFiMulti: Connect to the Strongest Wi-Fi Network (from a list of networks)\n\nTo set a custom hostname for your board, call WiFi.setHostname(YOUR_NEW_HOSTNAME); before WiFi.begin();\n\nThere is a method provided by the WiFi.h library that allows you to set a custom hostname.\n\nFirst, start by defining your new hostname. For example:\n\nThen, call the WiFi.setHostname() function before calling WiFi.begin(). You also need to call WiFi.config() as shown below:\n\nYou can copy the complete example below:\n\nYou can use this previous snippet of code in your projects to set a custom hostname for the ESP32.\n\nImportant: you may need to restart your router for the changes to take effect.\n\nAfter this, if you go to your router settings, you’ll see the ESP32 with the custom hostname.\n\nThis article was a compilation of some of the most used and useful ESP32 Wi-Fi functions. Although there are plenty of examples of using the ESP32 Wi-Fi capabilities, there is little documentation explaining how to use the Wi-Fi functions with the ESP32 using Arduino IDE. So, we’ve decided to put together this guide to make it easier to use ESP32 Wi-Fi-related functions in your projects.\n\nIf you have other suggestions, you can share them in the comments section.\n\nWe hope you’ve found this tutorial useful.\n\nLearn more about the ESP32 with our resources:"
    },
    {
        "link": "https://docs.arduino.cc/arduino-cloud/hardware/wifi",
        "document": ""
    },
    {
        "link": "https://github.com/espressif/arduino-esp32/blob/master/docs/en/api/wifi.rst",
        "document": "The Wi-Fi API provides support for the 802.11b/g/n protocol driver. This API includes:\n• Station mode (STA mode or Wi-Fi client mode). ESP32 connects to an access point\n• AP mode (aka Soft-AP mode or Access Point mode). Devices connect to the ESP32\n\nIn this mode, the ESP32 is configured as an Access Point (AP) and it's capable of receiving incoming connections from other devices (stations) by providing a Wi-Fi network.\n\nThis mode can be used for serving an HTTP or HTTPS server inside the ESP32, for example.\n\nThe STA mode is used to connect the ESP32 to a Wi-Fi network, provided by an Access Point.\n\nThis is the mode to be used if you want to connect your project to the Internet.\n\nHere is the description of the Wi-Fi API.\n\nHere are the common APIs that are used for both modes, AP and STA.\n\nRegisters a caller-supplied function to be called when Wi-Fi events occur. Several forms are available.\n\nA similar set of functions are available to remove callbacks:\n\nIn all cases, the subscribing function accepts an optional event type to invoke the callback only for that specific event; with the default , the callback will be invoked for all Wi-Fi events.\n\nAny callback function is given the event type in a parameter. Some of the possible callback function formats also take an (or use which includes both ID and info) which is a union of structs with additional information about different event types.\n\nSee WiFiGeneric.h for the list of event types and \"info\" substructures, and also see a full example of event handling: events example.\n\nSets the name the DHCP client uses to identify itself. In a typical network setup this will be the name that shows up in the Wi-Fi router's device list. The hostname must be no longer than 32 characters.\n\nIf the hostname is never specified, a default one will be assigned based on the chip type and MAC address. The current hostname (default or custom) may be retrieved:\n\nThis function is used to set the memory allocation mode for the Wi-Fi buffers.\n• Set to use the Wi-Fi buffers memory allocation as static.\n• Set to set the buffers memory allocation to dynamic.\n\nThe use of dynamic allocation is recommended to save memory and reduce resources usage. However, the dynamic performs slightly slower than the static allocation. Use static allocation if you want to have more performance and if your application is multi-tasking.\n\nBy default, the memory allocation will be set to dynamic if this function is not being used.\n\nConfigures the Dual antenna functionality. This function should be used only on the ESP32-WROOM-DA module or any other ESP32 with RF switch.\n• Configure the GPIO number for the antenna 1 connected to the RF switch (default on ESP32-WROOM-DA)\n• Configure the GPIO number for the antenna 2 connected to the RF switch (default on ESP32-WROOM-DA)\n• Set the RX antenna mode. See wifi_rx_ant_t for the options.\n• Set the TX antenna mode. See wifi_tx_ant_t for the options.\n\nReturn if the configuration was successful.\n\nFor the you can use the following configuration:\n• Selects the antenna 1 for all RX activity.\n• Selects the antenna 2 for all RX activity.\n\nFor the you can use the following configuration:\n• Selects the antenna 1 for all TX activity.\n• Selects the antenna 2 for all TX activity.\n\nThe is used to configure and manage the Wi-Fi as an Access Point. This is where you can find the related functions for the AP.\n\nTo start the Wi-Fi as an Access Point.\n\nPlease see the full WiFiAP example in: ap example.\n\nUse the function to configure the Wi-Fi AP characteristics:\n• sets the Wi-Fi network password. If the network is open, set as .\n• sets the maximum number of simultaneous connections. The default is 4.\n• sets the Wi-Fi FTM responder feature. Only for ESP32-S2 and ESP32-C3 SoC!\n\nReturn if the configuration was successful.\n\nFunction used to configure the IP as static (fixed) as well as the gateway and subnet.\n\nThe function will return if the configuration is successful.\n\nFunction used to force the AP disconnection.\n• sets the Wi-Fi off if .\n\nThe function will return if the configuration is successful.\n\nThis function returns the number of clients connected to the AP.\n\nFunction to get the AP IPv4 address.\n\nThe function will return the AP IP address in format.\n\nFunction to get the AP IPv4 broadcast address.\n\nThe function will return the AP broadcast address in format.\n\nThe function will return the AP network address in format.\n\nFunction used to enable the IPv6 support.\n\nThe function will return if the configuration is successful.\n\nFunction to get the IPv6 address.\n\nThe function will return the AP IPv6 address in format.\n\nFunction to get the AP hostname.\n\nThe function will return if the configuration is successful.\n\nFunction to get the AP MAC address.\n\nFunction to get the AP SSID.\n\nThe is used to configure and manage the Wi-Fi as Station. The related functions for the STA are here.\n\nThe following code shows the basic usage of the WifiSTA functionality.\n\nWhere the and are from the network you want to connect the ESP32.\n\nTo check if the connection is successful, you can use:\n\nAfter a successful connection, you can print the IP address given by the network.\n\nPlease see the full example of the WiFiSTA in: sta example.\n• Functions are used to configure and start the Wi-Fi.\n• sets the AP password. Set as for open networks.\n• sets to connect to the configured network automatically.\n• sets the AP password. Set as for open networks.\n• sets to connect to the configured network automatically.\n\nFunction to start the connection after being configured.\n\nFunction is used to configure Wi-Fi. After configuring, you can call function to start the Wi-Fi process.\n\nThe function will return if the configuration is successful.\n\nThe format is defined by 4 bytes as described here:\n\nSee the for more details on how to use this feature.\n\nFunction used to reconnect the Wi-Fi connection.\n• use to turn the Wi-Fi radio off.\n• use to erase the AP configuration from the NVS memory.\n\nThe function will return if the configuration is successful.\n\nFunction used to get the connection state.\n\nFunction used to set the automatic reconnection if the connection is lost.\n• is set to to enable this option.\n\nFunction used to get the automatic reconnection if the connection is lost.\n\nThe function will return if this setting is enabled.\n\nFunction used to set the minimum security for AP to be considered connectable.\n• is the minimum security for AP to be considered connectable. Default is .\n\nThe allows you to add more than one option for the AP connection while running as a station.\n\nTo add the AP, use the following function. You can add multiple AP's and this library will handle the connection.\n\nAfter adding the AP's, run by the following function.\n\nTo see how to use the , take a look at the example available.\n\nTo perform the Wi-Fi scan for networks, you can use the following functions:\n\nCalled to get the scan state in Async mode.\n\nLoads all infos from a scanned Wi-Fi in to the ptr parameters.\n\nTo see how to use the , take a look at the or example available."
    },
    {
        "link": "https://github.com/me-no-dev/ESPAsyncWebServer/blob/master/README.ESP32Async.md",
        "document": "Asynchronous HTTP and WebSocket Server Library for ESP32, ESP8266 and RP2040 Supports: WebSocket, SSE, Authentication, Arduino Json 7, File Upload, Static File serving, URL Rewrite, URL Redirect, etc.\n\nThis fork is based on yubox-node-org/ESPAsyncWebServer and includes all the concurrency fixes.\n• Changes in this fork\n• How to use Middleware\n• How to use authentication with AsyncAuthenticationMiddleware\n• Migration to Middleware to improve performance and memory usage\n• (ci) Better CI with a complete matrix of Arduino versions and boards\n• (feat) Middleware support with pre-built middlewares for authentication, authorization, rate limiting, logging, cors, etc.\n• (feat) Request attributes to store data on the request object\n• (feat) Response override: support the ability to replace a previously sent response by another one\n• (feat) example to show how to stream multiple files in one response\n• (perf) AsyncTCPSock support: AsyncTCP can be ignored and AsyncTCPSock used instead\n• (perf) to change the number of allows WebSocket clients and use to help cleanup resources about dead clients\n• (perf) which can be set on a client to either close the connection or discard messages but not close the connection when the queue is full\n• (perf) to control the maximum number of messages that can be queued for a SSE client\n• (perf) : control the maximum number of messages that can be queued for a Websocket client\n• (perf) in-flight buffer control and queue congestion avoidance to help to improve parallel connections handling, high volume data transfers and mitigate poor implemeneted slow user-code callbacks delayes on connctions handling\n• (perf) Performance improvements in terms of memory, speed and size\n\nThis ESPAsyncWebServer fork is now at version 3.x, where we try to keep the API compatibility with original project as much as possible.\n\nWe plan on creating a next major 4.x version that will:\n• Drop support for ESP8266, which goes EOL in a few years\n• Drop support for Arduino 2.x and ESP-IDF 4.x. The library will be compatible with latest Arduino and ESP-IDF\n• Drop support for ArduinoJson 5.x and 6.x. The library will be compatible with latest ArduinoJson\n\nSo if you need one of these feature, you will have to stick with the current 3.x. All releases we do will not cease to exist: all 3.x releases will stay in the release page. That is why we have tags and a release cycle.\n\nMaintaining a library for ESP8266 and RP2040 has a real cost and clearly what we see is that most users helping are on ESP32.\n\nIf you are an ESP8266 user and want to help improve current 3.x, you are more than welcomed to contribute to this community effort.\n\nAsyncTCPSock can be used instead of AsyncTCP by excluding AsyncTCP from the library dependencies and adding AsyncTCPSock instead:\n\nIn the example, there is an endpoint with some comments showing how these metrics are calculated.\n\nTest is running for 20 seconds with 10 connections.\n\nMost of the crashes are caused by improper use or configuration of the AsyncTCP library used for the project. Here are some recommendations to avoid them and build-time flags you can change.\n\n- defines a timeout for TCP connection to be considered alive when waiting for data. In some bad network conditions you might consider increasing it.\n\n- defines the length of the queue for events related to connections handling. Both the server and AsyncTCP library in this fork were optimized to control the queue automatically. Do NOT try blindly increasing the queue size, it does not help you in a way you might think it is. If you receive debug messages about queue throttling, try to optimize your server callbaks code to execute as fast as possible. Read #165 thread, it might give you some hints.\n\n- CPU core thread affinity that runs the queue events handling and executes server callbacks. Default is ANY core, so it means that for dualcore SoCs both cores could handle server activities. If your server's code is too heavy and unoptimized or you see that sometimes server might affect other network activities, you might consider to bind it to the same core that runs Arduino code (1) to minimize affect on radio part. Otherwise you can leave the default to let RTOS decide where to run the thread based on priority\n\n- stack size for the thread that runs sever events and callbacks. Default is 16k that is a way too much waste for well-defined short async code or simple static file handling. You might want to cosider reducing it to 4-8k to same RAM usage. If you do not know what this is or not sure about your callback code demands - leave it as default, should be enough even for very hungry callbacks in most cases.\n\nI personally use the following configuration in my projects:\n\nThe fork from yubox-node-org introduces some breaking API changes compared to the original library, especially regarding the use of for WebSocket.\n\nThis fork is compatible with the original library from me-no-dev regarding WebSocket, and wraps the optimizations done by in the class. So you have the choice of which API to use.\n\nHere are examples for serializing a Json document in a websocket message buffer:\n\nI recommend to use the official API to retain further compatibility.\n\nThis will send error 400 instead of 200.\n\nMiddleware is a way to intercept requests to perform some operations on them, like authentication, authorization, logging, etc and also act on the response headers.\n\nMiddleware can either be attached to individual handlers, attached at the server level (thus applied to all handlers), or both. They will be executed in the order they are attached, and they can stop the request processing by sending a response themselves.\n\nYou can have a look at the SimpleServer.ino example for some use cases.\n\nFor example, such middleware would handle authentication and set some attributes on the request to make them available for the next middleware and for the handler which will process the request.\n\nHere are the list of available middlewares:\n• : to handle basic/digest authentication globally or per handler\n• : to handle authorization globally or per handler\n• : to handle CORS preflight request globally or per handler\n• : to filter out headers from the request\n• : to only keep some headers from the request, and remove the others\n• : to log requests globally or per handler with the same pattern as curl. Will also record request processing time\n• : to limit the number of requests on a windows of time globally or per handler\n\nDo not use the and methods on the hanlders anymore. They are deprecated. These methods were causing a copy of the username and password for each handler, which is not efficient.\n\nNow, you can use the to handle authentication globally or per handler.\n• => do not use this method anymore: add a common to the handler or server, and make sure to add it AFTER the if you use authentication.\n• => do not use this method anymore: add a common to the handler or server\n• and => these callbacks receiving body data and upload and not calling anymore the authentication code for performance reasons. These callbacks can be called multiple times during request parsing, so this is up to the user to now call the if needed and ideally when the method is called for the first time. These callbacks are also not triggering the whole middleware chain since they are not part of the request processing workflow (they are not the final handler).\n• Why should you care\n• Principles of operation\n• Rewrites and how do they work\n• Handlers and how do they work\n• Responses and how do they work\n• Libraries and projects that use AsyncWebServer\n• Responses\n• Send large webpage from PROGMEM containing templates and extra headers\n• Respond with content coming from a Stream and extra headers\n• Respond with content coming from a Stream containing templates\n• Respond with content coming from a Stream containing templates and extra headers\n• Respond with content coming from a File and extra headers\n• Respond with content coming from a File containing templates\n• Respond with content using a callback and extra headers\n• Respond with file content using a callback and extra headers\n• Respond with content using a callback containing templates\n• Respond with content using a callback containing templates and extra headers\n• Using filters\n• Rewrite to different index on AP\n• Bad Responses\n• Respond with content using a callback without content length to HTTP/1.0 clients\n• Using asynchronous network means that you can handle more than one connection at the same time\n• You are called once the request is ready and parsed\n• When you send the response, you are immediately ready to handle other connections while the server is taking care of sending the response in the background\n• Easy to use API, HTTP Basic and Digest MD5 Authentication (default), ChunkedResponse\n• Easily extendible to handle any type of content\n• Async WebSocket plugin offering different locations without extra servers or ports\n• Async EventSource (Server-Sent Events) plugin to send events to the browser\n• ServeStatic plugin that supports cache, Last-Modified, default index and more\n• This is fully asynchronous server and as such does not run on the loop thread.\n• You can not use yield or delay or any function that uses them inside the callbacks\n• The server is smart enough to know when to close the connection and free resources\n• You can not send more than one response to a single request\n• Wraps the new clients into\n• Keeps track of clients and cleans memory\n• Manages and apply them on the request url\n• Manages and attaches them to Requests\n• TCP connection is received by the server\n• When the request head is received (type, url, get params, http version and host), the server goes through all (in the order they were added) to rewrite the url and inject query parameters, next, it goes through all attached (in the order they were added) trying to find one that the given request. If none are found, the default(catch-all) handler is attached.\n• The rest of the request is received, calling the or methods of the if they are needed (POST+File/Body)\n• When the whole request is parsed, the result is given to the method of the and is ready to be responded to\n• In the method, to the is attached a object (see below) that will serve the response data back to the client\n• When the is sent, the client is closed and freed from the memory\n• The are used to rewrite the request url and/or inject get parameters for a specific request url path.\n• All are evaluated on the request in the order they have been added to the server.\n• The will change the request url only if the request url (excluding get parameters) is fully match the rewrite url, and when the optional callback return true.\n• Setting a to the enables to control when to apply the rewrite, decision can be based on request url, http version, request host/port/target host, get parameters or the request client's localIP or remoteIP.\n• Two filter callbacks are provided: to execute the rewrite when request is made to the AP interface, to execute the rewrite when request is made to the STA interface.\n• The can specify a target url with optional get parameters, e.g.\n• The are used for executing specific actions to particular requests\n• One instance can be attached to any request and lives together with the server\n• Setting a to the enables to control when to apply the handler, decision can be based on request url, http version, request host/port/target host, get parameters or the request client's localIP or remoteIP.\n• Two filter callbacks are provided: to execute the rewrite when request is made to the AP interface, to execute the rewrite when request is made to the STA interface.\n• The method is used for handler specific control on whether the requests can be handled and for declaring any interesting headers that the should parse. Decision can be based on request method, request url, http version, request host/port/target host and get parameters\n• Once a is attached to given ( returned true) that takes care to receive any file/data upload and attach a once the has been fully parsed\n• are evaluated in the order they are attached to the server. The is called only if the that was set to the return true.\n• The first that can handle the request is selected, not further and are called.\n• The objects are used to send the response data back to the client\n• The object lives with the and is freed on end or disconnect\n• Different techniques are used depending on the response type to send the data in packets returning back almost immediately and sending the next packet when this one is received. Any time in between is spent to run the user loop and handle other network packets\n• Responding asynchronously is probably the most difficult thing for most to understand\n• Many different options exist for the user to make responding a background task\n• Template processing can be added to most response types.\n• Currently it supports only replacing template placeholders with actual values. No conditional processing, cycles, etc.\n• Placeholders are delimited with symbols. Like this: .\n• It works by extracting placeholder name from response text and passing it to user provided function which should return actual value to be used instead of placeholder.\n• Since it's user provided function, it is possible for library users to implement conditional processing and cycles themselves.\n• Since it's impossible to know the actual response size after template processing step in advance (and, therefore, to include it in response headers), the response becomes chunked.\n• ESPurna - ESPurna (\"spark\" in Catalan) is a custom C firmware for ESP8266 based smart switches. It was originally developed with the ITead Sonoff in mind.\n\nIf needed, the field on the request can be used to store a pointer to temporary data (e.g. from the body) associated with the request. If assigned, the pointer will automatically be freed along with the request.\n\nEndpoints which consume JSON can use a special handler to get ready to use JSON data in the request callback:\n\nWith this code your ESP is able to serve even large (large in terms of ESP, e.g. 100kB) files without memory problems.\n\nYou need to create a file handler in outer function (to have a single one for request) but use it in a lambda. The catch is that the lambda has it's own lifecycle which may/will cause it's called after the original function is over thus the original file handle is destroyed. Using the captured in the lambda then causes segfault (Hello, Exception 9!) and the whole ESP crashes.\n\n By using this code, you tell the compiler to move the handle into the lambda so it won't be destroyed when outer function (that one where you call ) ends.\n\nUsed when content length is unknown. Works best if the client supports HTTP/1.1\n\nUsed when content length is unknown. Works best if the client supports HTTP/1.1\n\nThis way of sending Json is great for when the result is below 4KB\n\nThis response can handle really large Json objects (tested to 40KB) There isn't any noticeable speed decrease for small results with the method above Since ArduinoJson does not allow reading parts of the string, the whole Json has to be passed every time a chunks needs to be sent, which shows speed decrease proportional to the resulting json packets\n\nIn addition to serving files from SPIFFS as described above, the server provide a dedicated handler that optimize the performance of serving files from SPIFFS - . Use function to initialize and add a new instance of to the server. The Handler will not handle the request if the file does not exists, e.g. the server will continue to look for another handler that can handle the request. Notice that you can chain setter functions to setup the handler, or keep a pointer to change it at a later time.\n\nTo serve files in a directory, the path to the files should specify a directory in SPIFFS and ends with \"/\".\n\nIt is possible to specify Cache-Control header value to reduce the number of calls to the server once the client loaded the files. For more information on Cache-Control values see Cache-Control\n\nIt is possible to specify Date-Modified header to enable the server to return Not-Modified (304) response for requests with \"If-Modified-Since\" header with the same value, instead of responding with the actual file content.\n\nIt is possible to specify template processor for static files. For information on template processor see Respond with content coming from a File containing templates.\n\nIt may happen your static files are too big and the ESP will crash the request before it sends the whole file.\n\n In that case, you can handle static files with custom file serving through not found handler.\n\nThis code below is more-or-less equivalent to this:\n\nAnd then configure your webserver:\n\nYou may want to try Respond with file content using a callback and extra headers For actual serving the file.\n\nIt is possible to rewrite the request url with parameter match. Here is an example with one parameter: Rewrite for example \"/radio/{frequence}\" -> \"/radio?f={frequence}\"\n\nFilters can be set to or in order to control when to apply the rewrite and consider the handler. A filter is a callback function that evaluates the request and return a boolean to include the item or to exclude it. Two filter callback are provided for convince:\n• - return true when requests are made to the STA (station mode) interface.\n• - return true when requests are made to the AP (access point) interface.\n\nSome responses are implemented, but you should not use them, because they do not conform to HTTP. The following example will lead to unclean close of the connection and more time wasted than providing the length of the content\n\nThe server includes a web socket plugin which lets you define different WebSocket locations to connect to without starting another listening service or using different port\n\nWhen sending a web socket message using the above methods a buffer is created. Under certain circumstances you might want to manipulate or populate this buffer directly from your application, for example to prevent unnecessary duplications of the data. This example below shows how to create a buffer and print data to it from an ArduinoJson object then send it.\n\nBrowsers sometimes do not correctly close the websocket connection, even when the close() function is called in javascript. This will eventually exhaust the web server's resources and will cause the server to crash. Periodically calling the cleanClients() function from the main loop() function limits the number of clients by closing the oldest client when the maximum number of clients has been exceeded. This can called be every cycle, however, if you wish to use less power, then calling as infrequently as once per second is sufficient.\n\nThe server includes EventSource (Server-Sent Events) plugin which can be used to send short text events to the browser. Difference between EventSource and WebSockets is that EventSource is single direction, text-only protocol.\n\nServer goes through handlers in same order as they were added. You can't simple add handler with same path to override them. To remove handler:\n\nIn some cases, such as when working with CORS, or with some sort of custom authentication system, you might need to define a header that should get added to all responses (including static, websocket and EventSource). The DefaultHeaders singleton allows you to do this.\n\nNOTE: You will still need to respond to the OPTIONS method for CORS pre-flight in most cases. (unless you are only using GET)\n\nThis is one option:\n\nWith path variable you can create a custom regex rule for a specific parameter in a route. For example we want a parameter in a route rule to match only a integer.\n\nNOTE: All regex patterns starts with and ends with\n\nTo enable the support, you have to define the buildflag .\n\nNOTE: By enabling , will be included. This will add an 100k to your binary."
    },
    {
        "link": "https://github.com/me-no-dev/ESPAsyncWebServer/issues/733",
        "document": "Hi, thanks for the great library! Please tell me, can I call request->send in an asynchronous function? Simple example:\n\nThis code causes unexpected errors, does not always work, and often throws backtrace:\n\nI tried several variations of asynchronous functions, not only using Ticker, for example: vector of callbacks, outside of request handler, recursive timer. Everything leads to the same errors.\n\nThe library itself allows you to delay the creation of response asynchronously such as:\n\nP.S I am using ESP32, PlatformIo. All libs updates to latest version. Reproduce code:"
    },
    {
        "link": "https://registry.platformio.org/libraries/esphome/ESPAsyncWebServer-esphome",
        "document": ""
    },
    {
        "link": "https://randomnerdtutorials.com/esp32-async-web-server-espasyncwebserver-library",
        "document": "In this tutorial you’ll learn how to build an asynchronous web server with the ESP32 board to control its outputs. The board will be programmed using Arduino IDE, and we’ll use the ESPAsyncWebServer library.\n\nYou might also like: ESP8266 NodeMCU Async Web Server – Control Outputs with Arduino IDE (ESPAsyncWebServer library)\n\nTo build the web server we’ll use the ESPAsyncWebServer library that provides an easy way to build an asynchronous web server. Building an asynchronous web server has several advantages as mentioned in the library GitHub page, such as:\n• “Handle more than one connection at the same time”;\n• “When you send the response, you are immediately ready to handle other connections while the server is taking care of sending the response in the background”;\n• And much more.\n\nTake a look at the library documentation on its GitHub page.\n\nIn this tutorial, we’ll control three outputs. As an example, we’ll control LEDs. So, you need the following parts:\n\nYou can use the preceding links or go directly to MakerAdvisor.com/tools to find all the parts for your projects at the best price!\n\nBefore proceeding to the code, wire 3 LEDs to the ESP32. We’re connecting the LEDs to GPIOs 2, 4 and 33, but you can use any other GPIOs (read ESP32 GPIO Reference Guide).\n\nWe’ll build the web server using the following libraries:\n\nYou can install these libraries in the Arduino Library Manager. Open the Library Manager by clicking the Library icon at the left sidebar.\n\nSearch for ESPAsyncWebServer and install the ESPAsyncWebServer by ESP32Async.\n\nThen, install the AsyncTCP library. Search for AsyncTCP and install the AsyncTCP by ESP32Async.\n\nTo better understand the code, let’s see how the web server works.\n• The web server contains one heading “ESP Web Server” and three buttons (toggle switches) to control three outputs. Each slider button has a label indicating the GPIO output pin. You can easily remove/add more outputs.\n• When the slider is red, it means the output is on (its state is HIGH). If you toggle the slider, it turns off the output (change the state to LOW).\n• When the slider is gray, it means the output is off (its state is LOW). If you toggle the slider, it turns on the output (change the state to HIGH).\n\nLet’s see what happens when you toggle the buttons. We’ll see the example for GPIO 2. It works similarly for the other buttons.\n\n1. In the first scenario, you toggle the button to turn GPIO 2 on. When that happens, the browser makes an HTTP GET request on the /update?output=2&state=1 URL. Based on that URL, the ESP changes the state of GPIO 2 to 1 (HIGH) and turns the LED on.\n\n2. In the second example, you toggle the button to turn GPIO 2 off. When that happens, the browser makes an HTTP GET request on the /update?output=2&state=0 URL. Based on that URL, we change the state of GPIO 2 to 0 (LOW) and turn the LED off.\n\nCopy the following code to your Arduino IDE.\n\nIn this section we’ll explain how the code works. Keep reading if you want to learn more or jump to the Demonstration section to see the final result.\n\nFirst, import the required libraries. You need to include the WiFi, ESPAsyncWebserver and the AsyncTCP libraries.\n\nInsert your network credentials in the following variables, so that the ESP32 can connect to your local network.\n\nTo check the parameters passed on the URL (GPIO number and its state), we create two variables, one for the output and other for the state.\n\nRemember that the ESP32 receives requests like this: /update?output=2&state=0\n\nAll the HTML text with styles and JavaScript is stored in the index_html variable. Now we’ll go through the HTML text and see what each part does.\n\nThe title goes inside the <title> and </tile> tags. The title is exactly what it sounds like: the title of your document, which shows up in your web browser’s title bar. In this case, it is “ESP Web Server”.\n\nThe following <meta> tag makes your web page responsive in any browser (laptop, tablet or smartphone).\n\nThe next line prevents requests on the favicon. In this case, we don’t have a favicon. The favicon is the website icon that shows next to the title in the web browser tab. If we don’t add the following line, the ESP32 will receive a request for the favicon every time we access the web server.\n\nBetween the <style></style> tags, we add some CSS to style the web page. We won’t go into detail on how this CSS styling works.\n\nInside the <body></body> tags is where we add the web page content.\n\nThe <h2></h2> tags add a heading to the web page. In this case, the “ESP Web Server” text, but you can add any other text.\n\nAfter the heading, we have the buttons. The way the buttons show up on the web page (red: if the GPIO is on; or gray: if the GPIO is off) varies depending on the current GPIO state.\n\nWhen you access the web server page, you want it to show the right current GPIO states. So, instead of adding the HTML text to build the buttons, we’ll add a placeholder %BUTTONPLACEHOLDER%. This palceholder will then be replaced with the actual HTML text to build the buttons with the right states, when the web page is loaded.\n\nThen, there’s some JavaScript that is responsible to make an HTTP GET request when you toggle the buttons as we’ve explained previously.\n\nHere’s the line that makes the request:\n\nelement.id returns the id of an HTML element. The id of each button will be the GPIO controlled as we’ll see in the next section:\n\nNow, we need to create the processor() function, that replaces the placeholders in the HTML text with what we define.\n\nWhen the web page is requested, check if the HTML has any placeholders. If it finds the %BUTTONPLACEHOLDER% placeholder, it returns the HTML text to create the buttons.\n\nYou can easily delete or add more lines to create more buttons.\n\nLet’s take a look at how the buttons are created. We create a String variable called buttons that contains the HTML text to build the buttons. We concatenate the HTML text with the current output state so that the toggle button is either gray or red. The current output state is returned by the outputState(<GPIO>) function (it accepts as argument the GPIO number). See below:\n\nThe \\ is used so that we can pass “” inside the String.\n\nThe outputState() function returns either “checked” if the GPIO is on or and empty field “” if the GPIO is off.\n\nSo, the HTML text for GPIO 2 when it is on, would be:\n\nLet’s break this down into smaller sections to understand how it works.\n\nIn HTML, a toggle switch is an input type. The <input> tag specifies an input field where the user can enter data. The toggle switch is an input field of type checkbox. There are many other input field types.\n\nThe checkbox can be checked or not. When it is check, you have something as follows:\n\nThe onchange is an event attribute that occurs when we change the value of the element (the checkbox). Whenever you check or uncheck the toggle switch, it calls the toggleCheckbox() JavaScript function for that specific element id (this).\n\nThe id specifies a unique id for that HTML element. The id allows us to manipulate the element using JavaScript or CSS.\n\nIn the setup() initialize the Serial Monitor for debugging purposes.\n\nSet the GPIOs you want to control as outputs using the pinMode() function and set them to LOW when the ESP32 first starts. If you’ve added more GPIOs, do the same procedure.\n\nConnect to your local network and print the ESP32 IP address.\n\nIn the setup(), you need to handle what happens when the ESP32 receives requests. As we’ve seen previously, you receive a request of this type:\n\nSo, we check if the request contains the PARAM_INPUT1 variable value (output) and the PARAM_INPUT2(state) and save the corresponding values on the input1Message and input2Message variables.\n\nThen, we control the corresponding GPIO with the corresponding state (the inputMessage1 variable saves the GPIO number and the inputMessage2 saves the state – 0 or 1)\n\nHere’s the complete code to handle the HTTP GET /update request:\n\nAfter uploading the code to your ESP32, open the Serial Monitor at a baud rate of 115200. Press the on-board RST/EN button. You should get its IP address.\n\nOpen a browser and type the ESP IP address. You’ll get access to a similar web page.\n\nPress the toggle buttons to control the ESP32 GPIOs. At the same time, you should get the following messages in the Serial Monitor to help you debug your code.\n\nYou can also access the web server from a browser in your smartphone. Whenever you open the web server, it shows the current GPIO states. Red indicates the GPIO is on, and gray that the GPIO is off.\n\nIn this tutorial you’ve learned how to create an asynchronous web server with the ESP32 to control its outputs using toggle switches. Whenever you open the web page, it shows the updated GPIO states.\n\nWe have other web server examples using the ESPAsyncWebServer library that you may like:\n\nWe hope you found this tutorial useful. If you have any questions, post a comment below and we’ll try to get back to you.\n\nIf you like ESP32, you might consider enrolling in our course “Learn ESP32 with Arduino IDE“. You can also access our free ESP32 resources here.\n\nThank you for reading."
    },
    {
        "link": "https://registry.platformio.org/libraries/ottowinter/ESPAsyncWebServer-esphome",
        "document": ""
    },
    {
        "link": "https://randomnerdtutorials.com/esp32-adc-analog-read-arduino-ide",
        "document": "This article shows how to read analog inputs with the ESP32 using Arduino IDE. Analog reading is useful to read values from variable resistors like potentiometers, or analog sensors.\n\nReading analog inputs with the ESP32 is as easy as using the analogRead(GPIO) function, that accepts as argument, the GPIO you want to read.\n\nWe also have other tutorials on how to use analog pins with ESP board:\n\nYou can watch the video tutorial or keep reading this page for the written instructions.\n\nReading an analog value with the ESP32 means you can measure varying voltage levels between 0 V and 3.3 V.\n\nThe voltage measured is then assigned to a value between 0 and 4095, in which 0 V corresponds to 0, and 3.3 V corresponds to 4095. Any voltage between 0 V and 3.3 V will be given the corresponding value in between.\n\nIdeally, you would expect a linear behavior when using the ESP32 ADC pins. However, that doesn’t happen. What you’ll get is a behavior as shown in the following chart:\n\nThis behavior means that your ESP32 is not able to distinguish 3.3 V from 3.2 V. You’ll get the same value for both voltages: 4095.\n\nThe same happens for very low voltage values: for 0 V and 0.1 V you’ll get the same value: 0. You need to keep this in mind when using the ESP32 ADC pins.\n\nThere’s a discussion on GitHub about this subject.\n\nReading an analog input with the ESP32 using the Arduino IDE is as simple as using the analogRead() function. It accepts as argument, the GPIO you want to read:\n\nThe ESP32 supports measurements in 18 different channels. Only 15 are available in the DEVKIT V1 DOIT board (version with 30 GPIOs).\n\nGrab your ESP32 board pinout and locate the ADC pins. These are highlighted with a red border in the figure below.\n\nLearn more about the ESP32 GPIOs: ESP32 Pinout Reference.\n\nThese analog input pins have 12-bit resolution. This means that when you read an analog input, its range may vary from 0 to 4095.\n\nNote: ADC2 pins cannot be used when Wi-Fi is used. So, if you’re using Wi-Fi and you’re having trouble getting the value from an ADC2 GPIO, you may consider using an ADC1 GPIO instead, that should solve your problem.\n\nThere are other more advanced functions to use with the ADC pins that can be useful in other projects.\n• : set the sample bits and resolution. It can be a value between 9 (0 – 511) and 12 bits (0 – 4095). Default is 12-bit resolution.\n• : set the sample bits and resolution. It can be a value between 9 (0 – 511) and 12 bits (0 – 4095). Default is 12-bit resolution.\n• : set the number of cycles per sample. Default is 8. Range: 1 to 255.\n• : set the number of samples in the range. Default is 1 sample. It has an effect of increasing sensitivity.\n• : set the divider for the ADC clock. Default is 1. Range: 1 to 255.\n• : sets the input attenuation for all ADC pins. Default is . Accepted values:\n• : sets no attenuation. ADC can measure up to approximately 800 mV (1V input = ADC reading of 1088).\n• : The input voltage of ADC will be attenuated, extending the range of measurement to up to approx. 1100 mV. (1V input = ADC reading of 3722).\n• : The input voltage of ADC will be attenuated, extending the range of measurement to up to approx. 1350 mV. (1V input = ADC reading of 3033).\n• : The input voltage of ADC will be attenuated, extending the range of measurement to up to approx. 2600 mV. (1V input = ADC reading of 1575).\n• : sets the input attenuation for the specified pin. The default is . Attenuation values are the same from previous function.\n• : Attach a pin to ADC (also clears any other analog mode that could be on). Returns TRUE or FALSE result.\n• ), and : starts an ADC convertion on attached pin’s bus. Check if conversion on the pin’s ADC bus is currently running (returns TRUE or FALSE). Get the result of the conversion: returns 16-bit integer.\n\nThere is a very good video explaining these functions that you can watch here.\n\nTo see how everything ties together, we’ll make a simple example to read an analog value from a potentiometer.\n\nFor this example, you need the following parts:\n\nYou can use the preceding links or go directly to MakerAdvisor.com/tools to find all the parts for your projects at the best price!\n\nWire a potentiometer to your ESP32. The potentiometer middle pin should be connected to GPIO 34. You can use the following schematic diagram as a reference.\n\nWe’ll program the ESP32 using Arduino IDE, so make sure you have the ESP32 add-on installed before proceeding:\n\nOpen your Arduino IDE and copy the following code.\n\nThis code simply reads the values from the potentiometer and prints those values in the Serial Monitor.\n\nIn the code, you start by defining the GPIO the potentiometer is connected to. In this example, GPIO 34.\n\nIn the setup(), initialize a serial communication at a baud rate of 115200.\n\nIn the loop(), use the analogRead()function to read the analog input from the potPin.\n\nFinally, print the values read from the potentiometer in the serial monitor.\n\nUpload the code provided to your ESP32. Make sure you have the right board and COM port selected in the Tools menu.\n\nAfter uploading the code and pressing the ESP32 reset button, open the Serial Monitor at a baud rate of 115200. Rotate the potentiometer and see the values changing.\n\nThe maximum value you’ll get is 4095 and the minimum value is 0.\n\nIn this article you’ve learned how to read analog inputs using the ESP32 with the Arduino IDE. In summary:\n• The ESP32 DEVKIT V1 DOIT board (version with 30 pins) has 15 ADC pins you can use to read analog inputs.\n• These pins have a resolution of 12 bits, which means you can get values from 0 to 4095.\n• To read a value in the Arduino IDE, you simply use the function.\n• The ESP32 ADC pins don’t have a linear behavior. You’ll probably won’t be able to distinguish between 0 and 0.1V, or between 3.2 and 3.3V. You need to keep that in mind when using the ADC pins.\n\nWe hope you’ve find this short guide useful. If you want to learn more about the ESP32, enroll in our course: Learn ESP32 with Arduino IDE.\n\nOther ESP32 guides that you may also like:\n• ESP32 with DHT Temperature and Humidity Sensor using Arduino IDE"
    },
    {
        "link": "https://lastminuteengineers.com/esp32-basics-adc",
        "document": "This article from our ESP32 Basics series demonstrates how to read analog values with the ESP32 using Arduino IDE.\n\nThis is useful for reading in a wide variety of sensors and variable components, including, but not limited to, trimpots, joysticks, sliders, and force-sensitive resistors.\n\nThe ESP32 includes two 12-bit SAR ADCs – ADC1 and ADC2 – and supports measurements on 18 channels (analog-enabled pins). ADC1 is available on eight GPIOs (32 to 39), while ADC2 is available on ten GPIOs (0, 2, 4, 12 to 15 and 25 to 27).\n\nHowever, the DEVKIT V1 DOIT board (the version with 30 GPIOs) has only 15 ADC channels, as shown in the figure below.\n\nThe ADC in your ESP32 has a resolution of 12 bits, meaning that it can detect 4096 (2^12) discrete analog levels. In other words, it will convert input voltages ranging from 0 to 3.3V (operating voltage) into integer values ranging from 0 to 4095. This results in a resolution of 3.3 volts / 4096 units, or 0.0008 volts (0.8 mV) per unit.\n\nMoreover, the ADC resolution and channel range can be set programmatically.\n\nTruth be told, ADC is not the ESP32’s strongest point. There are several limitations that you should be aware of.\n\nThe ADC2 pins cannot be used when Wi-Fi is enabled. Since there is a good chance of using WiFi on a microcontroller designed to use it, only the ADC1 can be used.\n\nThe ESP32’s ADC can only measure voltages ranging from 0 to 3.3V. You cannot measure analog voltages between 0 and 5V directly.\n\nIdeally, you would expect a linear behavior when using the ADC, but this is not the case. The ADC converters on the ESP32 are non-linear in nature. You can find more information about this in a discussion on GitHub.\n\nIn the graph below, the non-linearities at the lower and upper ends of the input voltage are clearly visible.\n\nThis basically means that the ESP32 cannot distinguish 3.2V from 3.3V; the measured value will be the same (4095). Similarly, it cannot distinguish between 0V and 0.13V signals; the measured value will be the same (0).\n\nThe electrical noise of the ADC implies a slight fluctuation of the measurements.\n\nHowever, this can be corrected by adding a capacitor at the output and by oversampling.\n\nReading the analog values from a GPIO pin is straightforward. In the Arduino IDE, you use the function, which accepts as an argument the GPIO pin number you want to read.\n\nTo demonstrate how to use the ADC on the ESP32, we will use a simple example that reads an analog value from a potentiometer.\n\nLet’s setup a simple potentiometer circuit for this example.\n\nStart by inserting the potentiometer into your breadboard. Wire the middle pin to pin GPIO 34 on your ESP32. Finally, wire one of the potentiometer’s outer pins – it doesn’t matter which – to ESP32’s 3V3 pin and the other to ground.\n\nLoad the following sketch onto your ESP32. This sketch simply reads the potentiometer and prints the results to the Serial Monitor.\n\nOnce you have uploaded the sketch, open the serial monitor at baud rate 115200 and press the EN button on the ESP32.\n\nYou should see a value between 0 and 4095, depending on the current rotation of the knob, being printed out to the serial monitor. Try turning the knob on the potentiometer to see how the values change.\n\nThe sketch begins by defining the GPIO pin to which the potentiometer is connected, which in this case is GPIO 34.\n\nA variable is also defined to store the potentiometer values.\n\nIn the setup(), we initialize the serial communication with the PC.\n\nIn the loop, the function is used to read the voltage on the . The returned value is stored in the variable .\n\nFinally, the values read from the potentiometer are printed to the serial monitor.\n\nThere are other ADC functions that may be useful in other projects:\n• : get ADC value for a given pin/ADC channel in millivolts.\n• : sets the sample bits and read resolution. Default is 12-bit resolution. Range: 9 (0 – 511) to 12 bits (0 – 4095).\n• : sets the hardware sample bits and read resolution. Default is 12-bit resolution. Range: 9 to 12 bits. 9-bit = 0-511, 10-bit = 0-1023, 11-bit = 0-2047 and 12-bit = 0-4095.\n• : sets the number of cycles per sample. Default is 8. Range: 1 to 255.\n• : sets the number of samples in the range. Default is 1 sample. It has an effect of increasing sensitivity.\n• : sets the divider for the ADC clock. Default is 1. Range: 1 to 255.\n• : sets the input attenuation for all ADC pins. Default is . Accepted values:\n• : This function is the same as the previous one, except it sets the input attenuation for the specified pin.\n• : Attaches a pin to ADC (also clears any other analog mode that could be on) and returns true if configuration is successful, else returns false.\n• : starts an ADC conversion on the attached pin’s bus.\n• : checks if conversion on the pin’s ADC bus is currently running (returns TRUE or FALSE).\n• : gets the result of the conversion (waits if ADC has not finished), returns 16-bit integer.\n\nMore information can be found at readthedocs."
    },
    {
        "link": "https://deepbluembedded.com/esp32-adc-tutorial-read-analog-voltage-arduino",
        "document": "In this tutorial, you’ll learn about ESP32 ADC and how to read ESP32 analog input channels (in Arduino IDE). But first of all, you’ll get an introduction to what’s an ADC and how it works in most microcontrollers on a hardware level. Then, we’ll implement an ESP32 ADC analog input read example project, ESP32 ADC error sources, calibration, and much more.\n\nWe’ll also summarize the ESP32 ADC Arduino API functions, like analogRead(). Without further ado, let’s get right into it!\n\nYou can either get the complete course kit for this series of tutorials using the link down below. Or just refer to the table for the exact components to be used in practical LABs for only this specific tutorial.\n• Get The ESP32 Full Course Kit (List of components)\n\nAn ADC (Analog to Digital Converter) is an electronic circuit that’s usually integrated into most microcontrollers or comes in as a dedicated IC. We typically use an ADC in order to measure/read the analog voltage from different sources or sensors.\n\nMost parameters and variables are analog in nature and the electronic sensors that we use to capture this information are also analog. Just like temperature, light, pressure, and other sensors are all analog.\n\nThe ADC does the inverse operation of a DAC. While an ADC (A/D) converts analog voltage to digital data, the DAC (D/A) converts digital numbers to an analog voltage on the output pin.\n\nThis is an in-depth article (tutorial) on ADC, how it works, different types of ADC, error sources, sampling, and much more. Consider checking it out if it’s your first time learning about the ADC.\n\nIn this section, I’ll give you an introduction to the hardware capabilities of the ESP32 ADC peripheral, how it works, and what kind of features it has. So you can use it in an efficient way depending on the specific application requirements you have.\n\nThe ESP32 has 2 x 12-Bit SAR (Successive Approximation Register) ADC hardware peripherals that can read 18 different analog input channels.\n\nThe ADC firmware driver API supports ADC1 (8 channels, attached to GPIOs 32 – 39), and ADC2 (10 channels, attached to GPIOs 0, 2, 4, 12 – 15, and 25 – 27). However, the usage of ADC2 has some restrictions for the application:\n• ADC2 is used by the Wi-Fi driver. Therefore the application can only use ADC2 when the Wi-Fi driver has not been started.\n• Some of the ADC2 pins are used as strapping pins (GPIO 0, 2, 15) thus cannot be used freely.\n\nFor the exact pinout for our DevKit board’s ADC analog input pins, refer to this ESP32 devkit board pinout.\n\nEach one of the ESP32’s ADCs has its own logic controller units. Those control units are shown in the diagram below. They support each ADC to operate in multiple modes to achieve certain design goals (high-performance or low-power consumption).\n\nADC-RTC is controlled by the RTC controller and is suitable for low-frequency sampling operations.\n\nADC-DMA is controlled by a digital controller and is suitable for high-frequency continuous sampling actions.\n\nThose are the ESP32’s ADC features as stated by its datasheet:\n• Two SAR ADCs, with simultaneous sampling and conversion\n• Up to five SAR ADC controllers for different purposes (e.g. high performance, low power, or PWDET / PKDET)\n• DMA support (available on one controller)\n• Multiple channel-scanning modes (available on two controllers)\n• Operation during deep sleep (available on one controller)\n• Controlled by a ULP coprocessor (available on two controllers)\n\nThe ESP32 ADC analog input pins are 3.3v tolerant with a peak input voltage of 3.3v. So it’s the maximum voltage a pin can experience under any circumstances. However, you can still do some signal conditioning outside the microcontroller board to accept different input ranges.\n\nBut at the ADC analog input pin, the voltage should always be in the range (0 – 3.3v) regardless of what you’re doing externally. Maybe using a voltage divider network to read up to 6.6v inputs (you lose half the resolution by doing this), just to name a use case.\n\nThe default ADC voltage is for attenuation 0 dB and is listed in the table below. By setting higher attenuation it is possible to read higher voltages. Due to ADC characteristics, the most accurate results are obtained within the “suggested range” shown in the following table.\n\nIn the ESP32 Arduino Core ADC driver, you’ll find 2 functions dedicated to setting or changing the ADC analog input channel’s attenuation value. They are listed down below.\n• : Sets the attenuation for all ADC channels\n\nWe’ll be mostly using the first function or just ignore this feature altogether. Why? because its default value is -11dB attenuation which already gives us the maximum operating voltage range for the analog inputs (0 – 3.3v).\n\nThe ESP32 ADC has a programmable resolution that can be changed if you want to. By default, it’s a 12-Bit ADC. Which gives you readings in the range (0 – 4095). However, you can change the resolution bits by using the following function from Arduino Core ADC Driver.\n\nThe minimum resolution you can get is 9-Bit, at which the ADC conversion range is (0 – 511). You change it if you want, but in most applications, we’ll also leave this feature without changing the default 12-Bit resolution. I had to mention it just in case you need to use it in a particular project or something.\n\nYou can use the interactive tool below to set an analog input voltage and see the ESP32 ADC digital output value that corresponds to the analog input voltage. The output equation for the ADC is as follows: . Where V = 3.3v and n is the ADC resolution which is 12bits.\n\nThe ESP32 ADC reference voltage (V ) varies among different ESP32 chips. By design, the ADC reference voltage is 1100 mV, however, the true reference voltage can range from 1000 mV to 1200 mV amongst different ESP32s.\n\nWith that being said, the V setting has its own contribution to drifting the ADC readings away from being ideal. There are so many other reasons and sources for ADC errors as we’ll see in the next sections. But (V ) setting is one of them. The function down below can be used to change the default V pin if the device is not already calibrated.\n\nIt’s extremely important to guarantee a stable V voltage to get consistent readings with the ADC. We’ll address this shortly after to calibrate the ADC using the Espressif V calibration function.\n\nThe ESP32 ADC (SAR Type) does the conversion on multiple clock cycles depending on the resolution of the conversion. The faster the clock rate is, the faster the ADC will finish every single A/D conversion process.\n\nYou can actually control the F for the ESP32 ADC by changing the clock frequency division factor. Dividing by a larger number will result in a slower clock rate and vice versa. The Arduino Core ADC Driver has a function to change the ESP32 ADC clock rate as shown below.\n\nThe fastest conversion time for the ADC we can get (when clockDiv = 1). While the slowest option is when (clockDiv = 255).\n\nGenerally speaking, there are so many different sources of error when it comes to A/D conversion. Not only in ESP32, but it’s just how ADCs work in most microcontrollers. Usually, you’ll find one or more “AppNotes” from the manufacturer to guide you through calibrating and characterizing the ADC performance to get better results.\n\nLet’s start with the ESP32 ADC linearity error. An ideal ADC should be linear in response but in practice, you’ll find out non-linearity in the characteristics curve as you can see in the figure below.\n\nAs stated by Espressif in their documentation, ” The ESP32 ADC can be sensitive to noise leading to large discrepancies in ADC readings. To minimize noise, users may connect a 0.1uF capacitor to the ADC input pad in use. Multi-sampling may also be used to further mitigate the effects of noise”.\n\nYou should be careful before considering to add that capacitor. It’s going to attenuate all the high-frequency components in your analog signal. If you’re measuring a near-DC signal like a temperature sensor or something that’s physically slow to change, then it’s okay. Otherwise, I’d advise against adding any capacitance on the ADC input lines.\n\nInstead, I usually incorporate an active buffering for ADC inputs in most of my designs. However, you should also be careful when doing this. Going cheap on the op-amp will get you more trouble, noise, bandwidth limitation, and end up defeating the purpose of doing such a buffering thing.\n\nA great advantage of having an active buffering (like a voltage follower op-amp config.) is that it reduces the ADC channels cross-coupling while the ADC is switching from channel to channel, the internal ADC’s sampling capacitor will end up picking some measurement noise due to this. Having an active buffer will eliminate this sort of error.\n\nAs we’ve earlier stated, the V is by design around 1.1v but it does vary from chip to chip causing a non-negligible source of error. For this, we’ll be using the calibration method provided by Espressif and see the results. It’s going to be the last LAB in this tutorial, so stick around.\n\nThe ESP32 Arduino Core ADC driver’s API provides functions to correct for differences in measured voltages caused by variation of ADC reference voltages (V ) between ESP32 chips.\n\nCorrecting ADC readings using this API involves characterizing one of the ADCs at a given attenuation to obtain a characteristics curve (ADC-Voltage curve) that takes into account the difference in ADC reference voltage.\n\nThe characteristics curve is in the form of y = coeff_a * x + coeff_b and is used to convert ADC readings to voltages in mV. Calculation of the characteristics curve is based on calibration values which can be stored in eFuse or provided by the user.\n\nWe’ll be using this function to characterize the ADC parameters.\n\nThen, we’ll call the ADC read calibrated results functions or use the characteristics to get the results on our own without using the functions below. Especially because they’ll give you the ADC results (in mV) which you might not be interested in.\n\nIf you’re not familiar with the terminology, the ADC sampling rate is a measure of the ADC speed. In other words, it’s how many times per second can the ADC read an ESP32 analog input channel.\n\nThere is no clear statement of how fast the ESP32 ADC can go. Some users have reported getting decent results with a timer interrupt @ up to 10kHz. While in DMA mode, it can get much faster but also didn’t get any exact figures. We’ll be doing our own testing using ESP IDF (not Arduino) in the future and I’ll check this parameter in one way or another.\n\nIn this section, I’ll give you a step-by-step approach to what to do in order to read any ADC analog input pin.\n\nStep1– Decide on the ESP32 ADC analog input channel that you’re going to use\n\nlet it be GPIO 35 for example\n\nStep2– Call the analog read function to get the raw result\n\nOptionally you can apply any kind of digital filtering, calibration, or whatever you need before using the results as-is. I’d highly recommend doing a multi-sampling function to average the last-N readings (where N = 4 or more samples).\n• Write the ADC_Result to the PWM duty cycle output pin (LED)\n\nThe code example down below does the following: We start with defining and attaching The PWM GPIO pin. The pin I’ll be using a PWM pin is GPIO5 in this example.\n\nThen, we’ll be configuring the PWM Channel’s frequency (1kHz) & resolution (12-Bits to be similar to the ADC_Result). And in the main loop() function, I’ll read the ESP32 ADC analog input (potentiometer – GPIO35 pin), and write the result to the PWM duty cycle.\n\nChoose the board, COM port, hold down the BOOT button, click upload, and keep your finger on the BOOT button pressed. When the Arduino IDE starts sending the code, you can release the button and wait for the flashing process to be completed. Now, the ESP32 is flashed with the new firmware.\n\nClick The image to watch the demo video on YouTube\n\nIn this example, I’ve used the ADC Calibration functions from Arduino Core ADC APIs. For this LAB, you’ll need a pretty accurate DMM (digital multi-meter). Then, I’ve picked an analog input channel pin (GPIO35).\n\nYou’ll have to connect the potentiometer to that analog channel pin and tweak the pot until you get 2v (or any other value). Just make sure the DMM is reading an exact value (2v or any other value).\n\nNow, read the ADC with the analogRead() function without calibration or whatsoever and note down that value. For me, it was 1.85v, while the DMM is reading an exact 2v.\n\nThen, I’ve incorporated the ADC calibration functions in my code as shown below. The result was 1.99v which is very close to the DMM reading. But keep in mind that this calibration procedure has an offset (dead-band) on both ends of the spectrum (in my test that was 0.14v near-zero end and near 3.3v end).\n\nAnother type of error that you’ll probably experience is the noise and fluctuations in readings. This can be reduced by placing a small capacitor on the ADC input pin (Hardware solution). Or by applying a simple digital filter like the moving average filter (Software solution). Both will work in the same way but I’d go for the multi-sampling and averaging solution.\n\nThis is an example code for doing multi-sampling and averaging for a specific ADC channel. You can change the Filter_Length to whatever you want but note that the larger it gets, the slower the response of the filter gets (it increases the phase lag effect but it gets smoother as it attenuates more frequencies).\n\nClick The image to watch the demo video on YouTube\n\nNote that: the blue curve is the Raw ADC Readings, and the red curve is the Filtered ADC Readings.\n\nadcAttachPin(pin): Attach an analog input pin to the ADC\n\nanalogRead(pin): Get the ADC Value for the specified pin.\n\nanalogSetWidth(bits): Sets the ADC resolution (in bits). The default is 12-bit but the range is 9 to 12.\n\nanalogSetAttenuation(attenuation): Set the attenuation for all channels. Default is 11db but possible values are 0db, 2_5db, 6db, and 11db.\n\nanalogSetPinAttenuation(pin, attenuation): Set the attenuation for a particular pin.\n\nanalogSetClockDiv(clockDiv): Set the divider for the ADC clock.\n\nanalogSetVRefPin(pin): Set the pin to be used for ADC calibration if ESP32 is not already calibrated. Possible pins are 25, 26, or 27.\n\nanalogReadMilliVolts(pin): Reads an analog channel, converts the raw value to voltage (in mV), and returns that voltage value.\n\n★ Check The Full Course Complete Kit List & LAB Test Equipment Required For Debugging\n\nYou can download all attachment files for this Article/Tutorial (project files, schematics, code, etc..) using the link below. Please consider supporting my work through the various support options listed in the link below. Every small donation helps to keep this website up and running and ultimately supports our community.\n\nESP32 ADC hardware peripheral can be used in many applications as we’ll see in future tutorials. I’ll keep updating this series of tutorials by adding more applications and techniques that may help you in your projects. Drop me a comment if you’ve got any questions or suggestions, I’ll be glad to help!\n\nLearn More About ADC in General\n• How Does ADC Work? ADC Types, etc. Full ADC Tutorial (Complete Guide)\n\nYou can also check the ESP32 Course Home Page ???? for more ESP32 tutorials divided into sections based on categories. This may be helpful for you in case of searching for a specific tutorial or application."
    },
    {
        "link": "https://forum.arduino.cc/t/esp32-analogread-very-slow/1028266",
        "document": "I'd like to see the code, please, of an analog reading taking 100us and the code used to measure the time of the ADC reading. One could strip off using the Arduino core code and use the ESP32's API to read the A:D and strip off some computing time. #include <driver/adc.h> void setup() { adc1_config_width(ADC_WIDTH_12Bit); adc1_config_channel_atten(ADC1_CHANNEL_6, ADC_ATTEN_DB_11);// using GPIO 34 wind direction adc1_config_channel_atten(ADC1_CHANNEL_3, ADC_ATTEN_DB_11);// using GPIO 39 current adc1_config_channel_atten(ADC1_CHANNEL_0, ADC_ATTEN_DB_11);// using GPIO 36 battery volts } void fReadBattery( void * parameter ) { const float r1 = 50500.0f; // R1 in ohm, 50K const float r2 = 10000.0f; // R2 in ohm, 10k potentiometer const TickType_t xFrequency = 1000; //delay for mS float adcValue = 0.0f; float Vbatt = 0.0f; int printCount = 0; float vRefScale = (3.3f / 4096.0f) * ((r1 + r2) / r2); uint64_t TimePastKalman = esp_timer_get_time(); // used by the Kalman filter UpdateProcessNoise, time since last kalman calculation SimpleKalmanFilter KF_ADC_b( 1.0f, 1.0f, .01f ); TickType_t xLastWakeTime = xTaskGetTickCount(); for (;;) { adc1_get_raw(ADC1_CHANNEL_0); //read and discard adcValue = float( adc1_get_raw(ADC1_CHANNEL_0) ); //take a raw ADC reading KF_ADC_b.setProcessNoise( (esp_timer_get_time() - TimePastKalman) / 1000000.0f ); //get time, in microsecods, since last readings adcValue = KF_ADC_b.updateEstimate( adcValue ); // apply simple Kalman filter Vbatt = adcValue * vRefScale; xSemaphoreTake( sema_CalculatedVoltage, portMAX_DELAY ); CalculatedVoltage = Vbatt; xSemaphoreGive( sema_CalculatedVoltage ); printCount++; if ( printCount == 3 ) { //log_i( \"Vbatt %f\", Vbatt ); printCount = 0; } TimePastKalman = esp_timer_get_time(); // time of update complete xLastWakeTime = xTaskGetTickCount(); vTaskDelayUntil( &xLastWakeTime, xFrequency ); //log_i( \"fReadBattery %d\", uxTaskGetStackHighWaterMark( NULL ) ); } vTaskDelete( NULL ); } ////\n\n// this file: interrupt_analog_test.ino\n\n // This code is for testing analogRead delay\n\n // Compiled using Arduino IDE\n\n // ESP32-WROOM-DA Module\n\n // Board is ESP WROOM 32 made by www.diymore.cc\n\n // Does nothing more than fire a periodic timer\n\n // interrupt every 200 microseconds and an analogRead\n\n // inside the ISR: PinTEST is high before read,\n\n // then is low. An oscilloscope in PinTEST allows measure time.\n\n // Library installed: ESP32TimerInterrupt by Khoi Hoang version 2.2\n\n // in Boards Manager: ESP32 by Espressif systems version 2.0.4 digitalWrite(PinTEST, HIGH);\n\n value_discard = analogRead(34); //read analog value in\n\n //pin 34 and assign to an integer\n\n digitalWrite(PinTEST, LOW);\n\n } timer_for_test = timerBegin(0, 80, true);// use hardware timer nro. 0,\n\n // prescaler=80, rising edge\n\n timerAttachInterrupt(timer_for_test, &onTimer_Alarm_ISR, true); // associate ISR with pointer\n\n timerAlarmWrite(timer_for_test, 200, true); // makes hardware timer nro. 0 works in Alarm mode,\n\n //alarm set every 200 counts , automatic reload the timer for endless working\n\n timerAlarmEnable(timer_for_test); // Just Enable void loop() {\n\n // do nothing, only the timer interrupt routine fires every 200 microseconds\n\n }\n\n // end of file More precise measuring gives me 80 microseconds for each analogRead(). Still slow for me.\n\nI think you can find some of stuff you are looking for here: Analog to Digital Converter - ESP32-S2 - — ESP-IDF Programming Guide v4.2.3 documentation Yeah, tradeoff between ADC precision and measuring times. I haven't tried myself for ESP32 though, only Arduino Uno by manipulating its ADC status registers. If I were tried this for ESP32, I can give you definite answer for this.\n\nThis may be the best that can be achieved with the ESP32 ADC:\n\n https://www.toptal.com/embedded/esp32-audio-sampling 80 microseconds for each analogRead(). Still slow for me. What is your application?\n\nIs an experimental sampling of biological signals. This ends sampling 4 analog channels for 3 or 4 seconds and then send data over WiFi. I really appreciate a simple example of using ESP32's DMA analog sampling in Arduino IDE but all that i have found is for IDF and too complex.\n\nThanks dlloyd. Espressif has deleted file rtc_module.c . Of course, they do not use Arduino IDE, only IDF or whatever. The only thing that i have learn is that \" The implementation of adc1_get_raw is quite complex and does a lot of hardware initialization/locking around adc_convert() .\" [quote from Patrick, 2018/08/28]\n\n adc1_get_raw works in Arduino IDE and has a conversion time of 42 microseconds. Setting adc_set_clk_div() do not work in Arduino IDE."
    },
    {
        "link": "https://forum.arduino.cc/t/how-esp32-cam-adc-analogread/932937",
        "document": "Post a pinout of your ESP32 CAM board. I bet you may find that the A:D pins are not exposed. If you remember this part of the code: It eats up the ADC1 pins. If you are not using WiFi you may get ADC2 working. Here are the deets on ADC2. Analog to Digital Converter (ADC) - ESP32 - — ESP-IDF Programming Guide latest documentation (espressif.com).\n\nhow can I use the ADC pins to read analog values with the ESP32-CAM Board? All the exposed GPIO pins on the ESP32CAM are Analog pins apart from GPI016. But the exposed pins are also used by the SD card, so there is likely a conflict if the SD card is in use.\n\nHi,\n\n ADvalue = analogRead(GPIOpin); do not work! ADvalue = 0 constant.\n\n I don't use the SD card and I don't have any active librarys. If someone has the chance, give it a try.\n\n For the ESP32 without the CAM, no problem.\n\nhere is the code, I am of the opinion that analogRead does not work with ESP32-CAM. #include \"esp_camera.h\" #include <WiFi.h> #include <Arduino.h> // // WARNING!!! PSRAM IC required for UXGA resolution and high JPEG quality // Ensure ESP32 Wrover Module or other board with PSRAM is selected // Partial images will be transmitted if image exceeds buffer size // // Select camera model #define CAMERA_MODEL_AI_THINKER // Has PSRAM #include \"camera_pins.h\" // print the received signal strength: const char* ssid = \"XXXXXXXXXXXXXXXXXXX\"; const char* password = \"XXXXXXXXXXXXXXXXXXXX\"; // Set web server port number to 80 //WiFiServer server(555); void startCameraServer(); // Set your Static IP address IPAddress local_IP(192, 168, 2, 120); // local_IP(192, 168, 178, 210); // Set your Gateway IP address IPAddress gateway(192, 168, 2, 1); // gateway(192, 168, 178, 1); IPAddress subnet(255, 255, 255, 0); ///IPAddress primaryDNS(8, 8, 8, 8); //optional ///IPAddress secondaryDNS(8, 8, 4, 4); //optional void setup() { Serial.begin(115200); Serial.setDebugOutput(true); Serial.println(); camera_config_t config; config.ledc_channel = LEDC_CHANNEL_0; config.ledc_timer = LEDC_TIMER_0; config.pin_d0 = Y2_GPIO_NUM; config.pin_d1 = Y3_GPIO_NUM; config.pin_d2 = Y4_GPIO_NUM; config.pin_d3 = Y5_GPIO_NUM; config.pin_d4 = Y6_GPIO_NUM; config.pin_d5 = Y7_GPIO_NUM; config.pin_d6 = Y8_GPIO_NUM; config.pin_d7 = Y9_GPIO_NUM; config.pin_xclk = XCLK_GPIO_NUM; config.pin_pclk = PCLK_GPIO_NUM; config.pin_vsync = VSYNC_GPIO_NUM; config.pin_href = HREF_GPIO_NUM; config.pin_sscb_sda = SIOD_GPIO_NUM; config.pin_sscb_scl = SIOC_GPIO_NUM; config.pin_pwdn = PWDN_GPIO_NUM; config.pin_reset = RESET_GPIO_NUM; config.xclk_freq_hz = 20000000; config.pixel_format = PIXFORMAT_JPEG; // if PSRAM IC present, init with UXGA resolution and higher JPEG quality // for larger pre-allocated frame buffer. if(psramFound()){ config.frame_size = FRAMESIZE_UXGA; config.jpeg_quality = 10; config.fb_count = 2; } else { config.frame_size = FRAMESIZE_SVGA; config.jpeg_quality = 12; config.fb_count = 1; } //#if defined(CAMERA_MODEL_ESP_EYE) // pinMode(13, INPUT_PULLUP); // pinMode(14, INPUT_PULLUP); //#endif // camera init esp_err_t err = esp_camera_init(&config); if (err != ESP_OK) { Serial.printf(\"Camera init failed with error 0x%x\", err); return; } sensor_t * s = esp_camera_sensor_get(); // initial sensors are flipped vertically and colors are a bit saturated if (s->id.PID == OV3660_PID) { // s->set_vflip(s, 1); // flip it back s->set_brightness(s, 1); // up the brightness just a bit s->set_saturation(s, -2); // lower the saturation } // drop down frame size for higher initial frame rate s->set_framesize(s, FRAMESIZE_XGA); //FRAMESIZE_QVGA <- HIER standard Auflösung ändern !!! s->set_vflip(s, 1); s->set_hmirror(s, 1); // s->set_quality(s, 30); //#if defined(CAMERA_MODEL_M5STACK_WIDE) || defined(CAMERA_MODEL_M5STACK_ESP32CAM) // s->set_vflip(s, 1); // s->set_hmirror(s, 1); //#endif // Configures static IP address if (!WiFi.config(local_IP, gateway, subnet)) { // , primaryDNS, secondaryDNS Serial.println(\"STA Failed to configure\"); } WiFi.begin(ssid, password); while (WiFi.status() != WL_CONNECTED) { delay(500); Serial.print(\".\"); } Serial.println(\"\"); Serial.println(\"WiFi connected\"); startCameraServer(); Serial.print(\"Camera Ready! Use 'http://\"); Serial.print(WiFi.localIP()); Serial.println(\"' to connect\"); // #define POTI_PIN 12 // ADC2_5 !!! pinMode(12,INPUT); adcAttachPin(12); // analogReadResolution(11); //analogSetAttenuation(ADC_6db); } // SETUP END void loop() { Serial.print(\"0-4095 Potivalue: \");Serial.println(analogRead(12)); delay(500*1); } // PROGRAMM ENDE !\n\nClue4U Analog to Digital Converter (ADC) - ESP32 - — ESP-IDF Programming Guide latest documentation (espressif.com). i will not write the code for you but i will help with debugging. An example of using ADC1 under the Arduio iDE using the A:D ESP32 API #include <driver/adc.h> void setup () { // set up A:D channels, refer: https://dl.espressif.com/doc/esp-idf/latest/api-reference/peripherals/adc.html adc1_config_width(ADC_WIDTH_12Bit); adc1_config_channel_atten(ADC1_CHANNEL_0, ADC_ATTEN_DB_11);// using GPIO 36 } void fDoParticleDetector( void * parameter ) { /* ug/m3 AQI Lvl AQ (Air Quality) (air Quality Index) 0-35 0-50 1 Excellent 35-75 51-100 2 Average 75-115 101-150 3 Light pollution 115-150 151-200 4 moderate 150-250 201-300 5 heavy 250-500 >=300 6 serious */ float ADbits = 4095.0f; float uPvolts = 3.3f; float adcValue = 0.0f; float dustDensity = 0.0f; float Voc = 0.6f; // Set the typical output voltage, when there is zero dust. const float K = 0.5f; // Use the typical sensitivity in units of V per 100ug/m3. xEventGroupWaitBits (eg, evtWaitForBME, pdTRUE, pdTRUE, portMAX_DELAY ); TickType_t xLastWakeTime = xTaskGetTickCount(); const TickType_t xFrequency = 100; //delay for mS for (;;) { //enable sensor led gpio_set_level( GPIO_NUM_4, HIGH ); // set gpio 4 to high to turn on sensor internal led for measurement esp_timer_start_once( oneshot_timer, 280 ); // trigger one shot timer for a 280uS timeout, warm up time. xEventGroupWaitBits (eg, evtDoParticleRead, pdTRUE, pdTRUE, portMAX_DELAY ); // event will be triggered by the timer expiring, wait here for the 280uS adcValue = float( adc1_get_raw(ADC1_CHANNEL_0) ); //take a raw ADC reading from the dust sensor gpio_set_level( GPIO_NUM_4, LOW );//Shut off the sensor LED adcValue = ( adcValue * uPvolts ) / ADbits; //calculate voltage dustDensity = (adcValue / K) * 100.0; //convert volts to dust density if ( dustDensity < 0.0f ) { dustDensity = 0.00f; // make negative values a 0 } if ( xSemaphoreTake( sema_PublishPM, 0 ) == pdTRUE ) // don't wait for semaphore to be available { xSemaphoreTake( sema_MQTT_KeepAlive, portMAX_DELAY ); //log_i( \"ADC volts %f Dust Density = %ug / m3 \", adcValue, dustDensity ); // print the calculated voltage and dustdensity MQTTclient.publish( topicInsidePM, String(dustDensity).c_str() ); xSemaphoreGive( sema_MQTT_KeepAlive ); x_eData.PM2 = dustDensity; } xLastWakeTime = xTaskGetTickCount(); vTaskDelayUntil( &xLastWakeTime, xFrequency ); //log_i( \" high watermark % d\", uxTaskGetStackHighWaterMark( NULL ) ); } vTaskDelete( NULL ); }// end fDoParticleDetector() In the APi you'll see things like ADC2 channel 5 is GPIO12 (ESP32), GPIO16 (ESP32-S2) that you'd want to pay attention to."
    }
]