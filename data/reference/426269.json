[
    {
        "link": "https://wiki.st.com/stm32mcu/wiki/Getting_started_with_UART",
        "document": "There are 1 incomplete or pending task to finish installation of Semantic MediaWiki . An administrator or user with sufficient rights can complete it. This should be done before adding new data to avoid inconsistencies.\n\nThis message will disappear after all relevant tasks have been resolved.\n\nThis article explains what is UART and how to use it through examples\n\nThe universal synchronous/asynchronous receiver transmitter (USART/UART) offers a flexible means of full-duplex data exchange with external equipment requiring an industry standard NRZ asynchronous serial data format. USART can operate with a very wide range of baud rates using a programmable baud rate generator.\n\n It supports synchronous one-way communication and half-duplex single-wire communication, as well as multiprocessor communications. It also supports the LIN (Local Interconnect Network), Smartcard protocol and IrDA (Infrared Data Association) SIR ENDEC specifications and Modem operations (CTS/RTS).\n\n High speed data communication is possible by using the DMA (direct memory access) for multibuffer configuration. Also, the UART can be used with interrupt.\n\n This article goes through the following UART features: \n\n\n\nLearn how to set up UART and generate code with STM32CubeIDE and how to use HAL functions. \n\n\n\n\n\n\n\n This example uses the NUCLEO-L476RG board.\n• Select NUCLEO-L476RG board using Board Selector as shown in the figure below:\n\n\n\nIn case you haven't downloaded the STM32L476 Cube library, it will be downloaded automatically. This however may take some time.\n• Initialize all peripherals with their default settings.\n\n\n\nAnswer “Yes” to initialize all peripherals with their default mode? Popup as below:\n• Configure Parameter Settings as shown in the figure below: \n\n\n\nTo select the correct GPIOs pins, it is necessary to refer to the datasheet. Look for the alternate function table. \n\n STM32L476 USART1 uses PA9 for transmission (TX) and PA10 for reception (RX) as shown below:\n\n\n\n \n\n\n\n PA9 and PA10 should be configured as follows:\n\n\n\n \n\n\n\n\n\nYou will need a pair of boards, one will act as transmitter and the other as receiver. \n\n The two boards should be connected as follows: \n\n\n\nFirst of all, build your project \n\n Connect the first NUCLEO-L476RG board. It will act as the TX board in this example.\n\n Then, run your program \n\n The debug configurations window will open. Rename your configuration as UART Debug TX.\n\n\n\n \n\n\n\n In the debugger tab, click ST-LINK S/N and scan. A number will appear: this is your TX board ST-LINK serial number used to indicate that this debug configuration is related to this specific board.\n\n\n\n \n\n\n\n Click OK and the program will run autonomously on the TX board.\n\n\n\n Now, connect the second NUCLEO-L476RG board. It will act as the RX board in this example. Let's go through the code for this board. \n\n\n\nWe will use this breakpoint to stop the program after data is received, and check rx_buff[] value.\n\nFirst, we need to create a new debug configuration for the RX board.\n\n Click the little arrow of the debug button and click Debug Configurations... Then click the New launch configuration button.\n\n\n\n \n\n\n\nRename this configuration as UART Debug RX. Just as we did for the previous configuration, in the debugger tab, click ST-LINK S/N and scan. Make sure to select the new serial number that appears: it belongs to the RX board we just connected.\n\nThen click Debug.\n\nClick the Resume button to execute the code. Code execution should stop at the breakpoint we toggled earlier. Now hover over rx_buff[] to monitor its value.\n\n\n\n Alternatively, you can add rx_buff to Expressions, on the right side of STM32CubeIDE. \n\n \n\n\n\nRemain in the same configuration as previously. Both TX and RX boards should be connected to your computer.\n\n\n\nOpen the UART.ioc file in the STM32CubeIDE project as shown in the figure below:\n\n Enable USART1 global interrupt.\n\n\n\n \n\n\n\nThe program will run autonomously on the TX board.\n\n Now, let's go through RX board code. Don't forget to clear the previous code.\n\n\n\nWe will use this breakpoint to stop the program after data is received, and check rx_buff[] value.\n\n In this callback, you can use HAL_UART_Receive_IT to keep receiving data, otherwise you will only receive it once.\n\n Debug your RX project \n\n\n\nClick the Resume button to execute the code. Code execution should stop at the breakpoint we toggled earlier. Add rx_buff to Expressions, on the right side of STM32CubeIDE, to monitor its value. \n\n\n\n \n\n\n\nRemain in the same configuration as previously. Both TX and RX boards should be connected to your computer.\n\n\n\nOpen the UART.ioc file in the STM32CubeIDE project as shown in the figure below:\n\n Add the DMA request as shown in the figure below:\n\n\n\n \n\n\n\nThe program will run autonomously on the TX board.\n\n Now, let's go through RX board code. Don't forget to clear the previous code.\n\n\n\nWe will use this breakpoint to stop the program after data is received, and check rx_buff[] value.\n\n In this callback, you can use HAL_UART_Receive_DMA to keep receiving data, otherwise you will only receive it once.\n\n Debug your RX project \n\n\n\nClick the Resume button to execute the code. Code execution should stop at the breakpoint we toggled earlier. Add rx_buff to Expressions, on the right side of STM32CubeIDE, to monitor its value."
    },
    {
        "link": "https://visualgdb.com/tutorials/arm/stm32/uart/hal",
        "document": "This tutorial shows how to use the STM32 UART interface in different modes using the HAL libraries. We will show how to use direct mode, interrupt-based mode and DMA-controlled mode and will use a logic analyzer to compare the precise timings of various events.\n\nBefore you begin, install VisualGDB 5.2 or later.\n• On the next page select your STM32 device. We will use the Nucleo-F410RB board that has the STM32F410RB chip:\n• Connect your board to USB and let VisualGDB automatically recognize it and configure debug settings:\n• Press “Finish” to create the project. We will begin with a simple program that will read bytes via UART and echo them back in groups of 4. This requires four steps:\n• Enabling the clocks for the UART and GPIO peripherals.\n• Configuring the GPIO pins corresponding to UART to actually act as UART pins (as opposed to manually controlled GPIO) pins.\n• Initializing the UART module by specifying the operating parameters.\n• Actually reading and writing the data. Replace the code in your main source file with the following: #include <stm32f4xx_hal.h> #include <stm32_hal_legacy.h> #ifdef __cplusplus extern \"C\" #endif void SysTick_Handler(void) { HAL_IncTick(); HAL_SYSTICK_IRQHandler(); } static UART_HandleTypeDef s_UARTHandle = UART_HandleTypeDef(); int main(void) { HAL_Init(); __USART2_CLK_ENABLE(); __GPIOA_CLK_ENABLE(); GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.Pin = GPIO_PIN_2; GPIO_InitStructure.Mode = GPIO_MODE_AF_PP; GPIO_InitStructure.Alternate = GPIO_AF7_USART2; GPIO_InitStructure.Speed = GPIO_SPEED_HIGH; GPIO_InitStructure.Pull = GPIO_NOPULL; HAL_GPIO_Init(GPIOA, &GPIO_InitStructure); GPIO_InitStructure.Pin = GPIO_PIN_3; GPIO_InitStructure.Mode = GPIO_MODE_AF_OD; HAL_GPIO_Init(GPIOA, &GPIO_InitStructure); s_UARTHandle.Instance = USART2; s_UARTHandle.Init.BaudRate = 115200; s_UARTHandle.Init.WordLength = UART_WORDLENGTH_8B; s_UARTHandle.Init.StopBits = UART_STOPBITS_1; s_UARTHandle.Init.Parity = UART_PARITY_NONE; s_UARTHandle.Init.HwFlowCtl = UART_HWCONTROL_NONE; s_UARTHandle.Init.Mode = UART_MODE_TX_RX; if (HAL_UART_Init(&s_UARTHandle) != HAL_OK) asm(\"bkpt 255\"); for (;;) { uint8_t buffer[4]; HAL_UART_Receive(&s_UARTHandle, buffer, sizeof(buffer), HAL_MAX_DELAY); HAL_UART_Transmit(&s_UARTHandle, buffer, sizeof(buffer), HAL_MAX_DELAY); } }\n• We are using UART2 and pins PA2 and PA3 as the Nucleo-F410RB board has them connected to the on-board ST-Link UART interface, so we can use a terminal to interact with the board. You can find the GPIO pin numbers and the alternate function numbers corresponding to the UART interface on your device by searching the datasheet for the Alternate Function Mapping section: For STM32F410RB connecting UART2 to pins PA2 and PA3 requires enabling alternate function #7.\n• You can use a terminal program to talk to your STM32 board over the UART interface. If you are using VisualGDB Custom Edition, simply enable the Raw Terminal in VisualGDB Project Properties and it will show a terminal window inside the Visual Studio window:\n• Press F5 to start debugging. Try typing some text in the terminal window and see how after every 4 characters the program echoes them back:\n• Now we will explore the UART timings using a logic analyzer. First of all, modify your code to continuously output “test\\r\n\n” and use GPIOC10 to signal the lifetime of the HAL_UART_Transmit() function:\n• We will use Analyzer2Go to turn another STM32 board into a full-featured logic analyzer. Connect your second board to your computer, start Analyzer2Go and select the board type:\n• Connect the following signals between the boards:\n\n Any of the supported inputs Any of the supported inputs\n• Enable the connected signals in Analyzer2go to begin watching them. See how the HAL_UART_Transmit() function (red) is active during the entire transmission (blue):\n• Press the “Record” button to record several packets in a row. Then stop recording and zoom into one of them:\n• In order to automatically decode the UART bytes, open the Protocol Analyzers tab, drag/drop the UART analyzer and connect it to the corresponding signal:\n• You can analyze the raw encoding of the UART signals by selecting the decoded characters and creating notes for some of them:\n• Then switch to the “Raw” view to see the signal shape. You can click the “set clock period” button to highlight individual zeroes and ones:\n• The ‘t’ character was encoded as 0 0010 1110 1, which corresponds to a start bit (0) followed by a value of 0x74 (ASCII code for ‘t’) followed by a stop bit (1):\n• Try changing the stop bit amount to 2: See how the stop bit is now twice longer:\n• Although calling HAL_UART_Transmit() for every transmission is simple, it has one major disadvanrage. While the transmission is active, the program cannot do anything else and has to wait for it to complete. We will now use the interrupt-based transmission to free up some of the CPU cycles. Replace the code in your main source file with this: SysTick_Handler HAL_IncTick HAL_SYSTICK_IRQHandler UART_HandleTypeDef s_UARTHandle UART_HandleTypeDef USART2_IRQHandler HAL_GPIO_WritePin GPIOC, GPIO_PIN_12, GPIO_PIN_SET HAL_UART_IRQHandler s_UARTHandle HAL_GPIO_WritePin GPIOC, GPIO_PIN_12, GPIO_PIN_RESET HAL_UART_TxCpltCallback UART_HandleTypeDef huart HAL_GPIO_WritePin GPIOC, GPIO_PIN_11, GPIO_PIN_RESET main HAL_Init // <Initialize UART and GPIO as before> __GPIOC_CLK_ENABLE GPIO_InitStructure. GPIO_PIN_10 GPIO_PIN_11 GPIO_PIN_12 GPIO_InitStructure. GPIO_MODE_OUTPUT_PP HAL_GPIO_Init GPIOC, GPIO_InitStructure NVIC_EnableIRQ USART2_IRQn buffer HAL_GPIO_WritePin GPIOC, GPIO_PIN_10 GPIO_PIN_11, GPIO_PIN_SET HAL_GPIO_WritePin GPIOC, GPIO_PIN_12, GPIO_PIN_RESET HAL_UART_Transmit_IT s_UARTHandle, buffer, buffer HAL_GPIO_WritePin GPIOC, GPIO_PIN_10, GPIO_PIN_RESET HAL_Delay #include <stm32f4xx_hal.h> #include <stm32_hal_legacy.h> #ifdef __cplusplus extern \"C\" #endif void SysTick_Handler(void) { HAL_IncTick(); HAL_SYSTICK_IRQHandler(); } static UART_HandleTypeDef s_UARTHandle = UART_HandleTypeDef(); extern \"C\" void USART2_IRQHandler() { HAL_GPIO_WritePin(GPIOC, GPIO_PIN_12, GPIO_PIN_SET); HAL_UART_IRQHandler(&s_UARTHandle); HAL_GPIO_WritePin(GPIOC, GPIO_PIN_12, GPIO_PIN_RESET); } void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart) { HAL_GPIO_WritePin(GPIOC, GPIO_PIN_11, GPIO_PIN_RESET); } int main(void) { HAL_Init(); // <Initialize UART and GPIO as before> __GPIOC_CLK_ENABLE(); GPIO_InitStructure.Pin = GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12; GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP; HAL_GPIO_Init(GPIOC, &GPIO_InitStructure); NVIC_EnableIRQ(USART2_IRQn); for (;;) { char buffer[] = \"test\\r\n\n\"; HAL_GPIO_WritePin(GPIOC, GPIO_PIN_10 | GPIO_PIN_11, GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOC, GPIO_PIN_12, GPIO_PIN_RESET); HAL_UART_Transmit_IT(&s_UARTHandle, (uint8_t *)buffer, sizeof(buffer)); HAL_GPIO_WritePin(GPIOC, GPIO_PIN_10, GPIO_PIN_RESET); HAL_Delay(2); } } Don’t forget to copy the previous initialization code for UART and GPIO.\n• Set a breakpoint in HAL_UART_TxCpltCallback(), start debugging and wait for it to trigger. Then check the call stack: You can see how the UART interrupt got invoked when the main() function was already running HAL_Delay(). The USART2_IRQHandler() handler called the HAL_UART_IRQHandler() and the HAL_UART_IRQHandler() in turn called the HAL_UART_TxCpltCallback() once it determined that the last byte got transmitted.\n• Remove the breakpoint and restart the program. Then add the C11 and C12 signals to Analyzer2Go and make another recording. Note how the HAL_UART_Transmit_IT() function returns immediately (red) and the interrupt handler (green) is called after each byte is queued for transmission. Finally, the HAL_UART_TxCpltCallback() (orange signal switching to 0) is called once the last byte was physically sent:\n• Most of the time during the transmission the CPU will be able to run code unrelated to the transmission. It will only be interrupted by occasional UART interrupts. You can measure the overhead of the UART interrupts by comparing the byte transmission period to the width of the ‘ISR’ pulse. For STM32F410RB the overhead is 12 out of 96 microseconds (12.5%) regardless of the buffer size:\n• In order to reduce the interrupt-related overhead, we will show switch UART to use DMA (direct memory access). In this mode the DMA controller will automatically feed the entire buffer to the UART byte-by-byte and only raise an interrupt once the entire buffer is sent. Add the following static variable: Then replace the code below the code initializing GPIOC with the following: Remove the UART interrupt handler and add the DMA interrupt handler and 2 UART callbacks: Note that different devices have different DMA channel and stream numbers assigned to UART. Use the DMA Request Mapping table in your device’s reference manual (not datasheet) to get the correct numbers:\n• Start the program and ensure you still can see the stream of ‘test’ messages:\n• Go back to Analyzer2Go and and check the timing. See how now the DMA interrupt is only called twice per the entire transmission (once for each half of the buffer): If you measure the interrupt overhead now you should get 41 microseconds out of 670 (for the entire packet) or ~6%. The DMA interrupt overhead also doesn’t scale up when you increase buffer size, so sending 70 bytes in a packet instead of 7 would reduce the overhead to 0.6%.\n• Having a separate callback for each half of the buffer allows implementing double-buffering. While the DMA is transferring the first half of the buffer, you program could fill the second part with the next frame and vice versa. The same technique would also work for other DMA-capable peripherals, such as SPI (see the SPI tutorial for more details)."
    },
    {
        "link": "https://st.com/resource/en/user_manual/um1725-description-of-stm32f4-hal-and-lowlayer-drivers-stmicroelectronics.pdf",
        "document": ""
    },
    {
        "link": "https://controllerstech.com/how-to-setup-uart-using-registers-in-stm32",
        "document": "How to Setup UART using Registers This is yet another tutorial in the Register Based Series in STM32, and today we will see how can we setup the UART for Transmitting and receiving data. This will be a simple setup, with no interrupts or DMA. We will simply receive and Transmit the data in the blocking mode. I will cover the Interrupts and DMA in the upcoming tutorials. Let’s start with the PIN Setup for the UART I am going to use the UART 2, and the Pins that I need to setup are Pin PA2 for Tx and Pin PA 3 for Rx Since we are using the Pins for Alternate Function, we need to select the Alternate Function Mode in the MODE Register\n• Here we will enable the Clock for the GPIOA Port\n• Then select the Pins PA2 and PA3 in the Alternate Function mode\n• This is done by writing ‘1 0’ (2) in the 4th and 6th positions. Now the Pins are setup as the Alternate Functions, but we still need to choose which function exactly. For eg: Is it I2C, SPI or UART etc. This can be done in the Alternate Function Register\n• Here First we have to look up for which alternate function is associated with the UART 2\n• Now in the Alternate Function Register, we will choose the AF7 (0111) for the Respective Pins GPIOA->AFR[0] |= (7<<8); // Bites (11:10:9:8) = 0:1:1:1 --> AF7 Alternate function for USART2 at Pin PA2 GPIOA->AFR[0] |= (7<<12); // Bites (15:14:13:12) = 0:1:1:1 --> AF7 Alternate function for USART2 at Pin PA3 In some Microcontrollers, the Alternate Function Mode is not available Directly, for eg: in F103C8. Here We have to choose the Mode in a different way.\n• Here First of all we need to choose the correct mode from the GPIO Configuration for Device Peripherals\n• UART TX in full duplex mode should be set as Alternate Function Push Pull\n• and UART RX should be set as Input Pull UP\n• So we will configure the GPIO Control Register (CRL/CRH) based on this configuration. GPIOA->CRL = 0; GPIOA->CRL |= (3<<8); // output mode 50 MHz for PA2 GPIOA->CRL |= (2<<10); // Alternate Func Push Pull For PA2 GPIOA->CRL &= ~(3<<12); // Intput Mode For PA3 GPIOA->CRL |= (2<<14); // Input Pull Up/ Down For PA3 GPIOA->ODR |= 1<<3; // Pull Up for PA3 Now the Pin Configuration is complete, we will move to the UART Configuration. The most important Register used in UART configuration is UART Control Register 1 (CR1). Most of the Configuration is done here. I have only included the important bits in the image. The rest are kept 0 for now. We will modify them as per the requirement in the future. USART2->CR1 = 0x00; // Clear ALL USART2->CR1 |= (1<<13); // UE = 1... Enable USART USART2->BRR = (7<<0) | (24<<4); // Baud rate of 115200, PCLK1 at 45MHz USART2->CR1 |= (1<<2); // RE=1.. Enable the Receiver USART2->CR1 |= (1<<3); // TE=1.. Enable Transmitter\n• We will enable the UART first. To setup other bits, UART needs to be enabled.\n• Bit 12 is kept at 0, and it means there will be 1 start bit and 8 Data Bits.\n• Then We will enable the Transmitter and Receiver.\n• I am also selecting the Baud rate here. The details about the Baud Rate are mentioned below The Baud Rate can be Programmed into the Baud Rate Register (UART_BRR). The calculation for the Baud Rate is Shown below\n• Here the UART2 is connected to the APB1 Clock, and therefore the F = 45 MHz (APB1 Peripheral Frequency)\n• Now If we want the Baud Rate of 115200, the MENSTISSA will come equal to 24, and the FRACTION = 7\n• We will program these values in the 0th Position (for FRACTION) and in the 4th position (for MENTISSA) in the BRR Register. This completes the Configuration part of the UART. Now we will see how to send or receive data using the UART To handle the sending and the receiving, the STATUS Register plays a very vital part. Below is the picture of the Status register\n• Here we are mainly interested in these 3 bits.\n• TXE bit will be set once the content of the Data Register has been transferred to the Shift Register. Now the Shift Register will start sending the data to the Tx Line.\n• In the means time we can put another data byte into the Data Register, and later that byte will also be transferred to the Shift register.\n• Once all the data bytes have been transferred (after the stop bit is sent), the TC flag will be set.\n• Similarly during the receive, we will wait for the RXNE bit to set.\n• This bit is set if there is data in he DATA Register, and once it is confirmed, we can read the data. void UART2_SendChar (char c) { /*********** STEPS FOLLOWED ************* 1. Write the data to send in the USART_DR register (this clears the TXE bit). Repeat this for each data to be transmitted in case of single buffer. 2. After writing the last data into the USART_DR register, wait until TC=1. This indicates that the transmission of the last frame is complete. This is required for instance when the USART is disabled or enters the Halt mode to avoid corrupting the last transmission. ****************************************/ USART2->DR = c; // LOad the Data while (!(USART2->SR & (1<<6))); // Wait for TC to SET.. This indicates that the data has been transmitted } uint8_t UART2_GetChar (void) { /*********** STEPS FOLLOWED ************* 1. Wait for the RXNE bit to set. It indicates that the data has been received and can be read. 2. Read the data from USART_DR Register. This also clears the RXNE bit ****************************************/ uint8_t Temp; while (!(USART2->SR & (1<<5))); // Wait for RXNE to SET.. This indicates that the data has been Received Temp = USART2->DR; // Read the data. return Temp; }\n• Here we will load he data into the Data Register, and wait for the TC bit to set.\n• This will indicate that the data has been transferred\n• During the receive, we will wait for the RXNE bit to set.\n• This will indicate that there is some data available in the Data Register\n• Now we will read the data void delay (uint32_t time) { while (time--); } uint8_t buffer[30]; int indx = 0; int main (void) { SysClockConfig (); Uart2Config (); while (1) { // int c = UART2_GetChar (); // UART2_SendChar (c); UART2_SendString (str); delay (100000000); // buffer[indx] = UART2_GetChar (); // indx++; // if (indx>=30) indx = 0; } } Here after initializing the system clock and the UART, we can send or receive data in the while loop. Check out the Video Below You can help with the development by Below.\n\nTo download the project, click the button."
    },
    {
        "link": "https://reddit.com/r/embedded/comments/1f1iyox/trouble_setting_up_uart_on_stm32_using_hal_library",
        "document": "I am trying to setup UART on my STM32 using the HAL library and without using the .ioc file for auto-configuration.\n\nI first had a test project using the .ioc file to help me setup UART and was able to transmit data. However, when I do it myself and use a logic analyzer to observe TX and RX, I see that no data is being sent.\n\nBelow is the code for my STM32L476RG. What am I missing?"
    },
    {
        "link": "https://electronics.stackexchange.com/questions/440468/stm32-rtc-with-hal-libraries",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://community.st.com/t5/stm32-mcus-embedded-software/cannot-set-time-with-hal-rtc-settime-on-l412kb-nucleo32-after/td-p/233856",
        "document": "I seem to be unable to set the time more than once after reset. Here is a way to reproduce my problem:\n• Create a new CubeMX project with the RTC enabled\n• Edit the MSP init function the following way:\n• ...After the time and date are set by MSP init\n• ...change the hour in the sTime structure, e.g. sTime.Hours = 0x09;\n• run the code in the debugger and break in the new readTime call from step 6\n• note that the value of hour has not changed\n\nOr insert this code in your main() function:\n\nReading the reference manual, the HAL already issues the CR unlock bytes. I've read some posts about writing the RTC_BKP_DR1 with 0x32f2, but that also does not help (and is not mentioned in the reference manual).\n\nSeems like I'm missing something obvious?"
    },
    {
        "link": "https://community.st.com/t5/stm32cubemx-mcus/hal-rtc-setdate-bug-or-some-another-way-to-do/td-p/428471",
        "document": "I am using STM32F103 in my new application. I have used STM32Cube to generate my code including Internal RTC. My\n\nproblem is that the time is ok saved when reseted but date is always reset. when i inspected the code i found that the HAL_RTC_SetDate() function is not setting the RTC_CNTH and RTC_CNTL registers appropriately. Is it a bug or is there any other way of doing this. when we add day shouldn't the RTC_CNTH and RTC_CNTL added with (24hrs x 60 Mins x 60 Secs) this is not happening."
    },
    {
        "link": "https://stackoverflow.com/questions/47040039/stm32l4-rtc-hal-not-working",
        "document": "I'm having a strange behavior with the RTC on a stm32L476 with FreeRTOS.\n\nIt only reads the first time in RUN mode, RTC is working, because from run to run it saves the value of the internal register and is going up.\n\nAlso if I do DEBUG when I put breakpoint at stm32l4xx_hal_rtc.c at line 583:\n\nI can see the tmpreg and TR register how they update, and then when I click jump to next breakpoint witch is the same I saw the display updated.\n\nSo why it's not working when normal RUN?\n\ntask where clock is readed and printed all this task and functions are at the same menu.c:\n\nI print on the LCD a bar with the clock in the middle\n\nHere is the problematic part, as you can see I have tried a wait for synchro but also didn't work. I have some doubts of how does this syncro and RTC reading works.\n\nHere I only draw the clock on my display\n\nIt's possible I can't read the RTC fast as 100ms? some one could explain to me why is needed a syncronitzation? datasheet explains that if the clock is 7 time faster is ok, I'm using an 80Mhz APB1 clock\n\nsome tutorials and examples I've found the do the exact same I do, but they read on the main loop with osDelay() of many values. Is a problem using freeRTOS and reading from a task?\n\ntime has nothing to do I've tried with 5s delay and also don't works"
    },
    {
        "link": "https://sourcevu.sysprogs.com/stm32/HAL/symbols/HAL_RTC_SetTime",
        "document": "Reads data from the specified RTC Backup data Register.\n\nSets the specified RTC Alarm with Interrupt.\n\nGets the RTC Timestamp value.\n\nWaits until the RTC Time and Date registers (RTC_TR and RTC_DR) are synchronized with RTC APB clock.\n\nGets the RTC Alarm value and masks.\n\nDaylight Saving Time, adds one hour to the calendar in one single operation without going through the initialization procedure.\n\nDaylight Saving Time, subtracts one hour from the calendar in one single operation without going through the initialization procedure."
    }
]