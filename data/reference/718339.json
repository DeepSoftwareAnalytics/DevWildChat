[
    {
        "link": "https://docs.rs/tracing",
        "document": "is a framework for instrumenting Rust programs to collect structured, event-based diagnostic information.\n\nIn asynchronous systems like Tokio, interpreting traditional log messages can often be quite challenging. Since individual tasks are multiplexed on the same thread, associated events and log lines are intermixed making it difficult to trace the logic flow. expands upon logging-style diagnostics by allowing libraries and applications to record structured events with additional information about temporality and causality — unlike a log message, a span in has a beginning and end time, may be entered and exited by the flow of execution, and may exist within a nested tree of similar spans. In addition, spans are structured, with the ability to record typed data as well as textual messages.\n\nThe crate provides the APIs necessary for instrumenting libraries and applications to emit trace data.\n\nThe core of ’s API is composed of spans, events and subscribers. We’ll cover these in turn.\n\nTo record the flow of execution through a program, introduces the concept of spans. Unlike a log line that represents a moment in time, a span represents a period of time with a beginning and an end. When a program begins executing in a context or performing a unit of work, it enters that context’s span, and when it stops executing in that context, it exits the span. The span in which a thread is currently executing is referred to as that thread’s current span.\n\nThe module’s documentation provides further details on how to use spans.\n\nAn represents a moment in time. It signifies something that happened while a trace was being recorded. s are comparable to the log records emitted by unstructured logging code, but unlike a typical log line, an may occur within the context of a span.\n\nIn general, events should be used to represent points in time within a span — a request returned with a given status code, n new items were taken from a queue, and so on.\n\nThe struct documentation provides further details on using events.\n\nAs s and s occur, they are recorded or aggregated by implementations of the trait. s are notified when an takes place and when a is entered or exited. These notifications are represented by the following trait methods:\n\nIn addition, subscribers may implement the function to filter the notifications they receive based on metadata describing each or . If a call to returns for a given set of metadata, that will not be notified about the corresponding or . For performance reasons, if no currently active subscribers express interest in a given set of metadata by returning , then the corresponding or will never be constructed.\n\nFirst, add this to your :\n\nSpans and events are recorded using macros.\n\nThe macro expands to a struct which is used to record a span. The method on that struct records that the span has been entered, and returns a RAII guard object, which will exit the span when dropped.\n\nThe attribute provides an easy way to add spans to functions. A function annotated with will create and enter a span with that function’s name every time the function is called, with arguments to that function will be recorded as fields using .\n\nFor functions which don’t have built-in tracing support and can’t have the attribute applied (such as from an external crate), the struct has a method which can be used to easily wrap synchronous code in a span.\n\nYou can find more examples showing how to use this crate here.\n\ns are recorded using the macro:\n\nThe and macros as well as the attribute use fairly similar syntax, with some exceptions.\n\nBoth macros require a specifying the verbosity of the span or event. Optionally, the, target and parent span may be overridden. If the target and parent span are not overridden, they will default to the module path where the macro was invoked and the current span (as determined by the subscriber), respectively.\n\nThe span macros also take a string literal after the level, to set the name of the span (as above). In the case of the event macros, the name of the event can be overridden (the default is ) using the specifier.\n\nStructured fields on spans and events are specified using the syntax . Fields are separated by commas.\n\nAs shorthand, local variables may be used as field values without an assignment, similar to struct initializers. For example:\n\nField names can include dots, but should not be terminated by them:\n\nSince field names can include dots, fields on local structs can be used using the local variable shorthand:\n\nFields with names that are not Rust identifiers, or with names that are Rust reserved words, may be created using quoted string literals. However, this may not be used with the local variable shorthand.\n\nConstant expressions can also be used as field names. Constants must be enclosed in curly braces ( ) to indicate that the value of the constant is to be used as the field name, rather than the constant’s name. For example:\n\nThe sigil is shorthand that specifies a field should be recorded using its implementation:\n\nThe sigil operates similarly, but indicates that the value should be recorded using its implementation:\n\nThe and sigils may also be used with local variable shorthand:\n\nAdditionally, a span may declare fields with the special value , which indicates that that the value for that field does not currently exist but may be recorded later. For example:\n\nFinally, events may also include human-readable messages, in the form of a format string and (optional) arguments, after the event’s key-value fields. If a format string and arguments are provided, they will implicitly create a new field named whose value is the provided set of format arguments.\n\nSpecifying a formatted message in this manner does not allocate by default.\n\nalso offers a number of macros with preset verbosity levels. The , , , , and behave similarly to the macro, but with the argument already specified, while the corresponding , , , , and macros are the same, but for the macro.\n\nThese are intended both as a shorthand, and for compatibility with the crate (see the next section).\n\nUsers of the crate should note that exposes a set of macros for creating s ( , , , , and ) which may be invoked with the same syntax as the similarly-named macros from the crate. Often, the process of converting a project to use can begin with a simple drop-in replacement.\n\nLet’s consider the crate’s yak-shaving example:\n\nLibraries should link only to the crate, and use the provided macros to record whatever information will be useful to downstream consumers.\n\nIn order to record trace events, executables have to use a implementation compatible with . A implements a way of collecting trace data, such as by logging it to standard output.\n\nThis library does not contain any implementations; these are provided by other crates.\n\nThe simplest way to use a subscriber is to call the function:\n\nThis subscriber will be used as the default in all threads for the remainder of the duration of the program, similar to setting the logger in the crate.\n\nIn addition, the default subscriber can be set through using the function. This follows the pattern of using closures to represent executing code in a context that is exited at the end of the closure. For example:\n\nThis approach allows trace data to be collected by multiple subscribers within different contexts in the program. Note that the override only applies to the currently executing thread; other threads will not see the change from with_default.\n\nAny trace events generated outside the context of a subscriber will not be collected.\n\nOnce a subscriber has been set, instrumentation points may be added to the executable using the crate’s macros.\n\nThe crate provides a simple, lightweight logging facade for Rust. While builds upon ’s foundation with richer structured diagnostic data, ’s simplicity and ubiquity make it the “lowest common denominator” for text-based logging in Rust — a vast majority of Rust libraries and applications either emit or consume records. Therefore, provides multiple forms of interoperability with : instrumentation can emit records, and a compatibility layer enables s to consume records as s.\n\nThis crate provides two feature flags, “log” and “log-always”, which will cause spans and events to emit records. When the “log” feature is enabled, if no is active, invoking an event macro or creating a span with fields will emit a record. This is intended primarily for use in libraries which wish to emit diagnostics that can be consumed by applications using or , without paying the additional overhead of emitting both forms of diagnostics when is in use.\n\nEnabling the “log-always” feature will cause records to be emitted even if a is set. This is intended to be used in applications where a is being used to record a textual log, and is used only to record other forms of diagnostics (such as metrics, profiling, or distributed tracing data). Unlike the “log” feature, libraries generally should not enable the “log-always” feature, as doing so will prevent applications from being able to opt out of the records.\n\nSee here for more details on this crate’s feature flags.\n\nThe generated records’ messages will be a string representation of the span or event’s fields, and all additional information recorded by (target, verbosity level, module path, file, and line number) will also be populated. Additionally, records are also generated when spans are entered, exited, and closed. Since these additional span lifecycle logs have the potential to be very verbose, and don’t include additional fields, they will always be emitted at the level, rather than inheriting the level of the span that generated them. Furthermore, they are are categorized under a separate target, “tracing::span” (and its sub-target, “tracing::span::active”, for the logs on entering and exiting a span), which may be enabled or disabled separately from other records emitted by .\n\nThe crate provides a compatibility layer which allows a to consume records as though they were events. This allows applications using to record the logs emitted by dependencies using as events within the context of the application’s trace tree. See that crate’s documentation for details.\n\nIn addition to and , the repository contains several additional crates designed to be used with the ecosystem. This includes a collection of implementations, as well as utility and adapter crates to assist in writing s and instrumenting applications.\n\nIn particular, the following crates are likely to be of interest:\n• provides a compatibility layer with the crate, allowing spans to be attached to s, s, and s.\n• provides implementations and utilities for working with s. This includes a for logging formatted trace data to stdout, with similar filtering and formatting to the crate.\n• provides a compatibility layer with the crate, allowing log messages to be recorded as s within the trace tree. This is useful when a project using have dependencies which use . Note that if you’re using ’s , you don’t need to depend on directly.\n• provides utilities for outputting tracing data, including a file appender and non blocking writer.\n\nAdditionally, there are also several third-party crates which are not maintained by the project. These include:\n• implements inter-event timing metrics on top of . It provides a subscriber that records the time elapsed between pairs of events and generates histograms.\n• provides a subscriber for emitting traces to OpenTelemetry-compatible distributed tracing systems.\n• Provides a layer that reports traces spanning multiple machines to honeycomb.io. Backed by .\n• Provides a generic implementation of a layer that reports traces spanning multiple machines to some backend.\n• provides integration for the web framework.\n• provides integration for the actor framework.\n• provides integration and Application insights export for the web framework.\n• provides integration with the coz causal profiler (Linux-only).\n• provides a layer implementation that reports events and spans in bunyan format, enriched with timing information.\n• provides a / implementation that reports events and spans via browser and User Timing API ( ).\n• provides a layer implementation of level-aware logging of events to web browsers’ and span events to the User Timing API ( ).\n• provides a tide middleware to trace all incoming requests and responses.\n• takes care of initializing for tests, based on environment variables with an compatible syntax.\n• provides convenience methods to report failed unwraps on or types to a .\n• provides a way to collect Tracy profiles in instrumented applications.\n• provides a layer for reporting traces to Elastic APM.\n• provides a fluent assertions-style testing framework for validating the behavior of spans.\n• provides a layer for reporting events and traces to Sentry.\n• provides a subscriber that preserves contextual coherence by grouping together logs from the same spans during writing.\n• provides a layer for shipping logs to Grafana Loki.\n• provides a layer that formats events and spans into the logfmt format.\n• provides a layer that sends events to AWS CloudWatch Logs.\n• provides a tool to add, remove and check for .\n• provides a subscriber for emitting JSON logs. The output can be customized much more than with ’s JSON output.\n\nIf you’re the maintainer of a ecosystem crate not listed above, please let us know! We’d love to add your project to the list!\n\nThe following crate feature flags are available:\n• : causes trace instrumentation points to emit records as well as trace events, if a default subscriber has not been set. This is intended for use in libraries whose users may be using either or .\n• : Emit records from all spans and events, even if a subscriber has been set. This should be set only by applications which intend to collect traces and logs separately; if an adapter is used to convert records into events, this will cause duplicate events to occur.\n• : Includes support for the attribute. This is on by default, but does bring in the crate as a dependency, which may add to the compile time of crates that do not already use it.\n• : Depend on the Rust standard library (enabled by default). users may disable this feature with :\n\nThese feature flags enable unstable features. The public API may break in 0.1.x releases. To enable these features, the must be passed to when compiling.\n\nThe following unstable feature flags are currently available:\n• : Enables support for recording field values using the crate.\n\nThe easiest way to set the cfg is to use the env variable when running commands:\n\nAlternatively, the following can be added to the file in a project to automatically enable the cfg flag for that project:\n\nTracing is built against the latest stable release. The minimum supported version is 1.63. The current Tracing version is not guaranteed to build on Rust versions earlier than the minimum supported version.\n\nTracing follows the same compiler support policies as the rest of the Tokio project. The current stable Rust compiler and the three most recent minor versions before it will always be supported. For example, if the current stable compiler version is 1.69, the minimum supported version will not be increased past 1.66, three minor versions prior. Increasing the minimum supported compiler version is not considered a semver breaking change as long as doing so complies with this policy."
    },
    {
        "link": "https://github.com/tokio-rs/tracing",
        "document": "is a framework for instrumenting Rust programs to collect structured, event-based diagnostic information. is maintained by the Tokio project, but does not require the runtime to be used.\n\nIn order to record trace events, executables have to use a collector implementation compatible with . A collector implements a way of collecting trace data, such as by logging it to standard output. 's module provides a collector for logging traces with reasonable defaults. Additionally, is able to consume messages emitted by -instrumented libraries and modules.\n\nTo use , add the following to your :\n\nThen create and install a collector, for example using :\n\nUsing calls so this collector will be used as the default in all threads for the remainder of the duration of the program, similar to how loggers work in the crate.\n\nFor more control, a collector can be built in stages and not set globally, but instead used to locally override the default collector. For example:\n\nAny trace events generated outside the context of a collector will not be collected.\n\nThis approach allows trace data to be collected by multiple collectors within different contexts in the program. Note that the override only applies to the currently executing thread; other threads will not see the change from with_default.\n\nOnce a collector has been set, instrumentation points may be added to the executable using the crate's macros.\n\nLibraries should only rely on the crate and use the provided macros and types to collect whatever information might be useful to downstream consumers.\n\nstd error io tracing debug error info span warn // every time the instrumented function is called. The span is named after // the function or method. Parameters passed to the function are recorded as fields. -> + // this creates an event at the DEBUG level with two fields: // - `excitement`, with the key \"excitement\" and the value \"yay!\" // - `message`, with the key \"message\" and the value \"hello! I'm gonna shave a yak.\" // unlike other fields, `message`'s shorthand initialization is just the string itself. excitement = yak == // note that this is intended to demonstrate `tracing`'s features, not idiomatic // error handling! in a library or application, you should consider returning // a dedicated `YakError`. libraries like snafu or thiserror make this easy. io io -> // Constructs a new span named \"shaving_yaks\" at the TRACE level, // and a field whose key is \"yaks\". This is equivalent to writing: // local variables (`yaks`) can be used as field values // without an assignment, similar to struct initializers. span = yaks _enter = span yaks_shaved = yak ..=yaks res = yak yak shaved = res is_ok error = res // Like spans, events can also use the field initialization shorthand. // In this instance, `yak` is the field being initialized. yak error = error as_ref yaks_shaved += yaks_shaved yaks_shaved\n\nNote: Libraries should NOT install a collector by using a method that calls , as this will cause conflicts when executables try to set the default later.\n\nTo trace s, the preferred method is using the attribute:\n\nSpecial handling is needed for the general case of code using or blocks with / , as the following example will not work:\n\nThe span guard will not exit until the future generated by the block is complete. Since futures and spans can be entered and exited multiple times without them completing, the span remains entered for as long as the future exists, rather than being entered only when it is polled, leading to very confusing and incorrect output. For more details, see the documentation on closing spans.\n\nThis problem can be solved using the combinator:\n\nattaches a span to the future, ensuring that the span's lifetime is as long as the future's.\n\nUnder the hood, the macro performs the same explicit span attachment that does.\n\nTracing is built against the latest stable release. The minimum supported version is 1.63. The current Tracing version is not guaranteed to build on Rust versions earlier than the minimum supported version.\n\nTracing follows the same compiler support policies as the rest of the Tokio project. The current stable Rust compiler and the three most recent minor versions before it will always be supported. For example, if the current stable compiler version is 1.69, the minimum supported version will not be increased past 1.66, three minor versions prior. Increasing the minimum supported compiler version is not considered a semver breaking change as long as doing so complies with this policy.\n\nFirst, see if the answer to your question can be found in the API documentation. If the answer is not there, there is an active community in the Tracing Discord channel. We would be happy to try to answer your question. Last, if that doesn't work, try opening an issue with the question.\n\n🎈 Thanks for your help improving the project! We are so happy to have you! We have a contributing guide to help you get involved in the Tracing project.\n\nThe crate contains the primary instrumentation API, used for instrumenting libraries and applications to emit trace data. The crate contains the core API primitives on which the rest of is instrumented. Authors of trace subscribers may depend on , which guarantees a higher level of stability.\n\nAdditionally, this repository contains several compatibility and utility libraries built on top of . Some of these crates are in a pre-release state, and are less stable than the and crates.\n\nThe crates included as part of Tracing are:\n• : Collector implementations, and utilities for implementing and composing s. (crates.io|docs)\n• : Provides , a type for instrumenting errors with tracing spans\n• ; Provides a layer for generating flame graphs based on tracing span entry / exit events.\n• : Provides a layer for recording events to the Linux service, preserving structured data.\n\nIn addition to this repository, here are also several third-party crates which are not maintained by the project. These include:\n• implements inter-event timing metrics on top of . It provides a subscriber that records the time elapsed between pairs of events and generates histograms.\n• Provides a layer that reports traces spanning multiple machines to honeycomb.io. Backed by .\n• Provides a generic implementation of a layer that reports traces spanning multiple machines to some backend.\n• provides integration for the web framework.\n• provides integration for the actor framework.\n• provides integration and Application insights export for the web framework.\n• provides integration with the coz causal profiler (Linux-only).\n• provides a layer implementation that reports events and spans in bunyan format, enriched with timing information.\n• provides a tide middleware to trace all incoming requests and responses.\n• provides a formatter for rendering span traces in the style of\n• provides customized panic and eyre report handlers for for capturing span traces and backtraces with new errors and pretty printing them.\n• provides a proc macro for constructing spans from doc comments inside of functions.\n• provides a / implementation that reports events and spans via browser and User Timing API ( ).\n• provides a layer implementation of level-aware logging of events to web browsers' and span events to the User Timing API ( ).\n• takes care of initializing for tests, based on environment variables with an compatible syntax.\n• provides convenience methods to report failed unwraps on or types to a .\n• provides a way to collect Tracy profiles in instrumented applications.\n• provides a layer for reporting traces to Elastic APM.\n• provides a layer for reporting events and traces to Sentry.\n• provides a subscriber that preserves contextual coherence by grouping together logs from the same spans during writing.\n• provides a layer for shipping logs to Grafana Loki.\n• provides a layer that formats events and spans into the logfmt format.\n• provides a layer that exports trace data that can be viewed in .\n• provides a layer that sends events to AWS CloudWatch Logs.\n• provides a tool to add, remove and check for .\n\nNote: that some of the ecosystem crates are currently unreleased and undergoing active development. They may be less stable than and .\n\nThis is a list of links to blog posts, conference talks, and tutorials about Tracing.\n• Diagnostics with Tracing on the Tokio blog, August 2019\n• Custom Logging in Rust using and , part 1 and part 2, October 2021\n• Are we observable yet? @ RustyDays talk and slides, August 2020\n\nHelp us expand this list! If you've written or spoken about Tracing, or know of resources that aren't listed, please open a pull request adding them.\n\nThis project is licensed under the MIT license.\n\nUnless you explicitly state otherwise, any contribution intentionally submitted for inclusion in Tracing by you, shall be licensed as MIT, without any additional terms or conditions."
    },
    {
        "link": "https://durch.github.io/rust-goauth/tracing/index.html",
        "document": "is a framework for instrumenting Rust programs to collect structured, event-based diagnostic information.\n\nIn asynchronous systems like Tokio, interpreting traditional log messages can often be quite challenging. Since individual tasks are multiplexed on the same thread, associated events and log lines are intermixed making it difficult to trace the logic flow. expands upon logging-style diagnostics by allowing libraries and applications to record structured events with additional information about temporality and causality — unlike a log message, a span in has a beginning and end time, may be entered and exited by the flow of execution, and may exist within a nested tree of similar spans. In addition, spans are structured, with the ability to record typed data as well as textual messages.\n\nThe crate provides the APIs necessary for instrumenting libraries and applications to emit trace data.\n\nThe core of 's API is composed of spans, events and subscribers. We'll cover these in turn.\n\nTo record the flow of execution through a program, introduces the concept of spans. Unlike a log line that represents a moment in time, a span represents a period of time with a beginning and an end. When a program begins executing in a context or performing a unit of work, it enters that context's span, and when it stops executing in that context, it exits the span. The span in which a thread is currently executing is referred to as that thread's current span.\n\nThe module's documentation provides further details on how to use spans.\n\nAn represents a moment in time. It signifies something that happened while a trace was being recorded. s are comparable to the log records emitted by unstructured logging code, but unlike a typical log line,``s an may occur within the context of a span.\n\nIn general, events should be used to represent points in time within a span — a request returned with a given status code, n new items were taken from a queue, and so on.\n\nThe struct documentation provides further details on using events.\n\nAs s and s occur, they are recorded or aggregated by implementations of the trait. s are notified when an takes place and when a is entered or exited. These notifications are represented by the following trait methods:\n\nIn addition, subscribers may implement the function to filter the notifications they receive based on metadata describing each or . If a call to returns for a given set of metadata, that will not be notified about the corresponding or . For performance reasons, if no currently active subscribers express interest in a given set of metadata by returning , then the corresponding or will never be constructed.\n\nFirst, add this to your :\n\nSpans and events are recorded using macros.\n\nThe macro expands to a struct which is used to record a span. The [ ] method on that struct records that the span has been entered, and returns a RAII guard object, which will exit the span when dropped.\n\nThe attribute provides an easy way to add spans to functions. A function annotated with will create and enter a span with that function's name every time the function is called, with arguments to that function will be recorded as fields using .\n\nYou can find more examples showing how to use this crate here.\n\ns are recorded using the macro:\n\nThe and macros use fairly similar syntax, with some exceptions.\n\nBoth macros require a specifying the verbosity of the span or event. Optionally, the target and parent span may be overridden. If the target and parent span are not overridden, they will default to the module path where the macro was invoked and the current span (as determined by the subscriber), respectively.\n\nThe span macros also take a string literal after the level, to set the name of the span.\n\nStructured fields on spans and events are specified using the syntax . Fields are separated by commas.\n\nAs shorthand, local variables may be used as field values without an assignment, similar to struct initializers. For example:\n\nField names can include dots, but should not be terminated by them:\n\nSince field names can include dots, fields on local structs can be used using the local variable shorthand:\n\nThe sigil is shorthand that specifies a field should be recorded using its implementation:\n\nThe sigil operates similarly, but indicates that the value should be recorded using its implementation:\n\nThe and sigils may also be used with local variable shorthand:\n\nAdditionally, a span may declare fields with the special value , which indicates that that the value for that field does not currently exist but may be recorded later. For example:\n\nNote that a span may have up to 32 fields. The following will not compile:\n\nFinally, events may also include human-readable messages, in the form of a format string and (optional) arguments, after the event's key-value fields. If a format string and arguments are provided, they will implicitly create a new field named whose value is the provided set of format arguments.\n\nSpecifying a formatted message in this manner does not allocate by default.\n\nalso offers a number of macros with preset verbosity levels. The , , , , and behave similarly to the macro, but with the argument already specified, while the corresponding , , , , and macros are the same, but for the macro.\n\nThese are intended both as a shorthand, and for compatibility with the crate (see the next section).\n\nUsers of the crate should note that exposes a set of macros for creating s ( , , , , and ) which may be invoked with the same syntax as the similarly-named macros from the crate. Often, the process of converting a project to use can begin with a simple drop-in replacement.\n\nLet's consider the crate's yak-shaving example:\n\nLibraries should link only to the crate, and use the provided macros to record whatever information will be useful to downstream consumers.\n\nIn order to record trace events, executables have to use a implementation compatible with . A implements a way of collecting trace data, such as by logging it to standard output.\n\nThis library does not contain any implementations; these are provided by other crates.\n\nThe simplest way to use a subscriber is to call the function:\n\nThis subscriber will be used as the default in all threads for the remainder of the duration of the program, similar to setting the logger in the crate.\n\nIn addition, the default subscriber can be set through using the function. This follows the pattern of using closures to represent executing code in a context that is exited at the end of the closure. For example:\n\nThis approach allows trace data to be collected by multiple subscribers within different contexts in the program. Note that the override only applies to the currently executing thread; other threads will not see the change from with_default.\n\nAny trace events generated outside the context of a subscriber will not be collected.\n\nOnce a subscriber has been set, instrumentation points may be added to the executable using the crate's macros.\n\nThe crate provides a simple, lightweight logging facade for Rust. While builds upon 's foundation with richer structured diagnostic data, 's simplicity and ubiquity make it the \"lowest common denominator\" for text-based logging in Rust — a vast majority of Rust libraries and applications either emit or consume records. Therefore, provides multiple forms of interoperability with : instrumentation can emit records, and a compatibility layer enables s to consume records as s.\n\nThis crate provides two feature flags, \"log\" and \"log-always\", which will cause [spans] and [events] to emit records. When the \"log\" feature is enabled, if no is active, invoking an event macro or creating a span with fields will emit a record. This is intended primarily for use in libraries which wish to emit diagnostics that can be consumed by applications using or , without paying the additional overhead of emitting both forms of diagnostics when is in use.\n\nEnabling the \"log-always\" feature will cause records to be emitted even if a is set. This is intended to be used in applications where a is being used to record a textual log, and is used only to record other forms of diagnostics (such as metrics, profiling, or distributed tracing data). Unlike the \"log\" feature, libraries generally should not enable the \"log-always\" feature, as doing so will prevent applications from being able to opt out of the records.\n\nSee here for more details on this crate's feature flags.\n\nThe generated records' messages will be a string representation of the span or event's fields, and all additional information recorded by (target, verbosity level, module path, file, and line number) will also be populated. Additionally, records are also generated when spans are entered, exited, and closed. Since these additional span lifecycle logs have the potential to be very verbose, and don't include additional fields, they are categorized under a separate target, \"tracing::span\", which may be enabled or disabled separately from other records emitted by .\n\nThe crate provides a compatibility layer which allows a to consume records as though they were [events]. This allows applications using to record the logs emitted by dependencies using as events within the context of the application's trace tree. See that crate's documentation for details.\n\nIn addition to and , the repository contains several additional crates designed to be used with the ecosystem. This includes a collection of implementations, as well as utility and adapter crates to assist in writing s and instrumenting applications.\n\nIn particular, the following crates are likely to be of interest:\n• provides a compatibility layer with the crate, allowing spans to be attached to s, s, and s.\n• provides implementations and utilities for working with s. This includes a for logging formatted trace data to stdout, with similar filtering and formatting to the crate.\n• provides a compatibility layer with the crate, allowing log messages to be recorded as s within the trace tree. This is useful when a project using have dependencies which use . Note that if you're using 's , you don't need to depend on directly.\n• provides utilities for outputting tracing data, including a file appender and non blocking writer.\n\nAdditionally, there are also several third-party crates which are not maintained by the project. These include:\n• implements inter-event timing metrics on top of . It provides a subscriber that records the time elapsed between pairs of events and generates histograms.\n• provides a subscriber for emitting traces to OpenTelemetry-compatible distributed tracing systems.\n• Provides a layer that reports traces spanning multiple machines to honeycomb.io. Backed by .\n• Provides a generic implementation of a layer that reports traces spanning multiple machines to some backend.\n• provides integration for the actor framework.\n• provides integration with the coz causal profiler (Linux-only).\n• provides a layer implementation that reports events and spans in bunyan format, enriched with timing information.\n\nIf you're the maintainer of a ecosystem crate not listed above, please let us know! We'd love to add your project to the list!\n\nThe following crate feature flags are available:\n• : causes trace instrumentation points to emit records as well as trace events, if a default subscriber has not been set. This is intended for use in libraries whose users may be using either or .\n• : Emit records from all spans and events, even a subscriber has been set. This should be set only by applications which intend to collect traces and logs separately; if an adapter is used to convert records into events, this will cause duplicate events to occur.\n• : Includes support for the attribute. This is on by default, but does bring in the crate as a dependency, which may add to the compile time of crates that do not already use it.\n• : Depend on the Rust standard library (enabled by default). users may disable this feature with :"
    },
    {
        "link": "https://docs.rs/tracing-config",
        "document": ": For viewers, the links in the documentation do not work for you. The documentation is best read online at or locally. To generate the documentation locally :\n\nThe primary purpose of this crate is to allow rust programs to configure the crate using the implementation from the crate given a configuration file and a simple macro call in or in any function.\n\nThis crate is not meant to be used by library authors. If your project contains a file, remove from your project file.\n\nIf you use this crate to build and set up your global , the implementation will be a and all s added to said will be dynamic dispatch . Moreover ’s own will be added to the right after the root which will essentially keep an in memory representation of all (non filtered out) s practically negating any and all performance gained by s which does not keep an in-memory representation of a span data after it’s been created/entered. The visits the values and leverages s , to persist span data for the remaining of the span’s lifetime.\n\nIf you suspect that your application suffers performance penalties due to how tracing is configured:\n• Try a stricter filter or entirely remove some high verbosity tracing events (see )\n• Consider emitting less events, you should not debug your application using tracing, use a debugger instead.\n• Try building your subscriber manually in doing so removes the need for dynamic dispatch layers.\n• Lastly you can remove from your project file and find a different way to configure tracing.\n\n: Given that there are a myriad of programming languages that only use dynamic dispatch or heavily rely on it for logging/tracing purposes. I think that having the same in rust is no big deal especially because once your configuration is mature enough you can easily construct your subscriber without dynamic dispatch or the .\n\nSet the environment variable so that it points directly to the file.\n\nIf setting up an environment variable is too much work, you can also place in the current directory (usually near ), as well as your IDE will both work.\n• Place in the current directory (near ) and .\n• You can set the environment variable and have it point directly to a configuration file.\n• You can set the environment variable if you want a separate configuration file for tests.\n\nBoth environment variables can also point to a directory containing :\n• ; where is replaced by the in your .\n• … And only for tests ( ), files with the suffix are checked first (i.e.: and ).\n\nThe macro or the function can be supplied with:\n• : A pointing directly to a configuration file or to a directory.\n• : The key of an environment variable, pointing directly to a configuration file or to a directory.\n• defaults to in your .\n\nIn order to understand the directories mentioned in the following search path, please read the documentation of the crate. is constructed by default with empty strings except for the parameter which is the same that you supply to the macro (that defaults to if not set).\n\n and/or are optional but can either or both be supplied to which will forward them to the constructor.\n\nThe is an ordered list of either or or . The first element in the list has the highest priority. The search function will loop trough all elements from highest priority to least priority returning the first existing configuration file.\n• (supplied in source to the macro or the function).\n• (supplied in source to the macro or the function).\n• if is set but does not exist.\n• only for tests: if is set but does not exist.\n• if is set but does not exist.\n\nWithin each directory in the the first file that matches the following is accepted :\n• ; where is replaced by the in your or by the override passed to or .\n• … And only for tests ( ), files with the suffix are checked first (e.g.: )\n\nThe is processed as follows :\n• Environment variable entries ( , and ) specifying (or pointing to) a direct configuration file or directory are accepted if the file/directory exists, otherwise demoted to the directory in which the (non existing) file or directory resides (i.e.: it’s parent).\n• Entries specifying (or pointing to) a directory that does NOT exist are ignored.\n• Environment variable values containing tokens in the form of , are d by replacing the token with the value of the environment variable specified by if it exists; this is done recursively up to a certain depth (>=25).\n• If an environment variable points to an existing file, said file is accepted regardless of it’s name, though calling it is recommended.\n\nBy default, during initialization, will only emit errors and warnings in ansi color to the program’s standard output, this can be changed by setting a different level when calling (e.g: ) or otherwise, an environment variable can be set; accepted values are : , , , , , . Setting this to or will cause the function responsible to evaluate the to “print” information about where it’s looking and which file is accepted.\n\nCall with this overrides the environment variable, otherwise make sure it’s value is set to “none”, this is not recommended though, as the default verbosity is set to which only outputs warnings that should be resolved and hard errors which eventually panic if initialized by macro.\n\nTo fully understand the nomenclature of the configuration file, a thorough read of the documentation on both and crates is required; however, here is a brief summary:\n• is used by a and is responsible to write the data incoming form a to a destination, which can be anything, e.g.(standard_output, file, network, database, etc…). A writer as a component in the system is not strictly necessary since a could do the writing itself.\n• is something that receives structured events and spans (i.e.: all the information that and macro calls contain) and is responsible to either ignore such events and spans or format them and either directly write somewhere or send the formatted events and spans to a .\n• is a special kind of with the sole purpose of filtering out events and spans. A filter is exclusive, in that it allows everything by default unless there is an exclusion rule.\n\nThe that events and spans usually go trough is : -> -> .\n\nYou can find a detailed example and how the configuration file works in the docs for the .\n\n For a full understanding of the configuration file structure, start by reading the docs for the root level configuration structure i.e.: a structure.\n• : The configuration file can include environment variables in the form of tokens in any toml string in the file, they are d with .\n\nIn this basic example, we will configure a compact fmt layer with colors for the terminal/console.\n\n Next we will require an environment variable named (the name is arbitrary) which will point to a directory where we will save both .log files and .json files in subdirectories (.log for humans, and .json for machines).\n• Declare the that will output in color to the terminal/console.\n• Call it (again, name is arbitrary).\n• The of the layer is from\n• We will have to later declare a but we can name it now “terminal” (name is arbitrary).\n• We want the layer to use the .\n• Since this is the terminal, we disable\n• We now have to declare the writer named since the is using it.\n• We wanted the console as output so set the to no other configuration is necessary for this type of writer.\n• Next we need to declare 2 more layers, 1 that will write .log and the other that will write .json\n• Let’s start with the .log, it’s the same as the except :\n• We want since these will emit an event on span enter and exit.\n• This is a file, so we don’t want\n• Lastly we will have to declare another writer, in this example I will give it the same name as the layer i.e.: log-file.\n• Let’s also declare the layer for the json file before starting with the s.\n• The default config for the json layer is acceptable, although the flag is off by default, we set it explicitly here to show that pretty output is possible.\n• Now we have to declare 2 writers, one and another .\n• The output directory will be a subdirectory inside whatever directory the environment variable points to. We set with a reference to ."
    },
    {
        "link": "https://github.com/tugglecore/rust-tracing-primer",
        "document": "All material will be based on Tracing version 0.1 and as such all links will refer to pages related to Tracing's version 0.1. At the time of writing, Tokio version 0.2 is unreleased.\n\nThis is a guide and conceptual explaination of Tokio's Tracing crate and will not be a reference or a tutorial. Please refer to Tracing's documentation for a reference and more in-depth treatment of the Tracing crate.\n\nHere is a disclaimer for the present material.\n\nIn a Rust project in a shell of your choosing, add the dependencies\n\nthen in your rust function:\n\nI believe this modified code snippet from a blog post posted on the Tokio site about the tracing crate sums up the value of the Tracing crate:\n\nIf you normally see logs similar to the following:\n\nAnd you also agree that it is hard to track activaty for any particular IP address then the crate can upgrade your logs:\n\nThis is the special sauce of the crate: structured context for logs.\n\nLet's talk about the crate. There are four fundamental concepts to the crate: , , and .\n\nLog levels are very similar to what you will see in other logging libraries. Log levels add simple descriptors to summarize and categorize logs. Log levels are present in logs by prepending a description to the logs as shown below with this log\n\nYou may ask why use them and you can find plenty of answers online but here is mine: Without logs it will be difficult to distinguish your logs from another. Take for example the image below. Lets imagine each grey bar represent a specific log and for now ignore any other content.\n\nIt is very difficult to identify any subset of logs from this list of logs. Furthermore, if given a task to diagnosis a program there is no way to filter logs that are unrelated to the problem. Now compare the above image with the following image:\n\nEach log line has a color representative of its log level. Now it becomes easier to filter for desired logs specific to certain levels such as or .\n\nEvents represent some occurence or some phenomenon happening at some moment in time. Let's say your code finish generating a CSV file, then you might want to record that fact.\n\nNotice, how the macro accepts a log level. The log level aids in program diagnosis during benchmarking, debugging or general comprehension. Let's model this event on a timeline representing some given program:\n\nOne question to ask is what are the events that led to this event? Said differently, what was going on in the program, or what was the context, when this event was generated? The answer to this could be instrumental to understanding the behavior of a program. This leads us to the concept of spans.\n\nSpans represent some period of time, or more practically, some unit of work. They provide context for events for which can describe the conditions for a given event.\n\nLet's see how to create a span in code:\n\nHere we created a , entered the , perform some work and generated an event then drop the or exited the span.\n\nIt's recommended to create spans with the macro such as:\n\nLet's partially model this program to demonstrate the concept of spans:\n\nEach event happens within the context of a span providing information on the conditions for which caused an event to generate and illustrate the overall execution of a program.\n\nAt this point, we have covered the fundamental concepts of the crate and hopefully have the intuition to use these tools to introduce logging into your project. In the process of using the crate, you may run into some problems putting all the required crates together and that is the topic of the next section.\n\nA simplistic view of the crate is that it provides a set of publishers. All the macros in the crate produce events or spans but there is no code observing the events or spans. So, we need some code to listen to the publishers which is availiable in the crate.\n\nprovides a basic subscriber which will collect the information from the publishers in the crate.\n\nLet see it in action. Run the example .\n\nAt this point, this could be the end of the story. Add the two crates and , select a subscriber and start tracing.\n\nNow, over the course of a project you may encounter a scenario where you want to use features of two different subscribers and if they may happen then let me introduce the crate's Regisry.\n\nLets create an example where you would like to log tracing data to a file and also generate a flamegraph. From this description you may beleive you just need two subscribers and you are done. Alas, there is no available API to add multiple subscribers. In fact the design of the crate restricts projects from having multiple subscribers per thread. The reason being is a subscriber is responsible for assigning unique s to spans and thus multiple susbscribers will result in spans having multiple ids which complicate consuming the tracing data. So having a file subscriber and flamegraph subscriber on the same thread is not allowed. However, you still need at least one subscriber on a thread to collect the tracing data. So you want two subscribers but you are limited to only one on a thread. The remedy to this dilemma is to use a registry and some layers.\n\nA registry is a subscriber, provided by the crate, with the sole purpose to generate span ids for spans and as such be used as the authoritive subscriber for a given thread. However, unlike other subscribers which normally send the tracing data to some medium, the Registry will not send the tracing data anywhere. Lastly, when the Registry receive new events and spans it will notify Layers with the newly received events and spans.\n\nLayers are not Subscribers and as such will not assign ids to spans yet they posses much of the same behavior as Subscribers such as reading spans and events and normally they will send the tracing data to some medium. Most importantly, you can multiple Layers active on a given thread since a layer.\n\nSumming up, the Registry will handle span id generation while Layers will read and can write the tracing data, to say, a file or to generate a flamegraph. This brings us back to our opening example and we are finally able to see some code. Run the example\n\nHere are some other helpful resources by the community which are helpful:\n• Are we observable yet? An introduction to Rust telemtry\n• Get started with Tracing in Rust\n\nThis primer is authored by a non-contributor conmmuntiy member and represent my own thoughts and not contributors, maintainers or authors of the Tracing crate or any relatated crates."
    },
    {
        "link": "https://stackoverflow.com/questions/72947600/how-to-show-line-number-and-file-on-tracing-events",
        "document": "How to print what source and a trace log originated from with tracing and tracing-subscriber?\n\nThe code I'm working with is well prepared and contains lots of log prints, which is good, but most of them are not very descriptive:\n\nAnd the console prints only show module and error message, not where the code failed. When I replaced it with:\n\nI was able to get the file and line in but then all error messages are turned into just the string \"message\". There is probably a simpler way of enabling printing of line numbers."
    },
    {
        "link": "https://users.rust-lang.org/t/tracing-subscriber-how-to-print-file-name-and-line/62106",
        "document": "I'm trying to add file name and file line number based on tracing_subscriber default output, but I can't find related api.\n\nwhat I need is\n\nIs there a possible to do that without implementing a custom Subscriber?\n\n Thanks in advance!"
    },
    {
        "link": "https://stackoverflow.com/questions/70013172/how-to-use-the-tracing-library",
        "document": "The tracing library itself does not display any output or write to any files. It is simply a facade that is designed to allow developers to fire events that are grouped into spans in an agnostic way that is separate from how those events and spans are handled. The library is complicated because there are a multitude of ways to track spans and consume events and they need to be supported in a lightweight infrastructure.\n\nHowever, as a user you don't need to really worry about any of that. All you need to do is use the , , , , and macros to describe what your code is doing. Then if you're writing a program that should do something with those events and spans, you should set up a .\n\nThe simplest way to get up and running with logs printed to the console is using the basic formatting subscriber from the tracing-subscriber crate, and then you'll see events logged to the console:\n\nSo can get you going in a hurry; it does the job of creating a with a bunch of sensible defaults and registers itself as the global subscriber. It is very flexible too, you may note the output above doesn't include the events, and you may not care about showing the crate name in every message. That can be configured:\n\nEverything is designed to be flexible: If you want to send to a file instead of stdout, there's . If you want to send logs to multiple locations, you can compose multiple subscribers with a . If you want to filter only certain events based on their level, source, or content, there's . If you want to log in a JSON format instead of human readable text, you can use .\n\nA common next step would be to set up which would allow you to configure what events to log based on an environment variable instead of trying to configure it in-code. It can be as simple as / to set a max level, or it could be complicated like (log debug events from my crate, only log warnings for anything else).\n\nBeyond that, you're probably looking for something a bit more focused. Like you need to log in a specific format. Or you need to send events directly to an external provider. Or you're simply looking for a different way to view your data. Look in tracing's Related Crates section for other s that will hopefully suit your needs."
    },
    {
        "link": "https://docs.rs/tracing",
        "document": "is a framework for instrumenting Rust programs to collect structured, event-based diagnostic information.\n\nIn asynchronous systems like Tokio, interpreting traditional log messages can often be quite challenging. Since individual tasks are multiplexed on the same thread, associated events and log lines are intermixed making it difficult to trace the logic flow. expands upon logging-style diagnostics by allowing libraries and applications to record structured events with additional information about temporality and causality — unlike a log message, a span in has a beginning and end time, may be entered and exited by the flow of execution, and may exist within a nested tree of similar spans. In addition, spans are structured, with the ability to record typed data as well as textual messages.\n\nThe crate provides the APIs necessary for instrumenting libraries and applications to emit trace data.\n\nThe core of ’s API is composed of spans, events and subscribers. We’ll cover these in turn.\n\nTo record the flow of execution through a program, introduces the concept of spans. Unlike a log line that represents a moment in time, a span represents a period of time with a beginning and an end. When a program begins executing in a context or performing a unit of work, it enters that context’s span, and when it stops executing in that context, it exits the span. The span in which a thread is currently executing is referred to as that thread’s current span.\n\nThe module’s documentation provides further details on how to use spans.\n\nAn represents a moment in time. It signifies something that happened while a trace was being recorded. s are comparable to the log records emitted by unstructured logging code, but unlike a typical log line, an may occur within the context of a span.\n\nIn general, events should be used to represent points in time within a span — a request returned with a given status code, n new items were taken from a queue, and so on.\n\nThe struct documentation provides further details on using events.\n\nAs s and s occur, they are recorded or aggregated by implementations of the trait. s are notified when an takes place and when a is entered or exited. These notifications are represented by the following trait methods:\n\nIn addition, subscribers may implement the function to filter the notifications they receive based on metadata describing each or . If a call to returns for a given set of metadata, that will not be notified about the corresponding or . For performance reasons, if no currently active subscribers express interest in a given set of metadata by returning , then the corresponding or will never be constructed.\n\nFirst, add this to your :\n\nSpans and events are recorded using macros.\n\nThe macro expands to a struct which is used to record a span. The method on that struct records that the span has been entered, and returns a RAII guard object, which will exit the span when dropped.\n\nThe attribute provides an easy way to add spans to functions. A function annotated with will create and enter a span with that function’s name every time the function is called, with arguments to that function will be recorded as fields using .\n\nFor functions which don’t have built-in tracing support and can’t have the attribute applied (such as from an external crate), the struct has a method which can be used to easily wrap synchronous code in a span.\n\nYou can find more examples showing how to use this crate here.\n\ns are recorded using the macro:\n\nThe and macros as well as the attribute use fairly similar syntax, with some exceptions.\n\nBoth macros require a specifying the verbosity of the span or event. Optionally, the, target and parent span may be overridden. If the target and parent span are not overridden, they will default to the module path where the macro was invoked and the current span (as determined by the subscriber), respectively.\n\nThe span macros also take a string literal after the level, to set the name of the span (as above). In the case of the event macros, the name of the event can be overridden (the default is ) using the specifier.\n\nStructured fields on spans and events are specified using the syntax . Fields are separated by commas.\n\nAs shorthand, local variables may be used as field values without an assignment, similar to struct initializers. For example:\n\nField names can include dots, but should not be terminated by them:\n\nSince field names can include dots, fields on local structs can be used using the local variable shorthand:\n\nFields with names that are not Rust identifiers, or with names that are Rust reserved words, may be created using quoted string literals. However, this may not be used with the local variable shorthand.\n\nConstant expressions can also be used as field names. Constants must be enclosed in curly braces ( ) to indicate that the value of the constant is to be used as the field name, rather than the constant’s name. For example:\n\nThe sigil is shorthand that specifies a field should be recorded using its implementation:\n\nThe sigil operates similarly, but indicates that the value should be recorded using its implementation:\n\nThe and sigils may also be used with local variable shorthand:\n\nAdditionally, a span may declare fields with the special value , which indicates that that the value for that field does not currently exist but may be recorded later. For example:\n\nFinally, events may also include human-readable messages, in the form of a format string and (optional) arguments, after the event’s key-value fields. If a format string and arguments are provided, they will implicitly create a new field named whose value is the provided set of format arguments.\n\nSpecifying a formatted message in this manner does not allocate by default.\n\nalso offers a number of macros with preset verbosity levels. The , , , , and behave similarly to the macro, but with the argument already specified, while the corresponding , , , , and macros are the same, but for the macro.\n\nThese are intended both as a shorthand, and for compatibility with the crate (see the next section).\n\nUsers of the crate should note that exposes a set of macros for creating s ( , , , , and ) which may be invoked with the same syntax as the similarly-named macros from the crate. Often, the process of converting a project to use can begin with a simple drop-in replacement.\n\nLet’s consider the crate’s yak-shaving example:\n\nLibraries should link only to the crate, and use the provided macros to record whatever information will be useful to downstream consumers.\n\nIn order to record trace events, executables have to use a implementation compatible with . A implements a way of collecting trace data, such as by logging it to standard output.\n\nThis library does not contain any implementations; these are provided by other crates.\n\nThe simplest way to use a subscriber is to call the function:\n\nThis subscriber will be used as the default in all threads for the remainder of the duration of the program, similar to setting the logger in the crate.\n\nIn addition, the default subscriber can be set through using the function. This follows the pattern of using closures to represent executing code in a context that is exited at the end of the closure. For example:\n\nThis approach allows trace data to be collected by multiple subscribers within different contexts in the program. Note that the override only applies to the currently executing thread; other threads will not see the change from with_default.\n\nAny trace events generated outside the context of a subscriber will not be collected.\n\nOnce a subscriber has been set, instrumentation points may be added to the executable using the crate’s macros.\n\nThe crate provides a simple, lightweight logging facade for Rust. While builds upon ’s foundation with richer structured diagnostic data, ’s simplicity and ubiquity make it the “lowest common denominator” for text-based logging in Rust — a vast majority of Rust libraries and applications either emit or consume records. Therefore, provides multiple forms of interoperability with : instrumentation can emit records, and a compatibility layer enables s to consume records as s.\n\nThis crate provides two feature flags, “log” and “log-always”, which will cause spans and events to emit records. When the “log” feature is enabled, if no is active, invoking an event macro or creating a span with fields will emit a record. This is intended primarily for use in libraries which wish to emit diagnostics that can be consumed by applications using or , without paying the additional overhead of emitting both forms of diagnostics when is in use.\n\nEnabling the “log-always” feature will cause records to be emitted even if a is set. This is intended to be used in applications where a is being used to record a textual log, and is used only to record other forms of diagnostics (such as metrics, profiling, or distributed tracing data). Unlike the “log” feature, libraries generally should not enable the “log-always” feature, as doing so will prevent applications from being able to opt out of the records.\n\nSee here for more details on this crate’s feature flags.\n\nThe generated records’ messages will be a string representation of the span or event’s fields, and all additional information recorded by (target, verbosity level, module path, file, and line number) will also be populated. Additionally, records are also generated when spans are entered, exited, and closed. Since these additional span lifecycle logs have the potential to be very verbose, and don’t include additional fields, they will always be emitted at the level, rather than inheriting the level of the span that generated them. Furthermore, they are are categorized under a separate target, “tracing::span” (and its sub-target, “tracing::span::active”, for the logs on entering and exiting a span), which may be enabled or disabled separately from other records emitted by .\n\nThe crate provides a compatibility layer which allows a to consume records as though they were events. This allows applications using to record the logs emitted by dependencies using as events within the context of the application’s trace tree. See that crate’s documentation for details.\n\nIn addition to and , the repository contains several additional crates designed to be used with the ecosystem. This includes a collection of implementations, as well as utility and adapter crates to assist in writing s and instrumenting applications.\n\nIn particular, the following crates are likely to be of interest:\n• provides a compatibility layer with the crate, allowing spans to be attached to s, s, and s.\n• provides implementations and utilities for working with s. This includes a for logging formatted trace data to stdout, with similar filtering and formatting to the crate.\n• provides a compatibility layer with the crate, allowing log messages to be recorded as s within the trace tree. This is useful when a project using have dependencies which use . Note that if you’re using ’s , you don’t need to depend on directly.\n• provides utilities for outputting tracing data, including a file appender and non blocking writer.\n\nAdditionally, there are also several third-party crates which are not maintained by the project. These include:\n• implements inter-event timing metrics on top of . It provides a subscriber that records the time elapsed between pairs of events and generates histograms.\n• provides a subscriber for emitting traces to OpenTelemetry-compatible distributed tracing systems.\n• Provides a layer that reports traces spanning multiple machines to honeycomb.io. Backed by .\n• Provides a generic implementation of a layer that reports traces spanning multiple machines to some backend.\n• provides integration for the web framework.\n• provides integration for the actor framework.\n• provides integration and Application insights export for the web framework.\n• provides integration with the coz causal profiler (Linux-only).\n• provides a layer implementation that reports events and spans in bunyan format, enriched with timing information.\n• provides a / implementation that reports events and spans via browser and User Timing API ( ).\n• provides a layer implementation of level-aware logging of events to web browsers’ and span events to the User Timing API ( ).\n• provides a tide middleware to trace all incoming requests and responses.\n• takes care of initializing for tests, based on environment variables with an compatible syntax.\n• provides convenience methods to report failed unwraps on or types to a .\n• provides a way to collect Tracy profiles in instrumented applications.\n• provides a layer for reporting traces to Elastic APM.\n• provides a fluent assertions-style testing framework for validating the behavior of spans.\n• provides a layer for reporting events and traces to Sentry.\n• provides a subscriber that preserves contextual coherence by grouping together logs from the same spans during writing.\n• provides a layer for shipping logs to Grafana Loki.\n• provides a layer that formats events and spans into the logfmt format.\n• provides a layer that sends events to AWS CloudWatch Logs.\n• provides a tool to add, remove and check for .\n• provides a subscriber for emitting JSON logs. The output can be customized much more than with ’s JSON output.\n\nIf you’re the maintainer of a ecosystem crate not listed above, please let us know! We’d love to add your project to the list!\n\nThe following crate feature flags are available:\n• : causes trace instrumentation points to emit records as well as trace events, if a default subscriber has not been set. This is intended for use in libraries whose users may be using either or .\n• : Emit records from all spans and events, even if a subscriber has been set. This should be set only by applications which intend to collect traces and logs separately; if an adapter is used to convert records into events, this will cause duplicate events to occur.\n• : Includes support for the attribute. This is on by default, but does bring in the crate as a dependency, which may add to the compile time of crates that do not already use it.\n• : Depend on the Rust standard library (enabled by default). users may disable this feature with :\n\nThese feature flags enable unstable features. The public API may break in 0.1.x releases. To enable these features, the must be passed to when compiling.\n\nThe following unstable feature flags are currently available:\n• : Enables support for recording field values using the crate.\n\nThe easiest way to set the cfg is to use the env variable when running commands:\n\nAlternatively, the following can be added to the file in a project to automatically enable the cfg flag for that project:\n\nTracing is built against the latest stable release. The minimum supported version is 1.63. The current Tracing version is not guaranteed to build on Rust versions earlier than the minimum supported version.\n\nTracing follows the same compiler support policies as the rest of the Tokio project. The current stable Rust compiler and the three most recent minor versions before it will always be supported. For example, if the current stable compiler version is 1.69, the minimum supported version will not be increased past 1.66, three minor versions prior. Increasing the minimum supported compiler version is not considered a semver breaking change as long as doing so complies with this policy."
    },
    {
        "link": "https://tokio.rs/tokio/topics/tracing",
        "document": "The crate is a framework for instrumenting Rust programs to collect structured, event-based diagnostic information.\n\nIn asynchronous systems like Tokio, interpreting traditional log messages can often be quite challenging. Since individual tasks are multiplexed on the same thread, associated events and log lines are intermixed making it difficult to trace the logic flow. expands upon logging-style diagnostics by allowing libraries and applications to record structured events with additional information about temporality and causality — unlike a log message, a in has a beginning and end time, may be entered and exited by the flow of execution, and may exist within a nested tree of similar spans. For representing things that occur at a single moment in time, provides the complementary concept of events. Both s and s are structured, with the ability to record typed data as well as textual messages.\n\nYou can use to:\n• profile where your application is spending time\n\nTo begin, add and as dependencies:\n\nThe crate provides the API we will use to emit traces. The crate provides some basic utilities for forwarding those traces to external listeners (e.g., ).\n\nIf you are authoring an executable (as opposed to a library), you will need to register a tracing subscriber. Subscribers are types that process traces emitted by your application and its dependencies, and can perform tasks such as computing metrics, monitoring for errors, and re-emitting traces to the outside world (e.g., , , or an daemon).\n\nIn most circumstances, you should register your tracing subscriber as early as possible in your function. For instance, the type provided by prints formatted traces and events to , can be registered like so:\n\nIf you run your application now, you may see some trace events emitted by Tokio, but you will need to modify your own application to emit traces to get the most out of .\n\nIn the above example, we've configured with its default configuration. However, also provides a number of ways to configure the 's behavior, such as customizing the output format, including additional information (such as thread IDs or source code locations) in the logs, and writing the logs to somewhere other than .\n\nFor details on the available configuration options, see the documentation.\n\nIn addition to the type from , other s can implement their own ways of recording data. This includes alternative output formats, analysis and aggregation, and integration with other systems such as distributed tracing or log aggregation services. A number of crates provide additional implementations that may be of interest. See here for an (incomplete) list of additional implementations.\n\nFinally, in some cases, it may be useful to combine multiple different ways of recording traces together to build a single that implements multiple behaviors. For this purpose, the crate provides a trait that represents a component that may be composed together with other s to form a . See here for details on using s.\n\nThe easiest way to emit spans is with the proc-macro annotation provided by , which re-writes the bodies of functions to emit spans each time they are invoked; e.g.:\n\nEach invocation of will emit a Span that:\n• has a verbosity level of (the \"middle ground\" verbosity),\n• has fields and , whose values are the arguments of\n\nThe attribute is highly configurable; e.g., to trace the method in that handles each connection:\n\nwill now emit a Span for each incoming connection that:\n• has a verbosity level of (the \"middle ground\" verbosity),\n• has some structured data associated with it.\n• indicates that emitted span should include the representation of the connection's in a field called .\n• indicates that emitted span should not record 's debug representation.\n\nYou can also construct a manually by invoking the macro, or any of its leveled shorthands ( , , , , ).\n\nTo emit events, invoke the macro, or any of its leveled shorthands ( , , , , ). For instance, to log that a client sent a malformed command:\n\nIf you run your application, you now will see events decorated with their span's context emitted for each incoming connection that it processes."
    }
]