[
    {
        "link": "https://stackoverflow.com/questions/69373738/what-is-the-standard-acceptable-request-response-timeout-for-api-server-and-why",
        "document": "TLDR: Please see paragraph starting with \"The arbitrary number\" in bold below. The rest is just extra info on the topic.\n\nAlthough you might know this or have already read this in your research, I can share the following ideas:\n\nTypically the timeout is set depending on the expected complexity of a query, the amount of data to be processed, and the expected load of the system when the query occurs (or any other expected operation that may require attention in terms of modifying a timeout). Also, this can be based on something like the number of requests an API makes to other APIs to handle an incoming request(s) and what those expectations might be.\n\nThe arbitrary number (\"best guess\" of whoever developed the software) would typically be expected when planning for a \"most requests should complete in some fraction of this time if there is no issue regardless of what happens\" or \"this isn't anything to worry about\" type of scenario. Hence the default values for timeouts are pretty much based on the assumption that they represent the vast majority of \"acceptable\" completed requests where no issue is present. It is typically set somewhere between \"this should be plenty of time\" and \"there is most likely something terribly wrong with this request, let's end it\" and most successful requests pass this test by \"default\".\n\nIn the case that you have operations that may take several minutes and you expect that this can occur without an actual issue being present, you may want to set the timeout higher than the default so your requests don't timeout when there is no actual problem (for example, most commercial APIs have constraints on the number of requests and time in which they must complete so problematic requests don't clog up the system and other reasons as seen by their developers).\n\nThus, there really isn't a great answer or standard to this aside from just taking a look at the amount of data/requests to be processed, planning for a reasonable ebb and flow of server load, level of optimization of your code compared to the expected load, and so on... It's almost like error-handling but for things that you don't know might happen yet (such as unexpected bugs) but based on things you already know about your system and its expected usage.\n\nGenerally, you won't have many scenarios where the timeout really matters all that much but you always want to have one (at least the default) to prepare for the unexpected.\n\nI found the following article that talks about the topic and some of what I mentioned as well if you haven't seen it already:"
    },
    {
        "link": "https://requests.readthedocs.io/en/latest/user/advanced",
        "document": "This document covers some of Requests more advanced features.\n\nThe Session object allows you to persist certain parameters across requests. It also persists cookies across all requests made from the Session instance, and will use ’s connection pooling. So if you’re making several requests to the same host, the underlying TCP connection will be reused, which can result in a significant performance increase (see HTTP persistent connection). A Session object has all the methods of the main Requests API. Sessions can also be used to provide default data to the request methods. This is done by providing data to the properties on a Session object: # both 'x-test' and 'x-test2' are sent Any dictionaries that you pass to a request method will be merged with the session-level values that are set. The method-level parameters override session parameters. Note, however, that method-level parameters will not be persisted across requests, even if using a session. This example will only send the cookies with the first request, but not the second: If you want to manually add cookies to your session, use the Cookie utility functions to manipulate . Sessions can also be used as context managers: This will make sure the session is closed as soon as the block is exited, even if unhandled exceptions occurred. Sometimes you’ll want to omit session-level keys from a dict parameter. To do this, you simply set that key’s value to in the method-level parameter. It will automatically be omitted. All values that are contained within a session are directly available to you. See the Session API Docs to learn more.\n\nWhenever you receive a object from an API call or a Session call, the attribute is actually the that was used. In some cases you may wish to do some extra work to the body or headers (or anything else really) before sending a request. The simple recipe for this is the following: # do something with prepped.body 'No, I want exactly this as the body.' # do something with prepped.headers Since you are not doing anything special with the object, you prepare it immediately and modify the object. You then send that with the other parameters you would have sent to or . However, the above code will lose some of the advantages of having a Requests object. In particular, -level state such as cookies will not get applied to your request. To get a with that state applied, replace the call to with a call to , like this: # do something with prepped.body 'Seriously, send exactly these bytes.' # do something with prepped.headers When you are using the prepared request flow, keep in mind that it does not take into account the environment. This can cause problems if you are using environment variables to change the behaviour of requests. For example: Self-signed SSL certificates specified in will not be taken into account. As a result an is thrown. You can get around this behaviour by explicitly merging the environment settings into your session:\n\nIf you need to use a proxy, you can configure individual requests with the argument to any request method: Alternatively you can configure it once for an entire : Setting may behave differently than expected. Values provided will be overwritten by environmental proxies (those returned by urllib.request.getproxies). To ensure the use of proxies in the presence of environmental proxies, explicitly specify the argument on all individual requests as initially explained above. When the proxies configuration is not overridden per request as shown above, Requests relies on the proxy configuration defined by standard environment variables , , , and . Uppercase variants of these variables are also supported. You can therefore set them to configure Requests (only set the ones relevant to your needs): To use HTTP Basic Auth with your proxy, use the syntax in any of the above configuration entries: Storing sensitive username and password information in an environment variable or a version-controlled file is a security risk and is highly discouraged. To give a proxy for a specific scheme and host, use the form for the key. This will match for any request to the given scheme and exact hostname. Note that proxy URLs must include the scheme. Finally, note that using a proxy for https connections typically requires your local machine to trust the proxy’s root certificate. By default the list of certificates trusted by Requests can be found with: You override this default certificate bundle by setting the (or ) environment variable to another file path: In addition to basic HTTP proxies, Requests also supports proxies using the SOCKS protocol. This is an optional feature that requires that additional third-party libraries be installed before use. You can get the dependencies for this feature from : Once you’ve installed those dependencies, using a SOCKS proxy is just as easy as using a HTTP one: Using the scheme causes the DNS resolution to happen on the client, rather than on the proxy server. This is in line with curl, which uses the scheme to decide whether to do the DNS resolution on the client or proxy. If you want to resolve the domains on the proxy server, use as the scheme.\n\nRequests provides access to almost the full range of HTTP verbs: GET, OPTIONS, HEAD, POST, PUT, PATCH and DELETE. The following provides detailed examples of using these various verbs in Requests, using the GitHub API. We will begin with the verb most commonly used: GET. HTTP GET is an idempotent method that returns a resource from a given URL. As a result, it is the verb you ought to use when attempting to retrieve data from a web location. An example usage would be attempting to get information about a specific commit from GitHub. Suppose we wanted commit on Requests. We would get it like so: We should confirm that GitHub responded correctly. If it has, we want to work out what type of content it is. Do this like so: So, GitHub returns JSON. That’s great, we can use the method to parse it into Python objects. So far, so simple. Well, let’s investigate the GitHub API a little bit. Now, we could look at the documentation, but we might have a little more fun if we use Requests instead. We can take advantage of the Requests OPTIONS verb to see what kinds of HTTP methods are supported on the url we just used. Uh, what? That’s unhelpful! Turns out GitHub, like many API providers, don’t actually implement the OPTIONS method. This is an annoying oversight, but it’s OK, we can just use the boring documentation. If GitHub had correctly implemented OPTIONS, however, they should return the allowed methods in the headers, e.g. Turning to the documentation, we see that the only other method allowed for commits is POST, which creates a new commit. As we’re using the Requests repo, we should probably avoid making ham-handed POSTS to it. Instead, let’s play with the Issues feature of GitHub. This documentation was added in response to Issue #482. Given that this issue already exists, we will use it as an example. Let’s start by getting it. Cool, we have three comments. Let’s take a look at the last of them. Probably in the \"advanced\" section Well, that seems like a silly place. Let’s post a comment telling the poster that he’s silly. Who is the poster, anyway? OK, so let’s tell this Kenneth guy that we think this example should go in the quickstart guide instead. According to the GitHub API doc, the way to do this is to POST to the thread. Let’s do it. \"Sounds great! I'll get right on it!\" Huh, that’s weird. We probably need to authenticate. That’ll be a pain, right? Wrong. Requests makes it easy to use many forms of authentication, including the very common Basic Auth. Sounds great! I'll get right on it. Brilliant. Oh, wait, no! I meant to add that it would take me a while, because I had to go feed my cat. If only I could edit this comment! Happily, GitHub allows us to use another HTTP verb, PATCH, to edit this comment. Let’s do that. \"Sounds great! I'll get right on it once I feed my cat.\" Excellent. Now, just to torture this Kenneth guy, I’ve decided to let him sweat and not tell him that I’m working on this. That means I want to delete this comment. GitHub lets us delete comments using the incredibly aptly named DELETE method. Let’s get rid of it. Excellent. All gone. The last thing I want to know is how much of my ratelimit I’ve used. Let’s find out. GitHub sends that information in the headers, so rather than download the whole page I’ll send a HEAD request to get the headers. Excellent. Time to write a Python program that abuses the GitHub API in all kinds of exciting ways, 4995 more times.\n\nAs of v1.0.0, Requests has moved to a modular internal design. Part of the reason this was done was to implement Transport Adapters, originally described here. Transport Adapters provide a mechanism to define interaction methods for an HTTP service. In particular, they allow you to apply per-service configuration. Requests ships with a single Transport Adapter, the . This adapter provides the default Requests interaction with HTTP and HTTPS using the powerful urllib3 library. Whenever a Requests is initialized, one of these is attached to the object for HTTP, and one for HTTPS. Requests enables users to create and use their own Transport Adapters that provide specific functionality. Once created, a Transport Adapter can be mounted to a Session object, along with an indication of which web services it should apply to. The mount call registers a specific instance of a Transport Adapter to a prefix. Once mounted, any HTTP request made using that session whose URL starts with the given prefix will use the given Transport Adapter. The adapter will be chosen based on a longest prefix match. Be mindful prefixes such as will also match or . It’s recommended to terminate full hostnames with a . Many of the details of implementing a Transport Adapter are beyond the scope of this documentation, but take a look at the next example for a simple SSL use- case. For more than that, you might look at subclassing the . The Requests team has made a specific choice to use whatever SSL version is default in the underlying library (urllib3). Normally this is fine, but from time to time, you might find yourself needing to connect to a service-endpoint that uses a version that isn’t compatible with the default. You can use Transport Adapters for this by taking most of the existing implementation of HTTPAdapter, and adding a parameter ssl_version that gets passed-through to . We’ll make a Transport Adapter that instructs the library to use SSLv3: \"\"\"\"Transport adapter\" that allows us to use SSLv3.\"\"\" By default, Requests does not retry failed connections. However, it is possible to implement automatic retries with a powerful array of features, including backoff, within a Requests using the urllib3.util.Retry class:\n\nMost requests to external servers should have a timeout attached, in case the server is not responding in a timely manner. By default, requests do not time out unless a timeout value is set explicitly. Without a timeout, your code may hang for minutes or more. The connect timeout is the number of seconds Requests will wait for your client to establish a connection to a remote machine (corresponding to the connect()) call on the socket. It’s a good practice to set connect timeouts to slightly larger than a multiple of 3, which is the default TCP packet retransmission window. Once your client has connected to the server and sent the HTTP request, the read timeout is the number of seconds the client will wait for the server to send a response. (Specifically, it’s the number of seconds that the client will wait between bytes sent from the server. In 99.9% of cases, this is the time before the server sends the first byte). If you specify a single value for the timeout, like this: The timeout value will be applied to both the and the timeouts. Specify a tuple if you would like to set the values separately: If the remote server is very slow, you can tell Requests to wait forever for a response, by passing None as a timeout value and then retrieving a cup of coffee. The connect timeout applies to each connection attempt to an IP address. If multiple addresses exist for a domain name, the underlying will try each address sequentially until one successfully connects. This may lead to an effective total connection timeout multiple times longer than the specified time, e.g. an unresponsive server having both IPv4 and IPv6 addresses will have its perceived timeout doubled, so take that into account when setting the connection timeout. Neither the connect nor read timeouts are wall clock. This means that if you start a request, and look at the time, and then look at the time when the request finishes or times out, the real-world time may be greater than what you specified."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Methods/POST",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 .\n\nThe HTTP method sends data to the server. The type of the body of the request is indicated by the header.\n\nThe difference between and is that is idempotent: calling it once is no different from calling it several times successively (there are no side effects). Successive identical requests may have additional effects, such as creating the same order several times.\n\nHTML forms typically send data using and this usually results in a change on the server. For HTML forms the format/encoding of the body content is determined by the attribute of the element or the attribute of the or elements. The encoding may be one of the following:\n• : the keys and values are encoded in key-value tuples separated by an ampersand ( ), with an equals symbol ( ) between the key and the value (e.g., ). Non-alphanumeric characters in both keys and values are percent-encoded: this is the reason why this type is not suitable to use with binary data and you should use for this purpose instead.\n• : each value is sent as a block of data (\"body part\"), with a user agent-defined delimiter (for example, ) separating each part. The keys are described in the header of each part or block of data.\n\nWhen the request is sent following a call, or for any other reason than an HTML form, the body can be any type. As described in the HTTP 1.1 specification, is designed to allow a uniform method to cover the following functions:\n• Posting a message to a bulletin board, newsgroup, mailing list, or similar group of articles\n• Providing a block of data, such as the result of submitting a form, to a data-handling process"
    },
    {
        "link": "https://linkedin.com/pulse/how-set-request-timeout-rest-api-spring-boot-nilesh-mahant-uhdnf",
        "document": "This is the preferred way to set a timeout on a REST API using Resilience4j. The TimeoutDecorator can be used to decorate any functional interface, lambda expression, or method reference. To use the TimeoutDecorator, you first need to create a CircuitBreaker instance. Then, you can use the TimeoutDecorator.of() method to create a new TimeoutDecorator instance with the desired timeout value. Finally, you can use the TimeoutDecorator.executeSupplier() method to execute the functional interface, lambda expression, or method reference with the timeout applied."
    },
    {
        "link": "https://stackoverflow.com/questions/34852236/spring-boot-rest-api-request-timeout",
        "document": "I have a Spring Boot REST service that sometimes call third party services as a part of a request. I would like to set a timeout on all my resources (let's say 5 seconds), so that if any request handling (the whole chain, from incoming to response) takes longer than 5 seconds my controllers responds with HTTP 503 instead of the actual response. It would be awesome if this was just a Spring property, for example setting\n\nbut I haven't had any luck with that. I've also tried extending WebMvcConfigurationSupport and overriding configureAsyncSupport:\n\nI suspect I have to manually time all my third party calls, and if they take too long, throw a timeout exception. Is that right? Or is there any easier, holistic solution that covers all my request endpoints?"
    },
    {
        "link": "https://jsonapi.org",
        "document": "If you’ve ever argued with your team about the way your JSON responses should be formatted, JSON:API can help you stop the bikeshedding and focus on what matters: your application.\n\nBy following shared conventions, you can increase productivity, take advantage of generalized tooling and best practices. Clients built around JSON:API are able to take advantage of its features around efficiently caching responses, sometimes eliminating network requests entirely.\n\nHere’s an example response from a blog that implements JSON:API:\n\nThe response above contains the first in a collection of “articles”, as well as links to subsequent members in that collection. It also contains resources linked to the article, including its author and comments. Last but not least, links are provided that can be used to fetch or update any of these resources.\n\nJSON:API covers creating and updating resources as well, not just responses.\n\nJSON:API has been properly registered with the IANA. Its media type designation is .\n\nTo get started with JSON:API, check out documentation for the base specification.\n\nThe JSON:API community has created a collection of extensions that APIs can use to provide clients with information or functionality beyond that described in the base JSON:API specification. These extensions are called profiles.\n\nYou can browse existing profiles or create a new one.\n\nA more thorough history is available here.\n\nYou can subscribe to an RSS feed of individual changes here."
    },
    {
        "link": "https://medium.com/swlh/getting-json-data-from-a-restful-api-using-java-b327aafb3751",
        "document": "I like Java. It’s my go to object oriented programming language. It’s easy to use and it gets the job done. Recently, I had to implement an application that gets data from a REST API using Java and oh my god! I started hating Java.\n\nHaving previously worked with technologies such as “ReactJS”, getting JSON (JavaScript Object Notation) data from a RESTful API is just an “axios” call away. JavaScript makes it so easy for me to work with JSON data. Java on the other hand was a mess, and there was no proper material online that I could refer to. So I decided to help anyone who’s struggling to do this in Java.\n\nBefore we begin make sure you have downloaded and installed the JSON Simple Java library (https://github.com/fangyidong/json-simple). For this article I’ll be using the REST API for Covid-19 (https://api.covid19api.com/)\n\nThis is how our JSON data will look,\n\nFirst let’s set the URL object and type cast it into an HttpURLConnection object so that we can set request types and get response codes back. Since we’re only going to get data from the endpoint, let’s set the request method to “GET” and connect. Now we’ll be able to get a response code.\n\nMake sure everything is inside a try and catch block :)\n\nNow that we have a response code, let’s check if it’s successful and if so do the rest of the work.\n\nIf the response code is not 200 (Successful) we throw a new exception, otherwise we use a scanner to go through the URL stream and write all the data we get into a string.\n\nThen using the JSON Simple library we parse that string into a JSON object. Then we can get the object (or array) we want from that object using its key. Here I took the “Global” object containing all the global statistics and displayed the total number of recovered individuals.\n\nIf you want to access an array we simply cast the object we want to a JSONArray and within a for loop try to find the specific object we want from inside the array.\n\nHere you can see the code to get the total number of recovered individuals from “Albania”\n\nBelow you can find the code we used in its entirety,\n\nI hope this article helped anyone who was struggling with this problem. If I forgot to cover something or if something was unclear please let me know :)"
    },
    {
        "link": "https://moesif.com/blog/technical/api-development/Blueprint-to-Create-RESTful-APIs",
        "document": "Creating RESTful APIs is essential for efficient web service development. With this article, you’ll learn to create restful apis using Node.js and Express by following a concise, step-by-step approach designed for real-world application. From server setup to endpoint creation and securing data, we’ve got you covered. This comprehensive guide will ensure you grasp the fundamentals while also diving into the more nuanced aspects of RESTful API development. You’ll gain insights into best practices for designing your API for maximum scalability and performance, and learn how to handle common challenges that arise during development. Whether you’re a novice eager to get started or an experienced developer looking to refine your skills, this article will provide valuable knowledge to enhance your web service projects.\n\nDiving into the subject matter, the REST architecture needs to be understood first. As an architectural style for building web services, REST promotes a clear separation between the client and the server, facilitating the independent progression and scaling of each component. This architectural design not only enhances scalability but also boosts reliability and predictability, thanks to each client-server interaction being stateless. That is to say, each request is self-contained with all the required details for its execution.\n\nBeyond the client-server dichotomy, a uniform interface is another key aspect of REST. By abstracting the client from the server, it simplifies interactions and makes the system independently evolvable. A REST API, fundamentally, is a collection of standard protocols and guidelines that establish the framework for web services, using universal HTTP methods for interaction.\n\nAt the core of REST architecture lie six principles:\n\nEach principle is instrumental in the design of REST APIs for efficient, scalable systems. We’ll explore these principles in greater depth, along with their practical applications, in the upcoming segments.\n\nCrafting Your First REST API with Node.js and Express\n\nAs we step into the domain of REST API development, Node.js and Express stand out as the prime frameworks for developing straightforward REST API endpoints. From setting up the server.js file as the starting point to ensuring that the Node.js server is actively running for accessible API endpoints, the journey of building a REST API is an engaging endeavor.\n\nThe initial phase of this process involves establishing the appropriate environment. This initial setup is akin to laying the foundation for a building, providing a stable base on which to construct our API.\n\nThe initial phase of this process involves establishing the appropriate environment. This initial setup is akin to laying the foundation for a building, providing a stable base on which to construct our API. Before diving into the coding aspect, it’s essential to prepare your development environment. Here’s a step-by-step guide to get you started:\n\nEnsure Node.js and npm (Node Package Manager) are installed on your system. Node.js serves as the runtime environment, while npm is the package manager that allows you to install various libraries, including Express.\n\nOpen your terminal or command prompt, navigate to the folder where you want to create your project, and run:\n\nInitialize a Node.js Project To create a file which holds metadata about the project and its dependencies, run:\n\nInside your project directory, install Express using npm by running:\n\nThis command adds Express to your project’s dependencies, allowing you to start building your REST API.\n\nWith the environment set up, let’s create a simple server using Express. This involves writing a small amount of code in a file, traditionally named , to start your server and listen for requests.\n\nOpen in your text editor and add the following code:\n\nThis code snippet does the following:\n• Sets up a basic route ( ) that responds with a message when accessed via a GET request.\n• Starts the server on a specified port (3000 in this example), logging a message to the console once it’s running.\n\nTo start your server, go back to your terminal and run:\n\nYou should see a message indicating that the server is running. Open a web browser and navigate to . You will be greeted with the message, “Hello World! This is my first REST API.”\n\nNice, you’ve just set up your development environment and created a simple server with Express to serve your first REST API endpoint! This forms the foundation upon which you can build more complex APIs, adding more routes and functionality as needed.\n\nNow that the groundwork has been laid, we can commence the building process. And in REST API development, building starts with defining endpoints and HTTP methods, including handling HTTP requests. To build a REST API, it’s essential to understand the standard HTTP methods - GET, PUT, POST, and DELETE - as these are the tools we use to define endpoints for CRUD (Create, Read, Update, Delete) operations, including handling delete requests. These methods, when combined with clear and intuitive endpoints, provide a structured interface that clients can use to manage information intuitively.\n\nCreating a REST API involves more than just setting up a server; it requires defining specific paths (endpoints) and how they respond to different HTTP requests. This is crucial for performing CRUD operations. Let’s dive into how we can define these operations using HTTP methods like GET, POST, PUT, and DELETE, and set up a structured request and response system.\n\nLet’s say we want to retrieve a list of items. We use a GET request for reading data.\n\nTo create a new item, we use a POST request. This involves sending data (in the body of the request) from the client to the server.\n\nUpdating data can be accomplished with a PUT request, specifying the item’s ID in the endpoint.\n\nFor deleting an item, a DELETE request is used, also specifying the item’s ID.\n\nBy defining endpoints and handling HTTP methods appropriately, we lay the foundation for a robust REST API that allows clients to perform CRUD operations intuitively. This setup not only makes our API more structured but also ensures that it can handle complex data manipulation and interaction seamlessly.\n\nIn a REST API, both the request from the client and the response from the server typically use JSON (JavaScript Object Notation) for the body’s structure. This format is easy to read and write for humans and easy for machines to parse and generate.\n• Request Body: When clients make POST or PUT requests, they send a JSON object in the request body, which contains the data to be created or updated.\n• Response Payload: The server responds with a JSON object. This could be the created or updated data, a confirmation message, or, in the case of GET requests, an array of objects.\n\nUsing JSON ensures consistency in the way data is sent and received, making the API more intuitive to use. Furthermore, setting appropriate status codes (like 200 for success, 201 for created, 404 for not found) in the response helps the client understand the outcome of their request.\n\nPreventing processing delays and potential errors can be achieved by evading unnecessary data and prudently utilizing nested data structures. This involves careful consideration of the data that is essential for each API call, ensuring that each JSON object sent in a request or response contains only what is necessary for that particular interaction. Avoiding overly complex or deeply nested structures helps to maintain clarity and aids in the processing speed of the API.\n\nIt’s important to establish a schema for the request and response data. This schema acts as a contract that defines the format, type, and constraints of the data elements within the API’s exchange. Utilizing schemas not only helps in validating the data but also serves as documentation for the expected data model, which can be extremely beneficial for both the API developers and consumers.\n\nIn addition to the structure, the way data is handled in the request body and response payload can significantly impact the performance and usability of the API. For example, pagination in the response payload can help manage large datasets by breaking them down into smaller, more manageable chunks. This improves the client’s ability to consume and process the data, as well as the efficiency of data transmission over the network.\n\nOverall, thoughtful structuring of the request body and response payload is a critical aspect of RESTful API design that contributes to the creation of robust, scalable, and user-friendly APIs.\n\nMuch like any design process, API design aims at developing something that is not only operational but also intuitive and capable of scaling. Horizontal scaling, for instance, is a preferable approach over vertical scaling for maintaining scalable and high-performing APIs.\n\nIncorporating cache layers in HTTP and along the API request processing pipeline significantly contributes to sustaining API performance.\n\nData forms the core of APIs, and its efficient management is critical to the success of a RESTful API. JSON (JavaScript Object Notation) is one of the standardized data formats commonly used when interacting with RESTful APIs.\n\nAlong with data modeling, which is essential for identifying the structure of data and its interrelationships, JSON enables efficient operations in RESTful APIs.\n\nWithin the domain of REST API, the representation of resources is of paramount importance. Using plural nouns to represent resources in REST API endpoints makes the API more intuitive for those interacting with it. These endpoints, or URLs, represent resources in a web service, allowing for actions to be performed on these resources like creating, reading, updating, and deleting.\n\nBy meticulously structuring data, defining clear resource representations, and managing data transfer formats, developers lay the groundwork for powerful web services. It’s a process that demands attention to detail and a deep understanding of web standards, but the rewards—scalable, efficient, and user-friendly APIs—are well worth the effort.\n\nManaging data transfer and choosing the right data format is as important as determining resource representations. The Last-Modified header, for instance, is used in content negotiation to indicate when the associated resource last changed, which is crucial for data transfer management.\n\nThe foundation of dependable API development lies in robust error management. Implementing proper HTTP status codes and detailed error messages helps engineers quickly identify problems. Moreover, mapping all exceptions in an error payload that describes the origin of the error and provides guidance on how to address it offers clearer feedback during unexpected situations.\n\nSecurity holds utmost importance in every digital undertaking, including API development. Implementing authentication and authorization protocols like OAuth 2.0 is crucial for the security of your RESTful API. Additional security measures such as SSL/TLS encryption and fine-grained access control complement API key usage to protect sensitive information.\n\nTo boost API performance, caching serves as an influential tool. Using data caching solutions like Redis and apicache improves the overall experience, serves often requested resources more quickly, and reduces querying from the database.\n\nCache-Control headers are used to manage the duration and location of cached responses, including their validation before use.\n\nAPI development is incomplete without the integral process of testing. Automated testing frameworks like Rspec, API Fortress, and Postman can enhance testing procedures, allowing for structured, extendable, reusable, and maintainable tests.\n\nPrior to testing REST APIs, understanding API requirements, including query parameter usage, is imperative for proper test data and verification method preparation.\n\nDocumentation, being the initial interaction point for consumers with an API, aids developers in using the API effectively. Clear and thorough API documentation is crucial for understanding functionalities, endpoints, request/response formats, authentication, rate limits, and error handling. Including practical code examples within the documentation enhances developers’ understanding of how to implement the API.\n\nThe optimization of APIs for third-party apps focuses on facilitating effortless integration and updates. API versioning is essential for allowing service providers to introduce changes without disrupting existing clients. Optimizing API architecture for modularity helps manage complexity and isolates issues, facilitating the integration of superfluous services.\n\nFrom understanding the core principles of REST architecture to the intricacies of crafting, testing, and optimizing REST APIs, we’ve embarked on a comprehensive journey through the world of RESTful APIs. As digital transformation continues to shape our world, the knowledge and skills shared in this blog post will empower you to contribute to this evolution.\n\nEmpower your API management with Moesif’s cutting-edge governance and monetization features. Govern user access and enforce quotas efficiently, while unlocking new revenue streams through flexible, usage-based billing models. Seamless integration ensures your API’s security and financial growth. Start revolutionizing your API strategy today by signing up for Moesif’s free trial, and take the first step towards optimized control and monetization of your digital services."
    },
    {
        "link": "https://stackoverflow.com/questions/12806386/is-there-any-standard-for-json-api-response-format",
        "document": "Do standards or best practices exist for structuring JSON responses from an API? Obviously, every application's data is different, so that much I'm not concerned with, but rather the \"response boilerplate\", if you will. An example of what I mean:\n\nAssuming you question is about REST webservices design and more precisely concerning success/error. I think there are 3 different types of design.\n• None Use only HTTP Status code to indicate if there was an error and try to limit yourself to the standard ones (usually it should suffice).\n• Pros: It is a standard independent of your api.\n• Cons: Less information on what really happened.\n• None Use HTTP Status + json body (even if it is an error). Define a uniform structure for errors (ex: code, message, reason, type, etc) and use it for errors, if it is a success then just return the expected json response.\n• Pros: Still standard as you use the existing HTTP status codes and you return a json describing the error (you provide more information on what happened).\n• Cons: The output json will vary depending if it is a error or success.\n• None Forget the http status (ex: always status 200), always use json and add at the root of the response a boolean responseValid and a error object (code,message,etc) that will be populated if it is an error otherwise the other fields (success) are populated.\n• None Pros: The client deals only with the body of the response that is a json string and ignores the status(?). It's up to you to choose :) Depending on the API I would choose 2 or 3 (I prefer 2 for json rest apis). Another thing I have experienced in designing REST Api is the importance of documentation for each resource (url): the parameters, the body, the response, the headers etc + examples. I would also recommend you to use jersey (jax-rs implementation) + genson (java/json databinding library). You only have to drop genson + jersey in your classpath and json is automatically supported.\n• None Solution 2 is the hardest to implement but the advantage is that you can nicely handle exceptions and not only business errors, initial effort is more important but you win on the long term.\n• None Solution 3 is the easy to implement on both, server side and client but it's not so nice as you will have to encapsulate the objects you want to return in a response object containing also the responseValid + error.\n\nI will not be as arrogant to claim that this is a standard so I will use the \"I prefer\" form. I prefer terse response (when requesting a list of /articles I want a JSON array of articles). In my designs I use HTTP for status report, a 200 returns just the payload. 400 returns a message of what was wrong with request: If there was error with processing on my side, I return 501 with a message: {\"message\" : \"Could not connect to data store.\"} From what I've seen quite a few REST-ish frameworks tend to be along these lines. JSON is supposed to be a payload format, it's not a session protocol. The whole idea of verbose session-ish payloads comes from the XML/SOAP world and various misguided choices that created those bloated designs. After we realized all of it was a massive headache, the whole point of REST/JSON was to KISS it, and adhere to HTTP. I don't think that there is anything remotely standard in either JSend and especially not with the more verbose among them. XHR will react to HTTP response, if you use jQuery for your AJAX (like most do) you can use / and / callbacks to capture errors. I can't see how encapsulating status reports in JSON is any more useful than that.\n\nFor what it's worth I do this differently. A successful call just has the JSON objects. I don't need a higher level JSON object that contains a success field indicating true and a payload field that has the JSON object. I just return the appropriate JSON object with a 200 or whatever is appropriate in the 200 range for the HTTP status in the header. However, if there is an error (something in the 400 family) I return a well-formed JSON error object. For example, if the client is POSTing a User with an email address and phone number and one of these is malformed (i.e. I cannot insert it into my underlying database) I will return something like this: Important bits here are that the \"field\" property must match the JSON field exactly that could not be validated. This allows clients to know exactly what went wrong with their request. Also, \"message\" is in the locale of the request. If both the \"emailAddress\" and \"phoneNumber\" were invalid then the \"errors\" array would contain entries for both. A 409 (Conflict) JSON response body might look like this: { \"description\" : \"Already Exists\" \"errors\" : [ { \"field\" : \"phoneNumber\", \"message\" : \"Phone number already exists for another user.\" } ], } With the HTTP status code and this JSON the client has all they need to respond to errors in a deterministic way and it does not create a new error standard that tries to complete replace HTTP status codes. Note, these only happen for the range of 400 errors. For anything in the 200 range I can just return whatever is appropriate. For me it is often a HAL-like JSON object but that doesn't really matter here. The one thing I thought about adding was a numeric error code either in the the \"errors\" array entries or the root of the JSON object itself. But so far we haven't needed it.\n\nThe point of JSON is that it is completely dynamic and flexible. Bend it to whatever whim you would like, because it's just a set of serialized JavaScript objects and arrays, rooted in a single node. What the type of the rootnode is is up to you, what it contains is up to you, whether you send metadata along with the response is up to you, whether you set the mime-type to or leave it as is up to you (as long as you know how to handle the edge cases). Build a lightweight schema that you like.\n\n Personally, I've found that analytics-tracking and mp3/ogg serving and image-gallery serving and text-messaging and network-packets for online gaming, and blog-posts and blog-comments all have very different requirements in terms of what is sent and what is received and how they should be consumed. So the last thing I'd want, when doing all of that, is to try to make each one conform to the same boilerplate standard, which is based on XML2.0 or somesuch. That said, there's a lot to be said for using schemas which make sense to you and are well thought out.\n\n Just read some API responses, note what you like, criticize what you don't, write those criticisms down and understand why they rub you the wrong way, and then think about how to apply what you learned to what you need.\n\nI used to follow this standard, was pretty good, easy, and clean on the client layer. Normally, the HTTP status 200, so that's a standard check which I use at the top. and I normally use the following JSON I also use a template for the API's dynamic response; try { // query and what not. response.payload = new { data = new { pagination = new Pagination(), customer = new Customer(), notifications = 5 } } // again something here if we get here success has to be true // I follow an exit first strategy, instead of building a pyramid // of doom. response.success = true; } catch(Exception exception){ response.success = false; response.message = exception.GetStackTrace(); _logger.Fatal(exception, this.GetFacadeName()) } return response; { \"success\": boolean, \"message\": \"some message\", \"payload\": { \"data\" : [] \"message\": \"\" ... // put whatever you want to here. } } on the client layer I would use the following: if(response.code != 200) { // woops something went wrong. return; } if(!response.success){ console.debug ( response.message ); return; } // if we are here then success has to be true. if(response.payload) { .... } notice how I break early avoiding the pyramid of doom.\n\nThere is no lawbreaking or outlaw standard other than common sense. If we abstract this like two people talking, the standard is the best way they can accurately understand each other in minimum words in minimum time. In our case, 'minimum words' is optimizing bandwidth for transport efficiency and 'accurately understand' is the structure for parser efficiency; which ultimately ends up with the less the data, and the common the structure; so that it can go through a pin hole and can be parsed through a common scope (at least initially). Almost in every cases suggested, I see separate responses for 'Success' and 'Error' scenario, which is kind of ambiguity to me. If responses are different in these two cases, then why do we really need to put a 'Success' flag there? Is it not obvious that the absence of 'Error' is a 'Success'? Is it possible to have a response where 'Success' is TRUE with an 'Error' set? Or the way, 'Success' is FALSE with no 'Error' set? Just one flag is not enough? I would prefer to have the 'Error' flag only, because I believe there will be less 'Error' than 'Success'. Also, should we really make the 'Error' a flag? What about if I want to respond with multiple validation errors? So, I find it more efficient to have an 'Error' node with each error as child to that node; where an empty (counts to zero) 'Error' node would denote a 'Success'."
    },
    {
        "link": "https://geeksforgeeks.org/rest-api-introduction",
        "document": "REST API stands for REpresentational State Transfer API. It is a type of API (Application Programming Interface) that allows communication between different systems over the internet. REST APIs work by sending requests and receiving responses, typically in JSON format, between the client and server.\n\nREST APIs use HTTP methods (such as GET, POST, PUT, DELETE) to define actions that can be performed on resources. These methods align with CRUD (Create, Read, Update, Delete) operations, which are used to manipulate resources over the web.\n\nA request is sent from the client to the server via a web URL, using one of the HTTP methods. The server then responds with the requested resource, which could be HTML, XML, Image, or JSON, with JSON being the most commonly used format for modern web services.\n• Stateless : Each request from a client to a server must contain all the information the server needs to fulfill the request. No session state is stored on the server.\n• Client-Server Architecture : RESTful APIs are based on a client-server model, where the client and server operate independently, allowing scalability.\n• Cacheable : Responses from the server can be explicitly marked as cacheable or non-cacheable to improve performance.\n• Uniform Interface : REST APIs follow a set of conventions and constraints, such as consistent URL paths, standardized HTTP methods, and status codes, to ensure smooth communication.\n• Layered System : REST APIs can be deployed on multiple layers, which helps with scalability and security.\n\nVarious HTTP Methods Used in REST API\n\nIn HTTP, there are five methods that are commonly used in a REST-based Architecture, i.e., POST, GET, PUT, PATCH, and DELETE. These correspond to create, read, update, and delete (or CRUD) operations, respectively. There are other methods that are less frequently used, like OPTIONS and HEAD.\n\nThe HTTP GET method is used to read (or retrieve) a representation of a resource. In the safe path, GET returns a representation in XML or JSON and an HTTP response code of 200 (OK). In an error case, it most often returns a 404 (NOT FOUND) or 400 (BAD REQUEST).\n\nThe POST verb is most often utilized to create new resources. In particular, it’s used to create subordinate resources. That is, subordinate to some other (e.g. parent) resource. On successful creation, return HTTP status 201, returning a Location header with a link to the newly-created resource with the 201 HTTP status.\n\nPUT is an HTTP method used to update or create a resource on the server. When using PUT, the entire resource is sent in the request body, and it replaces the current resource at the specified URL. If the resource doesn’t exist, it can create a new one.\n\nPATCH is an HTTP method used to partially update a resource on the server. Unlike PUT, PATCH only requires the fields that need to be updated to be sent in the request body. It modifies specific parts of the resource rather than replacing the entire resource.\n\nIt is used to delete a resource identified by a URI. On successful deletion, return HTTP status 200 (OK) along with a response body.\n\nNow let’s create a REST AP and perform the various HTTP operations.\n\nCreate the NodeJs project by using the following command:\n\nTo begin building a REST API in Node.js, you need to install Express. Run the following command in your terminal:\n\nHere’s a basic example of creating a REST API in Node.js using Express\n\nOutput: Open the http://localhost:3000 on the postman to check the API is working properly or not.\n\nIn this example\n• GET /users: This route fetches the list of users (or mock data in this case).\n• POST /users: This route accepts JSON data from the client to create a new user.\n• PUT /users/:id: This route updates the information of a user based on the user ID provided in the URL.\n• DELETE /users/:id: This route deletes a user with the specified ID.\n\nGraphQL is another popular approach for building APIs. Here’s how it compares to REST API:\n\nWhat are the HTTP methods used in REST APIs?\n\nWhat is the advantage of using REST APIs?\n\nWhat is the difference between REST and SOAP APIs?"
    }
]