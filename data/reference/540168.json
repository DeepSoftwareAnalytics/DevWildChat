[
    {
        "link": "https://wg5-fortran.org/N2201-N2250/N2212.pdf",
        "document": ""
    },
    {
        "link": "https://j3-fortran.org/doc/year/24/24-007.pdf",
        "document": ""
    },
    {
        "link": "https://docs.oracle.com/cd/E19957-01/805-4939/6j4m0vnap/index.html",
        "document": "The statement writes from a list to .\n\nThe statement accepts the following arguments.\n\nis a format identifier and can be:\n• An asterisk ( ), which indicates list-directed I/O. See \"List-Directed I/O \" on for more information.\n• The label of a statement that appears in the same program unit.\n• An integer variable name that has been assigned the label of a statement that appears in the same program unit.\n• A character expression or integer array that specifies the format string. The integer array is nonstandard.\n\niolist can be empty or can contain output items or implied lists. The output items must be one of the following:\n\nA simple unsubscripted array name specifies all of the elements of the array in memory storage order, with the leftmost subscript increasing more rapidly.\n\nImplied DO lists are described on \"Implied Lists\".\n\nThe second form of the statement is used to print the items of the specified namelist group. Here, grname is the name of a group previously defined by a statement.\n• The format, if specified, is established.\n• If the output list is not empty, data is transferred from the list to standard output. If a format is specified, data is edited accordingly.\n• In the second form of the statement, data is transferred from the items of the specified namelist group to standard output.\n\nOutput from an exception handler is unpredictable. If you make your own exception handler, do not do any FORTRAN output from it. If you must do some, then call abort right after the output. Doing so reduces the relative risk of a program freeze. FORTRAN I/O from an exception handler amounts to recursive I/O. See the next point.\n\nRecursive I/O does not work reliably. If you list a function in an I/O list, and if that function does I/O, then during runtime, the execution may freeze, or some other unpredictable problem may occur. This risk exists independent of parallelization."
    },
    {
        "link": "https://community.intel.com/t5/Intel-Fortran-Compiler/Debugging-with-print-statements-changes-results/td-p/1450036",
        "document": "My results change when I use print statements to debug the code. Is this problem related specifically to the variable I m printing or it can be any other variable that was not initialized. All variables appear to be initialized.\n\nI have consulted a similar question on this forum: Adding debugging 'print' statements changes variable values - Intel Communities and I could not post in the same thread.\n\nI m using intel fortran with visual studio. Is there any option that I can change on the project options that can help me resolve the problem and identify the problem.\n\nThank you for your help."
    },
    {
        "link": "https://fortran-lang.discourse.group/t/print-and-write-in-same-line/6416",
        "document": "Hey everyone I had a doubt that whether we can able to print the line and take the user input in the same line in the fortran programming is it possible if yes can anyone please help me out in this and give a sample example of it Your help is much appreciated …\n\nthank you so much this is my initial phase of learning the fortran and this help from you really helped me a lot by the way can you please explain this this in simple words write (*, ‘(a)’, advance=‘no’)\n\nSorry, I don’t understand “restricted to only bits rights”. There is really no difference between: They both write to “standard output” and are often considered the same unit number. is an artifact of the past when there was also a statement. It’s just a few characters fewer to write, but omits the I/O control list that lets you do things such as .\n\nlet me say you in a code manner write (*, ‘(i2, i1)’ ,advance=“no”) n1, n3\n\n consider the above line if the n1 value is 2 digits, n3 value is 1 digit its geting displayed\n\n but where as n1 value if it exceeds the 2 digits like 3 digits its displaying as *** like how can i achieve it properly"
    },
    {
        "link": "https://fortran-lang.org/learn/quickstart/variables",
        "document": "Fortran is a statically typed language, which means the type of each variable is fixed when the program is compiled—variable types cannot change while the program is running.\n\nBefore we can use a variable, we must declare it; this tells the compiler the variable type and any other variable attributes.\n\nlogical – for data that represent boolean (true or false) values\n\ncomplex – pair consisting of a real part and an imaginary part\n\nreal – for floating-point data (not a whole number)\n\ninteger – for data that represent whole numbers, positive or negative\n\nThere are 5 built-in data types in Fortran:\n\nVariables store information that can be manipulated by the program. Fortran is a strongly typed language, which means that each variable must have a type.\n\nThe syntax for declaring variables is:\n\nwhere is one of the built-in variable types listed above and is the name that you would like to call your variable.\n\nVariable names must start with a letter and can consist of letters, numbers and underscores. In the following example we declare a variable for each of the built-in types.\n\nNote the additional statement at the beginning of the program: . This statement tells the compiler that all variables will be explicitly declared; without this statement variables will be implicitly typed according to the letter they begin with.\n\nOnce we have declared a variable, we can assign and reassign values to it using the assignment operator .\n\nCharacters are surrounded by either single ( ) or double quotes ( ).\n\nLogical or boolean values can be either or .\n\nWatch out for assignment at declaration: This is NOT a normal initialisation; it implies the attribute, which means that the variable retains its value between procedure calls. Good practice is to initialise your variables separately to their declaration.\n\nIn our Hello World example, we printed text to the command window. This is commonly referred to as writing to or . We can use the statement introduced earlier to print variable values to : 'The value of amount (integer) is: ' 'The value of pi (real) is: ' 'The value of frequency (complex) is: ' 'The value of initial (character) is: ' 'The value of isOkay (logical) is: ' In a similar way, we can read values from the command window using the statement: 'The sum and product of the numbers are ' This input source is commonly referred to as or .\n\nThe desired floating-point precision can be explicitly declared using a parameter. The intrinsic module provides parameters for the common 32-bit and 64-bit floating-point types. Always use a suffix for floating-point literal constants. In the next part we will learn how to use arrays for storing more than one value in a variable."
    },
    {
        "link": "https://stackoverflow.com/questions/22331165/what-is-good-style-for-variable-declaration-in-fortran",
        "document": "So I have a whole lot of variables I need to declare, and the original code looked like this:\n\nAnd I rewrote it as this:\n\nIs this considered good style, or are there better ways? Note that the second way allows for comments with each variable, and I don't have to use line continuations if I might add another variable.\n\nP.S.: is there a consensus/style bible/widely regarded source on Fortran programming style & good practices?"
    },
    {
        "link": "https://wvuhpc.github.io/Modern-Fortran/11-Best-Practices/index.html",
        "document": "Fortran is a language with a long history. Fortran is one of the oldest Programming Languages still in active use. That old history means that the language has evolved in expression and scope over more than 60 years.\n\nThe way you programmed Fortran back in the 60s, 70s, and 80s is completely inadequate for modern computers. Consider for example the length of the lines. Back in the 70s and 80s, people programmed computers using punched cards and later dumb terminals connected to mainframes. Those terminals have a limited number of characters in one line. It is from that time that a limit of 72 characters on one line and characters beyond column 72 were ignored. The first five columns must be blank or contain a numeric label. Continuation lines were identified by a nonblank, nonzero in column 6. All these limitations were present in what is called the Standard Fixed Format of Fortran 77.\n\nOver time, these limitations and many others in the language became obsolete but were still in use for decades even after Fortran 90 was the new Standard. Back in the 90s, there were no free Fortran 90 compilers, people continue to use Fortran 77 with restrictions relaxed and some characteristics of Fortran 90 were integrated little by little into the compilers.\n\nThe fact is that there are many codes written in Fortran 77. If you search for Fortran tutorials and documentation, there are many pages in academics that still teach Fortran 77. Fortran 90 was gaining space and later Fortran 95. Today almost main Fortran compilers support Fortran 2003 entirely and Fortran 2008 to a fairly complete degree. New features in Fortran 2018 are still not implemented in the latest version of major compilers.\n\nIn previous sections, we have discussed the basic elements so you can read and write code in Fortran. We learn about variables assignments subroutines and modules and we explored those elements using the modern ways of writing code in Fortran. In this section we will have to learn a bit about the “old ways” in such a way that when you encounter those pieces of code, you can recognize them knowing which are the alternatives and best practices used today. This is in this way an intermediate class in Modern Fortran. I assume you know the basics and are able to write useful code in Fortran. The idea is to recognize old Fortran 77 and Fortran 90 styles and be able to translate those into modern Fortran 2003 and 2008 Standards. By doing that you are moving the code into more flexible, readable, extensible, and potentially with more performance.\n\nFortran 77 was a powerful language back in its time. It was so powerful that stay as the standard de facto well in the 90s. Many elements of the language still in use today were added to Fortran 77 to address the limitations of FORTRAN 66. For example the and statements including and were the first steps into structured programming. These statements were an important move to move into oblivion. was one of the reasons why codes were so difficult to follow and almost unpredictable when were the source of a bug. Another powerful element of the language were intrinsic functions such as that accept complex or double precision numbers as arguments.\n\n All these niceties today are taken for granted but back then were big improvements to the language. However, the language has important flaws. One important is the lack of dynamic memory allocation. The code still promotes a code that is cluttered, with missing blanks, and in general hard to read.\n\nNow the question is if a code works in Fortran 77 why change it? Investing some time now in rewriting a code in a new language could return in big gains later on. A new structure could emerge that uses better memory (with dynamic allocation) to structure the code in ways that make it easier to read and extend. There are good reasons and rewards for better and cleaner code.\n\nBack to the first versions of Fortran, the first 5 columns of characters were dedicated as label fields. A C in column 1 means that the line was treated as a comment and any character in column 6 means that the line was a continuation of the previous statement.\n\nToday those restrictions are no longer needed. Statements can start in the first column. An exclamation mark starts a comment and comments could be inserted any place in the line, except literal strings. Blanks help the readability of the code. Variables cannot have spaces, it is a better practice to use underscore for multi-word variables. Use as the last character for continuing on the next line. Declaring multiple statements on the same line is possible with a semicolon ( ) but use it only for very short statements.\n\nUse blank characters, blank lines and comments to improve the readability of your code. A cluttered code is hard to read and you are not doing any good trying to fit most of your code in one screen page.\n\nInstead of this ( ):\n\nThis code is too compact, it is not hard to read because is too small, but for bigger codes became really hard to follow.\n\nAn alternative is like this ( ):\n\nWe include spaces to clarify variable assignments from the conditional. Indentations inside the and also help to visualize the scope of blocks.\n\nIn old FORTRAN 77, do loops have a numerical identifier to jump to a statement to cycle the loop, that is completely obsolete and must be avoided in modern coding ( ):\n\nThis old style of coding wastes 6 columns of space, uses a labeled statement for cycling and is written with full capitalization.\n\nAn alternative is something like this ( ):\n\nThis code uses indentations and has an that is clearer for the user when the loops grow or became nested. We will discuss the down below\n\nFortran 95 introduce variable attributes and they were extended in Fortran 2003 and 2008. The most common attributes are , , , , , , , , , and\n\nFrom those, we will demonstrate the first 3. is important for declaring constants that otherwise will require going beyond the language and using the preprocessor. is used to define the length of arrays or the dimension using colons and commas to declare it. is used for the dynamic allocation of arrays an important feature introduced in Fortran 90 and expanded in Fortran 95 and beyond. This is an example using these 3 attributes that should be frequently used ( ).\n\nBy default all variables starting with , , , , and are integers. All others are real.\n\nDespite of this being usually true for small codes, it is better to turn those defaults off with Variables in large codes will have names with scientific meaning and the defaults can bring bugs that are hard to catch.\n\nUse to abandon a loop and to jump to the next iteration. These are better replacements to complicated statements from old FORTRAN. You can use and in bounded and unbounded loops.\n\nThe file and show the effect of and respectively.\n\nIn the case of nested loops, the solution is to name the loop. Constructs such as , and as can be named and you can use the name to leave outer loops from inside an inner loop.\n\nThe construct in Fortran works different from its homologous in C language. In C you need to use a break, otherwise the code will test every single case. In Fortran once one case passes the condition, the others will be skipped. In Fortran case take ranges apart from a single element as other languages. Example:\n\nThere are at least 2 kinds of reals: 4-byte, 8-byte. Some compilers offer the third kind with 16-byte reals. The kind numbers are usually 4, 8, and 16, but this is just a tradition of several languages and not mandatory by the language. The kind values could be 1, 2 and 4.\n\nThere is an intrinsic module called that provides the kind values for logical, character, integer, and real data types.\n\nConsider this example to get the values used ( )\n\nDifferent compilers will respond with different kinds values. For example, will return this:\n\nAs Fortran have evolve over the years, several ways were created to declare the storage size of different kinds and consequently the precision of them. This example explores some of those old ways that you can still encounter in codes.\n\nConsider this example illustrative of the multiple ways of declaring REAL variables ( ):\n\nThe original REAL data type have received multiple variations for declaring floating point numbers based on rather ambiguous terms such as which actually does not mean what literally says. Other variations use the kind assuming that the numbers 4, 8, and 16 represent the number of bytes used by each data type, this is not standard and Salford f95 compiler used kinds 1,2, and 3 to stand for 2- 4- and 8-byte.\n\nNotice that storage size is not the same as precision. Those terms are related and you expect that more bytes will end up giving more precision, but REALS have several internal components such as the size of mantissa and exponent. The 24 bits (including the hidden bit) of mantissa in a 32-bit floating-point number represent about 7 significant decimal digits.\n\nEven though, this is not the same across all the real space. We are using the same number of bits to represent all normalized numbers, the smaller the exponent, the greater the density of truncated numbers. For example, there are approximately 8 million single-precision numbers between 1.0 and 2.0, while there are only about 8 thousand numbers between 1023.0 and 1024.0.\n\nBeyond the standard representation, you can also change the storage size during compilation. Below, the same code was compiled using arguments that change the storage size of different variables.\n\nFortran 2008 includes standard kinds , , to specify a REAL type with a storage size of 32, 64, and 128 bits. In cases where target platform does not support the particular kind a negative value is returned.\n\nThis example shows the new kind parameters ( ).\n\nThe storage size of these variables is no longer affected by the compiler arguments used above.\n\nYou can still change those kinds during compile time using command line arguments , and similar ones.\n\nChanging kinds during compile time could have unintended consequences, for example using external libraries as could be the case with MPI.\n\nThere are two types of memory for a program: The stack and the heap. Scalars and static arrays live in the stack but the size of that space is very limited and some sysadmins and queue systems limit its value even more. Most other variables including allocatable arrays live on the heap.\n\nBefore allocatable arrays were part of Fortran 90, Arrays were created with a fixed size. Programs used arrays with sizes that overestimated the actual needs for storage or require being recompiled every time the size of those arrays changed. Still, some scientific codes work with fixed arrays and need recompilation before any simulation. Modern written codes (Since Fortran 90) used allocatable arrays. Declarations and allocation happen in two steps instead of a single step with fixed arrays. As allocation takes time, it is not a good idea to allocate and deallocate very often. Allocate once and use the space as much as possible. Fortran 90 introduces attributes and and functions. Fortran 95 added attribute as an alternative to specifying the dimension of arrays. Otherwise, the array shape must be specified after the array-variable name. For example ( ):\n\nStatic arrays could be allocated on the stack instead of using the heap. The stack has a limited size and under some circumstances, static arrays could exhaust the stack space allowed for a process. Consider this example ( ):\n\nYou can check the limit for stack memory on the machine:\n\nWe have a soft limit of 8MB for stack and the user can raise its value to an unlimited value.\n\nAs the limit is 8MB we will create an integer array that takes a bit under 8MB. The array will be of integers and each integer takes by default 4 Bytes. This is not a safe value but will work for the purpose of demonstrating the effect:\n\nNow we will compile the code above with , forcing the static arrays to be on stack. Some compilers move large arrays to heap automatically so we are bypassing this protection.\n\nSometimes you will get an output like this:\n\nWe are so close to filling the stack that small variations in loading libraries could cross the limit. Try a few times until the code stops when asking for input from the keyboard.\n\nOnce the code is waiting for any input, execute this command on a separate terminal:\n\nThe command will print a map of the memory and the stack is marked there.\n\nNotice that in this case, we have fully consumed the stack. Compilers could take decisions of moving static arrays to the heap, but even with these provisions, is very easy that multiple arrays combined could cross the limit.\n\nConsider arrays to be always , so they are allocated on the heap always.\n\nBeyond the variables of a simple type (real, integer, character, logical, complex) new data types can be created by grouping them into a derived type. Derived types can also include other derived types Arrays can also be included in both static and allocatable. Structures can be made allocatable.\n\nConsider this example that shows the use of derived types and its instances called structures ( ).\n\nA simple program will have only variable declarations and statements. The next level of organization is to encapsulate variable declarations and statements as an entity (function or subroutine) that can be reused inside the main program, other programs or other function or subroutine.\n\nAnother advantage of moving code inside functions or subroutines is that you hide variables inside the scope of the function, allowing the reuse of the names in other routines without collisions.\n\nFortran makes the distinction between and . This is different from other programming languages such as C/C++, Python, Java. In purely functional programming languages (e.g. Haskell) only functions are allowed. Subroutines have arguments that make no distinction between input and output and input variables can be modified as side-effects.\n\nFortran Functions are simpler compared to subroutines. A function return a single value that is predefined. Functions can be invoked from within expressions, like a write statement, inside an if declaration and other statements.\n\nA subroutine does not return a value, but can return many values via its changing one or more arguments. Subroutines can only be used using the keyword .\n\nThis is one example of a code with one function and one subroutine. ( )\n\nIt is a good practice to declare the intent of variable with , or . Using them could help during debugging in case variables became modified unintentionally.\n\nModules is the next natural level of abstraction. Modules can contain various kinds of things like\n\nThis small example uses a module to contain constants. ( )\n\nThe content of a module is accessible after the statement By default all variables, subroutines and functions inside a module are visible, but restrictions can be made using the statement before the routine and it can only be used by other subroutines on the same module but not by routines that the module. The variable attribute public can also be used to make exceptions after the private statement\n\nExample of and variables and functions. It will be very similar for subroutines and data types. ( ):\n\nA public variable is visible by routines that use the module. Private variables will not. There are cases were the value needs to be visible but not changed outside. That is the purpose of attribute.\n\nAnother option is for variables be renamed when the module is loaded allowing codes outside to use the name of the variable for other purposes.\n\nThis example combine both features ( ):\n\nIn Modern Fortran (since Fortran 90), optional arguments can be part of a subroutine. They must be declared as optional in the calling function (either through a module or an explicit interface). In several implementations of old Fortran 77 it was possible to simply leave out the last argument, if it was a scalar number This behavior, was not part of the Fortran standard but used by some programmers. Now the attribute must be declared explicitly.\n\nThis example explores several options for optional variables. ( ):\n\nOne of the strengths of Fortran is scientific computing and High-Performance Computing. Central to HPC programming are arrays and Fortran is particularly good in expressing operations with arrays.\n\nMany operations that require loops in C are done in one operation in Fortran, those are implicit loops hidden in the language expression.\n\nConditions for operations with arrays are:\n• The left and right sides of an assignment must be conformable. That means that the same number of elements are involved and they match in dimension\n• Operations with strides are valid if they are also conformable."
    },
    {
        "link": "https://fortran90.org/src/best-practices.html",
        "document": ""
    },
    {
        "link": "https://fortran-lang.org/learn/intrinsics/type",
        "document": "These intrinsics allow for explicitly casting one type of variable to another or can be used to conditionally execute code blocks based on variable types when working with polymorphic variables.\n• None The integer types can hold only whole number values.\n• None Stores floating point numbers, such as 2.0, 3.1415, -100.876, etc.\n• None A complex number has two parts, the real part and the imaginary part. Two consecutive floating point storage units store the two parts.\n• None There are only two logical values: .true. and .false.\n• None The character type stores strings. The length of the string can be specified by the len specifier. If no length is specified, it is 1. These “types” can be of many “kinds”. Often different numeric kinds take up different storage sizes and therefore can represent different ranges; but a different kind can have other meanings. A character variable might represent ASCII characters or UTF-8 or Unicode characters, for example. You can derive your own data types from these fundamental types as well.\n\nFortran allows a feature called implicit typing, i.e., you do not have to declare some variables before use. By default if a variable is not declared, then the first letter of its name will determine its type:\n• None Variable names starting with i-n (the first two letters of “integer”) specify integer variables.\n• None All other variable names default to real. However, in most circles it is considered good programming practice to declare all the variables. For that to be enforced, you start your variable declaration section with a statement that turns off implicit typing: the statement For more information refer to the implicit statement.\n• None x may be integer, real, or complex.\n• None y may be integer or real. y is allowed only if x is not complex.\n• None KIND is a constant integer initialization expression indicating the kind parameter of the result. The type of the arguments does not affect the kind of the result except for a complex x value.\n• None if kind is not present and x is complex the result is of the kind of x.\n• None if kind is not present and x is not complex the result if of default complex kind. NOTE: a kind designated as ** may be any supported kind for the type The cmplx(3) function converts numeric values to a complex value. Even though constants can be used to define a complex variable using syntax like this will not work for variables. So you cannot enter ! NO ! (unless a and b are constants, not variables) so to construct a complex value using non-complex values you must use the cmplx(3) function: or assign values separately to the imaginary and real components using the %IM and %RE designators: If x is complex y is not allowed and cmplx essentially returns the input value except for an optional change of kind, which can be useful when passing a value to a procedure that requires the arguments to have a different kind (and does not return an altered value): would pass a copy of a value with kind=real64 even if z had a different kind but otherwise is equivalent to a simple assign. So if z1 and z2 were complex: If x is not complex x is only used to define the real component of the result but y is still optional – the imaginary part of the result will just be assigned a value of zero. If y is present it is converted to the imaginary component. Primarily in order to maintain upward compatibility you need to be careful when working with complex values of higher precision that the default. It was necessary for Fortran to continue to specify that cmplx(3) always return a result of the default kind if the kind option is absent, since that is the behavior mandated by FORTRAN 77. It might have been preferable to use the highest precision of the arguments for determining the return kind, but that is not the case. So with arguments with greater precision than default values you are required to use the kind argument or the greater precision values will be reduced to default precision. This means cmplx(d1,d2), where d1 and d2 are doubleprecision, is treated as: So Fortran 90 extends the cmplx(3) intrinsic by adding an extra argument used to specify the desired kind of the complex result. ! note this was stored with default real precision ! ! again, note output components are just real A more recent alternative to using cmplx(3) is “F2018 component syntax” where real and imaginary parts of a complex entity can be accessed independently: Where the designator value is of course of complex type. The type of a complex-part-designator is real, and its kind and shape are those of the designator. That is, you retain the precision of the complex value by default, unlike with cmplx. The following are examples of complex part designators: !-- Same value as real(impedance) !-- Same value as AIMAG(fft) !-- Sets the imaginary part of x to zero !-- even if x is an array Note that if format statements are specified a complex value is treated as two real values. For list-directed I/O (ie. using an asterisk for a format) and NAMELIST output the values are expected to be delimited by “(” and “)” and of the form “(realpart,imaginary_part)”. For NAMELIST input parenthesized values or lists of multiple _real values are acceptable.\n• None The value assigned to the real component of the result when x is not complex. If x is complex, the result is the same as if the real part of the input was passed as x and the imaginary part as y. That is, a complex x value is copied to the result value with a possible change of kind.\n• None y is only allowed if x is not complex. Its value is assigned to the imaginary component of the result and defaults to a value of zero if absent.\n• None An integer initialization expression indicating the kind parameter of the result. The return value is of complex type, with magnitudes determined by the values x and y. The common case when x is not complex is that the real component of the result is assigned the value of x and the imaginary part is zero or the value of y if y is present. When x is complex y is not allowed and the result is the same value as x with a possible change of kind. That is, the real part is real(x, kind) and the imaginary part is real(y, kind). ! with a format treat a complex as two real values ! using kind=dp makes it keep DOUBLEPRECISION precision ! otherwise the result would be of default kind ! assignment of constant values does not require cmplx(3)00 ! The following is intuitive and works without calling cmplx(3) ! but does not work for variables just constants ! what happens when you assign a complex to a real? Fortran has strong support for complex values, including many intrinsics that take or produce complex values in addition to algebraic and logical expressions:\n• None a kind designated as ** may be any supported kind for the type\n• None a is type real of any kind\n• None The result is default integer kind or the value of kind if kind is present. nint(3) rounds its argument to the nearest whole number with its sign preserved. The user must ensure the value is a valid value for the range of the kind returned. If the processor cannot represent the result in the kind specified, the result is undefined. If a is greater than zero, nint(a) has the value int(a+0.5). If a is less than or equal to zero, nint(a) has the value int(a-0.5).\n• None The value to round to the nearest whole number\n• None can specify the kind of the output value. If not present, the output is the default type of integer. The result is the integer nearest a, or if there are two integers equally near a, the result is whichever such integer has the greater magnitude. The result is undefined if it cannot be represented in the specified integer type. ! make sure input is in range for the type returned ! the standard does not require this to be an error ... 'These are all wrong answers for ' > 1 -1 > 5 -5 > -2.700000 -3 > -2.500000 -3 > -2.200000 -2 > -2.000000 -2 > -1.500000 -2 > -1.000000 -1 > -0.5000000 -1 > -0.4000000 0 > 0.0000000E+00 0 > 3.9999999E-02 0 > 0.5000000 1 > 1.000000 1 > 1.500000 2 > 2.000000 2 > 2.200000 2 > 2.500000 3 > 2.700000 3 > Range limits for typical KINDS: > 1 127 > 2 32767 > 4 2147483647 > 8 9223372036854775807 > Any KIND big enough? ICHECK= -1 > These are all wrong answers for 1.234566949990144E+019 > 0 > 0 > -2147483648 > -9223372036854775808\n• None source shall be a scalar or an array of any type.\n• None mold shall be a scalar or an array of any type.\n• None size shall be a scalar of type integer.\n• None result has the same type as mold transfer(3) copies the bitwise representation of source in memory into a variable or array of the same type and type parameters as mold. This is approximately equivalent to the C concept of “casting” one type to another.\n• None Holds the bit pattern to be copied\n• None the type of mold is used to define the type of the returned value. In addition, if it is an array the returned value is a one-dimensional array. If it is a scalar the returned value is a scalar.\n• None If size is present, the result is a one-dimensional array of length size. If size is absent but mold is an array (of any size or shape), the result is a one-dimensional array of the minimum length needed to contain the entirety of the bitwise representation of source. If size is absent and mold is a scalar, the result is a scalar. The result has the bit level representation of source. If the bitwise representation of the result is longer than that of source, then the leading bits of the result correspond to those of source but any trailing bits are filled arbitrarily. When the resulting bit representation does not correspond to a valid representation of a variable of the same type as mold, the results are undefined, and subsequent operations on the result cannot be guaranteed to produce sensible behavior. For example, it is possible to create logical variables for which var and .not. var both appear to be true. ! the bit patterns are the same ! a string to an array of characters\n\nout_of_range(3) - [TYPE:NUMERIC] Whether a value cannot be converted safely.\n• None x is of type integer or real.\n• None mold is an integer or real scalar. out_of_range(3) determines whether a value x can be converted safely to a real or integer variable the same type and kind as mold. For example, if int8 is the kind value for an 8-bit binary integer type, out_of_range(-128.5, 0_int8) will have the value false and out_of_range(-128.5, 0_int8, .true.) will have the value .true. because the value will be truncated when converted to an integer and -128 is a representable value on a two’s complement machine in eight bits even though +128 is not.\n• None a scalar to be tested for whether it can be stored in a variable of the type and kind of mold\n• None mold and kind are queried to determine the characteristics of what needs to be fit into.\n• None flag whether to round the value of xx before validating it as an integer value like mold. round can only be present if x is of type real and mold is of type integer. Case (i): If mold is of type integer, and round is absent or present with the value false, the result is true if and only if the value of X is an IEEE infinity or NaN, or if the integer with largest magnitude that lies between zero and X inclusive is not representable by objects with the type and kind of mold. Case (ii): If mold is of type integer, and round is present with the value true, the result is true if and only if the value of X is an IEEE infinity or NaN, or if the integer nearest X, or the integer of greater magnitude if two integers are equally near to X, is not representable by objects with the type and kind of mold. Case (iii): Otherwise, the result is true if and only if the value of X is an IEEE infinity or NaN that is not supported by objects of the type and kind of mold, or if X is a finite number and the result of rounding the value of X (according to the IEEE rounding mode if appropriate) to the extended model for the kind of mold has magnitude larger than that of the largest finite number with the same sign as X that is representable by objects with the type and kind of mold. mold is required to be a scalar because the only information taken from it is its type and kind. Allowing an array mold would require that it be conformable with x. round is scalar because allowing an array rounding mode would have severe performance difficulties on many processors. ! compilers are not required to produce an error on out of range. ! here storing the default integers into 1-byte integers ! OUT_OF_RANGE(3f) can let you check if the value will fit ! the real -128.5 is truncated to -128 and is in range ! the real -128.5 is rounded to -129 and is not in range > 127 -127 might have expected 127 -127 F F > -128 -128 might have expected 128 -128 T F > -127 127 might have expected 129 -129 T T > -126 126 might have expected 130 -130 T T > RANGE IS -128 TO 127 > F > T\n• None int(3) - Truncate towards zero and convert to integer\n• None the result is an default integer scalar selected_real_kind(3) return the kind value of a real data type with decimal precision of at least p digits, exponent range of at least r, and with a radix of radix. That is, if such a kind exists + it has the decimal precision as returned by **precision**(3) of at least **p** digits. + a decimal exponent range, as returned by the function **range**(3) of at least **r** + a radix, as returned by the function **radix**(3) , of **radix**, If the requested kind does not exist, -1 is returned. At least one argument shall be present.\n• Before Fortran 2008, at least one of the arguments r or p shall be present; since Fortran 2008, they are assumed to be zero if absent. selected_real_kind returns the value of the kind type parameter of a real data type with decimal precision of at least p digits, a decimal exponent range of at least R, and with the requested radix. If p or r is absent, the result value is the same as if it were present with the value zero. If the radix parameter is absent, there is no requirement on the radix of the selected kind and real kinds with any radix can be returned. If more than one real data type meet the criteria, the kind of the data type with the smallest decimal precision is returned. If no real data type matches the criteria, the result is\n• None if the processor does not support a real data type with a precision greater than or equal to p, but the r and radix requirements can be fulfilled\n• None if the processor does not support a real type with an exponent range greater than or equal to r, but p and radix are fulfillable\n• None if radix but not p and r requirements are fulfillable\n• None if radix and either p or r requirements are fulfillable\n• None if there is no real type with the given radix"
    }
]