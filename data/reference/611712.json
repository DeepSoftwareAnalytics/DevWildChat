[
    {
        "link": "https://en.cppreference.com/w/cpp/header/iostream",
        "document": "This header is part of the Input/output library.\n\nIncluding behaves as if it defines a static storage duration object of type std::ios_base::Init, whose constructor initializes the standard stream objects if it is the first object to be constructed, and whose destructor flushes those objects (except for and ) if it is the last object to be destroyed.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://geeksforgeeks.org/iomanip-in-cpp",
        "document": "In C++, the <iomanip> header file defines the manipulator functions that are used to manipulate the format of the input and output of our program. It is a part of the input/output library in C++. In this article, we will discuss the functions and facilities provided in the <iomanip> header file in C++ with examples.\n\nThe following table lists the commonly used <iomain> functions:\n\nThis function is used to reset or clear ios_base flags specified by the parameter mask. This function is used to set the ios_base flags specified by the parameter mask. This function is used to set the base according to the argument specified as a parameter to the function. This function is used to change the fill character. It is used to set the fill according to the character specified as a parameter to the function. This function is used to change the floating-point precision based on the precision specified as a parameter to the function. This function is used to change the width of the next input/output field based on the width specified as a parameter to the function. This function is used to parse a monetary value. This function is used to format and output a monetary value. This function is used to parse a date/time value according to the specified format. This function is used to format and output a date/time value according to the format specified. This function is used to insert and extract quoted strings with embedded space.\n\nLets discuss each of these functions one by one.\n\nThe setiosflag function is used to set the ios_base flags that are specified by its parameter for the stream it is used on.\n• mask: It is actually the flag which we have to set.\n\nThe resetiosflags function in C++ is used to reset or clear ios_base flags specified by parameter mask for the stream it is used on.\n• mask: It is the actual flag to be reset.\n\nThe setbase function is used to set the base according to the argument specified as a parameter to the function.\n• base: It is the base of the numerical values.\n\nThe setw function is used to change the width of the next input/output field based on the width specified as a parameter to the function.\n• n : It is an integer argument specifying the number of characters to be used as width.\n\nThe setfill function is used to change the fill character that is used when the span of the printed data is less than the span specified using setw. It is used to set the fill according to the character specified as a parameter to the function.\n• c: It is a variable of character type corresponding to which the fill is set.\n\nThe setprecision function is used to change the floating-point precision of the float and double data type based on the precision specified as a parameter to the function.\n• n : It is an integer argument specifying the new precision.\n\nThe get_money function in C++ is used to parse a monetary value from the input stream.\n• mon: represents the object where the monetary value will be stored\n• intl: Boolean value which is true of international representation and false otherwise.\n\nThe put_money function is the counterpart of get_money function is used to format and output a monetary value to the given output stream.\n• mon: represents the object where the monetary value will be stored\n• intl: Boolean value which is true of international representation and false otherwise.\n\nThe get_time function in C++ is used to parse a date and time value from the input stream according to the specified format.\n• tmb: It is a pointer to the structure where the date and time information will be stored\n• fmt: It represents the desired format of date and time.\n\nThe put_time function is used to format and output a date/time value according to the format specified for the given stream.\n• tmb: It is a pointer to the structure where the date and time information will be stored\n• fmt: It represents the desired format of date and time.\n\nThe quoted function in C++ is used to insert and extract quoted strings with embedded space.\n• delim: Character to be used as delimiter.\n• escape: Character to be used as escape sequence."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/header",
        "document": "The interface of C++ standard library is defined by the following collection of headers.\n\nFor some of the C standard library headers of the form , the C++ standard library both includes an identically-named header and another header of the form (all meaningful headers are listed above). The intended use of headers of form is for interoperability only. It is possible that C++ source files need to include one of these headers in order to be valid ISO C. Source files that are not intended to also be valid ISO C should not use any of the C headers.\n\nWith the exception of , each header included in the C++ standard library places in the global namespace each name that the corresponding header would have placed in the std namespace.\n\nThese headers are allowed to also declare the same names in the std namespace, and the corresponding headers are allowed to also declare the same names in the global namespace: including definitely provides std::malloc and may also provide ::malloc. Including definitely provides ::malloc and may also provide std::malloc. This applies even to functions and function overloads that are not part of C standard library.\n\nNotes: headers are deprecated in C++98 and undeprecated in C++23. These headers are discouraged for pure C++ code, but not subject to future removal.\n\nThe headers , , and declare names which are also provided in the C standard library. The header also defines the macro which is a keyword in C. Unlike other headers, corresponding , , and are not provided.\n\nThe headers , , , and do not contain any content from the C standard library and instead merely include other headers from the C++ standard library.\n\nThe headers , , and are meaningless in C++ because the macros they provide in C are language keywords in C++.\n\nThe C headers ,(until C++23) , and are not included in C++ and have no equivalents.\n\nC++ TR's/TS's also define several collections of headers."
    },
    {
        "link": "https://stackoverflow.com/questions/74860097/is-iostream-a-header-or-a-library",
        "document": "I have just started learning cpp and one thing that is really confusing me is or . Some people say that we are including iostream library and some say that is used for including header files. But and don't have extension so how can they be header files? Also, can we include a library by using ? This also makes me think about difference between and . Which one is header file? Which one is library? If we are only including header files then why don't we write ?\n\nWhat does the standard cpp library contain? Smaller libraries like containers library , utilities library?\n\nI tried looking on cppreference but couldn't understand"
    },
    {
        "link": "https://ibm.com/docs/en/xl-c-and-cpp-aix/13.1.0?topic=reference-standard-library-header-files",
        "document": "The Standard C++ Library can be categorized as follows:\n• The Containers, Iterators and Algorithms Libraries (the Standard Template Library)\n• C++ Headers for the Standard C Library\n• TR1 Headers for the Standard C Library\n\nThe Language Support Library The Language Support Library defines types and functions that will be used implicitly by C++ programs that employ such C++ language features as operators new and delete, exception handling and runtime type information (RTTI).\n\nThe Diagnostics Library The Diagnostics Library is used to detect and report error conditions in C++ programs.\n\nThe General Utilities Library The General Utilities Library is used by other components of the Standard C++ Library, especially the Containers, Iterators and Algorithms Libraries (the Standard Template Library).\n\nThe Standard String Templates The Strings Library is a facility for the manipulation of character sequences.\n\nLocalization Classes and Templates The Localization Library permits a C++ program to address the cultural differences of its various users.\n\nThe Containers, Iterators and Algorithms Libraries (the Standard Template Library) The Standard Template Library (STL) is a facility for the management and manipulation of collections of objects.\n\nThe Standard Numerics Library The Numerics Library is a facility for performing seminumerical operations.\n\nUsers who require library facilities for complex arithmetic but want to maintain compatibility with older compilers may use the compatibility complex numbers library whose types are defined in the non-standard header file <complex.h>. Although the header files <complex> and <complex.h> are similar in purpose, they are mutually incompatible.\n\nThe Standard Input/Output Library The standard iostreams library differs from the compatibility iostreams in a number of important respects. To maintain compatibility between such a product and VisualAge® C++ Version 5.0 or greater, use instead the compatibility iostreams library.\n\nC++ Headers for the Standard C Library The 1990 C International Standard specifies 18 headers which must be provided by a conforming hosted implementation. The name of each of these headers is of the form name.h. The C++ Standard Library includes the 1990 C Standard Library and, hence, includes these 18 headers. Additionally, for each of the 18 headers specified by the 1990 C International Standard, the C++ standard specifies a corresponding header that is functionally equivalent to its C library counterpart, but which locates all of the declarations that it contains within the std namespace. The name of each of these C++ headers is of the form cname, where name is the string that results when the “.h” extension is removed from the name of the equivalent C Standard Library header. For example, the header files <stdlib.h> and <cstdlib> are both provided by the C++ Standard Library and are equivalent in function, with the exception that all declarations in <cstdlib> are located within the namespace.\n\nTR1 Headers for the Standard C Library In addition to the 18 headers that were introduced in the 1990 C International Standard, the 1999 C International Standard specifies new 5 headers which must be provided by a conforming hosted implementation. The name of each of these headers is of the form name.h. TR1 includes the 1999 C Standard Library and, hence, includes these 5 headers. Additionally, for each of the 5 headers specified by the 1999 C International Standard, the C++ standard specifies a corresponding header that is functionally equivalent to its C library counterpart, but which locates all of the declarations that it contains within the std namespace. The name of each of these C++ headers is of the form cname, where name is the string that results when the \".h\" extension is removed from the name of the equivalent C Standard Library header. For example, the header files <fenv.h> and <cfenv> are both provided by TR1 and are equivalent in function, with the exception that all declarations in <cfenv> are located within the std namespace. In addition to the 18 headers that were introduced in the 1990 C International Standard, the 1999 C International Standard specifies new 5 headers which must be provided by a conforming hosted implementation. The name of each of these headers is of the form name.h. TR1 includes the 1999 C Standard Library and, hence, includes these 5 headers. Additionally, for each of the 5 headers specified by the 1999 C International Standard, the C++ standard specifies a corresponding header that is functionally equivalent to its C library counterpart, but which locates all of the declarations that it contains within the std namespace. The name of each of these C++ headers is of the form cname, where name is the string that results when the \".h\" extension is removed from the name of the equivalent C Standard Library header. For example, the header files and are both provided by TR1 and are equivalent in function, with the exception that all declarations in are located within the std namespace."
    },
    {
        "link": "https://simplilearn.com/tutorials/cpp-tutorial/cpp-setprecision",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/25925290/c-round-a-double-up-to-2-decimal-places",
        "document": "I am having trouble rounding a GPA double to 2 decimal places. (ex of a GPA needed to be rounded: 3.67924) I am currently using ceil to round up, but it currently outputs it as a whole number (368)\n\nhere is what I have right now\n\nusing the above code with 3.67924 would output 368 (which is what I want, but just without the period between the whole number and the decimals). How can I fix this?"
    },
    {
        "link": "https://stackoverflow.com/questions/9999221/double-precision-decimal-places",
        "document": "An IEEE double has 53 significant bits (that's the value of in ). That's approximately 15.95 decimal digits (log10(253)); the implementation sets to 15, not 16, because it has to round down. So you have nearly an extra decimal digit of precision (beyond what's implied by ) because of that.\n\nThe function computes the nearest representable number to a given number; it can be used to show just how precise a given number is.\n\ngives me this output on my system:\n\nAs you can see, the last displayed decimal digit changes by 3 with each consecutive value. The fact that the last displayed digit of ( ) happens to match the mathematical value is largely coincidental; it was a lucky guess. And the correct rounded digit is , not . Replacing by gives this output:\n\nwhich shows about 16 decimal digits of precision, as you'd expect."
    },
    {
        "link": "https://websites.umich.edu/~eecs381/handouts/formatting.pdf",
        "document": ""
    },
    {
        "link": "https://simplilearn.com/tutorials/cpp-tutorial/cpp-double",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/24665459/best-practices-for-floating-point-arithmetics",
        "document": "I was performing addition and subtraction on an input of decimals that are precise to the second decimal place. I tried to improve accuracy by converting them to integers through multiplying 100, but achieved opposite effects.\n\nConsider the following code and output:\n\nOnce and for all, what are some of the best practices regarding floating-point arithmetics? Is it at all feasible to first convert the to an using some variant of the code above, and then casting it back?"
    },
    {
        "link": "https://stackoverflow.com/questions/77641143/how-to-safely-do-floating-point-arithmetic-in-c",
        "document": "Omitting discussion of C conformance, both of the standard and of implementations, to the IEEE 754 floating-point standard, IEEE 754 specifies five kinds of exceptions in clause 7:\n• Invalid operation is signaled iff “there is no useful definable result”: general operations on a signaling NaN, multiplication of a zero by an infinity, addition of opposite-signed infinities, subtraction of same-signed infinities, division of zero by zero or infinity by infinity, square root of a number less than zero, certain uses of the quantize operation (used to adjust the exponent of decimal formats), conversions to integer that cannot represent the result, comparisons of NaNs with operators that require non-NaNs, and integer-logarithm (“get the floating-point exponent”) of a NaN, +∞, or zero.\n• Division by zero is signaled for ordinary division by zero and integer-logarithm of −∞.\n• Overflow is signaled when the computed result is infinite because the exponent is bounded by the floating-point format (not because it would “naturally” be infinite).\n• Underflow is signaled when the computed result is zero because the exponent is bounded by the floating-point format (not because it would “naturally” be zero) except an implementation may also signal underflow when the result before rounding is lower in magnitude than the smallest representable non-zero number.\n• Inexact is signaled when the computed floating-point result differs from the real-number arithmetic result. (Inexact is a frequent outcome of floating-point arithmetic so that it is considered normal, not an exception in a common language sense, except in special-purpose code.)\n\nIn this context, “signaled” means the exception is indicted in some means, such as setting a bit in a status register. It does not mean program execution is interrupted or altered, as when a Unix signal causes a signal handler to be executed. The above is a summary and omits some details.\n\nThe current C standard, 2018, and the forthcoming standard, if faithful to the available drafts, provide facilities for testing floating-point exceptions in clause 7.6, discussing the header and its associated facilities. Testing for exceptions is specified in 7.6.4.\n\nattempts to clear all supported exception flags and returns zero iff succesful.\n\nreturns the bitwise AND of and the exception flags that are set. The mask may be a bitwise OR of , , , , , and possibly other flag names supported by the particular C implementation.\n\nTesting exceptions in this way may be slow, depending on the C implementation and its underlying hardware, because it may require accessing a status register in a way that interrupts processor execution of instructions or because it requires the compiler to use scalar floating-point instructions when it might have optimized to using SIMD instructions if the flags were not being accessed. Some C implementations may provide alternate methods of testing flags. In particular, for performance, it may be preferable not to test flags explicitly but rather to set exception handlers to be triggered when an exception occurs. This can be useful for detecting exceptions you expect to be rare, such as overflows with code designed to avoid them. However, with exceptions that are common, such as inexact (normally common) or underflow (not uncommon in some code, such as diminishing echo effects), frequent execution of exception handlers will impair performance."
    },
    {
        "link": "https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html",
        "document": "What Every Computer Scientist Should Know About Floating-Point Arithmetic\n\nFloating-point arithmetic is considered an esoteric subject by many people. This is rather surprising because floating-point is ubiquitous in computer systems. Almost every language has a floating-point datatype; computers from PCs to supercomputers have floating-point accelerators; most compilers will be called upon to compile floating-point algorithms from time to time; and virtually every operating system must respond to floating-point exceptions such as overflow. This paper presents a tutorial on those aspects of floating-point that have a direct impact on designers of computer systems. It begins with background on floating-point representation and rounding error, continues with a discussion of the IEEE floating-point standard, and concludes with numerous examples of how computer builders can better support floating-point.\n\nBuilders of computer systems often need information about floating-point arithmetic. There are, however, remarkably few sources of detailed information about it. One of the few books on the subject, Floating-Point Computation by Pat Sterbenz, is long out of print. This paper is a tutorial on those aspects of floating-point arithmetic (floating-point hereafter) that have a direct connection to systems building. It consists of three loosely connected parts. The first section, Rounding Error, discusses the implications of using different rounding strategies for the basic operations of addition, subtraction, multiplication and division. It also contains background information on the two methods of measuring rounding error, ulps and . The second part discusses the IEEE floating-point standard, which is becoming rapidly accepted by commercial hardware manufacturers. Included in the IEEE standard is the rounding method for basic operations. The discussion of the standard draws on the material in the section Rounding Error. The third part discusses the connections between floating-point and the design of various aspects of computer systems. Topics include instruction set design, optimizing compilers and exception handling.\n\nI have tried to avoid making statements about floating-point without also giving reasons why the statements are true, especially since the justifications involve nothing more complicated than elementary calculus. Those explanations that are not central to the main argument have been grouped into a section called \"The Details,\" so that they can be skipped if desired. In particular, the proofs of many of the theorems appear in this section. The end of each proof is marked with the symbol. When a proof is not included, the appears immediately following the statement of the theorem.\n\nSqueezing infinitely many real numbers into a finite number of bits requires an approximate representation. Although there are infinitely many integers, in most programs the result of integer computations can be stored in 32 bits. In contrast, given any fixed number of bits, most calculations with real numbers will produce quantities that cannot be exactly represented using that many bits. Therefore the result of a floating-point calculation must often be rounded in order to fit back into its finite representation. This rounding error is the characteristic feature of floating-point computation. The section Relative Error and Ulps describes how it is measured.\n\nSince most floating-point calculations have rounding error anyway, does it matter if the basic arithmetic operations introduce a little bit more rounding error than necessary? That question is a main theme throughout this section. The section Guard Digits discusses guard digits, a means of reducing the error when subtracting two nearby numbers. Guard digits were considered sufficiently important by IBM that in 1968 it added a guard digit to the double precision format in the System/360 architecture (single precision already had a guard digit), and retrofitted all existing machines in the field. Two examples are given to illustrate the utility of guard digits.\n\nThe IEEE standard goes further than just requiring the use of a guard digit. It gives an algorithm for addition, subtraction, multiplication, division and square root, and requires that implementations produce the same result as that algorithm. Thus, when a program is moved from one machine to another, the results of the basic operations will be the same in every bit if both machines support the IEEE standard. This greatly simplifies the porting of programs. Other uses of this precise specification are given in Exactly Rounded Operations.\n\nSeveral different representations of real numbers have been proposed, but by far the most widely used is the floating-point representation.1 Floating-point representations have a base (which is always assumed to be even) and a precision . If = 10 and = 3, then the number 0.1 is represented as 1.00 10-1. If = 2 and = 24, then the decimal number 0.1 cannot be represented exactly, but is approximately 1.10011001100110011001101 2-4.\n\nIn general, a floating-point number will be represented as e, where is called the significand2 and has digits. More precisely e represents the number\n\nThe term floating-point number will be used to mean a real number that can be exactly represented in the format under discussion. Two other parameters associated with floating-point representations are the largest and smallest allowable exponents, and . Since there are p possible significands, and - + 1 possible exponents, a floating-point number can be encoded in\n\nbits, where the final +1 is for the sign bit. The precise encoding is not important for now.\n\nThere are two reasons why a real number might not be exactly representable as a floating-point number. The most common situation is illustrated by the decimal number 0.1. Although it has a finite decimal representation, in binary it has an infinite repeating representation. Thus when = 2, the number 0.1 lies strictly between two floating-point numbers and is exactly representable by neither of them. A less common situation is that a real number is out of range, that is, its absolute value is larger than or smaller than 1.0 . Most of this paper discusses issues due to the first reason. However, numbers that are out of range will be discussed in the sections Infinity and Denormalized Numbers.\n\nFloating-point representations are not necessarily unique. For example, both 0.01 101 and 1.00 10-1 represent 0.1. If the leading digit is nonzero ( 0 in equation (1) above), then the representation is said to be normalized. The floating-point number 1.00 10-1 is normalized, while 0.01 101 is not. When = 2, = 3, = -1 and = 2 there are 16 normalized floating-point numbers, as shown in FIGURE D-1. The bold hash marks correspond to numbers whose significand is 1.00. Requiring that a floating-point representation be normalized makes the representation unique. Unfortunately, this restriction makes it impossible to represent zero! A natural way to represent 0 is with 1.0 , since this preserves the fact that the numerical ordering of nonnegative real numbers corresponds to the lexicographic ordering of their floating-point representations.3 When the exponent is stored in a bit field, that means that only 2k - 1 values are available for use as exponents, since one must be reserved to represent 0.\n\nNote that the in a floating-point number is part of the notation, and different from a floating-point multiply operation. The meaning of the symbol should be clear from the context. For example, the expression (2.5 10-3) (4.0 102) involves only a single floating-point multiplication.\n\nSince rounding error is inherent in floating-point computation, it is important to have a way to measure this error. Consider the floating-point format with = 10 and = 3, which will be used throughout this section. If the result of a floating-point computation is 3.12 10-2, and the answer when computed to infinite precision is .0314, it is clear that this is in error by 2 units in the last place. Similarly, if the real number .0314159 is represented as 3.14 10-2, then it is in error by .159 units in the last place. In general, if the floating-point number e is used to represent , then it is in error by ( / e) p-1 units in the last place.4, 5 The term ulps will be used as shorthand for \"units in the last place.\" If the result of a calculation is the floating-point number nearest to the correct result, it still might be in error by as much as .5 ulp. Another way to measure the difference between a floating-point number and the real number it is approximating is relative error, which is simply the difference between the two numbers divided by the real number. For example the relative error committed when approximating 3.14159 by 3.14 × 100 is .00159/3.14159 .0005.\n\nTo compute the relative error that corresponds to .5 ulp, observe that when a real number is approximated by the closest possible floating-point number e, the error can be as large as 0.00 00 ' e, where ' is the digit /2, there are units in the significand of the floating-point number, and units of 0 in the significand of the error. This error is (( /2) -p) e. Since numbers of the form e all have the same absolute error, but have values that range between e and e, the relative error ranges between (( /2) -p) e/ e and (( /2) -p) e/ e+1. That is,\n\nIn particular, the relative error corresponding to .5 ulp can vary by a factor of . This factor is called the wobble. Setting = ( /2) -p to the largest of the bounds in (2) above, we can say that when a real number is rounded to the closest floating-point number, the relative error is always bounded by , which is referred to as machine epsilon.\n\nIn the example above, the relative error was .00159/3.14159 .0005. In order to avoid such small numbers, the relative error is normally written as a factor times , which in this case is = ( /2) -p = 5(10)-3 = .005. Thus the relative error would be expressed as (.00159/3.14159)/.005) 0.1 .\n\nTo illustrate the difference between ulps and relative error, consider the real number = 12.35. It is approximated by = 1.24 101. The error is 0.5 ulps, the relative error is 0. . Next consider the computation 8 . The exact value is 8 = 98.8, while the computed value is 8 = 9.92 101. The error is now 4.0 ulps, but the relative error is still 0. . The error measured in ulps is 8 times larger, even though the relative error is the same. In general, when the base is , a fixed relative error expressed in ulps can wobble by a factor of up to . And conversely, as equation (2) above shows, a fixed error of .5 ulps results in a relative error that can wobble by .\n\nThe most natural way to measure rounding error is in ulps. For example rounding to the nearest floating-point number corresponds to an error of less than or equal to .5 ulp. However, when analyzing the rounding error caused by various formulas, relative error is a better measure. A good illustration of this is the analysis in the section Theorem 9. Since can overestimate the effect of rounding to the nearest floating-point number by the wobble factor of , error estimates of formulas will be tighter on machines with a small .\n\nWhen only the order of magnitude of rounding error is of interest, ulps and may be used interchangeably, since they differ by at most a factor of . For example, when a floating-point number is in error by ulps, that means that the number of contaminated digits is log . If the relative error in a computation is , then\n\nOne method of computing the difference between two floating-point numbers is to compute the difference exactly and then round it to the nearest floating-point number. This is very expensive if the operands differ greatly in size. Assuming = 3, 2.15 1012 - 1.25 10-5 would be calculated as\n\nwhich rounds to 2.15 1012. Rather than using all these digits, floating-point hardware normally operates on a fixed number of digits. Suppose that the number of digits kept is , and that when the smaller operand is shifted right, digits are simply discarded (as opposed to rounding). Then 2.15 1012 - 1.25 10-5 becomes\n\nThe answer is exactly the same as if the difference had been computed exactly and then rounded. Take another example: 10.1 - 9.93. This becomes\n\nThe correct answer is .17, so the computed difference is off by 30 ulps and is wrong in every digit! How bad can the error be?\n\nWhen =2, the relative error can be as large as the result, and when =10, it can be 9 times larger. Or to put it another way, when =2, equation (3) shows that the number of contaminated digits is log (1/ ) = log (2p) = . That is, all of the digits in the result are wrong! Suppose that one extra digit is added to guard against this situation (a guard digit). That is, the smaller number is truncated to + 1 digits, and then the result of the subtraction is rounded to digits. With a guard digit, the previous example becomes\n\nand the answer is exact. With a single guard digit, the relative error of the result may be greater than , as in 110 - 8.59.\n\nThis rounds to 102, compared with the correct answer of 101.41, for a relative error of .006, which is greater than = .005. In general, the relative error of the result can be only slightly larger than . More precisely,\n\nThis theorem will be proven in Rounding Error. Addition is included in the above theorem since and can be positive or negative.\n\nThe last section can be summarized by saying that without a guard digit, the relative error committed when subtracting two nearby quantities can be very large. In other words, the evaluation of any expression containing a subtraction (or an addition of quantities with opposite signs) could result in a relative error so large that all the digits are meaningless (Theorem 1). When subtracting nearby quantities, the most significant digits in the operands match and cancel each other. There are two kinds of cancellation: catastrophic and benign.\n\nCatastrophic cancellation occurs when the operands are subject to rounding errors. For example in the quadratic formula, the expression 2 - 4 occurs. The quantities 2 and 4 are subject to rounding errors since they are the results of floating-point multiplications. Suppose that they are rounded to the nearest floating-point number, and so are accurate to within .5 ulp. When they are subtracted, cancellation can cause many of the accurate digits to disappear, leaving behind mainly digits contaminated by rounding error. Hence the difference might have an error of many ulps. For example, consider = 3.34, = 1.22, and = 2.28. The exact value of 2 - 4 is .0292. But 2 rounds to 11.2 and 4 rounds to 11.1, hence the final answer is .1 which is an error by 70 ulps, even though 11.2 - 11.1 is exactly equal to .16. The subtraction did not introduce any error, but rather exposed the error introduced in the earlier multiplications.\n\nBenign cancellation occurs when subtracting exactly known quantities. If x and y have no rounding error, then by Theorem 2 if the subtraction is done with a guard digit, the difference x-y has a very small relative error (less than 2 ).\n\nA formula that exhibits catastrophic cancellation can sometimes be rearranged to eliminate the problem. Again consider the quadratic formula\n\nWhen , then does not involve a cancellation and\n\nBut the other addition (subtraction) in one of the formulas will have a catastrophic cancellation. To avoid this, multiply the numerator and denominator of by\n\n(and similarly for ) to obtain\n\nIf and , then computing using formula (4) will involve a cancellation. Therefore, use formula (5) for computing and (4) for . On the other hand, if < 0, use (4) for computing and (5) for .\n\nThe expression x2 - 2 is another formula that exhibits catastrophic cancellation. It is more accurate to evaluate it as ( - )( + ).7 Unlike the quadratic formula, this improved form still has a subtraction, but it is a benign cancellation of quantities without rounding error, not a catastrophic one. By Theorem 2, the relative error in x - is at most 2 . The same is true of x + . Multiplying two quantities with a small relative error results in a product with a small relative error (see the section Rounding Error).\n\nIn order to avoid confusion between exact and computed values, the following notation is used. Whereas x - denotes the exact difference of x and y, x denotes the computed difference (i.e., with rounding error). Similarly , , and denote computed addition, multiplication, and division, respectively. All caps indicate the computed value of a function, as in or . Lowercase functions and traditional mathematical notation denote their exact values as in ln( ) and .\n\nAlthough ( ) ( ) is an excellent approximation to x2 - y2, the floating-point numbers x and y might themselves be approximations to some true quantities and . For example, and might be exactly known decimal numbers that cannot be expressed exactly in binary. In this case, even though x is a good approximation to - , it can have a huge relative error compared to the true expression , and so the advantage of ( + )( - ) over x2 - y2 is not as dramatic. Since computing ( + )( - ) is about the same amount of work as computing x2 - y2, it is clearly the preferred form in this case. In general, however, replacing a catastrophic cancellation by a benign one is not worthwhile if the expense is large, because the input is often (but not always) an approximation. But eliminating a cancellation entirely (as in the quadratic formula) is worthwhile even if the data are not exact. Throughout this paper, it will be assumed that the floating-point inputs to an algorithm are exact and that the results are computed as accurately as possible.\n\nThe expression x2 - 2 is more accurate when rewritten as ( - )( + ) because a catastrophic cancellation is replaced with a benign one. We next present more interesting examples of formulas exhibiting catastrophic cancellation that can be rewritten to exhibit only benign cancellation.\n\nThe area of a triangle can be expressed directly in terms of the lengths of its sides , , and as\n\n(Suppose the triangle is very flat; that is, + . Then , and the term ( - ) in formula (6) subtracts two nearby numbers, one of which may have rounding error. For example, if = 9.0, = = 4.53, the correct value of is 9.03 and is 2.342.... Even though the computed value of (9.05) is in error by only 2 ulps, the computed value of is 3.04, an error of 70 ulps.\n\nThere is a way to rewrite formula (6) so that it will return accurate results even for flat triangles [Kahan 1986]. It is\n\nIf , and do not satisfy , rename them before applying (7). It is straightforward to check that the right-hand sides of (6) and (7) are algebraically identical. Using the values of , , and above gives a computed area of 2.35, which is 1 ulp in error and much more accurate than the first formula.\n\nAlthough formula (7) is much more accurate than (6) for this example, it would be nice to know how well (7) performs in general.\n\nThe condition that < .005 is met in virtually every actual floating-point system. For example when = 2, p 8 ensures that < .005, and when = 10, p 3 is enough.\n\nIn statements like Theorem 3 that discuss the relative error of an expression, it is understood that the expression is computed using floating-point arithmetic. In particular, the relative error is actually of the expression\n\nBecause of the cumbersome nature of (8), in the statement of theorems we will usually say the computed value of rather than writing out with circle notation.\n\nError bounds are usually too pessimistic. In the numerical example given above, the computed value of (7) is 2.35, compared with a true value of 2.34216 for a relative error of 0.7 , which is much less than 11 . The main reason for computing error bounds is not to get precise bounds but rather to verify that the formula does not contain numerical problems.\n\nA final example of an expression that can be rewritten to use benign cancellation is (1 + )n, where . This expression arises in financial calculations. Consider depositing $100 every day into a bank account that earns an annual interest rate of 6%, compounded daily. If = 365 and = .06, the amount of money accumulated at the end of one year is\n\ndollars. If this is computed using = 2 and p = 24, the result is $37615.45 compared to the exact answer of $37614.05, a discrepancy of $1.40. The reason for the problem is easy to see. The expression 1 + / involves adding 1 to .0001643836, so the low order bits of / are lost. This rounding error is amplified when 1 + / is raised to the th power.\n\nThe troublesome expression (1 + / )n can be rewritten as nln(1 + i/n), where now the problem is to compute ln(1 + ) for small x. One approach is to use the approximation ln(1 + ) , in which case the payment becomes $37617.26, which is off by $3.21 and even less accurate than the obvious formula. But there is a way to compute ln(1 + ) very accurately, as Theorem 4 shows [Hewlett-Packard 1982]. This formula yields $37614.07, accurate to within two cents!\n\nTheorem 4 assumes that approximates ln( ) to within 1/2 ulp. The problem it solves is that when x is small, (1 ) is not close to ln(1 + ) because 1 has lost the information in the low order bits of x. That is, the computed value of ln(1 + ) is not close to its actual value when .\n\nThis formula will work for any value of x but is only interesting for , which is where catastrophic cancellation occurs in the naive formula ln(1 + ). Although the formula may seem mysterious, there is a simple explanation for why it works. Write ln(1 + ) as\n\nThe left hand factor can be computed exactly, but the right hand factor ( ) = ln(1 + )/ will suffer a large rounding error when adding 1 to x. However, is almost constant, since ln(1 + ) . So changing x slightly will not introduce much error. In other words, if , computing will be a good approximation to x ( ) = ln(1 + ). Is there a value for for which and can be computed accurately? There is; namely = (1 ) 1, because then 1 + is exactly equal to 1 .\n\nThe results of this section can be summarized by saying that a guard digit guarantees accuracy when nearby precisely known quantities are subtracted (benign cancellation). Sometimes a formula that gives inaccurate results can be rewritten to have much higher numerical accuracy by using benign cancellation; however, the procedure only works if subtraction is performed using a guard digit. The price of a guard digit is not high, because it merely requires making the adder one bit wider. For a 54 bit double precision adder, the additional cost is less than 2%. For this price, you gain the ability to run many algorithms such as formula (6) for computing the area of a triangle and the expression ln(1 + ). Although most modern computers have a guard digit, there are a few (such as Cray systems) that do not.\n\nWhen floating-point operations are done with a guard digit, they are not as accurate as if they were computed exactly then rounded to the nearest floating-point number. Operations performed in this manner will be called exactly rounded.8 The example immediately preceding Theorem 2 shows that a single guard digit will not always give exactly rounded results. The previous section gave several examples of algorithms that require a guard digit in order to work properly. This section gives examples of algorithms that require exact rounding.\n\nSo far, the definition of rounding has not been given. Rounding is straightforward, with the exception of how to round halfway cases; for example, should 12.5 round to 12 or 13? One school of thought divides the 10 digits in half, letting {0, 1, 2, 3, 4} round down, and {5, 6, 7, 8, 9} round up; thus 12.5 would round to 13. This is how rounding works on Digital Equipment Corporation's VAX computers. Another school of thought says that since numbers ending in 5 are halfway between two possible roundings, they should round down half the time and round up the other half. One way of obtaining this 50% behavior to require that the rounded result have its least significant digit be even. Thus 12.5 rounds to 12 rather than 13 because 2 is even. Which of these methods is best, round up or round to even? Reiser and Knuth [1975] offer the following reason for preferring round to even.\n\nTo clarify this result, consider = 10, p = 3 and let x = 1.00, y = -.555. When rounding up, the sequence becomes\n\nand each successive value of x increases by .01, until x = 9.45 (n 845)9. Under round to even, x is always 1.00. This example suggests that when using the round up rule, computations can gradually drift upward, whereas when using round to even the theorem says this cannot happen. Throughout the rest of this paper, round to even will be used.\n\nOne application of exact rounding occurs in multiple precision arithmetic. There are two basic approaches to higher precision. One approach represents floating-point numbers using a very large significand, which is stored in an array of words, and codes the routines for manipulating these numbers in assembly language. The second approach represents higher precision floating-point numbers as an array of ordinary floating-point numbers, where adding the elements of the array in infinite precision recovers the high precision floating-point number. It is this second approach that will be discussed here. The advantage of using an array of floating-point numbers is that it can be coded portably in a high level language, but it requires exactly rounded arithmetic.\n\nThe key to multiplication in this system is representing a product xy as a sum, where each summand has the same precision as x and y. This can be done by splitting x and y. Writing x = + x and y = + y , the exact product is\n\nIf x and y have p bit significands, the summands will also have p bit significands provided that x , x , y , y can be represented using /2 bits. When is even, it is easy to find a splitting. The number x . x can be written as the sum of x . and 0.0 0 . When p is odd, this simple splitting method will not work. An extra bit can, however, be gained by using negative numbers. For example, if = 2, p = 5, and x = .10111, x can be split as x = .11 and x = -.00001. There is more than one way to split a number. A splitting method that is easy to compute is due to Dekker [1971], but it requires more than a single guard digit.\n\nand each x is representable using [p/2] bits of precision.\n\nTo see how this theorem works in an example, let = 10, p = 4, = 3.476, = 3.463, and = 3.479. Then 2 - rounded to the nearest floating-point number is .03480, while = 12.08, = 12.05, and so the computed value of 2 - is .03. This is an error of 480 ulps. Using Theorem 6 to write = 3.5 - .024, = 3.5 - .037, and = 3.5 - .021, 2 becomes 3.52 - 2 3.5 .024 + .0242. Each summand is exact, so 2 = 12.25 - .168 + .000576, where the sum is left unevaluated at this point. Similarly, = 3.52 - (3.5 .037 + 3.5 .021) + .037 .021 = 12.25 - .2030 +.000777. Finally, subtracting these two series term by term gives an estimate for 2 - of 0 .0350 .000201 = .03480, which is identical to the exactly rounded result. To show that Theorem 6 really requires exact rounding, consider p = 3, = 2, and x = 7. Then = 5, = 35, and = 32. If subtraction is performed with a single guard digit, then ( ) = 28. Therefore, x = 4 and x = 3, hence x is not representable with /2] = 1 bit.\n\nAs a final example of exact rounding, consider dividing by 10. The result is a floating-point number that will in general not be equal to /10. When = 2, multiplying /10 by 10 will restore , provided exact rounding is being used. Actually, a more general fact (due to Kahan) is true. The proof is ingenious, but readers not interested in such details can skip ahead to section The IEEE Standard.\n\nThe theorem holds true for any base , as long as 2i + 2j is replaced by i + j. As gets larger, however, denominators of the form i + j are farther and farther apart.\n\nWe are now in a position to answer the question, Does it matter if the basic arithmetic operations introduce a little more rounding error than necessary? The answer is that it does matter, because accurate basic operations enable us to prove that formulas are \"correct\" in the sense they have a small relative error. The section Cancellation discussed several algorithms that require guard digits to produce correct results in this sense. If the input to those formulas are numbers representing imprecise measurements, however, the bounds of Theorems 3 and 4 become less interesting. The reason is that the benign cancellation x - can become catastrophic if x and y are only approximations to some measured quantity. But accurate operations are useful even in the face of inexact data, because they enable us to establish exact relationships like those discussed in Theorems 6 and 7. These are useful even if every floating-point variable is only an approximation to some actual value.\n\nThere are two different IEEE standards for floating-point computation. IEEE 754 is a binary standard that requires = 2, p = 24 for single precision and p = 53 for double precision [IEEE 1987]. It also specifies the precise layout of bits in a single and double precision. IEEE 854 allows either = 2 or = 10 and unlike 754, does not specify how floating-point numbers are encoded into bits [Cody et al. 1984]. It does not require a particular value for p, but instead it specifies constraints on the allowable values of p for single and double precision. The term IEEE Standard will be used when discussing properties common to both standards.\n\nThis section provides a tour of the IEEE standard. Each subsection discusses one aspect of the standard and why it was included. It is not the purpose of this paper to argue that the IEEE standard is the best possible floating-point standard but rather to accept the standard as given and provide an introduction to its use. For full details consult the standards themselves [IEEE 1987; Cody et al. 1984].\n\nIt is clear why IEEE 854 allows = 10. Base ten is how humans exchange and think about numbers. Using = 10 is especially appropriate for calculators, where the result of each operation is displayed by the calculator in decimal.\n\nThere are several reasons why IEEE 854 requires that if the base is not 10, it must be 2. The section Relative Error and Ulps mentioned one reason: the results of error analyses are much tighter when is 2 because a rounding error of .5 ulp wobbles by a factor of when computed as a relative error, and error analyses are almost always simpler when based on relative error. A related reason has to do with the effective precision for large bases. Consider = 16, p = 1 compared to = 2, p = 4. Both systems have 4 bits of significand. Consider the computation of 15/8. When = 2, 15 is represented as 1.111 23, and 15/8 as 1.111 20. So 15/8 is exact. However, when = 16, 15 is represented as 160, where is the hexadecimal digit for 15. But 15/8 is represented as 1 160, which has only one bit correct. In general, base 16 can lose up to 3 bits, so that a precision of p hexadecimal digits can have an effective precision as low as 4 - 3 rather than 4 binary bits. Since large values of have these problems, why did IBM choose = 16 for its system/370? Only IBM knows for sure, but there are two possible reasons. The first is increased exponent range. Single precision on the system/370 has = 16, p = 6. Hence the significand requires 24 bits. Since this must fit into 32 bits, this leaves 7 bits for the exponent and one for the sign bit. Thus the magnitude of representable numbers ranges from about to about = . To get a similar exponent range when = 2 would require 9 bits of exponent, leaving only 22 bits for the significand. However, it was just pointed out that when = 16, the effective precision can be as low as 4 - 3 = 21 bits. Even worse, when = 2 it is possible to gain an extra bit of precision (as explained later in this section), so the = 2 machine has 23 bits of precision to compare with a range of 21 - 24 bits for the = 16 machine.\n\nAnother possible explanation for choosing = 16 has to do with shifting. When adding two floating-point numbers, if their exponents are different, one of the significands will have to be shifted to make the radix points line up, slowing down the operation. In the = 16, p = 1 system, all the numbers between 1 and 15 have the same exponent, and so no shifting is required when adding any of the ( ) = 105 possible pairs of distinct numbers from this set. However, in the = 2, p = 4 system, these numbers have exponents ranging from 0 to 3, and shifting is required for 70 of the 105 pairs.\n\nIn most modern hardware, the performance gained by avoiding a shift for a subset of operands is negligible, and so the small wobble of = 2 makes it the preferable base. Another advantage of using = 2 is that there is a way to gain an extra bit of significance.12 Since floating-point numbers are always normalized, the most significant bit of the significand is always 1, and there is no reason to waste a bit of storage representing it. Formats that use this trick are said to have a hidden bit. It was already pointed out in Floating-point Formats that this requires a special convention for 0. The method given there was that an exponent of e - 1 and a significand of all zeros represents not , but rather 0.\n\nIEEE 754 single precision is encoded in 32 bits using 1 bit for the sign, 8 bits for the exponent, and 23 bits for the significand. However, it uses a hidden bit, so the significand is 24 bits (p = 24), even though it is encoded using only 23 bits.\n\nThe IEEE standard defines four different precisions: single, double, single-extended, and double-extended. In IEEE 754, single and double precision correspond roughly to what most floating-point hardware provides. Single precision occupies a single 32 bit word, double precision two consecutive 32 bit words. Extended precision is a format that offers at least a little extra precision and exponent range (TABLE D-1).\n\nThe IEEE standard only specifies a lower bound on how many extra bits extended precision provides. The minimum allowable double-extended format is sometimes referred to as 80-bit format, even though the table shows it using 79 bits. The reason is that hardware implementations of extended precision normally do not use a hidden bit, and so would use 80 rather than 79 bits.13\n\nThe standard puts the most emphasis on extended precision, making no recommendation concerning double precision, but strongly recommending that Implementations should support the extended format corresponding to the widest basic format supported,\n\nOne motivation for extended precision comes from calculators, which will often display 10 digits, but use 13 digits internally. By displaying only 10 of the 13 digits, the calculator appears to the user as a \"black box\" that computes exponentials, cosines, etc. to 10 digits of accuracy. For the calculator to compute functions like exp, log and cos to within 10 digits with reasonable efficiency, it needs a few extra digits to work with. It is not hard to find a simple rational expression that approximates log with an error of 500 units in the last place. Thus computing with 13 digits gives an answer correct to 10 digits. By keeping these extra 3 digits hidden, the calculator presents a simple model to the operator.\n\nExtended precision in the IEEE standard serves a similar function. It enables libraries to efficiently compute quantities to within about .5 ulp in single (or double) precision, giving the user of those libraries a simple model, namely that each primitive operation, be it a simple multiply or an invocation of log, returns a value accurate to within about .5 ulp. However, when using extended precision, it is important to make sure that its use is transparent to the user. For example, on a calculator, if the internal representation of a displayed value is not rounded to the same precision as the display, then the result of further operations will depend on the hidden digits and appear unpredictable to the user.\n\nTo illustrate extended precision further, consider the problem of converting between IEEE 754 single precision and decimal. Ideally, single precision numbers will be printed with enough digits so that when the decimal number is read back in, the single precision number can be recovered. It turns out that 9 decimal digits are enough to recover a single precision binary number (see the section Binary to Decimal Conversion). When converting a decimal number back to its unique binary representation, a rounding error as small as 1 ulp is fatal, because it will give the wrong answer. Here is a situation where extended precision is vital for an efficient algorithm. When single-extended is available, a very straightforward method exists for converting a decimal number to a single precision binary one. First read in the 9 decimal digits as an integer , ignoring the decimal point. From TABLE D-1, p 32, and since 109 < 232 4.3 109, can be represented exactly in single-extended. Next find the appropriate power 10P necessary to scale . This will be a combination of the exponent of the decimal number, together with the position of the (up until now) ignored decimal point. Compute 10|P|. If | | 13, then this is also represented exactly, because 1013 = 213513, and 513 < 232. Finally multiply (or divide if p < 0) and 10|P|. If this last operation is done exactly, then the closest binary number is recovered. The section Binary to Decimal Conversion shows how to do the last multiply (or divide) exactly. Thus for | | 13, the use of the single-extended format enables 9-digit decimal numbers to be converted to the closest binary number (i.e. exactly rounded). If | | > 13, then single-extended is not enough for the above algorithm to always compute the exactly rounded binary equivalent, but Coonen [1984] shows that it is enough to guarantee that the conversion of binary to decimal and back will recover the original binary number.\n\nIf double precision is supported, then the algorithm above would be run in double precision rather than single-extended, but to convert double precision to a 17-digit decimal number and back would require the double-extended format.\n\nSince the exponent can be positive or negative, some method must be chosen to represent its sign. Two common methods of representing signed numbers are sign/magnitude and two's complement. Sign/magnitude is the system used for the sign of the significand in the IEEE formats: one bit is used to hold the sign, the rest of the bits represent the magnitude of the number. The two's complement representation is often used in integer arithmetic. In this scheme, a number in the range [-2p-1, 2p-1 - 1] is represented by the smallest nonnegative number that is congruent to it modulo 2p.\n\nThe IEEE binary standard does not use either of these methods to represent the exponent, but instead uses a representation. In the case of single precision, where the exponent is stored in 8 bits, the bias is 127 (for double precision it is 1023). What this means is that if is the value of the exponent bits interpreted as an unsigned integer, then the exponent of the floating-point number is - 127. This is often called the unbiased exponent to distinguish from the biased exponent .\n\nReferring to TABLE D-1, single precision has e = 127 and e = -126. The reason for having |e | < e is so that the reciprocal of the smallest number will not overflow. Although it is true that the reciprocal of the largest number will underflow, underflow is usually less serious than overflow. The section Base explained that e - 1 is used for representing 0, and Special Quantities will introduce a use for e + 1. In IEEE single precision, this means that the biased exponents range between e - 1 = -127 and e + 1 = 128, whereas the unbiased exponents range between 0 and 255, which are exactly the nonnegative numbers that can be represented using 8 bits.\n\nThe IEEE standard requires that the result of addition, subtraction, multiplication and division be exactly rounded. That is, the result must be computed exactly and then rounded to the nearest floating-point number (using round to even). The section Guard Digits pointed out that computing the exact difference or sum of two floating-point numbers can be very expensive when their exponents are substantially different. That section introduced guard digits, which provide a practical way of computing differences while guaranteeing that the relative error is small. However, computing with a single guard digit will not always give the same answer as computing the exact result and then rounding. By introducing a second guard digit and a third sticky bit, differences can be computed at only a little more cost than with a single guard digit, but the result is the same as if the difference were computed exactly and then rounded [Goldberg 1990]. Thus the standard can be implemented efficiently.\n\nOne reason for completely specifying the results of arithmetic operations is to improve the portability of software. When a program is moved between two machines and both support IEEE arithmetic, then if any intermediate result differs, it must be because of software bugs, not from differences in arithmetic. Another advantage of precise specification is that it makes it easier to reason about floating-point. Proofs about floating-point are hard enough, without having to deal with multiple cases arising from multiple kinds of arithmetic. Just as integer programs can be proven to be correct, so can floating-point programs, although what is proven in that case is that the rounding error of the result satisfies certain bounds. Theorem 4 is an example of such a proof. These proofs are made much easier when the operations being reasoned about are precisely specified. Once an algorithm is proven to be correct for IEEE arithmetic, it will work correctly on any machine supporting the IEEE standard.\n\nBrown [1981] has proposed axioms for floating-point that include most of the existing floating-point hardware. However, proofs in this system cannot verify the algorithms of sections Cancellation and Exactly Rounded Operations, which require features not present on all hardware. Furthermore, Brown's axioms are more complex than simply defining operations to be performed exactly and then rounded. Thus proving theorems from Brown's axioms is usually more difficult than proving them assuming operations are exactly rounded.\n\nThere is not complete agreement on what operations a floating-point standard should cover. In addition to the basic operations +, -, and /, the IEEE standard also specifies that square root, remainder, and conversion between integer and floating-point be correctly rounded. It also requires that conversion between internal formats and decimal be correctly rounded (except for very large numbers). Kulisch and Miranker [1986] have proposed adding inner product to the list of operations that are precisely specified. They note that when inner products are computed in IEEE arithmetic, the final answer can be quite wrong. For example sums are a special case of inner products, and the sum ((2 10-30 + 1030) - 1030) - 10-30 is exactly equal to 10-30, but on a machine with IEEE arithmetic the computed result will be -10-30. It is possible to compute inner products to within 1 ulp with less hardware than it takes to implement a fast multiplier [Kirchner and Kulish 1987].14 15\n\nAll the operations mentioned in the standard are required to be exactly rounded except conversion between decimal and binary. The reason is that efficient algorithms for exactly rounding all the operations are known, except conversion. For conversion, the best known efficient algorithms produce results that are slightly worse than exactly rounded ones [Coonen 1984].\n\nThe IEEE standard does not require transcendental functions to be exactly rounded because of the table maker's dilemma. To illustrate, suppose you are making a table of the exponential function to 4 places. Then exp(1.626) = 5.0835. Should this be rounded to 5.083 or 5.084? If exp(1.626) is computed more carefully, it becomes 5.08350. And then 5.083500. And then 5.0835000. Since exp is transcendental, this could go on arbitrarily long before distinguishing whether exp(1.626) is 5.083500 0 or 5.0834999 9 . Thus it is not practical to specify that the precision of transcendental functions be the same as if they were computed to infinite precision and then rounded. Another approach would be to specify transcendental functions algorithmically. But there does not appear to be a single algorithm that works well across all hardware architectures. Rational approximation, CORDIC,16 and large tables are three different techniques that are used for computing transcendentals on contemporary machines. Each is appropriate for a different class of hardware, and at present no single algorithm works acceptably over the wide range of current hardware.\n\nOn some floating-point hardware every bit pattern represents a valid floating-point number. The IBM System/370 is an example of this. On the other hand, the VAX reserves some bit patterns to represent special numbers called . This idea goes back to the CDC 6600, which had bit patterns for the special quantities and .\n\nThe IEEE standard continues in this tradition and has NaNs (Not a Number) and infinities. Without any special quantities, there is no good way to handle exceptional situations like taking the square root of a negative number, other than aborting computation. Under IBM System/370 FORTRAN, the default action in response to computing the square root of a negative number like -4 results in the printing of an error message. Since every bit pattern represents a valid number, the return value of square root must be some floating-point number. In the case of System/370 FORTRAN, is returned. In IEEE arithmetic, a NaN is returned in this situation.\n\nThe IEEE standard specifies the following special values (see TABLE D-2): 0, denormalized numbers, and NaNs (there is more than one NaN, as explained in the next section). These special values are all encoded with exponents of either e + 1 or e - 1 (it was already pointed out that 0 has an exponent of e - 1).\n\nTraditionally, the computation of 0/0 or has been treated as an unrecoverable error which causes a computation to halt. However, there are examples where it makes sense for a computation to continue in such a situation. Consider a subroutine that finds the zeros of a function , say . Traditionally, zero finders require the user to input an interval [ , ] on which the function is defined and over which the zero finder will search. That is, the subroutine is called as , , . A more useful zero finder would not require the user to input this extra information. This more general zero finder is especially appropriate for calculators, where it is natural to simply key in a function, and awkward to then have to specify the domain. However, it is easy to see why most zero finders require a domain. The zero finder does its work by probing the function at various values. If it probed for a value outside the domain of , the code for might well compute 0/0 or , and the computation would halt, unnecessarily aborting the zero finding process.\n\nThis problem can be avoided by introducing a special value called NaN, and specifying that the computation of expressions like 0/0 and produce NaN, rather than halting. A list of some of the situations that can cause a NaN are given in TABLE D-3. Then when probes outside the domain of , the code for will return NaN, and the zero finder can continue. That is, is not \"punished\" for making an incorrect guess. With this example in mind, it is easy to see what the result of combining a NaN with an ordinary floating-point number should be. Suppose that the final statement of is . If < 0, then should return a NaN. Since < 0, is a NaN, and will be a NaN, if the sum of a NaN and any other number is a NaN. Similarly if one operand of a division operation is a NaN, the quotient should be a NaN. In general, whenever a NaN participates in a floating-point operation, the result is another NaN.\n\nAnother approach to writing a zero solver that doesn't require the user to input a domain is to use signals. The zero-finder could install a signal handler for floating-point exceptions. Then if was evaluated outside its domain and raised an exception, control would be returned to the zero solver. The problem with this approach is that every language has a different method of handling signals (if it has a method at all), and so it has no hope of portability.\n\nIn IEEE 754, NaNs are often represented as floating-point numbers with the exponent e + 1 and nonzero significands. Implementations are free to put system-dependent information into the significand. Thus there is not a unique NaN, but rather a whole family of NaNs. When a NaN and an ordinary floating-point number are combined, the result should be the same as the NaN operand. Thus if the result of a long computation is a NaN, the system-dependent information in the significand will be the information that was generated when the first NaN in the computation was generated. Actually, there is a caveat to the last statement. If both operands are NaNs, then the result will be one of those NaNs, but it might not be the NaN that was generated first.\n\nJust as NaNs provide a way to continue a computation when expressions like 0/0 or are encountered, infinities provide a way to continue when an overflow occurs. This is much safer than simply returning the largest representable number. As an example, consider computing , when = 10, p = 3, and e = 98. If x = 3 1070 and y = 4 1070, then x2 will overflow, and be replaced by 9.99 1098. Similarly y2, and x2 + 2 will each overflow in turn, and be replaced by 9.99 1098. So the final result will be , which is drastically wrong: the correct answer is 5 1070. In IEEE arithmetic, the result of x2 is , as is y2, x2 + 2 and . So the final result is , which is safer than returning an ordinary floating-point number that is nowhere near the correct answer.17\n\nThe division of 0 by 0 results in a NaN. A nonzero number divided by 0, however, returns infinity: 1/0 = , -1/0 = - . The reason for the distinction is this: if ( ) 0 and ( ) 0 as x approaches some limit, then ( )/ ( ) could have any value. For example, when ( ) = sin and ( ) = , then ( )/ ( ) 1 as x 0. But when ( ) = 1 - cos , ( )/ ( ) 0. When thinking of 0/0 as the limiting situation of a quotient of two very small numbers, 0/0 could represent anything. Thus in the IEEE standard, 0/0 results in a NaN. But when > 0, ( ) , ( ) 0, then ( )/ ( ) , for any analytic functions f and g. If ( ) 0 for small x, then ( )/ ( ) - , otherwise the limit is + . So the IEEE standard defines /0 = , as long as 0. The sign of depends on the signs of and 0 in the usual way, so that -10/0 = - , and -10/-0 = . You can distinguish between getting because of overflow and getting because of division by zero by checking the status flags (which will be discussed in detail in section Flags). The overflow flag will be set in the first case, the division by zero flag in the second.\n\nThe rule for determining the result of an operation that has infinity as an operand is simple: replace infinity with a finite number x and take the limit as x . Thus 3/ = 0, because\n\nSimilarly, 4 - = - , and = . When the limit doesn't exist, the result is a NaN, so / will be a NaN (TABLE D-3 has additional examples). This agrees with the reasoning used to conclude that 0/0 should be a NaN.\n\nWhen a subexpression evaluates to a NaN, the value of the entire expression is also a NaN. In the case of however, the value of the expression might be an ordinary floating-point number because of rules like 1/ = 0. Here is a practical example that makes use of the rules for infinity arithmetic. Consider computing the function x/( 2 + 1). This is a bad formula, because not only will it overflow when x is larger than , but infinity arithmetic will give the wrong answer because it will yield 0, rather than a number near 1/ . However, x/( 2 + 1) can be rewritten as 1/( + -1). This improved expression will not overflow prematurely and because of infinity arithmetic will have the correct value when x = 0: 1/(0 + 0-1) = 1/(0 + ) = 1/ = 0. Without infinity arithmetic, the expression 1/( + -1) requires a test for x = 0, which not only adds extra instructions, but may also disrupt a pipeline. This example illustrates a general fact, namely that infinity arithmetic often avoids the need for special case checking; however, formulas need to be carefully inspected to make sure they do not have spurious behavior at infinity (as x/( 2 + 1) did).\n\nZero is represented by the exponent e - 1 and a zero significand. Since the sign bit can take on two different values, there are two zeros, +0 and -0. If a distinction were made when comparing +0 and -0, simple tests like would have very unpredictable behavior, depending on the sign of . Thus the IEEE standard defines comparison so that +0 = -0, rather than -0 < +0. Although it would be possible always to ignore the sign of zero, the IEEE standard does not do so. When a multiplication or division involves a signed zero, the usual sign rules apply in computing the sign of the answer. Thus 3 (+0) = +0, and +0/-3 = -0. If zero did not have a sign, then the relation 1/(1/ ) = would fail to hold when x = . The reason is that 1/- and 1/+ both result in 0, and 1/0 results in + , the sign information having been lost. One way to restore the identity 1/(1/ ) = is to only have one kind of infinity, however that would result in the disastrous consequence of losing the sign of an overflowed quantity.\n\nAnother example of the use of signed zero concerns underflow and functions that have a discontinuity at 0, such as log. In IEEE arithmetic, it is natural to define log 0 = - and log to be a NaN when x < 0. Suppose that x represents a small negative number that has underflowed to zero. Thanks to signed zero, x will be negative, so log can return a NaN. However, if there were no signed zero, the log function could not distinguish an underflowed negative number from 0, and would therefore have to return - . Another example of a function with a discontinuity at zero is the signum function, which returns the sign of a number.\n\nProbably the most interesting use of signed zero occurs in complex arithmetic. To take a simple example, consider the equation . This is certainly true when 0. If = -1, the obvious computation gives and . Thus, ! The problem can be traced to the fact that square root is multi-valued, and there is no way to select the values so that it is continuous in the entire complex plane. However, square root is continuous if a branch cut consisting of all negative real numbers is excluded from consideration. This leaves the problem of what to do for the negative real numbers, which are of the form - + i0, where x > 0. Signed zero provides a perfect way to resolve this problem. Numbers of the form x + (+0) have one sign and numbers of the form x + (-0) on the other side of the branch cut have the other sign . In fact, the natural formulas for computing will give these results.\n\nBack to . If =1 = -1 + 0, then\n\nand so , while . Thus IEEE arithmetic preserves this identity for all . Some more sophisticated examples are given by Kahan [1987]. Although distinguishing between +0 and -0 has advantages, it can occasionally be confusing. For example, signed zero destroys the relation x = 1/ = 1/ , which is false when x = +0 and y = -0. However, the IEEE committee decided that the advantages of utilizing the sign of zero outweighed the disadvantages.\n\nConsider normalized floating-point numbers with = 10, p = 3, and e = -98. The numbers x = 6.87 10-97 and y = 6.81 10-97 appear to be perfectly ordinary floating-point numbers, which are more than a factor of 10 larger than the smallest floating-point number 1.00 10-98. They have a strange property, however: x = 0 even though x ! The reason is that x - = .06 10 -97 = 6.0 10-99 is too small to be represented as a normalized number, and so must be flushed to zero. How important is it to preserve the property\n\nIt's very easy to imagine writing the code fragment, , and much later having a program fail due to a spurious division by zero. Tracking down bugs like this is frustrating and time consuming. On a more philosophical level, computer science textbooks often point out that even though it is currently impractical to prove large programs correct, designing programs with the idea of proving them often results in better code. For example, introducing invariants is quite useful, even if they aren't going to be used as part of a proof. Floating-point code is just like any other code: it helps to have provable facts on which to depend. For example, when analyzing formula (6), it was very helpful to know that x/2 < < 2 = - . Similarly, knowing that (10) is true makes writing reliable floating-point code easier. If it is only true for most numbers, it cannot be used to prove anything.\n\nThe IEEE standard uses denormalized18 numbers, which guarantee (10), as well as other useful relations. They are the most controversial part of the standard and probably accounted for the long delay in getting 754 approved. Most high performance hardware that claims to be IEEE compatible does not support denormalized numbers directly, but rather traps when consuming or producing denormals, and leaves it to software to simulate the IEEE standard.19 The idea behind denormalized numbers goes back to Goldberg [1967] and is very simple. When the exponent is e , the significand does not have to be normalized, so that when = 10, p = 3 and e = -98, 1.00 10-98 is no longer the smallest floating-point number, because 0.98 10-98 is also a floating-point number.\n\nThere is a small snag when = 2 and a hidden bit is being used, since a number with an exponent of e will always have a significand greater than or equal to 1.0 because of the implicit leading bit. The solution is similar to that used to represent 0, and is summarized in TABLE D-2. The exponent e is used to represent denormals. More formally, if the bits in the significand field are , , , , and the value of the exponent is e, then when e > e - 1, the number being represented is 1. 2e whereas when e = e - 1, the number being represented is 0. 2e + 1. The +1 in the exponent is needed because denormals have an exponent of e , not e - 1.\n\nRecall the example of = 10, p = 3, e = -98, x = 6.87 10-97 and y = 6.81 10-97 presented at the beginning of this section. With denormals, x - does not flush to zero but is instead represented by the denormalized number .6 10-98. This behavior is called gradual underflow. It is easy to verify that (10) always holds when using gradual underflow.\n\nFIGURE D-2 illustrates denormalized numbers. The top number line in the figure shows normalized floating-point numbers. Notice the gap between 0 and the smallest normalized number . If the result of a floating-point calculation falls into this gulf, it is flushed to zero. The bottom number line shows what happens when denormals are added to the set of floating-point numbers. The \"gulf\" is filled in, and when the result of a calculation is less than , it is represented by the nearest denormal. When denormalized numbers are added to the number line, the spacing between adjacent floating-point numbers varies in a regular way: adjacent spacings are either the same length or differ by a factor of . Without denormals, the \n\nspacing abruptly changes from to , which is a factor of , rather than the orderly change by a factor of . Because of this, many algorithms that can have large relative error for normalized numbers close to the underflow threshold are well-behaved in this range when gradual underflow is used.\n\nWithout gradual underflow, the simple expression x can have a very large relative error for normalized inputs, as was seen above for x = 6.87 10-97 and y = 6.81 10-97. Large relative errors can happen even without cancellation, as the following example shows [Demmel 1984]. Consider dividing two complex numbers, + and + . The obvious formula\n\nsuffers from the problem that if either component of the denominator + is larger than , the formula will overflow, even though the final result may be well within range. A better method of computing the quotients is to use Smith's formula:\n\nApplying Smith's formula to (2 10-98 + 10-98)/(4 10-98 + (2 10-98)) gives the correct answer of 0.5 with gradual underflow. It yields 0.4 with flush to zero, an error of 100 ulps. It is typical for denormalized numbers to guarantee error bounds for arguments all the way down to 1.0 x .\n\nWhen an exceptional condition like division by zero or overflow occurs in IEEE arithmetic, the default is to deliver a result and continue. Typical of the default results are NaN for 0/0 and , and for 1/0 and overflow. The preceding sections gave examples where proceeding from an exception with these default values was the reasonable thing to do. When any exception occurs, a status flag is also set. Implementations of the IEEE standard are required to provide users with a way to read and write the status flags. The flags are \"sticky\" in that once set, they remain set until explicitly cleared. Testing the flags is the only way to distinguish 1/0, which is a genuine infinity from an overflow.\n\nSometimes continuing execution in the face of exception conditions is not appropriate. The section Infinity gave the example of x/( 2 + 1). When x > , the denominator is infinite, resulting in a final answer of 0, which is totally wrong. Although for this formula the problem can be solved by rewriting it as 1/( + -1), rewriting may not always solve the problem. The IEEE standard strongly recommends that implementations allow trap handlers to be installed. Then when an exception occurs, the trap handler is called instead of setting the flag. The value returned by the trap handler will be used as the result of the operation. It is the responsibility of the trap handler to either clear or set the status flag; otherwise, the value of the flag is allowed to be undefined.\n\nThe IEEE standard divides exceptions into 5 classes: overflow, underflow, division by zero, invalid operation and inexact. There is a separate status flag for each class of exception. The meaning of the first three exceptions is self-evident. Invalid operation covers the situations listed in TABLE D-3, and any comparison that involves a NaN. The default result of an operation that causes an invalid exception is to return a NaN, but the converse is not true. When one of the operands to an operation is a NaN, the result is a NaN but no invalid exception is raised unless the operation also satisfies one of the conditions in TABLE D-3.20\n\n* is the exact result of the operation, = 192 for single precision, 1536 for double, and = 1.11 11 .\n\nThe inexact exception is raised when the result of a floating-point operation is not exact. In the = 10, p = 3 system, 3.5 4.2 = 14.7 is exact, but 3.5 4.3 = 15.0 is not exact (since 3.5 4.3 = 15.05), and raises an inexact exception. Binary to Decimal Conversion discusses an algorithm that uses the inexact exception. A summary of the behavior of all five exceptions is given in TABLE D-4.\n\nThere is an implementation issue connected with the fact that the inexact exception is raised so often. If floating-point hardware does not have flags of its own, but instead interrupts the operating system to signal a floating-point exception, the cost of inexact exceptions could be prohibitive. This cost can be avoided by having the status flags maintained by software. The first time an exception is raised, set the software flag for the appropriate class, and tell the floating-point hardware to mask off that class of exceptions. Then all further exceptions will run without interrupting the operating system. When a user resets that status flag, the hardware mask is re-enabled.\n\nOne obvious use for trap handlers is for backward compatibility. Old codes that expect to be aborted when exceptions occur can install a trap handler that aborts the process. This is especially useful for codes with a loop like . Since comparing a NaN to a number with <, , >, , or = (but not ) always returns false, this code will go into an infinite loop if ever becomes a NaN.\n\nThere is a more interesting use for trap handlers that comes up when computing products such as that could potentially overflow. One solution is to use logarithms, and compute exp instead. The problem with this approach is that it is less accurate, and that it costs more than the simple expression , even if there is no overflow. There is another solution using trap handlers called over/underflow counting that avoids both of these problems [Sterbenz 1974].\n\nThe idea is as follows. There is a global counter initialized to zero. Whenever the partial product overflows for some , the trap handler increments the counter by one and returns the overflowed quantity with the exponent wrapped around. In IEEE 754 single precision, e = 127, so if p = 1.45 2130, it will overflow and cause the trap handler to be called, which will wrap the exponent back into range, changing p to 1.45 2-62 (see below). Similarly, if p underflows, the counter would be decremented, and negative exponent would get wrapped around into a positive one. When all the multiplications are done, if the counter is zero then the final product is p . If the counter is positive, the product overflowed, if the counter is negative, it underflowed. If none of the partial products are out of range, the trap handler is never called and the computation incurs no extra cost. Even if there are over/underflows, the calculation is more accurate than if it had been computed with logarithms, because each p was computed from p using a full precision multiply. Barnett [1987] discusses a formula where the full accuracy of over/underflow counting turned up an error in earlier tables of that formula.\n\nIEEE 754 specifies that when an overflow or underflow trap handler is called, it is passed the wrapped-around result as an argument. The definition of wrapped-around for overflow is that the result is computed as if to infinite precision, then divided by 2 , and then rounded to the relevant precision. For underflow, the result is multiplied by 2 . The exponent is 192 for single precision and 1536 for double precision. This is why 1.45 x 2130 was transformed into 1.45 2-62 in the example above.\n\nIn the IEEE standard, rounding occurs whenever an operation has a result that is not exact, since (with the exception of binary decimal conversion) each operation is computed exactly and then rounded. By default, rounding means round toward nearest. The standard requires that three other rounding modes be provided, namely round toward 0, round toward + , and round toward - . When used with the convert to integer operation, round toward - causes the convert to become the floor function, while round toward + is ceiling. The rounding mode affects overflow, because when round toward 0 or round toward - is in effect, an overflow of positive magnitude causes the default result to be the largest representable number, not + . Similarly, overflows of negative magnitude will produce the largest negative number when round toward + or round toward 0 is in effect.\n\nOne application of rounding modes occurs in interval arithmetic (another is mentioned in Binary to Decimal Conversion). When using interval arithmetic, the sum of two numbers x and y is an interval , where is x rounded toward - , and is rounded toward + . The exact result of the addition is contained within the interval . Without rounding modes, interval arithmetic is usually implemented by computing and , where is machine epsilon.21 This results in overestimates for the size of the intervals. Since the result of an operation in interval arithmetic is an interval, in general the input to an operation will also be an interval. If two intervals , and , are added, the result is , where is with the rounding mode set to round toward - , and is with the rounding mode set to round toward + .\n\nWhen a floating-point calculation is performed using interval arithmetic, the final answer is an interval that contains the exact result of the calculation. This is not very helpful if the interval turns out to be large (as it often does), since the correct answer could be anywhere in that interval. Interval arithmetic makes more sense when used in conjunction with a multiple precision floating-point package. The calculation is first performed with some precision p. If interval arithmetic suggests that the final answer may be inaccurate, the computation is redone with higher and higher precisions until the final interval is a reasonable size.\n\nThe IEEE standard has a number of flags and modes. As discussed above, there is one status flag for each of the five exceptions: underflow, overflow, division by zero, invalid operation and inexact. There are four rounding modes: round toward nearest, round toward + , round toward 0, and round toward - . It is strongly recommended that there be an enable mode bit for each of the five exceptions. This section gives some simple examples of how these modes and flags can be put to good use. A more sophisticated example is discussed in the section Binary to Decimal Conversion.\n\nConsider writing a subroutine to compute xn, where is an integer. When > 0, a simple routine like while (n is even) {\n\nIf n < 0, then a more accurate way to compute xn is not to call but rather , because the first expression multiplies quantities each of which have a rounding error from the division (i.e., 1/ ). In the second expression these are exact (i.e., x), and the final division commits just one additional rounding error. Unfortunately, these is a slight snag in this strategy. If underflows, then either the underflow trap handler will be called, or else the underflow status flag will be set. This is incorrect, because if x-n underflows, then xn will either overflow or be in range.22 But since the IEEE standard gives the user access to all the flags, the subroutine can easily correct for this. It simply turns off the overflow and underflow trap enable bits and saves the overflow and underflow status bits. It then computes . If neither the overflow nor underflow status bit is set, it restores them together with the trap enable bits. If one of the status bits is set, it restores the flags and redoes the calculation using , which causes the correct exceptions to occur.\n\nAnother example of the use of flags occurs when computing arccos via the formula\n\nIf arctan( ) evaluates to /2, then arccos(-1) will correctly evaluate to 2 arctan( ) = , because of infinity arithmetic. However, there is a small snag, because the computation of (1 - )/(1 + ) will cause the divide by zero exception flag to be set, even though arccos(-1) is not exceptional. The solution to this problem is straightforward. Simply save the value of the divide by zero flag before computing arccos, and then restore its old value after the computation.\n\nThe design of almost every aspect of a computer system requires knowledge about floating-point. Computer architectures usually have floating-point instructions, compilers must generate those floating-point instructions, and the operating system must decide what to do when exception conditions are raised for those floating-point instructions. Computer system designers rarely get guidance from numerical analysis texts, which are typically aimed at users and writers of software, not at computer designers. As an example of how plausible design decisions can lead to unexpected behavior, consider the following BASIC program.\n\nWhen compiled and run using Borland's Turbo Basic on an IBM PC, the program prints ! This example will be analyzed in the next section\n\nIncidentally, some people think that the solution to such anomalies is never to compare floating-point numbers for equality, but instead to consider them equal if they are within some error bound . This is hardly a cure-all because it raises as many questions as it answers. What should the value of be? If < 0 and y > 0 are within , should they really be considered to be equal, even though they have different signs? Furthermore, the relation defined by this rule, ~ |a - | < , is not an equivalence relation because ~ and ~ does not imply that ~ .\n\nIt is quite common for an algorithm to require a short burst of higher precision in order to produce accurate results. One example occurs in the quadratic formula ( )/2 . As discussed in the section Proof of Theorem 4, when 2 4 , rounding error can contaminate up to half the digits in the roots computed with the quadratic formula. By performing the subcalculation of 2 - 4 in double precision, half the double precision bits of the root are lost, which means that all the single precision bits are preserved.\n\nThe computation of 2 - 4 in double precision when each of the quantities , , and are in single precision is easy if there is a multiplication instruction that takes two single precision numbers and produces a double precision result. In order to produce the exactly rounded product of two p-digit numbers, a multiplier needs to generate the entire 2 bits of product, although it may throw bits away as it proceeds. Thus, hardware to compute a double precision product from single precision operands will normally be only a little more expensive than a single precision multiplier, and much cheaper than a double precision multiplier. Despite this, modern instruction sets tend to provide only instructions that produce a result of the same precision as the operands.23\n\nIf an instruction that combines two single precision operands to produce a double precision product was only useful for the quadratic formula, it wouldn't be worth adding to an instruction set. However, this instruction has many other uses. Consider the problem of solving a system of linear equations,\n\nwhich can be written in matrix form as = , where\n\nSuppose that a solution x(1) is computed by some method, perhaps Gaussian elimination. There is a simple way to improve the accuracy of the result called iterative improvement. First compute\n\nand then solve the system\n\nNote that if x(1) is an exact solution, then is the zero vector, as is y. In general, the computation of and y will incur rounding error, so (1) - = ( (1) - ), where x is the (unknown) true solution. Then y (1) - , so an improved estimate for the solution is\n\nThe three steps (12), (13), and (14) can be repeated, replacing x(1) with x(2), and x(2) with x(3). This argument that x(i + 1) is more accurate than x(i) is only informal. For more information, see [Golub and Van Loan 1989].\n\nWhen performing iterative improvement, is a vector whose elements are the difference of nearby inexact floating-point numbers, and so can suffer from catastrophic cancellation. Thus iterative improvement is not very useful unless = (1) - is computed in double precision. Once again, this is a case of computing the product of two single precision numbers (A and x(1)), where the full double precision result is needed.\n\nTo summarize, instructions that multiply two floating-point numbers and return a product with twice the precision of the operands make a useful addition to a floating-point instruction set. Some of the implications of this for compilers are discussed in the next section.\n\nThe interaction of compilers and floating-point is discussed in Farnum [1988], and much of the discussion in this section is taken from that paper.\n\nIdeally, a language definition should define the semantics of the language precisely enough to prove statements about programs. While this is usually true for the integer part of a language, language definitions often have a large grey area when it comes to floating-point. Perhaps this is due to the fact that many language designers believe that nothing can be proven about floating-point, since it entails rounding error. If so, the previous sections have demonstrated the fallacy in this reasoning. This section discusses some common grey areas in language definitions, including suggestions about how to deal with them.\n\nRemarkably enough, some languages don't clearly specify that if is a floating-point variable (with say a value of ), then every occurrence of (say) must have the same value. For example Ada, which is based on Brown's model, seems to imply that floating-point arithmetic only has to satisfy Brown's axioms, and thus expressions can have one of many possible values. Thinking about floating-point in this fuzzy way stands in sharp contrast to the IEEE model, where the result of each floating-point operation is precisely defined. In the IEEE model, we can prove that evaluates to (Theorem 7). In Brown's model, we cannot.\n\nAnother ambiguity in most language definitions concerns what happens on overflow, underflow and other exceptions. The IEEE standard precisely specifies the behavior of exceptions, and so languages that use the standard as a model can avoid any ambiguity on this point.\n\nAnother grey area concerns the interpretation of parentheses. Due to roundoff errors, the associative laws of algebra do not necessarily hold for floating-point numbers. For example, the expression has a totally different answer than when x = 1030, y = -1030 and = 1 (it is 1 in the former case, 0 in the latter). The importance of preserving parentheses cannot be overemphasized. The algorithms presented in theorems 3, 4 and 6 all depend on it. For example, in Theorem 6, the formula x = - ( - ) would reduce to x = if it weren't for parentheses, thereby destroying the entire algorithm. A language definition that does not require parentheses to be honored is useless for floating-point calculations.\n\nSubexpression evaluation is imprecisely defined in many languages. Suppose that is double precision, but and are single precision. Then in the expression is the product performed in single or double precision? Another example: in where and are integers, is the division an integer operation or a floating-point one? There are two ways to deal with this problem, neither of which is completely satisfactory. The first is to require that all variables in an expression have the same type. This is the simplest solution, but has some drawbacks. First of all, languages like Pascal that have subrange types allow mixing subrange variables with integer variables, so it is somewhat bizarre to prohibit mixing single and double precision variables. Another problem concerns constants. In the expression , most languages interpret 0.1 to be a single precision constant. Now suppose the programmer decides to change the declaration of all the floating-point variables from single to double precision. If 0.1 is still treated as a single precision constant, then there will be a compile time error. The programmer will have to hunt down and change every floating-point constant.\n\nThe second approach is to allow mixed expressions, in which case rules for subexpression evaluation must be provided. There are a number of guiding examples. The original definition of C required that every floating-point expression be computed in double precision [Kernighan and Ritchie 1978]. This leads to anomalies like the example at the beginning of this section. The expression is computed in double precision, but if is a single-precision variable, the quotient is rounded to single precision for storage. Since 3/7 is a repeating binary fraction, its computed value in double precision is different from its stored value in single precision. Thus the comparison = 3/7 fails. This suggests that computing every expression in the highest precision available is not a good rule.\n\nAnother guiding example is inner products. If the inner product has thousands of terms, the rounding error in the sum can become substantial. One way to reduce this rounding error is to accumulate the sums in double precision (this will be discussed in more detail in the section Optimizers). If is a double precision variable, and and are single precision arrays, then the inner product loop will look like . If the multiplication is done in single precision, than much of the advantage of double precision accumulation is lost, because the product is truncated to single precision just before being added to a double precision variable.\n\nA rule that covers both of the previous two examples is to compute an expression in the highest precision of any variable that occurs in that expression. Then will be computed entirely in single precision24 and will have the boolean value true, whereas will be computed in double precision, gaining the full advantage of double precision accumulation. However, this rule is too simplistic to cover all cases cleanly. If and are double precision variables, the expression contains a double precision variable, but performing the sum in double precision would be pointless, because both operands are single precision, as is the result.\n\nA more sophisticated subexpression evaluation rule is as follows. First assign each operation a tentative precision, which is the maximum of the precisions of its operands. This assignment has to be carried out from the leaves to the root of the expression tree. Then perform a second pass from the root to the leaves. In this pass, assign to each operation the maximum of the tentative precision and the precision expected by the parent. In the case of , every leaf is single precision, so all the operations are done in single precision. In the case of , the tentative precision of the multiply operation is single precision, but in the second pass it gets promoted to double precision, because its parent operation expects a double precision operand. And in , the addition is done in single precision. Farnum [1988] presents evidence that this algorithm in not difficult to implement.\n\nThe disadvantage of this rule is that the evaluation of a subexpression depends on the expression in which it is embedded. This can have some annoying consequences. For example, suppose you are debugging a program and want to know the value of a subexpression. You cannot simply type the subexpression to the debugger and ask it to be evaluated, because the value of the subexpression in the program depends on the expression it is embedded in. A final comment on subexpressions: since converting decimal constants to binary is an operation, the evaluation rule also affects the interpretation of decimal constants. This is especially important for constants like which are not exactly representable in binary.\n\nAnother potential grey area occurs when a language includes exponentiation as one of its built-in operations. Unlike the basic arithmetic operations, the value of exponentiation is not always obvious [Kahan and Coonen 1982]. If is the exponentiation operator, then certainly has the value -27. However, is problematical. If the operator checks for integer powers, it would compute as -3.03 = -27. On the other hand, if the formula xy = eylogx is used to define for real arguments, then depending on the log function, the result could be a NaN (using the natural definition of log( ) = when x < 0). If the FORTRAN function is used however, then the answer will be -27, because the ANSI FORTRAN standard defines to be + log 3 [ANSI 1978]. The programming language Ada avoids this problem by only defining exponentiation for integer powers, while ANSI FORTRAN prohibits raising a negative number to a real power.\n\nIn fact, the FORTRAN standard says that\n\nUnfortunately, with the introduction of by the IEEE standard, the meaning of not mathematically defined is no longer totally clear cut. One definition might be to use the method shown in section Infinity. For example, to determine the value of b, consider non-constant analytic functions and with the property that ( ) and ( ) as x 0. If ( )g(x) always approaches the same limit, then this should be the value of b. This definition would set 2 = which seems quite reasonable. In the case of 1.0 , when ( ) = 1 and ( ) = 1/ the limit approaches 1, but when ( ) = 1 - and ( ) = 1/ the limit is e-1. So 1.0 , should be a NaN. In the case of 00, ( )g(x) = eg(x)log f(x). Since and are analytic and take on the value 0 at 0, ( ) = 1 + 2 + and ( ) = 1 + 2 + . Thus lim ( ) log ( ) = lim log( ( + + )) = lim log( ) = 0. So ( )g(x) e0 = 1 for all and , which means that 00 = 1.25 26 Using this definition would unambiguously define the exponential function for all arguments, and in particular would define to be -27.\n\nThe section The IEEE Standard,\" discussed many of the features of the IEEE standard. However, the IEEE standard says nothing about how these features are to be accessed from a programming language. Thus, there is usually a mismatch between floating-point hardware that supports the standard and programming languages like C, Pascal or FORTRAN. Some of the IEEE capabilities can be accessed through a library of subroutine calls. For example the IEEE standard requires that square root be exactly rounded, and the square root function is often implemented directly in hardware. This functionality is easily accessed via a library square root routine. However, other aspects of the standard are not so easily implemented as subroutines. For example, most computer languages specify at most two floating-point types, while the IEEE standard has four different precisions (although the recommended configurations are single plus single-extended or single, double, and double-extended). Infinity provides another example. Constants to represent could be supplied by a subroutine. But that might make them unusable in places that require constant expressions, such as the initializer of a constant variable.\n\nA more subtle situation is manipulating the state associated with a computation, where the state consists of the rounding modes, trap enable bits, trap handlers and exception flags. One approach is to provide subroutines for reading and writing the state. In addition, a single call that can atomically set a new value and return the old value is often useful. As the examples in the section Flags show, a very common pattern of modifying IEEE state is to change it only within the scope of a block or subroutine. Thus the burden is on the programmer to find each exit from the block, and make sure the state is restored. Language support for setting the state precisely in the scope of a block would be very useful here. Modula-3 is one language that implements this idea for trap handlers [Nelson 1991].\n\nThere are a number of minor points that need to be considered when implementing the IEEE standard in a language. Since x - = +0 for all x,27 (+0) - (+0) = +0. However, -(+0) = -0, thus - should not be defined as 0 - x. The introduction of NaNs can be confusing, because a NaN is never equal to any other number (including another NaN), so x = is no longer always true. In fact, the expression x is the simplest way to test for a NaN if the IEEE recommended function is not provided. Furthermore, NaNs are unordered with respect to all other numbers, so x cannot be defined as not x > . Since the introduction of NaNs causes floating-point numbers to become partially ordered, a function that returns one of <, =, >, or can make it easier for the programmer to deal with comparisons.\n\nAlthough the IEEE standard defines the basic floating-point operations to return a NaN if any operand is a NaN, this might not always be the best definition for compound operations. For example when computing the appropriate scale factor to use in plotting a graph, the maximum of a set of values must be computed. In this case it makes sense for the max operation to simply ignore NaNs.\n\nFinally, rounding can be a problem. The IEEE standard defines rounding very precisely, and it depends on the current value of the rounding modes. This sometimes conflicts with the definition of implicit rounding in type conversions or the explicit function in languages. This means that programs which wish to use IEEE rounding can't use the natural language primitives, and conversely the language primitives will be inefficient to implement on the ever increasing number of IEEE machines.\n\nCompiler texts tend to ignore the subject of floating-point. For example Aho et al. [1986] mentions replacing with , leading the reader to assume that should be replaced by . However, these two expressions do not have the same semantics on a binary machine, because 0.1 cannot be represented exactly in binary. This textbook also suggests replacing by , even though we have seen that these two expressions can have quite different values when y z. Although it does qualify the statement that any algebraic identity can be used when optimizing code by noting that optimizers should not violate the language definition, it leaves the impression that floating-point semantics are not very important. Whether or not the language standard specifies that parenthesis must be honored, can have a totally different answer than , as discussed above. There is a problem closely related to preserving parentheses that is illustrated by the following code\n\nThis is designed to give an estimate for machine epsilon. If an optimizing compiler notices that + 1 > 1 > 0, the program will be changed completely. Instead of computing the smallest number x such that 1 is still greater than x (x ), it will compute the largest number x for which x/2 is rounded to 0 (x ). Avoiding this kind of \"optimization\" is so important that it is worth presenting one more very useful algorithm that is totally ruined by it.\n\nMany problems, such as numerical integration and the numerical solution of differential equations involve computing sums with many terms. Because each addition can potentially introduce an error as large as .5 ulp, a sum involving thousands of terms can have quite a bit of rounding error. A simple way to correct for this is to store the partial summand in a double precision variable and to perform each addition using double precision. If the calculation is being done in single precision, performing the sum in double precision is easy on most computer systems. However, if the calculation is already being done in double precision, doubling the precision is not so simple. One method that is sometimes advocated is to sort the numbers and add them from smallest to largest. However, there is a much more efficient method which dramatically improves the accuracy of sums, namely\n\nUsing the naive formula , the computed sum is equal to where | | < ( - ) . Comparing this with the error in the Kahan summation formula shows a dramatic improvement. Each summand is perturbed by only 2 , instead of perturbations as large as in the simple formula. Details are in, Errors In Summation.\n\nAn optimizer that believed floating-point arithmetic obeyed the laws of algebra would conclude that = [ - ] - = [( + )- ] - = 0, rendering the algorithm completely useless. These examples can be summarized by saying that optimizers should be extremely cautious when applying algebraic identities that hold for the mathematical real numbers to expressions involving floating-point variables.\n\nAnother way that optimizers can change the semantics of floating-point code involves constants. In the expression , there is an implicit decimal to binary conversion operation that converts the decimal number to a binary constant. Because this constant cannot be represented exactly in binary, the inexact exception should be raised. In addition, the underflow flag should to be set if the expression is evaluated in single precision. Since the constant is inexact, its exact conversion to binary depends on the current value of the IEEE rounding modes. Thus an optimizer that converts to binary at compile time would be changing the semantics of the program. However, constants like 27.5 which are exactly representable in the smallest available precision can be safely converted at compile time, since they are always exact, cannot raise any exception, and are unaffected by the rounding modes. Constants that are intended to be converted at compile time should be done with a constant declaration, such as .\n\nCommon subexpression elimination is another example of an optimization that can change floating-point semantics, as illustrated by the following code\n\nAlthough can appear to be a common subexpression, it is not because the rounding mode is different at the two evaluation sites. Three final examples: x = cannot be replaced by the boolean constant , because it fails when x is a NaN; - = 0 - fails for x = +0; and x < is not the opposite of x , because NaNs are neither greater than nor less than ordinary floating-point numbers.\n\nDespite these examples, there are useful optimizations that can be done on floating-point code. First of all, there are algebraic identities that are valid for floating-point numbers. Some examples in IEEE arithmetic are x + = + , 2 = + , 1 = , and 0.5 = /2. However, even these simple identities can fail on a few machines such as CDC and Cray supercomputers. Instruction scheduling and in-line procedure substitution are two other potentially useful optimizations.28\n\nAs a final example, consider the expression , where and are single precision variables, and is double precision. On machines that have an instruction that multiplies two single precision numbers to produce a double precision number, can get mapped to that instruction, rather than compiled to a series of instructions that convert the operands to double and then perform a double to double precision multiply.\n\nSome compiler writers view restrictions which prohibit converting ( + ) + to + ( + ) as irrelevant, of interest only to programmers who use unportable tricks. Perhaps they have in mind that floating-point numbers model real numbers and should obey the same laws that real numbers do. The problem with real number semantics is that they are extremely expensive to implement. Every time two bit numbers are multiplied, the product will have 2 bits. Every time two bit numbers with widely spaced exponents are added, the number of bits in the sum is n + the space between the exponents. The sum could have up to (emax - emin) + n bits, or roughly 2 emax + n bits. An algorithm that involves thousands of operations (such as solving a linear system) will soon be operating on numbers with many significant bits, and be hopelessly slow. The implementation of library functions such as sin and cos is even more difficult, because the value of these transcendental functions aren't rational numbers. Exact integer arithmetic is often provided by lisp systems and is handy for some problems. However, exact floating-point arithmetic is rarely useful.\n\nThe fact is that there are useful algorithms (like the Kahan summation formula) that exploit the fact that ( + ) + + ( + ), and work whenever the bound\n\nholds (as well as similar bounds for -, and /). Since these bounds hold for almost all commercial hardware, it would be foolish for numerical programmers to ignore such algorithms, and it would be irresponsible for compiler writers to destroy these algorithms by pretending that floating-point variables have real number semantics.\n\nThe topics discussed up to now have primarily concerned systems implications of accuracy and precision. Trap handlers also raise some interesting systems issues. The IEEE standard strongly recommends that users be able to specify a trap handler for each of the five classes of exceptions, and the section Trap Handlers, gave some applications of user defined trap handlers. In the case of invalid operation and division by zero exceptions, the handler should be provided with the operands, otherwise, with the exactly rounded result. Depending on the programming language being used, the trap handler might be able to access other variables in the program as well. For all exceptions, the trap handler must be able to identify what operation was being performed and the precision of its destination.\n\nThe IEEE standard assumes that operations are conceptually serial and that when an interrupt occurs, it is possible to identify the operation and its operands. On machines which have pipelining or multiple arithmetic units, when an exception occurs, it may not be enough to simply have the trap handler examine the program counter. Hardware support for identifying exactly which operation trapped may be necessary.\n\nAnother problem is illustrated by the following program fragment.\n\nSuppose the second multiply raises an exception, and the trap handler wants to use the value of . On hardware that can do an add and multiply in parallel, an optimizer would probably move the addition operation ahead of the second multiply, so that the add can proceed in parallel with the first multiply. Thus when the second multiply traps, has already been executed, potentially changing the result of . It would not be reasonable for a compiler to avoid this kind of optimization, because every floating-point operation can potentially trap, and thus virtually all instruction scheduling optimizations would be eliminated. This problem can be avoided by prohibiting trap handlers from accessing any variables of the program directly. Instead, the handler can be given the operands or result as an argument.\n\nBut there are still problems. In the fragment\n\nthe two instructions might well be executed in parallel. If the multiply traps, its argument could already have been overwritten by the addition, especially since addition is usually faster than multiply. Computer systems that support the IEEE standard must provide some way to save the value of , either in hardware or by having the compiler avoid such a situation in the first place.\n\nW. Kahan has proposed using presubstitution instead of trap handlers to avoid these problems. In this method, the user specifies an exception and the value he wants to be used as the result when the exception occurs. As an example, suppose that in code for computing (sin / , the user decides that x = 0 is so rare that it would improve performance to avoid a test for x = 0, and instead handle this case when a 0/0 trap occurs. Using IEEE trap handlers, the user would write a handler that returns a value of 1 and install it before computing sin / . Using presubstitution, the user would specify that when an invalid operation occurs, the value 1 should be used. Kahan calls this presubstitution, because the value to be used must be specified before the exception occurs. When using trap handlers, the value to be returned can be computed when the trap occurs.\n\nThe advantage of presubstitution is that it has a straightforward hardware implementation.29 As soon as the type of exception has been determined, it can be used to index a table which contains the desired result of the operation. Although presubstitution has some attractive attributes, the widespread acceptance of the IEEE standard makes it unlikely to be widely implemented by hardware manufacturers.\n\nA number of claims have been made in this paper concerning properties of floating-point arithmetic. We now proceed to show that floating-point is not black magic, but rather is a straightforward subject whose claims can be verified mathematically. This section is divided into three parts. The first part presents an introduction to error analysis, and provides the details for the section Rounding Error. The second part explores binary to decimal conversion, filling in some gaps from the section The IEEE Standard. The third part discusses the Kahan summation formula, which was used as an example in the section Systems Aspects.\n\nIn the discussion of rounding error, it was stated that a single guard digit is enough to guarantee that addition and subtraction will always be accurate (Theorem 2). We now proceed to verify this fact. Theorem 2 has two parts, one for subtraction and one for addition. The part for subtraction is\n\nIf x and y are positive floating-point numbers in a format with parameters and p, and if subtraction is done with p + 1 digits (i.e. one guard digit), then the relative rounding error in the result is less than\n\nWhen = 2, the bound is exactly 2 , and this bound is achieved for x= 1 + 22 - p and y = 21 - p - 21 - 2p in the limit as p . When adding numbers of the same sign, a guard digit is not necessary to achieve good accuracy, as the following result shows.\n\nIf x 0 and y 0, then the relative error in computing x + y is at most 2 , even if no guard digits are used.\n\nThe sum is at least , so the relative error is less than\n\nIt is obvious that combining these two theorems gives Theorem 2. Theorem 2 gives the relative error for performing one operation. Comparing the rounding error of x2 - 2 and ( + ) ( - ) requires knowing the relative error of multiple operations. The relative error of is = [( ) - ( - )] / ( - ), which satisfies | | 2 . Or to write it another way\n\nAssuming that multiplication is performed by computing the exact product and then rounding, the relative error is at most .5 ulp, so\n\nfor any floating-point numbers and . Putting these three equations together (letting = and = ) gives\n\nSo the relative error incurred when computing ( - ) ( + ) is\n\nThis relative error is equal to + + + + + + , which is bounded by 5 + 8 2. In other words, the maximum relative error is about 5 rounding errors (since is a small number, 2 is almost negligible).\n\nA similar analysis of ( ) ( ) cannot result in a small value for the relative error, because when two nearby values of x and y are plugged into x2 - y2, the relative error will usually be quite large. Another way to see this is to try and duplicate the analysis that worked on ( ) ( ), yielding\n\nWhen x and y are nearby, the error term ( - )y2 can be as large as the result x2 - y2. These computations formally justify our claim that ( - ) ( + ) is more accurate than x2 - 2.\n\nWe next turn to an analysis of the formula for the area of a triangle. In order to estimate the maximum error that can occur when computing with (7), the following fact will be needed.\n\nWhen > 2, the hypothesis of Theorem 11 cannot be replaced by y/ x ; the stronger condition /2 2 is still necessary. The analysis of the error in ( - ) ( + ), immediately following the proof of Theorem 10, used the fact that the relative error in the basic operations of addition and subtraction is small (namely equations (19) and (20)). This is the most common kind of error analysis. However, analyzing formula (7) requires something more, namely Theorem 11, as the following proof will show.\n\nTheorem 12 certainly shows that there is no catastrophic cancellation in formula (7). So although it is not necessary to show formula (7) is numerically stable, it is satisfying to have a bound for the entire formula, which is what Theorem 3 of Cancellation gives.\n\nTo make the heuristic explanation immediately following the statement of Theorem 4 precise, the next theorem describes just how closely ( ) approximates a constant.\n\nwhere | | and | | . To estimate ( ), use the mean value theorem, which says that\n\nAn interesting example of error analysis using formulas (19), (20), and (21) occurs in the quadratic formula . The section Cancellation, explained how rewriting the equation will eliminate the potential cancellation caused by the operation. But there is another potential cancellation that can occur when computing = - 4 . This one cannot be eliminated by a simple rearrangement of the formula. Roughly speaking, when 2 4 , rounding error can contaminate up to half the digits in the roots computed with the quadratic formula. Here is an informal proof (another approach to estimating the error in the quadratic formula appears in Kahan [1972]).\n\n2 4ac, rounding error can contaminate up to half the digits in the roots computed with the quadratic formula .\n\nProof: Write ( b) (4 ) = ( 2(1 + ) - 4 (1 + )) (1 + ), where | | . 30 Using = 2 - 4 , this can be rewritten as ( (1 + ) - 4 ( - )) (1 + ). To get an estimate for the size of this error, ignore second order terms in , in which case the absolute error is ( + ) - 4ac , where | | = | - | 2 . Since , the first term ( + ) can be ignored. To estimate the second term, use the fact that 2 + + = ( - ) ( - ), so = . Since 2 4 , then , so the second error term is . Thus the computed value of is\n\nso the absolute error in a is about . Since -p, , and thus the absolute error of destroys the bottom half of the bits of the roots r . In other words, since the calculation of the roots involves computing with , and this expression does not have meaningful bits in the position corresponding to the lower order half of , then the lower order bits of cannot be meaningful.\n\nFinally, we turn to the proof of Theorem 6. It is based on the following fact, which is proven in the section Theorem 14 and Theorem 8.\n\nTheorem 6 gives a way to express the product of two working precision numbers exactly as a sum. There is a companion formula for expressing a sum exactly. If | | | | then x + = ( ) + ( ( )) [Dekker 1971; Knuth 1981, Theorem C in section 4.2.2]. However, when using exactly rounded operations, this formula is only true for = 2, and not for = 10 as the example x = .99998, y = .99997 shows.\n\nSince single precision has p = 24, and 224 < 108, you might expect that converting a binary number to 8 decimal digits would be sufficient to recover the original binary number. However, this is not the case.\n\nThe same argument applied to double precision shows that 17 decimal digits are required to recover a double precision number.\n\nBinary-decimal conversion also provides another example of the use of flags. Recall from the section Precision, that to recover a binary number from its decimal expansion, the decimal to binary conversion must be computed exactly. That conversion is performed by multiplying the quantities and 10|P| (which are both exact if p < 13) in single-extended precision and then rounding this to single precision (or dividing if p < 0; both cases are similar). Of course the computation of 10|P| cannot be exact; it is the combined operation round( 10|P|) that must be exact, where the rounding is from single-extended to single precision. To see why it might fail to be exact, take the simple case of = 10, p = 2 for single, and p = 3 for single-extended. If the product is to be 12.51, then this would be rounded to 12.5 as part of the single-extended multiply operation. Rounding to single precision would give 12. But that answer is not correct, because rounding the product to single precision should give 13. The error is due to double rounding.\n\nBy using the IEEE flags, double rounding can be avoided as follows. Save the current value of the inexact flag, and then reset it. Set the rounding mode to round-to-zero. Then perform the multiplication 10|P|. Store the new value of the inexact flag in , and restore the rounding mode and inexact flag. If is 0, then 10|P| is exact, so round( 10|P|) will be correct down to the last bit. If is 1, then some digits were truncated, since round-to-zero always truncates. The significand of the product will look like 1 . A double rounding error may occur if = 10 0. A simple way to account for both cases is to perform a logical of with . Then round( 10|P|) will be computed correctly in all cases.\n\nThe section Optimizers, mentioned the problem of accurately computing very long sums. The simplest approach to improving accuracy is to double the precision. To get a rough estimate of how much doubling the precision improves the accuracy of a sum, let = , = , = - 1 . Then = (1 + ) ( + ), where , and ignoring second order terms in gives\n\nThe first equality of (31) shows that the computed value of is the same as if an exact summation was performed on perturbed values of x . The first term x is perturbed by , the last term x by only . The second equality in (31) shows that error term is bounded by . Doubling the precision has the effect of squaring . If the sum is being done in an IEEE double precision format, 1/ 1016, so that for any reasonable value of . Thus, doubling the precision takes the maximum perturbation of and changes it to . Thus the 2 error bound for the Kahan summation formula (Theorem 8) is not as good as using double precision, even though it is much better than single precision.\n\nFor an intuitive explanation of why the Kahan summation formula works, consider the following diagram of the procedure.\n\nEach time a summand is added, there is a correction factor which will be applied on the next loop. So first subtract the correction computed in the previous loop from , giving the corrected summand Y. Then add this summand to the running sum . The low order bits of Y (namely Y ) are lost in the sum. Next compute the high order bits of Y by computing - . When Y is subtracted from this, the low order bits of Y will be recovered. These are the bits that were lost in the first sum in the diagram. They become the correction factor for the next loop. A formal proof of Theorem 8, taken from Knuth [1981] page 572, appears in the section Theorem 14 and Theorem 8.\"\n\nIt is not uncommon for computer system designers to neglect the parts of a system related to floating-point. This is probably due to the fact that floating-point is given very little (if any) attention in the computer science curriculum. This in turn has caused the apparently widespread belief that floating-point is not a quantifiable subject, and so there is little point in fussing over the details of hardware and software that deal with it.\n\nThis paper has demonstrated that it is possible to reason rigorously about floating-point. For example, floating-point algorithms involving cancellation can be proven to have small relative errors if the underlying hardware has a guard digit, and there is an efficient algorithm for binary-decimal conversion that can be proven to be invertible, provided that extended precision is supported. The task of constructing reliable floating-point software is made much easier when the underlying computer system is supportive of floating-point. In addition to the two examples just mentioned (guard digits and extended precision), the section Systems Aspects of this paper has examples ranging from instruction set design to compiler optimization illustrating how to better support floating-point.\n\nThe increasing acceptance of the IEEE floating-point standard means that codes that utilize features of the standard are becoming ever more portable. The section The IEEE Standard, gave numerous examples illustrating how the features of the IEEE standard can be used in writing practical floating-point codes.\n\nThis article was inspired by a course given by W. Kahan at Sun Microsystems from May through July of 1988, which was very ably organized by David Hough of Sun. My hope is to enable others to learn about the interaction of floating-point and computer systems without having to get up in time to attend 8:00 a.m. lectures. Thanks are due to Kahan and many of my colleagues at Xerox PARC (especially John Gilbert) for reading drafts of this paper and providing many useful comments. Reviews from Paul Hilfinger and an anonymous referee also helped improve the presentation.\n\nBrown, W. S. 1981. A Simple but Realistic Model of Floating-Point Computation, ACM Trans. on Math. Software 7(4), pp. 445-480.\n\nCody, W. J et. al. 1984. A Proposed Radix- and Word-length-independent Standard for Floating-point Arithmetic, IEEE Micro 4(4), pp. 86-100.\n\nCody, W. J. 1988. Floating-Point Standards -- Theory and Practice, in \"Reliability in Computing: the role of interval methods in scientific computing\", ed. by Ramon E. Moore, pp. 99-107, Academic Press, Boston, MA.\n\nCoonen, Jerome 1984. Contributions to a Proposed Standard for Binary Floating-Point Arithmetic, PhD Thesis, Univ. of California, Berkeley.\n\nDekker, T. J. 1971. A Floating-Point Technique for Extending the Available Precision, Numer. Math. 18(3), pp. 224-242.\n\nDemmel, James 1984. Underflow and the Reliability of Numerical Software, SIAM J. Sci. Stat. Comput. 5(4), pp. 887-919.\n\nForsythe, G. E. and Moler, C. B. 1967. Computer Solution of Linear Algebraic Systems, Prentice-Hall, Englewood Cliffs, NJ.\n\nGoldberg, I. Bennett 1967. 27 Bits Are Not Enough for 8-Digit Accuracy, Comm. of the ACM. 10(2), pp 105-106.\n\nGoldberg, David 1990. Computer Arithmetic, in \"Computer Architecture: A Quantitative Approach\", by David Patterson and John L. Hennessy, Appendix A, Morgan Kaufmann, Los Altos, CA.\n\nKahan, W. 1987. Branch Cuts for Complex Elementary Functions, in \"The State of the Art in Numerical Analysis\", ed. by M.J.D. Powell and A. Iserles (Univ of Birmingham, England), Chapter 7, Oxford University Press, New York.\n\nKahan, W. and Coonen, Jerome T. 1982. The Near Orthogonality of Syntax, Semantics, and Diagnostics in Numerical Programming Environments, in \"The Relationship Between Numerical Computation And Programming Languages\", ed. by J. K. Reid, pp. 103-115, North-Holland, Amsterdam.\n\nKahan, W. and LeBlanc, E. 1985. Anomalies in the IBM Acrith Package, Proc. 7th IEEE Symposium on Computer Arithmetic (Urbana, Illinois), pp. 322-331.\n\nKernighan, Brian W. and Ritchie, Dennis M. 1978. The C Programming Language, Prentice-Hall, Englewood Cliffs, NJ.\n\nKirchner, R. and Kulisch, U. 1987. Arithmetic for Vector Processors, Proc. 8th IEEE Symposium on Computer Arithmetic (Como, Italy), pp. 256-269.\n\nKnuth, Donald E., 1981. The Art of Computer Programming, Volume II, Second Edition, Addison-Wesley, Reading, MA.\n\nKulisch, U. W., and Miranker, W. L. 1986. The Arithmetic of the Digital Computer: A New Approach, SIAM Review 28(1), pp 1-36.\n\nReiser, John F. and Knuth, Donald E. 1975. Evading the Drift in Floating-point Addition, Information Processing Letters 3(3), pp 84-87.\n\nWalther, J. S., 1971. A unified algorithm for elementary functions, Proceedings of the AFIP Spring Joint Computer Conf. 38, pp. 379-385.\n\nThis section contains two of the more technical proofs that were omitted from the text.\n\nFinally, what is wanted is the coefficient of x in . To get this value, let x = 0, let all the Greek letters with subscripts of + 1 equal 0, and compute . Then = - , and the coefficient of x in is less than the coefficient in , which is = 1 + - + (4 + 2) 2 = (1 + 2 + ( 2)).\n\nThe preceding paper has shown that floating-point arithmetic must be implemented carefully, since programmers may depend on its properties for the correctness and accuracy of their programs. In particular, the IEEE standard requires a careful implementation, and it is possible to write useful programs that work correctly and deliver accurate results only on systems that conform to the standard. The reader might be tempted to conclude that such programs should be portable to all IEEE systems. Indeed, portable software would be easier to write if the remark \"When a program is moved between two machines and both support IEEE arithmetic, then if any intermediate result differs, it must be because of software bugs, not from differences in arithmetic,\" were true.\n\nUnfortunately, the IEEE standard does not guarantee that the same program will deliver identical results on all conforming systems. Most programs will actually produce different results on different systems for a variety of reasons. For one, most programs involve the conversion of numbers between decimal and binary formats, and the IEEE standard does not completely specify the accuracy with which such conversions must be performed. For another, many programs use elementary functions supplied by a system library, and the standard doesn't specify these functions at all. Of course, most programmers know that these features lie beyond the scope of the IEEE standard.\n\nMany programmers may not realize that even a program that uses only the numeric formats and operations prescribed by the IEEE standard can compute different results on different systems. In fact, the authors of the standard intended to allow different implementations to obtain different results. Their intent is evident in the definition of the term destination in the IEEE 754 standard: \"A destination may be either explicitly designated by the user or implicitly supplied by the system (for example, intermediate results in subexpressions or arguments for procedures). Some languages place the results of intermediate calculations in destinations beyond the user's control. Nonetheless, this standard defines the result of an operation in terms of that destination's format and the operands' values.\" (IEEE 754-1985, p. 7) In other words, the IEEE standard requires that each result be rounded correctly to the precision of the destination into which it will be placed, but the standard does not require that the precision of that destination be determined by a user's program. Thus, different systems may deliver their results to destinations with different precisions, causing the same program to produce different results (sometimes dramatically so), even though those systems all conform to the standard.\n\nSeveral of the examples in the preceding paper depend on some knowledge of the way floating-point arithmetic is rounded. In order to rely on examples such as these, a programmer must be able to predict how a program will be interpreted, and in particular, on an IEEE system, what the precision of the destination of each arithmetic operation may be. Alas, the loophole in the IEEE standard's definition of destination undermines the programmer's ability to know how a program will be interpreted. Consequently, several of the examples given above, when implemented as apparently portable programs in a high-level language, may not work correctly on IEEE systems that normally deliver results to destinations with a different precision than the programmer expects. Other examples may work, but proving that they work may lie beyond the average programmer's ability.\n\nIn this section, we classify existing implementations of IEEE 754 arithmetic based on the precisions of the destination formats they normally use. We then review some examples from the paper to show that delivering results in a wider precision than a program expects can cause it to compute wrong results even though it is provably correct when the expected precision is used. We also revisit one of the proofs in the paper to illustrate the intellectual effort required to cope with unexpected precision even when it doesn't invalidate our programs. These examples show that despite all that the IEEE standard prescribes, the differences it allows among different implementations can prevent us from writing portable, efficient numerical software whose behavior we can accurately predict. To develop such software, then, we must first create programming languages and environments that limit the variability the IEEE standard permits and allow programmers to express the floating-point semantics upon which their programs depend.\n\nCurrent implementations of IEEE 754 arithmetic can be divided into two groups distinguished by the degree to which they support different floating-point formats in hardware. Extended-based systems, exemplified by the Intel x86 family of processors, provide full support for an extended double precision format but only partial support for single and double precision: they provide instructions to load or store data in single and double precision, converting it on-the-fly to or from the extended double format, and they provide special modes (not the default) in which the results of arithmetic operations are rounded to single or double precision even though they are kept in registers in extended double format. (Motorola 68000 series processors round results to both the precision and range of the single or double formats in these modes. Intel x86 and compatible processors round results to the precision of the single or double formats but retain the same range as the extended double format.) Single/double systems, including most RISC processors, provide full support for single and double precision formats but no support for an IEEE-compliant extended double precision format. (The IBM POWER architecture provides only partial support for single precision, but for the purpose of this section, we classify it as a single/double system.)\n\nTo see how a computation might behave differently on an extended-based system than on a single/double system, consider a C version of the example from the section Systems Aspects:\n\nHere the constants 3.0 and 7.0 are interpreted as double precision floating-point numbers, and the expression 3.0/7.0 inherits the data type. On a single/double system, the expression will be evaluated in double precision since that is the most efficient format to use. Thus, will be assigned the value 3.0/7.0 rounded correctly to double precision. In the next line, the expression 3.0/7.0 will again be evaluated in double precision, and of course the result will be equal to the value just assigned to , so the program will print \"Equal\" as expected.\n\nOn an extended-based system, even though the expression 3.0/7.0 has type , the quotient will be computed in a register in extended double format, and thus in the default mode, it will be rounded to extended double precision. When the resulting value is assigned to the variable , however, it may then be stored in memory, and since is declared , the value will be rounded to double precision. In the next line, the expression 3.0/7.0 may again be evaluated in extended precision yielding a result that differs from the double precision value stored in , causing the program to print \"Not equal\". Of course, other outcomes are possible, too: the compiler could decide to store and thus round the value of the expression 3.0/7.0 in the second line before comparing it with , or it could keep in a register in extended precision without storing it. An optimizing compiler might evaluate the expression 3.0/7.0 at compile time, perhaps in double precision or perhaps in extended double precision. (With one x86 compiler, the program prints \"Equal\" when compiled with optimization and \"Not Equal\" when compiled for debugging.) Finally, some compilers for extended-based systems automatically change the rounding precision mode to cause operations producing results in registers to round those results to single or double precision, albeit possibly with a wider range. Thus, on these systems, we can't predict the behavior of the program simply by reading its source code and applying a basic understanding of IEEE 754 arithmetic. Neither can we accuse the hardware or the compiler of failing to provide an IEEE 754 compliant environment; the hardware has delivered a correctly rounded result to each destination, as it is required to do, and the compiler has assigned some intermediate results to destinations that are beyond the user's control, as it is allowed to do.\n\nConventional wisdom maintains that extended-based systems must produce results that are at least as accurate, if not more accurate than those delivered on single/double systems, since the former always provide at least as much precision and often more than the latter. Trivial examples such as the C program above as well as more subtle programs based on the examples discussed below show that this wisdom is naive at best: some apparently portable programs, which are indeed portable across single/double systems, deliver incorrect results on extended-based systems precisely because the compiler and hardware conspire to occasionally provide more precision than the program expects.\n\nCurrent programming languages make it difficult for a program to specify the precision it expects. As the section Languages and Compilers mentions, many programming languages don't specify that each occurrence of an expression like in the same context should evaluate to the same value. Some languages, such as Ada, were influenced in this respect by variations among different arithmetics prior to the IEEE standard. More recently, languages like ANSI C have been influenced by standard-conforming extended-based systems. In fact, the ANSI C standard explicitly allows a compiler to evaluate a floating-point expression to a precision wider than that normally associated with its type. As a result, the value of the expression may vary in ways that depend on a variety of factors: whether the expression is immediately assigned to a variable or appears as a subexpression in a larger expression; whether the expression participates in a comparison; whether the expression is passed as an argument to a function, and if so, whether the argument is passed by value or by reference; the current precision mode; the level of optimization at which the program was compiled; the precision mode and expression evaluation method used by the compiler when the program was compiled; and so on.\n\nLanguage standards are not entirely to blame for the vagaries of expression evaluation. Extended-based systems run most efficiently when expressions are evaluated in extended precision registers whenever possible, yet values that must be stored are stored in the narrowest precision required. Constraining a language to require that evaluate to the same value everywhere would impose a performance penalty on those systems. Unfortunately, allowing those systems to evaluate differently in syntactically equivalent contexts imposes a penalty of its own on programmers of accurate numerical software by preventing them from relying on the syntax of their programs to express their intended semantics.\n\nDo real programs depend on the assumption that a given expression always evaluates to the same value? Recall the algorithm presented in Theorem 4 for computing ln(1 + x), written here in Fortran:\n\nOn an extended-based system, a compiler may evaluate the expression in the third line in extended precision and compare the result with . When the same expression is passed to the log function in the sixth line, however, the compiler may store its value in memory, rounding it to single precision. Thus, if is not so small that rounds to in extended precision but small enough that rounds to in single precision, then the value returned by will be zero instead of , and the relative error will be one--rather larger than 5 . Similarly, suppose the rest of the expression in the sixth line, including the reoccurrence of the subexpression , is evaluated in extended precision. In that case, if is small but not quite small enough that rounds to in single precision, then the value returned by can exceed the correct value by nearly as much as , and again the relative error can approach one. For a concrete example, take to be 2-24 + 2-47, so is the smallest single precision number such that rounds up to the next larger number, 1 + 2-23. Then is approximately 2-23. Because the denominator in the expression in the sixth line is evaluated in extended precision, it is computed exactly and delivers , so returns approximately 2-23, which is nearly twice as large as the exact value. (This actually happens with at least one compiler. When the preceding code is compiled by the Sun WorkShop Compilers 4.2.1 Fortran 77 compiler for x86 systems using the optimization flag, the generated code computes exactly as described. As a result, the function delivers zero for and for .)\n\nFor the algorithm of Theorem 4 to work correctly, the expression must be evaluated the same way each time it appears; the algorithm can fail on extended-based systems only when is evaluated to extended double precision in one instance and to single or double precision in another. Of course, since is a generic intrinsic function in Fortran, a compiler could evaluate the expression in extended precision throughout, computing its logarithm in the same precision, but evidently we cannot assume that the compiler will do so. (One can also imagine a similar example involving a user-defined function. In that case, a compiler could still keep the argument in extended precision even though the function returns a single precision result, but few if any existing Fortran compilers do this, either.) We might therefore attempt to ensure that is evaluated consistently by assigning it to a variable. Unfortunately, if we declare that variable , we may still be foiled by a compiler that substitutes a value kept in a register in extended precision for one appearance of the variable and a value stored in memory in single precision for another. Instead, we would need to declare the variable with a type that corresponds to the extended precision format. Standard FORTRAN 77 does not provide a way to do this, and while Fortran 95 offers the mechanism for describing various formats, it does not explicitly require implementations that evaluate expressions in extended precision to allow variables to be declared with that precision. In short, there is no portable way to write this program in standard Fortran that is guaranteed to prevent the expression from being evaluated in a way that invalidates our proof.\n\nThere are other examples that can malfunction on extended-based systems even when each subexpression is stored and thus rounded to the same precision. The cause is double-rounding. In the default precision mode, an extended-based system will initially round each result to extended double precision. If that result is then stored to double precision, it is rounded again. The combination of these two roundings can yield a value that is different than what would have been obtained by rounding the first result correctly to double precision. This can happen when the result as rounded to extended double precision is a \"halfway case\", i.e., it lies exactly halfway between two double precision numbers, so the second rounding is determined by the round-ties-to-even rule. If this second rounding rounds in the same direction as the first, the net rounding error will exceed half a unit in the last place. (Note, though, that double-rounding only affects double precision computations. One can prove that the sum, difference, product, or quotient of two p-bit numbers, or the square root of a p-bit number, rounded first to q bits and then to p bits gives the same value as if the result were rounded just once to p bits provided q 2p + 2. Thus, extended double precision is wide enough that single precision computations don't suffer double-rounding.)\n\nSome algorithms that depend on correct rounding can fail with double-rounding. In fact, even some algorithms that don't require correct rounding and work correctly on a variety of machines that don't conform to IEEE 754 can fail with double-rounding. The most useful of these are the portable algorithms for performing simulated multiple precision arithmetic mentioned in the section Exactly Rounded Operations. For example, the procedure described in Theorem 6 for splitting a floating-point number into high and low parts doesn't work correctly in double-rounding arithmetic: try to split the double precision number 252 + 3 226 - 1 into two parts each with at most 26 bits. When each operation is rounded correctly to double precision, the high order part is 252 + 227 and the low order part is 226 - 1, but when each operation is rounded first to extended double precision and then to double precision, the procedure produces a high order part of 252 + 228 and a low order part of -226 - 1. The latter number occupies 27 bits, so its square can't be computed exactly in double precision. Of course, it would still be possible to compute the square of this number in extended double precision, but the resulting algorithm would no longer be portable to single/double systems. Also, later steps in the multiple precision multiplication algorithm assume that all partial products have been computed in double precision. Handling a mixture of double and extended double variables correctly would make the implementation significantly more expensive.\n\nLikewise, portable algorithms for adding multiple precision numbers represented as arrays of double precision numbers can fail in double-rounding arithmetic. These algorithms typically rely on a technique similar to Kahan's summation formula. As the informal explanation of the summation formula given on Errors In Summation suggests, if and are floating-point variables with | | | | and we compute:\n\nthen in most arithmetics, recovers exactly the roundoff error that occurred in computing . This technique doesn't work in double-rounded arithmetic, however: if = 252 + 1 and = 1/2 - 2-54, then rounds first to 252 + 3/2 in extended double precision, and this value rounds to 252 + 2 in double precision by the round-ties-to-even rule; thus the net rounding error in computing is 1/2 + 2-54, which is not representable exactly in double precision and so can't be computed exactly by the expression shown above. Here again, it would be possible to recover the roundoff error by computing the sum in extended double precision, but then a program would have to do extra work to reduce the final outputs back to double precision, and double-rounding could afflict this process, too. For this reason, although portable programs for simulating multiple precision arithmetic by these methods work correctly and efficiently on a wide variety of machines, they do not work as advertised on extended-based systems.\n\nFinally, some algorithms that at first sight appear to depend on correct rounding may in fact work correctly with double-rounding. In these cases, the cost of coping with double-rounding lies not in the implementation but in the verification that the algorithm works as advertised. To illustrate, we prove the following variant of Theorem 7:\n\nAssume without loss that m > 0. Let q = m n. Scaling by powers of two, we can consider an equivalent setting in which 252 m < 253 and likewise for q, so that both m and q are integers whose least significant bits occupy the units place (i.e., ulp(m) = ulp(q) = 1). Before scaling, we assumed m < 252, so after scaling, m is an even integer. Also, because the scaled values of m and q satisfy m/2 < q < 2m, the corresponding value of n must have one of two forms depending on which of m or q is larger: if q < m, then evidently 1 < n < 2, and since n is a sum of two powers of two, n = 1 + 2-k for some k; similarly, if q > m, then 1/2 < n < 1, so n = 1/2 + 2-(k + 1). (As n is the sum of two powers of two, the closest possible value of n to one is n = 1 + 2-52. Because m/(1 + 2-52) is no larger than the next smaller double precision number less than m, we can't have q = m.)\n\nLet e denote the rounding error in computing q, so that q = m/n + e, and the computed value q n will be the (once or twice) rounded value of m + ne. Consider first the case in which each floating-point operation is rounded correctly to double precision. In this case, |e| < 1/2. If n has the form 1/2 + 2-(k + 1), then ne = nq - m is an integer multiple of 2-(k + 1) and |ne| < 1/4 + 2-(k + 2). This implies that |ne| 1/4. Recall that the difference between m and the next larger representable number is 1 and the difference between m and the next smaller representable number is either 1 if m > 252 or 1/2 if m = 252. Thus, as |ne| 1/4, m + ne will round to m. (Even if m = 252 and ne = -1/4, the product will round to m by the round-ties-to-even rule.) Similarly, if n has the form 1 + 2-k, then ne is an integer multiple of 2-k and |ne| < 1/2 + 2-(k + 1); this implies |ne| 1/2. We can't have m = 252 in this case because m is strictly greater than q, so m differs from its nearest representable neighbors by 1. Thus, as |ne| 1/2, again m + ne will round to m. (Even if |ne| = 1/2, the product will round to m by the round-ties-to-even rule because m is even.) This completes the proof for correctly rounded arithmetic.\n\nIn double-rounding arithmetic, it may still happen that q is the correctly rounded quotient (even though it was actually rounded twice), so |e| < 1/2 as above. In this case, we can appeal to the arguments of the previous paragraph provided we consider the fact that q n will be rounded twice. To account for this, note that the IEEE standard requires that an extended double format carry at least 64 significant bits, so that the numbers m 1/2 and m 1/4 are exactly representable in extended double precision. Thus, if n has the form 1/2 + 2-(k + 1), so that |ne| 1/4, then rounding m + ne to extended double precision must produce a result that differs from m by at most 1/4, and as noted above, this value will round to m in double precision. Similarly, if n has the form 1 + 2-k, so that |ne| 1/2, then rounding m + ne to extended double precision must produce a result that differs from m by at most 1/2, and this value will round to m in double precision. (Recall that m > 252 in this case.)\n\nFinally, we are left to consider cases in which q is not the correctly rounded quotient due to double-rounding. In these cases, we have |e| < 1/2 + 2-(d + 1) in the worst case, where d is the number of extra bits in the extended double format. (All existing extended-based systems support an extended double format with exactly 64 significant bits; for this format, d = 64 - 53 = 11.) Because double-rounding only produces an incorrectly rounded result when the second rounding is determined by the round-ties-to-even rule, q must be an even integer. Thus if n has the form 1/2 + 2-(k + 1), then ne = nq - m is an integer multiple of 2-k, and\n\nIf k d, this implies |ne| 1/4. If k > d, we have |ne| 1/4 + 2-(d + 2). In either case, the first rounding of the product will deliver a result that differs from m by at most 1/4, and by previous arguments, the second rounding will round to m. Similarly, if n has the form 1 + 2-k, then ne is an integer multiple of 2-(k - 1), and\n\nIf k d, this implies |ne| 1/2. If k > d, we have |ne| 1/2 + 2-(d + 1). In either case, the first rounding of the product will deliver a result that differs from m by at most 1/2, and again by previous arguments, the second rounding will round to m.\n\nThe preceding proof shows that the product can incur double-rounding only if the quotient does, and even then, it rounds to the correct result. The proof also shows that extending our reasoning to include the possibility of double-rounding can be challenging even for a program with only two floating-point operations. For a more complicated program, it may be impossible to systematically account for the effects of double-rounding, not to mention more general combinations of double and extended double precision computations.\n\nThe preceding examples should not be taken to suggest that extended precision per se is harmful. Many programs can benefit from extended precision when the programmer is able to use it selectively. Unfortunately, current programming languages do not provide sufficient means for a programmer to specify when and how extended precision should be used. To indicate what support is needed, we consider the ways in which we might want to manage the use of extended precision.\n\nIn a portable program that uses double precision as its nominal working precision, there are five ways we might want to control the use of a wider precision:\n• Compile to produce the fastest code, using extended precision where possible on extended-based systems. Clearly most numerical software does not require more of the arithmetic than that the relative error in each operation is bounded by the \"machine epsilon\". When data in memory are stored in double precision, the machine epsilon is usually taken to be the largest relative roundoff error in that precision, since the input data are (rightly or wrongly) assumed to have been rounded when they were entered and the results will likewise be rounded when they are stored. Thus, while computing some of the intermediate results in extended precision may yield a more accurate result, extended precision is not essential. In this case, we might prefer that the compiler use extended precision only when it will not appreciably slow the program and use double precision otherwise.\n• Use a format wider than double if it is reasonably fast and wide enough, otherwise resort to something else. Some computations can be performed more easily when extended precision is available, but they can also be carried out in double precision with only somewhat greater effort. Consider computing the Euclidean norm of a vector of double precision numbers. By computing the squares of the elements and accumulating their sum in an IEEE 754 extended double format with its wider exponent range, we can trivially avoid premature underflow or overflow for vectors of practical lengths. On extended-based systems, this is the fastest way to compute the norm. On single/double systems, an extended double format would have to be emulated in software (if one were supported at all), and such emulation would be much slower than simply using double precision, testing the exception flags to determine whether underflow or overflow occurred, and if so, repeating the computation with explicit scaling. Note that to support this use of extended precision, a language must provide both an indication of the widest available format that is reasonably fast, so that a program can choose which method to use, and environmental parameters that indicate the precision and range of each format, so that the program can verify that the widest fast format is wide enough (e.g., that it has wider range than double).\n• Use a format wider than double even if it has to be emulated in software. For more complicated programs than the Euclidean norm example, the programmer may simply wish to avoid the need to write two versions of the program and instead rely on extended precision even if it is slow. Again, the language must provide environmental parameters so that the program can determine the range and precision of the widest available format.\n• Don't use a wider precision; round results correctly to the precision of the double format, albeit possibly with extended range. For programs that are most easily written to depend on correctly rounded double precision arithmetic, including some of the examples mentioned above, a language must provide a way for the programmer to indicate that extended precision must not be used, even though intermediate results may be computed in registers with a wider exponent range than double. (Intermediate results computed in this way can still incur double-rounding if they underflow when stored to memory: if the result of an arithmetic operation is rounded first to 53 significant bits, then rounded again to fewer significant bits when it must be denormalized, the final result may differ from what would have been obtained by rounding just once to a denormalized number. Of course, this form of double-rounding is highly unlikely to affect any practical program adversely.)\n• Round results correctly to both the precision and range of the double format. This strict enforcement of double precision would be most useful for programs that test either numerical software or the arithmetic itself near the limits of both the range and precision of the double format. Such careful test programs tend to be difficult to write in a portable way; they become even more difficult (and error prone) when they must employ dummy subroutines and other tricks to force results to be rounded to a particular format. Thus, a programmer using an extended-based system to develop robust software that must be portable to all IEEE 754 implementations would quickly come to appreciate being able to emulate the arithmetic of single/double systems without extraordinary effort.\n\nNo current language supports all five of these options. In fact, few languages have attempted to give the programmer the ability to control the use of extended precision at all. One notable exception is the ISO/IEC 9899:1999 Programming Languages - C standard, the latest revision to the C language, which is now in the final stages of standardization.\n\nThe C99 standard allows an implementation to evaluate expressions in a format wider than that normally associated with their type, but the C99 standard recommends using one of only three expression evaluation methods. The three recommended methods are characterized by the extent to which expressions are \"promoted\" to wider formats, and the implementation is encouraged to identify which method it uses by defining the preprocessor macro : if is 0, each expression is evaluated in a format that corresponds to its type; if is 1, expressions are promoted to the format that corresponds to ; and if is 2, and expressions are promoted to the format that corresponds to . (An implementation is allowed to set to -1 to indicate that the expression evaluation method is indeterminable.) The C99 standard also requires that the header file define the types and , which are at least as wide as and , respectively, and are intended to match the types used to evaluate and expressions. For example, if is 2, both and are . Finally, the C99 standard requires that the header file define preprocessor macros that specify the range and precision of the formats corresponding to each floating-point type.\n\nThe combination of features required or recommended by the C99 standard supports some of the five options listed above but not all. For example, if an implementation maps the type to an extended double format and defines to be 2, the programmer can reasonably assume that extended precision is relatively fast, so programs like the Euclidean norm example can simply use intermediate variables of type (or ). On the other hand, the same implementation must keep anonymous expressions in extended precision even when they are stored in memory (e.g., when the compiler must spill floating-point registers), and it must store the results of expressions assigned to variables declared to convert them to double precision even if they could have been kept in registers. Thus, neither the nor the type can be compiled to produce the fastest code on current extended-based hardware.\n\nLikewise, the C99 standard provides solutions to some of the problems illustrated by the examples in this section but not all. A C99 standard version of the function is guaranteed to work correctly if the expression is assigned to a variable (of any type) and that variable used throughout. A portable, efficient C99 standard program for splitting a double precision number into high and low parts, however, is more difficult: how can we split at the correct position and avoid double-rounding if we cannot guarantee that expressions are rounded correctly to double precision? One solution is to use the type to perform the splitting in double precision on single/double systems and in extended precision on extended-based systems, so that in either case the arithmetic will be correctly rounded. Theorem 14 says that we can split at any bit position provided we know the precision of the underlying arithmetic, and the and environmental parameter macros should give us this information.\n\nThe following fragment shows one possible implementation:\n\nOf course, to find this solution, the programmer must know that expressions may be evaluated in extended precision, that the ensuing double-rounding problem can cause the algorithm to malfunction, and that extended precision may be used instead according to Theorem 14. A more obvious solution is simply to specify that each expression be rounded correctly to double precision. On extended-based systems, this merely requires changing the rounding precision mode, but unfortunately, the C99 standard does not provide a portable way to do this. (Early drafts of the Floating-Point C Edits, the working document that specified the changes to be made to the C90 standard to support floating-point, recommended that implementations on systems with rounding precision modes provide and functions to get and set the rounding precision, analogous to the and functions that get and set the rounding direction. This recommendation was removed before the changes were made to the C99 standard.)\n\nCoincidentally, the C99 standard's approach to supporting portability among systems with different integer arithmetic capabilities suggests a better way to support different floating-point architectures. Each C99 standard implementation supplies an header file that defines those integer types the implementation supports, named according to their sizes and efficiency: for example, is an integer type exactly 32 bits wide, is the implementation's fastest integer type at least 16 bits wide, and is the widest integer type supported. One can imagine a similar scheme for floating-point types: for example, could name a floating-point type with exactly 53 bit precision but possibly wider range, could name the implementation's fastest type with at least 24 bit precision, and could name the widest reasonably fast type supported. The fast types could allow compilers on extended-based systems to generate the fastest possible code subject only to the constraint that the values of named variables must not appear to change as a result of register spilling. The exact width types would cause compilers on extended-based systems to set the rounding precision mode to round to the specified precision, allowing wider range subject to the same constraint. Finally, could name a type with both the precision and range of the IEEE 754 double format, providing strict double evaluation. Together with environmental parameter macros named accordingly, such a scheme would readily support all five options described above and allow programmers to indicate easily and unambiguously the floating-point semantics their programs require.\n\nMust language support for extended precision be so complicated? On single/double systems, four of the five options listed above coincide, and there is no need to differentiate fast and exact width types. Extended-based systems, however, pose difficult choices: they support neither pure double precision nor pure extended precision computation as efficiently as a mixture of the two, and different programs call for different mixtures. Moreover, the choice of when to use extended precision should not be left to compiler writers, who are often tempted by benchmarks (and sometimes told outright by numerical analysts) to regard floating-point arithmetic as \"inherently inexact\" and therefore neither deserving nor capable of the predictability of integer arithmetic. Instead, the choice must be presented to programmers, and they will require languages capable of expressing their selection.\n\nThe foregoing remarks are not intended to disparage extended-based systems but to expose several fallacies, the first being that all IEEE 754 systems must deliver identical results for the same program. We have focused on differences between extended-based systems and single/double systems, but there are further differences among systems within each of these families. For example, some single/double systems provide a single instruction to multiply two numbers and add a third with just one final rounding. This operation, called a fused multiply-add, can cause the same program to produce different results across different single/double systems, and, like extended precision, it can even cause the same program to produce different results on the same system depending on whether and when it is used. (A fused multiply-add can also foil the splitting process of Theorem 6, although it can be used in a non-portable way to perform multiple precision multiplication without the need for splitting.) Even though the IEEE standard didn't anticipate such an operation, it nevertheless conforms: the intermediate product is delivered to a \"destination\" beyond the user's control that is wide enough to hold it exactly, and the final sum is rounded correctly to fit its single or double precision destination.\n\nThe idea that IEEE 754 prescribes precisely the result a given program must deliver is nonetheless appealing. Many programmers like to believe that they can understand the behavior of a program and prove that it will work correctly without reference to the compiler that compiles it or the computer that runs it. In many ways, supporting this belief is a worthwhile goal for the designers of computer systems and programming languages. Unfortunately, when it comes to floating-point arithmetic, the goal is virtually impossible to achieve. The authors of the IEEE standards knew that, and they didn't attempt to achieve it. As a result, despite nearly universal conformance to (most of) the IEEE 754 standard throughout the computer industry, programmers of portable software must continue to cope with unpredictable floating-point arithmetic.\n\nIf programmers are to exploit the features of IEEE 754, they will need programming languages that make floating-point arithmetic predictable. The C99 standard improves predictability to some degree at the expense of requiring programmers to write multiple versions of their programs, one for each . Whether future languages will choose instead to allow programmers to write a single program with syntax that unambiguously expresses the extent to which it depends on IEEE 754 semantics remains to be seen. Existing extended-based systems threaten that prospect by tempting us to assume that the compiler and the hardware can know better than the programmer how a computation should be performed on a given system. That assumption is the second fallacy: the accuracy required in a computed result depends not on the machine that produces it but only on the conclusions that will be drawn from it, and of the programmer, the compiler, and the hardware, at best only the programmer can know what those conclusions may be."
    },
    {
        "link": "https://medium.com/@thisis-Shitanshu/navigating-integer-overflow-and-floating-point-imprecision-in-c-programming-9403c233639c",
        "document": "The Y2K problem, also known as the “Millennium Bug” or the “Year 2000 Problem,” serves as a significant historical example that sheds light on the challenges associated with outdated software architecture and data representation.\n\nDuring the late 20th century, many computer systems and software applications were designed with limited foresight, particularly in representing dates. As a cost-saving measure, some systems utilized two-digit representations for years, assuming the implicit “19” as the century prefix. For instance, the year 1999 was stored as ‘99.’\n\nThe Y2K problem became evident as the calendar approached the year 2000. With the transition from December 31, 1999, to January 1, 2000, the two-digit representation faced a critical challenge. The issue arose due to the inability of the software to distinguish between the years 1900 and 2000 when only the last two digits were considered. This discrepancy led to complications in date calculations, financial systems, and various other applications that relied on accurate date representation.\n\nThe heart of the Y2K problem was the constrained capacity of two-digit representations. The assumption that the software would perpetually operate within the 20th century proved shortsighted, as it failed to accommodate the impending shift to the 21st century.\n\nThe resolution to the Y2K problem involved a comprehensive effort to upgrade and modernize the affected software systems. This often meant transitioning from two-digit to four-digit representations for years. By employing larger data types capable of accommodating the expanded date range, software developers effectively mitigated the Y2K problem.\n\nClassic video games, including iconic titles like Pac-Man and Donkey Kong, witnessed glitches associated with integer overflow, significantly impacting game mechanics upon reaching specific levels. These glitches occurred as a consequence of the finite nature of the memory storage used for representing numerical values in these games. The manifestation of integer overflow led to unexpected behaviors in the gameplay after crossing certain levels, highlighting the real-world consequences of these computational limitations.\n\nIn 2015, the Boeing 787 encountered a critical issue involving power loss after 248 days of uninterrupted operation, attributed to a software counter overflow. This incident underscores the far-reaching impact of integer overflow in real-world systems. The solution implemented to address this issue was unconventional but pragmatic — resetting the plane’s power by turning it off and on. This temporary fix was necessitated by the limitations of a 32-bit integer representation for tracking time, revealing the significance of considering computational constraints in safety-critical systems."
    },
    {
        "link": "https://quora.com/What-is-the-best-way-to-tackle-floating-point-precision-issues-in-C",
        "document": "Something went wrong. Wait a moment and try again."
    }
]