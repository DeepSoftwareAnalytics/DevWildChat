[
    {
        "link": "https://boost.org/doc/libs/1_81_0/doc/html/boost_asio/tutorial.html",
        "document": ""
    },
    {
        "link": "https://github.com/sachinsaini4278/Socket-Programming-using-boost-asio",
        "document": "Cross platform networking code (code would work on Windows, Linux, etc.)\n\n IPv4 and IPv6 support\n\n Asynchronous event support\n\n Timer support\n\n iostream compatibility\n\n And much more. You can get the complete overview of the library here.\n\nWe just need the following to get started:\n\nboost.asio \n\n C++ compiler (preferably g++) \n\n Text-editor \n\n The simplest way to get asio on linux is by executing the following command:\n\n\n\nIf you’re using some other platform or the above doesn’t seem a good fit for you, follow the document here to get asio on your system.\n\nThe next step is to make sure you have C++ compiler on your compiler. I’m using g++. You can get the same with the following command in linux.\n\nOnce you have the compiler, you’re good to follow along. I don’t have any text-editor preference. You can choose one of your choice.\n\nNow that we have everything, we are in a position to start coding."
    },
    {
        "link": "https://boost.org/doc/libs/1_76_0/doc/html/boost_asio.html",
        "document": "...one of the most highly regarded and expertly designed C++ library projects in the world. — Herb Sutter and Andrei Alexandrescu , C++ Coding Standards\n\nBoost.Asio is a cross-platform C++ library for network and low-level I/O programming that provides developers with a consistent asynchronous model using a modern C++ approach.\n\nAn overview of the features included in Boost.Asio, plus rationale and design information. How to use Boost.Asio in your applications. Includes information on library dependencies and supported platforms. A tutorial that introduces the fundamental concepts required to use Boost.Asio, and shows how to use Boost.Asio to develop simple client and server programs. Examples that illustrate the use of Boost.Asio in more complex applications. Description of changes to provide compatibility with the \"C++ Extensions for Networking\" Technical Specification. Description of Boost.Asio's support for the proposed standard executors library. Log of Boost.Asio changes made in each Boost release."
    },
    {
        "link": "https://boost.org/doc/libs/1_38_0/doc/html/boost_asio/tutorial.html",
        "document": ""
    },
    {
        "link": "https://think-async.com",
        "document": "Asio is a cross-platform C++ library for network and low-level I/O programming that provides developers with a consistent asynchronous model using a modern C++ approach.\n\nThe following video illustrates the use of Asio in C++20.\n\nWhen targeting C++11 (or later), most of Asio can be used without any extra dependencies. More…​\n\nAsio provides the basic building blocks for C++ networking, concurrency and other kinds of I/O.\n\nWhat kind of applications can use Asio? Asio is used in all kinds of applications, from phone apps to the world’s fastest share markets. Here is a list of some applications that use Asio."
    },
    {
        "link": "https://doc.qt.io/qt-5/topics-network-connectivity.html",
        "document": "Qt provides classes for both high-level and low-level network communication, classes for web integration, and classes for interprocess communication.\n\nFor high-level network traffic, Qt Network provides an abstraction layer over the operations used, showing only high-level classes and functions. Qt Network can also handle lower level protocols like TCP and UDP. Classes like QTcpSocket and QUdpSocket enable the developer to send and receive messages using the TCP or UDP protocol.Name resolution is done with QHostInfo. QHostInfo is called before creating a network connection with QTcpSocket or QUdpSocket. Filtering and redistributing network traffic via proxies can handled by the QNetWorkProxy class.\n\nQt Network also provides the Bearer Management API. It has functions that can start or stop network interfaces and roam between access points. It does however not take care of the network configurations itself. The platform needs to take care of that.\n\nQt WebEngine offers a Chromium-based web engine that enables using web content in your application. Qt WebEngine can render HTML5, XHTML, and SVG documents, and execute Javascript.\n\nQt also offers functionalities for inter-process communication (IPC). The class QProcess is used to start external programs. Qt D-Bus provides support for D-Bus, an interprocess communication and remoteprocedure calling mechanism. It mostly communicates via a central server application, called a bus. However, it is also possible to let applications communicate directly with each other. QSharedMemory provides access to a shared memory segment by multiple threads and processes. It is however also possible for a single process to exclusively lock that shared memory.\n\nQt supports a wide range of network communication, with a focus on HTTP, TCP, and UDP.\n\nAt the HTTP level, the Qt Network module offers the network access API, which consists mainly of QNetworkRequest, QNetworkAccessManager, and QNetworkReply. Put simply, the QNetworkRequest resembles an HTTP request, which gets passed to the QNetworkAccessManager to send the request on the wire; this class returns a QNetworkReply, which enables parsing the HTTP reply. The network access API uses the socket classes mentioned below (for TCP and SSL) internally.\n\nFor communication at the socket level, QTcpSocket, QUdpSocket and QSslSocket should be used. These classes offer a synchronous API through the waitFor* methods as well as an asynchronous API; if possible (i.e. if the event loop is running), the asynchronous API should always be preferred. Qt also offers QTcpServer to enable the server-side part of a TCP communication. Please note that there is no HTTP server class in Qt.\n\nFor secure communication via SSL, Qt Network offers a wide range of classes alongside the central QSslSocket, e.g. QSslCertificate, QSslConfiguration and QSslError.\n\nFor mobile devices, Qt Network offers the bearer management API to track the status of a connection (e.g. getting notified about online/offline status or whether Wifi or 3G is used).\n\nQt also offers HTTP support in QML by either using HTTP explicitly via XmlHttpRequest, or by transparently using HTTP URLs in e.g. Image sources.\n• Resource Loading and Network Transparency - network and URL transparency in QML\n\nAn alternative to direct TCP or HTTP communication is to use the WebSocket protocol (RFC 6455). It is a two-way communication protocol on top of the TCP protocol to utilize existing web infrastructure without having to create additional client-server based communication. The Qt WebSockets module provides both a QML and C++ API, in addition to several examples to demonstrate its use.\n\nQt makes it easy to embed web content into your Qt application using features of the Qt WebEngine layout engine. The Qt WebEngine module equips Qt with support for a broad range of standard web technologies that make it possible to embed HTML content styled with CSS and scripted with JavaScript into your Qt application. Qt WebEngine facilitates both integration with traditional QWidget based desktop applications as well as embedding into Qt Quick QML applications.\n\nFor more information see Integrating Web Content.\n\nQt provides several ways to implement Inter-Process Communication (IPC) in Qt applications.\n\nThe cross-platform Qt Network module provides classes that make network programming portable and easy. It offers high-level classes (e.g., QNetworkAccessManager, QFtp) that communicate using specific application-level protocols, and lower-level classes (e.g., QTcpSocket, QTcpServer, QSslSocket) for implementing protocols.\n\nThe cross-platform shared memory class, QSharedMemory, provides access to the operating system's shared memory implementation. It allows safe access to shared memory segments by multiple threads and processes. Additionally, QSystemSemaphore can be used to control access to resources shared by the system, as well as to communicate between processes.\n\nThe Qt D-Bus module is a cross-platform library you can use to implement IPC using the D-Bus protocol. It extends Qt's signals and slots mechanism to the IPC level, allowing a signal emitted by one process to be connected to a slot in another process.\n\nThe cross-platform class QProcess can be used to start external programs as child processes, and to communicate with them. It provides an API for monitoring and controlling the state of the child process. QProcess gives access to the input/output channels of child process by inheriting from QIODevice.\n\nThe QLocalSocket class provides a local socket. On Windows this is a named pipe and on Unix this is a local domain socket. The QLocalServer class provides a local socket based server. This class makes it possible to accept incoming local socket connections.\n\nThe Qt Serial Port module provides a C++ API for communicating through serial ports, using the RS-232 standard. It works with physical ports and also with drivers that emulate these ports. Examples of serial port emulators include virtual COM ports, com0com emulators, and the Bluetooth SPP.\n\nThis module is designed to make serial port programming easier and portable. As of Qt 5.2, it is supported on Windows, macOS, and Linux.\n\nThe Qt Bluetooth module provides both C++ and QML APIs for the short-range (less than 100 meters) wireless protocol developed by the Bluetooth Special Interest Group. It provides classic Bluetooth and Bluetooth Low Energy features.\n\nThe Qt NFC module provides both C++ and QML APIs for the extremely short-range (less than 20 centimeters) wireless protocol developed by the NFC Forum."
    },
    {
        "link": "https://doc.qt.io/qt-6/qtnetwork-index.html",
        "document": "The Qt Network module provides a set of APIs for programming applications that use TCP/IP. Operations such as requests, cookies, and sending data over HTTP are handled by various C++ classes.\n\nUsing a Qt module's C++ API requires linking against the module library, either directly or through other dependencies. Several build tools have dedicated support for this, including CMake and qmake.\n\nUse the command to locate the needed module component in the package:\n\nFor more details, see the Build with CMake overview.\n\nTo configure the module for building with qmake, add the module as a value of the variable in the project's .pro file:\n\nThese articles contain information about Qt Network setup and about applications with networking capabilities.\n\nThese are links to the API reference materials.\n\nChanges to Qt Network lists important changes in the module API and functionality that were done for the Qt 6 series of Qt.\n\nQt Network is available under commercial licenses from The Qt Company. In addition, it is available under the GNU Lesser General Public License, version 3, or the GNU General Public License, version 2. See Qt Licensing for further details.\n\nFurthermore, Qt Network in Qt 6.8.2 may contain third-party modules under the following permissive licenses:\n\nQt Network can make use of the OpenSSL Toolkit as a back end. The library is then linked against OpenSSL in a way that requires compliance with the OpenSSL License. To allow linking OpenSSL with Qt Network under the GPL, following exceptions to the GPL do apply:\n\nAlso note shipping OpenSSL might cause Import and Export Restrictions to apply."
    },
    {
        "link": "https://lira.no-ip.org:8443/doc/qtbase5-doc-html/html/qtdoc/topics-network-connectivity.html",
        "document": "Qt provides classes for both high-level and low-level network communication, classes for web integration, and classes for interprocess communication.\n\nFor high-level network traffic, Qt Network provides an abstraction layer over the operations used, showing only high-level classes and functions. Qt Network can also handle lower level protocols like TCP and UDP. Classes like QTcpSocket and QUdpSocket enable the developer to send and receive messages using the TCP or UDP protocol.Name resolution is done with QHostInfo. QHostInfo is called before creating a network connection with QTcpSocket or QUdpSocket. Filtering and redistributing network traffic via proxies can handled by the QNetWorkProxy class.\n\nQt Network also provides the Bearer Management API. It has functions that can start or stop network interfaces and roam between access points. It does however not take care of the network configurations itself. The platform needs to take care of that.\n\nQt WebEngine offers a Chromium-based web engine that enables using web content in your application. Qt WebEngine can render HTML5, XHTML, and SVG documents, and execute Javascript.\n\nQt also offers functionalities for inter-process communication (IPC). The class QProcess is used to start external programs. Qt D-Bus provides support for D-Bus, an interprocess communication and remoteprocedure calling mechanism. It mostly communicates via a central server application, called a bus. However, it is also possible to let applications communicate directly with each other. QSharedMemory provides access to a shared memory segment by multiple threads and processes. It is however also possible for a single process to exclusively lock that shared memory.\n\nQt supports a wide range of network communication, with a focus on HTTP, TCP, and UDP.\n\nAt the HTTP level, the Qt Network module offers the network access API, which consists mainly of QNetworkRequest, QNetworkAccessManager, and QNetworkReply. Put simply, the QNetworkRequest resembles an HTTP request, which gets passed to the QNetworkAccessManager to send the request on the wire; this class returns a QNetworkReply, which enables parsing the HTTP reply. The network access API uses the socket classes mentioned below (for TCP and SSL) internally.\n\nFor communication at the socket level, QTcpSocket, QUdpSocket and QSslSocket should be used. These classes offer a synchronous API through the waitFor* methods as well as an asynchronous API; if possible (i.e. if the event loop is running), the asynchronous API should always be preferred. Qt also offers QTcpServer to enable the server-side part of a TCP communication. Please note that there is no HTTP server class in Qt.\n\nFor secure communication via SSL, Qt Network offers a wide range of classes alongside the central QSslSocket, e.g. QSslCertificate, QSslConfiguration and QSslError. The only supported backend for SSL in Qt is OpenSSL, which needs to be installed separately.\n\nFor mobile devices, Qt Network offers the bearer management API to track the status of a connection (e.g. getting notified about online/offline status or whether Wifi or 3G is used).\n\nQt also offers HTTP support in QML by either using HTTP explicitly via XmlHttpRequest, or by transparently using HTTP URLs in e.g. Image sources.\n• Resource Loading and Network Transparency - network and URL transparency in QML\n\nAn alternative to direct TCP or HTTP communication is to use the WebSocket protocol (RFC 6455). It is a two-way communication protocol on top of the TCP protocol to utilize existing web infrastructure without having to create additional client-server based communication. The Qt WebSockets module provides both a QML and C++ API, in addition to several examples to demonstrate its use.\n\nQt makes it easy to embed web content into your Qt application using features of the Qt WebEngine layout engine. The Qt WebEngine module equips Qt with support for a broad range of standard web technologies that make it possible to embed HTML content styled with CSS and scripted with JavaScript into your Qt application. Qt WebEngine facilitates both integration with traditional QWidget based desktop applications as well as embedding into Qt Quick QML applications.\n\nFor more information see Integrating Web Content.\n\nQt provides several ways to implement Inter-Process Communication (IPC) in Qt applications.\n\nThe cross-platform Qt Network module provides classes that make network programming portable and easy. It offers high-level classes (e.g., QNetworkAccessManager, QFtp) that communicate using specific application-level protocols, and lower-level classes (e.g., QTcpSocket, QTcpServer, QSslSocket) for implementing protocols.\n\nThe cross-platform shared memory class, QSharedMemory, provides access to the operating system's shared memory implementation. It allows safe access to shared memory segments by multiple threads and processes. Additionally, QSystemSemaphore can be used to control access to resources shared by the system, as well as to communicate between processes.\n\nThe Qt D-Bus module is a cross-platform library you can use to implement IPC using the D-Bus protocol. It extends Qt's signals and slots mechanism to the IPC level, allowing a signal emitted by one process to be connected to a slot in another process.\n\nThe cross-platform class QProcess can be used to start external programs as child processes, and to communicate with them. It provides an API for monitoring and controlling the state of the child process. QProcess gives access to the input/output channels of child process by inheriting from QIODevice.\n\nThe QLocalSocket class provides a local socket. On Windows this is a named pipe and on Unix this is a local domain socket. The QLocalServer class provides a local socket based server. This class makes it possible to accept incoming local socket connections.\n\nThe Qt Serial Port module provides a C++ API for communicating through serial ports, using the RS-232 standard. It works with physical ports and also with drivers that emulate these ports. Examples of serial port emulators include virtual COM ports, com0com emulators, and the Bluetooth SPP.\n\nThis module is designed to make serial port programming easier and portable. As of Qt 5.2, it is supported on Windows, macOS, and Linux.\n\nThe Qt Bluetooth module provides both C++ and QML APIs for the short-range (less than 100 meters) wireless protocol developed by the Bluetooth Special Interest Group. It provides classic Bluetooth and Bluetooth Low Energy features.\n\nThe Qt NFC module provides both C++ and QML APIs for the extremely short-range (less than 20 centimeters) wireless protocol developed by the NFC Forum."
    },
    {
        "link": "https://felgo.com/doc/qt/topics-network-connectivity",
        "document": "Qt provides classes for both high-level and low-level network communication, classes for web integration, and classes for inter-process communication.\n\nFor high-level network traffic, Qt Network provides an abstraction layer over the operations used, showing only high-level classes and functions. Qt Network can also handle lower level protocols like TCP and UDP. Classes like QTcpSocket and QUdpSocket enable the developer to send and receive messages using the TCP or UDP protocol.Name resolution is done with QHostInfo. QHostInfo is called before creating a network connection with QTcpSocket or QUdpSocket. Filtering and redistributing network traffic via proxies can handled by the QNetWorkProxy class.\n\nQt also offers functionalities for inter-process communication (IPC). The class QProcess is used to start external programs. Qt D-Bus provides support for D-Bus, an inter-process communication and remote procedure calling mechanism. It mostly communicates via a central server application, called a bus. However, it is also possible to let applications communicate directly with each other. QSharedMemory provides access to a shared memory segment by multiple threads and processes. It is however also possible for a single process to exclusively lock that shared memory.\n\nQt supports a wide range of network communication, with a focus on HTTP, TCP, and UDP.\n\nAt the HTTP level, the Qt Network module offers the network access API, which consists mainly of QNetworkRequest, QNetworkAccessManager, and QNetworkReply. Put simply, the QNetworkRequest resembles an HTTP request, which gets passed to the QNetworkAccessManager to send the request on the wire; this class returns a QNetworkReply, which enables parsing the HTTP reply. The network access API uses the socket classes mentioned below (for TCP and SSL) internally.\n\nFor communication at the socket level, QTcpSocket, QUdpSocket and QSslSocket should be used. These classes offer a synchronous API through the waitFor* methods as well as an asynchronous API; if possible (i.e. if the event loop is running), the asynchronous API should always be preferred. Qt also offers QTcpServer to enable the server-side part of a TCP communication. Please note that there is no HTTP server class in Qt.\n\nFor secure communication via SSL, Qt Network offers a wide range of classes alongside the central QSslSocket, e.g. QSslCertificate, QSslConfiguration and QSslError.\n\nQt also offers HTTP support in QML by either using HTTP explicitly via XmlHttpRequest, or by transparently using HTTP URLs in e.g. Image sources.\n• Resource Loading and Network Transparency - network and URL transparency in QML\n\nQt provides several ways to implement Inter-Process Communication (IPC) in Qt applications.\n\nThe cross-platform Qt Network module provides classes that make network programming portable and easy. It offers high-level classes (e.g., QNetworkAccessManager) that communicate using specific application-level protocols, and lower-level classes (e.g., QTcpSocket, QTcpServer, QSslSocket) for implementing protocols.\n\nThe cross-platform shared memory class, QSharedMemory, provides access to the operating system's shared memory implementation. It allows safe access to shared memory segments by multiple threads and processes. Additionally, QSystemSemaphore can be used to control access to resources shared by the system, as well as to communicate between processes.\n\nThe Qt D-Bus module is a cross-platform library you can use to implement IPC using the D-Bus protocol. It extends Qt's signals and slots mechanism to the IPC level, allowing a signal emitted by one process to be connected to a slot in another process.\n\nThe cross-platform class QProcess can be used to start external programs as child processes, and to communicate with them. It provides an API for monitoring and controlling the state of the child process. QProcess gives access to the input/output channels of child process by inheriting from QIODevice.\n\nThe QLocalSocket class provides a local socket. On Windows this is a named pipe and on Unix this is a local domain socket. The QLocalServer class provides a local socket based server. This class makes it possible to accept incoming local socket connections."
    },
    {
        "link": "https://stackoverflow.com/questions/15051553/qt-signals-queuedconnection-and-directconnection",
        "document": "You won't see much of a difference unless you're working with objects having different thread affinities. Let's say you have QObjects and and they're both attached to different threads. has a signal called and has a slot called .\n\nIf you use a direct connection\n\nthe method will actually run in the 's thread. Basically, it's as if emitting the signal calls the slot method \"directly\". If isn't thread-safe, this can cause some (difficult to locate) bugs. At the very least, you're missing out on the benefits of the extra thread.\n\nIf you change the connection method to (or, in this case, let Qt decide which method to use), things get more interesting. Assuming 's thread is running an event loop, emitting the signal will post an event to 's event loop. The event loop queues the event, and eventually invokes the slot method whenever control returns to it (it being the event loop). This makes it pretty easy to deal with communication between/among threads in Qt (again, assuming your threads are running their own local event loops). You don't have to worry about locks, etc. because the event loop serializes the slot invocations.\n\nNote: If you don't know how to change a QObject's thread affinity, look into . That should get you started.\n\nI should clarify my opening sentence. It does make a difference if you specify a queued connection - even for two objects on the same thread. The event is still posted to the thread's event loop. So, the method call is still asynchronous, meaning it can be delayed in unpredictable ways (depending on any other events the loop may need to process). However, if you don't specify a connection method, the direct method is automatically used for connections between objects on the same thread (at least it is in Qt 4.8)."
    }
]