[
    {
        "link": "https://stackoverflow.com/questions/17511313/how-to-do-pagination-with-mybatis",
        "document": "I am currently working on a ecommerce application where I have to show a list of available products using search functionality.\n\nAs with every search, I have to implement Pagination here.\n\nI am using mybatis as my ORM tool and mysql as an underlying database.\n\nGoogling around I found following ways to accomplish this task :\n• None Client Side paging : Here I will have to fetch all the results from the database matching the search criteria in one stroke and handle the pagination at my code level (Possibly frond end code ).\n• None Server Side Paging : With mysql I can use the Limit and the offset of the resultset to construct a query like : SELECT * FROM sampletable WHERE condition1>1 AND condition2>2 LIMIT 0,20\n\nHere, I have to pass the offset and limit count everytime the user selects a new page while navigating in search results.\n\nCan anyone tell,\n• which will be better way to implement paging ?\n• Do mybatis supports a better way to implement paging than just relying on above SQL queries ( like the hibernate criteria APIs).\n\nAny inputs is highly appreaciated. Thanks ."
    },
    {
        "link": "https://baeldung.com/mybatis-plus-introduction",
        "document": "MyBatis is a popular open-source persistence framework that provides alternatives to JDBC and Hibernate.\n\nIn this article, we’ll discuss an extension over MyBatis called MyBatis-Plus, loaded with many handy features offering rapid development and better efficiency.\n\nFirst, let’s add the following Maven dependency to our pom.xml.\n\nThe latest version of the Maven dependency can be found here. Since this is the Spring Boot 3-based Maven dependency, we’ll also be required to add the spring-boot-starter dependency to our pom.xml.\n\nAlternatively, we can add the following dependency when using Spring Boot 2:\n\nNext, we’ll add the H2 dependency to our pom.xml for an in-memory database to verify the features and capabilities of MyBatis-Plus.\n\nSimilarly, find the latest version of the Maven dependency here. We can also use MySQL for the integration.\n\nOnce our setup is ready, let’s create the Client entity with a few properties like id, firstName, lastName, and email:\n\nHere, we’ve used MyBatis-Plus’s self-explanatory annotations like @TableName and @TableId for quick integration with the client table in the underlying database.\n\nThen, we’ll create the mapper interface for the Client entity – ClientMapper that extends the BaseMapper interface provided by MyBatis-Plus:\n\nThe BaseMapper interface provides numerous default methods like insert(), selectOne(), updateById(), insertOrUpdate(), deleteById(), and deleteByIds() for CRUD operations.\n\nNext, let’s create the ClientService service interface extending the IService interface:\n\nThe IService interface encapsulates the default implementations of CRUD operations and uses the BaseMapper interface to offer simple and maintainable basic database operations.\n\nIt’s the service implementation for the Client entity, injected with the ClientMapper dependency.\n\nNow that we’ve all the utility interfaces and classes ready, let’s use the ClientService interface to create the Client object:\n\nWe can observe the following logs when saving the client object once we set the logging level to DEBUG for the package com.baeldung.mybatisplus:\n\nThe logs generated by the ClientMapper interface show the insert query with the parameters and final number of rows inserted in the database.\n\nNext, let’s check out a few handy read methods like getById() and list():\n\nSimilarly, we can observe the following SELECT statement in the logs:\n\nAlso, the MyBatis-Plus framework comes with a few handy wrapper classes like QueryWrapper, LambdaQueryWrapper, and QueryChainWrapper:\n\nHere, we’ve used the getBaseMapper() method of the ClientService interface to utilize the wrapper classes to let us write complex queries intuitively.\n\nThen, let’s take a look at a few ways to execute the updates:\n\nFollow the console to check out the following logs:\n\nSimilarly, we can use the LambdaUpdateWrapper class to update the Client objects:\n\nOnce the client objects are updated, we use the QueryWrapper class to confirm the operation.\n\nSimilarly, we can use the removeById() or removeByMap() methods to delete the records:\n\nThe logs for the delete operation would look like this:\n\nSimilar to the update logs, these logs show the delete query with the parameters and total rows deleted from the database.\n\nLet’s discuss a few handy features available in MyBatis-Plus as extensions over MyBatis.\n\nFirst and foremost is the ability to perform common CRUD operations in batches thereby improving performance and efficiency:\n\nLikewise, let’s check out the logs to see the batch inserts in action:\n\nAlso, we’ve got methods like updateBatchById(), saveOrUpdateBatch(), and removeBatchByIds() to perform save, update, or delete operations for a collection of objects in batches.\n\nMyBatis-Plus framework offers an intuitive way to paginate the query results.\n\nAll we need is to declare the MyBatisPlusInterceptor class as a Spring Bean and add the PaginationInnerInterceptor class defined with database type as an inner interceptor:\n\nThen, we can use the Page class to paginate the records. For instance, let’s fetch the second page with three results:\n\nSo, we can observe the following logs for the above operation:\n\nLikewise, these logs show the select query with the parameters and total rows selected from the database.\n\nMyBatis-Plus offers support for streaming queries through methods like selectList(), selectByMap(), and selectBatchIds(), letting us process big data and meet the performance objectives.\n\nFor instance, let’s check out the selectList() method available through the ClientService interface:\n\nHere, we’ve used the getResultObject() method to get every record from the database.\n\nLikewise, we’ve got the getResultCount() method that returns the count of results being processed and the stop() method to halt the processing of the result set.\n\nBeing a fairly opinionated and intelligent framework, MyBatis-Plus also supports automatically filling fields for insert and update operations.\n\nFor example, we can use the @TableField annotation to set the creationDate when inserting a new record and lastModifiedDate in the event of an update:\n\nNow, MyBatis-Plus will fill the creation_date and last_modified_date columns automatically with every insert and update query.\n\nMyBatis-Plus framework offers a simple and efficient strategy to let us logically delete the record by flagging it in the database.\n\nWe can enable the feature by using the @TableLogic annotation over the deleted property:\n\nNow, the framework will automatically handle the logical deletion of the records when performing database operations.\n\nSo, let’s remove the Client object and try to read the same:\n\nObserve the following logs to check out the update query setting the value of the deleted property to 1 and using the 0 value while running the select query on the database:\n\nAlso, it’s possible to modify the default configuration through the application.yml:\n\nThe above configuration lets us to change the name of the delete field with delete and active values.\n\nMyBatis-Plus offers an automatic code generation feature to avoid manually creating redundant code like entity, mapper, and service interfaces.\n\nFirst, let’s add the latest mybatis-plus-generator dependency to our pom.xml:\n\nAlso, we’ll require the support of a template engine like Velocity or Freemarker.\n\nThen, we can use MyBatis-Plus’s FastAutoGenerator class with the FreemarkerTemplateEngine class set as a template engine to connect the underlying database, scan all the existing tables, and generate the utility code:\n\nTherefore, when the above program runs, it’ll generate the output files in the com.baeldung.mybatisplus package:\n\nHere, we’ve asserted that the automatically generated classes/interfaces like Client, ClientMapper, ClientService, and ClientServiceImpl exist at the corresponding paths.\n\nMyBatis-Plus framework allows implementing a custom ID generator using the IdentifierGenerator interface.\n\nFor instance, let’s create the TimestampIdGenerator class and implement the nextId() method of the IdentifierGenerator interface to return the System’s nanoseconds:\n\nNow, we can create the Client object setting the custom ID using the timestampIdGenerator bean:\n\nThe logs will show the custom ID value generated by the TimestampIdGenerator class:\n\nThe long value of id shown in the parameters is the system time in nanoseconds.\n\nWe require to simply extend the SimpleDdl class and override the getSqlFiles() method to return a list of paths of SQL files containing the database migration statements:\n\nThe underlying IdDL interface creates the ddl_history table to keep the history of DDL statements performed on the schema:\n\nNote: this feature works with most databases like MySQL and PostgreSQL, but not H2.\n\nIn this introductory article, we’ve explored MyBatis-Plus – an extension over the popular MyBatis framework, loaded with many developer-friendly opinionated ways to perform CRUD operations on the database.\n\nAlso, we’ve seen a few handy features like batch operations, pagination, ID generation, and DB migration.\n\nThe complete code for this article is available over on GitHub."
    },
    {
        "link": "https://github.com/baomidou/mybatis-plus-samples/blob/master/mybatis-plus-sample-pagination/src/test/java/com/baomidou/mybatisplus/samples/pagination/PaginationTest.java",
        "document": "To see all available qualifiers, see our documentation .\n\nSaved searches Use saved searches to filter your results more quickly\n\nWe read every piece of feedback, and take your input very seriously.\n\nYou signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    },
    {
        "link": "https://stackoverflow.com/questions/28888375/run-a-query-with-a-limit-offset-and-also-get-the-total-number-of-rows",
        "document": "Be aware that the cost will be substantially higher than without the total number. Postgres has to actually count all qualifying rows either way, which imposes a cost depending on the total number. See:\n• Best way to get result count before LIMIT was applied\n\nTwo separate queries (one for the result set, one for the total count) may or may not be faster. But the overhead of executing two separate queries and processing results often tips the scales. Depends on the nature of the query, indexes, resources, cardinalities ...\n\nHowever, as Dani pointed out, when is at least as great as the number of rows returned from the base query, no rows are returned. So we get no , either. If that's a rare case, just run a second query for the count in this case.\n\n If that's not acceptable, here is a single query always returning the full count, with a CTE and an . This adds more overhead and only makes sense for certain cases (expensive filters, few qualifying rows).\n\n① Typically it does not pay to add (the same) in the CTE. That forces all rows to be sorted. With , typically only a small fraction has to be sorted (with \"top-N heapsort\").\n\nYou get one row of null values, with the appended if is too big. Else, it's appended to every row like in the first query.\n\nIf a row with all null values is a possible valid result you have to check to disambiguate the origin of the empty row.\n\nThis still executes the base query only once. But it adds more overhead to the query and only pays if that's less than repeating the base query for the count.\n\nEither way, the total count is returned with every row (redundantly). Doesn't add much cost. But if that's an issue, you could instead ...\n\nThe added row must match the row type of the query result, and the count must fit into the data type of one of the columns. A bit of a hack. Like:\n\nAgain, sometimes it may be cheaper to just run a separate count (still in a single query!):\n• Is there a shortcut for SELECT * FROM?"
    },
    {
        "link": "https://github.com/qingqiu8/mybatis-plus/blob/master/mybatis-plus/src/main/java/com/baomidou/mybatisplus/plugins/PaginationInterceptor.java",
        "document": "* Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n\n* use this file except in compliance with the License. You may obtain a copy of\n\n* Unless required by applicable law or agreed to in writing, software\n\n* distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n\n* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n\n* License for the specific language governing permissions and limitations under"
    },
    {
        "link": "https://stackoverflow.com/questions/17511313/how-to-do-pagination-with-mybatis",
        "document": "I am currently working on a ecommerce application where I have to show a list of available products using search functionality.\n\nAs with every search, I have to implement Pagination here.\n\nI am using mybatis as my ORM tool and mysql as an underlying database.\n\nGoogling around I found following ways to accomplish this task :\n• None Client Side paging : Here I will have to fetch all the results from the database matching the search criteria in one stroke and handle the pagination at my code level (Possibly frond end code ).\n• None Server Side Paging : With mysql I can use the Limit and the offset of the resultset to construct a query like : SELECT * FROM sampletable WHERE condition1>1 AND condition2>2 LIMIT 0,20\n\nHere, I have to pass the offset and limit count everytime the user selects a new page while navigating in search results.\n\nCan anyone tell,\n• which will be better way to implement paging ?\n• Do mybatis supports a better way to implement paging than just relying on above SQL queries ( like the hibernate criteria APIs).\n\nAny inputs is highly appreaciated. Thanks ."
    },
    {
        "link": "https://baeldung.com/mybatis-plus-introduction",
        "document": "MyBatis is a popular open-source persistence framework that provides alternatives to JDBC and Hibernate.\n\nIn this article, we’ll discuss an extension over MyBatis called MyBatis-Plus, loaded with many handy features offering rapid development and better efficiency.\n\nFirst, let’s add the following Maven dependency to our pom.xml.\n\nThe latest version of the Maven dependency can be found here. Since this is the Spring Boot 3-based Maven dependency, we’ll also be required to add the spring-boot-starter dependency to our pom.xml.\n\nAlternatively, we can add the following dependency when using Spring Boot 2:\n\nNext, we’ll add the H2 dependency to our pom.xml for an in-memory database to verify the features and capabilities of MyBatis-Plus.\n\nSimilarly, find the latest version of the Maven dependency here. We can also use MySQL for the integration.\n\nOnce our setup is ready, let’s create the Client entity with a few properties like id, firstName, lastName, and email:\n\nHere, we’ve used MyBatis-Plus’s self-explanatory annotations like @TableName and @TableId for quick integration with the client table in the underlying database.\n\nThen, we’ll create the mapper interface for the Client entity – ClientMapper that extends the BaseMapper interface provided by MyBatis-Plus:\n\nThe BaseMapper interface provides numerous default methods like insert(), selectOne(), updateById(), insertOrUpdate(), deleteById(), and deleteByIds() for CRUD operations.\n\nNext, let’s create the ClientService service interface extending the IService interface:\n\nThe IService interface encapsulates the default implementations of CRUD operations and uses the BaseMapper interface to offer simple and maintainable basic database operations.\n\nIt’s the service implementation for the Client entity, injected with the ClientMapper dependency.\n\nNow that we’ve all the utility interfaces and classes ready, let’s use the ClientService interface to create the Client object:\n\nWe can observe the following logs when saving the client object once we set the logging level to DEBUG for the package com.baeldung.mybatisplus:\n\nThe logs generated by the ClientMapper interface show the insert query with the parameters and final number of rows inserted in the database.\n\nNext, let’s check out a few handy read methods like getById() and list():\n\nSimilarly, we can observe the following SELECT statement in the logs:\n\nAlso, the MyBatis-Plus framework comes with a few handy wrapper classes like QueryWrapper, LambdaQueryWrapper, and QueryChainWrapper:\n\nHere, we’ve used the getBaseMapper() method of the ClientService interface to utilize the wrapper classes to let us write complex queries intuitively.\n\nThen, let’s take a look at a few ways to execute the updates:\n\nFollow the console to check out the following logs:\n\nSimilarly, we can use the LambdaUpdateWrapper class to update the Client objects:\n\nOnce the client objects are updated, we use the QueryWrapper class to confirm the operation.\n\nSimilarly, we can use the removeById() or removeByMap() methods to delete the records:\n\nThe logs for the delete operation would look like this:\n\nSimilar to the update logs, these logs show the delete query with the parameters and total rows deleted from the database.\n\nLet’s discuss a few handy features available in MyBatis-Plus as extensions over MyBatis.\n\nFirst and foremost is the ability to perform common CRUD operations in batches thereby improving performance and efficiency:\n\nLikewise, let’s check out the logs to see the batch inserts in action:\n\nAlso, we’ve got methods like updateBatchById(), saveOrUpdateBatch(), and removeBatchByIds() to perform save, update, or delete operations for a collection of objects in batches.\n\nMyBatis-Plus framework offers an intuitive way to paginate the query results.\n\nAll we need is to declare the MyBatisPlusInterceptor class as a Spring Bean and add the PaginationInnerInterceptor class defined with database type as an inner interceptor:\n\nThen, we can use the Page class to paginate the records. For instance, let’s fetch the second page with three results:\n\nSo, we can observe the following logs for the above operation:\n\nLikewise, these logs show the select query with the parameters and total rows selected from the database.\n\nMyBatis-Plus offers support for streaming queries through methods like selectList(), selectByMap(), and selectBatchIds(), letting us process big data and meet the performance objectives.\n\nFor instance, let’s check out the selectList() method available through the ClientService interface:\n\nHere, we’ve used the getResultObject() method to get every record from the database.\n\nLikewise, we’ve got the getResultCount() method that returns the count of results being processed and the stop() method to halt the processing of the result set.\n\nBeing a fairly opinionated and intelligent framework, MyBatis-Plus also supports automatically filling fields for insert and update operations.\n\nFor example, we can use the @TableField annotation to set the creationDate when inserting a new record and lastModifiedDate in the event of an update:\n\nNow, MyBatis-Plus will fill the creation_date and last_modified_date columns automatically with every insert and update query.\n\nMyBatis-Plus framework offers a simple and efficient strategy to let us logically delete the record by flagging it in the database.\n\nWe can enable the feature by using the @TableLogic annotation over the deleted property:\n\nNow, the framework will automatically handle the logical deletion of the records when performing database operations.\n\nSo, let’s remove the Client object and try to read the same:\n\nObserve the following logs to check out the update query setting the value of the deleted property to 1 and using the 0 value while running the select query on the database:\n\nAlso, it’s possible to modify the default configuration through the application.yml:\n\nThe above configuration lets us to change the name of the delete field with delete and active values.\n\nMyBatis-Plus offers an automatic code generation feature to avoid manually creating redundant code like entity, mapper, and service interfaces.\n\nFirst, let’s add the latest mybatis-plus-generator dependency to our pom.xml:\n\nAlso, we’ll require the support of a template engine like Velocity or Freemarker.\n\nThen, we can use MyBatis-Plus’s FastAutoGenerator class with the FreemarkerTemplateEngine class set as a template engine to connect the underlying database, scan all the existing tables, and generate the utility code:\n\nTherefore, when the above program runs, it’ll generate the output files in the com.baeldung.mybatisplus package:\n\nHere, we’ve asserted that the automatically generated classes/interfaces like Client, ClientMapper, ClientService, and ClientServiceImpl exist at the corresponding paths.\n\nMyBatis-Plus framework allows implementing a custom ID generator using the IdentifierGenerator interface.\n\nFor instance, let’s create the TimestampIdGenerator class and implement the nextId() method of the IdentifierGenerator interface to return the System’s nanoseconds:\n\nNow, we can create the Client object setting the custom ID using the timestampIdGenerator bean:\n\nThe logs will show the custom ID value generated by the TimestampIdGenerator class:\n\nThe long value of id shown in the parameters is the system time in nanoseconds.\n\nWe require to simply extend the SimpleDdl class and override the getSqlFiles() method to return a list of paths of SQL files containing the database migration statements:\n\nThe underlying IdDL interface creates the ddl_history table to keep the history of DDL statements performed on the schema:\n\nNote: this feature works with most databases like MySQL and PostgreSQL, but not H2.\n\nIn this introductory article, we’ve explored MyBatis-Plus – an extension over the popular MyBatis framework, loaded with many developer-friendly opinionated ways to perform CRUD operations on the database.\n\nAlso, we’ve seen a few handy features like batch operations, pagination, ID generation, and DB migration.\n\nThe complete code for this article is available over on GitHub."
    },
    {
        "link": "https://stackoverflow.com/questions/39718720/how-use-pagingandsorting-with-mybatis",
        "document": "I use mybatis for retriving data from the DB. But I would use the Pageable object (from spring) to have the pagination functionalities. Is this possible? It is still enough to extend myMapper with a PaginationAndSortRepository?\n\nand then I use it from my service:\n\nThe problem is that so I will return all MyObjects and not only the requested set.... I have to extract the interested list every time?"
    },
    {
        "link": "https://github.com/baomidou/mybatis-plus-samples/blob/master/mybatis-plus-sample-pagination/src/test/java/com/baomidou/mybatisplus/samples/pagination/PaginationTest.java",
        "document": "To see all available qualifiers, see our documentation .\n\nSaved searches Use saved searches to filter your results more quickly\n\nWe read every piece of feedback, and take your input very seriously.\n\nYou signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    },
    {
        "link": "https://alibabacloud.com/en/knowledge/developer/common-annotations-of-mybatis-plus?_p_lc=1",
        "document": "Related Tags： 1.MyBatis with a More Fluent Experience In those years, the common annotations of Mybatis -Plus that we have learned togetherrecently learned mybatis -plus, and now I will take you to review which annotations we often use in the process of learning, and what functions do these annotations have? How to use these annotations? Especially suitable for novice learning and veteran review~Without further ado , let's get started!2. Introduction to mybatis -plusMyBatis -Plus (MP for short) is an enhancement tool for MyBatis . It only enhances and does not change on the basis of MyBatis. It is born to simplify development and improve efficiency .vision is to be the best partner of MyBatis !Official address: https://baomidou.com/Document release address: https://baomidou.com/pages/24112f1. @MapperScan@SpringBootApplication _@MapperScan ( \" com.cabbage.mapper \" )public class Mybatisplus01Application {public static void main( String[] args ) {SpringApplication.run ( Mybatisplus01Application.class, args );Combining the code and pictures, the friends can guess: the annotation @ MapperScan is used to scan the mapper mapping file, and only after using it can we use the various methods provided by the official.2. @Mapper@Mapper@Repositorypublic interface UserMapper extends BaseMapper"
    }
]