[
    {
        "link": "https://cesium.com/learn/ion-sdk/ref-doc/Primitive.html",
        "document": "A primitive represents geometry in the . The geometry can be from a single as shown in example 1 below, or from an array of instances, even if the geometry is from different geometry types, e.g., an and an as shown in Code Example 2. A primitive combines geometry instances with an that describes the full shading, including and . Roughly, the geometry instance defines the structure and placement, and the appearance defines the visual characteristics. Decoupling geometry and appearance allows us to mix and match most of them and add a new geometry or appearance independently of each other. Combining multiple instances into one primitive is called batching, and significantly improves performance for static data. Instances can be individually picked; returns their . Using per-instance appearances like , each instance can also have a unique color. can either be created and batched on a web worker or the main thread. The first two examples show geometry that will be created on a web worker by using the descriptions of the geometry. The third example shows how to create the geometry on the main thread by explicitly calling the method. Object with the following properties: The geometry instances - or a single geometry instance - to render. The appearance used to render the primitive. The appearance used to shade this primitive when it fails the depth test. Determines if this primitive will be shown. The 4x4 transformation matrix that transforms the primitive (all geometry instances) from model to world coordinates. When , geometry vertices are optimized for the pre and post-vertex-shader caches. When , geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time. When , the geometry vertices are compressed, which will save memory. When , the primitive does not keep a reference to the input to save memory. When , each geometry instance will only be pickable with . When , GPU memory is saved. When , the renderer frustum culls and horizon culls the primitive's commands based on their bounding volume. Set this to for a small performance gain if you are manually culling the primitive. Determines if the primitive will be created asynchronously or block until ready. For debugging only. Determines if this primitive's commands' bounding spheres are shown. Determines whether this primitive casts or receives shadows from light sources. // 1. Draw a translucent ellipse on the surface with a checkerboard pattern const instance = new Cesium.GeometryInstance({ geometry : new Cesium.EllipseGeometry({ center : Cesium.Cartesian3.fromDegrees(-100.0, 20.0), semiMinorAxis : 500000.0, semiMajorAxis : 1000000.0, rotation : Cesium.Math.PI_OVER_FOUR, vertexFormat : Cesium.VertexFormat.POSITION_AND_ST }), id : 'object returned when this instance is picked and to get/set per-instance attributes' }); scene.primitives.add(new Cesium.Primitive({ geometryInstances : instance, appearance : new Cesium.EllipsoidSurfaceAppearance({ material : Cesium.Material.fromType('Checkerboard') }) })); // 2. Draw different instances each with a unique color const rectangleInstance = new Cesium.GeometryInstance({ geometry : new Cesium.RectangleGeometry({ rectangle : Cesium.Rectangle.fromDegrees(-140.0, 30.0, -100.0, 40.0), vertexFormat : Cesium.PerInstanceColorAppearance.VERTEX_FORMAT }), id : 'rectangle', attributes : { color : new Cesium.ColorGeometryInstanceAttribute(0.0, 1.0, 1.0, 0.5) } }); const ellipsoidInstance = new Cesium.GeometryInstance({ geometry : new Cesium.EllipsoidGeometry({ radii : new Cesium.Cartesian3(500000.0, 500000.0, 1000000.0), vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL }), modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame( Cesium.Cartesian3.fromDegrees(-95.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 500000.0), new Cesium.Matrix4()), id : 'ellipsoid', attributes : { color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA) } }); scene.primitives.add(new Cesium.Primitive({ geometryInstances : [rectangleInstance, ellipsoidInstance], appearance : new Cesium.PerInstanceColorAppearance() })); // 3. Create the geometry on the main thread. scene.primitives.add(new Cesium.Primitive({ geometryInstances : new Cesium.GeometryInstance({ geometry : Cesium.EllipsoidGeometry.createGeometry(new Cesium.EllipsoidGeometry({ radii : new Cesium.Cartesian3(500000.0, 500000.0, 1000000.0), vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL })), modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame( Cesium.Cartesian3.fromDegrees(-95.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 500000.0), new Cesium.Matrix4()), id : 'ellipsoid', attributes : { color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA) } }), appearance : new Cesium.PerInstanceColorAppearance(), asynchronous : false }));\n\nDetermines if the geometry instances will be created and batched on a web worker.\n\nWhen , geometry vertices are compressed, which will save memory.\n\nWhen , the renderer frustum culls and horizon culls the primitive's commands based on their bounding volume. Set this to for a small performance gain if you are manually culling the primitive.\n\nThe used to shade this primitive when it fails the depth test. Each geometry instance is shaded with the same appearance. Some appearances, like allow giving each instance unique properties. When using an appearance that requires a color attribute, like PerInstanceColorAppearance, add a depthFailColor per-instance attribute instead. Requires the EXT_frag_depth WebGL extension to render properly. If the extension is not supported, there may be artifacts.\n\nDetermines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.\n\nWhen , the primitive does not keep a reference to the input to save memory.\n\nDetermines whether this primitive casts or receives shadows from light sources.\n\nDetermines if the primitive will be shown. This affects all geometry instances in the primitive.\n\nWhen , geometry vertices are optimized for the pre and post-vertex-shader caches.\n\nDestroys the WebGL resources held by this object. Destroying an object allows for deterministic release of WebGL resources, instead of relying on the garbage collector to destroy this object. Once an object is destroyed, it should not be used; calling any function other than will result in a exception. Therefore, assign the return value ( ) to the object as done in the example.\n• : This object was destroyed, i.e., destroy() was called. : This object was destroyed, i.e., destroy() was called.\n\nThe typed array in the attribute's format or undefined if the is no instance with id.\n\nif this object was destroyed; otherwise, .\n• : All instance geometries must have the same primitiveType. : All instance geometries must have the same primitiveType.\n• : Appearance and material have a uniform with the same name. : Appearance and material have a uniform with the same name.\n• : Primitive.modelMatrix is only supported in 3D mode. : Primitive.modelMatrix is only supported in 3D mode.\n• : Vertex texture fetch support is required to render primitives with per-instance attributes. The maximum number of vertex texture image units must be greater than zero. : Vertex texture fetch support is required to render primitives with per-instance attributes. The maximum number of vertex texture image units must be greater than zero."
    },
    {
        "link": "https://cesium.com/learn/ion-sdk/ref-doc/SphereGeometry.html",
        "document": "A description of a sphere centered at the origin. Object with the following properties: The radius of the sphere. The number of times to partition the ellipsoid into stacks. The number of times to partition the ellipsoid into radial slices. The vertex attributes to be computed.\n• : options.slicePartitions cannot be less than three. : options.slicePartitions cannot be less than three.\n• : options.stackPartitions cannot be less than three. : options.stackPartitions cannot be less than three.\n\nThe number of elements used to pack the object into an array.\n\nComputes the geometric representation of a sphere, including its vertices, indices, and a bounding sphere.\n\nStores the provided instance into the provided array.\n\nThe array that was packed into\n\nThe modified result parameter or a new SphereGeometry instance if one was not provided."
    },
    {
        "link": "https://help.agi.com/STKWebVisualizationLibrary/Primitive.html",
        "document": ""
    },
    {
        "link": "http://cesium.xin/cesium/en/Documentation1.95/SphereGeometry.html",
        "document": "A description of a sphere centered at the origin. Object with the following properties: The radius of the sphere. The number of times to partition the ellipsoid into stacks. The number of times to partition the ellipsoid into radial slices. The vertex attributes to be computed.\n• : options.slicePartitions cannot be less than three. : options.slicePartitions cannot be less than three.\n• : options.stackPartitions cannot be less than three. : options.stackPartitions cannot be less than three.\n\nThe number of elements used to pack the object into an array.\n\nComputes the geometric representation of a sphere, including its vertices, indices, and a bounding sphere.\n\nStores the provided instance into the provided array.\n\nThe array that was packed into\n\nThe modified result parameter or a new SphereGeometry instance if one was not provided."
    },
    {
        "link": "https://nrc-publications.canada.ca/eng/view/supplement?id=15a22e19-b588-4947-87ed-f5cb7cd1221c&dp=2",
        "document": ""
    },
    {
        "link": "https://cesium.com/learn/ion-sdk/ref-doc/Camera.html",
        "document": "The default heading/pitch/range that is used when the camera flies to a location that contains a bounding sphere.\n\nA scalar to multiply to the camera position and add it back after setting the camera to view the rectangle. A value of zero means the camera will view the entire , a value greater than zero will move it further away from the extent, and a value less than zero will move it close to the extent.\n\nThe default rectangle the camera will view on creation.\n\nGets the event that will be raised when the camera has changed by .\n\nIf set, the camera will not be able to rotate past this axis in either direction.\n\nThe default amount to rotate the camera when an argument is not provided to the look methods.\n\nThe default amount to move the camera when an argument is not provided to the move methods.\n\nThe default amount to rotate the camera when an argument is not provided to the rotate methods.\n\nThe default amount to move the camera when an argument is not provided to the zoom methods.\n\nThe view direction of the camera.\n\nGets the view direction of the camera in world coordinates.\n\nThe region of space in view.\n\nGets the camera heading in radians.\n\nThe factor multiplied by the the map size used to determine where to clamp the camera position when zooming out from the surface. The default is 1.5. Only valid for 2D and the map is rotatable.\n\nGets the event that will be raised when the camera has stopped moving.\n\nGets the event that will be raised at when the camera starts to move.\n\nThe amount the camera has to change before the event is raised. The value is a percentage in the [0, 1] range.\n\nGets the camera pitch in radians.\n\nThe position of the camera.\n\nGets the position of the camera in world coordinates.\n\nThe right direction of the camera.\n\nGets the right direction of the camera in world coordinates.\n\nGets the camera roll in radians.\n\nGets the camera's reference frame. The inverse of this transformation is appended to the view matrix.\n\nThe up direction of the camera.\n\nGets the up direction of the camera in world coordinates.\n\nTransform a vector or point from the camera's reference frame to world coordinates.\n\nTransform a point from the camera's reference frame to world coordinates.\n\nTransform a vector from the camera's reference frame to world coordinates.\n\nCancels the current camera flight and leaves the camera at its current location. If no flight is in progress, this function does nothing.\n\nCompletes the current camera flight and moves the camera immediately to its final destination. If no flight is in progress, this function does nothing.\n\nComputes the approximate visible rectangle on the ellipsoid.\n\nThe visible rectangle or undefined if the ellipsoid isn't visible at all.\n\nReturn the distance from the camera to the front of the bounding sphere.\n\nThe distance to the bounding sphere.\n\nFly the camera to the home view. Use to set the default view for the 3D scene. The home view for 2D and columbus view shows the entire map.\n\nFlies the camera from its current position to a new position.\n• : If either direction or up is given, then both are required. : If either direction or up is given, then both are required.\n\nGets the magnitude of the camera position. In 3D, this is the vector magnitude. In 2D and Columbus view, this is the distance to the map.\n\nThe magnitude of the position.\n\nCreate a ray from the camera position through the pixel at in world coordinates.\n\nGet the camera position needed to view a rectangle on an ellipsoid or map\n\nThe camera position needed to view the rectangle\n\nRotate each of the camera's orientation vectors around by\n\nSets the camera position and orientation using a target and offset. The target must be given in world coordinates. The offset can be either a cartesian or heading/pitch/range in the local east-north-up reference frame centered at the target. If the offset is a cartesian, then it is an offset from the center of the reference frame defined by the transformation matrix. If the offset is heading/pitch/range, then the heading and the pitch angles are defined in the reference frame defined by the transformation matrix. The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center. In 2D, there must be a top down view. The camera will be placed above the target looking down. The height above the target will be the magnitude of the offset. The heading will be determined from the offset. If the heading cannot be determined from the offset, the heading will be north.\n• : lookAt is not supported while morphing. : lookAt is not supported while morphing.\n\nSets the camera position and orientation using a target and transformation matrix. The offset can be either a cartesian or heading/pitch/range. If the offset is a cartesian, then it is an offset from the center of the reference frame defined by the transformation matrix. If the offset is heading/pitch/range, then the heading and the pitch angles are defined in the reference frame defined by the transformation matrix. The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center. In 2D, there must be a top down view. The camera will be placed above the center of the reference frame. The height above the target will be the magnitude of the offset. The heading will be determined from the offset. If the heading cannot be determined from the offset, the heading will be north.\n• : lookAtTransform is not supported while morphing. : lookAtTransform is not supported while morphing.\n\nRotates the camera around its right vector by amount, in radians, in the opposite direction of its up vector if not in 2D mode.\n\nRotates the camera around its up vector by amount, in radians, in the opposite direction of its right vector if not in 2D mode.\n\nRotates the camera around its up vector by amount, in radians, in the direction of its right vector if not in 2D mode.\n\nRotates the camera around its right vector by amount, in radians, in the direction of its up vector if not in 2D mode.\n\nTranslates the camera's position by along .\n\nTranslates the camera's position by along the opposite direction of the camera's view vector. When in 2D mode, this will zoom out the camera instead of translating the camera's position.\n\nTranslates the camera's position by along the opposite direction of the camera's up vector.\n\nTranslates the camera's position by along the camera's view vector. When in 2D mode, this will zoom in the camera instead of translating the camera's position.\n\nTranslates the camera's position by along the opposite direction of the camera's right vector.\n\nTranslates the camera's position by along the camera's right vector.\n\nTranslates the camera's position by along the camera's up vector.\n\nIf the ellipsoid or map was picked, returns the point on the surface of the ellipsoid or map in world coordinates. If the ellipsoid or map was not picked, returns undefined.\n\nRotates the camera around by . The distance of the camera's position to the center of the camera's reference frame remains the same.\n\nRotates the camera around the center of the camera's reference frame by angle downwards.\n\nRotates the camera around the center of the camera's reference frame by angle to the left.\n\nRotates the camera around the center of the camera's reference frame by angle to the right.\n\nRotates the camera around the center of the camera's reference frame by angle upwards.\n\nSwitches the frustum/projection to orthographic. This function is a no-op in 2D which will always be orthographic.\n\nSwitches the frustum/projection to perspective. This function is a no-op in 2D which must always be orthographic.\n\nRotate the camera counter-clockwise around its direction vector by amount, in radians.\n\nRotate the camera clockwise around its direction vector by amount, in radians.\n• : viewBoundingSphere is not supported while morphing. : viewBoundingSphere is not supported while morphing.\n\nTransform a vector or point from world coordinates to the camera's reference frame.\n\nTransform a point from world coordinates to the camera's reference frame.\n\nTransform a vector from world coordinates to the camera's reference frame.\n\nZooms along the opposite direction of the camera's view vector.\n\nA function that will execute when a flight is cancelled.\n\nA function that will execute when a flight completes."
    },
    {
        "link": "https://help.agi.com/STKWebVisualizationLibrary/index.html",
        "document": ""
    },
    {
        "link": "https://community.cesium.com/t/camera-api/1047",
        "document": "Over the next couple of weeks, I will be working on making the Camera API simpler to use. I plan on moving everything from CameraController up to Camera so it will be easier for new Cesium developers to find, make the API more consistent across the scene modes, and add a higher level interface comparable to functionality provided by Leaflet or OpenLayers.\n\nMany have asked for similar functionality to Leaflet or Open Layers, but not all operations they provide for 2D make sense in 3D. I’ll add new functions to change the camera state where it makes sense across all scene modes or there is a reasonable alternative for one of the modes.\n\nThere have been a few discussions about the Camera API here so any feedback or suggestions would be appreciated."
    },
    {
        "link": "https://github.com/CesiumGS/cesium/blob/main/CHANGES.md?plain=1",
        "document": ""
    },
    {
        "link": "https://classic.yarnpkg.com/en/package/@cesium/widgets",
        "document": ""
    }
]