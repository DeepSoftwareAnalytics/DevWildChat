[
    {
        "link": "https://typescriptlang.org/docs/handbook/2/functions.html",
        "document": "Functions are the basic building block of any application, whether they’re local functions, imported from another module, or methods on a class. They’re also values, and just like other values, TypeScript has many ways to describe how functions can be called. Let’s learn about how to write types that describe functions.\n\nThe simplest way to describe a function is with a function type expression. These types are syntactically similar to arrow functions:\n\nThe syntax means “a function with one parameter, named , of type , that doesn’t have a return value”. Just like with function declarations, if a parameter type isn’t specified, it’s implicitly .\n\nOf course, we can use a type alias to name a function type:\n\nIn JavaScript, functions can have properties in addition to being callable. However, the function type expression syntax doesn’t allow for declaring properties. If we want to describe something callable with properties, we can write a call signature in an object type:\n\nNote that the syntax is slightly different compared to a function type expression - use between the parameter list and the return type rather than .\n\nJavaScript functions can also be invoked with the operator. TypeScript refers to these as constructors because they usually create a new object. You can write a construct signature by adding the keyword in front of a call signature:\n\nSome objects, like JavaScript’s object, can be called with or without . You can combine call and construct signatures in the same type arbitrarily:\n\nIt’s common to write a function where the types of the input relate to the type of the output, or where the types of two inputs are related in some way. Let’s consider for a moment a function that returns the first element of an array:\n\nThis function does its job, but unfortunately has the return type . It’d be better if the function returned the type of the array element.\n\nIn TypeScript, generics are used when we want to describe a correspondence between two values. We do this by declaring a type parameter in the function signature:\n\nBy adding a type parameter to this function and using it in two places, we’ve created a link between the input of the function (the array) and the output (the return value). Now when we call it, a more specific type comes out:\n\nNote that we didn’t have to specify in this sample. The type was inferred - chosen automatically - by TypeScript.\n\nWe can use multiple type parameters as well. For example, a standalone version of would look like this:\n\nNote that in this example, TypeScript could infer both the type of the type parameter (from the given array), as well as the type parameter based on the return value of the function expression ( ).\n\nWe’ve written some generic functions that can work on any kind of value. Sometimes we want to relate two values, but can only operate on a certain subset of values. In this case, we can use a constraint to limit the kinds of types that a type parameter can accept.\n\nLet’s write a function that returns the longer of two values. To do this, we need a property that’s a number. We constrain the type parameter to that type by writing an clause:\n\nThere are a few interesting things to note in this example. We allowed TypeScript to infer the return type of . Return type inference also works on generic functions.\n\nBecause we constrained to , we were allowed to access the property of the and parameters. Without the type constraint, we wouldn’t be able to access those properties because the values might have been some other type without a length property.\n\nThe types of and were inferred based on the arguments. Remember, generics are all about relating two or more values with the same type!\n\nFinally, just as we’d like, the call to is rejected because the type doesn’t have a property.\n\nIt might look like this function is OK - is constrained to , and the function either returns or a value matching that constraint. The problem is that the function promises to return the same kind of object as was passed in, not just some object matching the constraint. If this code were legal, you could write code that definitely wouldn’t work:\n\nTypeScript can usually infer the intended type arguments in a generic call, but not always. For example, let’s say you wrote a function to combine two arrays:\n\nNormally it would be an error to call this function with mismatched arrays:\n\nIf you intended to do this, however, you could manually specify :\n\nWriting generic functions is fun, and it can be easy to get carried away with type parameters. Having too many type parameters or using constraints where they aren’t needed can make inference less successful, frustrating callers of your function.\n\nHere are two ways of writing a function that appear similar:\n\nThese might seem identical at first glance, but is a much better way to write this function. Its inferred return type is , but ’s inferred return type is because TypeScript has to resolve the expression using the constraint type, rather than “waiting” to resolve the element during a call.\n\nWe’ve created a type parameter that doesn’t relate two values. That’s always a red flag, because it means callers wanting to specify type arguments have to manually specify an extra type argument for no reason. doesn’t do anything but make the function harder to read and reason about!\n\nType Parameters Should Appear Twice\n\nSometimes we forget that a function might not need to be generic:\n\nWe could just as easily have written a simpler version:\n\nRemember, type parameters are for relating the types of multiple values. If a type parameter is only used once in the function signature, it’s not relating anything. This includes the inferred return type; for example, if was part of the inferred return type of , it would be relating the argument and return types, so would be used twice despite appearing only once in the written code.\n\nFunctions in JavaScript often take a variable number of arguments. For example, the method of takes an optional digit count:\n\nWe can model this in TypeScript by marking the parameter as optional with :\n\nAlthough the parameter is specified as type , the parameter will actually have the type because unspecified parameters in JavaScript get the value .\n\nYou can also provide a parameter default:\n\nNow in the body of , will have type because any argument will be replaced with . Note that when a parameter is optional, callers can always pass , as this simply simulates a “missing” argument:\n\nOnce you’ve learned about optional parameters and function type expressions, it’s very easy to make the following mistakes when writing functions that invoke callbacks:\n\nWhat people usually intend when writing as an optional parameter is that they want both of these calls to be legal:\n\nWhat this actually means is that might get invoked with one argument. In other words, the function definition says that the implementation might look like this:\n\nIn turn, TypeScript will enforce this meaning and issue errors that aren’t really possible:\n\nIn JavaScript, if you call a function with more arguments than there are parameters, the extra arguments are simply ignored. TypeScript behaves the same way. Functions with fewer parameters (of the same types) can always take the place of functions with more parameters.\n\nSome JavaScript functions can be called in a variety of argument counts and types. For example, you might write a function to produce a that takes either a timestamp (one argument) or a month/day/year specification (three arguments).\n\nIn TypeScript, we can specify a function that can be called in different ways by writing overload signatures. To do this, write some number of function signatures (usually two or more), followed by the body of the function:\n\nIn this example, we wrote two overloads: one accepting one argument, and another accepting three arguments. These first two signatures are called the overload signatures.\n\nThen, we wrote a function implementation with a compatible signature. Functions have an implementation signature, but this signature can’t be called directly. Even though we wrote a function with two optional parameters after the required one, it can’t be called with two parameters!\n\nThis is a common source of confusion. Often people will write code like this and not understand why there is an error:\n\nAgain, the signature used to write the function body can’t be “seen” from the outside.\n\nThe implementation signature must also be compatible with the overload signatures. For example, these functions have errors because the implementation signature doesn’t match the overloads in a correct way:\n\nLike generics, there are a few guidelines you should follow when using function overloads. Following these principles will make your function easier to call, easier to understand, and easier to implement.\n\nLet’s consider a function that returns the length of a string or an array:\n\nThis function is fine; we can invoke it with strings or arrays. However, we can’t invoke it with a value that might be a string or an array, because TypeScript can only resolve a function call to a single overload:\n\nBecause both overloads have the same argument count and same return type, we can instead write a non-overloaded version of the function:\n\nThis is much better! Callers can invoke this with either sort of value, and as an added bonus, we don’t have to figure out a correct implementation signature.\n\nTypeScript will infer what the should be in a function via code flow analysis, for example in the following:\n\nTypeScript understands that the function has a corresponding which is the outer object . , heh, can be enough for a lot of cases, but there are a lot of cases where you need more control over what object represents. The JavaScript specification states that you cannot have a parameter called , and so TypeScript uses that syntax space to let you declare the type for in the function body.\n\nThis pattern is common with callback-style APIs, where another object typically controls when your function is called. Note that you need to use and not arrow functions to get this behavior:\n\nOther Types to Know About\n\nThere are some additional types you’ll want to recognize that appear often when working with function types. Like all types, you can use them everywhere, but these are especially relevant in the context of functions.\n\nrepresents the return value of functions which don’t return a value. It’s the inferred type any time a function doesn’t have any statements, or doesn’t return any explicit value from those return statements:\n\nIn JavaScript, a function that doesn’t return any value will implicitly return the value . However, and are not the same thing in TypeScript. There are further details at the end of this chapter.\n\nThe special type refers to any value that isn’t a primitive ( , , , , , , or ). This is different from the empty object type , and also different from the global type . It’s very likely you will never use .\n\nNote that in JavaScript, function values are objects: They have properties, have in their prototype chain, are , you can call on them, and so on. For this reason, function types are considered to be s in TypeScript.\n\nThe type represents any value. This is similar to the type, but is safer because it’s not legal to do anything with an value:\n\nThis is useful when describing function types because you can describe functions that accept any value without having values in your function body.\n\nConversely, you can describe a function that returns a value of unknown type:\n\nSome functions never return a value:\n\nThe type represents values which are never observed. In a return type, this means that the function throws an exception or terminates execution of the program.\n\nalso appears when TypeScript determines there’s nothing left in a union.\n\nThe global type describes properties like , , , and others present on all function values in JavaScript. It also has the special property that values of type can always be called; these calls return :\n\nThis is an untyped function call and is generally best avoided because of the unsafe return type.\n\nIf you need to accept an arbitrary function but don’t intend to call it, the type is generally safer.\n\nIn addition to using optional parameters or overloads to make functions that can accept a variety of fixed argument counts, we can also define functions that take an unbounded number of arguments using rest parameters.\n\nA rest parameter appears after all other parameters, and uses the syntax:\n\nIn TypeScript, the type annotation on these parameters is implicitly instead of , and any type annotation given must be of the form or , or a tuple type (which we’ll learn about later).\n\nConversely, we can provide a variable number of arguments from an iterable object (for example, an array) using the spread syntax. For example, the method of arrays takes any number of arguments:\n\nNote that in general, TypeScript does not assume that arrays are immutable. This can lead to some surprising behavior:\n\nThe best fix for this situation depends a bit on your code, but in general a context is the most straightforward solution:\n\nUsing rest arguments may require turning on when targeting older runtimes.\n\nYou can use parameter destructuring to conveniently unpack objects provided as an argument into one or more local variables in the function body. In JavaScript, it looks like this:\n\nThe type annotation for the object goes after the destructuring syntax:\n\nThis can look a bit verbose, but you can use a named type here as well:\n\nThe return type for functions can produce some unusual, but expected behavior.\n\nContextual typing with a return type of does not force functions to not return something. Another way to say this is a contextual function type with a return type ( ), when implemented, can return any other value, but it will be ignored.\n\nThus, the following implementations of the type are valid:\n\nAnd when the return value of one of these functions is assigned to another variable, it will retain the type of :\n\nThis behavior exists so that the following code is valid even though returns a number and the method expects a function with a return type of .\n\nThere is one other special case to be aware of, when a literal function definition has a return type, that function must not return anything.\n\nFor more on please refer to these other documentation entries:"
    },
    {
        "link": "https://stackoverflow.com/questions/12736269/how-to-declare-return-types-for-functions-in-typescript",
        "document": "You can read more about function types in the language specification in sections 3.5.3.5 and 3.5.5.\n\nThe TypeScript compiler will infer types when it can, and this is done you do not need to specify explicit types. so for the greeter example, greet() returns a string literal, which tells the compiler that the type of the function is a string, and no need to specify a type. so for instance in this sample, I have the greeter class with a greet method that returns a string, and a variable that is assigned to number literal. the compiler will infer both types and you will get an error if you try to assign a string to a number.\n\nSimilarly, this sample will cause an error as the compiler, given the information, has no way to decide the type, and this will be a place where you have to have an explicit return type.\n\nThis, however, will work:"
    },
    {
        "link": "https://typescriptlang.org/docs/handbook/2/everyday-types.html",
        "document": "In this chapter, we’ll cover some of the most common types of values you’ll find in JavaScript code, and explain the corresponding ways to describe those types in TypeScript. This isn’t an exhaustive list, and future chapters will describe more ways to name and use other types.\n\nTypes can also appear in many more places than just type annotations. As we learn about the types themselves, we’ll also learn about the places where we can refer to these types to form new constructs.\n\nWe’ll start by reviewing the most basic and common types you might encounter when writing JavaScript or TypeScript code. These will later form the core building blocks of more complex types.\n\nJavaScript has three very commonly used primitives: , , and . Each has a corresponding type in TypeScript. As you might expect, these are the same names you’d see if you used the JavaScript operator on a value of those types:\n• is for numbers like . JavaScript does not have a special runtime value for integers, so there’s no equivalent to or - everything is simply\n• is for the two values and\n\nTo specify the type of an array like , you can use the syntax ; this syntax works for any type (e.g. is an array of strings, and so on). You may also see this written as , which means the same thing. We’ll learn more about the syntax when we cover generics.\n\nTypeScript also has a special type, , that you can use whenever you don’t want a particular value to cause typechecking errors.\n\nWhen a value is of type , you can access any properties of it (which will in turn be of type ), call it like a function, assign it to (or from) a value of any type, or pretty much anything else that’s syntactically legal:\n\nThe type is useful when you don’t want to write out a long type just to convince TypeScript that a particular line of code is okay.\n\nWhen you don’t specify a type, and TypeScript can’t infer it from context, the compiler will typically default to .\n\nYou usually want to avoid this, though, because isn’t type-checked. Use the compiler flag to flag any implicit as an error.\n\nWhen you declare a variable using , , or , you can optionally add a type annotation to explicitly specify the type of the variable:\n\nIn most cases, though, this isn’t needed. Wherever possible, TypeScript tries to automatically infer the types in your code. For example, the type of a variable is inferred based on the type of its initializer:\n\nFor the most part you don’t need to explicitly learn the rules of inference. If you’re starting out, try using fewer type annotations than you think - you might be surprised how few you need for TypeScript to fully understand what’s going on.\n\nFunctions are the primary means of passing data around in JavaScript. TypeScript allows you to specify the types of both the input and output values of functions.\n\nWhen you declare a function, you can add type annotations after each parameter to declare what types of parameters the function accepts. Parameter type annotations go after the parameter name:\n\nWhen a parameter has a type annotation, arguments to that function will be checked:\n\nYou can also add return type annotations. Return type annotations appear after the parameter list:\n\nMuch like variable type annotations, you usually don’t need a return type annotation because TypeScript will infer the function’s return type based on its statements. The type annotation in the above example doesn’t change anything. Some codebases will explicitly specify a return type for documentation purposes, to prevent accidental changes, or just for personal preference.\n\nIf you want to annotate the return type of a function which returns a promise, you should use the type:\n\nAnonymous functions are a little bit different from function declarations. When a function appears in a place where TypeScript can determine how it’s going to be called, the parameters of that function are automatically given types.\n\nEven though the parameter didn’t have a type annotation, TypeScript used the types of the function, along with the inferred type of the array, to determine the type will have.\n\nThis process is called contextual typing because the context that the function occurred within informs what type it should have.\n\nSimilar to the inference rules, you don’t need to explicitly learn how this happens, but understanding that it does happen can help you notice when type annotations aren’t needed. Later, we’ll see more examples of how the context that a value occurs in can affect its type.\n\nApart from primitives, the most common sort of type you’ll encounter is an object type. This refers to any JavaScript value with properties, which is almost all of them! To define an object type, we simply list its properties and their types.\n\nFor example, here’s a function that takes a point-like object:\n\nHere, we annotated the parameter with a type with two properties - and - which are both of type . You can use or to separate the properties, and the last separator is optional either way.\n\nThe type part of each property is also optional. If you don’t specify a type, it will be assumed to be .\n\nObject types can also specify that some or all of their properties are optional. To do this, add a after the property name:\n\nIn JavaScript, if you access a property that doesn’t exist, you’ll get the value rather than a runtime error. Because of this, when you read from an optional property, you’ll have to check for before using it.\n\nTypeScript’s type system allows you to build new types out of existing ones using a large variety of operators. Now that we know how to write a few types, it’s time to start combining them in interesting ways.\n\nThe first way to combine types you might see is a union type. A union type is a type formed from two or more other types, representing values that may be any one of those types. We refer to each of these types as the union’s members.\n\nLet’s write a function that can operate on strings or numbers:\n\nIt’s easy to provide a value matching a union type - simply provide a type matching any of the union’s members. If you have a value of a union type, how do you work with it?\n\nTypeScript will only allow an operation if it is valid for every member of the union. For example, if you have the union , you can’t use methods that are only available on :\n\nThe solution is to narrow the union with code, the same as you would in JavaScript without type annotations. Narrowing occurs when TypeScript can deduce a more specific type for a value based on the structure of the code.\n\nFor example, TypeScript knows that only a value will have a value :\n\nAnother example is to use a function like :\n\nNotice that in the branch, we don’t need to do anything special - if wasn’t a , then it must have been a .\n\nSometimes you’ll have a union where all the members have something in common. For example, both arrays and strings have a method. If every member in a union has a property in common, you can use that property without narrowing:\n\nWe’ve been using object types and union types by writing them directly in type annotations. This is convenient, but it’s common to want to use the same type more than once and refer to it by a single name.\n\nA type alias is exactly that - a name for any type. The syntax for a type alias is:\n\nYou can actually use a type alias to give a name to any type at all, not just an object type. For example, a type alias can name a union type:\n\nNote that aliases are only aliases - you cannot use type aliases to create different/distinct “versions” of the same type. When you use the alias, it’s exactly as if you had written the aliased type. In other words, this code might look illegal, but is OK according to TypeScript because both types are aliases for the same type:\n\nAn interface declaration is another way to name an object type:\n\nJust like when we used a type alias above, the example works just as if we had used an anonymous object type. TypeScript is only concerned with the structure of the value we passed to - it only cares that it has the expected properties. Being concerned only with the structure and capabilities of types is why we call TypeScript a structurally typed type system.\n\nType aliases and interfaces are very similar, and in many cases you can choose between them freely. Almost all features of an are available in , the key distinction is that a type cannot be re-opened to add new properties vs an interface which is always extendable.\n\nYou’ll learn more about these concepts in later chapters, so don’t worry if you don’t understand all of these right away.\n• Prior to TypeScript version 4.2, type alias names may appear in error messages, sometimes in place of the equivalent anonymous type (which may or may not be desirable). Interfaces will always be named in error messages.\n• Type aliases may not participate in declaration merging, but interfaces can.\n• Interfaces may only be used to declare the shapes of objects, not rename primitives.\n• Interface names will always appear in their original form in error messages, but only when they are used by name.\n• Using interfaces with can often be more performant for the compiler than type aliases with intersections\n\nFor the most part, you can choose based on personal preference, and TypeScript will tell you if it needs something to be the other kind of declaration. If you would like a heuristic, use until you need to use features from .\n\nSometimes you will have information about the type of a value that TypeScript can’t know about.\n\nFor example, if you’re using , TypeScript only knows that this will return some kind of , but you might know that your page will always have an with a given ID.\n\nIn this situation, you can use a type assertion to specify a more specific type:\n\nLike a type annotation, type assertions are removed by the compiler and won’t affect the runtime behavior of your code.\n\nYou can also use the angle-bracket syntax (except if the code is in a file), which is equivalent:\n\nTypeScript only allows type assertions which convert to a more specific or less specific version of a type. This rule prevents “impossible” coercions like:\n\nSometimes this rule can be too conservative and will disallow more complex coercions that might be valid. If this happens, you can use two assertions, first to (or , which we’ll introduce later), then to the desired type:\n\nIn addition to the general types and , we can refer to specific strings and numbers in type positions.\n\nOne way to think about this is to consider how JavaScript comes with different ways to declare a variable. Both and allow for changing what is held inside the variable, and does not. This is reflected in how TypeScript creates types for literals.\n\nBy themselves, literal types aren’t very valuable:\n\nIt’s not much use to have a variable that can only have one value!\n\nBut by combining literals into unions, you can express a much more useful concept - for example, functions that only accept a certain set of known values:\n\nNumeric literal types work the same way:\n\nOf course, you can combine these with non-literal types:\n\nThere’s one more kind of literal type: boolean literals. There are only two boolean literal types, and as you might guess, they are the types and . The type itself is actually just an alias for the union .\n\nWhen you initialize a variable with an object, TypeScript assumes that the properties of that object might change values later. For example, if you wrote code like this:\n\nTypeScript doesn’t assume the assignment of to a field which previously had is an error. Another way of saying this is that must have the type , not , because types are used to determine both reading and writing behavior.\n\nThe same applies to strings:\n\nIn the above example is inferred to be , not . Because code can be evaluated between the creation of and the call of which could assign a new string like to , TypeScript considers this code to have an error.\n\nThere are two ways to work around this.\n• You can change the inference by adding a type assertion in either location: Change 1 means “I intend for to always have the literal type ”, preventing the possible assignment of to that field after. Change 2 means “I know for other reasons that has the value “.\n• You can use to convert the entire object to be type literals:\n\nThe suffix acts like but for the type system, ensuring that all properties are assigned the literal type instead of a more general version like or .\n\nJavaScript has two primitive values used to signal absent or uninitialized value: and .\n\nTypeScript has two corresponding types by the same names. How these types behave depends on whether you have the option on.\n\nWith off, values that might be or can still be accessed normally, and the values and can be assigned to a property of any type. This is similar to how languages without null checks (e.g. C#, Java) behave. The lack of checking for these values tends to be a major source of bugs; we always recommend people turn on if it’s practical to do so in their codebase.\n\nWith on, when a value is or , you will need to test for those values before using methods or properties on that value. Just like checking for before using an optional property, we can use narrowing to check for values that might be :\n\nTypeScript also has a special syntax for removing and from a type without doing any explicit checking. Writing after any expression is effectively a type assertion that the value isn’t or :\n\nJust like other type assertions, this doesn’t change the runtime behavior of your code, so it’s important to only use when you know that the value can’t be or .\n\nEnums are a feature added to JavaScript by TypeScript which allows for describing a value which could be one of a set of possible named constants. Unlike most TypeScript features, this is not a type-level addition to JavaScript but something added to the language and runtime. Because of this, it’s a feature which you should know exists, but maybe hold off on using unless you are sure. You can read more about enums in the Enum reference page.\n\nIt’s worth mentioning the rest of the primitives in JavaScript which are represented in the type system. Though we will not go into depth here.\n\nFrom ES2020 onwards, there is a primitive in JavaScript used for very large integers, :\n\nYou can learn more about BigInt in the TypeScript 3.2 release notes.\n\nThere is a primitive in JavaScript used to create a globally unique reference via the function :\n\nYou can learn more about them in Symbols reference page."
    },
    {
        "link": "https://stackoverflow.com/questions/67621745/typescript-return-type-narrowing-based-on-boolean-option-argument",
        "document": "I am trying to create a type for my function so that the return type changes based on a value passed to it. I've considered Typescript return type depending on parameter and following that to (almost) the letter seems to work just fine. In my project however, I must use arrow functions. Also, I'd like to avoid overloads if at all possible. Consider this signature and implementation:\n\nwhen I call the function like this:\n\nI get a type mismatch as TS thinkgs returns a not the desired . I was under the impression that using the ternary operator would be enough information for TS to understand that the return type would change based on its condition.\n\nFor the complete editable example:"
    },
    {
        "link": "https://typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html",
        "document": "❌ Don’t ever use the types , , , , or These types refer to non-primitive boxed objects that are almost never used appropriately in JavaScript code.\n\n✅ Do use the types , , , and .\n\nInstead of , use the non-primitive type (added in TypeScript 2.2).\n\n❌ Don’t ever have a generic type which doesn’t use its type parameter. See more details in TypeScript FAQ page.\n\n❌ Don’t use as a type unless you are in the process of migrating a JavaScript project to TypeScript. The compiler effectively treats as “please turn off type checking for this thing”. It is similar to putting an comment around every usage of the variable. This can be very helpful when you are first migrating a JavaScript project to TypeScript as you can set the type for stuff you haven’t migrated yet as , but in a full TypeScript project you are disabling type checking for any parts of your program that use it.\n\nIn cases where you don’t know what type you want to accept, or when you want to accept anything because you will be blindly passing it through without interacting with it, you can use .\n\n❌ Don’t use the return type for callbacks whose value will be ignored:\n\n✅ Do use the return type for callbacks whose value will be ignored:\n\n❔ Why: Using is safer because it prevents you from accidentally using the return value of in an unchecked way:\n\n❌ Don’t use optional parameters in callbacks unless you really mean it:\n\nThis has a very specific meaning: the callback might be invoked with 1 argument or might be invoked with 2 arguments. The author probably intended to say that the callback might not care about the parameter, but there’s no need to make the parameter optional to accomplish this — it’s always legal to provide a callback that accepts fewer arguments.\n\n❌ Don’t write separate overloads that differ only on callback arity:\n\n✅ Do write a single overload using the maximum arity:\n\n❔ Why: It’s always legal for a callback to disregard a parameter, so there’s no need for the shorter overload. Providing a shorter callback first allows incorrectly-typed functions to be passed in because they match the first overload.\n\n❌ Don’t put more general overloads before more specific overloads:\n\n✅ Do sort overloads by putting the more general signatures after more specific signatures:\n\n❔ Why: TypeScript chooses the first matching overload when resolving function calls. When an earlier overload is “more general” than a later one, the later one is effectively hidden and cannot be called.\n\n❌ Don’t write several overloads that differ only in trailing parameters:\n\n✅ Do use optional parameters whenever possible:\n\nNote that this collapsing should only occur when all overloads have the same return type.\n\n❔ Why: This is important for two reasons.\n\nTypeScript resolves signature compatibility by seeing if any signature of the target can be invoked with the arguments of the source, and extraneous arguments are allowed. This code, for example, exposes a bug only when the signature is correctly written using optional parameters:\n\nThe second reason is when a consumer uses the “strict null checking” feature of TypeScript. Because unspecified parameters appear as in JavaScript, it’s usually fine to pass an explicit to a function with optional arguments. This code, for example, should be OK under strict nulls:\n\n❌ Don’t write overloads that differ by type in only one argument position:\n\n✅ Do use union types whenever possible:\n\nNote that we didn’t make optional here because the return types of the signatures differ.\n\n❔ Why: This is important for people who are “passing through” a value to your function:"
    },
    {
        "link": "https://typescriptlang.org/docs/handbook/advanced-types.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/61692571/is-it-possible-to-define-custom-function-types-in-typescript",
        "document": "To specify an object has first and last property, we specify it as type Person, is there similar feature available for function in Typescript For ex.\n\nFun1 and Fun2 are functions of same type, so can we define some type in TypeScript like this"
    },
    {
        "link": "https://stackoverflow.com/questions/73115640/define-and-extend-custom-types-in-typescript",
        "document": "I am trying to define custom types in TypeScript with some additional extension methods, also want to allow other uses of my library to extend this type as well.\n\nWant to implement the toJson method and more utility functions, I tried to do that by creating two files: domain.d.ts with this code:\n\nand tried to add new file domain.extension.ts with the following code:\n\nBut I am getting errors such as:\n\nError TS2693 (TS) 'Domain' only refers to a type, but is being used as a value here.\n\ndon't know exactly how to achieve this, as I am a beginner in JavaScript.\n\nFor more context, here is how I am planning to use this code:"
    },
    {
        "link": "https://nozzlegear.com/blog/build-a-simple-object-validation-utility-with-typescript",
        "document": "TypeScript has become an incredibly powerful language, with a type system that helps developers like you and me build similarly powerful functions, tools, utilities and classes. It's gone from something that was neat and definitely useful in the frontend, to a language that I honestly prefer to use everywhere I possibly can. I've even begun rewriting one my biggest Shopify applications in TypeScript because the type system makes C#'s look like woefully ill-equipped by comparison (even with the new type switching in C# 7).\n\nSince the large majority of my work is building web apps for Shopify -- which you can hire me for, let's talk at joshua@nozzlegear.com -- a lot of my development time involves building out API endpoints that the frontend part of an app can call. I've already covered how you can use a tool called Reinforced.Typings to sync your expected request/response object types from a C# backend to a TypeScript frontend, but if you're using TypeScript on your server too, such a tool is unnecessary (because you can just share your type declarations across the project). Instead the real bulk of the work is in validating the objects and data your endpoints receive.\n\nAnd that brings us to the point of this post: how can you easily validate objects or types using TypeScript? Yes, a simple check will work, but if you have dozens of properties on dozens (or potentially hundreds) of expected objects, that will very quickly turn into way too many checks. Moreover, if you add a property to your object model and forget to check for it, you won't get any warnings or help from the TypeScript compiler because you're not checking the shape of the object itself, just its individual properties.\n\nThe problem is, just because you're using TypeScript on the frontend and the backend (or syncing types between C# and TypeScript with a tool like Reinforced.Typings), that doesn't mean you don't have to check that an object is what you expect it to be. Mistakes happen, and that property you're expecting to be a boolean might be a falsey or even undefined. Or maybe there's a user out there with an agressive cache, or a user who hasn't refreshed the page since your last update, and their script is still sending data that was valid in a previous version but not in the latest version.\n\nBefore we begin validating, we need to set up a strict return type for all validation functions that will tell us if the value was valid or if it contained an error. Both anonymous functions passed to the validator and the validator classes that we'll build soon will use this return type. We should get the same return type whether we use a validator class or a regular function.\n\nBy using a union type for the result, the TypeScript compiler will know which case we're dealing with when we test the property. That is to say, if we test then TypeScript knows we have a property too, but if then TypeScript knows there's a instead.\n\nWe'll also need to quickly set up a dummy interface for the object we're going to validate throughout the rest of this post. It looks like this:\n\nOne of my requirements for validating objects is that the validation mechanism should accept any random function I give it, and then use that function to validate a value. This requirement evolved from using validation packages like Joi, which had (in my opinion) unnecessarily confusing and verbose methods for doing things like \"if Property is true then validate for case , but if its false then validate for case \". If you take advantage of union types and literals in TypeScript's type system, there may be cases where you validate differently based on a certain property you receive, and I found that difficult to do in Joi to the point that I would rather just use a function that validates the value itself.\n\nSo let's take our first whack at a validation function. It's going to receive a value that we don't know anything about, and it should return that type, where is the interface:\n\nThis looks pretty simple, if not a little verbose, and it has a few things going for it; chiefly, it's easy to read and easy to reason about. The rules are laid out there in the blocks and there's nothing magic going on. However, it does have a couple of problems:\n• There are too many blocks. Yes, the code above is just fine and there's nothing wrong with it if you're only dealing with one object that has three properties, but this quickly becomes far too verbose and bloated when you apply it to even a \"small\" API. It easily violates the DRY principle.\n• Lots of \"guarding\" must be done to first ensure the properties are actually the type you expect them to be. You don't want your validation functions throwing errors, so you need to first check that is actually a string before you can check its length.\n\nLet's try to clean this up a bit and move all of these checks into their own functions that can be reused. We can also add some improvements by using the TypeScript guard functions, which will tell the TypeScript compiler that a value is of a certain type (e.g. the value is a string) if it passes the function:\n\nAgain, this works pretty well! However, it can still get a little messy and verbose when you need to combine a bunch of rules though. For example, what if had to: 1) be a string; 2) not be empty; 3) have a length less than 20; and 4) not be equal to ? You quickly balloon into four blocks and again, this eventually becomes untenable when applied to a \"real\" API.\n\nWhat we really need is a validation function that is both chainable and reusable, i.e. you can use -- something that can express all of our rules on one concise line. In the .NET world they call these \"fluent\" methods, and they're pretty darn easy to build in TypeScript or JavaScript; all you need to do is return the same class (or a new instance of it that preserves the last one's settings) after each function.\n\nTo accomplish this, we'll create some Validator classes that will focus on validating one type of value (e.g. string, boolean, number, object). Each Validator class is going to implement an interface, where is the type that the validator handles. All implementors will have a function that accepts a single value (the value that's being validated) and returns the interface that we have already declared above:\n\nBy setting the value type to , the TypeScript compiler will force us to check that the value is exactly the type we want it to be before we can even attempt to validate it. That is to say, if the StringValidator we're about to build wants to validate a string, it must first check that the value is even a string type before anything can be done with it. This helps eliminate entire classes of bugs, because you never know what you're going to get in your validation functions -- that's why you're vlaidating, after all.\n\nNow that we have the interface, we can build our first implementation, a . This validator will contain functions for validating string values. It will internally keep track of an array of StringRule objects that will be updated or added to each time one of its rules are invoked. The important bit is that every rule function must return the StringValidator -- this is what makes the functions chainable.\n\nWith that small ruleset in place, we can set up a switch statement in the function and return either an okay result if an individual rule passes, or an error result if it doesn't. Since we used a union type of several different interfaces for the StringRule, the TypeScript compiler will know when the rule has a , or property, complete with intellisense. Depending on your tsconfig.json settings, it will also complain if you forget to check each different case in a switch statement.\n\nAnd finally, the last piece of the StringValidator is the function. It will loop through each rule and check it, and then short-circuit the loop to return an error result if any rule doesn't pass. If all rules pass, an okay result will be returned and the value will have passed all validation rules!\n\nRemember, also, that the value received by the function is , so we have to test if it's a string before we can check each rule.\n\nAnd that's the string validator! Since each rule will return itself we can easily set up a chain of multiple rules and, when finished, call to test the value against them.\n\nRemember that code snippet above, the one with all of the blocks checking if the string is a string, not empty, has a max length of 20, and is not equal to ? Here's how that's implemented with the StringValidator:\n\nNow that's a nice improvement from the blocks above, although, again, there's nothing wrong with using some simple checks for validation if it fits the bill. In my case, the APIs I build deal with lots and lots of objects, and different versions of those objects when things inevitably change. These utility validation classes save a ton of time and are, as we can see above, pretty simple to build.\n\nWhile implementing these validators is fairly straightforward as seen with the StringValidator, I'm not going to implement all of the validators for numbers, booleans, arrays, etc. Instead, let's skip straight to the most useful one: the ShapeValidator for validating the shapes and individual properties of objects.\n\nWhile the other type validators make testing individual values super simple, it still doesn't help us when properties are added to an object. We get no compiler warning that a new property hasn't been tested or validated. That's where the ShapeValidator comes in! We can have it receive any generic object type, and then set it up to require that every property gets checked. If a new property is added to the type, the TypeScript compiler will give a warning that the property needs to be validated. The same goes if a property is removed from the type.\n\nRather than having specific validation rules itself, the ShapeValidator will use other validators to check each property. This means that the ShapeValidator can even recursively check child objects by using another ShapeValidator. Personally I also find it very useful to also allow random functions for each property, as there are sometimes cases where I want to change which validator gets used based on one of the properties on the object itself.\n\nLet's start off by defining a type and a guard function. We'll need the following:\n• A type -- all of the properties on the validation object will need to be this type. It can either be an IValidator or a function that receives an value and returns Result (the same return type as ).\n• A type, which will take any type (as long as it's an object and not a string, bool, etc.) and morph all of the properties into . This is what's doing the \"magic\" for the ShapeValidator, it's going to give us intellisense and compiler protection for every property on the type being validated.\n• A guard function for working with , which the TypeScript compiler will use to decide if a value is an IValidator or one of the custom validation functions that returns a result.\n\nHere's what that looks like:\n\nAnd now we can define the ShapeValidator itself. Instead of adding rules to it, though, it's going to be the only validator that requires an argument: a , which, again, is just the \"shape\" of the type being validated, but with all properties set to an IValidator or validation function. We'll see an example of that in a minute.\n\nThe only other thing that the ShapeValidator will need is the function that all other IValidators have. Inside of that function, we'll get the properties on the shape that was passed in and go through them one-by-one, checking the passed in value against each of them.\n\nAnd there's the ShapeValidator! With this, you can easily validate that both the value and the \"shape\" of the objects you're receiving are what you expect them to be. Here's how you'd use the ShapeValidator in combination with the StringValidator and a custom validation function:\n\nNow you can use that validator instance to validate any value under the sun, including arrays, strings, null, undefined, and so on. The validation will only pass if it's an object that has the exact properties you passed in when creating the validator:\n\nHere's the best part: since it's pure TypeScript (er, JavaScript) with zero node dependencies, you can even use this same validation utility in the browser before you even send the request!\n\nBeware: only return the values you expect\n\nWhile the ShapeValidator is now fully functional and ready to go, there's one last thing you should know about before you put this into production: the ShapeValidator is returning exactly what it's given if the object passes all validation. That doesn't sound likea problem at first glance, and in many cases it's not, but I've been bitten by this once before.\n\nImagine a scenario in which you've built an app that uses a document-style database such as MongoDB or CouchDB, and you have an API set up in front of them. Like a good developer, you're validating all of the input you're receiving before you put data in the database with the ShapeValidator that we just built above. But, because the ShapeValidator is actually returning the exact value it's been given, you end up unknowingly dumping data in your database that you didn't intend!\n\nUh-oh! You've just inserted the property into your database alongside the properties you validated. Granted, this is a fabricated scenario, and in many cases you're probably transforming the request data into something else before storing it in your database, but this is still a problem that you need to watch for.\n\nLuckily, the ShapeValidator can easily be adjusted to only return the properties that you're expecting (i.e. the ones that you're validating). All we need to do is change to use a reducer function rather than a loop when iterating over the validators. If a property passes validation, you tack it onto the output object and return it once all properties have been looped through.\n\nThere we go, the ShapeValidator is officially complete! Now it will only return the exact properties that it's expected to validate. As a sidenote, this is kind of looping and reducing is one of my favorite parts of functional programming, and is very prevalent in more functional languages like F#. It's such a joy that we can use functional paradigms in TypeScript/JavaScript.\n\nAs always, I'm available for freelancing or consulting engagements not only with functional languages like TypeScript, JavaScript and F#, but also more object-oriented languages like C#, Java and Dart! If you're looking for a developer to build your web app, Shopify app, mobile app or otherwise, send me an email at joshua@nozzlegear.com and let's talk!"
    },
    {
        "link": "https://typescriptlang.org/docs/handbook/2/functions.html",
        "document": "Functions are the basic building block of any application, whether they’re local functions, imported from another module, or methods on a class. They’re also values, and just like other values, TypeScript has many ways to describe how functions can be called. Let’s learn about how to write types that describe functions.\n\nThe simplest way to describe a function is with a function type expression. These types are syntactically similar to arrow functions:\n\nThe syntax means “a function with one parameter, named , of type , that doesn’t have a return value”. Just like with function declarations, if a parameter type isn’t specified, it’s implicitly .\n\nOf course, we can use a type alias to name a function type:\n\nIn JavaScript, functions can have properties in addition to being callable. However, the function type expression syntax doesn’t allow for declaring properties. If we want to describe something callable with properties, we can write a call signature in an object type:\n\nNote that the syntax is slightly different compared to a function type expression - use between the parameter list and the return type rather than .\n\nJavaScript functions can also be invoked with the operator. TypeScript refers to these as constructors because they usually create a new object. You can write a construct signature by adding the keyword in front of a call signature:\n\nSome objects, like JavaScript’s object, can be called with or without . You can combine call and construct signatures in the same type arbitrarily:\n\nIt’s common to write a function where the types of the input relate to the type of the output, or where the types of two inputs are related in some way. Let’s consider for a moment a function that returns the first element of an array:\n\nThis function does its job, but unfortunately has the return type . It’d be better if the function returned the type of the array element.\n\nIn TypeScript, generics are used when we want to describe a correspondence between two values. We do this by declaring a type parameter in the function signature:\n\nBy adding a type parameter to this function and using it in two places, we’ve created a link between the input of the function (the array) and the output (the return value). Now when we call it, a more specific type comes out:\n\nNote that we didn’t have to specify in this sample. The type was inferred - chosen automatically - by TypeScript.\n\nWe can use multiple type parameters as well. For example, a standalone version of would look like this:\n\nNote that in this example, TypeScript could infer both the type of the type parameter (from the given array), as well as the type parameter based on the return value of the function expression ( ).\n\nWe’ve written some generic functions that can work on any kind of value. Sometimes we want to relate two values, but can only operate on a certain subset of values. In this case, we can use a constraint to limit the kinds of types that a type parameter can accept.\n\nLet’s write a function that returns the longer of two values. To do this, we need a property that’s a number. We constrain the type parameter to that type by writing an clause:\n\nThere are a few interesting things to note in this example. We allowed TypeScript to infer the return type of . Return type inference also works on generic functions.\n\nBecause we constrained to , we were allowed to access the property of the and parameters. Without the type constraint, we wouldn’t be able to access those properties because the values might have been some other type without a length property.\n\nThe types of and were inferred based on the arguments. Remember, generics are all about relating two or more values with the same type!\n\nFinally, just as we’d like, the call to is rejected because the type doesn’t have a property.\n\nIt might look like this function is OK - is constrained to , and the function either returns or a value matching that constraint. The problem is that the function promises to return the same kind of object as was passed in, not just some object matching the constraint. If this code were legal, you could write code that definitely wouldn’t work:\n\nTypeScript can usually infer the intended type arguments in a generic call, but not always. For example, let’s say you wrote a function to combine two arrays:\n\nNormally it would be an error to call this function with mismatched arrays:\n\nIf you intended to do this, however, you could manually specify :\n\nWriting generic functions is fun, and it can be easy to get carried away with type parameters. Having too many type parameters or using constraints where they aren’t needed can make inference less successful, frustrating callers of your function.\n\nHere are two ways of writing a function that appear similar:\n\nThese might seem identical at first glance, but is a much better way to write this function. Its inferred return type is , but ’s inferred return type is because TypeScript has to resolve the expression using the constraint type, rather than “waiting” to resolve the element during a call.\n\nWe’ve created a type parameter that doesn’t relate two values. That’s always a red flag, because it means callers wanting to specify type arguments have to manually specify an extra type argument for no reason. doesn’t do anything but make the function harder to read and reason about!\n\nType Parameters Should Appear Twice\n\nSometimes we forget that a function might not need to be generic:\n\nWe could just as easily have written a simpler version:\n\nRemember, type parameters are for relating the types of multiple values. If a type parameter is only used once in the function signature, it’s not relating anything. This includes the inferred return type; for example, if was part of the inferred return type of , it would be relating the argument and return types, so would be used twice despite appearing only once in the written code.\n\nFunctions in JavaScript often take a variable number of arguments. For example, the method of takes an optional digit count:\n\nWe can model this in TypeScript by marking the parameter as optional with :\n\nAlthough the parameter is specified as type , the parameter will actually have the type because unspecified parameters in JavaScript get the value .\n\nYou can also provide a parameter default:\n\nNow in the body of , will have type because any argument will be replaced with . Note that when a parameter is optional, callers can always pass , as this simply simulates a “missing” argument:\n\nOnce you’ve learned about optional parameters and function type expressions, it’s very easy to make the following mistakes when writing functions that invoke callbacks:\n\nWhat people usually intend when writing as an optional parameter is that they want both of these calls to be legal:\n\nWhat this actually means is that might get invoked with one argument. In other words, the function definition says that the implementation might look like this:\n\nIn turn, TypeScript will enforce this meaning and issue errors that aren’t really possible:\n\nIn JavaScript, if you call a function with more arguments than there are parameters, the extra arguments are simply ignored. TypeScript behaves the same way. Functions with fewer parameters (of the same types) can always take the place of functions with more parameters.\n\nSome JavaScript functions can be called in a variety of argument counts and types. For example, you might write a function to produce a that takes either a timestamp (one argument) or a month/day/year specification (three arguments).\n\nIn TypeScript, we can specify a function that can be called in different ways by writing overload signatures. To do this, write some number of function signatures (usually two or more), followed by the body of the function:\n\nIn this example, we wrote two overloads: one accepting one argument, and another accepting three arguments. These first two signatures are called the overload signatures.\n\nThen, we wrote a function implementation with a compatible signature. Functions have an implementation signature, but this signature can’t be called directly. Even though we wrote a function with two optional parameters after the required one, it can’t be called with two parameters!\n\nThis is a common source of confusion. Often people will write code like this and not understand why there is an error:\n\nAgain, the signature used to write the function body can’t be “seen” from the outside.\n\nThe implementation signature must also be compatible with the overload signatures. For example, these functions have errors because the implementation signature doesn’t match the overloads in a correct way:\n\nLike generics, there are a few guidelines you should follow when using function overloads. Following these principles will make your function easier to call, easier to understand, and easier to implement.\n\nLet’s consider a function that returns the length of a string or an array:\n\nThis function is fine; we can invoke it with strings or arrays. However, we can’t invoke it with a value that might be a string or an array, because TypeScript can only resolve a function call to a single overload:\n\nBecause both overloads have the same argument count and same return type, we can instead write a non-overloaded version of the function:\n\nThis is much better! Callers can invoke this with either sort of value, and as an added bonus, we don’t have to figure out a correct implementation signature.\n\nTypeScript will infer what the should be in a function via code flow analysis, for example in the following:\n\nTypeScript understands that the function has a corresponding which is the outer object . , heh, can be enough for a lot of cases, but there are a lot of cases where you need more control over what object represents. The JavaScript specification states that you cannot have a parameter called , and so TypeScript uses that syntax space to let you declare the type for in the function body.\n\nThis pattern is common with callback-style APIs, where another object typically controls when your function is called. Note that you need to use and not arrow functions to get this behavior:\n\nOther Types to Know About\n\nThere are some additional types you’ll want to recognize that appear often when working with function types. Like all types, you can use them everywhere, but these are especially relevant in the context of functions.\n\nrepresents the return value of functions which don’t return a value. It’s the inferred type any time a function doesn’t have any statements, or doesn’t return any explicit value from those return statements:\n\nIn JavaScript, a function that doesn’t return any value will implicitly return the value . However, and are not the same thing in TypeScript. There are further details at the end of this chapter.\n\nThe special type refers to any value that isn’t a primitive ( , , , , , , or ). This is different from the empty object type , and also different from the global type . It’s very likely you will never use .\n\nNote that in JavaScript, function values are objects: They have properties, have in their prototype chain, are , you can call on them, and so on. For this reason, function types are considered to be s in TypeScript.\n\nThe type represents any value. This is similar to the type, but is safer because it’s not legal to do anything with an value:\n\nThis is useful when describing function types because you can describe functions that accept any value without having values in your function body.\n\nConversely, you can describe a function that returns a value of unknown type:\n\nSome functions never return a value:\n\nThe type represents values which are never observed. In a return type, this means that the function throws an exception or terminates execution of the program.\n\nalso appears when TypeScript determines there’s nothing left in a union.\n\nThe global type describes properties like , , , and others present on all function values in JavaScript. It also has the special property that values of type can always be called; these calls return :\n\nThis is an untyped function call and is generally best avoided because of the unsafe return type.\n\nIf you need to accept an arbitrary function but don’t intend to call it, the type is generally safer.\n\nIn addition to using optional parameters or overloads to make functions that can accept a variety of fixed argument counts, we can also define functions that take an unbounded number of arguments using rest parameters.\n\nA rest parameter appears after all other parameters, and uses the syntax:\n\nIn TypeScript, the type annotation on these parameters is implicitly instead of , and any type annotation given must be of the form or , or a tuple type (which we’ll learn about later).\n\nConversely, we can provide a variable number of arguments from an iterable object (for example, an array) using the spread syntax. For example, the method of arrays takes any number of arguments:\n\nNote that in general, TypeScript does not assume that arrays are immutable. This can lead to some surprising behavior:\n\nThe best fix for this situation depends a bit on your code, but in general a context is the most straightforward solution:\n\nUsing rest arguments may require turning on when targeting older runtimes.\n\nYou can use parameter destructuring to conveniently unpack objects provided as an argument into one or more local variables in the function body. In JavaScript, it looks like this:\n\nThe type annotation for the object goes after the destructuring syntax:\n\nThis can look a bit verbose, but you can use a named type here as well:\n\nThe return type for functions can produce some unusual, but expected behavior.\n\nContextual typing with a return type of does not force functions to not return something. Another way to say this is a contextual function type with a return type ( ), when implemented, can return any other value, but it will be ignored.\n\nThus, the following implementations of the type are valid:\n\nAnd when the return value of one of these functions is assigned to another variable, it will retain the type of :\n\nThis behavior exists so that the following code is valid even though returns a number and the method expects a function with a return type of .\n\nThere is one other special case to be aware of, when a literal function definition has a return type, that function must not return anything.\n\nFor more on please refer to these other documentation entries:"
    }
]