[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.string.substring?view=net-9.0",
        "document": "A string that is equivalent to the substring that begins at in this instance, or Empty if is equal to the length of this instance.\n\nThe following example demonstrates obtaining a substring from a string.\n\nThe following example uses the Substring method to separate key/value pairs that are delimited by an equals ( ) character.\n\nThe IndexOf method is used to get the position of the equals character in the string. The call to the Substring(Int32, Int32) method extracts the key name, which starts from the first character in the string and extends for the number of characters returned by the call to the IndexOf method. The call to the Substring(Int32) method then extracts the value assigned to the key. It starts at one character position beyond the equals character and extends to the end of the string.\n\nYou call the Substring(Int32) method to extract a substring from a string that begins at a specified character position and ends at the end of the string. The starting character position is zero-based; in other words, the first character in the string is at index 0, not index 1. To extract a substring that begins at a specified character position and ends before the end of the string, call the Substring(Int32, Int32) method.\n\nTo extract a substring that begins with a particular character or character sequence, call a method such as IndexOf or IndexOf to get the value of . The second example illustrates this; it extracts a key value that begins one character position after the character.\n\nIf is equal to zero, the method returns the original string unchanged."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/strings",
        "document": "A string is an object of type String whose value is text. Internally, the text is stored as a sequential read-only collection of Char objects. The Length property of a string represents the number of objects it contains, not the number of Unicode characters. To access the individual Unicode code points in a string, use the StringInfo object.\n\nIn C#, the keyword is an alias for String; therefore, and are equivalent. Use the provided alias as it works even without . The class provides many methods for safely creating, manipulating, and comparing strings. In addition, the C# language overloads some operators to simplify common string operations. For more information about the keyword, see string. For more information about the type and its methods, see String.\n\nYou can declare and initialize strings in various ways, as shown in the following example:\n\nYou don't use the new operator to create a string object except when initializing the string with an array of chars.\n\nInitialize a string with the Empty constant value to create a new String object whose string is of zero length. The string literal representation of a zero-length string is . By initializing strings with the Empty value instead of null, you can reduce the chances of a NullReferenceException occurring. Use the static IsNullOrEmpty(String) method to verify the value of a string before you try to access it.\n\nString objects are immutable: they can't be changed after they're created. All of the String methods and C# operators that appear to modify a string actually return the results in a new string object. In the following example, when the contents of and are concatenated to form a single string, the two original strings are unmodified. The operator creates a new string that contains the combined contents. That new object is assigned to the variable , and the original object that was assigned to is released for garbage collection because no other variable holds a reference to it.\n\nBecause a string \"modification\" is actually a new string creation, you must use caution when you create references to strings. If you create a reference to a string, and then \"modify\" the original string, the reference continues to point to the original object instead of the new object that was created when the string was modified. The following code illustrates this behavior:\n\nFor more information about how to create new strings that are based on modifications such as search and replace operations on the original string, see How to modify string contents.\n\nQuoted string literals start and end with a single double quote character ( ) on the same line. Quoted string literals are best suited for strings that fit on a single line and don't include any escape sequences. A quoted string literal must embed escape characters, as shown in the following example:\n\nVerbatim string literals are more convenient for multi-line strings, strings that contain backslash characters, or embedded double quotes. Verbatim strings preserve new line characters as part of the string text. Use double quotation marks to embed a quotation mark inside a verbatim string. The following example shows some common uses for verbatim strings:\n\nBeginning with C# 11, you can use raw string literals to more easily create strings that are multi-line, or use any characters requiring escape sequences. Raw string literals remove the need to ever use escape sequences. You can write the string, including whitespace formatting, how you want it to appear in output. A raw string literal:\n• Starts and ends with a sequence of at least three double quote characters ( ). You can use more than three consecutive characters to start and end the sequence to support string literals that contain three (or more) repeated quote characters.\n• Single line raw string literals require the opening and closing quote characters on the same line.\n• Multi-line raw string literals require both opening and closing quote characters on their own line.\n• In multi-line raw string literals, any whitespace to the left of the closing quotes is removed from all lines of the raw string literal.\n• In multi-line raw string literals, whitespace following the opening quote on the same line is ignored.\n• In multi-line raw string literals, whitespace only lines following the opening quote are included in the string literal.\n\nThe following examples demonstrate these rules:\n\nThe following examples demonstrate the compiler errors reported based on these rules:\n\nThe first two examples are invalid because multiline raw string literals require the opening and closing quote sequence on its own line. The third example is invalid because the text is outdented from the closing quote sequence.\n\nYou should consider raw string literals when you're generating text that includes characters that require escape sequences when using quoted string literals or verbatim string literals. Raw string literals are easier for you and others to read because it more closely resembles the output text. For example, consider the following code that includes a string of formatted JSON:\n\nA format string is a string whose contents are determined dynamically at run time. Format strings are created by embedding interpolated expressions or placeholders inside of braces within a string. Everything inside the braces ( ) is resolved to a value and output as a formatted string at run time. There are two methods to create format strings: string interpolation and composite formatting.\n\nYou declare Interpolated strings with the special character. An interpolated string includes interpolated expressions in braces. If you're new to string interpolation, see the String interpolation - C# interactive tutorial for a quick overview.\n\nUse string interpolation to improve the readability and maintainability of your code. String interpolation achieves the same results as the method, but improves ease of use and inline clarity.\n\nYou can use string interpolation to initialize a constant string when all the expressions used for placeholders are also constant strings.\n\nBeginning with C# 11, you can combine raw string literals with string interpolations. You start and end the format string with three or more successive double quotes. If your output string should contain the or character, you can use extra characters to specify how many and characters start and end an interpolation. Any sequence of fewer or characters is included in the output. The following example shows how you can use that feature to display the distance of a point from the origin, and place the point inside braces:\n\nC# also allows verbatim string interpolation, for example across multiple lines, using the or syntax.\n\nTo interpret escape sequences literally, use a verbatim string literal. An interpolated verbatim string starts with the character followed by the character. You can use the and tokens in any order: both and are valid interpolated verbatim strings.\n\nThe String.Format utilizes placeholders in braces to create a format string. This example results in similar output to the string interpolation method used in the preceding sample.\n\nFor more information on formatting .NET types, see Formatting Types in .NET.\n\nA substring is any sequence of characters that is contained in a string. Use the Substring method to create a new string from a part of the original string. You can search for one or more occurrences of a substring by using the IndexOf method. Use the Replace method to replace all occurrences of a specified substring with a new string. Like the Substring method, Replace actually returns a new string and doesn't modify the original string. For more information, see How to search strings and How to modify string contents.\n\nYou can use array notation with an index value to acquire read-only access to individual characters, as in the following example:\n\nIf the String methods don't provide the functionality that you must have to modify individual characters in a string, you can use a StringBuilder object to modify the individual chars \"in-place,\" and then create a new string to store the results by using the StringBuilder methods. In the following example, assume that you must modify the original string in a particular way and then store the results for future use:\n\nAn empty string is an instance of a System.String object that contains zero characters. Empty strings are used often in various programming scenarios to represent a blank text field. You can call methods on empty strings because they're valid System.String objects. Empty strings are initialized as follows:\n\nBy contrast, a null string doesn't refer to an instance of a System.String object and any attempt to call a method on a null string causes a NullReferenceException. However, you can use null strings in concatenation and comparison operations with other strings. The following examples illustrate some cases in which a reference to a null string does and doesn't cause an exception to be thrown:\n\nString operations in .NET are highly optimized and in most cases don't significantly impact performance. However, in some scenarios such as tight loops that are executing many hundreds or thousands of times, string operations can affect performance. The StringBuilder class creates a string buffer that offers better performance if your program performs many string manipulations. The StringBuilder string also enables you to reassign individual characters, something the built-in string data type doesn't support. This code, for example, changes the content of a string without creating a new string:\n\nIn this example, a StringBuilder object is used to create a string from a set of numeric types:\n\nBecause the String type implements IEnumerable<T>, you can use the extension methods defined in the Enumerable class on strings. To avoid visual clutter, these methods are excluded from IntelliSense for the String type, but they're available nevertheless. You can also use LINQ query expressions on strings. For more information, see LINQ and Strings.\n• How to modify string contents: Illustrates techniques to transform strings and modify the contents of strings.\n• How to compare strings: Shows how to perform ordinal and culture specific comparisons of strings.\n• How to concatenate multiple strings: Demonstrates various ways to join multiple strings into one.\n• How to parse strings using String.Split: Contains code examples that illustrate how to use the String.Split method to parse strings.\n• How to search strings: Explains how to use search for specific text or patterns in strings.\n• How to determine whether a string represents a numeric value: Shows how to safely parse a string to see whether it has a valid numeric value.\n• String interpolation: Describes the string interpolation feature that provides a convenient syntax to format strings.\n• Basic String Operations: Provides links to articles that use System.String and System.Text.StringBuilder methods to perform basic string operations.\n• Parsing Strings: Describes how to convert string representations of .NET base types to instances of the corresponding types.\n• Parsing Date and Time Strings in .NET: Shows how to convert a string such as \"01/24/2008\" to a System.DateTime object.\n• Comparing Strings: Includes information about how to compare strings and provides examples in C# and Visual Basic.\n• Using the StringBuilder Class: Describes how to create and modify dynamic string objects by using the StringBuilder class.\n• LINQ and Strings: Provides information about how to perform various string operations by using LINQ queries."
    },
    {
        "link": "https://geeksforgeeks.org/c-sharp-substring-method",
        "document": "In C#, Substring() is a string method. It is used to retrieve a substring from the current instance of the string. This method can be overloaded by passing the different number of parameters to it as follows:\n\nThis method is used to retrieves a substring from the current instance of the string. The parameter “startIndex” will specify the starting position of substring and then substring will continue to the end of the string.\n• Parameter: This method accept one parameter “startIndex”. This parameter will specify the starting position of the substring which has to be retrieve. The type of this parameter is System.Int32.\n• Return Value: This method will return the substring which begins from startIndex and continues to the end of the string. The return value type is System.String.\n\nException: If startIndex is less than zero or greater than the length of current instance then it will arise ArgumentOutOfRangeException.\n\nThis method is used to extract a substring that begins from specified position describe by parameter startIndex and has a specified length. If startIndex is equal to the length of string and parameter length is zero, then it will return nothing substring.\n• Parameter: This method accept two parameters “startIndex” and length. First parameter will specify the starting position of the substring which has to be retrieve and second parameter will specify the length of the substring. The type of both the parameters is System.Int32.\n• Return Value: This method will return the substring which begins from specified position and substring will have a specified length. The return value type is System.String.\n\nException: This method can arise ArgumentOutOfRangeException in two conditions:\n• if the parameters startIndex or length is less than zero.\n• If startIndex + length indicates a position which is not within current instance."
    },
    {
        "link": "https://ironpdf.com/blog/net-help/csharp-substring",
        "document": "Test in production without watermarks.\n\nWorks wherever you need it to."
    },
    {
        "link": "https://stackoverflow.com/questions/19859389/string-substring-explanation",
        "document": "In my program I have a long string sent via another program. This string is roughly 100 characters long and I only need a small portion of it. For this, we'll say the string I'm sending is as follows:\n\nSo, to cut the string so I only get the portion I need I have used the following string method:\n\nNow in my program I know that the bit of the string I need to use is exactly 38 characters from the start and is only 36 characters long. Thus my call looks something like this:\n\nAnd my program will happily read in from the above example.\n\nThis doesnt show up any issues or bugs when I build the program. But when I run it, the computer complains that the end point can't be lower than the start point. The thing is, however, the part of the message I want, gets sent over.\n\nI've tried modifying my call so that it would look similar to this:\n\nBut that has returned a bunch of extra characters I don't need or want.\n\nNow my thinking behind that method is that it works by taking my initial point, the 38th character from the beginning of the string, and then goes 36 characters along from the 38th. Is my thinking behind how this method works wrong?\n\nWhy does this computer complain about an issue but then does what I want anyway?"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/base-types/trimming",
        "document": "Trim and remove characters from strings in .NET\n\nIf you're parsing a sentence into individual words, you might end up with words that have blank spaces (also called white spaces) on either end of the word. In this situation, you can use one of the trim methods in the class to remove any number of spaces or other characters from a specified position in the string. The following table describes the available trim methods:\n\nYou can easily remove white spaces from both ends of a string by using the String.Trim method, as shown in the following example:\n\nYou can also remove characters that you specify in a character array from the beginning and end of a string. The following example removes white-space characters, periods, and asterisks:\n\nThe method removes characters from the end of a string, creating a new string object. An array of characters is passed to this method to specify the characters to be removed. The order of the elements in the character array doesn't affect the trim operation. The trim stops when a character not specified in the array is found.\n\nThe following example removes the last letters of a string using the method. In this example, the position of the character and the character are reversed to illustrate that the order of characters in the array doesn't matter. Notice that this code removes the last word of plus part of the first.\n\nThis code displays to the console.\n\nThe following example removes the last word of a string using the method. In this code, a comma follows the word and because the comma isn't specified in the array of characters to trim, the trim ends at the comma.\n\nThis code displays to the console.\n\nThe method is similar to the method except that it creates a new string by removing characters from the beginning of an existing string object. An array of characters is passed to the method to specify the characters to be removed. As with the method, the order of the elements in the character array doesn't affect the trim operation. The trim stops when a character not specified in the array is found.\n\nThe following example removes the first word of a string. In this example, the position of the character and the character are reversed to illustrate that the order of characters in the array doesn't matter.\n\nThis code displays to the console.\n\nThe String.Remove method removes a specified number of characters that begin at a specified position in an existing string. This method assumes a zero-based index.\n\nThe following example removes 10 characters from a string beginning at position five of a zero-based index of the string.\n\nYou can also remove a specified character or substring from a string by calling the String.Replace(String, String) method and specifying an empty string (String.Empty) as the replacement. The following example removes all commas from a string:"
    },
    {
        "link": "https://stackoverflow.com/questions/1120198/most-efficient-way-to-remove-special-characters-from-string",
        "document": "The strings that will be cleaned will be rather short, usually between 10 and 30 characters in length.\n\nWhat is the most efficient way to do this? What would a regular expression look like, and how does it compare with normal string manipulation?\n\nI have the following, it works but I suspect (I know!) it's not very efficient:\n\nI want to remove all special characters from a string. Allowed characters are A-Z (uppercase or lowercase), numbers (0-9), underscore (_), or the dot sign (.).\n\nWhy do you think that your method is not efficient? It's actually one of the most efficient ways that you can do it. You should of course read the character into a local variable or use an enumerator to reduce the number of array accesses: public static string RemoveSpecialCharacters(this string str) { StringBuilder sb = new StringBuilder(); foreach (char c in str) { if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || c == '.' || c == '_') { sb.Append(c); } } return sb.ToString(); } One thing that makes a method like this efficient is that it scales well. The execution time will be relative to the length of the string. There is no nasty surprises if you would use it on a large string. Edit:\n\n I made a quick performance test, running each function a million times with a 24 character string. These are the results: Edit 2: I added the distinction between A-Z and a-z in the code above. (I reran the performance test, and there is no noticable difference.) Edit 3:\n\n I tested the lookup+char[] solution, and it runs in about 13 ms. The price to pay is, of course, the initialization of the huge lookup table and keeping it in memory. Well, it's not that much data, but it's much for such a trivial function... private static bool[] _lookup; static Program() { _lookup = new bool[65536]; for (char c = '0'; c <= '9'; c++) _lookup[c] = true; for (char c = 'A'; c <= 'Z'; c++) _lookup[c] = true; for (char c = 'a'; c <= 'z'; c++) _lookup[c] = true; _lookup['.'] = true; _lookup['_'] = true; } public static string RemoveSpecialCharacters(string str) { char[] buffer = new char[str.Length]; int index = 0; foreach (char c in str) { if (_lookup[c]) { buffer[index] = c; index++; } } return new string(buffer, 0, index); }\n\nIf you're using a dynamic list of characters, LINQ may offer a much faster and graceful solution: I compared this approach against two of the previous \"fast\" approaches (release compilation): Note that the algorithm is slightly modified - the characters are passed in as an array rather than hard-coded, which could be impacting things slightly (ie/ the other solutions would have an inner foor loop to check the character array). If I switch to a hard-coded solution using a LINQ where clause, the results are: Might be worth looking at LINQ or a modified approach if you're planning on writing a more generic solution, rather than hard-coding the list of characters. LINQ definitely gives you concise, highly readable code - even more so than Regex.\n\nI'm not convinced your algorithm is anything but efficient. It's O(n) and only looks at each character once. You're not gonna get any better than that unless you magically know values before checking them. I would however initialize the capacity of your to the initial size of the string. I'm guessing your perceived performance problem comes from memory reallocation. Side note: Checking - is not safe. You're including , , , , , and `... Side note 2: For that extra bit of efficiency, put the comparisons in an order to minimize the number of comparisons. (At worst, you're talking 8 comparisons tho, so don't think too hard.) This changes with your expected input, but one example could be: Side note 3: If for whatever reason you REALLY need this to be fast, a switch statement may be faster. The compiler should create a jump table for you, resulting in only a single comparison:\n\nI had to do something similar for work, but in my case I had to filter all that is not a letter, number or whitespace (but you could easily modify it to your needs). The filtering is done client-side in JavaScript, but for security reasons I am also doing the filtering server-side. Since I can expect most of the strings to be clean, I would like to avoid copying the string unless I really need to. This let my to the implementation below, which should perform better for both clean and dirty strings. public static string EnsureOnlyLetterDigitOrWhiteSpace(string input) { StringBuilder cleanedInput = null; for (var i = 0; i < input.Length; ++i) { var currentChar = input[i]; var charIsValid = char.IsLetterOrDigit(currentChar) || char.IsWhiteSpace(currentChar); if (charIsValid) { if(cleanedInput != null) cleanedInput.Append(currentChar); } else { if (cleanedInput != null) continue; cleanedInput = new StringBuilder(); if (i > 0) cleanedInput.Append(input.Substring(0, i)); } } return cleanedInput == null ? input : cleanedInput.ToString(); }\n\nIf you're worried about speed, use pointers to edit the existing string. You could pin the string and get a pointer to it, then run a for loop over each character, overwriting each invalid character with a replacement character. It would be extremely efficient and would not require allocating any new string memory. You would also need to compile your module with the unsafe option, and add the \"unsafe\" modifier to your method header in order to use pointers. static void Main(string[] args) { string str = \"string!$%with^&*invalid!!characters\"; Console.WriteLine( str ); //print original string FixMyString( str, ' ' ); Console.WriteLine( str ); //print string again to verify that it has been modified Console.ReadLine(); //pause to leave command prompt open } public static unsafe void FixMyString( string str, char replacement_char ) { fixed (char* p_str = str) { char* c = p_str; //temp pointer, since p_str is read-only for (int i = 0; i < str.Length; i++, c++) //loop through each character in string, advancing the character pointer as well if (!IsValidChar(*c)) //check whether the current character is invalid (*c) = replacement_char; //overwrite character in existing string with replacement character } } public static bool IsValidChar( char c ) { return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c == '.' || c == '_'); //return char.IsLetterOrDigit( c ) || c == '.' || c == '_'; //this may work as well }"
    },
    {
        "link": "https://stackoverflow.com/questions/7411438/remove-characters-from-c-sharp-string",
        "document": "I would like to remove the characters '@', ',', '.', ';', '\\'' from that string so that it becomes \"My name is Wan Wan\"\n\nHow might I remove characters from a string? For example: \"My name @is ,Wan.;'; Wan\" .\n\nComparing various suggestions (as well as comparing in the context of single-character replacements with various sizes and positions of the target). In this particular case, splitting on the targets and joining on the replacements (in this case, empty string) is the fastest by at least a factor of 3. Ultimately, performance is different depending on the number of replacements, where the replacements are in the source, and the size of the source. #ymmv | Test | Compare | Elapsed | |---------------------------|---------|--------------------------------------------------------------------| | SplitJoin | 1.00x | 29023 ticks elapsed (2.9023 ms) [in 10K reps, 0.00029023 ms per] | | Replace | 2.77x | 80295 ticks elapsed (8.0295 ms) [in 10K reps, 0.00080295 ms per] | | RegexCompiled | 5.27x | 152869 ticks elapsed (15.2869 ms) [in 10K reps, 0.00152869 ms per] | | LinqSplit | 5.43x | 157580 ticks elapsed (15.758 ms) [in 10K reps, 0.0015758 ms per] | | Regex, Uncompiled | 5.85x | 169667 ticks elapsed (16.9667 ms) [in 10K reps, 0.00169667 ms per] | | Regex | 6.81x | 197551 ticks elapsed (19.7551 ms) [in 10K reps, 0.00197551 ms per] | | RegexCompiled Insensitive | 7.33x | 212789 ticks elapsed (21.2789 ms) [in 10K reps, 0.00212789 ms per] | | Regex Insensitive | 7.52x | 218164 ticks elapsed (21.8164 ms) [in 10K reps, 0.00218164 ms per] | void test(string title, string sample, string target, string replacement) { var targets = target.ToCharArray(); var tox = \"[\" + target + \"]\"; var x = new Regex(tox); var xc = new Regex(tox, RegexOptions.Compiled); var xci = new Regex(tox, RegexOptions.Compiled | RegexOptions.IgnoreCase); // no, don't dump the results var p = new Perf/*<string>*/(); p.Add(string.Join(\" \", title, \"Replace\"), n => targets.Aggregate(sample, (res, curr) => res.Replace(new string(curr, 1), replacement))); p.Add(string.Join(\" \", title, \"SplitJoin\"), n => String.Join(replacement, sample.Split(targets))); p.Add(string.Join(\" \", title, \"LinqSplit\"), n => String.Concat(sample.Select(c => targets.Contains(c) ? replacement : new string(c, 1)))); p.Add(string.Join(\" \", title, \"Regex\"), n => Regex.Replace(sample, tox, replacement)); p.Add(string.Join(\" \", title, \"Regex Insentive\"), n => Regex.Replace(sample, tox, replacement, RegexOptions.IgnoreCase)); p.Add(string.Join(\" \", title, \"Regex, Uncompiled\"), n => x.Replace(sample, replacement)); p.Add(string.Join(\" \", title, \"RegexCompiled\"), n => xc.Replace(sample, replacement)); p.Add(string.Join(\" \", title, \"RegexCompiled Insensitive\"), n => xci.Replace(sample, replacement)); var trunc = 40; var header = sample.Length > trunc ? sample.Substring(0, trunc) + \"...\" : sample; p.Vs(header); } void Main() { // also see https://stackoverflow.com/questions/7411438/remove-characters-from-c-sharp-string \"Control\".Perf(n => { var s = \"*\"; }); var text = \"My name @is ,Wan.;'; Wan\"; var clean = new[] { '@', ',', '.', ';', '\\'' }; test(\"stackoverflow\", text, string.Concat(clean), string.Empty); var target = \"o\"; var f = \"x\"; var replacement = \"1\"; var fillers = new Dictionary<string, string> { { \"short\", new String(f[0], 10) }, { \"med\", new String(f[0], 300) }, { \"long\", new String(f[0], 1000) }, { \"huge\", new String(f[0], 10000) } }; var formats = new Dictionary<string, string> { { \"start\", \"{0}{1}{1}\" }, { \"middle\", \"{1}{0}{1}\" }, { \"end\", \"{1}{1}{0}\" } }; foreach(var filler in fillers) foreach(var format in formats) { var title = string.Join(\"-\", filler.Key, format.Key); var sample = string.Format(format.Value, target, filler.Value); test(title, sample, target, replacement); } }\n\nLess specific to your question, it is possible to remove ALL punctuation from a string (except space) by white listing the acceptable characters in a regular expression: string dirty = \"My name @is ,Wan.;'; Wan\"; // only space, capital A-Z, lowercase a-z, and digits 0-9 are allowed in the string string clean = Regex.Replace(dirty, \"[^A-Za-z0-9 ]\", \"\"); Note there is a space after that 9 so as not to remove spaces from your sentence. The third argument is an empty string which serves to replace any substring that does not belong in the regular expression.\n\nHere's a method I wrote that takes a slightly different approach. Rather than specifying the characters to remove, I tell my method which characters I want to keep -- it will remove all other characters. In the OP's example, he only wants to keep alphabetical characters and spaces. Here's what a call to my method would look like (C# demo): var str = \"My name @is ,Wan.;'; Wan\"; // \"My name is Wan Wan\" var result = RemoveExcept(str, alphas: true, spaces: true); /// <summary> /// Returns a copy of the original string containing only the set of whitelisted characters. /// </summary> /// <param name=\"value\">The string that will be copied and scrubbed.</param> /// <param name=\"alphas\">If true, all alphabetical characters (a-zA-Z) will be preserved; otherwise, they will be removed.</param> /// <param name=\"numerics\">If true, all numeric characters (0-9) will be preserved; otherwise, they will be removed.</param> /// <param name=\"dashes\">If true, all dash characters (-) will be preserved; otherwise, they will be removed.</param> /// <param name=\"underlines\">If true, all underscore characters (_) will be preserved; otherwise, they will be removed.</param> /// <param name=\"spaces\">If true, all whitespace (e.g. spaces, tabs) will be preserved; otherwise, they will be removed.</param> /// <param name=\"periods\">If true, all dot characters (\".\") will be preserved; otherwise, they will be removed.</param> public static string RemoveExcept(string value, bool alphas = false, bool numerics = false, bool dashes = false, bool underlines = false, bool spaces = false, bool periods = false) { if (string.IsNullOrWhiteSpace(value)) return value; if (new[] { alphas, numerics, dashes, underlines, spaces, periods }.All(x => x == false)) return value; var whitelistChars = new HashSet<char>(string.Concat( alphas ? \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" : \"\", numerics ? \"0123456789\" : \"\", dashes ? \"-\" : \"\", underlines ? \"_\" : \"\", periods ? \".\" : \"\", spaces ? \" \" : \"\" ).ToCharArray()); var scrubbedValue = value.Aggregate(new StringBuilder(), (sb, @char) => { if (whitelistChars.Contains(@char)) sb.Append(@char); return sb; }).ToString(); return scrubbedValue; }\n\nI might as well throw this out here. Make an extension to remove chars from a string: public static string RemoveChars(this string input, params char[] chars) { var sb = new StringBuilder(); for (int i = 0; i < input.Length; i++) { if (!chars.Contains(input[i])) sb.Append(input[i]); } return sb.ToString(); } And it's usable like this: string str = \"My name @is ,Wan.;'; Wan\"; string cleanedUpString = str.RemoveChars('@', ',', '.', ';', '\\''); string str = \"My name @is ,Wan.;'; Wan\".RemoveChars('@', ',', '.', ';', '\\'');\n\nIt seems that the shortest way is to combine LINQ and : var input = @\"My name @is ,Wan.;'; Wan\"; var chrs = new[] {'@', ',', '.', ';', '\\''}; var result = string.Concat(input.Where(c => !chrs.Contains(c))); // => result = \"My name is Wan Wan\" See the C# demo. Note that is a shortcut to . Note that using a regex to remove individual known chars is still possible to build dynamically, although it is believed that regex is slower. However, here is a way to build such a dynamic regex (where all you need is a character class): See another C# demo. The regex will look like (matching one or more ( ) consecutive occurrences of , , , or chars) where the dot does not have to be escaped, but will be necessary to escape other chars that must be escaped, like , , or whose position inside the character class you cannot predict.\n\nLots of good answers here, here's my addition along with several unit tests that can be used to help test correctness, my solution is similar to @Rianne's above but uses an ISet to provide O(1) lookup time on the replacement characters (and also similar to @Albin Sunnanbo's Linq solution). using System; using System.Collections.Generic; using System.Linq; /// <summary> /// Returns a string with the specified characters removed. /// </summary> /// <param name=\"source\">The string to filter.</param> /// <param name=\"removeCharacters\">The characters to remove.</param> /// <returns>A new <see cref=\"System.String\"/> with the specified characters removed.</returns> public static string Remove(this string source, IEnumerable<char> removeCharacters) { if (source == null) { throw new ArgumentNullException(\"source\"); } if (removeCharacters == null) { throw new ArgumentNullException(\"removeCharacters\"); } // First see if we were given a collection that supports ISet ISet<char> replaceChars = removeCharacters as ISet<char>; if (replaceChars == null) { replaceChars = new HashSet<char>(removeCharacters); } IEnumerable<char> filtered = source.Where(currentChar => !replaceChars.Contains(currentChar)); return new string(filtered.ToArray()); } using System; using System.Collections; using System.Collections.Generic; using NUnit.Framework; [TestFixture] public class StringExtensionMethodsTests { [TestCaseSource(typeof(StringExtensionMethodsTests_Remove_Tests))] public void Remove(string targetString, IEnumerable<char> removeCharacters, string expected) { string actual = StringExtensionMethods.Remove(targetString, removeCharacters); Assert.That(actual, Is.EqualTo(expected)); } [TestCaseSource(typeof(StringExtensionMethodsTests_Remove_ParameterValidation_Tests))] public void Remove_ParameterValidation(string targetString, IEnumerable<char> removeCharacters) { Assert.Throws<ArgumentNullException>(() => StringExtensionMethods.Remove(targetString, removeCharacters)); } } internal class StringExtensionMethodsTests_Remove_Tests : IEnumerable { public IEnumerator GetEnumerator() { yield return new TestCaseData(\"My name @is ,Wan.;'; Wan\", new char[] { '@', ',', '.', ';', '\\'' }, \"My name is Wan Wan\").SetName(\"StringUsingCharArray\"); yield return new TestCaseData(\"My name @is ,Wan.;'; Wan\", new HashSet<char> { '@', ',', '.', ';', '\\'' }, \"My name is Wan Wan\").SetName(\"StringUsingISetCollection\"); yield return new TestCaseData(string.Empty, new char[1], string.Empty).SetName(\"EmptyStringNoReplacementCharactersYieldsEmptyString\"); yield return new TestCaseData(string.Empty, new char[] { 'A', 'B', 'C' }, string.Empty).SetName(\"EmptyStringReplacementCharsYieldsEmptyString\"); yield return new TestCaseData(\"No replacement characters\", new char[1], \"No replacement characters\").SetName(\"StringNoReplacementCharactersYieldsString\"); yield return new TestCaseData(\"No characters will be replaced\", new char[] { 'Z' }, \"No characters will be replaced\").SetName(\"StringNonExistantReplacementCharactersYieldsString\"); yield return new TestCaseData(\"AaBbCc\", new char[] { 'a', 'C' }, \"ABbc\").SetName(\"CaseSensitivityReplacements\"); yield return new TestCaseData(\"ABC\", new char[] { 'A', 'B', 'C' }, string.Empty).SetName(\"AllCharactersRemoved\"); yield return new TestCaseData(\"AABBBBBBCC\", new char[] { 'A', 'B', 'C' }, string.Empty).SetName(\"AllCharactersRemovedMultiple\"); yield return new TestCaseData(\"Test That They Didn't Attempt To Use .Except() which returns distinct characters\", new char[] { '(', ')' }, \"Test That They Didn't Attempt To Use .Except which returns distinct characters\").SetName(\"ValidateTheStringIsNotJustDistinctCharacters\"); } } internal class StringExtensionMethodsTests_Remove_ParameterValidation_Tests : IEnumerable { public IEnumerator GetEnumerator() { yield return new TestCaseData(null, null); yield return new TestCaseData(\"valid string\", null); yield return new TestCaseData(null, new char[1]); } }"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/strings",
        "document": "A string is an object of type String whose value is text. Internally, the text is stored as a sequential read-only collection of Char objects. The Length property of a string represents the number of objects it contains, not the number of Unicode characters. To access the individual Unicode code points in a string, use the StringInfo object.\n\nIn C#, the keyword is an alias for String; therefore, and are equivalent. Use the provided alias as it works even without . The class provides many methods for safely creating, manipulating, and comparing strings. In addition, the C# language overloads some operators to simplify common string operations. For more information about the keyword, see string. For more information about the type and its methods, see String.\n\nYou can declare and initialize strings in various ways, as shown in the following example:\n\nYou don't use the new operator to create a string object except when initializing the string with an array of chars.\n\nInitialize a string with the Empty constant value to create a new String object whose string is of zero length. The string literal representation of a zero-length string is . By initializing strings with the Empty value instead of null, you can reduce the chances of a NullReferenceException occurring. Use the static IsNullOrEmpty(String) method to verify the value of a string before you try to access it.\n\nString objects are immutable: they can't be changed after they're created. All of the String methods and C# operators that appear to modify a string actually return the results in a new string object. In the following example, when the contents of and are concatenated to form a single string, the two original strings are unmodified. The operator creates a new string that contains the combined contents. That new object is assigned to the variable , and the original object that was assigned to is released for garbage collection because no other variable holds a reference to it.\n\nBecause a string \"modification\" is actually a new string creation, you must use caution when you create references to strings. If you create a reference to a string, and then \"modify\" the original string, the reference continues to point to the original object instead of the new object that was created when the string was modified. The following code illustrates this behavior:\n\nFor more information about how to create new strings that are based on modifications such as search and replace operations on the original string, see How to modify string contents.\n\nQuoted string literals start and end with a single double quote character ( ) on the same line. Quoted string literals are best suited for strings that fit on a single line and don't include any escape sequences. A quoted string literal must embed escape characters, as shown in the following example:\n\nVerbatim string literals are more convenient for multi-line strings, strings that contain backslash characters, or embedded double quotes. Verbatim strings preserve new line characters as part of the string text. Use double quotation marks to embed a quotation mark inside a verbatim string. The following example shows some common uses for verbatim strings:\n\nBeginning with C# 11, you can use raw string literals to more easily create strings that are multi-line, or use any characters requiring escape sequences. Raw string literals remove the need to ever use escape sequences. You can write the string, including whitespace formatting, how you want it to appear in output. A raw string literal:\n• Starts and ends with a sequence of at least three double quote characters ( ). You can use more than three consecutive characters to start and end the sequence to support string literals that contain three (or more) repeated quote characters.\n• Single line raw string literals require the opening and closing quote characters on the same line.\n• Multi-line raw string literals require both opening and closing quote characters on their own line.\n• In multi-line raw string literals, any whitespace to the left of the closing quotes is removed from all lines of the raw string literal.\n• In multi-line raw string literals, whitespace following the opening quote on the same line is ignored.\n• In multi-line raw string literals, whitespace only lines following the opening quote are included in the string literal.\n\nThe following examples demonstrate these rules:\n\nThe following examples demonstrate the compiler errors reported based on these rules:\n\nThe first two examples are invalid because multiline raw string literals require the opening and closing quote sequence on its own line. The third example is invalid because the text is outdented from the closing quote sequence.\n\nYou should consider raw string literals when you're generating text that includes characters that require escape sequences when using quoted string literals or verbatim string literals. Raw string literals are easier for you and others to read because it more closely resembles the output text. For example, consider the following code that includes a string of formatted JSON:\n\nA format string is a string whose contents are determined dynamically at run time. Format strings are created by embedding interpolated expressions or placeholders inside of braces within a string. Everything inside the braces ( ) is resolved to a value and output as a formatted string at run time. There are two methods to create format strings: string interpolation and composite formatting.\n\nYou declare Interpolated strings with the special character. An interpolated string includes interpolated expressions in braces. If you're new to string interpolation, see the String interpolation - C# interactive tutorial for a quick overview.\n\nUse string interpolation to improve the readability and maintainability of your code. String interpolation achieves the same results as the method, but improves ease of use and inline clarity.\n\nYou can use string interpolation to initialize a constant string when all the expressions used for placeholders are also constant strings.\n\nBeginning with C# 11, you can combine raw string literals with string interpolations. You start and end the format string with three or more successive double quotes. If your output string should contain the or character, you can use extra characters to specify how many and characters start and end an interpolation. Any sequence of fewer or characters is included in the output. The following example shows how you can use that feature to display the distance of a point from the origin, and place the point inside braces:\n\nC# also allows verbatim string interpolation, for example across multiple lines, using the or syntax.\n\nTo interpret escape sequences literally, use a verbatim string literal. An interpolated verbatim string starts with the character followed by the character. You can use the and tokens in any order: both and are valid interpolated verbatim strings.\n\nThe String.Format utilizes placeholders in braces to create a format string. This example results in similar output to the string interpolation method used in the preceding sample.\n\nFor more information on formatting .NET types, see Formatting Types in .NET.\n\nA substring is any sequence of characters that is contained in a string. Use the Substring method to create a new string from a part of the original string. You can search for one or more occurrences of a substring by using the IndexOf method. Use the Replace method to replace all occurrences of a specified substring with a new string. Like the Substring method, Replace actually returns a new string and doesn't modify the original string. For more information, see How to search strings and How to modify string contents.\n\nYou can use array notation with an index value to acquire read-only access to individual characters, as in the following example:\n\nIf the String methods don't provide the functionality that you must have to modify individual characters in a string, you can use a StringBuilder object to modify the individual chars \"in-place,\" and then create a new string to store the results by using the StringBuilder methods. In the following example, assume that you must modify the original string in a particular way and then store the results for future use:\n\nAn empty string is an instance of a System.String object that contains zero characters. Empty strings are used often in various programming scenarios to represent a blank text field. You can call methods on empty strings because they're valid System.String objects. Empty strings are initialized as follows:\n\nBy contrast, a null string doesn't refer to an instance of a System.String object and any attempt to call a method on a null string causes a NullReferenceException. However, you can use null strings in concatenation and comparison operations with other strings. The following examples illustrate some cases in which a reference to a null string does and doesn't cause an exception to be thrown:\n\nString operations in .NET are highly optimized and in most cases don't significantly impact performance. However, in some scenarios such as tight loops that are executing many hundreds or thousands of times, string operations can affect performance. The StringBuilder class creates a string buffer that offers better performance if your program performs many string manipulations. The StringBuilder string also enables you to reassign individual characters, something the built-in string data type doesn't support. This code, for example, changes the content of a string without creating a new string:\n\nIn this example, a StringBuilder object is used to create a string from a set of numeric types:\n\nBecause the String type implements IEnumerable<T>, you can use the extension methods defined in the Enumerable class on strings. To avoid visual clutter, these methods are excluded from IntelliSense for the String type, but they're available nevertheless. You can also use LINQ query expressions on strings. For more information, see LINQ and Strings.\n• How to modify string contents: Illustrates techniques to transform strings and modify the contents of strings.\n• How to compare strings: Shows how to perform ordinal and culture specific comparisons of strings.\n• How to concatenate multiple strings: Demonstrates various ways to join multiple strings into one.\n• How to parse strings using String.Split: Contains code examples that illustrate how to use the String.Split method to parse strings.\n• How to search strings: Explains how to use search for specific text or patterns in strings.\n• How to determine whether a string represents a numeric value: Shows how to safely parse a string to see whether it has a valid numeric value.\n• String interpolation: Describes the string interpolation feature that provides a convenient syntax to format strings.\n• Basic String Operations: Provides links to articles that use System.String and System.Text.StringBuilder methods to perform basic string operations.\n• Parsing Strings: Describes how to convert string representations of .NET base types to instances of the corresponding types.\n• Parsing Date and Time Strings in .NET: Shows how to convert a string such as \"01/24/2008\" to a System.DateTime object.\n• Comparing Strings: Includes information about how to compare strings and provides examples in C# and Visual Basic.\n• Using the StringBuilder Class: Describes how to create and modify dynamic string objects by using the StringBuilder class.\n• LINQ and Strings: Provides information about how to perform various string operations by using LINQ queries."
    },
    {
        "link": "https://geeksforgeeks.org/c-sharp-remove-method",
        "document": "In C#, the Remove() method of the String class is used for removing the characters from the specified position of a string. If the length is not specified, then it will remove all the characters after the specified position. This method can be overloaded by changing the number of arguments passed to it.\n\nExample 1: Using String.Remove() method to remove the specified characters from a string.\n\nExplanation: In the above example, we use the Remove(int StartIndex) method which takes a single parameter as the starting index it will start to remove characters from the current String object. This method will continue to remove the characters till the end of the current string object.\n• StartIndex: The index position from which it will start to remove characters from the current String object.\n• count(optional): The count of the number of characters to be removed from the string.\n• None It will return the string of type System.String\n\nExceptions: There can be two cases where exception ArgumentOutOfRangeException may occur\n• None Either StartIndex or (StartIndex + count) indicates a position which may be outside the current string object.\n• None StartIndex or count is less than zero.\n\nExample 2: Using the Remove(int StartIndex) method to remove all the characters from the start index of a string.\n\nExplanation: In the above example, we use the Remove(int StartIndex ) method and specified the StartIndex from which we want to delete the characters till the end.\n\nExample 3: Using Remove(int StartIndex, int count) method with the count of characters to remove.\n\nExplanation: In the above example, we use the Remove(startIndex, count) method and first we specify the index from which we want to remove the characters and the count of the number of characters to remove.\n• None Both above methods do not modify the value of the current string object. Instead, they return a new modified string because in C# strings are immutable and can not be modified.\n• None If StartIndex is equal to the length of the string and the length is zero, the method will not remove any character from the string."
    }
]