[
    {
        "link": "https://stackoverflow.com/questions/43687964/only-numbers-input-number-in-react",
        "document": "I'm trying to exclude minus and plus from input, but it's going wrong:\n\nI tried to mimic your code and noticed that there's an issue on React with . For workaround, check this example and try it yourself: https://codepen.io/zvona/pen/WjpKJX?editors=0010 You need to define it as normal input (type='text') with pattern for numbers only: And then to compare the validity of input: The biggest caveat on this approach is when it comes to mobile --> where keyboard isn't in numeric but in normal alphabetic format.\n\nIf you want to maintain input (probably for mobile devices to trigger the numeric keyboard) you should use instead of to capture your event changes. Using fixed a bug where typing text into a number input would bypass the validation I had assigned to it in . Once I fixed this function to be called in it triggered in all instances. Here's an example of what I'm doing: I came up with a better solution. Use type='tel' along with a pattern regex within the input component itself. The nuts and bolts of how I wired this up is here: class Input extends React.Component { state = {message: '3'}; updateNumber = (e) => { const val = e.target.value; // If the current value passes the validity test then apply that to state if (e.target.validity.valid) this.setState({message: e.target.value}); // If the current val is just the negation sign, or it's been provided an empty string, // then apply that value to state - we still have to validate this input before processing // it to some other component or data structure, but it frees up our input the way a user // would expect to interact with this component else if (val === '' || val === '-') this.setState({message: val}); } render() { return ( <input type='tel' value={this.state.message} onChange={this.updateNumber} pattern=\"^-?[0-9]\\d*\\.?\\d*$\" /> ); } } ReactDOM.render(<Input />, document.getElementById('main')); I have an example of this working on Codepen here\n\nHere is a solution with onBlur, it can be very helpful as it also allows you to format the number the way you need it without requiring any black magic or external library. const toNumber = (value: string | number) => { if (typeof value === 'number') return value return parseInt(value.replace(/[^\\d]+/g, '')) } const formatPrice = (price: string | number) => { return new Intl.NumberFormat('es-PY').format(toNumber(price)) }\n• Allow user to freely type anything they feel\n• onBlur (once the input looses focus):\n• replace any character that is not a digit with an empty string\n• set the value of the input field to the numeric value and apply optional formatting Pay attention: In case your value come from a async source (e.g. fetch): Since defaultValue will only set the value on the first render, you need to make sure to render the component only once the data is there.\n\nAttach a event to the field of your choice - in this example.\n\n In the event-handler function just test the key of with the given regex. In this case if it doesn't match we prevent the default action of the element - so a \"wrong\" key-press within the input box won't be registered thus it will never appear in the input box. The benefit of this solution may be its flexible nature and by changing and/or logically chaining regular expression(s) can fit many requirements. E.g. the regex should match only lowercase English alphanumeric characters with no spaces and only and allowed. Note: that if you use (note the i at the end) will ignore letter case and will still accept capital letters.\n\nUse a pattern validation in order to allow one point (for decimals) and not allow spaces. You need to pass an arrow function in setState() in order to immediately update the state value, once it will be placed back in the input field. Given some context to the state variable. The input field content is evaluated against the regex. If both match, the event's property is assigned as , otherwise : In , the state is immediately updated if is true, otherwise it keeps the previous value (and the text in the input field doesn't change).\n\nIf you want to handle both , and (nothing) for the input as a number then you can use this mix: The will be a that can then be parsed to float when needed (like when passed for back-end call). It means that the is still a number but should be in a string format. Decimal value or no number is usually not handled well by default, so this way I have a controlled string input as a number.\n\nDefine an input with an method like below (in my case, childState contains the state, passed down to this child component). One approach I used was to install validatorJS ( ) I then defined a function , which takes an object that will be used to change your state, in this case, . Note: I needed the OR condition to allow my input to be blank, otherwise it would not let the user backspace (delete) the last integer if they wanted the field blank. The user will now not be allowed to type anything other than backspace, 0-9, or e (this is a number..) in the input field. I referenced this post to create my solution: https://stackoverflow.com/a/45676912/6169225"
    },
    {
        "link": "https://stackoverflow.com/questions/70987832/only-numbers-on-type-text-input-on-react-js-with-hooks",
        "document": "I am trying to avoid any type of string when entering an input. I found a code here on stack overflow which works. However it only works when a number is entered first, or if I put a letter and delete all; it does not work when typing the first letter. And I didn't understand the code that well. I don't even know what is /^[0-9\\b]+$/\n\nHere is the code"
    },
    {
        "link": "https://reddit.com/r/react/comments/1cq768c/how_to_only_accept_numbers_in_a_inputtypetext",
        "document": "Hey guys, I am using react hook form and zod to manage forms. I want to know how to only accept numbers in a input[type=text]. Please Help"
    },
    {
        "link": "https://dev.to/anilsingh/allow-only-numbers-in-input-in-react-2m71",
        "document": "Use value and onChange property of input field to allow only numbers in textbox.\n\n Inside the onChange handle check whether the entered value is valid number or not. Update the state only when entered value is a valid number.\n\nSee the below example to do this.\n\nYou can use Number and conditionally change state.\n\nYou can use regex and conditionally change state.\n\nExplore other examples, 65 Best FAQs and Examples"
    },
    {
        "link": "https://reddit.com/r/reactjs/comments/1c07n8e/how_to_prevent_entering_nondigits_inside_a_custom",
        "document": "The UI Kit we use in our company has some input component that allows to enter any symbol. But I need to make it a numeric field. So I need to ignore any non-digit symbols that a user tries to enter in this field. For that on every key down I check the key with isFinite() and if it's not then I just prevent the default behavior.\n\nBut sometimes a user needs to use combinations like ctrl+A or some other ones. So my solution is not good because I also need to check for all possible shortcuts.\n\nAlso worth to mention that the input is controlled by React Form Hook and not useState"
    },
    {
        "link": "https://react.dev/reference/react/Component",
        "document": "\n• Alternatives\n• Migrating a component with state from a class to a function\n• Migrating a component with lifecycle methods from a class to a function\n• Migrating a component with context from a class to a function\n\nTo define a React component as a class, extend the built-in class and define a method:\n\nOnly the method is required, other methods are optional.\n\nSee more examples below.\n\nThe context of a class component is available as . It is only available if you specify which context you want to receive using .\n\nA class component can only read one context at a time.\n\nThe props passed to a class component are available as .\n\nThe state of a class component is available as . The field must be an object. Do not mutate the state directly. If you wish to change the state, call with the new state.\n\nThe constructor runs before your class component mounts (gets added to the screen). Typically, a constructor is only used for two purposes in React. It lets you declare state and bind your class methods to the class instance:\n\nIf you use modern JavaScript syntax, constructors are rarely needed. Instead, you can rewrite this code above using the public class field syntax which is supported both by modern browsers and tools like Babel:\n\nA constructor should not contain any side effects or subscriptions.\n\nshould not return anything.\n• Do not run any side effects or subscriptions in the constructor. Instead, use for that.\n• Inside a constructor, you need to call before any other statement. If you don’t do that, will be while the constructor runs, which can be confusing and cause bugs.\n• Constructor is the only place where you can assign directly. In all other methods, you need to use instead. Do not call in the constructor.\n• When you use server rendering, the constructor will run on the server too, followed by the method. However, lifecycle methods like or will not run on the server.\n• When Strict Mode is on, React will call twice in development and then throw away one of the instances. This helps you notice the accidental side effects that need to be moved out of the .\n\nIf you define , React will call it when some child component (including distant children) throws an error during rendering. This lets you log that error to an error reporting service in production.\n\nTypically, it is used together with which lets you update state in response to an error and display an error message to the user. A component with these methods is called an error boundary.\n\nSee an example.\n• : The error that was thrown. In practice, it will usually be an instance of but this is not guaranteed because JavaScript allows to any value, including strings or even .\n• : An object containing additional information about the error. Its field contains a stack trace with the component that threw, as well as the names and source locations of all its parent components. In production, the component names will be minified. If you set up production error reporting, you can decode the component stack using sourcemaps the same way as you would do for regular JavaScript error stacks.\n\nshould not return anything.\n• In the past, it was common to call inside in order to update the UI and display the fallback error message. This is deprecated in favor of defining .\n• Production and development builds of React slightly differ in the way handles errors. In development, the errors will bubble up to , which means that any or will intercept the errors that have been caught by . In production, instead, the errors will not bubble up, which means any ancestor error handler will only receive errors not explicitly caught by .\n\nIf you define the method, React will call it when your component is added (mounted) to the screen. This is a common place to start data fetching, set up subscriptions, or manipulate the DOM nodes.\n\nIf you implement , you usually need to implement other lifecycle methods to avoid bugs. For example, if reads some state or props, you also have to implement to handle their changes, and to clean up whatever was doing.\n\ndoes not take any parameters.\n\nshould not return anything.\n• When Strict Mode is on, in development React will call , then immediately call , and then call again. This helps you notice if you forgot to implement or if its logic doesn’t fully “mirror” what does.\n• Although you may call immediately in , it’s best to avoid that when you can. It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though the will be called twice in this case, the user won’t see the intermediate state. Use this pattern with caution because it often causes performance issues. In most cases, you should be able to assign the initial state in the instead. It can, however, be necessary for cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.\n\nIf you define the method, React will call it immediately after your component has been re-rendered with updated props or state. This method is not called for the initial render.\n\nYou can use it to manipulate the DOM after an update. This is also a common place to do network requests as long as you compare the current props to previous props (e.g. a network request may not be necessary if the props have not changed). Typically, you’d use it together with and :\n• : Props before the update. Compare to to determine what changed.\n• : State before the update. Compare to to determine what changed.\n• : If you implemented , will contain the value you returned from that method. Otherwise, it will be .\n\nshould not return anything.\n• will not get called if is defined and returns .\n• The logic inside should usually be wrapped in conditions comparing with , and with . Otherwise, there’s a risk of creating infinite loops.\n• Although you may call immediately in , it’s best to avoid that when you can. It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though the will be called twice in this case, the user won’t see the intermediate state. This pattern often causes performance issues, but it may be necessary for rare cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.\n\nIf you define the method, React will call it before your component is removed (unmounted) from the screen. This is a common place to cancel data fetching or remove subscriptions.\n\nThe logic inside should “mirror” the logic inside . For example, if sets up a subscription, should clean up that subscription. If the cleanup logic in your reads some props or state, you will usually also need to implement to clean up resources (such as subscriptions) corresponding to the old props and state.\n\ndoes not take any parameters.\n\nshould not return anything.\n• When Strict Mode is on, in development React will call , then immediately call , and then call again. This helps you notice if you forgot to implement or if its logic doesn’t fully “mirror” what does.\n\nUsually, this is not necessary. If your component’s method only reads from , , or , it will re-render automatically when you call inside your component or one of its parents. However, if your component’s method reads directly from an external data source, you have to tell React to update the user interface when that data source changes. That’s what lets you do.\n\nTry to avoid all uses of and only read from and in .\n• optional If specified, React will call the you’ve provided after the update is committed.\n\ndoes not return anything.\n• If you call , React will re-render without calling .\n\nIf you implement , React will call it immediately before React updates the DOM. It enables your component to capture some information from the DOM (e.g. scroll position) before it is potentially changed. Any value returned by this lifecycle method will be passed as a parameter to .\n\nFor example, you can use it in a UI like a chat thread that needs to preserve its scroll position during updates:\n\nIn the above example, it is important to read the property directly in . It is not safe to read it in , , or because there is a potential time gap between these methods getting called and React updating the DOM.\n• : Props before the update. Compare to to determine what changed.\n• : State before the update. Compare to to determine what changed.\n\nYou should return a snapshot value of any type that you’d like, or . The value you returned will be passed as the third argument to .\n• will not get called if is defined and returns .\n\nThe method is the only required method in a class component.\n\nThe method should specify what you want to appear on the screen, for example:\n\nReact may call at any moment, so you shouldn’t assume that it runs at a particular time. Usually, the method should return a piece of JSX, but a few other return types (like strings) are supported. To calculate the returned JSX, the method can read , , and .\n\nYou should write the method as a pure function, meaning that it should return the same result if props, state, and context are the same. It also shouldn’t contain side effects (like setting up subscriptions) or interact with the browser APIs. Side effects should happen either in event handlers or methods like .\n\ndoes not take any parameters.\n\ncan return any valid React node. This includes React elements such as , strings, numbers, portals, empty nodes ( , , , and ), and arrays of React nodes.\n• should be written as a pure function of props, state, and context. It should not have side effects.\n• will not get called if is defined and returns .\n• When Strict Mode is on, React will call twice in development and then throw away one of the results. This helps you notice the accidental side effects that need to be moved out of the method.\n• There is no one-to-one correspondence between the call and the subsequent or call. Some of the call results may be discarded by React when it’s beneficial.\n\nCall to update the state of your React component.\n\nenqueues changes to the component state. It tells React that this component and its children need to re-render with the new state. This is the main way you’ll update the user interface in response to interactions.\n\nYou can also pass a function to . It lets you update state based on the previous state:\n\nYou don’t have to do this, but it’s handy if you want to update state multiple times during the same event.\n• : Either an object or a function.\n• If you pass an object as , it will be shallowly merged into .\n• If you pass a function as , it will be treated as an updater function. It must be pure, should take the pending state and props as arguments, and should return the object to be shallowly merged into . React will put your updater function in a queue and re-render your component. During the next render, React will calculate the next state by applying all of the queued updaters to the previous state.\n• optional : If specified, React will call the you’ve provided after the update is committed.\n\ndoes not return anything.\n• Think of as a request rather than an immediate command to update the component. When multiple components update their state in response to an event, React will batch their updates and re-render them together in a single pass at the end of the event. In the rare case that you need to force a particular state update to be applied synchronously, you may wrap it in , but this may hurt performance.\n• does not update immediately. This makes reading right after calling a potential pitfall. Instead, use or the setState argument, either of which are guaranteed to fire after the update has been applied. If you need to set the state based on the previous state, you can pass a function to as described above.\n\nIf you define , React will call it to determine whether a re-render can be skipped.\n\nIf you are confident you want to write it by hand, you may compare with and with and return to tell React the update can be skipped.\n\nReact calls before rendering when new props or state are being received. Defaults to . This method is not called for the initial render or when is used.\n• : The next props that the component is about to render with. Compare to to determine what changed.\n• : The next state that the component is about to render with. Compare to to determine what changed.\n• : The next context that the component is about to render with. Compare to to determine what changed. Only available if you specify .\n\nReturn if you want the component to re-render. That’s the default behavior.\n\nReturn to tell React that re-rendering can be skipped.\n• This method only exists as a performance optimization. If your component breaks without it, fix that first.\n• Consider using instead of writing by hand. shallowly compares props and state, and reduces the chance that you’ll skip a necessary update.\n• We do not recommend doing deep equality checks or using in . It makes performance unpredictable and dependent on the data structure of every prop and state. In the best case, you risk introducing multi-second stalls to your application, and in the worst case you risk crashing it.\n• Returning does not prevent child components from re-rendering when their state changes.\n• Returning does not guarantee that the component will not re-render. React will use the return value as a hint but it may still choose to re-render your component if it makes sense to do for other reasons.\n\nIf you define , React will call it immediately after the . It only exists for historical reasons and should not be used in any new code. Instead, use one of the alternatives:\n• To initialize state, declare as a class field or set inside the .\n• If you need to run a side effect or set up a subscription, move that logic to instead.\n\nSee examples of migrating away from unsafe lifecycles.\n\ndoes not take any parameters.\n\nshould not return anything.\n• will not get called if the component implements or .\n• Despite its naming, does not guarantee that the component will get mounted if your app uses modern React features like . If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. This is why this method is “unsafe”. Code that relies on mounting (like adding a subscription) should go into .\n• is the only lifecycle method that runs during server rendering. For all practical purposes, it is identical to , so you should use the for this type of logic instead.\n\nIf you define , React will call it when the component receives new props. It only exists for historical reasons and should not be used in any new code. Instead, use one of the alternatives:\n• If you need to run a side effect (for example, fetch data, run an animation, or reinitialize a subscription) in response to prop changes, move that logic to instead.\n• If you need to avoid re-computing some data only when a prop changes, use a memoization helper instead.\n• If you need to “reset” some state when a prop changes, consider either making a component fully controlled or fully uncontrolled with a key instead.\n• If you need to “adjust” some state when a prop changes, check whether you can compute all the necessary information from props alone during rendering. If you can’t, use instead.\n\nSee examples of migrating away from unsafe lifecycles.\n• : The next props that the component is about to receive from its parent component. Compare to to determine what changed.\n• : The next context that the component is about to receive from the closest provider. Compare to to determine what changed. Only available if you specify .\n\nshould not return anything.\n• will not get called if the component implements or .\n• Despite its naming, does not guarantee that the component will receive those props if your app uses modern React features like . If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. By the time of the next render attempt, the props might be different. This is why this method is “unsafe”. Code that should run only for committed updates (like resetting a subscription) should go into .\n• does not mean that the component has received different props than the last time. You need to compare and yourself to check if something changed.\n• React doesn’t call with initial props during mounting. It only calls this method if some of component’s props are going to be updated. For example, calling doesn’t generally trigger inside the same component.\n\nIf you define , React will call it before rendering with the new props or state. It only exists for historical reasons and should not be used in any new code. Instead, use one of the alternatives:\n• If you need to run a side effect (for example, fetch data, run an animation, or reinitialize a subscription) in response to prop or state changes, move that logic to instead.\n• If you need to read some information from the DOM (for example, to save the current scroll position) so that you can use it in later, read it inside instead.\n\nSee examples of migrating away from unsafe lifecycles.\n• : The next props that the component is about to render with. Compare to to determine what changed.\n• : The next state that the component is about to render with. Compare to to determine what changed.\n\nshould not return anything.\n• will not get called if is defined and returns .\n• will not get called if the component implements or .\n• It’s not supported to call (or any method that leads to being called, like dispatching a Redux action) during .\n• Despite its naming, does not guarantee that the component will update if your app uses modern React features like . If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. By the time of the next render attempt, the props and state might be different. This is why this method is “unsafe”. Code that should run only for committed updates (like resetting a subscription) should go into .\n• does not mean that the component has received different props or state than the last time. You need to compare with and with yourself to check if something changed.\n• React doesn’t call with initial props and state during mounting.\n\nIf you want to read from your class component, you must specify which context it needs to read. The context you specify as the must be a value previously created by .\n\nYou can define to set the default props for the class. They will be used for and missing props, but not for props.\n\nFor example, here is how you define that the prop should default to :\n\nIf the prop is not provided or is , it will be set by default to :\n\nIf you define , React will call it when a child component (including distant children) throws an error during rendering. This lets you display an error message instead of clearing the UI.\n\nTypically, it is used together with which lets you send the error report to some analytics service. A component with these methods is called an error boundary.\n\nSee an example.\n• : The error that was thrown. In practice, it will usually be an instance of but this is not guaranteed because JavaScript allows to any value, including strings or even .\n\nshould return the state telling the component to display the error message.\n• should be a pure function. If you want to perform a side effect (for example, to call an analytics service), you need to also implement .\n\nIf you define , React will call it right before calling , both on the initial mount and on subsequent updates. It should return an object to update the state, or to update nothing.\n\nThis method exists for rare use cases where the state depends on changes in props over time. For example, this component resets the state when the prop changes:\n\nNote that this pattern requires you to keep a previous value of the prop (like ) in state (like ).\n• : The next props that the component is about to render with.\n• : The next state that the component is about to render with.\n\nreturn an object to update the state, or to update nothing.\n• This method is fired on every render, regardless of the cause. This is different from , which only fires when the parent causes a re-render and not as a result of a local .\n• This method doesn’t have access to the component instance. If you’d like, you can reuse some code between and the other class methods by extracting pure functions of the component props and state outside the class definition.\n\nTo define a React component as a class, extend the built-in class and define a method:\n\nReact will call your method whenever it needs to figure out what to display on the screen. Usually, you will return some JSX from it. Your method should be a pure function: it should only calculate the JSX.\n\nSimilarly to function components, a class component can receive information by props from its parent component. However, the syntax for reading props is different. For example, if the parent component renders , then you can read the prop from , like :"
    },
    {
        "link": "https://legacy.reactjs.org/docs/state-and-lifecycle.html",
        "document": "This page introduces the concept of state and lifecycle in a React component. You can find a detailed component API reference here.\n\nConsider the ticking clock example from one of the previous sections. In Rendering Elements, we have only learned one way to update the UI. We call to change the rendered output:\n\nTry it on CodePen\n\nIn this section, we will learn how to make the component truly reusable and encapsulated. It will set up its own timer and update itself every second.\n\nWe can start by encapsulating how the clock looks:\n\nTry it on CodePen\n\nHowever, it misses a crucial requirement: the fact that the sets up a timer and updates the UI every second should be an implementation detail of the .\n\nIdeally we want to write this once and have the update itself:\n\nTo implement this, we need to add “state” to the component.\n\nState is similar to props, but it is private and fully controlled by the component.\n\nYou can convert a function component like to a class in five steps:\n• Create an ES6 class, with the same name, that extends .\n• Move the body of the function into the method.\n• Replace with in the body.\n\nTry it on CodePen\n\nis now defined as a class rather than a function.\n\nThe method will be called each time an update happens, but as long as we render into the same DOM node, only a single instance of the class will be used. This lets us use additional features such as local state and lifecycle methods.\n\nWe will move the from props to state in three steps:\n• Replace with in the method:\n\nNote how we pass to the base constructor:\n\nClass components should always call the base constructor with .\n• Remove the prop from the element:\n\nWe will later add the timer code back to the component itself.\n\nThe result looks like this:\n\nTry it on CodePen\n\nNext, we’ll make the set up its own timer and update itself every second.\n\nIn applications with many components, it’s very important to free up resources taken by the components when they are destroyed.\n\nWe want to set up a timer whenever the is rendered to the DOM for the first time. This is called “mounting” in React.\n\nWe also want to clear that timer whenever the DOM produced by the is removed. This is called “unmounting” in React.\n\nWe can declare special methods on the component class to run some code when a component mounts and unmounts:\n\nThe method runs after the component output has been rendered to the DOM. This is a good place to set up a timer:\n\nNote how we save the timer ID right on ( ).\n\nWhile is set up by React itself and has a special meaning, you are free to add additional fields to the class manually if you need to store something that doesn’t participate in the data flow (like a timer ID).\n\nWe will tear down the timer in the lifecycle method:\n\nFinally, we will implement a method called that the component will run every second.\n\nIt will use to schedule updates to the component local state:\n\nTry it on CodePen\n\nNow the clock ticks every second.\n\nLet’s quickly recap what’s going on and the order in which the methods are called:\n• When is passed to , React calls the constructor of the component. Since needs to display the current time, it initializes with an object including the current time. We will later update this state.\n• React then calls the component’s method. This is how React learns what should be displayed on the screen. React then updates the DOM to match the ’s render output.\n• When the output is inserted in the DOM, React calls the lifecycle method. Inside it, the component asks the browser to set up a timer to call the component’s method once a second.\n• Every second the browser calls the method. Inside it, the component schedules a UI update by calling with an object containing the current time. Thanks to the call, React knows the state has changed, and calls the method again to learn what should be on the screen. This time, in the method will be different, and so the render output will include the updated time. React updates the DOM accordingly.\n• If the component is ever removed from the DOM, React calls the lifecycle method so the timer is stopped.\n\nThere are three things you should know about .\n\nFor example, this will not re-render a component:\n\nThe only place where you can assign is the constructor.\n\nReact may batch multiple calls into a single update for performance.\n\nBecause and may be updated asynchronously, you should not rely on their values for calculating the next state.\n\nFor example, this code may fail to update the counter:\n\nTo fix it, use a second form of that accepts a function rather than an object. That function will receive the previous state as the first argument, and the props at the time the update is applied as the second argument:\n\nWe used an arrow function above, but it also works with regular functions:\n\nWhen you call , React merges the object you provide into the current state.\n\nFor example, your state may contain several independent variables:\n\nThen you can update them independently with separate calls:\n\nThe merging is shallow, so leaves intact, but completely replaces .\n\nNeither parent nor child components can know if a certain component is stateful or stateless, and they shouldn’t care whether it is defined as a function or a class.\n\nThis is why state is often called local or encapsulated. It is not accessible to any component other than the one that owns and sets it.\n\nA component may choose to pass its state down as props to its child components:\n\nThe component would receive the in its props and wouldn’t know whether it came from the ’s state, from the ’s props, or was typed by hand:\n\nTry it on CodePen\n\nThis is commonly called a “top-down” or “unidirectional” data flow. Any state is always owned by some specific component, and any data or UI derived from that state can only affect components “below” them in the tree.\n\nIf you imagine a component tree as a waterfall of props, each component’s state is like an additional water source that joins it at an arbitrary point but also flows down.\n\nTo show that all components are truly isolated, we can create an component that renders three s:\n\nTry it on CodePen\n\nEach sets up its own timer and updates independently.\n\nIn React apps, whether a component is stateful or stateless is considered an implementation detail of the component that may change over time. You can use stateless components inside stateful components, and vice versa."
    },
    {
        "link": "https://legacy.reactjs.org/docs/react-component.html",
        "document": "This page contains a detailed API reference for the React component class definition. It assumes you’re familiar with fundamental React concepts, such as Components and Props, as well as State and Lifecycle. If you’re not, read them first.\n\nReact lets you define components as classes or functions. Components defined as classes currently provide more features which are described in detail on this page. To define a React component class, you need to extend :\n\nThe only method you must define in a subclass is called . All the other methods described on this page are optional.\n\nWe strongly recommend against creating your own base component classes. In React components, code reuse is primarily achieved through composition rather than inheritance.\n\nEach component has several “lifecycle methods” that you can override to run code at particular times in the process. You can use this lifecycle diagram as a cheat sheet. In the list below, commonly used lifecycle methods are marked as bold. The rest of them exist for relatively rare use cases.\n\nThese methods are called in the following order when an instance of a component is being created and inserted into the DOM:\n\nAn update can be caused by changes to props or state. These methods are called in the following order when a component is being re-rendered:\n\nThis method is called when a component is being removed from the DOM:\n\nThese methods are called when there is an error during rendering, in a lifecycle method, or in the constructor of any child component.\n\nEach component also provides some other APIs:\n\nThe methods in this section cover the vast majority of use cases you’ll encounter creating React components. For a visual reference, check out this lifecycle diagram.\n\nThe method is the only required method in a class component.\n\nWhen called, it should examine and and return one of the following types:\n• React elements. Typically created via JSX. For example, and are React elements that instruct React to render a DOM node, or another user-defined component, respectively.\n• Arrays and fragments. Let you return multiple elements from render. See the documentation on fragments for more details.\n• Portals. Let you render children into a different DOM subtree. See the documentation on portals for more details.\n• String and numbers. These are rendered as text nodes in the DOM.\n• Booleans or or . Render nothing. (Mostly exists to support pattern, where is boolean).\n\nThe function should be pure, meaning that it does not modify component state, it returns the same result each time it’s invoked, and it does not directly interact with the browser.\n\nIf you need to interact with the browser, perform your work in or the other lifecycle methods instead. Keeping pure makes components easier to think about.\n\nIf you don’t initialize state and you don’t bind methods, you don’t need to implement a constructor for your React component.\n\nThe constructor for a React component is called before it is mounted. When implementing the constructor for a subclass, you should call before any other statement. Otherwise, will be undefined in the constructor, which can lead to bugs.\n\nTypically, in React constructors are only used for two purposes:\n• Initializing local state by assigning an object to .\n\nYou should not call in the . Instead, if your component needs to use local state, assign the initial state to directly in the constructor:\n\nConstructor is the only place where you should assign directly. In all other methods, you need to use instead.\n\nAvoid introducing any side-effects or subscriptions in the constructor. For those use cases, use instead.\n\nis invoked immediately after a component is mounted (inserted into the tree). Initialization that requires DOM nodes should go here. If you need to load data from a remote endpoint, this is a good place to instantiate the network request.\n\nThis method is a good place to set up any subscriptions. If you do that, don’t forget to unsubscribe in .\n\nYou may call immediately in . It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though the will be called twice in this case, the user won’t see the intermediate state. Use this pattern with caution because it often causes performance issues. In most cases, you should be able to assign the initial state in the instead. It can, however, be necessary for cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.\n\nis invoked immediately after updating occurs. This method is not called for the initial render.\n\nUse this as an opportunity to operate on the DOM when the component has been updated. This is also a good place to do network requests as long as you compare the current props to previous props (e.g. a network request may not be necessary if the props have not changed).\n\nYou may call immediately in but note that it must be wrapped in a condition like in the example above, or you’ll cause an infinite loop. It would also cause an extra re-rendering which, while not visible to the user, can affect the component performance. If you’re trying to “mirror” some state to a prop coming from above, consider using the prop directly instead. Read more about why copying props into state causes bugs.\n\nIf your component implements the lifecycle (which is rare), the value it returns will be passed as a third “snapshot” parameter to . Otherwise this parameter will be undefined.\n\nis invoked immediately before a component is unmounted and destroyed. Perform any necessary cleanup in this method, such as invalidating timers, canceling network requests, or cleaning up any subscriptions that were created in .\n\nYou should not call in because the component will never be re-rendered. Once a component instance is unmounted, it will never be mounted again.\n\nThe methods in this section correspond to uncommon use cases. They’re handy once in a while, but most of your components probably don’t need any of them. You can see most of the methods below on this lifecycle diagram if you click the “Show less common lifecycles” checkbox at the top of it.\n\nUse to let React know if a component’s output is not affected by the current change in state or props. The default behavior is to re-render on every state change, and in the vast majority of cases you should rely on the default behavior.\n\nis invoked before rendering when new props or state are being received. Defaults to . This method is not called for the initial render or when is used.\n\nThis method only exists as a performance optimization. Do not rely on it to “prevent” a rendering, as this can lead to bugs. Consider using the built-in instead of writing by hand. performs a shallow comparison of props and state, and reduces the chance that you’ll skip a necessary update.\n\nIf you are confident you want to write it by hand, you may compare with and with and return to tell React the update can be skipped. Note that returning does not prevent child components from re-rendering when their state changes.\n\nWe do not recommend doing deep equality checks or using in . It is very inefficient and will harm performance.\n\nCurrently, if returns , then , , and will not be invoked. In the future React may treat as a hint rather than a strict directive, and returning may still result in a re-rendering of the component.\n\nis invoked right before calling the render method, both on the initial mount and on subsequent updates. It should return an object to update the state, or to update nothing.\n\nThis method exists for rare use cases where the state depends on changes in props over time. For example, it might be handy for implementing a component that compares its previous and next children to decide which of them to animate in and out.\n\nDeriving state leads to verbose code and makes your components difficult to think about. Make sure you’re familiar with simpler alternatives:\n• If you need to perform a side effect (for example, data fetching or an animation) in response to a change in props, use lifecycle instead.\n• If you want to re-compute some data only when a prop changes, use a memoization helper instead.\n• If you want to “reset” some state when a prop changes, consider either making a component fully controlled or fully uncontrolled with a instead.\n\nThis method doesn’t have access to the component instance. If you’d like, you can reuse some code between and the other class methods by extracting pure functions of the component props and state outside the class definition.\n\nNote that this method is fired on every render, regardless of the cause. This is in contrast to , which only fires when the parent causes a re-render and not as a result of a local .\n\nis invoked right before the most recently rendered output is committed to e.g. the DOM. It enables your component to capture some information from the DOM (e.g. scroll position) before it is potentially changed. Any value returned by this lifecycle method will be passed as a parameter to .\n\nThis use case is not common, but it may occur in UIs like a chat thread that need to handle scroll position in a special way.\n\nA snapshot value (or ) should be returned.\n\nIn the above examples, it is important to read the property in because there may be delays between “render” phase lifecycles (like ) and “commit” phase lifecycles (like and ).\n\nError boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the component tree that crashed. Error boundaries catch errors during rendering, in lifecycle methods, and in constructors of the whole tree below them.\n\nA class component becomes an error boundary if it defines either (or both) of the lifecycle methods or . Updating state from these lifecycles lets you capture an unhandled JavaScript error in the below tree and display a fallback UI.\n\nOnly use error boundaries for recovering from unexpected exceptions; don’t try to use them for control flow.\n\nFor more details, see Error Handling in React 16.\n\nThis lifecycle is invoked after an error has been thrown by a descendant component. It receives the error that was thrown as a parameter and should return a value to update state.\n\nThis lifecycle is invoked after an error has been thrown by a descendant component. It receives two parameters:\n• - The error that was thrown.\n• - An object with a key containing information about which component threw the error.\n\nis called during the “commit” phase, so side-effects are permitted. It should be used for things like logging errors:\n\nProduction and development builds of React slightly differ in the way handles errors.\n\nOn development, the errors will bubble up to , this means that any or will intercept the errors that have been caught by .\n\nOn production, instead, the errors will not bubble up, which means any ancestor error handler will only receive errors not explicitly caught by .\n\nThe lifecycle methods below are marked as “legacy”. They still work, but we don’t recommend using them in the new code. You can learn more about migrating away from legacy lifecycle methods in this blog post.\n\nis invoked just before mounting occurs. It is called before , therefore calling synchronously in this method will not trigger an extra rendering. Generally, we recommend using the instead for initializing state.\n\nAvoid introducing any side-effects or subscriptions in this method. For those use cases, use instead.\n\nThis is the only lifecycle method called on server rendering.\n\nis invoked before a mounted component receives new props. If you need to update the state in response to prop changes (for example, to reset it), you may compare and and perform state transitions using in this method.\n\nNote that if a parent component causes your component to re-render, this method will be called even if props have not changed. Make sure to compare the current and next values if you only want to handle changes.\n\nReact doesn’t call with initial props during mounting. It only calls this method if some of component’s props may update. Calling generally doesn’t trigger .\n\nis invoked just before rendering when new props or state are being received. Use this as an opportunity to perform preparation before an update occurs. This method is not called for the initial render.\n\nNote that you cannot call here; nor should you do anything else (e.g. dispatch a Redux action) that would trigger an update to a React component before returns.\n\nTypically, this method can be replaced by . If you were reading from the DOM in this method (e.g. to save a scroll position), you can move that logic to .\n\nUnlike the lifecycle methods above (which React calls for you), the methods below are the methods you can call from your components.\n\nThere are just two of them: and .\n\nenqueues changes to the component state and tells React that this component and its children need to be re-rendered with the updated state. This is the primary method you use to update the user interface in response to event handlers and server responses.\n\nThink of as a request rather than an immediate command to update the component. For better perceived performance, React may delay it, and then update several components in a single pass. In the rare case that you need to force the DOM update to be applied synchronously, you may wrap it in , but this may hurt performance.\n\ndoes not always immediately update the component. It may batch or defer the update until later. This makes reading right after calling a potential pitfall. Instead, use or a callback ( ), either of which are guaranteed to fire after the update has been applied. If you need to set the state based on the previous state, read about the argument below.\n\nwill always lead to a re-render unless returns . If mutable objects are being used and conditional rendering logic cannot be implemented in , calling only when the new state differs from the previous state will avoid unnecessary re-renders.\n\nThe first argument is an function with the signature:\n\nis a reference to the component state at the time the change is being applied. It should not be directly mutated. Instead, changes should be represented by building a new object based on the input from and . For instance, suppose we wanted to increment a value in state by :\n\nBoth and received by the updater function are guaranteed to be up-to-date. The output of the updater is shallowly merged with .\n\nThe second parameter to is an optional callback function that will be executed once is completed and the component is re-rendered. Generally we recommend using for such logic instead.\n\nYou may optionally pass an object as the first argument to instead of a function:\n\nThis performs a shallow merge of into the new state, e.g., to adjust a shopping cart item quantity:\n\nThis form of is also asynchronous, and multiple calls during the same cycle may be batched together. For example, if you attempt to increment an item quantity more than once in the same cycle, that will result in the equivalent of:\n\nSubsequent calls will override values from previous calls in the same cycle, so the quantity will only be incremented once. If the next state depends on the current state, we recommend using the updater function form, instead:\n\nFor more detail, see:\n• In depth: When and why are calls batched?\n\nBy default, when your component’s state or props change, your component will re-render. If your method depends on some other data, you can tell React that the component needs re-rendering by calling .\n\nCalling will cause to be called on the component, skipping . This will trigger the normal lifecycle methods for child components, including the method of each child. React will still only update the DOM if the markup changes.\n\nNormally you should try to avoid all uses of and only read from and in .\n\ncan be defined as a property on the component class itself, to set the default props for the class. This is used for props, but not for props. For example:\n\nIf is not provided, it will be set by default to :\n\nIf is set to , it will remain :\n\nThe string is used in debugging messages. Usually, you don’t need to set it explicitly because it’s inferred from the name of the function or class that defines the component. You might want to set it explicitly if you want to display a different name for debugging purposes or when you create a higher-order component, see Wrap the Display Name for Easy Debugging for details.\n\ncontains the props that were defined by the caller of this component. See Components and Props for an introduction to props.\n\nIn particular, is a special prop, typically defined by the child tags in the JSX expression rather than in the tag itself.\n\nThe state contains data specific to this component that may change over time. The state is user-defined, and it should be a plain JavaScript object.\n\nIf some value isn’t used for rendering or data flow (for example, a timer ID), you don’t have to put it in the state. Such values can be defined as fields on the component instance.\n\nSee State and Lifecycle for more information about the state.\n\nNever mutate directly, as calling afterwards may replace the mutation you made. Treat as if it were immutable."
    },
    {
        "link": "https://react.dev/learn/managing-state",
        "document": "Read Reacting to Input with State to learn how to approach interactions with a state-driven mindset. Read More Structuring state well can make a difference between a component that is pleasant to modify and debug, and one that is a constant source of bugs. The most important principle is that state shouldn’t contain redundant or duplicated information. If there’s unnecessary state, it’s easy to forget to update it, and introduce bugs! For example, this form has a redundant state variable:\n\nThis might seem like a small change, but many bugs in React apps are fixed this way. Read Choosing the State Structure to learn how to design the state shape to avoid bugs. Read More Sometimes, you want the state of two components to always change together. To do it, remove state from both of them, move it to their closest common parent, and then pass it down to them via props. This is known as “lifting state up”, and it’s one of the most common things you will do writing React code. In this example, only one panel should be active at a time. To achieve this, instead of keeping the active state inside each individual panel, the parent component holds the state and specifies the props for its children.\n\nRead Sharing State Between Components to learn how to lift state up and keep components in sync. Read More When you re-render a component, React needs to decide which parts of the tree to keep (and update), and which parts to discard or re-create from scratch. In most cases, React’s automatic behavior works well enough. By default, React preserves the parts of the tree that “match up” with the previously rendered component tree. However, sometimes this is not what you want. In this chat app, typing a message and then switching the recipient does not reset the input. This can make the user accidentally send a message to the wrong person:\n\nReact lets you override the default behavior, and force a component to reset its state by passing it a different , like . This tells React that if the recipient is different, it should be considered a different component that needs to be re-created from scratch with the new data (and UI like inputs). Now switching between the recipients resets the input field—even though you render the same component.\n\nRead Preserving and Resetting State to learn the lifetime of state and how to control it. Read More Components with many state updates spread across many event handlers can get overwhelming. For these cases, you can consolidate all the state update logic outside your component in a single function, called “reducer”. Your event handlers become concise because they only specify the user “actions”. At the bottom of the file, the reducer function specifies how the state should update in response to each action!\n\nRead Extracting State Logic into a Reducer to learn how to consolidate logic in the reducer function. Read More Usually, you will pass information from a parent component to a child component via props. But passing props can become inconvenient if you need to pass some prop through many components, or if many components need the same information. Context lets the parent component make some information available to any component in the tree below it—no matter how deep it is—without passing it explicitly through props. Here, the component determines its heading level by “asking” the closest for its level. Each tracks its own level by asking the parent and adding one to it. Every provides information to all components below it without passing props—it does that through context.\n\nRead Passing Data Deeply with Context to learn about using context as an alternative to passing props. Read More Scaling up with reducer and context Reducers let you consolidate a component’s state update logic. Context lets you pass information deep down to other components. You can combine reducers and context together to manage state of a complex screen. With this approach, a parent component with complex state manages it with a reducer. Other components anywhere deep in the tree can read its state via context. They can also dispatch actions to update that state."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/how-to-manage-state-on-react-class-components",
        "document": "The author selected Creative Commons to receive a donation as part of the Write for DOnations program.\n\nIn React, state refers to a structure that keeps track of how data changes over time in your application. Managing state is a crucial skill in React because it allows you to make interactive components and dynamic web applications. State is used for everything from tracking form inputs to capturing dynamic data from an API. In this tutorial, you’ll run through an example of managing state on class-based components.\n\nAs of the writing of this tutorial, the official React documentation encourages developers to adopt React Hooks to manage state with functional components when writing new code, rather than using class-based components. Although the use of React Hooks is considered a more modern practice, it’s important to understand how to manage state on class-based components as well. Learning the concepts behind state management will help you navigate and troubleshoot class-based state management in existing code bases and help you decide when class-based state management is more appropriate. There’s also a class-based method called that is not available in Hooks and will require setting state using class methods.\n\nThis tutorial will first show you how to set state using a static value, which is useful for cases where the next state does not depend on the first state, such as setting data from an API that overrides old values. Then it will run through how to set a state as the current state, which is useful when the next state depends on the current state, such as toggling a value. To explore these different ways of setting state, you’ll create a product page component that you’ll update by adding purchases from a list of options.\n• You will need a development environment running Node.js; this tutorial was tested on Node.js version 10.20.1 and npm version 6.14.4. To install this on macOS or Ubuntu 18.04, follow the steps in How to Install Node.js and Create a Local Development Environment on macOS or the Installing Using a PPA section of How To Install Node.js on Ubuntu 18.04.\n• In this tutorial, you will create apps with Create React App. You can find instructions for installing an application with Create React App at How To Set Up a React Project with Create React App.\n• You will also need a basic knowledge of JavaScript, which you can find in How To Code in JavaScript, along with a basic knowledge of HTML and CSS. A good resource for HTML and CSS is the Mozilla Developer Network.\n\nIn this step, you’ll create a new project using Create React App. Then you will delete the sample project and related files that are installed when you bootstrap the project. Finally, you will create a simple file structure to organize your components. This will give you a solid basis on which to build this tutorial’s sample application for managing state on class-based components.\n\nTo start, make a new project. In your terminal, run the following script to install a fresh project using :\n\nAfter the project is finished, change into the directory:\n\nIn a new terminal tab or window, start the project using the Create React App start script. The browser will auto-refresh on changes, so leave this script running while you work:\n\nYou will get a running local server. If the project did not open in a browser window, you can open it with . If you are running this from a remote server, the address will be .\n\nYour browser will load with a simple React application included as part of Create React App:\n\nYou will be building a completely new set of custom components, so you’ll need to start by clearing out some boilerplate code so that you can have an empty project.\n\nTo start, open in a text editor. This is the root component that is injected into the page. All components will start from here. You can find more information about at How To Set Up a React Project with Create React App.\n\nOpen with the following command:\n\nYou will see a file like this:\n\nDelete the line . Then replace everything in the statement to return a set of empty tags: . This will give you a valid page that returns nothing. The final code will look like this:\n\nFinally, delete the logo. You won’t be using it in your application and you should remove unused files as you work. It will save you from confusion in the long run.\n\nIn the terminal window type the following command:\n\nIf you look at your browser, you will see a blank screen.\n\nNow that you have cleared out the sample Create React App project, create a simple file structure. This will help you keep your components isolated and independent.\n\nCreate a directory called in the directory. This will hold all of your custom components.\n\nEach component will have its own directory to store the component file along with the styles, images, and tests.\n\nMove all of the files into that directory. Use the wildcard, , to select any files that start with regardless of file extension. Then use the command to put them into the new directory:\n\nNext, update the relative import path in , which is the root component that bootstraps the whole process:\n\nThe import statement needs to point to the file in the directory, so make the following highlighted change:\n\nNow that the project is set up, you can create your first component.\n\nIn this step, you’ll set the initial state of a component on its class and reference the state to display a value. You’ll then make a product page with a shopping cart that displays the total items in the cart using the state value. By the end of the step, you’ll know the different ways to hold a value and when you should use state rather than a prop or a static value.\n\nNext, open up in that directory:\n\nStart by creating a component with no state. The component will have two parts: The cart, which has the number of items and the total price, and the product, which has a button to add and remove an item. For now, the buttons will have no actions.\n\nAdd the following code to :\n\nYou have also included a couple of elements that have JSX class names so you can add some basic styling.\n\nSave and close the file, then open :\n\nGive some light styling to increase the for the text and the emoji:\n\nThe emoji will need a much larger font size than the text, since it’s acting as the product image in this example. In addition, you are removing the default gradient background on buttons by setting the to .\n\nNow, render the component in the component so you can see the results in the browser. Open :\n\nImport the component and render it. You can also delete the CSS import since you won’t be using it in this tutorial:\n\nSave and close the file. When you do, the browser will refresh and you’ll see the component.\n\nThere are two values in your component values that are going to change in your display: total number of items and total cost. Instead of hard coding them, in this step you’ll move them into an object called .\n\nThe of a React class is a special property that controls the rendering of a page. When you change the state, React knows that the component is out-of-date and will automatically re-render. When a component re-renders, it modifies the rendered output to include the most up-to-date information in . In this example, the component will re-render whenever you add a product to the cart or remove it from the cart. You can add other properties to a React class, but they won’t have the same ability to trigger re-rendering.\n\nAdd a property called to the class. Then add two values to the object: and . The will be an array, since it may eventually hold many items. The will be a number. After assigning these, replace references to the values with :\n\nNotice that in both cases, since you are referencing JavaScript inside of your JSX, you need to wrap the code in curly braces. You are also displaying the of the array to get a count of the number of items in the array.\n\nSave the file. When you do, the browser will refresh and you’ll see the same page as before.\n\nThe property is a standard class property, which means that it is accessible in other methods, not just the method.\n\nNext, instead of displaying the price as a static value, convert it to a string using the method, which will convert the number to a string that matches the way numbers are displayed in the browser’s region.\n\nCreate a method called that takes the and converts it to a localized string using an array of . Then, replace the reference to in the JSX with a method call:\n\nSince is a price for goods, you are passing that set the maximum and minimum decimal places for your to two. Note that this is set as a separate property. Often, beginner React developers will put information like this in the object, but it is best to only add information to that you expect to change. This way, the information in will be easier to keep strack of as your application scales.\n\nAnother important change you made was to create the method by assigning an arrow function to a class property. Without using the arrow function, this method would create a new binding, which would interfere with the current binding and introduce a bug into our code. You’ll see more on this in the next step.\n\nSave the file. When you do, the page will refresh and you’ll see the value converted to a decimal.\n\nYou’ve now added state to a component and referenced it in your class. You also accessed values in the method and in other class methods. Next, you’ll create methods to update the state and show dynamic values.\n\nSo far you’ve created a base state for the component and you’ve referenced that state in your functions and your JSX code. In this step, you’ll update your product page to modify the on button clicks. You’ll learn how to pass a new object containing updated values to a special method called , which will then set the with the updated data.\n\nTo update , React developers use a special method called that is inherited from the base class. The method can take either an object or a function as the first argument. If you have a static value that doesn’t need to reference the , it’s best to pass an object containing the new value, since it’s easier to read. If you need to reference the current state, you pass a function to avoid any references to out-of-date .\n\nStart by adding an event to the buttons. If your user clicks Add, then the program will add the item to the and update the . If they click Remove, it will reset the cart to an empty array and the to . For example purposes, the program will not allow a user to add an item more then once.\n\nInside the component, create a new method called , then pass the method to the prop for the Add button:\n\nInside the method, you call the method and pass an object containing the updated with a single item and the updated price of . Notice that you again used an arrow function to create the method. As mentioned before, this will ensure the function has the proper context when running the update. If you add the function as a method without using the arrow function, the would not exist without binding the function to the current context.\n\nFor example, if you created the function this way:\n\nThe user would get an error when they click on the Add button.\n\nUsing an arrow function ensures that you’ll have the proper context to avoid this error.\n\nSave the file. When you do, the browser will reload, and when you click on the Add button the cart will update with the current amount.\n\nWith the method, you passed both properties of the object: and . However, you do not always need to pass a complete object. You only need to pass an object containing the properties that you want to update, and everything else will stay the same.\n\nTo see how React can handle a smaller object, create a new function called . Pass a new object containing just the with an empty array, then add the method to the property of the Remove button:\n\nSave the file. When the browser refreshes, click on the Add and Remove buttons. You’ll see the cart update, but not the price. The state value is preserved during the update. This value is only preserved for example purposes; with this application, you would want to update both properties of the object. But you will often have components with stateful properties that have different responsibilities, and you can make them persist by leaving them out of the updated object.\n\nThe change in this step was static. You knew exactly what the values would be ahead of time, and they didn’t need to be recalculated from . But if the product page had many products and you wanted to be able to add them multiple times, passing a static object would provide no guarantee of referencing the most up-to-date , even if your object used a value. In this case, you could instead use a function.\n\nIn the next step, you’ll update using functions that reference the current state.\n\nThere are many times when you’ll need to reference a previous state to update a current state, such as updating an array, adding a number, or modifying an object. To be as accurate as possible, you need to reference the most up-to-date object. Unlike updating with a predefined value, in this step you’ll pass a function to the method, which will take the current state as an argument. Using this method, you will update a component’s state using the current state.\n\nAnother benefit of setting with a function is increased reliability. To improve performance, React may batch calls, which means that may not be fully reliable. For example, if you update quickly in several places, it is possible that a value could be out of date. This can happen during data fetches, form validations, or any situation where several actions are occurring in parallel. But using a function with the most up-to-date as the argument ensures that this bug will not enter your code.\n\nTo demonstrate this form of state management, add some more items to the product page. First, open the file:\n\nNext, create an array of objects for different products. The array will contain the product emoji, name, and price. Then loop over the array to display each product with an Add and Remove button:\n\nIn this code, you are using the array method to loop over the array and return the JSX that will display each element in your browser.\n\nSave the file. When the browser reloads, you’ll see an updated product list:\n\nNow you need to update your methods. First, change the method to take the as an argument. Then instead of passing an object to , pass a function that takes the as an argument and returns an object that has the updated with the new product and the updated with the new price:\n\nInside the anonymous function that you pass to , make sure you reference the argument— —and not the component’s state— . Otherwise, you still run a risk of getting an out-of-date object. The in your function will be otherwise identical.\n\nTake care not to directly mutate state. Instead, when adding a new value to the , you can add the new to the by using the spread syntax on the current value and adding the new value onto the end.\n\nFinally, update the call to by changing the prop to take an anonymous function that calls with the relevant product.\n\nSave the file. When you do, the browser will reload and you’ll be able to add multiple products.\n\nNext, update the method. Follow the same steps: convert to take a function, update the values without mutating, and update the prop:\n\nTo avoid mutating the state object, you must first make a copy of it using the operator. Then you can splice out the item you want from the copy and return the copy in the new object. By copying as the first step, you can be sure that you will not mutate the object.\n\nSave the file. When you do, the browser will refresh and you’ll be able to add and remove items:\n\nThere is still a bug in this application: In the method, a user can subtract from the even if the item is not in the . If you click Remove on the ice cream without adding it to your cart, your total will be -5.00.\n\nYou can fix the bug by checking for an item’s existence before subtracting, but an easier way is to keep your state object small by only keeping references to the products and not separating references to products and total cost. Try to avoid double references to the same data. Instead, store the raw data in — in this case the whole object—then perform the calculations outside of the .\n\nRefactor the component so that the method adds the whole object, the method removes the whole object, and the method uses the :\n\nThe method is similar to what it was before, except that reference to the property has been removed. In the method, you find the index of the with . If the index doesn’t exist, you’ll get a . In that case, you use a conditional statement toreturn nothing. By returning nothing, React will know the didn’t change and won’t trigger a re-render. If you return or an empty object, it will still trigger a re-render.\n\nWhen using the method, you are now passing as the second argument, which will remove one value and keep the rest.\n\nFinally, you calculate the using the array method.\n\nSave the file. When you do, the browser will refresh and you’ll have your final :\n\nThe function you pass can have an additional argument of the current props, which can be helpful if you have state that needs to reference the current props. You can also pass a callback function to as the second argument, regardless of if you pass an object or function for the first argument. This is particularly useful when you are setting after fetching data from an API and you need to perform a new action after the update is complete.\n\nIn this step, you learned how to update a new state based on the current state. You passed a function to the function and calculated new values without mutating the current state. You also learned how to exit a function if there is no update in a manner that will prevent a re-render, adding a slight performance enhancement.\n\nIn this tutorial, you have developed a class-based component with a dynamic state that you’ve updated statically and using the current state. You now have the tools to make complex projects that respond to users and dynamic information.\n\nReact does have a way to manage state with Hooks, but it is helpful to understand how to use state on components if you need to work with components that must be class-based, such as those that use the method.\n\nManaging state is key to nearly all components and is necessary for creating interactive applications. With this knowledge you can recreate many common web components, such as sliders, accordions, forms, and more. You will then use the same concepts as you build applications using hooks or develop components that pull data dynamically from APIs.\n\nIf you would like to look at more React tutorials, check out our React Topic page, or return to the How To Code in React.js series page."
    }
]