[
    {
        "link": "https://geeksforgeeks.org/loops-in-python",
        "document": "Loops in Python are used to repeat actions efficiently. The main types are For loops (counting through items) and While loops (based on conditions). Additionally, Nested Loops allow looping within loops for more complex tasks. While all the ways provide similar basic functionality, they differ in their syntax and condition-checking time. In this article, we will look at Python loops and understand their working with the help of examples.\n\nIn Python, a while loop is used to execute a block of statements repeatedly until a given condition is satisfied. When the condition becomes false, the line immediately after the loop in the program is executed.\n\nAll the statements indented by the same number of character spaces after a programming construct are considered to be part of a single block of code. Python uses indentation as its method of grouping statements.\n\nExample of Python While Loop:\n\nUsing else statement with While Loop in Python\n\nElse clause is only executed when our while condition becomes false. If we break out of the loop or if an exception is raised then it won’t be executed.\n\nSyntax of While Loop with else statement:\n\nThe code prints “Hello Geek” three times using a ‘while’ loop and then after the loop it prints “In Else Block” because there is an “else” block associated with the ‘while’ loop.\n\nIf we want a block of code to execute infinite number of times then we can use the while loop in Python to do so.\n\nThe code given below uses a ‘while’ loop with the condition (count == 0) and this loop will only run as long as count is equal to 0. Since count is initially set to 0, the loop will execute indefinitely because the condition is always true.\n\nNote: It is suggested not to use this type of loop as it is a never-ending infinite loop where the condition is always true and we have to forcefully terminate the compiler.\n\nFor loops are used for sequential traversal. For example: traversing a list or string or array etc. In Python, there is “for in” loop which is similar to foreach loop in other languages. Let us learn how to use for loops in Python for sequential traversals with examples.\n\nExplanation: This code prints the numbers from 0 to 3 (inclusive) using a for loop that iterates over a range from 0 to n-1 (where n = 4).\n\nExample with List, Tuple, String, and Dictionary Iteration Using for Loops in Python\n\nWe can use for loop to iterate lists, tuples, strings and dictionaries in Python.\n\nIterating by the Index of Sequences\n\nWe can also use the index of elements in the sequence to iterate. The key idea is to first calculate the length of the list and in iterate over the sequence within the range of this length.\n\nExplanation: This code iterates through each element of the list using its index and prints each element one by one. The range(len(list)) generates indices from 0 to the length of the list minus 1.\n\nUsing else Statement with for Loop in Python\n\nWe can also combine else statement with for loop like in while loop. But as there is no condition in for loop based on which the execution will terminate so the else block will be executed immediately after for block finishes execution.\n\nExplanation: The code iterates through the list and prints each element. After the loop ends it prints “Inside Else Block” as the else block executes when the loop completes without a break.\n\nPython programming language allows to use one loop inside another loop which is called nested loop. Following section shows few examples to illustrate the concept.\n\nThe syntax for a nested while loop statement in the Python programming language is as follows:\n\nA final note on loop nesting is that we can put any type of loop inside of any other type of loops in Python. For example, a for loop can be inside a while loop or vice versa.\n\nExplanation: In the above code we use nested loops to print the value of i multiple times in each row, where the number of times it prints i increases with each iteration of the outer loop. The print() function prints the value of i and moves to the next line after each row.\n\nLoop control statements change execution from their normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed. Python supports the following control statements.\n\nThe continue statement in Python returns the control to the beginning of the loop.\n\nExplanation: The continue statement is used to skip the current iteration of a loop and move to the next iteration. It is useful when we want to bypass certain conditions without terminating the loop.\n\nThe break statement in Python brings control out of the loop.\n\nExplanation: break statement is used to exit the loop prematurely when a specified condition is met. In this example, the loop breaks when the letter is either ‘e’ or ‘s’, stopping further iteration.\n\nWe use pass statement in Python to write empty loops. Pass is also used for empty control statements, functions and classes.\n\nExplanation: In this example, the loop iterates over each letter in ‘geeksforgeeks’ but doesn’t perform any operation, and after the loop finishes, the last letter (‘s’) is printed.\n\nHow for loop works internally in Python?\n\nBefore proceeding to this section, we should have a prior understanding of Python Iterators.\n\nFirstly, lets see how a simple for loops in Python looks like.\n\nExample: This Python code iterates through a list called fruits, containing “apple”, “orange” and “kiwi.” It prints each fruit name on a separate line, displaying them in the order they appear in the list.\n\nThis code iterates over each item in the fruits list and prints the item (fruit) on each iteration and the output will display each fruit on a new line.\n\nThis Python code manually iterates through a list of fruits using an iterator. It prints each fruit’s name one by one and stops when there are no more items in the list.\n\nWe can see that under the hood we are calling iter() and next() method.\n• None Difference between for loop and while loop in Python\n• None Use for Loop That Loops Over a Sequence in Python\n\nWhich loop is faster in Python?\n\nWhy is Python slow in loops?\n\nHow many loops are used in Python?\n\nIs for loop bad in Python?"
    },
    {
        "link": "https://stackoverflow.com/questions/77027077/optimizing-a-nested-loop-algorithm-for-maximum-efficiency",
        "document": "Performance optimisation is a complicated field and typically requires making use of all available information about the specific problem. Your 'Perform Some Computations' comment doesn't provide any details at all. However, I'll try to give some general pointers.\n\nYour main options are as follows.\n• Using a fast compiled language (e.g. c, c++).\n• Using a fast compiled language with multithreading and SIMD.\n• Using GPGPU or other accelerators.\n\nSometimes, there are opportunities for performance gains by using a different algorithm. It is often the case that faster algorithms are more complicated to code, so more work to write test and maintain than simple algorithms, so their benefit needs to considered against their costs. Also, a common mistake people often make is to assume that algorithms with faster asymptotic complexity are 'faster' but they may not always be.\n\nCode optimisations typically means using more variables to avoid repeating computations.\n\nSometimes, just switching from a 'slow' language like python (though it has many fast library functions) to a language that can be compiled with performance optimisations can give massive performance improvements. Billions of arithmetic operations per second are possible on modern CPUs on a single thread.\n\nIf the algorithm can be parallelised, then the following can also be considered. Tasks that are memory, IO, or network bound may not benefit much from parallelisation.\n\nFurther speed-up can sometimes be made by using your CPUs vector instructions. Sometimes compilers can figure out how to make use of these themselves if the program is compiled with those instructions enabled. These builds can be quite brittle though, and a small change, or even a re-compilation with another compiler might lose that optimisation. Programs can be manually vectorised using intrinsics but such code is no longer portable across different CPU architectures. One may have to write a slower portable version as well. These SIMD instructions are great for optimising code that has a short runtime, of the order of <1m machine cycles or so (~100 us). Other ways of parallelising code like GPGPU and multithreading come with overheads that make them unsuitable for such instances. SIMD instructions are generally quite primitive, so there may not be much opportunity for gains if you require complicated maths functions like trig functions and logs etc. Tens of billions of arithmetic operations per second are possible on modern CPUs with SIMD vector instructions on a single thread.\n\nMultithreading makes use of more of the CPUs cores to execute code in parallel. Not all tasks can be parallelised, but when they can, provided the work to be done takes significantly more time than the cost of starting the threads, then performance can often be improved by a factor of the order of the number of CPU cores available. Multi threaded programs however, can be significantly more difficult to write, test and maintain than their single threaded equivalents though there are tools like OpenMP that can make it much easier. Sometimes when the main part of an algorithm can not be parallelised, it can still be broken up into a few threads to make the overall runtime not much longer than that of the most time consuming dependency chain. For example, one thread can be loading a new batch of data for the main algorithm to process while another thread is processing the previous batch.\n\nTo squeeze the absolute maximum computational performance from a modern CPU, you may be able write your program using both multithreading and SIMD. Tens of billions of arithmetic operations per second are possible on modern CPUs per thread.\n\nAs fast as modern CPUs are at running parallelisable code, modern GPUs are much faster. In 2023, a high end GPU can execute tens of trillions of arithmetic operations per second. There is a significant overhead though, passing data and commands between the host CPU and the GPU. It makes the most sense to use GPGPU (General Purpose GPU (Graphics Processing Unit)) computing for tasks with runtimes over 1ms. That can still mean billions of operations. There's also a runtime compilation which might take a second or so at program startup. CUDA has become the dominant API for this purpose followed by OpenCL, Vulkan Kompute and a few other less well known options. GPU architectures vary significantly across vendors and models and choosing a good architecture for the required task can make a big difference to the performance achieved. The performance of modern GPUs in memory bandwidth, integer, fp16, or fp64 can vary in unexpected ways across models so attention should be paid to particular architectures' capabilities."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-analyse-loops-for-complexity-analysis-of-algorithms",
        "document": "We have discussed Asymptotic Analysis, Worst, Average and Best Cases and Asymptotic Notations in previous posts. In this post, an analysis of iterative programs with simple examples is discussed.\n\nThe analysis of loops for the complexity analysis of algorithms involves finding the number of operations performed by a loop as a function of the input size. This is usually done by determining the number of iterations of the loop and the number of operations performed in each iteration.\n\nHere are the general steps to analyze loops for complexity analysis:\n\nDetermine the number of iterations of the loop. This is usually done by analyzing the loop control variables and the loop termination condition.\n\nDetermine the number of operations performed in each iteration of the loop. This can include both arithmetic operations and data access operations, such as array accesses or memory accesses.\n\nExpress the total number of operations performed by the loop as a function of the input size. This may involve using mathematical expressions or finding a closed-form expression for the number of operations performed by the loop.\n\nDetermine the order of growth of the expression for the number of operations performed by the loop. This can be done by using techniques such as big O notation or by finding the dominant term and ignoring lower-order terms.\n\nThe time complexity of a function (or set of statements) is considered as O(1) if it doesn’t contain a loop, recursion, and call to any other non-constant time function. \n\n i.e. set of non-recursive and non-loop statements\n\nIn computer science, O(1) refers to constant time complexity, which means that the running time of an algorithm remains constant and does not depend on the size of the input. This means that the execution time of an O(1) algorithm will always take the same amount of time regardless of the input size. An example of an O(1) algorithm is accessing an element in an array using an index.\n• None A loop or recursion that runs a constant number of times is also considered O(1). For example, the following loop is O(1).\n\nThe Time Complexity of a loop is considered as O(n) if the loop variables are incremented/decremented by a constant amount. For example following functions have O(n) time complexity. Linear time complexity, denoted as O(n), is a measure of the growth of the running time of an algorithm proportional to the size of the input. In an O(n) algorithm, the running time increases linearly with the size of the input. For example, searching for an element in an unsorted array or iterating through an array and performing a constant amount of work for each element would be O(n) operations. In simple words, for an input of size n, the algorithm takes n steps to complete the operation.\n\nThe time complexity is defined as an algorithm whose performance is directly proportional to the squared size of the input data, as in nested loops it is equal to the number of times the innermost statement is executed. For example, the following sample loops have O(n2) time complexity\n\nQuadratic time complexity, denoted as O(n^2), refers to an algorithm whose running time increases proportional to the square of the size of the input. In other words, for an input of size n, the algorithm takes n * n steps to complete the operation. An example of an O(n^2) algorithm is a nested loop that iterates over the entire input for each element, performing a constant amount of work for each iteration. This results in a total of n * n iterations, making the running time quadratic in the size of the input.\n\nExample: Selection sort and Insertion Sort have O(n2) time complexity.\n\nThe time Complexity of a loop is considered as O(Logn) if the loop variables are divided/multiplied by a constant amount. And also for recursive calls in the recursive function, the Time Complexity is considered as O(Logn).\n\nThe Time Complexity of a loop is considered as O(LogLogn) if the loop variables are reduced/increased exponentially by a constant amount.\n\nSee this for mathematical details.\n\nHow to combine the time complexities of consecutive loops?\n\nWhen there are consecutive loops, we calculate time complexity as a sum of the time complexities of individual loops.\n\nTo combine the time complexities of consecutive loops, you need to consider the number of iterations performed by each loop and the amount of work performed in each iteration. The total time complexity of the algorithm can be calculated by multiplying the number of iterations of each loop by the time complexity of each iteration and taking the maximum of all possible combinations.\n\nFor example, consider the following code:\n\nHere, the outer loop performs n iterations, and the inner loop performs m iterations for each iteration of the outer loop. So, the total number of iterations performed by the inner loop is n * m, and the total time complexity is O(n * m).\n\nIn another example, consider the following code:\n\nHere, the outer loop performs n iterations, and the inner loop performs i iterations for each iteration of the outer loop, where i is the current iteration count of the outer loop. The total number of iterations performed by the inner loop can be calculated by summing the number of iterations performed in each iteration of the outer loop, which is given by the formula sum(i) from i=1 to n, which is equal to n * (n + 1) / 2. Hence, the total time complex\n\n\n\nHow to calculate time complexity when there are many if, else statements inside loops?\n\nAs discussed here, the worst-case time complexity is the most useful among best, average and worst. Therefore we need to consider the worst case. We evaluate the situation when values in if-else conditions cause a maximum number of statements to be executed. \n\nFor example, consider the linear search function where we consider the case when an element is present at the end or not present at all. \n\nWhen the code is too complex to consider all if-else cases, we can get an upper bound by ignoring if-else and other complex control statements.\n\nHow to calculate the time complexity of recursive functions?\n\nThe time complexity of a recursive function can be written as a mathematical recurrence relation. To calculate time complexity, we must know how to solve recurrences. We will soon be discussing recurrence-solving techniques as a separate post.\n\nQuiz on Analysis of Algorithms \n\nFor more details, please refer: Design and Analysis of Algorithms.\n\nPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above."
    },
    {
        "link": "https://pynative.com/python-nested-loops",
        "document": "In Python, a loop inside a loop is known as a nested loop. In this tutorial, we will learn about nested loops in Python with the help of examples.\n\nWhat is a Nested Loop in Python?\n\nA nested loop is a loop inside the body of the outer loop. The inner or outer loop can be any type, such as a while loop or for loop. For example, the outer loop can contain a loop and vice versa.\n\nThe outer loop can contain more than one inner loop. There is no limitation on the chaining of loops.\n\nIn the nested loop, the number of iterations will be equal to the number of iterations in the outer loop multiplied by the iterations in the inner loop.\n\nIn each iteration of the outer loop inner loop execute all its iteration. For each iteration of an outer loop the inner loop re-start and completes its execution before the outer loop can continue to its next iteration.\n\nNested loops are typically used for working with multidimensional data structures, such as printing two-dimensional arrays, iterating a list that contains a nested list.\n\nA nested loop is a part of a control flow statement that helps you to understand the basics of Python.\n\nIn Python, the for loop is used to iterate over a sequence such as a list, string, tuple, other iterable objects such as range.\n\nSyntax of using a nested for loop in Python\n\nIn this example, we are using a for loop inside a loop. In this example, we are printing a multiplication table of the first ten numbers.\n• The outer loop uses the range() function to iterate over the first ten numbers\n• The inner loop will execute ten times for each outer number\n• In the body of the inner loop, we will print the multiplication of the outer number and current number\n• The inner loop is nothing but a body of an outer loop.\n\nExample: Write a nested loop program to print multiplication table in Python\n• In this program, the outer loop is iterate numbers from 1 to 10. The return 10 numbers. So total number of iteration of the outer loop is 10.\n• In the first iteration of the nested loop, the number is 1. In the next, it 2. and so on till 10.\n• Next, For each iteration of the outer loop, the inner loop will execute ten times. The inner loop will also execute ten times because we are printing multiplication table up to ten.\n• In each iteration of an inner loop, we calculated the multiplication of two numbers.\n\nAnother most common use of nested loop is to print various star and number patterns.\n\nLet’s see how to use a nested loop to print the following pattern in Python.\n• In this program, the outer loop is the number of rows print.\n• The number of rows is five, so the outer loop will execute five times\n• Next, the inner loop is the total number of columns in each row.\n• For each iteration of the outer loop, the columns count gets incremented by 1\n• In the first iteration of the outer loop, the column count is 1, in the next it 2. and so on.\n• The inner loop iteration is equal to the count of columns.\n• In each iteration of an inner loop, we print star\n\nIt is very common and helpful to use one type of loop inside another. we can put a while loop inside the loop.\n\nAssume we wanted to repeat each name from a list five times.\n• Here we will iterate the list using an outer for loop\n• In each iteration of outer for loop, the inner for loop execute five times to print the current name five times\n\nPractice: Print a rectangle Pattern with 5 rows and 3 columns of stars\n\nThe break statement is used inside the loop to exit out of the loop. If the break statement is used inside a nested loop (loop inside another loop), it will terminate the innermost loop.\n\nIn the following example, we have two loops. The outer loop iterates the first four numbers using the function, and the inner loop also iterates the first four numbers. If the outer number and a current number of the inner loop are the same, then break the inner (nested) loop.\n\nAs you can see in the output, no rows contain the same number.\n\nThe continue statement skip the current iteration and move to the next iteration. In Python, when the statement is encountered inside the loop, it skips all the statements below it and immediately jumps to the next iteration.\n\nIn the following example, we have two loops. The outer for loop iterates the first list, and the inner loop also iterates the second list of numbers.\n\nIf the outer number and the inner loop’s current number are the same, then move to the next iteration of an inner loop.\n\nAs you can see in the output, no same numbers multiplying to each other.\n\nFor example, if you had two lists and want to get all combinations of them, To achieve this, you need to use two nested loops as mentioned below.\n\nYou can write more fast and compact code using the list compression and nested loop like as shown below.\n\nHow to write it:\n• First, Write an outer loop that will iterate the first list like [for i in first]\n• Next, Write an inner loop that will iterate the second list after the outer loop like [for i in first for j in second]\n• Last, calculate the addition of the outer number and inner number like [i+j for i in first for j in second]\n• At last, store result in a new list like final = [i+j for i in first for j in second]\n\nLet’s see more such examples.\n\nIn this example, we will use two loops in list Comprehension and the final result would be a list of lists. we will not include the same numbers in each list. we will filter them using an if condition.\n\nIn Python, The while loop statement repeatedly executes a code block while a particular condition is true. We use w a while loop when number iteration is not fixed.\n\nIn this section, we will see how to use a while loop inside another while loop.\n\nThe syntax to write a nested while loop statement in Python is as follows:\n\nIn this example, we will print the first 10 numbers on each line 5 times.\n\nSometimes it is helpful to use one type of loop inside another. we can put a loop inside the loop.\n\nAssume we wanted to print all perfect numbers from 1 to 100\n• Here we will iterate the first 100 numbers using a loop\n• In each iteration of the outer loop, the inner loop execute from 1 up to the current outer number to check if the current number is a perfect number.\n\nWhen To Use a Nested Loop in Python?\n• Nested loops are handy when you have nested arrays or lists that need to be looped through the same function.\n• When you want to print different star and number patterns using rows can columns\n\nKeep the time complexity in mind. Let’s understand this with examples on how nested for loop work in Python.\n\nWe use for loop to iterates on the given elements of a sequence or iterable. like . Here time complexity is O(n) because we are iterating all items from a list.\n\nThe number of execution steps (iterations) determines the time complexity of a loop.\n\nWhen you use a nested loop and both outer and inner loop runs without any if condition in it, the time complexity is because, for all of the n elements, the code is executed n times.\n\nIf you give a condition in the inner loop that will stop executing after some elements and not execute all n iterations of the inner loop or outer loop, it will have less time complexity.\n\nUse nested loop when you don’t have any better alternatives, Remember writing efficient and compact code is far better than writing complex code."
    },
    {
        "link": "https://stackoverflow.com/questions/59052383/algorithm-for-arbitrary-number-of-nested-for-loops",
        "document": "I am trying to figure out an algorithm to generalise my code for an arbitrary integer value of a parameter that in my code controls the number of nested for loops. My code schematically looks like\n\nwhere the number of for loops is controlled by an arbitrary integer number.\n\nThanks for any suggestions!"
    },
    {
        "link": "https://geeksforgeeks.org/how-to-analyse-loops-for-complexity-analysis-of-algorithms",
        "document": "We have discussed Asymptotic Analysis, Worst, Average and Best Cases and Asymptotic Notations in previous posts. In this post, an analysis of iterative programs with simple examples is discussed.\n\nThe analysis of loops for the complexity analysis of algorithms involves finding the number of operations performed by a loop as a function of the input size. This is usually done by determining the number of iterations of the loop and the number of operations performed in each iteration.\n\nHere are the general steps to analyze loops for complexity analysis:\n\nDetermine the number of iterations of the loop. This is usually done by analyzing the loop control variables and the loop termination condition.\n\nDetermine the number of operations performed in each iteration of the loop. This can include both arithmetic operations and data access operations, such as array accesses or memory accesses.\n\nExpress the total number of operations performed by the loop as a function of the input size. This may involve using mathematical expressions or finding a closed-form expression for the number of operations performed by the loop.\n\nDetermine the order of growth of the expression for the number of operations performed by the loop. This can be done by using techniques such as big O notation or by finding the dominant term and ignoring lower-order terms.\n\nThe time complexity of a function (or set of statements) is considered as O(1) if it doesn’t contain a loop, recursion, and call to any other non-constant time function. \n\n i.e. set of non-recursive and non-loop statements\n\nIn computer science, O(1) refers to constant time complexity, which means that the running time of an algorithm remains constant and does not depend on the size of the input. This means that the execution time of an O(1) algorithm will always take the same amount of time regardless of the input size. An example of an O(1) algorithm is accessing an element in an array using an index.\n• None A loop or recursion that runs a constant number of times is also considered O(1). For example, the following loop is O(1).\n\nThe Time Complexity of a loop is considered as O(n) if the loop variables are incremented/decremented by a constant amount. For example following functions have O(n) time complexity. Linear time complexity, denoted as O(n), is a measure of the growth of the running time of an algorithm proportional to the size of the input. In an O(n) algorithm, the running time increases linearly with the size of the input. For example, searching for an element in an unsorted array or iterating through an array and performing a constant amount of work for each element would be O(n) operations. In simple words, for an input of size n, the algorithm takes n steps to complete the operation.\n\nThe time complexity is defined as an algorithm whose performance is directly proportional to the squared size of the input data, as in nested loops it is equal to the number of times the innermost statement is executed. For example, the following sample loops have O(n2) time complexity\n\nQuadratic time complexity, denoted as O(n^2), refers to an algorithm whose running time increases proportional to the square of the size of the input. In other words, for an input of size n, the algorithm takes n * n steps to complete the operation. An example of an O(n^2) algorithm is a nested loop that iterates over the entire input for each element, performing a constant amount of work for each iteration. This results in a total of n * n iterations, making the running time quadratic in the size of the input.\n\nExample: Selection sort and Insertion Sort have O(n2) time complexity.\n\nThe time Complexity of a loop is considered as O(Logn) if the loop variables are divided/multiplied by a constant amount. And also for recursive calls in the recursive function, the Time Complexity is considered as O(Logn).\n\nThe Time Complexity of a loop is considered as O(LogLogn) if the loop variables are reduced/increased exponentially by a constant amount.\n\nSee this for mathematical details.\n\nHow to combine the time complexities of consecutive loops?\n\nWhen there are consecutive loops, we calculate time complexity as a sum of the time complexities of individual loops.\n\nTo combine the time complexities of consecutive loops, you need to consider the number of iterations performed by each loop and the amount of work performed in each iteration. The total time complexity of the algorithm can be calculated by multiplying the number of iterations of each loop by the time complexity of each iteration and taking the maximum of all possible combinations.\n\nFor example, consider the following code:\n\nHere, the outer loop performs n iterations, and the inner loop performs m iterations for each iteration of the outer loop. So, the total number of iterations performed by the inner loop is n * m, and the total time complexity is O(n * m).\n\nIn another example, consider the following code:\n\nHere, the outer loop performs n iterations, and the inner loop performs i iterations for each iteration of the outer loop, where i is the current iteration count of the outer loop. The total number of iterations performed by the inner loop can be calculated by summing the number of iterations performed in each iteration of the outer loop, which is given by the formula sum(i) from i=1 to n, which is equal to n * (n + 1) / 2. Hence, the total time complex\n\n\n\nHow to calculate time complexity when there are many if, else statements inside loops?\n\nAs discussed here, the worst-case time complexity is the most useful among best, average and worst. Therefore we need to consider the worst case. We evaluate the situation when values in if-else conditions cause a maximum number of statements to be executed. \n\nFor example, consider the linear search function where we consider the case when an element is present at the end or not present at all. \n\nWhen the code is too complex to consider all if-else cases, we can get an upper bound by ignoring if-else and other complex control statements.\n\nHow to calculate the time complexity of recursive functions?\n\nThe time complexity of a recursive function can be written as a mathematical recurrence relation. To calculate time complexity, we must know how to solve recurrences. We will soon be discussing recurrence-solving techniques as a separate post.\n\nQuiz on Analysis of Algorithms \n\nFor more details, please refer: Design and Analysis of Algorithms.\n\nPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above."
    },
    {
        "link": "https://enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming",
        "document": "We encounter various loop patterns when solving different coding questions. On the other hand, many problem-solving approaches are based on loops. For example:\n• Problem-solving using data structures like stacks, queues, hash tables, heaps, etc.\n\nOne idea is simple: To design better algorithms or optimize the code further, we should learn to analyze the time complexity of various loop patterns. Once we have good practice, we can confidently think of new solution ideas or make optimization decisions quickly.\n\nThe time complexity of a loop pattern depends on various factors like the number of iterations, the cost of operations at each iteration, etc. In most situations, we frequently encounter such loop patterns:\n• Single loop patterns: A loop running constant time, a loop running n times, a loop growing exponentially, a loop running based on a condition, a loop running with a data structure, double traversal, etc.\n• Nested loops: Two nested loops, three nested loops, a single loop followed by nested loops, etc.\n\nSteps to analyze the time complexity of loop\n\nThe time complexity of the loop = (Number of loop iterations in the worst case) * (Time complexity of code executing at each iteration). We can represent this in terms of Big-O notation by ignoring lower-order terms and coefficients.\n• Counting total loop iterations in the worst case: We can gain this insight by considering the worst-case input scenario, initial and final value of the loop variable, loop condition, and increment or decrement operations.\n• Calculating time complexity of code executing at each iteration: A loop executes some lines of code on each iteration. This code may contain various operations like conditional statements, comparisons, swapping, assignments, shifting, copying, calls to other functions, etc.\n\nSometimes, we can also follow this approach:\n• Identify the most critical operation inside the loop, which executes the maximum number of times in the worst case. This critical operation will be the dominating factor in the time complexity function.\n• Calculate the total count of this operation for the complete loop in terms of input size. Representing this expression in terms of Big-O notation will give the time complexity of the loop.\n\nHere loop is running constant times and performing O(1) operation at each iteration. Time complexity = c * O(1) = O(1) * O(1) = O(1).\n\nLoop running n times and incrementing or decrementing by constant: O(n).\n\nExample 1: Loop incrementing by some constant c.\n\nExample 2: Loop decrementing by some constant c.\n\nHere both loops are running n/c times and performing O(1) operation at each iteration. Time complexity = n/c * O(1) = O(n) * O(1) = O(n).\n\nHere loop is running cn times and performing O(1) operation at each iteration. Time complexity = cn * O(1) = O(n) * O(1) = O(n).\n\nBased on some conditions, we are either incrementing l or decrementing r by 1 and performing O(1) operation at each iteration. Here loop will run n times because l and r are starting from opposite ends and stop when l > r. So time complexity = n * O(1) = O(n).\n\nLoop incrementing or decrementing exponentially by factor of 2: O(logn)\n\nExample 1: Loop incrementing by factor of 2.\n\nExample 2: Loop decrementing by factor of 2.\n\nIn the above examples, the loop runs from 1 to n, and the loop variable increases or decreases by a factor of 2 at each iteration. To calculate the time complexity, we need to count the total number of iterations performed by the loop.\n\nLet’s assume the loop will terminate after the k steps. So by the end of the loop, 2^k must be equal to the n. => 2^k = n => k = logn. So the loop will run logn number of times and perform O(1) operation at each step. Time complexity = k * O(1) = logn* O(1) = O(logn).\n\nIn this case, the loop runs from 1 to n, and the loop variable increases by a factor of i^c. How do we calculate the total number of loop iterations? Let's think.\n• The first iteration starts with i = 2.\n• In the second iteration, the value of i is 2^c.\n• In the third iteration, the value of i is (2^c)^c = 2^(c²).\n• This pattern continues until the end. At the ith iteration, the value of i is 2^(c^i).\n• The loop will end when 2^(c^i) = n.\n\nSo the loop will run log(log(n)) number of times, where each iteration will take O(1) time. So overall time complexity = log(log(n)) * O(1) = O(log(log(n))).\n\nFor calculating such consecutive loops, we do the sum of the time complexities of each loop. So overall time complexity = Time complexity of loop 1 + Time complexity of loop 2 = O(m) + O(n) = O(m + n).\n\nIn the above example, the inner loop is running n times for every iteration of the outer loop. So the total number of loop iterations = Total iteration of the outer loop * Total iteration of the inner loop = n * n = n². At each step of the iteration, nested loop is doing O(1) operation. So overall time complexity = n² * O(1) = O(n²).\n\nIn the above example, at every iteration of the outer loop, inner loop is running (n - i) times. So number of loop iterations = (n - 1) + (n - 2) + (n - 3)…..+ 2 + 1 = Sum of values from (i = 0 to n - 1) = n(n - 1)/2 = n²/2 - n/2 = O(n²). At each iteration, nested loop is performing O(1) operation. So overall time complexity = O(n²) * O(1) = O(n²).\n\nLet's take an interesting example. Suppose, we have an input matrix X of size m x n containing only 0's and 1's, which are sorted in a row-wise fashion. What will be the time complexity of this loop?\n\nIf we observe closely, the outer loop iterates over rows, and the inner loop iterates over columns independently. Thus, the nested loop will traverse each row and column once in the worst case. So, the total loop iterations = Total number of rows + Total number of columns = m + n. At each loop iteration, we are performing an O(1) operation. So time complexity = Total loop iteration*O(1) = (m + n) * O(1) = O(m + n).\n\nNote: It’s an exercise for you to analyze the following loop.\n\nIn such a case, we need to do the sum of the time complexities of each loop, but time complexity will be dominated by the time complexity of the nested loop.\n\nTime complexity = Time complexity of loop 1 + Time complexity of loop 2 + Time complexity of loop 3 = O(n) + O(mn) + O(n) = O(mn).\n\nAll three nested loops are running n times and doing O(1) operation at each iteration, so time complexity = n * n * n * O(1) = n³ * O(1) = O(n³) * O(1) = O(n³).\n\nIn the above three nested loops, the outer loop runs n - 1 time and two inner loops run n - i and j - i + 1 time. So what would be the total count of nested loop iterations? Let’s think.\n\nNow we solve this summation by expanding the summation one by one.\n\nHigher-order term in T(n) is n^3, so T(n) = O(n^3). We are ignoring lower-order terms and coefficients. Note: There is one error in the third line of the above image. Instead of + i(n - i), it would be - i (n - i).\n\nWe recommend to explore these problems to explore more about the time complexity analysis of loop\n\nIf you have any queries or feedback, please write us at contact@enjoyalgorithms.com. Enjoy learning, Enjoy coding, Enjoy algorithms!"
    },
    {
        "link": "https://reddit.com/r/learnprogramming/comments/yqhyhh/what_is_the_big_o_notation_for_a_nested_for_loop",
        "document": "Hi all. I have a question regarding big O notation when it comes to time complexity. If I understand correctly, if I have an array of N elements, and carry out a nested loop over all N elements, then the time complexity will be O(N2 ), e.g.\n\nIf that is true, then that makes sense intuitively--N x N = N2 . But what if the second loop doesn't start at 0, but starts at element i--what is the time complexity? e.g.\n\nIt looks like the time complexity should still be greater than O(N), but now less than O(N2 ). So my educated guess would be O(NlogN). Is that correct? If not, what am I misunderstanding?\n\nI ask because the two solutions I've seen to the Maximum Subarray LeetCode problem say the time complexity of such a nested loop is still O(N2 ) (here and here)."
    },
    {
        "link": "https://medium.com/enjoy-algorithm/analysis-of-loop-in-programming-cc9a644ef8cd",
        "document": "Loops are a fundamental operation in programming and are used to solve a variety of problems. Many problem-solving approaches in coding involve different types of loop structures. In fact, some approaches are entirely based on loops, such as:\n• Problem solving using data structures like stack, queue, hash table, etc.\n\nThe efficiency of an algorithm that uses these approaches often depends on the loop structure and the operations within the loop.\n\nThere are two common loop patterns that often appear in our solutions:\n• Single loop: This can involve a loop that runs in constant time, a loop that runs n times, a loop that grows exponentially, a loop that runs based on a specific condition, a loop that runs with a data structure, consecutive single loops, etc.\n• Nested loops: This can involve two nested loops, three nested loops, a single loop with nested loops, etc.\n\nOne way to design a better algorithm or optimize the code further is to learn how to analyze the time complexity of loops using Big-O notation. This is not difficult to learn, and with some practice on various loop patterns, you will be able to make optimization decisions quickly, saving time in the analysis process.\n\nSteps to analyze the time complexity of the loop\n• Counting the total loop iteration in the worst case: We can get this insight by considering the worst-case scenario, initial and final value of the loop variable, loop condition, and increment or decrement operation. Most of the time, loop will be running for each data element or total input size.\n• Calculating the time complexity of the code in the loop body: The loop executes this code on each iteration. This code may contain conditional statements, comparison operations, swapping operations, assignment operations, etc.\n• The time complexity of loop = (Count of loop iterations in the worst case) * (Time complexity of the code in the loop body). We represent this in the form of Big-O notation by ignoring lower-order terms and coefficients.\n\nSometimes, we can also follow another simple approach:\n• Identify the most critical operation inside the loop, which executes the maximum number of times in the worst case. This critical operation would be the dominating factor in the time complexity function.\n• Now calculate the total count of this operation for the complete loop in terms of input size. Representing this expression in terms of Big-O notation will give the time complexity of the loop.\n\nLet’s analyze the time complexity of the various loop pattern.\n\nTime complexity analysis of a single for and while loop\n\nSingle for and while loop running constant times: O(1)\n\nHere loop is running constant times and performing O(1) operation at each iteration of the loop. Time complexity = c * O(1) = O(1) * O(1) = O(1).\n\nBest examples of such loops: Accessing an element in an array, Finding minimum value in the min-heap, Searching elements in the hash table [O(1) average], Finding median in a sorted array, swapping two variables, etc.\n\nSingle for loop running n times and incrementing or decrementing by a constant: O(n)\n\nHere both loops are running n times and performing O(1) operation at each iteration of the loop. Time complexity = n * O(1) = O(n) * O(1) = O(n).\n\nFor better understanding, You can explore the analysis of these coding problems\n\nSingle for and while loop running constant multiple of n times: O(n)\n\nHere loop is running cn times and performing O(1) operation at each iteration of the loop. Time complexity = cn * O(1) = O(n) * O(1) = O(n).\n\nTwo pointers single for and while loop: O(n)\n\nIn the above loop, based on some conditions, we are either incrementing l or decrementing r by one and performing an O(1) operation at each step of the iteration. Loop will run n times because l and r are starting from opposite ends and end when l > r. So time complexity = n*O(1) = O(n).\n\nFor better understanding, You can explore the analysis of two pointers solution to these coding problems\n• Check two arrays are subset or not\n\nA single for and while loop incrementing or decrementing by a constant factor: O(logn)\n\nHere loop is running in the range of 1 to n, and the loop variable increases or decreases by a factor of 2 at each step. So we need to count the total number of iterations performed by the loop to calculate the time complexity.\n\nLet’s assume the loop will terminate after k steps where the loop variable increases or decreases by a factor of 2. Then 2^k must be equal to the n i.e. 2^k = n and k = logn = O(logn).\n\nSo the loop will run O(logn) number of times and do O(1) operation at each step. Time complexity = k * O(1) = O(logn)* O(1) = O(logn).\n\nBest examples of such loop patterns: Iterative binary search, iterative approach to find the nth power of a number, exponential search, iterative approach to find the nth power of a matrix, etc.\n\nSingle for and while loop incrementing by some constant power: O(log(logn))\n\nHere, the loop is running in the range of 1 to n, but the loop variable increases by factor i power constant c. So, how do we calculate the total number of loop steps? Let’s think!\n• The first iteration of the loop is starting with i = 2.\n• At second iteration, value of i = 2^c.\n• At third iteration, value of i = (2^c)^c = 2^(c²).\n• And it will go so on till the end. At any ith iteration the value of i = 2^(c^i).\n\nSo loop will run logc(log(n)) number of times, where each iteration is taking O(1) time. So the overall time complexity = O(log(log(n))) * O(1) = O(log(log(n))).\n\nFor calculating such consecutive loops, we need to do the sum of the time complexities of each loop. So overall time complexity = Time complexity of loop 1 + Time complexity of loop 2 = O(m) + O(n) = O(m + n).\n\nFor better understanding, You can explore the analysis of these coding problems.\n• Product of array except self\n\nTime complexity analysis of the nested for and while loops\n\nThe time complexity of nested loops is equal to the number of times the innermost statement is executed.\n\nTwo nested for and while loops: O(n²)\n\nIn the above nested-loop example, the inner loop is running n times for every iteration of the outer loop. So total number of nested loop iteration = Total number of iteration of outer loop * Total number of iteration of inner loop = n * n = n² = O(n²).\n\nAt each step of the iteration, the nested loop is doing an O(1) operation. So overall time complexity = O(n²) * O(1) = O(n²).\n\nIn the above nested loop example, outer loop is running n times and for every iteration of the outer loop, inner loop is running (n — i) times. So total number of nested loop iteration = (n — 1) + (n — 2) + (n — 3)…..+ 2 + 1 = Sum of arithmatic series from i = 0 to n — 1 = n(n — 1)/2 = n²/2 — n/2 = O(n²).\n\nAt each step of the iteration, the nested loop is doing an O(1) operation. So overall time complexity = O(n²) * O(1) = O(n²).\n\nNote: It’s an exercise for you to analyze the following loop.\n\nFor better understanding, You can explore the analysis of iterative solution of these coding problems.\n\nWe need to do the sum of the time complexities of each loop. In such a case, the time complexity is dominated by the time complexity of the nested loop.\n\nTime complexity = Time complexity of loop 1 + Time complexity of loop 2 + Time complexity of loop 3 = O(n) + O(mn) + O(n) = O(mn).\n\nThree nested for and while loops: O(n³)\n\nAll three nested loops are running n times and doing O(1) operation at each iteration, so time complexity = n * n * n*O(1) = n³ * O(1) = O(n³)*O(1) = O(n³).\n\nIn the above three nested loop situations, the outer loop runs n — 1 time, but two inner loops run n — i and j — i + 1 time. So what would be the total count of the nested loop iterations? Let’s think.\n\nNow we solve this tripple summation by expanding the summation one by one.\n\nHigher-order term in T(n) is n³, then T(n) = O(n³). We are ignoring lower-order terms and coefficients. Note: There is one error in the third line of the above image. Instead of + i(n — i), it would be — i (n — i).\n\nExplore these coding problems to learn more about the time complexity analysis of for and while loops\n• Count the number of possible triangles\n• Check whether two strings are anagram or not\n• Check if two arrays are equal or not\n\nFor more content, you can explore our free DSA course and coding interview blogs.\n\nIf you have any queries/doubts/feedback, please write us at contact@enjoyalgorithms.com. Enjoy learning, Enjoy algorithms!"
    },
    {
        "link": "https://stackoverflow.com/questions/526728/time-complexity-of-nested-for-loop",
        "document": "Yes, nested loops are one way to quickly get a big O notation.\n\nTypically (but not always) one loop nested in another will cause O(n²).\n\nThink about it, the inner loop is executed i times, for each value of i. The outer loop is executed n times.\n\nthus you see a pattern of execution like this: 1 + 2 + 3 + 4 + ... + n times\n\nTherefore, we can bound the number of code executions by saying it obviously executes more than n times (lower bound), but in terms of n how many times are we executing the code?\n\nWell, mathematically we can say that it will execute no more than n² times, giving us a worst case scenario and therefore our Big-Oh bound of O(n²). (For more information on how we can mathematically say this look at the Power Series)\n\nBig-Oh doesn't always measure exactly how much work is being done, but usually gives a reliable approximation of worst case scenario.\n\n4 yrs later Edit: Because this post seems to get a fair amount of traffic. I want to more fully explain how we bound the execution to O(n²) using the power series\n\nFrom the website: 1+2+3+4...+n = (n² + n)/2 = n²/2 + n/2. How, then are we turning this into O(n²)? What we're (basically) saying is that n² >= n²/2 + n/2. Is this true? Let's do some simple algebra.\n• Multiply both sides by 2 to get: 2n² >= n² + n?\n• Subtract n² from both sides to get: n² >= n?\n\nIt should be clear that n² >= n (not strictly greater than, because of the case where n=0 or 1), assuming that n is always an integer.\n\nActual Big O complexity is slightly different than what I just said, but this is the gist of it. In actuality, Big O complexity asks if there is a constant we can apply to one function such that it's larger than the other, for sufficiently large input (See the wikipedia page)"
    }
]