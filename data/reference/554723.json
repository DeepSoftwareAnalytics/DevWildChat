[
    {
        "link": "https://en.cppreference.com/w/cpp/algorithm/generate_n",
        "document": "Assigns values, generated by given function object , to the first elements in the range beginning at , if . Does nothing otherwise.\n\nSame as , but executed according to .\n\nIf is not convertible to an integral type, the program is ill-formed.\n\nthe beginning of the range of elements to generate number of the elements to generate the execution policy to use generator function object that will be called. \n\n The signature of the function should be equivalent to the following: The type Ret must be such that an object of type OutputIt can be dereferenced and assigned a value of type Ret. ​ - must meet the requirements of . - must meet the requirements of .\n\nIterator one past the last element assigned if count > 0, first otherwise.\n\nExactly std::max(0, count) invocations of g() and assignments.\n\nThe overload with a template parameter named reports errors as follows:\n• If execution of a function invoked as part of the algorithm throws an exception and is one of the standard policies, is called. For any other , the behavior is implementation-defined.\n• If the algorithm fails to allocate memory, is thrown.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://geeksforgeeks.org/stdgenerate_n-in-cpp",
        "document": "std::generate is an STL algorithm, which is used to generate numbers based upon a generator function, and then, it assigns those values to the elements in the container in the range [first, last).\n\nThe generator function has to be defined by the user, and it is called successively for assigning the numbers.\n\n Now, there can be a scenario, where we want to assign values only to the first n elements, for that we have another STL algorithm std::generate_n, which has the following syntax:\n\n Template function:"
    },
    {
        "link": "https://cplusplus.com/reference/algorithm/generate_n",
        "document": "An iterator pointing to the element that follows the last element whose value has been generated."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/algorithm/generate",
        "document": "Assigns each element in range a value generated by the given function object .\n\nSame as , but executed according to .\n\nthe pair of iterators defining the range of elements to generate the execution policy to use generator function object that will be called. \n\n The signature of the function should be equivalent to the following: The type Ret must be such that an object of type ForwardIt can be dereferenced and assigned a value of type Ret. ​ - must meet the requirements of .\n\nExactly std::distance(first, last) invocations of g() and assignments.\n\nThe overload with a template parameter named reports errors as follows:\n• If execution of a function invoked as part of the algorithm throws an exception and is one of the standard policies, is called. For any other , the behavior is implementation-defined.\n• If the algorithm fails to allocate memory, is thrown."
    },
    {
        "link": "https://cpp-lang.net/docs/std/algo/ordinary/generate_n",
        "document": "\n• (1) Assigns values, generated by given function object , to the first elements in the range beginning at , if .\n\n Does nothing otherwise.\n• (2) Same as (1), but executed according to .\n\nThe beginning of the range of elements to generate. The execution policy to use. See execution policy for details. Generator function object that will be called. The signature of the function should be equivalent to the following:\n• The type must be such that an object of type can be dereferenced and assigned a value of type .\n\nIterator one past the last element assigned if , otherwise.\n\nExactly invocations of and assignments.\n\nThe overloads with a template parameter named report errors as follows:\n• If execution of a function invoked as part of the algorithm throws an exception and is one of the standard policies, is called. For none other , the behavior is .\n• If the algorithm fails to allocate memory, is thrown."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/algorithm",
        "document": "The algorithms library defines functions for a variety of purposes (e.g. searching, sorting, counting, manipulating) that operate on ranges of elements. Note that a range is defined as first last where last refers to the element past the last element to inspect or modify.\n\nC++20 provides constrained versions of most algorithms in the namespace . In these algorithms, a range can be specified as either an iterator-sentinel pair or as a single argument, and projections and pointer-to-member callables are supported. Additionally, the return types of most algorithms have been changed to return all potentially useful information computed during the execution of the algorithm.\n\nMost algorithms have overloads that accept execution policies. The standard library algorithms support several execution policies, and the library provides corresponding execution policy types and objects. Users may select an execution policy statically by invoking a parallel algorithm with an execution policy object of the corresponding type.\n\nStandard library implementations (but not the users) may define additional execution policies as an extension. The semantics of parallel algorithms invoked with an execution policy object of implementation-defined type is implementation-defined.\n\nParallel version of algorithms (except for std::for_each and std::for_each_n) are allowed to make arbitrary copies of elements from ranges, as long as both std::is_trivially_copy_constructible_v<T> and std::is_trivially_destructible_v<T> are true, where is the type of elements.\n\nSome algorithms require the sequence represented by the arguments to be “sorted” or “partitioned”. The behavior is undefined if the requirement is not met.\n\nA sequence is sorted with respect to a comparator comp if for every iterator iter pointing to the sequence and every non-negative integer n such that iter + n[1] is a valid iterator pointing to an element of the sequence, comp(*(iter + n), *iter) == false[1]. A sequence is sorted with respect to comp and proj for a comparator comp and projection proj if for every iterator iter pointing to the sequence and every non-negative integer n such that iter + n[1] is a valid iterator pointing to an element of the sequence, bool(std::invoke(comp, std::invoke(proj, *(iter + n)),\n\n std::invoke(proj, *iter)))[1] is false. A sequence is sorted with respect to a comparator comp if the sequence is sorted with respect to comp and std::identity{} (the identity projection).\n\nA sequence start finish is partitioned with respect to an expression f(e) if there exists an integer n such that for all i in ​0​ std::distance(start, finish) , f(*(start + i))[1] is true if and only if i < n.\n• simply means “the result of being incremented times”, regardless of whether is a random access iterator.\n\nA heap can be created by std::make_heap and ranges::make_heap(since C++20).\n\nFor more properties of heap, see max heap.\n\ncopies a range of objects to an uninitialized area of memory \n\n copies a range of objects to an uninitialized area of memory\n\n copies a number of objects to an uninitialized area of memory \n\n copies a number of objects to an uninitialized area of memory\n\n copies an object to an uninitialized area of memory, defined by a range \n\n copies an object to an uninitialized area of memory, defined by a range\n\n copies an object to an uninitialized area of memory, defined by a start and a count \n\n copies an object to an uninitialized area of memory, defined by a start and a count\n\n moves a range of objects to an uninitialized area of memory \n\n moves a range of objects to an uninitialized area of memory\n\n moves a number of objects to an uninitialized area of memory \n\n moves a number of objects to an uninitialized area of memory\n\n constructs objects by default-initialization in an uninitialized area of memory, defined by a range \n\n constructs objects by default-initialization in an uninitialized area of memory, defined by a range\n\n constructs objects by default-initialization in an uninitialized area of memory, defined by a start and a count \n\n constructs objects by default-initialization in an uninitialized area of memory, defined by a start and count\n\n constructs objects by value-initialization in an uninitialized area of memory, defined by a range \n\n constructs objects by value-initialization in an uninitialized area of memory, defined by a range\n\n constructs objects by value-initialization in an uninitialized area of memory, defined by a start and a count \n\n constructs objects by value-initialization in an uninitialized area of memory, defined by a start and a count\n\n destroys an object at a given address \n\n destroys an object at a given address\n\n creates an object at a given address \n\n creates an object at a given address\n\n\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://isocpp.org/wiki/faq/cpp11-library-stl",
        "document": "The standard library algorithms are improved partly by simple addition of new algorithms, partly by improved implementations made possible by new language features, and partly by new language features enabling easier use:\n• Effects of move: Moving can be much more efficient than copying (see Move semantics. For example, move-based and have been measured to be 15 times faster than copy based versions. This is less impressive than it sounds because such standard library operations for standard library types, such as and , are usually hand-optimized to gain the effects of moving through techniques such as replacing copies with optimized swaps. However, if your type has a move operation, you gain the performance benefits automatically from the standard algorithms. Consider also that the use of moves allows simple and efficient sort (and other algorithms) of containers of smart pointers, especially :\n• Use of lambdas: For ages, people have complained about having to write functions or (better) function objects for use as operations, such as above, for standard library (and other) algorithms. This was especially painful to do if you wrote large functions (don’t) because in C++98 you could not define a local function object to use as an argument; now you can. However, lambdas allows us to define operations “inline”:\n• Use of initializer lists: Sometimes, initializer lists come in handy as arguments. For example, assuming variables and being a case-insensitive comparison:\n• Howard E. Hinnant, Peter Dimov, and Dave Abrahams: A Proposal to Add Move Semantics Support to the C++ Language. N1377=02-0035.\n\nGiven the new language features and a decade’s worth of experience, what has happened to the standard containers? First, of course we got a few new ones: array (a fixed-sized container), forward_list (a singly-linked list), and unordered containers (the hash tables). Next, new features, such as initializer lists, rvalue references, variadic templates, and constexpr[cpp11-constexpr] were put to use. Consider .\n• Initializer lists: The most visible improvement is the use of initializer-list constructors to allow a container to take an initializer list as its argument:\n• Move operators: Containers now have move constructors and move assignments (in addition to the traditional copy operations). The most important implication of this is that we can efficiently return a container by value from a function:\n\nThe point here is that no s are copied. Rewrite this to return a free-store-allocated vector and you have to deal with memory management. Rewrite this to pass the to be filled as an argument to and you have a far less obvious code (plus an added opportunity for making an error).\n• Improved push operations: Many people’s favorite container operation is that allows a container to grow gracefully:\n\nThis will construct a out of and and move it into . Note “move” not “copy;” there is a version that takes an rvalue reference argument so that we can take advantage of ’s move constructor. Note also the use of the uniform initializer syntax to avoid verbosity.\n• Emplace operations: The using a move constructor is far more efficient in important cases than the traditional copy-based one, but in extreme cases we can go further. Why copy/move anything? Why not make space in the and then construct the desired value in that space? Operations that do that are called “ ” (meaning “putting in place”). For example :\n\nAn takes a variadic template argument and uses that to construct an object of the desired type. Whether the really is more efficient than the depends on the types involved and the implementation (of the library and of variadic templates). If you think it matters, measure. Otherwise, choose based on aesthetics: or . For now, many prefer the version in part due to familiarity, but that might change over time.\n• Scoped allocators: Containers can now hold “real allocation objects (with state)” and use those to control nested/scoped allocation (e.g. allocation of elements in a container).\n\nObviously, the containers are not the only parts of the standard library that have benefited from the new language features. Consider:\n• Compile-time evaluation: is used to ensure compiler time evaluation in , , , , , types, random numbers, , etc. In some cases, it means improved performance; in others (where there is no alternative to compile-time evaluation), it means absence of messy low-level code and macros.\n• Tuples: Tuples would not be possible without variadic templates\n\nAn container is implemented using a hash table. C++11 offers four standard ones:\n\nThey would have been called etc., but there are so many incompatible uses of those names that the committee had to choose new names and the name nicely highlighted the key difference between (say) and : When you iterate over a from to , you do so in the order provided by its key type’s less-than comparison operator (by default ) whereas the value type of is not required to have a less-than comparison operator and a hash table doesn’t naturally provide an order. The are other differences; in particular, conversely, the element type of a map is not required to have a hash function.\n\nThe basic idea is simply to use as an optimized version of map where optimization is possible and reasonable. For example:\n\nThe iterator over will present the elements in alphabetical order; the iteration over will not (except through a freak accident). Lookup is implemented very differently for and . For lookup involves less-than comparisons, whereas for lookup involves a single call of a hash function and one or more equality operations. For a few elements (say a few dozen), it is hard to tell which is faster. For larger numbers of elements (e.g. thousands), lookup in an can be much faster than for a map.\n\nThe standard container array is a fixed-sized random-access sequence of elements defined in . It has no space overheads beyond what it needs to hold its elements, it does not use free store, it can be initialized with an initializer list, it knows its size (number of elements), and doesn’t convert to a pointer unless you explicitly ask it to. In other words, it is very much like a built-in array without the problems.\n\nNote that you can have zero-length s but that you cannot deduce the length of an from an initializer list:\n\nThe standard ’s features makes it attractive for embedded systems programming (and similar constrained, performance-critical, or safety critical tasks). It is a sequence container so it provides the usual member types and functions (just like ):\n\nAlso, you don’t get (potentially nasty) derived to base conversions:\n\nIf that was allowed, would now contain a .\n\nThe standard container , defined in , is basically a singly-linked list. It supports forward iteration (only) and guarantees that elements don’t move if you insert or erase one. It occupies minimal space (an empty list is likely to be one word) and does not provide a operation (so that it does not have to store a size member):"
    },
    {
        "link": "https://stackoverflow.com/questions/15500621/c-c-algorithm-to-produce-same-pseudo-random-number-sequences-from-same-seed-on",
        "document": "Any particular pseudo-random number generation algorithm will behave like this. The problem with is that it's not specified how it is implemented. Different implementations will behave in different ways and even have varying qualities.\n\nHowever, C++11 provides the new standard library header that contains lots of great random number generation facilities. The random number engines defined within are well-defined and, given the same seed, will always produce the same set of numbers.\n\nFor example, a popular high quality random number engine is , which is the Mersenne twister algorithm configured in a specific way. No matter which machine, you're on, the following will always produce the same set of real numbers between 0 and 1:"
    },
    {
        "link": "https://en.cppreference.com/w/cpp/standard_library",
        "document": "The C++ standard library provides a wide range of facilities that are usable in standard C++.\n\nThe language support library provides components that are required by certain parts of the C++ language, such as memory allocation (new/delete) and exception processing.\n\nThe diagnostics library provides a consistent framework for reporting errors in a C++ program, including predefined exception classes.\n\nThe memory management library provides components for memory management, including smart pointers and scoped allocator(since C++11).\n\nThe general utilities library includes components used by other library elements, such as a predefined storage allocator for dynamic storage management, and components used as infrastructure in C++ programs, such as tuples and(since C++11) function wrappers.\n\nThe containers, iterators, ranges(since C++20), and algorithms libraries provide a C++ program with access to a subset of the most widely used algorithms and data structures.\n\nThe strings library provides support for manipulating text represented as homogeneous sequences of following types: char, char8_t(since C++20), char16_t, char32_t(since C++11), wchar_t, and any other character-like types.\n\nThe text processing library provides regular expression matching and searching(since C++11), utilities for text formatting(since C++20) and identifying text encodings(since C++26), and localization facilities.\n\nThe numerics library provides numeric algorithms and complex number components that extend support for numeric processing. The valarray component provides support for n-at-a-time processing, potentially implemented as parallel operations on platforms that support such processing. The random number component provides facilities for generating pseudo-random numbers.(since C++11)\n\nThe time library provides generally useful time utilities.\n\nThe input/output library provides the iostream components that are the primary mechanism for C++ program input and output. They can be used with other elements of the library, particularly strings, locales, and iterators.\n\nThe C++ standard library provides definitions for the entities and macros described in the synopses of the C++ standard library headers, unless otherwise specified.\n\nAll library entities except operator new and operator delete are defined within the namespace std or namespaces nested within namespace std (except the entities for the C standard library facilities, see below). It is unspecified whether names declared in a specific namespace are declared directly in that namespace or in an inline namespace inside that namespace.(since C++11)\n\nEach element of the C++ standard library is declared or defined (as appropriate) in a header. A header is not necessarily a source file, nor are the sequences delimited by and in header names necessarily valid source file names.\n\nThe C++ standard library provides the C++ library headers and additional C++ headers for C library facilities (see “headers” page for descriptions):\n\nA freestanding implementation has an implementation-defined set of headers, see here for the minimal requirement on the set of headers.\n\nThe C++ standard library also makes available the facilities of the C standard library, suitably adjusted to ensure static type safety. The descriptions of many library functions rely on the C standard library for the semantics of those functions.\n\nIn some cases, the signatures specified in standard C++ may be different from the signatures in the C standard library, and additional overloads may be declared, but the behavior and the preconditions (including those implied by C's restrict)(since C++17) are the same unless otherwise stated.\n\nFor compatibility with the C standard library, the C++ standard library provides the C headers listed below. The intended use of these headers is for interoperability only. It is possible that C++ source files need to include one of these headers in order to be valid ISO C. Source files that are not intended to also be valid ISO C should not use any of the C headers. See here for descriptions.\n\nExcept otherwise noted, the contents of each header is the same as that of the corresponding header as specified in the C standard library. In the C++ standard library, however, the declarations (except for names which are defined as macros in C) are within namespace scope of the namespace std. It is unspecified whether these names (including any overloads added) are first declared within the global namespace scope and are then injected into namespace std by explicit using-declarations.\n\nNames which are defined as macros in C ( , , , , and ) must be defined as macros in the C++ standard library, even if C grants license for implementation as functions.\n\nNames that are defined as functions in C must be defined as functions in the C++ standard library. This disallows the practice, allowed in C, of providing a masking macro in addition to the function prototype. The only way to achieve equivalent inline behavior in C++ is to provide a definition as an extern inline function.\n\nIdentifiers that are keywords or operators in C++ cannot be defined as macros in C++ standard library headers. In particular, including the standard header has no effect.\n\nNames associated with safe functions in standard C\n\nIf any C++ header is included, it is implementation-defined whether any of the following C standard Annex K names is declared in the global namespace (none of them is declared in namespace std):\n\nThe entities in the C++ standard library are defined in headers, whose contents are made available to a translation unit when it contains the appropriate preprocessing directive.\n\nA translation unit may include library headers in any order. Each may be included more than once, with no effect different from being included exactly once, except that the effect of including either or depends each time on the lexically current definition of NDEBUG.\n\nA translation unit can only include a header outside of any declaration or definition, and lexically before the first reference in that translation unit to any of the entities declared in that header. No diagnostic is required.\n\nEntities in the C++ standard library have storage duration#external linkage. Unless otherwise specified, objects and functions have the default extern \"C++\" linkage.\n\nWhether a name from the C standard library declared with external linkage has extern \"C\" or extern \"C++\" linkage is implementation-defined. The C++ standard recommends using extern \"C++\" in this case.\n\nObjects and functions defined in the library and required by a C++ program are included in the program prior to program startup.\n\nA C++ header must provide declarations and definitions that appear in\n• the synopsis of that header, or\n• the synopsis of another header which is appeared to be included in the synopsis of that header.\n\nFor types and macros defined in multiple headers (such as ), including any number of these headers in any order never violates the one definition rule.\n\nUnless otherwise specified, all object-like macros defined by the C standard library that expand to integral constant expressions can be used in preprocessing directives.\n\nCalling a standard library non-member function signature always results in actually calling that function. Therefore a conforming standard library implementation cannot define additional non-member functions that may be called by a valid C++ program.\n\nNon-member function signatures are never declared with additional default arguments.\n\nUnless otherwise specified, calls made by functions in the standard library to non-operator, non-member functions do not use functions from another namespace which are found through argument-dependent name lookup.\n\nFor each friend declaration of a function (template) within a class (template) definition, no other declaration is provided for that function (template).\n\nFor each class defined in the C++ standard library required to be derived from another class defined in the C++ standard library,\n• the base class must be virtual if it is specified as ,\n• the base class cannot be virtual if it is not specified as , and\n• unless otherwise specified, types with distinct names shall be distinct types.\n\nIf a function defined in the C++ standard library is specified to throw an exception (in a particular situation) of a given type, the exception thrown can only have that type or a type derived from that type so that an exception handler for the base type can catch it.\n\nFunctions from the C standard library can only throw exceptions when such a function calls a program-supplied function that throws an exception ( and meet this condition).\n\nDestructor operations defined in the C++ standard library never throw exceptions. Every destructor in the C++ standard library behaves as if it had a non-throwing exception specification.\n\nIt is unspecified whether any member or non-member functions in the C++ standard library are defined as inline.\n\nFor a non-virtual C++ standard library member function, a different set of member function signatures can be declared, provided that any call to that member function that would select an overload from the given set of declarations behaves as if that overload was selected. This allows, for instance:\n• replacing a member function with default arguments with two or more member functions with equivalent behavior, or\n\nUnless otherwise specified, it is implementation-defined which functions in the C++ standard library may be recursively reentered.\n\nIt is unspecified whether any function signature or class in the C++ standard library is a friend of another class in the C++ standard library.\n\nThe names and global function signatures described here are reserved to the implementation.\n\nAny class in the C++ standard library can be derived from a class with a name reserved to the implementation. If a class defined in the C++ standard library is required to be derived from other classes in the C++ standard library, that class can be derived directly from the required base or indirectly through a hierarchy of base classes with names reserved to the implementation.\n\nIf a function defined in the C++ standard library is not specified to throw an exception but does not have a non-throwing exception specification, the exception thrown is implementation-defined, but its type should be std::exception or any type derived from std::exception.\n\nThe exception specification for a non-virtual function can be strengthened by adding a non-throwing exception specification.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://stackoverflow.com/questions/57025341/how-to-understand-c11-random-number-generator",
        "document": "random_device is slow but genuinely random, it's used to generate the 'seed' for the random number sequence.\n\nmt19937 is fast but only 'pseudo random'. It needs a 'seed' to start generating a sequence of numbers. That seed can be random (as in your example) so you get a different sequence of random numbers each time. But it could be a constant, so you get the same sequence of numbers each time.\n\nuniform_int_distribution is a way of mapping random numbers (which could have any values) to the numbers you're actually interested in, in this case a uniform distribution of integers from 1 to 6.\n\nAs is often the case with OO programming, this code is about division of responsibilities. Each class contributes a small piece to the overall requirement (the generation of dice rolls). If you wanted to do something different it's easy because you've got all the pieces in front of you.\n\nIf this is too much then all you need to do is write a function to capture the overall effect, for instance\n\nis an example of a function object or functor. It's an object which overloads so it can be called as if it was a function."
    }
]