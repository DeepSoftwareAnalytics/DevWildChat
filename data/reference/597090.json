[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function",
        "document": "An declaration creates an object. Each time when an async function is called, it returns a new which will be resolved with the value returned by the async function, or rejected with an exception uncaught within the async function.\n\nAsync functions can contain zero or more expressions. Await expressions make promise-returning functions behave as though they're synchronous by suspending execution until the returned promise is fulfilled or rejected. The resolved value of the promise is treated as the return value of the await expression. Use of and enables the use of ordinary / blocks around asynchronous code.\n\nNote: The keyword is only valid inside async functions within regular JavaScript code. If you use it outside of an async function's body, you will get a . can be used on its own with JavaScript modules.\n\nAsync functions always return a promise. If the return value of an async function is not explicitly a promise, it will be implicitly wrapped in a promise.\n\nFor example, consider the following code:\n\nIt is similar to:\n\nNote that even though the return value of an async function behaves as if it's wrapped in a , they are not equivalent. An async function will return a different reference, whereas returns the same reference if the given value is a promise. It can be a problem when you want to check the equality of a promise and a return value of an async function.\n\nThe body of an async function can be thought of as being split by zero or more await expressions. Top-level code, up to and including the first await expression (if there is one), is run synchronously. In this way, an async function without an await expression will run synchronously. If there is an await expression inside the function body, however, the async function will always complete asynchronously.\n\nIt is also equivalent to:\n\nCode after each await expression can be thought of as existing in a callback. In this way a promise chain is progressively constructed with each reentrant step through the function. The return value forms the final link in the chain.\n\nIn the following example, we successively await two promises. Progress moves through function in three stages.\n• The first line of the body of function is executed synchronously, with the await expression configured with the pending promise. Progress through is then suspended and control is yielded back to the function that called .\n• Some time later, when the first promise has either been fulfilled or rejected, control moves back into . The result of the first promise fulfillment (if it was not rejected) is returned from the await expression. Here is assigned to . Progress continues, and the second await expression is evaluated. Again, progress through is suspended and control is yielded.\n• Some time later, when the second promise has either been fulfilled or rejected, control re-enters . The result of the second promise resolution is returned from the second await expression. Here is assigned to . Control moves to the return expression (if any). The default return value of is returned as the resolution value of the current promise.\n\nNote how the promise chain is not built-up in one go. Instead, the promise chain is constructed in stages as control is successively yielded from and returned to the async function. As a result, we must be mindful of error handling behavior when dealing with concurrent asynchronous operations.\n\nFor example, in the following code an unhandled promise rejection error will be thrown, even if a handler has been configured further along the promise chain. This is because will not be \"wired into\" the promise chain until control returns from .\n\ndeclarations behave similar to declarations — they are hoisted to the top of their scope and can be called anywhere in their scope, and they can be redeclared only in certain contexts."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
        "document": "A is a proxy for a value not necessarily known when the promise is created. It allows you to associate handlers with an asynchronous action's eventual success value or failure reason. This lets asynchronous methods return values like synchronous methods: instead of immediately returning the final value, the asynchronous method returns a promise to supply the value at some point in the future. A is in one of these states:\n• fulfilled: meaning that the operation was completed successfully. The eventual state of a pending promise can either be fulfilled with a value or rejected with a reason (error). When either of these options occur, the associated handlers queued up by a promise's method are called. If the promise has already been fulfilled or rejected when a corresponding handler is attached, the handler will be called, so there is no race condition between an asynchronous operation completing and its handlers being attached. A promise is said to be settled if it is either fulfilled or rejected, but not pending. You will also hear the term resolved used with promises — this means that the promise is settled or \"locked-in\" to match the eventual state of another promise, and further resolving or rejecting it has no effect. The States and fates document from the original Promise proposal contains more details about promise terminology. Colloquially, \"resolved\" promises are often equivalent to \"fulfilled\" promises, but as illustrated in \"States and fates\", resolved promises can be pending or rejected as well. For example: This promise is already resolved at the time when it's created (because the is called synchronously), but it is resolved with another promise, and therefore won't be fulfilled until 1 second later, when the inner promise fulfills. In practice, the \"resolution\" is often done behind the scenes and not observable, and only its fulfillment or rejection are. Note: Several other languages have mechanisms for lazy evaluation and deferring a computation, which they also call \"promises\", e.g. Scheme. Promises in JavaScript represent processes that are already happening, which can be chained with callback functions. If you are looking to lazily evaluate an expression, consider using a function with no arguments e.g. to create the lazily-evaluated expression, and to evaluate the expression immediately. itself has no first-class protocol for cancellation, but you may be able to directly cancel the underlying asynchronous operation, typically using .\n\nThe promise methods , , and are used to associate further action with a promise that becomes settled. The method takes up to two arguments; the first argument is a callback function for the fulfilled case of the promise, and the second argument is a callback function for the rejected case. The and methods call internally and make error handling less verbose. For example, a is really just a without passing the fulfillment handler. As these methods return promises, they can be chained. For example: We will use the following terminology: initial promise is the promise on which is called; new promise is the promise returned by . The two callbacks passed to are called fulfillment handler and rejection handler, respectively. The settled state of the initial promise determines which handler to execute.\n• If the initial promise is fulfilled, the fulfillment handler is called with the fulfillment value.\n• If the initial promise is rejected, the rejection handler is called with the rejection reason. The completion of the handler determines the settled state of the new promise.\n• If the handler returns a thenable value, the new promise settles in the same state as the returned value.\n• If the handler returns a non-thenable value, the new promise is fulfilled with the returned value.\n• If the handler throws an error, the new promise is rejected with the thrown error.\n• If the initial promise has no corresponding handler attached, the new promise will settle to the same state as the initial promise — that is, without a rejection handler, a rejected promise stays rejected with the same reason. For example, in the code above, if rejects, will be called, and if completes normally (without throwing or returning a rejected promise), the promise returned by the first will be fulfilled instead of staying rejected. Therefore, if an error must be handled immediately, but we want to maintain the error state down the chain, we must throw an error of some type in the rejection handler. On the other hand, in the absence of an immediate need, we can leave out error handling until the final handler. Using arrow functions for the callback functions, implementation of the promise chain might look something like this: myPromise .then((value) => `${value} and bar`) .then((value) => `${value} and bar again`) .then((value) => `${value} and again`) .then((value) => `${value} and again`) .then((value) => { console.log(value); }) .catch((err) => { console.error(err); }); Note: For faster execution, all synchronous actions should preferably be done within one handler, otherwise it would take several ticks to execute all handlers in sequence. JavaScript maintains a job queue. Each time, JavaScript picks a job from the queue and executes it to completion. The jobs are defined by the executor of the constructor, the handlers passed to , or any platform API that returns a promise. The promises in a chain represent the dependency relationship between these jobs. When a promise settles, the respective handlers associated with it are added to the back of the job queue. A promise can participate in more than one chain. For the following code, the fulfillment of will cause both and to be added to the job queue. Because is registered first, it will be invoked first. An action can be assigned to an already settled promise. In this case, the action is added immediately to the back of the job queue and will be performed when all existing jobs are completed. Therefore, an action for an already \"settled\" promise will occur only after the current synchronous code completes and at least one loop-tick has passed. This guarantees that promise actions are asynchronous. const promiseA = new Promise((resolve, reject) => { resolve(777); }); // At this point, \"promiseA\" is already settled. promiseA.then((val) => console.log(\"asynchronous logging has val:\", val)); console.log(\"immediate logging\"); // produces output in this order: // immediate logging // asynchronous logging has val: 777\n\nThe class offers four static methods to facilitate async task concurrency: Fulfills when all of the promises fulfill; rejects when any of the promises rejects. Fulfills when any of the promises fulfills; rejects when all of the promises reject. Settles when any of the promises settles. In other words, fulfills when any of the promises fulfills; rejects when any of the promises rejects. All these methods take an iterable of promises (thenables, to be exact) and return a new promise. They all support subclassing, which means they can be called on subclasses of , and the result will be a promise of the subclass type. To do so, the subclass's constructor must implement the same signature as the constructor — accepting a single function that can be called with the and callbacks as parameters. The subclass must also have a static method that can be called like to resolve values to promises. Note that JavaScript is single-threaded by nature, so at a given instant, only one task will be executing, although control can shift between different promises, making execution of the promises appear concurrent. Parallel execution in JavaScript can only be achieved through worker threads.\n\nThis example shows diverse techniques for using Promise capabilities and diverse situations that can occur. To understand this, start by scrolling to the bottom of the code block, and examine the promise chain. Upon provision of an initial promise, a chain of promises can follow. The chain is composed of calls, and typically (but not necessarily) has a single at the end, optionally followed by . In this example, the promise chain is initiated by a custom-written construct; but in actual practice, promise chains more typically start with an API function (written by someone else) that returns a promise. The example function shows that a promise generator will utilize while setting up an asynchronous call, or within the call-back, or both. The function illustrates how an API function might generate and return a promise in a self-contained manner. Note that the function ends with a . That is forced because a promise chain goes through all the promises, even after an error, and without the , the error would seem \"fixed\". This is a hassle, and for this reason, it is common to omit throughout the chain of promises, and just have a single in the final . This code can be run under NodeJS. Comprehension is enhanced by seeing the errors actually occur. To force more errors, change the values. // To experiment with error handling, \"threshold\" values cause errors randomly const THRESHOLD_A = 8; // can use zero 0 to guarantee error function tetheredGetNumber(resolve, reject) { setTimeout(() => { const randomInt = Date.now(); const value = randomInt % 10; if (value < THRESHOLD_A) { resolve(value); } else { reject(`Too large: ${value}`); } }, 500); } function determineParity(value) { const isOdd = value % 2 === 1; return { value, isOdd }; } function troubleWithGetNumber(reason) { const err = new Error(\"Trouble getting number\", { cause: reason }); console.error(err); throw err; } function promiseGetWord(parityInfo) { return new Promise((resolve, reject) => { const { value, isOdd } = parityInfo; if (value >= THRESHOLD_A - 1) { reject(`Still too large: ${value}`); } else { parityInfo.wordEvenOdd = isOdd ? \"odd\" : \"even\"; resolve(parityInfo); } }); } new Promise(tetheredGetNumber) .then(determineParity, troubleWithGetNumber) .then(promiseGetWord) .then((info) => { console.log(`Got: ${info.value}, ${info.wordEvenOdd}`); return info; }) .catch((reason) => { if (reason.cause) { console.error(\"Had previously handled error\"); } else { console.error(`Trouble with promiseGetWord(): ${reason}`); } }) .finally((info) => console.log(\"All done\"));\n\nThis small example shows the mechanism of a . The method is called each time the is clicked. It creates a promise that will be fulfilled, using , to the promise count (number starting from 1) every 1-3 seconds, at random. The constructor is used to create the promise. The fulfillment of the promise is logged, via a fulfill callback set using . A few logs show how the synchronous part of the method is decoupled from the asynchronous completion of the promise. By clicking the button several times in a short amount of time, you'll even see the different promises being fulfilled one after another. \"use strict\"; let promiseCount = 0; function testPromise() { const thisPromiseCount = ++promiseCount; const log = document.getElementById(\"log\"); // begin log.insertAdjacentHTML(\"beforeend\", `${thisPromiseCount}) Started<br>`); // We make a new promise: we promise a numeric count of this promise, // starting from 1 (after waiting 3s) const p1 = new Promise((resolve, reject) => { // The executor function is called with the ability // to resolve or reject the promise log.insertAdjacentHTML( \"beforeend\", `${thisPromiseCount}) Promise constructor<br>`, ); // This is only an example to create asynchronism setTimeout( () => { // We fulfill the promise resolve(thisPromiseCount); }, Math.random() * 2000 + 1000, ); }); // We define what to do when the promise is resolved with the then() call, // and what to do when the promise is rejected with the catch() call p1.then((val) => { // Log the fulfillment value log.insertAdjacentHTML(\"beforeend\", `${val}) Promise fulfilled<br>`); }).catch((reason) => { // Log the rejection reason console.log(`Handle rejected promise (${reason}) here.`); }); // end log.insertAdjacentHTML(\"beforeend\", `${thisPromiseCount}) Promise made<br>`); } const btn = document.getElementById(\"make-promise\"); btn.addEventListener(\"click\", testPromise);\n\nA settings object is an environment that provides additional information when JavaScript code is running. This includes the realm and module map, as well as HTML specific information such as the origin. The incumbent settings object is tracked in order to ensure that the browser knows which one to use for a given piece of user code. To better picture this, we can take a closer look at how the realm might be an issue. A realm can be roughly thought of as the global object. What is unique about realms is that they hold all of the necessary information to run JavaScript code. This includes objects like and . Each settings object has its own \"copy\" of these and they are not shared. That can cause some unexpected behavior in relation to promises. In order to get around this, we track something called the incumbent settings object. This represents information specific to the context of the user code responsible for a certain function call. To illustrate this a bit further we can take a look at how an embedded in a document communicates with its host. Since all web APIs are aware of the incumbent settings object, the following will work in all browsers: <!doctype html> <iframe></iframe> <!-- we have a realm here --> <script> // we have a realm here as well const bound = frames[0].postMessage.bind(frames[0], \"some data\", \"*\"); // bound is a built-in function — there is no user // code on the stack, so which realm do we use? setTimeout(bound); // this still works, because we use the youngest // realm (the incumbent) on the stack </script> The same concept applies to promises. If we modify the above example a little bit, we get this: <!doctype html> <iframe></iframe> <!-- we have a realm here --> <script> // we have a realm here as well const bound = frames[0].postMessage.bind(frames[0], \"some data\", \"*\"); // bound is a built in function — there is no user // code on the stack — which realm do we use? Promise.resolve(undefined).then(bound); // this still works, because we use the youngest // realm (the incumbent) on the stack </script> If we change this so that the in the document is listening to post messages, we can observe the effect of the incumbent settings object: <!-- x.html --> <!doctype html> <script> window.addEventListener( \"message\", (event) => { document.querySelector(\"#text\").textContent = \"hello\"; // this code will only run in browsers that track the incumbent settings object console.log(event); }, false, ); </script> In the above example, the inner text of the will be updated only if the incumbent settings object is tracked. This is because without tracking the incumbent, we may end up using the wrong environment to send the message. Note: Currently, incumbent realm tracking is fully implemented in Firefox, and has partial implementations in Chrome and Safari."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Async_JS/Promises",
        "document": "Promises are the foundation of asynchronous programming in modern JavaScript. A promise is an object returned by an asynchronous function, which represents the current state of the operation. At the time the promise is returned to the caller, the operation often isn't finished, but the promise object provides methods to handle the eventual success or failure of the operation. A solid understanding of JavaScript fundamentals and asynchronous concepts, as covered in previous lessons in this module.\n• The concepts and fundamentals of using promises in JavaScript.\n• and : how they relate to promises, and why they are useful. In the previous article, we talked about the use of callbacks to implement asynchronous functions. With that design, you call the asynchronous function, passing in your callback function. The function returns immediately and calls your callback when the operation is finished. With a promise-based API, the asynchronous function starts the operation and returns a object. You can then attach handlers to this promise object, and these handlers will be executed when the operation has succeeded or failed.\n\nNote: In this article, we will explore promises by copying code samples from the page into your browser's JavaScript console. To set this up:\n• in that tab, open the JavaScript console in your browser's developer tools\n• when we show an example, copy it into the console. You will have to reload the page each time you enter a new example, or the console will complain that you have redeclared . In this example, we'll download the JSON file from https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json, and log some information about it. To do this, we'll make an HTTP request to the server. In an HTTP request, we send a request message to a remote server, and it sends us back a response. In this case, we'll send a request to get a JSON file from the server. Remember in the last article, where we made HTTP requests using the API? Well, in this article, we'll use the API, which is the modern, promise-based replacement for . Copy this into your browser's JavaScript console:\n• calling the API, and assigning the return value to the variable\n• immediately after, logging the variable. This should output something like: , telling us that we have a object, and it has a whose value is . The state means that the fetch operation is still going on.\n• passing a handler function into the Promise's method. When (and if) the fetch operation succeeds, the promise will call our handler, passing in a object, which contains the server's response.\n• logging a message that we have started the request. The complete output should be something like: Note that is logged before we receive the response. Unlike a synchronous function, returns while the request is still going on, enabling our program to stay responsive. The response shows the (OK) status code, meaning that our request succeeded. This probably seems a lot like the example in the last article, where we added event handlers to the object. Instead of that, we're passing a handler into the method of the returned promise.\n\nWith the API, once you get a object, you need to call another function to get the response data. In this case, we want to get the response data as JSON, so we would call the method of the object. It turns out that is also asynchronous. So this is a case where we have to call two successive asynchronous functions. In this example, as before, we add a handler to the promise returned by . But this time, our handler calls , and then passes a new handler into the promise returned by . This should log \"baked beans\" (the name of the first product listed in \"products.json\"). But wait! Remember the last article, where we said that by calling a callback inside another callback, we got successively more nested levels of code? And we said that this \"callback hell\" made our code hard to understand? Isn't this just the same, only with calls? It is, of course. But the elegant feature of promises is that itself returns a promise, which will be completed with the result of the function passed to it. This means that we can (and certainly should) rewrite the above code like this: Instead of calling the second inside the handler for the first , we can return the promise returned by , and call the second on that return value. This is called promise chaining and means we can avoid ever-increasing levels of indentation when we need to make consecutive asynchronous function calls. Before we move on to the next step, there's one more piece to add. We need to check that the server accepted and was able to handle the request, before we try to read it. We'll do this by checking the status code in the response and throwing an error if it wasn't \"OK\":\n\nThis brings us to the last piece: how do we handle errors? The API can throw an error for many reasons (for example, because there was no network connectivity or the URL was malformed in some way) and we are throwing an error ourselves if the server returned an error. In the last article, we saw that error handling can get very difficult with nested callbacks, making us handle errors at every nesting level. To support error handling, objects provide a method. This is a lot like : you call it and pass in a handler function. However, while the handler passed to is called when the asynchronous operation succeeds, the handler passed to is called when the asynchronous operation fails. If you add to the end of a promise chain, then it will be called when any of the asynchronous function calls fail. So you can implement an operation as several consecutive asynchronous function calls, and have a single place to handle all errors. Try this version of our code. We've added an error handler using , and also modified the URL so the request will fail. const fetchPromise = fetch( \"bad-scheme://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json\", ); fetchPromise .then((response) => { if (!response.ok) { throw new Error(`HTTP error: ${response.status}`); } return response.json(); }) .then((data) => { console.log(data[0].name); }) .catch((error) => { console.error(`Could not get products: ${error}`); }); Try running this version: you should see the error logged by our handler.\n\nPromises come with some quite specific terminology that it's worth getting clear about. First, a promise can be in one of three states:\n• pending: the promise has been created, and the asynchronous function it's associated with has not succeeded or failed yet. This is the state your promise is in when it's returned from a call to , and the request is still being made.\n• fulfilled: the asynchronous function has succeeded. When a promise is fulfilled, its handler is called.\n• rejected: the asynchronous function has failed. When a promise is rejected, its handler is called. Note that what \"succeeded\" or \"failed\" means here is up to the API in question. For example, rejects the returned promise if (among other reasons) a network error prevented the request being sent, but fulfills the promise if the server sent a response, even if the response was an error like 404 Not Found. Sometimes, we use the term settled to cover both fulfilled and rejected. A promise is resolved if it is settled, or if it has been \"locked in\" to follow the state of another promise. The article Let's talk about how to talk about promises gives a great explanation of the details of this terminology.\n\nThe promise chain is what you need when your operation consists of several asynchronous functions, and you need each one to complete before starting the next one. But there are other ways you might need to combine asynchronous function calls, and the API provides some helpers for them. Sometimes, you need all the promises to be fulfilled, but they don't depend on each other. In a case like that, it's much more efficient to start them all off together, then be notified when they have all fulfilled. The method is what you need here. It takes an array of promises and returns a single promise. The promise returned by is:\n• fulfilled when and if all the promises in the array are fulfilled. In this case, the handler is called with an array of all the responses, in the same order that the promises were passed into .\n• rejected when and if any of the promises in the array are rejected. In this case, the handler is called with the error thrown by the promise that rejected. const fetchPromise1 = fetch( \"https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json\", ); const fetchPromise2 = fetch( \"https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found\", ); const fetchPromise3 = fetch( \"https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json\", ); Promise.all([fetchPromise1, fetchPromise2, fetchPromise3]) .then((responses) => { for (const response of responses) { console.log(`${response.url}: ${response.status}`); } }) .catch((error) => { console.error(`Failed to fetch: ${error}`); }); Here, we're making three requests to three different URLs. If they all succeed, we will log the response status of each one. If any of them fail, then we're logging the failure. With the URLs we've provided, all the requests should be fulfilled, although for the second, the server will return (Not Found) instead of (OK) because the requested file does not exist. So the output should be: If we try the same code with a badly formed URL, like this: const fetchPromise1 = fetch( \"https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json\", ); const fetchPromise2 = fetch( \"https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found\", ); const fetchPromise3 = fetch( \"bad-scheme://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json\", ); Promise.all([fetchPromise1, fetchPromise2, fetchPromise3]) .then((responses) => { for (const response of responses) { console.log(`${response.url}: ${response.status}`); } }) .catch((error) => { console.error(`Failed to fetch: ${error}`); }); Then we can expect the handler to run, and we should see something like: Sometimes, you might need any one of a set of promises to be fulfilled, and don't care which one. In that case, you want . This is like , except that it is fulfilled as soon as any of the array of promises is fulfilled, or rejected if all of them are rejected: Note that in this case we can't predict which fetch request will complete first. These are just two of the extra functions for combining multiple promises. To learn about the rest, see the reference documentation.\n\nThe keyword gives you a simpler way to work with asynchronous promise-based code. Adding at the start of a function makes it an async function: async function myFunction() { // This is an async function } Inside an async function, you can use the keyword before a call to a function that returns a promise. This makes the code wait at that point until the promise is settled, at which point the fulfilled value of the promise is treated as a return value, or the rejected value is thrown. This enables you to write code that uses asynchronous functions but looks like synchronous code. For example, we could use it to rewrite our fetch example: async function fetchProducts() { try { // after this line, our function will wait for the `fetch()` call to be settled // the `fetch()` call will either return a Response or throw an error const response = await fetch( \"https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json\", ); if (!response.ok) { throw new Error(`HTTP error: ${response.status}`); } // after this line, our function will wait for the `response.json()` call to be settled // the `response.json()` call will either return the parsed JSON object or throw an error const data = await response.json(); console.log(data[0].name); } catch (error) { console.error(`Could not get products: ${error}`); } } fetchProducts(); Here, we are calling , and instead of getting a , our caller gets back a fully complete object, just as if were a synchronous function! We can even use a block for error handling, exactly as we would if the code were synchronous. Note though that async functions always return a promise, so you can't do something like: async function fetchProducts() { try { const response = await fetch( \"https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json\", ); if (!response.ok) { throw new Error(`HTTP error: ${response.status}`); } const data = await response.json(); return data; } catch (error) { console.error(`Could not get products: ${error}`); } } const promise = fetchProducts(); console.log(promise[0].name); // \"promise\" is a Promise object, so this will not work Instead, you'd need to do something like: async function fetchProducts() { const response = await fetch( \"https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json\", ); if (!response.ok) { throw new Error(`HTTP error: ${response.status}`); } const data = await response.json(); return data; } const promise = fetchProducts(); promise .then((data) => { console.log(data[0].name); }) .catch((error) => { console.error(`Could not get products: ${error}`); }); Here, we moved the back to the handler on the returned promise. This means our handler doesn't have to deal with the case where an error got caught inside the function, causing to be . Handle errors as the last step of your promise chain. Also, note that you can only use inside an function, unless your code is in a JavaScript module. That means you can't do this in a normal script: try { // using await outside an async function is only allowed in a module const response = await fetch( \"https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json\", ); if (!response.ok) { throw new Error(`HTTP error: ${response.status}`); } const data = await response.json(); console.log(data[0].name); } catch (error) { console.error(`Could not get products: ${error}`); throw error; } You'll probably use functions a lot where you might otherwise use promise chains, and they make working with promises much more intuitive. Keep in mind that just like a promise chain, forces asynchronous operations to be completed in series. This is necessary if the result of the next operation depends on the result of the last one, but if that's not the case then something like will be more performant."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Async_JS",
        "document": "In this module, we take a look at asynchronous JavaScript, why it is important, and how it can be used to effectively handle potential blocking operations, such as fetching resources from a server.\n\nAsynchronous JavaScript is a fairly advanced topic, and you are advised to work through Dynamic scripting with JavaScript modules before attempting this. Note: If you are working on a computer/tablet/other device where you don't have the ability to create your own files, you can try out (most of) the code examples in an online coding program such as JS Bin or Glitch.\n\nIn this article, we'll learn about synchronous and asynchronous programming, why we often need to use asynchronous techniques, and the problems related to the way asynchronous functions have historically been implemented in JavaScript. How to use promises Here we'll introduce promises and show how to use promise-based APIs. We'll also introduce the and keywords. This article will outline how to implement your own promise-based API. Workers enable you to run certain tasks in a separate thread to keep your main code responsive. In this article, we'll rewrite a long-running synchronous function to use a worker. This challenge asks you to use promises to play a set of animations in a particular sequence."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises",
        "document": "A is an object representing the eventual completion or failure of an asynchronous operation. Since most people are consumers of already-created promises, this guide will explain consumption of returned promises before explaining how to create them. Essentially, a promise is a returned object to which you attach callbacks, instead of passing callbacks into a function. Imagine a function, , which asynchronously generates a sound file given a configuration record and two callback functions: one called if the audio file is successfully created, and the other called if an error occurs. Here's some code that uses : If were rewritten to return a promise, you would attach your callbacks to it instead: This convention has several advantages. We will explore each one.\n\nA common need is to execute two or more asynchronous operations back to back, where each subsequent operation starts when the previous operation succeeds, with the result from the previous step. In the old days, doing several asynchronous operations in a row would lead to the classic callback hell: With promises, we accomplish this by creating a promise chain. The API design of promises makes this great, because callbacks are attached to the returned promise object, instead of being passed into a function. Here's the magic: the function returns a new promise, different from the original: This second promise ( ) represents the completion not just of , but also of the or you passed in — which can be other asynchronous functions returning a promise. When that's the case, any callbacks added to get queued behind the promise returned by either or . Note: If you want a working example to play with, you can use the following template to create any function returning a promise: function doSomething() { return new Promise((resolve) => { setTimeout(() => { // Other things to do before completion of the promise console.log(\"Did something\"); // The fulfillment value of the promise resolve(\"https://example.com/\"); }, 200); }); } The implementation is discussed in the Creating a Promise around an old callback API section below. With this pattern, you can create longer chains of processing, where each promise represents the completion of one asynchronous step in the chain. In addition, the arguments to are optional, and is short for — so if your error handling code is the same for all steps, you can attach it to the end of the chain: You might see this expressed with arrow functions instead: Note: Arrow function expressions can have an implicit return; so, is short for . and can return any value — if they return promises, that promise is first waited until it settles, and the next callback receives the fulfillment value, not the promise itself. It is important to always return promises from callbacks, even if the promise always resolves to . If the previous handler started a promise but did not return it, there's no way to track its settlement anymore, and the promise is said to be \"floating\". doSomething() .then((url) => { // Missing `return` keyword in front of fetch(url). fetch(url); }) .then((result) => { // result is undefined, because nothing is returned from the previous // handler. There's no way to know the return value of the fetch() // call anymore, or whether it succeeded at all. }); By returning the result of the call (which is a promise), we can both track its completion and receive its value when it completes. Floating promises could be worse if you have race conditions — if the promise from the last handler is not returned, the next handler will be called early, and any value it reads may be incomplete. const listOfIngredients = []; doSomething() .then((url) => { // Missing `return` keyword in front of fetch(url). fetch(url) .then((res) => res.json()) .then((data) => { listOfIngredients.push(data); }); }) .then(() => { console.log(listOfIngredients); // listOfIngredients will always be [], because the fetch request hasn't completed yet. }); Therefore, as a rule of thumb, whenever your operation encounters a promise, return it and defer its handling to the next handler. const listOfIngredients = []; doSomething() .then((url) => { // `return` keyword now included in front of fetch call. return fetch(url) .then((res) => res.json()) .then((data) => { listOfIngredients.push(data); }); }) .then(() => { console.log(listOfIngredients); // listOfIngredients will now contain data from fetch call. }); Even better, you can flatten the nested chain into a single chain, which is simpler and makes error handling easier. The details are discussed in the Nesting section below. Using / can help you write code that's more intuitive and resembles synchronous code. Below is the same example using / : Note how the code looks exactly like synchronous code, except for the keywords in front of promises. One of the only tradeoffs is that it may be easy to forget the keyword, which can only be fixed when there's a type mismatch (e.g. trying to use a promise as a value). / builds on promises — for example, is the same function as before, so there's minimal refactoring needed to change from promises to / . You can read more about the / syntax in the async functions and references. Note: / has the same concurrency semantics as normal promise chains. within one async function does not stop the entire program, only the parts that depend on its value, so other async jobs can still run while the is pending.\n\nIn the examples above involving , the first one has one promise chain nested in the return value of another handler, while the second one uses an entirely flat chain. Simple promise chains are best kept flat without nesting, as nesting can be a result of careless composition. Nesting is a control structure to limit the scope of statements. Specifically, a nested only catches failures in its scope and below, not errors higher up in the chain outside the nested scope. When used correctly, this gives greater precision in error recovery: Note that the optional steps here are nested — with the nesting caused not by the indentation, but by the placement of the outer and parentheses around the steps. The inner error-silencing handler only catches failures from and , after which the code resumes with . Importantly, if fails, its error is caught by the final (outer) only, and does not get swallowed by the inner handler. In / , this code looks like: async function main() { try { const result = await doSomethingCritical(); try { const optionalResult = await doSomethingOptional(result); await doSomethingExtraNice(optionalResult); } catch (e) { // Ignore failures in optional steps and proceed. } await moreCriticalStuff(); } catch (e) { console.error(`Critical failure: ${e.message}`); } } Note: If you don't have sophisticated error handling, you very likely don't need nested handlers. Instead, use a flat chain and put the error handling logic at the end.\n\nIf a promise rejection event is not handled by any handler, it bubbles to the top of the call stack, and the host needs to surface it. On the web, whenever a promise is rejected, one of two events is sent to the global scope (generally, this is either the or, if being used in a web worker, it's the or other worker-based interface). The two events are: Sent when a promise is rejected but there is no rejection handler available. Sent when a handler is attached to a rejected promise that has already caused an event. In both cases, the event (of type ) has as members a property indicating the promise that was rejected, and a property that provides the reason given for the promise to be rejected. These make it possible to offer fallback error handling for promises, as well as to help debug issues with your promise management. These handlers are global per context, so all errors will go to the same event handlers, regardless of source. In Node.js, handling promise rejection is slightly different. You capture unhandled rejections by adding a handler for the Node.js event (notice the difference in capitalization of the name), like this: process.on(\"unhandledRejection\", (reason, promise) => { // Add code here to examine the \"promise\" and \"reason\" values }); For Node.js, to prevent the error from being logged to the console (the default action that would otherwise occur), adding that listener is all that's necessary; there's no need for an equivalent of the browser runtime's method. However, if you add that listener but don't also have code within it to handle rejected promises, they will just be dropped on the floor and silently ignored. So ideally, you should add code within that listener to examine each rejected promise and make sure it was not caused by an actual code bug.\n\nThere are four composition tools for running asynchronous operations concurrently: , , , and . We can start operations at the same time and wait for them all to finish like this: If one of the promises in the array rejects, immediately rejects the returned promise and aborts the other operations. This may cause unexpected state or behavior. is another composition tool that ensures all operations are complete before resolving. These methods all run promises concurrently — a sequence of promises are started simultaneously and do not wait for each other. Sequential composition is possible using some clever JavaScript: In this example, we reduce an array of asynchronous functions down to a promise chain. The code above is equivalent to: This can be made into a reusable compose function, which is common in functional programming: The function accepts any number of functions as arguments and returns a new function that accepts an initial value to be passed through the composition pipeline: Sequential composition can also be done more succinctly with async/await: let result; for (const f of [func1, func2, func3]) { result = await f(result); } /* use last result (i.e. result3) */ However, before you compose promises sequentially, consider if it's really necessary — it's always better to run promises concurrently so that they don't unnecessarily block each other unless one promise's execution depends on another's result.\n\nIn the callback-based API, when and how the callback gets called depends on the API implementor. For example, the callback may be called synchronously or asynchronously: The above design is strongly discouraged because it leads to the so-called \"state of Zalgo\". In the context of designing asynchronous APIs, this means a callback is called synchronously in some cases but asynchronously in other cases, creating ambiguity for the caller. For further background, see the article Designing APIs for Asynchrony, where the term was first formally presented. This API design makes side effects hard to analyze: let value = 1; doSomething(() => { value = 2; }); console.log(value); // 1 or 2? On the other hand, promises are a form of inversion of control — the API implementor does not control when the callback gets called. Instead, the job of maintaining the callback queue and deciding when to call the callbacks is delegated to the promise implementation, and both the API user and API developer automatically gets strong semantic guarantees, including:\n• Callbacks added with will never be invoked before the completion of the current run of the JavaScript event loop.\n• These callbacks will be invoked even if they were added after the success or failure of the asynchronous operation that the promise represents.\n• Multiple callbacks may be added by calling several times. They will be invoked one after another, in the order in which they were inserted. To avoid surprises, functions passed to will never be called synchronously, even with an already-resolved promise: Instead of running immediately, the passed-in function is put on a microtask queue, which means it runs later (only after the function which created it exits, and when the JavaScript execution stack is empty), just before control is returned to the event loop; i.e. pretty soon: const wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms)); wait(0).then(() => console.log(4)); Promise.resolve() .then(() => console.log(2)) .then(() => console.log(3)); console.log(1); // 1, 2, 3, 4"
    },
    {
        "link": "https://reddit.com/r/VoxelGameDev/comments/f9gha2/the_good_way_to_create_a_voxel_game",
        "document": "i'm a newby developer and for now i used Unity3D for my games. Recently i started to love the voxel stuff and im really interested to try to create a voxel game. For who knows how to use Unity, for my game, i use the GameObject for each element of my game but i learned that using a gameobject for each cube in a \"infinite\" world is quite impossible because it will burn your pc hehe.\n\nI followed a tutorial to how create minecraft in unity and he just use 1 gameobject to hold scripts and inside their scripts the cube is made using vertices and tris. So i thought that maybe using unity is too much and useless for a voxel game similar minecraft?\n\nCan you guys suggest me the right way to create a voxel game? I mean if i should keep using unity or maybe i should use lwjgl like Notch from minecraft or openGL or other stuff."
    },
    {
        "link": "https://reddit.com/r/VoxelGameDev/comments/15sy6ky/i_want_to_make_a_voxel_game_in_unreal_using",
        "document": "I know it's probably inefficient but I can't spend years trying to learn making a proper voxel engine.\n\nI intend to watch lots of tutorials and self studying to accomplish this but I just want some guidance cantrip from more experienced devs here. (I'm a 3d artist and my coding exp was years ago but I'm eager to learn)\n\nI was able to follow a tutorial to make an infinitely generating flat floor, but I'm unsure if I'm on the right path.\n\nMy only goal is to accomplish something like this for now. Where I'm able to generate millions of blocks and able to see every distant mountains like this. No destructible environment or inventories etc. I just wanna walk around and see very far terrain.\n\nIf you were me just starting out what would you have told yourself? Like in broad concepts how would you do this very far view distance? Is it doable in unreal blueprints or do I need to learn something else?\n\nI thought about reading some code from open source voxel games like minetest and veloren but how do I even start to do that? Do I install visual basic or python or something? Idk I'm just really lost and need some direction."
    },
    {
        "link": "https://stackoverflow.com/questions/32544383/procedural-structure-generation",
        "document": "I know this thread is old and I suck at explaining, but I'll share my approach.\n\nSo for example 5x5x5 trees. What you want is for your noise function to return the same value for an area of 5x5 blocks, so that even outside of the chunk, you can still check if you should generate a tree or not.\n\nAnd now we'll plant a tree. For this we need to check what x y z position this current block is relative to the tree's starting position, so we can know what part of the tree this block is.\n\nThe tree 3d array here is almost like a \"prefab\" of the tree, which you can use to know what block to set at the position relative to the starting point. (God I don't know how to explain this, and having english as my fifth language doesn't help me either ;-; feel free to improve my answer or create a new one). I've implemented this in my engine, and it's totally working. The structures can be as big as you want, with no chunk pre loading needed. The one problem with this method is that the trees or structures will we spawned almost within a grid, but this can easily be solved with multiple octaves with different offsets.\n\nSo 'i' and 'k' are looping withing the chunk, and 'j' is looping inside the structure. This is pretty much how it should work.\n\nAnd about the rivers, I personally haven't done it yet, and I'm not sure why you need to set the blocks around the chunk when generating them ( you could just use perlin worms and it would solve problem), but it's pretty much the same idea, and for your cities too."
    },
    {
        "link": "https://discussions.unity.com/t/best-approach-for-open-world-voxel-performance/952395",
        "document": ""
    },
    {
        "link": "https://github.com/topics/voxel-generator",
        "document": "This project is a DL model that performs 3D shape (voxelization) generation. It takes text prompts and produces 3D shapes. The model is implemented using supervised learning and has been tested on pytorch."
    }
]