[
    {
        "link": "https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_bvp.html",
        "document": "Solve a boundary value problem for a system of ODEs.\n\nThis function numerically solves a first order system of ODEs subject to two-point boundary conditions:\n\nHere x is a 1-D independent variable, y(x) is an n-D vector-valued function and p is a k-D vector of unknown parameters which is to be found along with y(x). For the problem to be determined, there must be n + k boundary conditions, i.e., bc must be an (n + k)-D function.\n\nThe last singular term on the right-hand side of the system is optional. It is defined by an n-by-n matrix S, such that the solution must satisfy S y(a) = 0. This condition will be forced during iterations, so it must not contradict boundary conditions. See [2] for the explanation how this term is handled when solving BVPs numerically.\n\nProblems in a complex domain can be solved as well. In this case, y and p are considered to be complex, and f and bc are assumed to be complex-valued functions, but x stays real. Note that f and bc must be complex differentiable (satisfy Cauchy-Riemann equations [4]), otherwise you should rewrite your problem for real and imaginary parts separately. To solve a problem in a complex domain, pass an initial guess for y with a complex data type (see below).\n\nRight-hand side of the system. The calling signature is , or if parameters are present. All arguments are ndarray: with shape (m,), with shape (n, m), meaning that corresponds to , and with shape (k,). The return value must be an array with shape (n, m) and with the same layout as . Function evaluating residuals of the boundary conditions. The calling signature is , or if parameters are present. All arguments are ndarray: and with shape (n,), and with shape (k,). The return value must be an array with shape (n + k,). Initial mesh. Must be a strictly increasing sequence of real numbers with and . Initial guess for the function values at the mesh nodes, ith column corresponds to . For problems in a complex domain pass y with a complex data type (even if the initial guess is purely real). p array_like with shape (k,) or None, optional Initial guess for the unknown parameters. If None (default), it is assumed that the problem doesn’t depend on any parameters. S array_like with shape (n, n) or None Matrix defining the singular term. If None (default), the problem is solved without the singular term. Function computing derivatives of f with respect to y and p. The calling signature is , or if parameters are present. The return must contain 1 or 2 elements in the following order:\n• None df_dy : array_like with shape (n, n, m), where an element (i, j, q) equals to d f_i(x_q, y_q, p) / d (y_q)_j.\n• None df_dp : array_like with shape (n, k, m), where an element (i, j, q) equals to d f_i(x_q, y_q, p) / d p_j. Here q numbers nodes at which x and y are defined, whereas i and j number vector components. If the problem is solved without unknown parameters, df_dp should not be returned. If fun_jac is None (default), the derivatives will be estimated by the forward finite differences. Function computing derivatives of bc with respect to ya, yb, and p. The calling signature is , or if parameters are present. The return must contain 2 or 3 elements in the following order:\n• None dbc_dya : array_like with shape (n, n), where an element (i, j) equals to d bc_i(ya, yb, p) / d ya_j.\n• None dbc_dyb : array_like with shape (n, n), where an element (i, j) equals to d bc_i(ya, yb, p) / d yb_j.\n• None dbc_dp : array_like with shape (n, k), where an element (i, j) equals to d bc_i(ya, yb, p) / d p_j. If the problem is solved without unknown parameters, dbc_dp should not be returned. If bc_jac is None (default), the derivatives will be estimated by the forward finite differences. Desired tolerance of the solution. If we define , where y is the found solution, then the solver tries to achieve on each mesh interval , where is estimated in a root mean squared sense (using a numerical quadrature formula). Default is 1e-3. Maximum allowed number of the mesh nodes. If exceeded, the algorithm terminates. Default is 1000. Desired absolute tolerance for the boundary condition residuals: bc value should satisfy component-wise. Equals to tol by default. Up to 10 iterations are allowed to achieve this tolerance. Bunch object with the following fields defined: Found parameters. None, if the parameters were not present in the problem. RMS values of the relative residuals over each mesh interval (see the description of tol parameter).\n• None 0: The algorithm converged to the desired accuracy.\n• None 1: The maximum number of mesh nodes is exceeded. True if the algorithm converged to the desired accuracy ( ).\n\nThis function implements a 4th order collocation algorithm with the control of residuals similar to [1]. A collocation system is solved by a damped Newton method with an affine-invariant criterion function as described in [3].\n\nNote that in [1] integral residuals are defined without normalization by interval lengths. So, their definition is different by a multiplier of h**0.5 (h is an interval length) from the definition used here.\n\nIn the first example, we solve Bratu’s problem: We rewrite the equation as a first-order system and implement its right-hand side evaluation: This problem is known to have two solutions. To obtain both of them, we use two different initial guesses for y. We denote them by subscripts a and b. Now we are ready to run the solver. Let’s plot the two found solutions. We take an advantage of having the solution in a spline form to produce a smooth plot. We see that the two solutions have similar shape, but differ in scale significantly. In the second example, we solve a simple Sturm-Liouville problem: It is known that a non-trivial solution y = A * sin(k * x) is possible for k = pi * n, where n is an integer. To establish the normalization constant A = 1 we add a boundary condition: Again, we rewrite our equation as a first-order system and implement its right-hand side evaluation: Note that parameters p are passed as a vector (with one element in our case). Set up the initial mesh and guess for y. We aim to find the solution for k = 2 * pi, to achieve that we set values of y to approximately follow sin(2 * pi * x): Run the solver with 6 as an initial guess for k. We see that the found k is approximately correct: And, finally, plot the solution to see the anticipated sinusoid:"
    },
    {
        "link": "https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.integrate.solve_bvp.html",
        "document": "Solve a boundary value problem for a system of ODEs.\n\nThis function numerically solves a first order system of ODEs subject to two-point boundary conditions:\n\nHere x is a 1-D independent variable, y(x) is an N-D vector-valued function and p is a k-D vector of unknown parameters which is to be found along with y(x). For the problem to be determined, there must be n + k boundary conditions, i.e., bc must be an (n + k)-D function.\n\nThe last singular term on the right-hand side of the system is optional. It is defined by an n-by-n matrix S, such that the solution must satisfy S y(a) = 0. This condition will be forced during iterations, so it must not contradict boundary conditions. See [2] for the explanation how this term is handled when solving BVPs numerically.\n\nProblems in a complex domain can be solved as well. In this case, y and p are considered to be complex, and f and bc are assumed to be complex-valued functions, but x stays real. Note that f and bc must be complex differentiable (satisfy Cauchy-Riemann equations [4]), otherwise you should rewrite your problem for real and imaginary parts separately. To solve a problem in a complex domain, pass an initial guess for y with a complex data type (see below).\n\nRight-hand side of the system. The calling signature is , or if parameters are present. All arguments are ndarray: with shape (m,), with shape (n, m), meaning that corresponds to , and with shape (k,). The return value must be an array with shape (n, m) and with the same layout as . Function evaluating residuals of the boundary conditions. The calling signature is , or if parameters are present. All arguments are ndarray: and with shape (n,), and with shape (k,). The return value must be an array with shape (n + k,). Initial mesh. Must be a strictly increasing sequence of real numbers with and . Initial guess for the function values at the mesh nodes, ith column corresponds to . For problems in a complex domain pass y with a complex data type (even if the initial guess is purely real). p array_like with shape (k,) or None, optional Initial guess for the unknown parameters. If None (default), it is assumed that the problem doesn’t depend on any parameters. S array_like with shape (n, n) or None Matrix defining the singular term. If None (default), the problem is solved without the singular term. Function computing derivatives of f with respect to y and p. The calling signature is , or if parameters are present. The return must contain 1 or 2 elements in the following order:\n• None df_dy : array_like with shape (n, n, m), where an element (i, j, q) equals to d f_i(x_q, y_q, p) / d (y_q)_j.\n• None df_dp : array_like with shape (n, k, m), where an element (i, j, q) equals to d f_i(x_q, y_q, p) / d p_j. Here q numbers nodes at which x and y are defined, whereas i and j number vector components. If the problem is solved without unknown parameters, df_dp should not be returned. If fun_jac is None (default), the derivatives will be estimated by the forward finite differences. Function computing derivatives of bc with respect to ya, yb, and p. The calling signature is , or if parameters are present. The return must contain 2 or 3 elements in the following order:\n• None dbc_dya : array_like with shape (n, n), where an element (i, j) equals to d bc_i(ya, yb, p) / d ya_j.\n• None dbc_dyb : array_like with shape (n, n), where an element (i, j) equals to d bc_i(ya, yb, p) / d yb_j.\n• None dbc_dp : array_like with shape (n, k), where an element (i, j) equals to d bc_i(ya, yb, p) / d p_j. If the problem is solved without unknown parameters, dbc_dp should not be returned. If bc_jac is None (default), the derivatives will be estimated by the forward finite differences. Desired tolerance of the solution. If we define , where y is the found solution, then the solver tries to achieve on each mesh interval , where is estimated in a root mean squared sense (using a numerical quadrature formula). Default is 1e-3. Maximum allowed number of the mesh nodes. If exceeded, the algorithm terminates. Default is 1000. Desired absolute tolerance for the boundary condition residuals: bc value should satisfy component-wise. Equals to tol by default. Up to 10 iterations are allowed to achieve this tolerance. Bunch object with the following fields defined: Found parameters. None, if the parameters were not present in the problem. RMS values of the relative residuals over each mesh interval (see the description of tol parameter).\n• None 0: The algorithm converged to the desired accuracy.\n• None 1: The maximum number of mesh nodes is exceeded. True if the algorithm converged to the desired accuracy ( ).\n\nThis function implements a 4th order collocation algorithm with the control of residuals similar to [1]. A collocation system is solved by a damped Newton method with an affine-invariant criterion function as described in [3].\n\nNote that in [1] integral residuals are defined without normalization by interval lengths. So, their definition is different by a multiplier of h**0.5 (h is an interval length) from the definition used here.\n\nIn the first example, we solve Bratu’s problem:\n\nWe rewrite the equation as a first-order system and implement its right-hand side evaluation:\n\nThis problem is known to have two solutions. To obtain both of them, we use two different initial guesses for y. We denote them by subscripts a and b.\n\nNow we are ready to run the solver.\n\nLet’s plot the two found solutions. We take an advantage of having the solution in a spline form to produce a smooth plot.\n\nWe see that the two solutions have similar shape, but differ in scale significantly.\n\nIn the second example, we solve a simple Sturm-Liouville problem:\n\nIt is known that a non-trivial solution y = A * sin(k * x) is possible for k = pi * n, where n is an integer. To establish the normalization constant A = 1 we add a boundary condition:\n\nAgain, we rewrite our equation as a first-order system and implement its right-hand side evaluation:\n\nNote that parameters p are passed as a vector (with one element in our case).\n\nSet up the initial mesh and guess for y. We aim to find the solution for k = 2 * pi, to achieve that we set values of y to approximately follow sin(2 * pi * x):\n\nRun the solver with 6 as an initial guess for k.\n\nWe see that the found k is approximately correct:\n\nAnd, finally, plot the solution to see the anticipated sinusoid:"
    },
    {
        "link": "https://caam37830.github.io/book/04_functions/bvp.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/58792981/solving-a-bvp-using-scipy-solve-bvp-where-the-function-returns-an-array",
        "document": "a few problems I think. Firstly the only reason for trying to 'run back' to the -1000 day point as far as I can see would be to obtain a good y estimate to pass to solve_bvp.\n\nto do this simply reverse the initial velocities and run a similation to +1000 days. once you have done this flip the resulting sol.y arrays and they should serve as a good estimate for solve_bvp.\n\nNext, you dont actually need vel past, boundary conditions of the initial position and the t=0 velocity will do perfectly.\n\nThis brings us to the next problem, your Boundary condition function looks mistaken.\n\nit should look something like this.\n\nFinal note: you will most likley have to increase the number of nodes in the solve_bvp problem to"
    },
    {
        "link": "https://github.com/jkitchin/f19-06623/blob/master/lectures/09-bvp.org",
        "document": "Adapted from Example 8.7 in Numerical Methods in Engineering with Python by Jaan Kiusalaas.\n\nWe want to solve with and .\n\nThis is a boundary value problem not an initial value problem. First we consider using a finite difference method. We discretize the region and approximate the derivatives as:\n\nWe define a function . At each node in our discretized region, we will have an equation that looks like , which will be nonlinear in the unknown solution . The set of equations to solve is:\n\nSince we use a nonlinear solver, we will have to provide an initial guess to the solution. We will in this case assume a line. In other cases, a bad initial guess may lead to no solution.\n\nWe need to specify a grid of points to discretize the solution on. We will start with a small grid because it is easy to visualize, but note that the grid spacing determines how good the approximation to the derivative is, so we will have to return here to see what the impact of our spacing is.\n\nNow, we can define functions for the differential equation, and for the nonlinear equations.\n\nWe need a guess, and here we guess a line. It is always a good idea to plot your guess just to make sure it does what you want. Here, we want it to have the right boundary values.\n\nWe should check our residuals function. We mostly want to see that it runs, and produces the right shaped output.\n\nNow, we solve the BVP.\n\nThe solution is has some apparent discontinuities because we only used about 10 points. How can you tell if the solution is correct? We can estimate the derivatives, and see how well they fit the equation. We look for:\n\nThis result doesn’t look great at the origin, but remember:\n• we used a coarse grid, so the derivative approximations are probably not that accurate\n• Numerical derivatives at the end-points are less accurate than in the middle.\n\nexercise Go back and repeat this for a finer grid, e.g. with 50, 100 points.\n\nThe approach described here is pretty general. Here, we were able to solve a second-order BVP by discretizing it, approximating the derivatives at the points, and solving the corresponding nonlinear algebra equations. This approach can be extended in a variety of ways, including to systems of equations, and to 2D or 3D systems (where this approach is called finite-element). You will see these kinds of problems extensively in the spring semster in the Transport class.\n\nAs we have seen before, however, there are functions in that can help solve these problems.\n\nIn the pressure driven flow of a fluid with viscosity between two stationary plates separated by distance and driven by a pressure drop , the governing equations on the velocity of the fluid are (assuming flow in the x-direction with the velocity varying only in the y-direction):\n\nwith boundary conditions and , i.e. the no-slip condition at the edges of the plate.\n\nwe convert this second order BVP to a system of ODEs by letting , and then . This leads to:\n\nfor this problem we let the plate separation be d=0.1, the viscosity , and .\n\nThe function defining the BVP has to return an array that has a row for each equation, and a column for each value in the grid.\n\nThe boundary condition function will get the whole numeric solution at each boundary. We want and .\n\nNext, we need an initial guess for u1 and u2 on a grid of points. You have to make some decisions here. You need a guess that is reasonably close, but not hard to construct. Here, we anticipate a solution that looks parabolic, and that goes through the points: (0, 0), (d, 0), and some point at (d / 2, ?), where ? represents the point of maximum velocity in middle. We can easily get this polynomial with np.polyfit.\n\nWe don’t know what the maximum velocity is, so we make a guess, say 0.5. Then, we get the parameters, and apply them to an array of y values.\n\nNow, we can define a Y grid and define the guess for the first U1.\n\nWe also need a guess for U2, and in this case we know that , so we just use that.\n\nYou should always visualize the guess to make sure it does what you want. It is hard to make these!\n\nNow, we are ready to solve the BVP.\n\nexercise Try using different guesses, e.g. lines, or triangle shapes, etc. What else looks like this shape? Half a cycle of a sin wave? A semi-circle?\n\nexercise How can you show this is a solution to the BVP?\n\nAnother typical boundary value problem in chemical engineering is the concentration profile inside a catalyst particle. Here is the dimensionless equation for a second order reaction in a slab. Note here we have a boundary condition on the derivative at the origin. This kind of condition means either there is no flux at this position, or that the slab is symmetric about this position.\n\nWe again convert this to a system of first order differential equations like this:\n\nLet c1 = c, c1’ = c’, and c2 = c1’, so c2’ = c1” = c”\n\nThen we have:\n\nWe begin with the required functions:\n\nWe need an initial guess. We make a naive one, that in the slab, i.e. there is no reaction. As usual, we visualize the guess to be sure it does what we intended.\n\nNow we solve the system.\n\nYou can see the solution looks nothing like our initial guess. In this case, a high thiele modulus means most of the reaction happens near the catalyst surface, and the interior of the slab has hardly any reactant in it. This solution is consistent with that.\n\nThe effectiveness factor for this system is defined by:\n\nWe can estimate this with the trapezoid or Simpson’s method (remember that the solution is a vector of numbers).\n\nOr, we can use the dense_output of the solution with quad.\n\nexcercise Repeat this example for different values of Φ.\n\nexercise Try different kinds of guesses. Think of a guess that has the properties of the boundary conditions, e.g. c’(0) = 0, and c(1) = 1.\n\nexercise Evaluate the quality of the solution based on the equations.\n\nToday, we leveraged the ability to solve systems of nonlinear algebraic equations to solve boundary value problems by discretizing them on a grid, approximating them at the grid points, and then solving the resulting nonlinear equations.\n\nWe also learned about the solve_bvp function, which is in scipy.integrate to solve systems of first-order boundary value problems.\n\nNext time, we will return to nonlinear algebra to see how the algorithms can be used to find minima and maxima."
    },
    {
        "link": "https://geeksforgeeks.org/three-dimensional-plotting-in-python-using-matplotlib",
        "document": "3D plots are very important tools for visualizing data that have three dimensions such as data that have two dependent and one independent variable. By plotting data in 3d plots we can get a deeper understanding of data that have three variables. We can use various matplotlib library functions to plot 3D plots.\n\nExample Of Three-dimensional Plotting using Matplotlib\n\nWe will first start with plotting the 3D axis using the Matplotlib library. For plotting the 3D axis we just have to change the projection parameter of plt.axes() from None to 3D.\n\nWith the above syntax three -dimensional axes are enabled and data can be plotted in 3 dimensions. 3 dimension graph gives a dynamic approach and makes data more interactive. Like 2-D graphs, we can use different ways to represent to plot 3-D graphs. We can make a scatter plot, contour plot, surface plot, etc. Let’s have a look at different 3-D plots.\n\nGraphs with lines and points are the simplest 3-dimensional graph. We will use ax.plot3d and ax.scatter functions to plot line and point graph respectively.\n\nFor plotting the 3-Dimensional line graph we will use the mplot3d function from the mpl_toolkits library. For plotting lines in 3D we will have to initialize three variable points for the line equation. In our case, we will define three variables as x, y, and z. \n\n\n\nTo plot the same graph using scatter points we will use the scatter() function from matplotlib. It will plot the same line equation using distinct points.\n\nSurface graphs and Wireframes graph work on gridded data. They take the grid value and plot it on a three-dimensional surface. We will use the plot_surface() function to plot the surface plot.\n\nFor plotting the wireframes graph we will use the plot_wireframe() function from the matplotlib library.\n\nThe contour graph takes all the input data in two-dimensional regular grids, and the Z data is evaluated at every point. We use the ax.contour3D function to plot a contour graph. Contour plots are an excellent way to visualize optimization plots.\n\nThe above graph is sometimes overly restricted and inconvenient. So by this method, we use a set of random draws. The function ax.plot_trisurf is used to draw this graph. It is not that clear but more flexible.\n\nMöbius strip also called the twisted cylinder, is a one-sided surface without boundaries. To create the Möbius strip think about its parameterization, it’s a two-dimensional strip, and we need two intrinsic dimensions. Its angle range from 0 to 2 pie around the loop and its width ranges from -1 to 1."
    },
    {
        "link": "https://stackoverflow.com/questions/40351026/plotting-a-simple-3d-numpy-array-using-matplotlib",
        "document": "I want to plot the result of a numerical method for a three dimensional system of ODEs. My output is in the form (let's suppose we have computed three steps):\n\nWhere the first value in every 3-tuple is the x coordinate, the second is y coordinate and the third is the z coordinate.\n\nI would like the most simple and efficient way of plotting these points on a 3D grid. The problem seems to be that the data should be formated like ."
    },
    {
        "link": "https://matplotlib.org/stable/gallery/mplot3d/index.html",
        "document": "Clip the data to the axes view limits\n\nClip the data to the axes view limits"
    },
    {
        "link": "https://pythonnumericalmethods.studentorg.berkeley.edu/notebooks/chapter12.02-3D-Plotting.html",
        "document": "This notebook contains an excerpt from the Python Programming and Numerical Methods - A Guide for Engineers and Scientists, the content is also available at Berkeley Python Numerical Methods.\n\nThe copyright of the book belongs to Elsevier. We also have this interactive book online for a better learning experience. The code is released under the MIT license. If you find this content useful, please consider supporting the work on Elsevier or Amazon!\n\nIn order to plot 3D figures use matplotlib, we need to import the mplot3d toolkit, which adds the simple 3D plotting capabilities to matplotlib.\n\nOnce we imported the mplot3d toolkit, we could create 3D axes and add data to the axes. Let’s first create a 3D axes.\n\nThe ax = plt.axes(projection=’3d’) created a 3D axes object, and to add data to it, we could use plot3D function. And we could change the title, set the x,y,z labels for the plot as well.\n\nTRY IT! Consider the parameterized data set t is a vector from 0 to \\(10\\pi\\) with a step \\(\\pi/50\\), x = sin(t), and y = cos(t). Make a three-dimensional plot of the (x,y,t) data set using plot3. Turn the grid on, make the axis equal, and put axis labels and a title. Let’s also activate the interactive plot using %matplotlib notebook, so that you can move and rotate the figure as well.\n\nTry to rotate the above figure, and get a 3D view of the plot. You may notice that we also set the labelpad=20 to the 3-axis labels, which will make the label not overlap with the tick texts.\n\nWe could also plot 3D scatter plot using scatter function.\n\nTRY IT! Make a 3D scatter plot with randomly generate 50 data points for x, y, and z. Set the point color as red, and size of the point as 50.\n\nMany times we would like a surface plot rather than a line plot when plotting in three dimensions. In three-dimensional surface plotting, we wish to make a graph of some relationship f (x, y). In surface plotting all (x,y) pairs must be given. This is not straightforward to do using vectors. Therefore, in surface plotting, the first data structure you must create is called a mesh. Given lists/arrays of x and y values, a mesh is a listing of all the possible combinations of x and y. In Python, the mesh is given as two arrays X and Y where X (i,j) and Y (i,j) define possible (x,y) pairs. A third array, Z, can then be created such that Z (i,j) = f (X (i,j), Y (i,j)). A mesh can be created using the np.meshgrid function in Python. The meshgrid function has the inputs x and y are lists containing the independent data set. The output variables X and Y are as described earlier.\n\nTRY IT! Create a mesh for x = [1, 2, 3, 4] and y = [3, 4, 5] using the meshgrid function.\n\nWe could plot 3D surfaces in Python too, the function to plot the 3D surfaces is plot_surface(X,Y,Z), where X and Y are the output arrays from meshgrid, and \\(Z = f (X,Y)\\) or \\(Z (i,j) = f (X (i,j),Y (i,j))\\). The most common surface plotting functions are surf and contour.\n\nTRY IT! Make a plot of the surface \\(f(x,y) = sin(x)\\cdot cos(y) for -5\\le x\\le5, -5\\le y\\le5\\) using the plot_surface function. Take care to use a sufficiently fine discretization in x and y to make the plot look smooth.\n\nYou will notice that the surface plot shows different colors for different elevations, yellow for higher and blue for lower, since we used the colormap plt.cm.cividis in the surface plot. You can change to different color schemes for the surface plot. These are left as exercises. We also plotted a colorbar to show the corresponding colors to different values.\n\nWe could have subplots of different 3D plots as well. We could use the add_subplot function from the figure object we created to generate the subplots for 3D cases.\n\n‘ TRY IT! Make a 1 by 2 subplot to plot the above X, Y, Z data in wireframe plot and surface plot.\n\nThere are many more functions related to plotting in Python and this is in no way an exhaustive list. However, it should be enough to get you started so that you can find the plotting functions in Python that suit you best and provide you with enough background to learn how to use them when you encounter them. You can find more examples of different type 3D plots on the mplot3d tutorial website."
    },
    {
        "link": "https://stackoverflow.com/questions/12414619/creating-a-3d-plot-from-a-3d-numpy-array",
        "document": "If you have a like that, and you want to just get the values, you could use , which \"returns a tuple of arrays, one for each dimension of , containing the indices of the non-zero elements in that dimension.\".\n\nFor example, we can make a simple 3d array:\n\nand find where the nonzero elements are located:\n\nIf we wanted a more complicated cut, we could have done something like or something, as True has an integer value of 1 and counts as nonzero."
    }
]