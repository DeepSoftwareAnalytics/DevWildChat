[
    {
        "link": "https://developers.google.com/earth-engine/guides/ic_creating",
        "document": "Save and categorize content based on your preferences.\n\nStay organized with collections Save and categorize content based on your preferences.\n\nAn is a stack or sequence of images. An can be loaded by pasting an Earth Engine asset ID into the constructor. You can find IDs in the data catalog. For example, to load the Sentinel-2 surface reflectance collection:\n\nThis collection contains every Sentinel-2 image in the public catalog. There are a lot. Usually you want to filter the collection as shown here or here.\n\nIn addition to loading an using an Earth Engine collection ID, Earth Engine has methods to create image collections. The constructor or the convenience method create image collections from lists of images. You can also create new image collections by merging existing collections. For example:\n\nNote that in this example an is created by mapping a function that returns an over a . Learn more about mapping in the Mapping over an ImageCollection section. Learn more about feature collections from the FeatureCollection section.\n\nYou can also create an from GeoTiffs in Cloud Storage. For example:\n\nLearn more about loading images from Cloud GeoTiffs."
    },
    {
        "link": "https://developers.google.com/earth-engine/tutorials/tutorial_api_04",
        "document": "An image collection refers to a set of Earth Engine images. For example, the collection of all Landsat 8 images is an . Like the SRTM image you have been working with, image collections also have an ID. As with single images, you can discover the ID of an image collection by searching the Earth Engine data catalog from the Code Editor and looking at the details page of the dataset. For example, search for 'landsat 8 toa' and click on the first result, which should correspond to the USGS Landsat 8 Collection 1 Tier 1 TOA Reflectance dataset. Either import that dataset using the Import button and rename it to , or copy the ID into the image collection constructor:\n\nIt's worth noting that this collection represents every Landsat 8 scene collected, all over the Earth. Often it is useful to extract a single image, or subset of images, on which to test algorithms. The way to limit the collection by time or space is by filtering it. For example, to filter the collection to images that cover a particular location, first define your area of interest with a point (or line or polygon) using the geometry drawing tools. Pan to your area of interest, hover on the Geometry Imports (if you already have one or more geometries defined) and click +new layer (if you don't have any imports, go to the next step). Get the point drawing tool ( ) and make a point in your area of interest. Name the import . Now, filter the collection to get only the images that intersect the point, then add a second filter to limit the collection to only the images that were acquired in 2015:\n\nHere, and are shortcut methods for the more general method on image collections, which takes an as its argument. Explore the Docs tab of the Code Editor to learn more about these methods. The argument to is the point you digitized and the arguments to are two dates, expressed as strings.\n\nNote that you can the filtered collections. You can't print more than 5000 things at once, so you couldn't, for example, print the entire collection. After executing the method, you can inspect the printed collections in the console. Note that when you expand the using the zippy ( ), then expand the list of , you will see a list of images, each of which also can be expanded and inspected. This is one way to discover the ID of an individual image. Another, more programmatic way to get individual images for analysis is to sort the collection in order to get the most recent, oldest, or optimal image relative to some metadata property. For example, by inspecting the image objects in the printed image collections, you may have observed a metadata property called . You can use that property to get the least cloudy image in 2015 in your area of interest: // This will sort from least to most cloudy. var sorted = temporalFiltered.sort('CLOUD_COVER'); // Get the first (least cloudy) image. var scene = sorted.first();\n\nYou're now ready to display the image!\n\nWhen a multi-band image is added to a map, Earth Engine chooses the first three bands of the image and displays them as red, green, and blue by default, stretching them according to the data type, as described previously. Usually, this won't do. For example, if you add the Landsat image ( in the previous example) to the map, the result is unsatisfactory:\n\nNote that first, the map is centered on the image at zoom scale 9. Then the image is displayed with an empty object ( ) for the parameter (see the docs for details). As a result, the image is displayed with the default visualization: first three bands map to R, G, B, respectively, and stretched to [0, 1] since the bands are data type. This means that the coastal aerosol band ('B1') is rendered in red, the blue band ('B2') is rendered in green, and the green band ('B3') is rendered in blue. To render the image as a true-color composite, you need to tell Earth Engine to use the Landsat 8 bands 'B4', 'B3', and 'B2' for R, G, and B, respectively. Specify which bands to use with the property of the object. Learn more about Landsat bands at this reference.\n\nYou also need to provide and values suitable for displaying reflectance from typical Earth surface targets. Although lists can be used to specify different values for each band, here it's sufficient to specify as and use the default value of zero for the parameter. Combining the visualization parameters into one object and displaying:\n\nThe result should look something like Figure 5. Note that this code assigns the object of visualization parameters to a variable for possible future use. As you'll soon discover, that object will be useful when you visualize image collections!\n\nTry playing with visualizing different bands. Another favorite combination is 'B5', 'B4', and 'B3' which is called a false-color composite. Some other interesting false-color composites are described here.\n\nSince Earth Engine is designed to do large-scale analyses, you are not limited to working with just one scene. Now it's time to display a whole collection as an RGB composite!\n\nAdding an image collection to a map is similar to adding an image to a map. For example, using 2016 images in the collection and the object defined previously,\n\nNote that now you can zoom out and see a continuous mosaic where Landsat imagery is collected (i.e. over land). Also note that when you use the Inspector tab and click on the image, you'll see a list of pixel values (or a chart) in the Pixels section and a list of image objects in the Objects section of the inspector.\n\nIf you zoomed out enough, you probably noticed some clouds in the mosaic. When you add an to the map, it is displayed as a recent-value composite, meaning that only the most recent pixels are displayed (like calling on the collection). That is why you can see discontinuities between paths which were acquired at different times. It's also why many areas may appear cloudy. In the next page, learn how to change the way the images are composited to get rid of those pesky clouds!"
    },
    {
        "link": "https://courses.spatialthoughts.com/end-to-end-gee.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/43868762/exporting-all-images-in-a-google-earth-engine-image-collection-google-earth-eng",
        "document": "I need to download a bunch of Landsat images for my thesis. My problem seems simple but I don't have a clue about JavaScript and the documentation didn't help enough. I have filtered the collection to my region and time period and i want to export all images to Drive, seperately. Collection example:\n\nThe code for exporting a single image is:\n\nHow can I iterate through the collection to export all images? The use of map() function seems to be the answer.\n\nThe question is how to set the image parameter to the correct image (i.e first the 1st image, then the 2nd etc, something like ' ' ) and the description to match image (i.e. , ...).\n\nMany thanks in advance!!!"
    },
    {
        "link": "https://gis.stackexchange.com/questions/463018/classification-using-google-earth-engine-javascript-api",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://developers.google.com/earth-engine/apidocs/export-image-todrive",
        "document": "// Use the \"crsTransform\" export parameter instead of \"scale\" for more control // over the output grid. Here, \"crsTransform\" is set to align the output grid // with the grid of another dataset. To view an image's CRS transform: // If the export has more than 1e8 pixels, set \"maxPixels\" higher. // Define a nodata value and replace masked pixels with it using \"unmask\". // Set the \"sameFootprint\" parameter as \"false\" to include pixels outside of the // Use the \"noData\" key in the \"formatOptions\" parameter to set the nodata value"
    },
    {
        "link": "https://developers.google.com/earth-engine/guides/exporting_images",
        "document": "You can export images from Earth Engine in GeoTIFF or TFRecord format. See Configuration Parameters for more output options.\n\nStart by defining the image data that will be exported:\n\nNext define the projection parameters that will be used in the following exports. We use the parameter to specify the coordinate system, and the parameter to precisely specify the pixel grid. The parameter is a list of parameters from an affine transformation matrix in row-major order . An image's origin is defined by the and values, and the image's pixel size is defined by the and values. See examples of affine matrices.\n\nAs a shortcut, you can specify a parameter and Earth Engine will calculate a parameter for you. However, simply setting the scale of an image does not specify the origin of the projection, and may result in an image that is shifted relative to another image with the same pixel size!\n\nThe reason for the potential shift is that the parameter is used to populate the and values of the , but the and values are calculated so that if they are divided by the corresponding and values the remainder will be zero. These parameters specify a pixel grid where the projection's origin is at the corner of a pixel. This convention differs from the translation parameters used by some data providers, which use grids that are offset from the projection's origin. For example, Landsat images provided by USGS use translation parameters that are offset by a 1/2 pixel from the projection's origin (15m offset for the 30m bands) while Sentinel-2 images provided by ESA use translation parameters that are aligned with the projection's origin. If the specified in an export do not match the of the original image, the output pixels will be resampled (using nearest neighbor by default), which will make the resulting image be shifted relative to the original image.\n\nTo sum up, if you need to match the exported image's pixels to a specific image, make sure to use the and parameters for full control of the grid.\n\nTo export an image to your Drive account, use . For example, to export portions of a Landsat image, define a region to export, then call :\n\nWhen this code is run, an export task will be created in the Code Editor Tasks tab. Click the Run button next to the task to start it. (Learn more about the Task Manager from the Code Editor section). The image will be created in your Drive account with the specified .\n\nTo export an image to a Google Cloud Storage bucket, use . To export the Landsat image in the previous example to Cloud Storage instead of Drive, use:\n\nAs with exports to Drive, start the export from the Tasks tab. The Cloud Storage bucket location can affect performance and storage costs, see the FAQ entry on location considerations for more information.\n\nTo export an image to an asset in your Earth Engine assets folder, use . To manage your Earth Engine assets, or check how much of your storage quota is in use, use the Asset Manager. The following example illustrates exporting portions of a Landsat image using different pyramiding policies for the same band. The pyramiding policy indicates how Earth Engine computes lower-resolution versions of the asset. Learn more about how Earth Engine handles multiple resolutions in the scale doc.\n\nYou can provide a default pyramiding policy for every band that isn't explicitly specified by using the key. You may also pass in just the key. For example, to make all bands default to the 'sample' pyramiding policy, use .\n\nObserve that the dictionary of configuration parameters passed to includes (in meters) and the export region as an . The exported image will cover the specified region with pixels at the specified scale. If not explicitly specified, the CRS of the output will be taken from the first band of the image to be exported.\n\nYou may also specify the , and/or of the exported image. See the glossary for more information on and . For example, to get a block of pixels precisely aligned to another data source, specify , and . To get a block of pixels of predefined size (for example a 256x256 thumbnail image) that covers a region, specify and .\n\nYou can specify image output format (if the destination is not ) with the parameter ( by default).\n\nOther configuration options are set with the parameter, which should be a dictionary keyed by other format options, specific to each as described below.\n\nTo export a cloud optimized GeoTIFF, pass a JavaScript literal for in which the key is set to true. Continuing the previous example:\n\nCloud optimized GeoTIFFs can be reloaded from Cloud Storage into an . See the overview docs for details.\n\nSpecify the GeoTIFF nodata value using the key within the parameter. For example:\n\nNote that the nodata value should be inside the valid range for the image's . You can check by printing image metadata and looking at the first band's property. You can also set the image's by casting the data to a specific type using image methods or , for example.\n\nThe parameter is intended to prevent very large exports from inadvertently being created. If the default value is too low for your intended output image, you can increase . For example:\n\nIf the output image is large, it will be exported as multiple files. If you are exporting to GeoTIFF(s), the image is split into tiles. The filename of each tile will be in the form where and are the coordinates of each tile within the overall bounding box of the exported image.\n\nIf you are exporting to TFRecord, the files will be appended by , ,... for N+1 files. Maintaining this order is important if you intend to perform inference on the files and upload the predictions back to Earth Engine as an image. See uploading images as TFRecord files for details.\n\nExporting images as they appear in the Code Editor\n\nTo export imagery as rendered on screen in Earth Engine, create visualization images as demonstrated in the Visualization images and the Compositing and Mosaicking sections. Since the Code Editor uses the CRS, specify a CRS of in the export to get an image in the same projection as that displayed in the Code Editor map. See the section on configuring image exports for details on specifying the resolution and coordinate system of the output."
    },
    {
        "link": "https://medium.com/@zrowland/exporting-images-and-imagecollections-from-google-earth-engine-to-your-local-machine-412a51d05283",
        "document": "This article was updated on 28/01/2023 to reflect changes in some UIs and libraries used.\n\nGoogle Earth Engine (GEE) is a platform for accessing and analysing remote sensing data of the Earth. In most cases it is sufficient to work with this data using GEE’s JavaScript Code Editor or Python API. However it is often also useful to export this data for further analysis outside of the GEE environment or for local storage.\n\nThere is no way to directly export data from Google Earth Engine to your local machine, however it is possible indirectly using Google Drive storage as an intermediate step. This is explained below.\n\nThis guide makes use of the following libraries:\n• geetools-code-editor: For bulk exporting Images in Image Collections using the Code Editor.\n• geetools: For bulk exporting Images in Image Collections using the Python API.\n• PyDrive2: For downloading the exported GeoTiff files from Google Drive. oauth2client is also required for authenticating with PyDrive2.\n\nAll the code examples in this guide can be accessed on GitHub here.\n\nExporting data from the JavaScript Code Editor is straightforward, as can be seen in the examples here. Images can be only be exported directly to Google Drive, Google Cloud Storage or to your Earth Engine Assets folder within the Code Editor. For Google Drive, GEE will export to the Drive of the account you used to authenticate to the Code Editor. For example:\n\nNote that in this case the buffer size of the ROI determines the dimensions of the exported image (check the docs).\n\nAfter running the above in the Code Editor, the export task can be executed in the Tasks pane. The details of the task can also be edited in the GUI before running.\n\nAfter the task has completed, you will be able to access the image in the specified folder of your Google Drive.\n\nBulk exporting ImageCollections using the JavaScript Code Editor and geetools\n\nThere is no built-in function for bulk exporting all the images in an ImageCollection from GEE to Google Drive or elsewhere. There is, however, a helpful collection of scripts created by Rodrigo E. Principe called geetools available in JavaScript (for the Code Editor) and Python (for the Python API).\n\nUsing the JavaScript version of this tool (geetools-code-editor) and the code below, all images in the ImageCollection above can be exported to Google Drive in bulk:\n\nAn individual task for each Image export will then be generated in the Tasks pane, which can be run as before to export each image to Google Drive.\n\nExporting data using the Python API follows a similar process, however it is now necessary to authenticate with a Google Cloud Project when using the Python API. This can be done in two ways, as follows.\n\nThe first way is to run the following code and authenticate via the GUI as instructed. You can create the Google Cloud Project as part of the authentication process when running the code below, or follow the guidance here.\n\nHowever this requires you to re-authenticate each time which can be tedious. It also only works in .ipynb, which makes it impractical for some applications. Fortunately there is a way to authenticate without the GUI that only requires some additional setup.\n\nFirst, go to the Google Earth Engine API for Google Cloud here: https://console.cloud.google.com/apis/library/earthengine.googleapis.com\n\nMake sure the correct project is selected at the top and click ENABLE to enable the API on your project. If you created the Project through the authentication flow in the code above it may already be enabled.\n\nOnce the API has been enabled a Service Account must be created to authenticate to the project.\n\nGo to https://console.cloud.google.com/iam-admin/serviceaccounts, select the correct Project if prompted, and click ‘+ CREATE SERVICE ACCOUNT’ to add a Service Account to the Project.\n\nGive the Service Account the Editor Role in ‘Grant this service account access to the project’ and click DONE.\n\nOnce the Service Account has been created, click the menu ( ⋮ ) and open Manage keys to create a private key for the account. Click ADD KEY > Create new key > JSON. This will download the Service Account key locally for use when authenticating the Python API.\n\nNow that you have your Service Account key, rename it and move it to the same directory as your script.\n\nFinally, register the Service Account to use Earth Engine at: https://signup.earthengine.google.com/#!/service_accounts\n\nUse the following code to authenticate, where is the email address of your Service Account (this can be found in the GCP Console, or under in ).\n\nAll done! Now you can use your Service Account or the GUI to authenticate with the Python API.\n\nNote: be careful who has access to your Service Account key! Follow Google’s guidance under ‘Keep your key file safe’ here.\n\nExporting data using the Python API is very similar to using the JavaScript API, as the libraries have a very similar syntax (with the exception of the inherent differences between JavaScript and Python).\n\nRun the following code to export an Image to your Google Drive (or the Google Drive of your Service Account - more on that in the last section).\n\nBulk exporting ImageCollections using the Python API and geetools\n\nAs mentioned in the Code Editor section above, there is a Python version of the geetools library that can be used to bulk export Images from an ImageCollection to Google Drive, Google Cloud Storage or to your Earth Engine Assets. This can be done by first installing the library:\n\nThen run the following code to batch export:\n\nNow that the images have been exported to Google Drive, the PyDrive2 library can be used to automate downloading the files to a local directory. This is particularly necessary when the images are saved to the Service Account Google Drive, which cannot be easily accessed otherwise, or when integrating export of GEE images into an application.\n\nTo authenticate to the Google Drive of the Service Account, it is first necessary to enable the Google Drive API for the Google Cloud Project. This can be done at the following link (make sure the correct project is selected): https://console.cloud.google.com/apis/library/drive.googleapis.com\n\nThen authentication with the following code, using the same previously downloaded for authenticating GEE:\n\nNote: The oauth2client library has now been depreciated in favour of google-auth (and oauthlib), however I have been unable to use these new library with PyDrive2 without generating an error and it does not seem to be supported. If you are aware of a way to use google-auth with PyDrive2 please let me know and I will update this article.\n\nOnce authenticated, the following code can be used to get the id of the ‘gee_images’ subfolder (this step can be skipped if the images were saved in the root directory of Google Drive):\n\nFinally, running the code below downloads the GeoTiffs to the local directory:\n\nBy following the steps above you will be able to export Images and ImageCollections from Google Earth Engine via the Code Editor or Python API to either your personal Google Drive or the Google Drive of a GCP Service Account, and then download those images to a local directory.\n\nAs written in the introduction, all the code in this article can be found on GitHub here."
    },
    {
        "link": "https://gis.stackexchange.com/questions/488962/exporting-the-results-to-drive-using-the-export-function-in-gee-app",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://stackoverflow.com/questions/75822877/exporting-tif-images-from-google-earth-engine-to-google-drive-minimal-example-i",
        "document": "I thought exporting images from GEE should be quite straightforward, turns out I am facing difficulties, and I'm not satisfied with the answers given so far on this platform.\n\nAs a minimal example, I want to extract nightlights images at original scale for South Africa:\n\nThis code runs perfectly, but in my drive I get something very odd:\n\nIn particular: why are there different versions of the same image (the constructed names are all unique, as evident from the printout), and what are these numbers appended to the file name?"
    }
]