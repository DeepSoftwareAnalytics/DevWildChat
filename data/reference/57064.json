[
    {
        "link": "https://geeksforgeeks.org/reading-writing-text-files-python",
        "document": "Python provides built-in functions for creating, writing, and reading files. Two types of files can be handled in Python, normal text files and binary files (written in binary language, 0s, and 1s).\n• Text files: In this type of file, Each line of text is terminated with a special character called EOL (End of Line), which is the new line character (‘\n\n’) in Python by default.\n• Binary files: In this type of file, there is no terminator for a line, and the data is stored after converting it into machine-understandable binary language.\n\nThis article will focus on opening, closing, reading, and writing data in a text file. Here, we will also see how to get Python output in a text file.\n\nIt is done using the open() function. No module is required to be imported for this function.\n\nExample: Here, file1 is created as an object for MyFile1 and file2 as object for MyFile2.\n\nThere are three ways to read txt file in Python:\n\nread(): Returns the read bytes in form of a string. Reads n bytes, if no n specified, reads the entire file.\n\nreadline(): Reads a line of the file and returns in form of a string.For specified n, reads at most n bytes. However, does not reads more than one line, even if n exceeds the length of the line.\n\nreadlines(): Reads all the lines and return them as each line a string element in a list.\n\nNote: ‘\n\n’ is treated as a special character of two bytes.\n\nIn this example, a file named “myfile.txt” is created and opened in write mode ( ). Data is written to the file using and methods. The file is then reopened in read and append mode ( ). Various read operations, including , , , and the use of , demonstrate different ways to retrieve data from the file. Finally, the file is closed.\n\nThere are two ways to write in a file:\n\nwrite(): Inserts the string str1 in a single line in the text file.\n\nwritelines(): For a list of string elements, each string is inserted in the text file.Used to insert multiple strings at a single time.\n\nIn this example, a file named “myfile.txt” is initially opened in write mode ( ) to write lines of text. The file is then reopened in append mode ( ), and “Today” is added to the existing content. The output after appending is displayed using . Subsequently, the file is reopened in write mode, overwriting the content with “Tomorrow”. The final output after writing is displayed using\n\nPython close() function closes the file and frees the memory space acquired by that file. It is used at the time when the file is no longer needed or if it is to be opened in a different file mode. File_object.close()\n\nReading and Writing to text files in Python – FAQs\n\nAccess modes govern the type of operations possible in the opened file. It refers to how the file will be used once it’s opened. These modes also define the location of the File Handle in the file. The file handle is like a cursor, which defines from where the data has to be read or written in the file and we can get Python output in text file. There are 6 access modes in Python:\n• Read Only (‘r’): Open text file for reading. The handle is positioned at the beginning of the file. If the file does not exist, raises the I/O error. This is also the default mode in which a file is opened.\n• Read and Write (‘r+’): Open the file for reading and writing. The handle is positioned at the beginning of the file. Raises I/O error if the file does not exist.\n• Write Only (‘w’): Open the file for writing. For the existing files, the data is truncated and over-written. The handle is positioned at the beginning of the file. Creates the file if the file does not exist.\n• Write and Read (‘w+’) : Open the file for reading and writing. For an existing file, data is truncated and over-written. The handle is positioned at the beginning of the file.\n• Append Only (‘a’) : Open the file for writing. The file is created if it does not exist. The handle is positioned at the end of the file. The data being written will be inserted at the end, after the existing data.\n• Append and Read (‘a+’): Open the file for reading and writing. The file is created if it does not exist. The handle is positioned at the end of the file. The data being written will be inserted at the end, after the existing data.\n\nHow to read a file and write to another file in Python?\n\nHow Files are Loaded into Primary Memory?\n\nThere are two kinds of memory in a computer i.e. Primary and Secondary memory every file that you saved or anyone saved is on secondary memory causing any data in primary memory to be deleted when the computer is powered off. So when you need to change any text file or just to work with them in Python you need to load that file into primary memory. Python interacts with files loaded in primary memory or main memory through “file handlers” ( This is how your operating system gives access to Python to interact with the file you opened by searching the file in its memory if found it returns a file handler and then you can work with the file).\n\nWhat is the difference between reading and writing files in Python?\n\nWhich function is used to read data from a text file?"
    },
    {
        "link": "https://docs.python.org/3/tutorial/inputoutput.html",
        "document": "There are several ways to present the output of a program; data can be printed in a human-readable form, or written to a file for future use. This chapter will discuss some of the possibilities.\n\nSo far we’ve encountered two ways of writing values: expression statements and the function. (A third way is using the method of file objects; the standard output file can be referenced as . See the Library Reference for more information on this.) Often you’ll want more control over the formatting of your output than simply printing space-separated values. There are several ways to format output.\n• None To use formatted string literals, begin a string with or before the opening quotation mark or triple quotation mark. Inside this string, you can write a Python expression between and characters that can refer to variables or literal values.\n• None The method of strings requires more manual effort. You’ll still use and to mark where a variable will be substituted and can provide detailed formatting directives, but you’ll also need to provide the information to be formatted. In the following code block there are two examples of how to format variables: Notice how the are padded with spaces and a negative sign only for negative numbers. The example also prints multiplied by 100, with 2 decimal places and followed by a percent sign (see Format Specification Mini-Language for details).\n• None Finally, you can do all the string handling yourself by using string slicing and concatenation operations to create any layout you can imagine. The string type has some methods that perform useful operations for padding strings to a given column width. When you don’t need fancy output but just want a quick display of some variables for debugging purposes, you can convert any value to a string with the or functions. The function is meant to return representations of values which are fairly human-readable, while is meant to generate representations which can be read by the interpreter (or will force a if there is no equivalent syntax). For objects which don’t have a particular representation for human consumption, will return the same value as . Many values, such as numbers or structures like lists and dictionaries, have the same representation using either function. Strings, in particular, have two distinct representations. The value of x is 32.5, and y is 40000... # The repr() of a string adds string quotes and backslashes: # The argument to repr() may be any Python object: The module contains a class that offers yet another way to substitute values into strings, using placeholders like and replacing them with values from a dictionary, but offers much less control of the formatting. Formatted string literals (also called f-strings for short) let you include the value of Python expressions inside a string by prefixing the string with or and writing expressions as . An optional format specifier can follow the expression. This allows greater control over how the value is formatted. The following example rounds pi to three places after the decimal: 'The value of pi is approximately The value of pi is approximately 3.142. Passing an integer after the will cause that field to be a minimum number of characters wide. This is useful for making columns line up. Other modifiers can be used to convert the value before it is formatted. applies , applies , and applies : 'My hovercraft is full of My hovercraft is full of eels. 'My hovercraft is full of My hovercraft is full of 'eels'. The specifier can be used to expand an expression to the text of the expression, an equal sign, then the representation of the evaluated expression: See self-documenting expressions for more information on the specifier. For a reference on these format specifications, see the reference guide for the Format Specification Mini-Language. Basic usage of the method looks like this: We are the knights who say \"Ni!\" The brackets and characters within them (called format fields) are replaced with the objects passed into the method. A number in the brackets can be used to refer to the position of the object passed into the method. If keyword arguments are used in the method, their values are referred to by using the name of the argument. Positional and keyword arguments can be arbitrarily combined: The story of Bill, Manfred, and Georg. If you have a really long format string that you don’t want to split up, it would be nice if you could reference the variables to be formatted by name instead of by position. This can be done by simply passing the dict and using square brackets to access the keys. This could also be done by passing the dictionary as keyword arguments with the notation. This is particularly useful in combination with the built-in function , which returns a dictionary containing all local variables: __name__: __main__; __doc__: None; __package__: None; __loader__: ... As an example, the following lines produce a tidily aligned set of columns giving integers and their squares and cubes: For a complete overview of string formatting with , see Format String Syntax. Here’s the same table of squares and cubes, formatted manually: # Note use of 'end' on previous line The method of string objects right-justifies a string in a field of a given width by padding it with spaces on the left. There are similar methods and . These methods do not write anything, they just return a new string. If the input string is too long, they don’t truncate it, but return it unchanged; this will mess up your column lay-out but that’s usually better than the alternative, which would be lying about a value. (If you really want truncation you can always add a slice operation, as in .) There is another method, , which pads a numeric string on the left with zeros. It understands about plus and minus signs: The % operator (modulo) can also be used for string formatting. Given (where format is a string), conversion specifications in format are replaced with zero or more elements of values. This operation is commonly known as string interpolation. For example: 'The value of pi is approximately The value of pi is approximately 3.142. More information can be found in the printf-style String Formatting section.\n\nreturns a file object, and is most commonly used with two positional arguments and one keyword argument: The first argument is a string containing the filename. The second argument is another string containing a few characters describing the way in which the file will be used. mode can be when the file will only be read, for only writing (an existing file with the same name will be erased), and opens the file for appending; any data written to the file is automatically added to the end. opens the file for both reading and writing. The mode argument is optional; will be assumed if it’s omitted. Normally, files are opened in text mode, that means, you read and write strings from and to the file, which are encoded in a specific encoding. If encoding is not specified, the default is platform dependent (see ). Because UTF-8 is the modern de-facto standard, is recommended unless you know that you need to use a different encoding. Appending a to the mode opens the file in binary mode. Binary mode data is read and written as objects. You can not specify encoding when opening file in binary mode. In text mode, the default when reading is to convert platform-specific line endings ( on Unix, on Windows) to just . When writing in text mode, the default is to convert occurrences of back to platform-specific line endings. This behind-the-scenes modification to file data is fine for text files, but will corrupt binary data like that in or files. Be very careful to use binary mode when reading and writing such files. It is good practice to use the keyword when dealing with file objects. The advantage is that the file is properly closed after its suite finishes, even if an exception is raised at some point. Using is also much shorter than writing equivalent - blocks: # We can check that the file has been automatically closed. If you’re not using the keyword, then you should call to close the file and immediately free up any system resources used by it. Calling without using the keyword or calling might result in the arguments of not being completely written to the disk, even if the program exits successfully. After a file object is closed, either by a statement or by calling , attempts to use the file object will automatically fail. The rest of the examples in this section will assume that a file object called has already been created. To read a file’s contents, call , which reads some quantity of data and returns it as a string (in text mode) or bytes object (in binary mode). size is an optional numeric argument. When size is omitted or negative, the entire contents of the file will be read and returned; it’s your problem if the file is twice as large as your machine’s memory. Otherwise, at most size characters (in text mode) or size bytes (in binary mode) are read and returned. If the end of the file has been reached, will return an empty string ( ). 'This is the entire file.\n\n' reads a single line from the file; a newline character ( ) is left at the end of the string, and is only omitted on the last line of the file if the file doesn’t end in a newline. This makes the return value unambiguous; if returns an empty string, the end of the file has been reached, while a blank line is represented by , a string containing only a single newline. 'This is the first line of the file.\n\n' 'Second line of the file\n\n' For reading lines from a file, you can loop over the file object. This is memory efficient, fast, and leads to simple code: This is the first line of the file. If you want to read all the lines of a file in a list you can also use or . writes the contents of string to the file, returning the number of characters written. Other types of objects need to be converted – either to a string (in text mode) or a bytes object (in binary mode) – before writing them: returns an integer giving the file object’s current position in the file represented as number of bytes from the beginning of the file when in binary mode and an opaque number when in text mode. To change the file object’s position, use . The position is computed from adding offset to a reference point; the reference point is selected by the whence argument. A whence value of 0 measures from the beginning of the file, 1 uses the current file position, and 2 uses the end of the file as the reference point. whence can be omitted and defaults to 0, using the beginning of the file as the reference point. # Go to the 6th byte in the file # Go to the 3rd byte before the end In text files (those opened without a in the mode string), only seeks relative to the beginning of the file are allowed (the exception being seeking to the very file end with ) and the only valid offset values are those returned from the , or zero. Any other offset value produces undefined behaviour. File objects have some additional methods, such as and which are less frequently used; consult the Library Reference for a complete guide to file objects. Strings can easily be written to and read from a file. Numbers take a bit more effort, since the method only returns strings, which will have to be passed to a function like , which takes a string like and returns its numeric value 123. When you want to save more complex data types like nested lists and dictionaries, parsing and serializing by hand becomes complicated. Rather than having users constantly writing and debugging code to save complicated data types to files, Python allows you to use the popular data interchange format called JSON (JavaScript Object Notation). The standard module called can take Python data hierarchies, and convert them to string representations; this process is called serializing. Reconstructing the data from the string representation is called deserializing. Between serializing and deserializing, the string representing the object may have been stored in a file or data, or sent over a network connection to some distant machine. The JSON format is commonly used by modern applications to allow for data exchange. Many programmers are already familiar with it, which makes it a good choice for interoperability. If you have an object , you can view its JSON string representation with a simple line of code: Another variant of the function, called , simply serializes the object to a text file. So if is a text file object opened for writing, we can do this: To decode the object again, if is a binary file or text file object which has been opened for reading: JSON files must be encoded in UTF-8. Use when opening JSON file as a text file for both of reading and writing. This simple serialization technique can handle lists and dictionaries, but serializing arbitrary class instances in JSON requires a bit of extra effort. The reference for the module contains an explanation of this. Contrary to JSON, pickle is a protocol which allows the serialization of arbitrarily complex Python objects. As such, it is specific to Python and cannot be used to communicate with applications written in other languages. It is also insecure by default: deserializing pickle data coming from an untrusted source can execute arbitrary code, if the data was crafted by a skilled attacker."
    },
    {
        "link": "https://geeksforgeeks.org/file-handling-python",
        "document": "File handling refers to the process of performing operations on a file such as creating, opening, reading, writing and closing it, through a programming interface. It involves managing the data flow between the program and the file system on the storage device, ensuring that data is handled safely and efficiently.\n\nTo open a file we can use function, which requires file path and mode as arguments:\n\nWhen opening a file, we must specify the mode we want to which specifies what we want to do with the file. Here’s a table of the different modes available:\n\nOpens the file for reading. File must exist; otherwise, it raises an error. Opens the file for reading binary data. File must exist; otherwise, it raises an error. Opens the file for both reading and writing. File must exist; otherwise, it raises an error. Opens the file for both reading and writing binary data. File must exist; otherwise, it raises an error. Opens the file for writing. Creates a new file or truncates the existing file. Opens the file for writing binary data. Creates a new file or truncates the existing file. Opens the file for both writing and reading. Creates a new file or truncates the existing file. Opens the file for both writing and reading binary data. Creates a new file or truncates the existing file. Opens the file for appending data. Creates a new file if it doesn’t exist. Opens the file for appending binary data. Creates a new file if it doesn’t exist. Opens the file for appending and reading. Creates a new file if it doesn’t exist. Opens the file for appending and reading binary data. Creates a new file if it doesn’t exist. Creates a new file. Raises an error if the file already exists. Creates a new binary file. Raises an error if the file already exists. Creates a new file for reading and writing. Raises an error if the file exists. Exclusive creation with read and write in binary mode. Creates a new binary file for reading and writing. Raises an error if the file exists.\n\nFor this article we are using text file with text:\n\nReading a file can be achieved by file.read() which reads the entire content of the file. After reading the file we can close the file using file.close() which closes the file after reading it, which is necessary to free up system resources.\n\nWriting to a file is done using file.write() which writes the specified string to the file. If the file exists, its content is erased. If it doesn’t exist, a new file is created.\n\nExample: Writing to a File in Write Mode (w)\n\nIt is done using adds the specified string to the end of the file without erasing its existing content.\n\nExample: For this example, we will use the Python file created in the previous example.\n\nClosing a file is essential to ensure that all resources used by the file are properly released. loses the file and ensures that any changes made to the file are saved.\n\nstatement is used for resource management. It ensures that file is properly closed after its suite finishes, even if an exception is raised. with open() as method automatically handles closing the file once the block of code is exited, even if an error occurs. This reduces the risk of file corruption and resource leakage.\n\nIt’s important to handle exceptions to ensure that files are closed properly, even if an error occurs during file operations.\n• None Versatility : File handling in Python allows us to perform a wide range of operations, such as creating, reading, writing, appending, renaming and deleting files.\n• Flexibility : File handling in Python is highly flexible, as it allows us to work with different file types (e.g. text files, binary files, CSV files , etc.) and to perform different operations on files (e.g. read, write, append, etc.).\n• User – friendly : Python provides a user-friendly interface for file handling, making it easy to create, read and manipulate files.\n• Cross-platform : Python file-handling functions work across different platforms (e.g. Windows, Mac, Linux), allowing for seamless integration and compatibility.\n• Error-prone: File handling operations in Python can be prone to errors, especially if the code is not carefully written or if there are issues with the file system (e.g. file permissions, file locks, etc.).\n• Security risks : File handling in Python can also pose security risks, especially if the program accepts user input that can be used to access or modify sensitive files on the system.\n• Complexity : File handling in Python can be complex, especially when working with more advanced file formats or operations. Careful attention must be paid to the code to ensure that files are handled properly and securely.\n• Performance : File handling operations in Python can be slower than other programming languages, especially when dealing with large files or performing complex operations.\n\nWhat are the types of files in Python?\n\nWhat are the 4 file handling functions?\n\nWhy is file handling useful?\n\nIn Python file handling, is a method of file objects that returns the current position of the file pointer (cursor) within the file. It returns an integer representing the byte offset from the beginning of the file where the next read or write operation will occur. # Open a file in read mode file = open('example.txt', 'r') # Read the first 10 characters content = file.read(10) print(content) # Check the current position of the file pointer position = file.tell() print(\"Current position:\", position) # Close the file file.close()\n• None reads the first 10 characters from the file.\n• None returns the current position of the file pointer after reading."
    },
    {
        "link": "https://freecodecamp.org/news/with-open-in-python-with-statement-syntax-example",
        "document": "The Python programming language has various functions and statements for working with a file. The statement and function are two of those statements and functions.\n\nIn this article, you will learn how to use both the statement and function to work with files in Python.\n\nWhat Does Do in Python?\n\nTo work with files in Python, you have to open the file first. So, the function does what the name implies – it opens a file for you so you can work with the file.\n\nTo use the open function, you declare a variable for it first. The function takes up to 3 parameters – the filename, the mode, and the encoding. You can then specify what you want to do with the file in a print function.\n\nThat’s not all. The function does not close the file, so you also have to close the file with the method.\n\nSo, a proper way to use the open function looks like this:\n\nThe read mode is the default file mode in Python, so if you don’t specify the mode, the code above still works fine:\n\nHow Does the Statement Work in Python?\n\nThe statement works with the function to open a file.\n\nSo, you can re-write the code we used in the function example like this:\n\nUnlike where you have to close the file with the method, the statement closes the file for you without you telling it to.\n\nThis is because the statement calls 2 built-in methods behind the scene – and .\n\nThe method closes the file when the operation you specify is done.\n\nWith the method, you also write to the file as I did below:\n\nYou can also loop through the file and print the text line by line:\n\nYou might be wondering which way you should use to work with files between the combo of and and just the function.\n\nI would advise you to use the combination of and because the statement closes the file for you and you get to write less code."
    },
    {
        "link": "https://realpython.com/read-write-files-python",
        "document": "One of the most common tasks that you can do with Python is reading and writing files. Whether it’s writing to a simple text file, reading a complicated server log, or even analyzing raw byte data, all of these situations require reading or writing a file.\n• What makes up a file and why that’s important in Python\n• The basics of reading and writing files in Python\n• Some basic scenarios of reading and writing files\n\nThis tutorial is mainly for beginner to intermediate Pythonistas, but there are some tips in here that more advanced programmers may appreciate as well.\n\nBefore we can go into how to work with files in Python, it’s important to understand what exactly a file is and how modern operating systems handle some of their aspects. At its core, a file is a contiguous set of bytes used to store data. This data is organized in a specific format and can be anything as simple as a text file or as complicated as a program executable. In the end, these byte files are then translated into binary and for easier processing by the computer. Files on most modern file systems are composed of three main parts:\n• Header: metadata about the contents of the file (file name, size, type, and so on)\n• Data: contents of the file as written by the creator or editor\n• End of file (EOF): special character that indicates the end of the file What this data represents depends on the format specification used, which is typically represented by an extension. For example, a file that has an extension of most likely conforms to the Graphics Interchange Format specification. There are hundreds, if not thousands, of file extensions out there. For this tutorial, you’ll only deal with or file extensions. When you access a file on an operating system, a file path is required. The file path is a string that represents the location of a file. It’s broken up into three major parts:\n• Folder Path: the file folder location on the file system where subsequent folders are separated by a forward slash (Unix) or backslash (Windows)\n• File Name: the actual name of the file\n• Extension: the end of the file path pre-pended with a period ( ) used to indicate the file type Here’s a quick example. Let’s say you have a file located within a file structure like this: Let’s say you wanted to access the file, and your current location was in the same folder as . In order to access the file, you need to go through the folder and then the folder, finally arriving at the file. The Folder Path is . The File Name is . The File Extension is . So the full path is . Now let’s say that your current location or current working directory (cwd) is in the folder of our example folder structure. Instead of referring to the by the full path of , the file can be simply referenced by the file name and extension . / │ ├── path/ | │ | ├── to/ ← Your current working directory (cwd) is here | │ └── cats.gif ← Accessing this file | │ | └── dog_breeds.txt | └── animals.csv But what about ? How would you access that without using the full path? You can use the special characters double-dot ( ) to move one directory up. This means that will reference the file from the directory of : / │ ├── path/ ← Referencing this parent folder | │ | ├── to/ ← Current working directory (cwd) | │ └── cats.gif | │ | └── dog_breeds.txt ← Accessing this file | └── animals.csv The double-dot ( ) can be chained together to traverse multiple directories above the current directory. For example, to access from the folder, you would use . One problem often encountered when working with file data is the representation of a new line or line ending. The line ending has its roots from back in the Morse Code era, when a specific pro-sign was used to communicate the end of a transmission or the end of a line. Later, this was standardized for teleprinters by both the International Organization for Standardization (ISO) and the American Standards Association (ASA). ASA standard states that line endings should use the sequence of the Carriage Return ( or ) and the Line Feed ( or ) characters ( or ). The ISO standard however allowed for either the characters or just the character. Windows uses the characters to indicate a new line, while Unix and the newer Mac versions use just the character. This can cause some complications when you’re processing files on an operating system that is different than the file’s source. Here’s a quick example. Let’s say that we examine the file that was created on a Windows system: This same output will be interpreted on a Unix device differently: This can make iterating over each line problematic, and you may need to account for situations like this. Another common problem that you may face is the encoding of the byte data. An encoding is a translation from byte data to human readable characters. This is typically done by assigning a numerical value to represent a character. The two most common encodings are the ASCII and UNICODE Formats. ASCII can only store 128 characters, while Unicode can contain up to 1,114,112 characters. ASCII is actually a subset of Unicode (UTF-8), meaning that ASCII and Unicode share the same numerical to character values. It’s important to note that parsing a file with the incorrect character encoding can lead to failures or misrepresentation of the character. For example, if a file was created using the UTF-8 encoding, and you try to parse it using the ASCII encoding, if there is a character that is outside of those 128 values, then an error will be thrown.\n\nWhen you want to work with a file, the first thing to do is to open it. This is done by invoking the built-in function. has a single required argument that is the path to the file. has a single return, the file object: After you open a file, the next thing to learn is how to close it. Warning: You should always make sure that an open file is properly closed. To learn why, check out the Why Is It Important to Close Files in Python? tutorial. It’s important to remember that it’s your responsibility to close the file. In most cases, upon termination of an application or script, a file will be closed eventually. However, there is no guarantee when exactly that will happen. This can lead to unwanted behavior including resource leaks. It’s also a best practice within Python (Pythonic) to make sure that your code behaves in a way that is well defined and reduces any unwanted behavior. When you’re manipulating a file, there are two ways that you can use to ensure that a file is closed properly, even when encountering an error. The first way to close a file is to use the block: # Further file processing goes here If you’re unfamiliar with what the block is, check out Python Exceptions: An Introduction. The second way to close a file is to use the statement: # Further file processing goes here The statement automatically takes care of closing the file once it leaves the block, even in cases of error. I highly recommend that you use the statement as much as possible, as it allows for cleaner code and makes handling any unexpected errors easier for you. Most likely, you’ll also want to use the second positional argument, . This argument is a string that contains multiple characters to represent how you want to open the file. The default and most common is , which represents opening the file in read-only mode as a text file: # Further file processing goes here Other options for modes are fully documented online, but the most commonly used ones are the following: Open for writing, truncating (overwriting) the file first Let’s go back and talk a little about file objects. A file object is: “an object exposing a file-oriented API (with methods such as or ) to an underlying resource.” (Source) There are three different categories of file objects: Each of these file types are defined in the module. Here’s a quick rundown of how everything lines up. A text file is the most common file that you’ll encounter. Here are some examples of how these files are opened: With these types of files, will return a file object: This is the default file object returned by . A buffered binary file type is used for reading and writing binary files. Here are some examples of how these files are opened: With these types of files, will return either a or file object: “generally used as a low-level building-block for binary and text streams.” (Source) It is therefore not typically used. Here’s an example of how these files are opened: With these types of files, will return a file object:\n\nOnce you’ve opened up a file, you’ll want to read or write to the file. First off, let’s cover reading a file. There are multiple methods that can be called on a file object to help you out: What It Does This reads from the file based on the number of bytes. If no argument is passed or or is passed, then the entire file is read. This reads at most number of characters from the line. This continues to the end of the line and then wraps back around. If no argument is passed or or is passed, then the entire line (or rest of the line) is read. This reads the remaining lines from the file object and returns them as a list. Using the same file you used above, let’s go through some examples of how to use these methods. Here’s an example of how to open and read the entire file using : Here’s an example of how to read 5 bytes of a line each time using the Python method: # Read & print the first 5 characters of the line 5 times # Notice that line is greater than the 5 chars and continues # down the line, reading 5 chars each time until the end of the # line and then \"wraps\" around Here’s an example of how to read the entire file as a list using the Python method: The above example can also be done by using to create a list out of the file object: Iterating Over Each Line in the File A common thing to do while reading a file is to iterate over each line. Here’s an example of how to use the Python method to perform that iteration: # Read and print the entire file line by line # The EOF char is an empty string Another way you could iterate over each line in the file is to use the Python method of the file object. Remember, returns a list where each element in the list represents a line in the file: However, the above examples can be further simplified by iterating over the file object itself: # Read and print the entire file line by line This final approach is more Pythonic and can be quicker and more memory efficient. Therefore, it is suggested you use this instead. Note: Some of the above examples contain . The is to prevent Python from adding an additional newline to the text that is being printed and only print what is being read from the file. Now let’s dive into writing files. As with reading files, file objects have multiple methods that are useful for writing to a file: What It Does This writes the string to the file. This writes the sequence to the file. No line endings are appended to each sequence item. It’s up to you to add the appropriate line ending(s). Here’s a quick example of using and : # Alternatively you could use # Write the dog breeds to the file in reversed order Sometimes, you may need to work with files using byte strings. This is done by adding the character to the argument. All of the same methods for the file object apply. However, each of the methods expect and return a object instead: Opening a text file using the flag isn’t that interesting. Let’s say we have this cute picture of a Jack Russell Terrier ( ): You can actually open that file in Python and examine the contents! Since the file format is well defined, the header of the file is 8 bytes broken up like this: A “magic” number to indicate that this is the start of a Sure enough, when you open the file and read these bytes individually, you can see that this is indeed a header file: Let’s bring this whole thing home and look at a full example of how to read and write to a file. The following is a like tool that will convert a file that contains line endings of to . This tool is broken up into three major sections. The first is , which converts a string from line endings to . The second is , which converts a string that contains characters into . calls internally. Finally, there’s the block, which is called only when the file is executed as a script. Think of it as the function found in other programming languages. A simple script and library to convert files or strings from dos like Converts the string from \\r\n\n line endings to \n\n The string whose line endings will be converted Converts a file that contains Dos like line endings into Unix like The path to the source file to be converted The path to the converted file for output # Create our Argument parser and set its description \"Script that converts a DOS like file to an Unix like file\" # - source_file: the source file we want to convert # - dest_file: the destination where the output should go # Note: the use of the argument type of argparse.FileType could 'The location of the source ' # Parse the args (argparse automatically grabs the values from # If the destination file wasn't passed, then assume we want to # create a new file based on the old one\n\nNow that you’ve mastered the basics of reading and writing files, here are some tips and tricks to help you grow your skills. The attribute is a special attribute of modules, similar to . It is: “the pathname of the file from which the module was loaded, if it was loaded from a file.” (Source Note: To re-iterate, returns the path relative to where the initial Python script was called. If you need the full system path, you can use to get the current working directory of your executing code. Here’s a real world example. In one of my past jobs, I did multiple tests for a hardware device. Each test was written using a Python script with the test script file name used as a title. These scripts would then be executed and could print their status using the special attribute. Here’s an example folder structure: I was able to run and get the status of all my tests dynamically through use of the special attribute. Sometimes, you may want to append to a file or start writing at the end of an already populated file. This is easily done by using the character for the argument: When you examine again, you’ll see that the beginning of the file is unchanged and is now added to the end of the file: Working With Two Files at the Same Time There are times when you may want to read a file and write to another file at the same time. If you use the example that was shown when you were learning how to write to a file, it can actually be combined into the following: There may come a time when you’ll need finer control of the file object by placing it inside a custom class. When you do this, using the statement can no longer be used unless you add a few magic methods: and . By adding these, you’ll have created what’s called a context manager. is invoked when calling the statement. is called upon exiting from the statement block. Here’s a template that you can use to make your custom class: Now that you’ve got your custom class that is now a context manager, you can use it similarly to the built-in: Here’s a good example. Remember the cute Jack Russell image we had? Perhaps you want to open other files but don’t want to parse the header file each time. Here’s an example of how to do this. This example also uses custom iterators. If you’re not familiar with them, check out Python Iterators: # Every .png file contains this in the header. Use it to verify # the file is indeed a .png. # Ensure the file has the right extension \"The File is not a properly formatted .png file!\" # This and __next__() are used to create a custom iterator # The file hasn't been opened or reached EOF. This means we # can't go any further so stop the iteration by raising the # Each chunk has a len, type, data (based on len) and crc # Grab these values and return them as a tuple You can now open files and properly parse them using your custom context manager:"
    },
    {
        "link": "https://realpython.com/sort-python-dictionary",
        "document": "Sorting a Python dictionary involves organizing its key-value pairs in a specific order. To sort a Python dictionary by its keys, you use the function combined with . This approach returns a list of tuples sorted by keys, which you can convert back to a dictionary using the constructor. Sorting by values requires specifying a sort key using a lambda function or .\n\nBy the end of this tutorial, you’ll understand that:\n• You can sort a dictionary by its keys using with and .\n• To sort by values, you use with a key function like or .\n• Sorting in descending order is possible by setting in .\n• For non-comparable keys or values, you use default values or custom sort keys.\n• Python dictionaries can’t be sorted in-place, so you need to create a new sorted dictionary.\n\nRead on to learn how to effectively sort dictionaries using these techniques and the strategic implications of choosing the right data structure for your key-value data. But first, you’ll learn some foundational knowledge that will help you understand how to sort a dictionary in Python.\n\nBefore Python 3.6, dictionaries were inherently unordered. A Python dictionary is an implementation of the hash table, which is traditionally an unordered data structure. As a side effect of the compact dictionary implementation in Python 3.6, dictionaries started to conserve insertion order. From 3.7, that insertion order has been guaranteed. If you wanted to keep an ordered dictionary as a data structure before compact dictionaries, then you could use from the module. Similar to the modern compact dictionary, it also keeps insertion order, but neither type of dictionary sorts itself. Another alternative for storing an ordered key-value pair data is to store the pairs as a list of tuples. As you’ll see later in the tutorial, using a list of tuples could be the best choice for your data. An essential point to understand when sorting dictionaries is that even though they conserve insertion order, they’re not considered a sequence. A dictionary is like a set of key-value pairs, and sets are unordered. Dictionaries also don’t have much reordering functionality. They’re not like lists, where you can insert elements at any position. In the next section, you’ll explore the consequences of this limitation further.\n\nBecause dictionaries don’t have much reordering functionality, when sorting a dictionary, it’s rarely done in-place. In fact, there are no methods for explicitly moving items in a dictionary. If you wanted to sort a dictionary in-place, then you’d have to use the keyword to delete an item from the dictionary and then add it again. Deleting and then adding again effectively moves the key-value pair to the end. The class has a specific method to move an item to the end or the start, which may make preferable for keeping a sorted dictionary. However, it’s still not very common and isn’t very performant, to say the least. The typical method for sorting dictionaries is to get a dictionary view, sort it, and then cast the resulting list back into a dictionary. So you effectively go from a dictionary to a list and back into a dictionary. Depending on your use case, you may not need to convert the list back into a dictionary. Note: Sorted dictionaries aren’t a very common pattern. You’ll explore more about that topic later in the tutorial. With those preliminaries out of the way, you’ll get to sorting dictionaries in the next section.\n\nIn this section, you’ll be putting together the components of sorting a dictionary so that, in the end, you can master the most common way of sorting a dictionary: Don’t worry if you don’t understand the snippets above—you’ll review it all step-by-step in the following sections. Along the way, you’ll learn how to use the function with sort keys, functions, and dictionary constructors. The critical function that you’ll use to sort dictionaries is the built-in function. This function takes an iterable as the main argument, with two optional keyword-only arguments—a function and a Boolean value. To illustrate the function’s behavior in isolation, examine its use on a list of numbers: As you can see, the function takes an iterable, sorts comparable elements like numbers in ascending order, and returns a new list. With strings, it sorts them in alphabetical order: Sorting by numerical or alphabetical precedence is the most common way to sort elements, but maybe you need more control. Say you want to sort on the second character of each word in the last example. To customize what the function uses to sort the elements, you can pass in a callback function to the parameter. A callback function is a function that’s passed as an argument to another function. For , you pass it a function that acts as a sort key. The function will then call back the sort key for every element. In the following example, the function passed as the key accepts a string and will return the second character of that string: The function passes every element of the iterable to the function and uses the return value for comparison. Using the key means that the function will compare the second letter instead of comparing the whole string directly. More examples and explanations of the parameter will come later in the tutorial when you use it to sort dictionaries by values or nested elements. If you take another look at the results of this last sorting, you may notice the stability of the function. The three elements, , and , are equivalent when sorted by their second character. Because they’re equal, the function conserves their original order. Python guarantees this stability. Note: Every list also has a method, which has the same signature as the function. The main difference is that the method sorts the list in-place. In contrast, the function returns a new list, leaving the original list unmodified. You can also pass to the sorting function or method to return the reverse order. Alternatively, you can use the function to invert the iterable after sorting: If you want to dive deeper into the mechanics of sorting in Python and learn how to sort data types other than dictionaries, then check out the tutorial on how to use and So, how about dictionaries? You can actually take the dictionary and feed it straight into the function: But the default behavior of passing in a dictionary directly to the function is to take the keys of the dictionary, sort them, and return a list of the keys only. That’s probably not the behavior you had in mind! To preserve all the information in a dictionary, you’ll need to be acquainted with dictionary views. Getting Keys, Values, or Both From a Dictionary If you want to conserve all the information from a dictionary when sorting it, the typical first step is to call the method on the dictionary. Calling on the dictionary will provide an iterable of tuples representing the key-value pairs: The method returns a read-only dictionary view object, which serves as a window into the dictionary. This view is not a copy or a list—it’s a read-only iterable that’s actually linked to the dictionary it was generated from: You’ll notice that any updates to the dictionary also get reflected in the view because they’re linked. A view represents a lightweight way to iterate over a dictionary without generating a list first. Note: You can use to get a view of the values only and to get one with only the keys. Crucially, you can use the function with dictionary views. You call the method and use the result as an argument to the function. Using keeps all the information from the dictionary: This example results in a sorted list of tuples, with each tuple representing a key-value pair of the dictionary. If you want to end up with a dictionary sorted by values, then you’ve still got two issues. The default behavior still seems to sort by key and not value. The other issue is that you end up with a list of tuples, not a dictionary. First, you’ll figure out how to sort by value. When using the method on a dictionary and feeding it into the function, you’re passing in an iterable of tuples, and the function compares the entire tuple directly. When comparing tuples, Python behaves a lot like it’s sorting strings alphabetically. That is, it sorts them lexicographically. Lexicographical sorting means that if you have two tuples, and , then you start by comparing the first item of each tuple. The first item is in both cases, which is equal. The second element, , is also identical in both cases. The third elements are and , respectively. Since is less than , you’ve found which item is less than the other. So, to order the tuples and lexicographically, you would switch their order to and . Because of Python’s lexicographic sorting behavior for tuples, using the method with the function will always sort by keys unless you use something extra. Using the Parameter and Lambda Functions For example, if you want to sort by value, then you have to specify a sort key. A sort key is a way to extract a comparable value. For instance, if you have a pile of books, then you might use the author surname as the sort key. With the function, you can specify a sort key by passing a callback function as a argument. Note: The argument has nothing to do with a dictionary key! To see a sort key in action, take a look at this example, which is similar to the one you saw in the section introducing the function: In this example, you try out two ways of passing a parameter. The parameter accepts a callback function. The function can be a normal function identifier or a lambda function. The lambda function in the example is the exact equivalent of the function. Note: Lambda functions are also known as anonymous functions because they don’t have a name. Lambda functions are standard for functions that you’re only using once in your code. Lambda functions confer no benefit apart from making things more compact, eliminating the need to define a function separately. They keep things nicely contained on the same line: For basic getter functions like the one in the example, lambdas can come in handy. But lambdas can make your code less readable for anything more complex, so use them with care. Lambdas can also only ever contain exactly one expression, making any multiline statements like statements or loops off limits. You can work around this by using comprehensions and expressions, for example, but those can make for long and cryptic one-liners. The callback function will receive each element of the iterable that it’s sorting. The callback function’s job is to return something that can be compared, such as a number or a string. In this example, you named the function because all it does is get the value from a key-value tuple. Since the default behavior of with tuples is to sort lexicographically, the parameter allows you to select a value from the element that it’s comparing. In the next section, you’ll take sort keys a bit further and use them to sort by a nested value. You can also go further and use a sort key to select nested values that may or may not be present and return a default value if they’re not present: \"\"\"Get the sum of Python and JavaScript skill\"\"\" # Return default value that is equivalent to no skill In this example, you have a dictionary with numeric keys and a nested dictionary as a value. You want to sort by the combined Python and JavaScript skills, attributes found in the subdictionary. Part of what makes sorting by the combined skill tricky is that the and keys aren’t present in the dictionary for all people. The dictionary is also nested. You use to read the keys and provide as a default value that’s used for missing skills. You’ve also used the argument because you want the top Python skills to appear first. Note: You didn’t use a lambda function in this example. While it’s possible, it would make for a long line of potentially cryptic code: A lambda function can only contain one expression, so you repeat the full look-up in the nested subdictionary. This inflates the line length considerably. The lambda function also requires multiple chained square bracket ( ) indices, making it harder to read than necessary. Using a lambda in this example only saves a few lines of code, and the performance difference is negligible. So, in these cases, it usually makes more sense to use a normal function. You’ve successfully used a higher-order function as a sort key to sort a dictionary view by value. That was the hard part. Now there’s only one issue left to solve—converting the list that yields back into a dictionary. The only issue left to address with the default behavior of is that it returns a list, not a dictionary. There are a few ways to convert a list of tuples back into a dictionary. You can iterate over the result with a loop and populate a dictionary on each iteration: This method gives you absolute control and flexibility in deciding how you want to construct your dictionary. This method can be quite lengthy to type out, though. If you don’t have any special requirements for constructing your dictionary, then you may want to go for a dictionary constructor instead: That’s nice and compact! You could also use a dictionary comprehension, but that only makes sense if you want to change the shape of the dictionary or swap the keys and values, for example. In the following comprehension, you swap the keys and values: Depending on how familiar you or your team are with comprehensions, this may be less readable than just using a normal loop. Congratulations, you’ve got your sorted dictionary! You can now sort it by any criteria that you’d like. Now that you can sort your dictionary, you might be interested in knowing if there are any performance implications to using a sorted dictionary, or whether there are alternative data structures for key-value data.\n\nIn this section, you’ll be taking a quick peek at some performance tweaks, strategic considerations, and questions to ask yourself about how you’ll use your key-value data. Note: If you decide to go for an ordered collection, check out the Sorted Containers package, which includes a . You’ll be leveraging the module to get some metrics to work with. It’s important to bear in mind that to make any solid conclusions about performance, you need to test on a variety of hardware, and with a variety of sample types and sizes. Finally, note that you won’t be going into detail about how to use . For that, check out the tutorial on Python timers. You’ll have some examples to play with, though. Using Special Getter Functions to Increase Performance and Readability You may have noticed that most of the sort key functions that you’ve used so far aren’t doing very much. All the function does is get a value from a tuple. Making a getter function is such a common pattern that Python has a special way to create special functions that get values more quickly than regular functions. The function can produce highly efficient versions of getter functions. You pass an argument, which is typically the key or index position that you want to select. The function will then return a getter object that you call like a function. That’s right, it’s a function that returns a function. Using the function is another example of working with higher-order functions. The getter object from will call the method on the item that’s passed to it. When something makes a call to , it needs to pass in the key or index of what to get. The argument that’s used for is the same argument that you passed to : In the example, you start off with a tuple, similar to one that you might get as part of a dictionary view. You make the first getter by passing as an argument to . When the resultant getter receives the tuple, it returns the first item in the tuple—the value at index . If you call with an argument of , then it gets the value at index position . You can use this itemgetter as a key for the function: In this example, you start by using with as an argument. Since it’s operating on each tuple from the variable, it gets the first element from each tuple. Then the example demonstrates initializing an with as an argument, which selects the second item in the tuple. Finally, the example shows what would happen if you used with as an argument. Since these tuples only have two index positions, trying to get the third element, with index , results in a . You can use the function produced by in place of the getter functions that you’ve been using up until now: The function produces a function that has exactly the same effect as the function from previous sections. The main reason you’d want to use the function from is because it’s more efficient. In the next section, you’ll start to put some numbers on just how much more efficient it is. So, you end up with a function that behaves like the original from the previous sections, except that the version returned from is more efficient. You can use the module to compare their performance: This code uses the module to compare the sorting processes of the function from and a lambda function. Running this script from the shell should give you similar results to what’s below: A savings of around 40 percent is significant! Bear in mind that when timing code execution, times can vary significantly between systems. That said, in this case, the ratio should be relatively stable across systems. From the results of this test, you can see that using is preferable from a performance standpoint. Plus, it’s part of the Python standard library, so there’s no cost to using it. Note: The difference between using a lambda and a normal function as the sort key is negligible in this test. Do you want to compare the performance of some operations that you haven’t covered here? Be sure to share the results by posting them in the comments! Now you can squeeze a bit more performance out of your dictionary sorting, but it’s worth taking a step back and considering whether using a sorted dictionary as your preferred data structure is the best choice. A sorted dictionary isn’t a very common pattern, after all. Coming up, you’ll be asking yourself some questions about what you what you want to do with your sorted dictionary and whether it’s the best data structure for your use case. Judging Whether You Want to Use a Sorted Dictionary If you’re considering making a sorted key-value data structure, then there are a few things you might want to take into consideration. If you’re going to be adding data to a dictionary, and you want it to stay sorted, then you might be better off using a structure like a list of tuples or a list of dictionaries: A list of dictionaries is the most widespread pattern because of its cross-language compatibility, known as language interoperability. Language interoperability is especially relevant if you create an HTTP REST API, for instance. Making your data available over the Internet will likely mean serializing it in JSON. If someone using JavaScript were to consume JSON data from a REST API, then the equivalent data structure would be an object. The kicker is that JavaScript objects are not ordered, so the order would end up scrambled! This scrambling behavior would be true for many languages, and objects are even defined in the JSON specification as an unordered data structure. So, if you took care to order your dictionary before serializing to JSON, it wouldn’t matter by the time it got into most other environments. Note: Signposting an ordered sequence of key-value pairs may not only be relevant for serializing Python dictionaries into JSON. Imagine you have people on your team who are used to other languages. An ordered dictionary might be a foreign concept to them, so you may need to be explicit about the fact that you’ve created an ordered data structure. One way to be explicit about having an ordered dictionary in Python is to use the aptly named . Another option is to simply not worry about ordering the data if you don’t need to. Including , , or other equivalent attributes for each object can be enough to express order. If the ordering gets mixed up for any reason, then there’ll always be an unambiguous way to sort it: With a attribute, for instance, it’s clear that should be first in line. Being clear about your intended ordering is nicely in agreement with the old Python adage of explicit is better than implicit, from the Zen of Python. What are the performance trade-offs with using a list of dictionaries versus a dictionary of dictionaries, though? In the next section, you’ll start to get some data on just that very question. Comparing the Performance of Different Data Structures If performance is a consideration—maybe you’ll be working with large datasets, for example—then you should carefully consider what you’ll be doing with the dictionary. The two main questions you’ll seek to answer in the next few sections are:\n• Will you be sorting once and then making lots of lookups?\n• Will you be sorting many times and making very few lookups? Once you’ve decided what usage patterns you’ll be subjecting your data structure to, then you can use the module to test the performance. These measurements can vary a lot with the exact shape and size of the data being tested. In this example, you’ll be pitting a dictionary of dictionaries against a list of dictionaries to see how they differ in terms of performance. You’ll be timing sorting operations and lookup operations with the following sample data: Each data structure has the same information, except one is structured as a dictionary of dictionaries, and the other is a list of dictionaries. First up, you’ll be getting some metrics on the performance of sorting these two data structures. In the following code, you’ll be using to compare the time it takes to sort the two data structures by the attribute: This code imports the sample data structures for sorting on the attribute. It may seem like you aren’t using the imports from , but it’s necessary for these samples to be in the global namespace so that the context has access to them. Running the code for this test on the command line should provide you with some interesting results: Sorting a list can be almost twice as fast as the process required to sort a dictionary view and then create a new sorted dictionary. So, if you plan on sorting your data very regularly, then a list of tuples might be better than a dictionary for you. Note: Not many solid conclusions can be drawn from a single dataset like this. Additionally, results can vary wildly with differently sized or shaped data. These examples are a way for you to dip your toes into the module and start to see how and why you might use it. This will give you some of the tools necessary to benchmark your data structures, to help you decide which data structure to settle on for your key-value pairs. If you need the extra performance, then go ahead and time your specific data structures. That said, beware of premature optimization! One of the main overheads when sorting a dictionary, as opposed to a list, is reconstructing the dictionary after sorting it. If you were to take out the outer constructor, then you’d significantly cut the execution time. In the next section, you’ll be looking at the time it takes to look up values in a dictionary of dictionaries versus in a list of dictionaries. However, if you plan to use the dictionary to sort your data once and use that dictionary mainly for lookups, then a dictionary will definitely make more sense than a list: This code makes a series of lookups to both the list and the dictionary. You’ll note that with the list, you have to write a special function to make a lookup. The function to make the list lookup involves going through all the list elements one by one until you find the target element, which isn’t ideal. Running this comparison script from the command line should yield a result showing that dictionary lookups are significantly faster: Nearly eighteen times faster! That’s a whole bunch. So, you certainly want to weigh the blazing speed of dictionary lookups against the data structure’s slower sorting. Bear in mind that this ratio can vary significantly from system to system, not to mention the variation that might come from differently sized dictionaries or lists. Dictionary lookups are certainly faster, though, no matter how you slice it. That said, if you’re just doing lookups, then you could just as easily do that with a regular unsorted dictionary. Why would you need a sorted dictionary in that case? Leave your use case in the comments! Note: You could try and optimize list lookups, for example by implementing a binary search algorithm to cut time off the list lookup. However, any benefit will only become noticeable at substantial list sizes. With list sizes like the ones tested here, using a binary search with the module is significantly slower than a regular loop. Now you should have a relatively good idea of some trade-offs between two ways to store your key-value data. The conclusion that you can reach is that, most of the time, if you want a sorted data structure, then you should probably steer clear of the dictionary, mainly for language interoperability reasons. That said, give Grant Jenks’ aforementioned sorted dictionary a try. It uses some ingenious strategies to get around typical performance drawbacks. Do you have any interesting or performant implementations of a sorted key-value data structure? Share them in the comments, along with your use cases for a sorted dictionary!"
    },
    {
        "link": "https://stackoverflow.com/questions/78083413/how-to-efficiently-sort-a-list-of-dictionaries-in-python",
        "document": "I have a list of dictionaries in Python and I want to sort this list based on a specific key in the dictionaries. The list is quite large, so I'm looking for an efficient way to do this.\n\nI've tried using the function with a lambda function as the key, like this:\n\nThis works, but it seems to be quite slow with large lists."
    },
    {
        "link": "https://stackoverflow.com/questions/51776799/python-how-to-sort-list-of-dictionaries-by-value-and-index",
        "document": "I have a list of a dictionary of data that is in order in some places and out of order in others:\n\nI want to sort them as:\n\nwherein my sorting is some combination of the index of the item and the 2nd value, I was thinking sort with:\n\nI can sort by the list of dicts by the 2nd value with:\n\nHow do I also add the index of the dictionary?\n\nAnd is there a better sorting key I could use?"
    },
    {
        "link": "https://geeksforgeeks.org/ways-sort-list-dictionaries-values-python-using-lambda-function",
        "document": "Ways to sort list of dictionaries by values in Python – Using lambda function\n\nIn this article, we will cover how to sort a dictionary by value in Python.\n\nSorting has always been a useful utility in day-to-day programming. Dictionary in Python is widely used in many applications ranging from competitive domain to developer domain(e.g. handling JSON data). Having the knowledge to sort dictionaries according to their values can prove useful in such cases.\n\nThere are 2 ways to achieve this sorting:\n\nWhat is the lambda function in python?\n\nThis article deals with sorting using the lambda function and using the “sorted()” inbuilt function. Various variations can also be achieved for sorting the dictionaries.\n• For descending order : Use “reverse = True” in addition to the sorted() function.\n• For sorting w.r.t multiple values: Separate by “comma” mentioning the correct order in which sorting has to be performed.\n\nNext Article -> Ways to sort list of dictionaries by values in Python – Using itemgetter"
    },
    {
        "link": "https://geeksforgeeks.org/python-sort-python-dictionaries-by-key-or-value",
        "document": "Sort Python Dictionary by Key or Value – Python\n\nThere are two elements in a Python dictionary-keys and values. You can sort the dictionary by keys, values, or both. In this article, we will discuss the methods of sorting dictionaries by key or value using Python.\n\nIn this example, we will sort the dictionary by keys and the result type will be a dictionary.\n\nDisplaying the Keys in Sorted Order using sorted() on Keys\n\nIn this example, we are trying to sort the dictionary by keys and values in Python. Here, keys() returns an iterator over the dictionary’s keys.\n\nIn this example, we will sort in lexicographical order Taking the key’s type as a string.\n\nSorting the Keys Alphabetically Using Sorted on Dictionary\n\nWhen we use sorted on a dictionary, it sorts by keys by default.\n\nIn this example, we are trying to sort the dictionary by keys and values in Python. Here we are using to sort in lexicographical order.\n\nSorting Dictionary By Value using Numpy\n\nIn this example, we are trying to sort the dictionary by values in Python. Here we are using dictionary comprehension to sort our values.\n\nSorting Dictionary By Value using sorted() method\n\nIn the below given example, the dictionary is sorted using a ‘lambda’ to obtain the desired result of sorting the dictionary based on values.\n\nNeed for Sorting Dictionary in Python\n\nWe need sorting of data to reduce the complexity of the data and make queries faster and more efficient. Sorting is very important when we are dealing with a large amount of data.\n\nWe can sort a dictionary by values using these methods:\n• None First, sort the keys alphabetically using key_value.iterkeys()\n• None Second, sort the keys alphabetically using the sorted (key_value) function & print the value corresponding to it.\n• None Third, sort the values alphabetically using key_value.iteritems(), key = lambda (k, v) : (v, k))\n\nWe have covered different examples based on sorting dictionary by key or value. Reading and practicing these Python codes will help you understand sorting in Python dictionaries.\n\nYou can easily sort the values of dictionaries by their key or value.\n• None Different ways of sorting Dictionary by Values and Reverse\n• None Different ways of sorting Dictionary by Keys and Reverse\n• None Ways to sort list of dictionaries by values\n\nPython | Sort Python Dictionaries by Key or Value – FAQs\n\nHow to check if key and value match in dictionary Python?\n\nDoes order of keys matter in dictionary Python?\n\nHow to extract key and value from list of dictionary in Python?\n\nHow do I print a specific key and value in a dictionary Python?\n\nHow to check if key and value exist in dictionary Python?\n\nYou can use the in keyword to check if a key exists in a dictionary, and then verify its corresponding value if needed: \n\n\n\n\n\n # Check if key has a specific value \n\n \n\n print(\"Key 'name' exists and has value 'Alice'\") \n\n\n\n print(\"Key 'name' exists but does not have value 'Alice'\") \n\n\n\n print(\"Key 'name' does not exist in the dictionary\")\n\nHow do I sort a dictionary by value when the values are strings?\n\nYou can sort a dictionary by its values, even if they are strings, using the sorted() function with a custom key based on the values: \n\n # Sort dictionary by values (strings converted to integers for numeric comparison) \n\n \n\n In this example, sorted() sorts the dictionary my_dict by converting the string values to integers (int(item[1])) for numeric comparison. Adjust the key function (lambda item: int(item[1])) based on the specific type or format of your dictionary values."
    }
]