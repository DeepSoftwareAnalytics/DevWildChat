[
    {
        "link": "https://stackoverflow.com/questions/41656176/tkinter-canvas-zoom-move-pan",
        "document": "Advanced zoom example. Like in Google Maps.\n\nIt zooms only a tile, but not the whole image. So the zoomed tile occupies constant memory and not crams it with a huge resized image for the large zooms. For the simplified zoom example look here.\n\nDo not forget to place a path to your image at the end of the script.\n\nI've created even more advanced zoom. There is \"image pyramid\" for smooth zooming of large images and even ability to open and zoom huge TIFF files up to several gigabytes.\n\nVersion 3.0 is tested on Windows 7 64-bit and Python 3.7.\n\nP.S. Here is the GitHub application using advanced zoom for manual image annotation with polygons."
    },
    {
        "link": "https://w3resource.com/python-exercises/tkinter/python-tkinter-canvas-and-graphics-exercise-9.php",
        "document": "Creating an image zooming application in Python with Tkinter\n\nWrite a Python program that uses the Canvas widget to display an image and allows users to zoom in and out using Tkinter.\n\nIn the exercise above -\n• 'tkinter': Provides functions for creating the GUI.\n• 'PIL' (Python Imaging Library): Used for opening, resizing, and displaying images.\n• Initialize the main application window ('root') with the title \"Image Zoom.\"\n• Initialize image-related attributes ('self.image' and 'self.tk_image') to 'None'.\n• Load an initial image using the 'load_image' method (replace '\"image1.png\"' with the path to your own image).\n• Create \"Zoom In\" and \"Zoom Out\" buttons using the 'tk.Button' widget and associate them with the respective methods ('self.zoom_in' and 'self.zoom_out').\n• Bind mouse wheel events to the Canvas for zooming in and out using '<Button-4>' (scroll up) and '<Button-5>' (scroll down).\n• This method loads an image from the specified file using PIL.\n• Converts the loaded image into a Tkinter PhotoImage ('self.tk_image') to display it on the Canvas.\n• Displays the image on the Canvas using 'self.canvas.create_image'.\n• Increases the image size by a factor of 1.2 (zooming in) using the 'resize' method from PIL.\n• Updates 'self.image' and 'self.tk_image' with the resized image and PhotoImage.\n• Clears the Canvas ('self.canvas.delete(\"all\"') and redraws the zoomed-in image.\n• Decreases the image size by a factor of 0.8 (zooming out) using the 'resize' method from PIL.\n• Updates 'self.image' and 'self.tk_image' with the resized image and PhotoImage.\n• Clears the Canvas ('self.canvas.delete(\"all\"') and redraws the zoomed-out image.\n• Create an instance of the 'ImageZoomApp' class ('app') to start the application.\n\nYou will see an initial image when running this program. To zoom in and out of the image, click the \"Zoom In\" and \"Zoom Out\" buttons or use the mouse wheel.\n\nPrevious: Creating a colorful canvas drawing program with Python and Tkinter.\n\n Next: Create a 'Catch the Ball' game with Python and Tkinter."
    },
    {
        "link": "https://stackoverflow.com/questions/5436810/adding-zooming-in-and-out-with-a-tkinter-canvas-widget",
        "document": "To my knowledge the built-in Tkinter Canvas class scale will not auto-scale images. If you are unable to use a custom widget, you can scale the raw image and replace it on the canvas when the scale function is invoked.\n\nThe code snippet below can be merged into your original class. It does the following:\n• Adds a function to calculate the scaled image and adds that to the canvas, and also removes the previously-drawn image if any.\n• Uses the mouse coordinates as part of the image placement. I just pass to the function to show how the image placement shifts around as the mouse moves. You can replace this with your own center/offset calculation.\n• This uses the Linux mousewheel buttons 4 and 5 (you'll need to generalize it to work on Windows, etc).\n\nUpdate I did a bit of testing for varying scales and found that quite a bit of memory is being used by resize / create_image. I ran the test using a 540x375 JPEG on a Mac Pro with 32GB RAM. Here is the memory used for different scale factors:\n\nGiven the above, a more efficient solution might be to determine the size of the viewport where the image will be displayed, calculate a cropping rectangle around the center of the mouse coordinates, crop the image using the rect, then scale just the cropped portion. This should use constant memory for storing the temporary image. Otherwise you may need to use a 3rd party Tkinter control which performs this cropping / windowed scaling for you.\n\nUpdate 2 Working but oversimplified cropping logic, just to get you started:"
    },
    {
        "link": "https://tkinter-docs.readthedocs.io/en/latest/widgets/canvas.html",
        "document": "Create a canvas widget for drawing graphics. It inherits all the common widget methods of , and .\n\nmaster is the parent widget of this canvas. If , tkinter will attempt to use the default root.\n\ncnf and kw are both used to specify widget options (see below). For example, and are equivalent.\n\nDraw an arc, chord or pieslice. Returns the item id. args is two coordinate points specifying a rectangle containing the oval (from which part is taken to draw the arc). Because tkinter flattens these, both and are acceptable. kw is the options, which can be any of the following: These options specifies dash patterns for the normal, active and disabled states of the outline of the arc (correspondingly). The value may be any valid . The default value is a solid outline. The starting offset in pixels into the pattern provided by the dash option. dashoffset is ignored if there is no dash pattern. The offset may have any of the forms described in the section below. The default value is 0. Specifies the size of the angular range occupied by the arc. The arc’s range extends for the given number of degrees counter-clockwise from the starting angle given by the start option. The value may be negative. If it is greater than 360 or less than -360, then degrees modulo 360 is used as the extent. The default value is 90. Specifies the colour to be used to fill arc’s area in its normal, active and disabled states (correspondingly). The given value may be any valid . If the value is an empty string, then the arc will not be filled (i.e. it will be transparent). The default value is an empty string. Specifies the offset of stipples. The offset value can be of the form or side, where side can be n, ne, e, se, s, sw, w, nw, or center. In the first case, the origin is the origin of the canvas itself, but putting # in front of the coordinate pair indicates using the current window’s origin instead. The default value is . Stipple offsets are only supported on Unix; they are silently ignored on other platforms. A Python tuple of cannot be given and instead must be manually formatted to string of the correct format ( or ). These options specifies the colour that should be used to draw the outline of the arc in its normal, active and disabled states (correspondingly). The given value may be any valid . If colour is specified as an empty string then no outline is drawn for the arc. The default values are as follows: Specifies the offset of the stipple pattern used for outlines, in the same way that the offset option controls fill stipples. See the offset option for a description of acceptable values. The default value is . This option specifies stipple patterns that should be used to draw the outline of the arc in its normal, active and disabled states (correspondingly). It indicates that the outline for the arc should be drawn with a stipple pattern and specifies the stipple pattern to use. The given value may be any valid . If the outline option has not been specified then this option has no effect. If the value is an empty string, then the outline is drawn in a solid fashion. The default value is an empty string. Stipples are not well supported on platforms other than Unix. This option specifies stipple patterns that should be used to fill the arc in its normal, active and disabled states (correspondingly). The given value may be any valid . If the fill option has not been specified then this option has no effect. If the value is an empty string, then filling is done in a solid fashion. The default value is an empty string. Stipples are not well supported on platforms other than Unix. Specifies the beginning of the angular range occupied by the arc. The value is given in degrees measured counter-clockwise from the 3-o’clock position; it may be either positive or negative. The default value is 0. This allows the arc to override the canvas widget’s global state option. It takes the same values: normal, disabled or hidden. An empty string will defer to the canvas widget’s state. The default value is an empty string. Specifies how to draw the arc. If type is pieslice then the arc’s region is defined by a section of the oval’s perimeter plus two lines between the center of the oval and each end of the perimeter section. If type is chord then the arc’s region is defined by a section of the oval’s perimeter plus a single line connecting the two end points of the perimeter section. If type is arc then the arc’s region consists of a section of the perimeter alone. In this last case the fill option is ignored. The default value is pieslice. Specifies one or more tags to apply to the arc. When used in , this replaces any existing tags for the arc. An empty list may also be specified. The default value is an empty list. Specifies the width of the outline to be drawn around the arc’s region, in its normal, active and disabled states (correspondingly). The value may be in any of the forms described in the section below. If the outline option has been specified as an empty string, then this option has no effect. The default value is 1. Wide outlines will be drawn centered on the edges of the arc’s region.\n\nargs is two or more coordinate points of the line. Because tkinter flattens these, both and are acceptable. kw is the options, which can be any of the following: none (for no arrowheads), first (for an arrowhead at the first point of the line), last (for an arrowhead at the last point of the line), or both (for arrowheads at both ends). When requested to draw an arrowhead, Tk internally adjusts the corresponding line end point so that the rendered line ends at the neck of the arrowhead rather than at its tip so that the line doesn’t extend past the edge of the arrowhead. This may trigger a Leave event if the mouse is hovering this line end (see the Enter event. The default value is none. Indicates whether or not arrowheads are to be drawn at one or both ends of the line. The value must have one of the values(for no arrowheads),(for an arrowhead at the first point of the line),(for an arrowhead at the last point of the line), or(for arrowheads at both ends). When requested to draw an arrowhead, Tk internally adjusts the corresponding line end point so that the rendered line ends at the neck of the arrowhead rather than at its tip so that the line doesn’t extend past the edge of the arrowhead. This may trigger aevent if the mouse is hovering this line end (see the section). Conversely, when removing an arrowhead Tk adjusts the corresponding line point the other way round, which may trigger anevent. The default value is l1 in the diagram). The second element gives the distance along the line from the trailing points of the arrowhead to the tip (l2), and the third element gives the distance from the outside edge of the line to the trailing points (l3). The default value is . This option indicates how to draw arrowheads. The shape argument must be a tuple / list with three elements, each specifying a distance in any of the forms described in the section below. The first element of the list gives the distance along the line from the neck of the arrowhead to its tip (in the diagram). The second element gives the distance along the line from the trailing points of the arrowhead to the tip (), and the third element gives the distance from the outside edge of the line to the trailing points (). The default value is Specifies the ways in which caps are to be drawn at the endpoints of the line. The value may be any of butt, projecting, or round. Where arrowheads are drawn, the cap style is ignored. The default value is butt. These options specifies dash patterns for the normal, active and disabled states of the line (correspondingly). The value may be any valid . The default value is a solid line. The starting offset in pixels into the pattern provided by the dash option. dashoffset is ignored if there is no dash pattern. The offset may have any of the forms described in the section below. The default value is 0. Specifies the colour used to draw the line in its normal, active and disabled states (correspondingly). The given value may be any valid . If the value is an empty string, then the line will not be filled (i.e. it will be transparent). The default values are as follows: Specifies the ways in which joints are to be drawn at the vertices of the line (only applicable if more than 2 coordinates are given). The value may be any of bevel, miter, or round. The default value is round. This value must either be a boolean or a line smoothing method. The line should be drawn as a curve, rendered as a set of quadratic splines: one spline is drawn for the first and second line segments, one for the second and third, and so on. Straight-line segments can be generated within a curve by duplicating the end-points of the desired line segment. The line should also be drawn as a curve but where the list of coordinates is such that the first coordinate pair (and every third coordinate pair thereafter) is a knot point on a cubic Bezier curve, and the other coordinates are control points on the cubic Bezier curve. Straight line segments can be generated within a curve by making control points equal to their neighbouring knot points. If the last point is a control point and not a knot point, the point is repeated (one or two times) so that it also becomes a knot point. The default value is . Specifies the degree of smoothness desired for curves: each spline will be approximated with number line segments. This option is ignored if the smooth option is or an empty string. The default value is 12. This option specifies stipple patterns that should be used to fill the line in its normal, active and disabled states (correspondingly). The given value may be any valid . If the fill option is an empty string, then this option has no effect. If the value is an empty string, then filling is done in a solid fashion. The default value is an empty string. Stipples are not well supported on platforms other than Unix. This allows the line to override the canvas widget’s global state option. It takes the same values: normal, disabled or hidden. An empty string will defer to the canvas widget’s state. The default value is an empty string. Specifies one or more tags to apply to the line. When used in , this replaces any existing tags for the line. An empty list may also be specified. The default value is an empty list. Specifies the width the line to be drawn, in its normal, active and disabled states (correspondingly). The value may be in any of the forms described in the section below. If the fill option has been specified as an empty string, then this option has no effect. The default value is 1.\n\nargs is two or more coordinate points of the polygon. These will be it’s vertices (corners). Because tkinter flattens these, both and are acceptable. kw is the options, which can be any of the following: These options specifies dash patterns for the normal, active and disabled states of the outline of the polygon (correspondingly). The value may be any valid . The default value is a solid line. The starting offset in pixels into the pattern provided by the dash option. dashoffset is ignored if there is no dash pattern. The offset may have any of the forms described in the section below. The default value is 0. Specifies the colour to be used to fill polygon’s area in its normal, active and disabled states (correspondingly). The given value may be any valid . If the value is an empty string, then the oval will not be filled (i.e. it will be transparent). The default value is an empty string. Specifies the ways in which joints are to be drawn at the vertices of the polygon. The value may be any of bevel, miter, or round. The default value is round. Specifies the offset of stipples. The offset value can be of the form or side, where side can be n, ne, e, se, s, sw, w, nw, or center. In the first case, the origin is the origin of the canvas itself, but putting # in front of the coordinate pair indicates using the current window’s origin instead. The default value is . Stipple offsets are only supported on Unix; they are silently ignored on other platforms. A Python tuple of cannot be given and instead must be manually formatted to string of the correct format ( or ). These options specifies the colour that should be used to draw the outline of the oval in its normal, active and disabled states (correspondingly). The given value may be any valid . If colour is specified as an empty string then no outline is drawn for the oval. The default values are as follows: Specifies the offset of the stipple pattern used for outlines, in the same way that the offset option controls fill stipples. See the offset option for a description of acceptable values. The default value is . This option specifies stipple patterns that should be used to draw the outline of the oval in its normal, active and disabled states (correspondingly). It indicates that the outline for the oval should be drawn with a stipple pattern and specifies the stipple pattern to use. The given value may be any valid . If the outline option has not been specified then this option has no effect. If the value is an empty string, then the outline is drawn in a solid fashion. The default value is an empty string. This value must either be a boolean or a line smoothing method. The outline should be drawn as a curve, rendered as a set of quadratic splines: one spline is drawn for the first and second line segments, one for the second and third, and so on. Straight-line segments can be generated within a curve by duplicating the end-points of the desired line segment. The outline should also be drawn as a curve but where the list of coordinates is such that the first coordinate pair (and every third coordinate pair thereafter) is a knot point on a cubic Bezier curve, and the other coordinates are control points on the cubic Bezier curve. Straight line segments can be generated within a curve by making control points equal to their neighbouring knot points. If the last point is a control point and not a knot point, the point is repeated (one or two times) so that it also becomes a knot point. The default value is . Specifies the degree of smoothness desired for curves: each spline will be approximated with number line segments. This option is ignored if the smooth option is or an empty string. The default value is 12. This option specifies stipple patterns that should be used to fill the polygon in its normal, active and disabled states (correspondingly). The given value may be any valid . If the fill option has not been specified then this option has no effect. If the value is an empty string, then filling is done in a solid fashion. The default value is an empty string. Stipples are not well supported on platforms other than Unix. This allows the polygon to override the canvas widget’s global state option. It takes the same values: normal, disabled or hidden. An empty string will defer to the canvas widget’s state. The default value is an empty string. Specifies one or more tags to apply to the polygon. When used in , this replaces any existing tags for the polygon. An empty list may also be specified. The default value is an empty list. Specifies the width of the outline to be drawn around the polygon’s region, in its normal, active and disabled states (correspondingly). The value may be in any of the forms described in the section below. If the outline option has been specified as an empty string, then this option has no effect. The default value is 1."
    },
    {
        "link": "https://wiki.tcl-lang.org/page/Canvas+zooming",
        "document": "It is really easy to draw lots and lots of data onto a canvas. Electronic Computer Aided Design (ECAD) developers routinely draw tens of thousands of rectangles or polygons representing design data, and the canvas performance is quite acceptable. But when you get a lot of data in a single window, you sometimes need to zoom in on a particular area to see the details. There are lots of sophisticated algorithms for the canvas, and even some generic Code to performs 2D graphics transforms. But here is some simple code which can allow you to zoom in on a section of a canvas drawing.\n\nYou could also use Zinc, an alternative to the canvas which offers natively scale, rotation and translation of any item, and specially to groups which are new items to group items together. CME.\n\nThe key canvas functionality is the scale subcommand, which actually modifies the coordinates of canvas items. A simple call like\n\ndoubles every (x,y) coordinate for every item on the canvas. You can think of this as zooming in by a factor of two, but you are really doubling the drawing size. Then you probably want to add scroll bars and utilize the canvas xview, yview, and scrollregion subcommands to allow users to easly scroll around the enlarged drawing. Pretty soon you've got a little canvas viewer application that looks something like this.\n\nLMN I wrote a zoom package very similar to this one which also handles zooming small images embedded in the canvas, as long as the total number of images is not too big: it works fine with 10-100 images, but becomes impractical with ~1k. Would that be of interest to anyone? If so, send email to [email protected]. It is using pure Tk, but I am afraid it is not as cleanly written as this one. I am also interested in getting advice on how to make it comply with your coding guidelines, and make the interface simpler. It looks that this code is also doing a better job of handling non-scalable items (my code is using 'bbox all'), so it might be a good idea to merge the two codes.\n\nThis code puts in a lot of extra work to handle non-scalable items like the text. But even that isn't perfect. If you zoom-out several times and zoom-in the same number of times, the window starts to drift off center. The canvas is storing its reference coordinate (x0,y0) as an integer, which causes some round-off errors. More complete coordinate transform solutions can do a better job than this, but they require correspondingly more code.\n\nSee also Canvas zooming using mousewheel for an alternative implementation.\n\nAM See also Simple zooming and scaling in a canvas\n\nOccasionally, \"zoom\" is used in a different sense. \"Maximizing a toplevel window\" explains more.\n\nLES on 2022-12-12: The scale command doesn't seem very nice to me. I have it \"zoom out\" and all existing items look perfectly smaller, but then new items are added in the original scale and look a lot bigger than the old ones. The manual says it \"rescales the coordinates of all of the items,\" which sounds to me like all the items are effectively resized while the entire containing space and its dimension references remain unchanged. So using scale in an interactive or \"live\" canvas is extremely difficult. One would have to constantly keep track of every scale change and recalculate the size of every new item according to the new overall proportions."
    },
    {
        "link": "https://pillow.readthedocs.io/en/stable/reference/Image.html",
        "document": "The module provides a class with the same name which is used to represent a PIL image. The module also provides a number of factory functions, including functions to load images from files, and to create new images.\n\nInstances of the class have the following attributes: The filename or path of the source file. Only images created with the factory function have a filename attribute. If the input is a file like object, the filename attribute is set to an empty string. The file format of the source file. For images created by the library itself (via a factory function, or by running a method on an existing image), this attribute is set to . Image mode. This is a string specifying the pixel format used by the image. Typical values are “1”, “L”, “RGB”, or “CMYK.” See Modes for a full list. Image size, in pixels. The size is given as a 2-tuple (width, height). Colour palette table, if any. If mode is “P” or “PA”, this should be an instance of the class. Otherwise, it should be set to . A dictionary holding data associated with the image. This dictionary is used by file handlers to pass on various non-image information read from the file. See documentation for the various file handlers for details. Most methods ignore the dictionary when returning new images; since the keys are not standardized, it’s not possible for a method to know if the operation affects the dictionary. If you need the information later on, keep a reference to the info dictionary returned from the open method. Unless noted elsewhere, this dictionary does not affect saving files. if this image has more than one frame, or otherwise. This attribute is only defined by image plugins that support animated images. Plugins may leave this attribute undefined if they don’t support loading animated images, even if the given format supports animated images. Given that this attribute is not present for all images use to check if Pillow is aware of multiple frames in an image regardless of its format. The number of frames in this image. This attribute is only defined by image plugins that support animated images. Plugins may leave this attribute undefined if they don’t support loading animated images, even if the given format supports animated images. Given that this attribute is not present for all images use to check the number of frames that Pillow is aware of in an image regardless of its format. Determine if an image has transparency data, whether in the form of an alpha channel, a palette with an alpha channel, or a “transparency” key in the info dictionary. Note the image might still appear solid, if all of the values shown within are opaque."
    },
    {
        "link": "https://geeksforgeeks.org/python-pil-image-resize-method",
        "document": "PIL is the Python Imaging Library which provides the python interpreter with image editing capabilities. The Image module provides a class with the same name which is used to represent a PIL image. The module also provides a number of factory functions, including functions to load images from files, and to create new images.\n\nImage.resize() Returns a resized copy of this image.\n\n\n\nSyntax: Image.resize(size, resample=0) \n\nParameters: \n\nsize – The requested size in pixels, as a 2-tuple: (width, height). \n\nresample – An optional resampling filter. This can be one of PIL.Image.NEAREST (use nearest neighbour), PIL.Image.BILINEAR (linear interpolation), PIL.Image.BICUBIC (cubic spline interpolation), or PIL.Image.LANCZOS (a high-quality downsampling filter). If omitted, or if the image has mode “1” or “P”, it is set PIL.Image.NEAREST. Otherwise, the default filter is Resampling.BICUBIC. \n\nReturns type: An Image object.\n\n\n\nAnother example:Here we use the different newsize value.\n\n\n\n\n\n What is the PIL Function in Python?\n\nWhat Does PIL Stand For in Python?\n\nHow to Import PIL Image in Python?\n\nTo import an image using PIL (now Pillow), you first need to install Pillow, then use the module to open and manipulate images. Here’s how to import and open an image: \n\n\n\n\n\n \n\n img.show() # Displays the image using an external viewer\n\nWhat is the Difference Between Numpy and PIL?\n\nNumpy and PIL (Pillow) are both powerful libraries in Python but serve different purposes:\n• Numpy : Primarily used for numerical operations and serves as the foundational package for scientific computing with Python. It provides a high-performance multidimensional array object and tools for working with these arrays. It’s typically used for large-scale numerical computations.\n• PIL/Pillow : Focused on image processing capabilities. It can read, write, and manipulate image data in various formats. Pillow provides functionality that is specifically geared towards image editing, such as cropping, rotating, converting between formats, and applying filters. Both can be used together, for example, converting a PIL image into a NumPy array to perform complex numerical operations on image data, then converting it back to a PIL image for saving or further manipulation.\n\nHow to Install PIL in Python Command?\n\nSince the original PIL is no longer maintained, you should install Pillow, the friendly PIL fork, which is fully backward compatible with PIL. You can install it using pip: This command installs Pillow, and you can start using it under the namespace, as shown in the import example earlier. Pillow continues to use the namespace to make it a drop-in replacement for legacy PIL installations"
    },
    {
        "link": "https://stackoverflow.com/questions/273946/how-do-i-resize-an-image-using-pil-and-maintain-its-aspect-ratio",
        "document": "Is there an obvious way to do this that I'm missing? I'm just trying to make thumbnails.\n\nI also recommend using PIL's thumbnail method, because it removes all the ratio hassles from you. by default, PIL uses the Image.NEAREST filter for resizing which results in good performance, but poor quality.\n\nYou can combine PIL's with if your resize limit is only on one dimension (width or height). For instance, if you want to resize an image so that its height is no more than 100px, while keeping aspect ratio, you can do something like this: Keep in mind that will resize the image in place, which is different from that instead returns the resized image without changing the original one.\n\nI will also add a version of the resize that keeps the aspect ratio fixed. In this case, it will adjust the height to match the width of the new image, based on the initial aspect ratio, asp_rat, which is float (!). But, to adjust the width to the height, instead, you just need to comment one line and uncomment the other in the else loop. You will see, where. You do not need the semicolons (;), I keep them just to remind myself of syntax of languages I use more often. from PIL import Image img_path = \"filename.png\"; img = Image.open(img_path); # puts our image to the buffer of the PIL.Image object width, height = img.size; asp_rat = width/height; # Enter new width (in pixels) new_width = 50; # Enter new height (in pixels) new_height = 54; new_rat = new_width/new_height; if (new_rat == asp_rat): img = img.resize((new_width, new_height), Image.ANTIALIAS); # adjusts the height to match the width # NOTE: if you want to adjust the width to the height, instead -> # uncomment the second line (new_width) and comment the first one (new_height) else: new_height = round(new_width / asp_rat); #new_width = round(new_height * asp_rat); img = img.resize((new_width, new_height), Image.ANTIALIAS); # usage: resize((x,y), resample) # resample filter -> PIL.Image.BILINEAR, PIL.Image.NEAREST (default), PIL.Image.BICUBIC, etc.. # https://pillow.readthedocs.io/en/3.1.x/reference/Image.html#PIL.Image.Image.resize # Enter the name under which you would like to save the new image img.save(\"outputname.png\"); And, it is done. I tried to document it as much as I can, so it is clear. I hope it might be helpful to someone out there!\n\nI was trying to resize some images for a slideshow video and because of that, I wanted not just one max dimension, but a max width and a max height (the size of the video frame).\n\n And there was always the possibility of a portrait video...\n\n The method was promising, but I could not make it upscale a smaller image. So after I couldn't find an obvious way to do that here (or at some other places), I wrote this function and put it here for the ones to come: from PIL import Image def get_resized_img(img_path, video_size): img = Image.open(img_path) width, height = video_size # these are the MAX dimensions video_ratio = width / height img_ratio = img.size[0] / img.size[1] if video_ratio >= 1: # the video is wide if img_ratio <= video_ratio: # image is not wide enough width_new = int(height * img_ratio) size_new = width_new, height else: # image is wider than video height_new = int(width / img_ratio) size_new = width, height_new else: # the video is tall if img_ratio >= video_ratio: # image is not tall enough height_new = int(width / img_ratio) size_new = width, height_new else: # image is taller than video width_new = int(height * img_ratio) size_new = width_new, height return img.resize(size_new, resample=Image.LANCZOS)"
    },
    {
        "link": "https://cloudinary.com/guides/bulk-image-resize/python-image-resize-with-pillow-and-opencv",
        "document": "Python is a popular object-oriented programming language for image-related tasks for webpages, visualizations, or when using Python for machine-learning operations through frameworks like OpenCV and Scikit Learn.\n\nReducing the size of an image means changing its dimensions by removing its pixels. Scaling up an image increases the number of pixels but lowers quality. Either way, the image’s aspect ratio changes, which results in distortion.\n\nThis article describes how to resize images in bulk with the Pillow library, a popular fork of the Python Imaging Library (PIL); and, to maintain the quality and aspect ratio, in OpenCV, a robust library of programming functions for computer vision, neural networks, and other advanced image processing tasks. Also explained is how to resize and crop Python images with Cloudinary through automation.\n• Resize and Crop Images in Python With Cloudinary Through Automation\n\nPillow is a fork of the Python Imaging Library (PIL) that supports Python 3 and numerous image formats, including PNG, JPEG, TIFF, and PPM. When you load an image from a file, create a new image, or generate separate instances for images, you create an instance of PIL’s Image class.\n\nTo resize an image with Pillow’s method:\n• Load the image from a file with the function: The above command returns an object. In case of failure, the command returns an exception.\n• Call the method on the new image instance, passing a tuple argument with two integers to specify the width and height you desire: Note: Instead of modifying the image file, this function returns a separate instance with the new dimensions.\n\nThe method has two drawbacks, however:\n• Oftentimes, resizing to an exact width and height changes the image’s aspect ratio, leading to distortions.\n• If you set the size of the new instance to be larger than that of the original, “blows up” the instance, reducing its quality.\n\nAs a solution, resize the image with the more advanced Pillow method, :\n• Perform steps 1 and 2 of the above procedure.\n• Call the method on the instance, passing a tuple argument with two integers to specify the width and height you desire:\n\nAs shown under , the size of the new instance is 400×350 pixels. The aspect ratio of the original image remains unchanged. In addition, if the dimensions of the original are smaller than that specified for the new instance, instead of “blowing up” the image, returns an instance of the same size.\n\nOpenCV is an open-source computer-vision library with thousands of machine-learning and deep-learning algorithms for face detection, object recognition, and many other computer-vision tasks. Given that numerous computer-vision models require a certain size and quality level for their images, resizing is critical. To determine which image variation performs best, experiment with different sizes or resolutions.\n\nHere is the full syntax for the method in OpenCV:\n\nThe parameters are as follows:\n\nNote: Apply either or and , or all three.\n• Acquire a sample image and specify its current size:\n• Resize the image of, say, a size of 800×600 pixels, to 300×300 pixels:\n\nAs in the previous example on resizing images with Pillow’s resize() method, this procedure changes the aspect ratio, causing distortions. To maintain that ratio, run the following command to resize the image to 75% of its width and height:\n\nIn addition, for a resized instance that is larger than the original, you can customize the interpolation of the resize operation. Even though doing that causes quality loss, it might be the right choice for certain computer-vision applications.\n\nHere are the values for the argument:\n\nResize and Crop Python Images With Cloudinary Through Automation\n\nA cloud-based service for managing images and videos, Cloudinary offers a generous free-forever subscription plan. While on that platform, you can upload images and apply built-in effects, filters, and modifications.\n\nYou can also resize images through automation, focusing on the most important elements with AI, or adapt them to your website design by, for example, specifying the width, height, and aspect ratio as qualifiers for the new image instances. Cloudinary then automatically performs the resizing and cropping tasks to meet the criteria. No manual efforts are required.\n\nResizing it to 200×200 pixels with crop, scale, fill, and pad results in the following images:\n\nAutomatically determine what to keep in a banner crop\n\nTo automate image resizing and cropping on Cloudinary:\n• Set the transformation criteria for the above examples: # Focus on the model in a portrait crop. CloudinaryImage(\"docs/model.jpg\").image(gravity=\"person\", height=600, width=450, crop=\"fill\") # Detect the face for a thumbnail crop. CloudinaryImage(\"docs/model.jpg\").image(gravity=\"face\", height=250, width=250, crop=\"thumb\") # Crop to a banner, automatically focusing on a region of interest. CloudinaryImage(\"docs/model.jpg\").image(gravity=\"auto\", height=150, width=600, crop=\"fill\")\n\nPython offers numerous modules and libraries, such as Pillow and OpenCV, to resize images. While these tools are powerful and versatile, they require significant coding effort to handle various use cases, such as different image formats, sizes, and quality requirements. This can be a daunting task for developers looking to streamline their workflow rather than managing image processing code.\n\nThe Cloudinary API not only simplifies the process of resizing images but also provides a comprehensive suite of image management functionalities. With Cloudinary, you can easily handle image uploads, transformations, optimizations, and even advanced features like automatic format selection, watermarking, and responsive image delivery.\n\nReady to take your image processing to the next level? Sign up for a free Cloudinary account today and experience the ease and power of Cloudinary’s image management solutions. Start simplifying your workflow and focus on what truly matters—building great applications."
    },
    {
        "link": "https://auth0.com/blog/image-processing-in-python-with-pillow",
        "document": "If you’re building your application with Python and it needs to process images, you have a choice of libraries, including OpenCV, scikit-image, Python Imaging Library and Pillow.\n\nWe won't debate which library is the best here; they all have their merits. This article will focus on Pillow, a powerful library that provides a wide array of image processing features and is simple to use. To make the tutorial more interactive and easy to follow, we'll run all the code using Jupyter Notebooks.\n\nPillow is a fork of the Python Imaging Library (PIL). PIL is a library that offers several standard functions for manipulating images. It's a powerful library but hasn't been updated since 2009 and doesn't support Python 3.\n\nPillow builds on PIL, adding more features and support for Python 3. It supports a range of image file formats such as PNG, JPEG, PPM, GIF, TIFF, and BMP. We'll see how to perform various operations on images using this library, such as cropping, resizing, adding text to images, rotating, greyscaling, and more.\n\nYou can follow along by downloading our sample Jupyter notebook from GitHub, or you can create your own project and install the following packages:\n\nTo follow along, you can download the images (courtesy of Unsplash) that we'll use in the article.\n\nAll the code examples will assume the required images are in the same directory as your Jupyter Notebook file.\n\nYou’ll find the code for all the Pillow exercise in this article in a Jupyter Notebook in this GitHub repository.\n\nOf all the classes in Pillow, you’ll probably use\n\nthe most. It's defined in themodule and is the class that represents images and provides methods for loading or creating them, processing them, and displaying them.\n\nTo load an image from a file, use the\n\nfunction in themodule, which takes thefor the image as its argument:\n\nRun the cell. Here’s what it should look like in Jupyter Notebook:\n\nIf you’re using a command-line Python REPL (or something similar) instead of a Jupyter Notebook, you’ll need to call on an external viewer application to see the image. You can do this with\n\nGetting information about an image\n\nlaunches your system’s external viewer, using it to display the image. On Windows, it will usually launch Paint; on macOS, it will launch Preview; and on Linux and other Unix-based systems, it will launch xv.\n\nYou can get some information about an\n\nobject using its attributes. Enter the following into a new cell and run it:\n\nFor more on what you can do with the\n\n’smethod takes a two-integer tuple argument representing the width and height of the new resized image.\n\nHere’s an example that takes the image you loaded and resizes both its width and height to 300 pixels — enter it into a new cell and run it:\n\ndoesn't modify the image but returns anotherinstance with the new dimensions.\n\nchanges the image’s dimensions to the ones you provide, it doesn’t preserve the image’s aspect ratio unless you purposely do so. The resulting image may end up looking stretched or compressed, which may not be the effect you want. You can see this in the newly-created image from the code above; it looks a bit squished horizontally:\n\nIf you want to resize images and keep their aspect ratios, use\n\n’smethod instead. Liketakes a two-integer tuple argument. However, the values in the tuple represent the maximum x- and y-sizes allowed while also preserving the image’s aspect ratio.\n\nEnter the code below into a new cell and run it:\n\n, themethod does not create a newinstance. Instead, it modifies the original. That’s why the code above first makes a copy of the image.\n\nThe code above resize the image to 300 × 200 and preserves the original’s aspect ratio:\n\nAnother significant difference between the\n\nandmethods is thatenalrges an image if given parameters that are larger than the original image, whiledoesn't.\n\nFor example, given an image of size 400 × 200, a call to\n\nwill create a larger-sized image 1200 pixels wide and 600 pixels tall, along with the expected loss of sharpness. A similar call tousing the original image will not enlarge the image since themethod cannot expand an image beyond either of its original dimensions.\n\nThe rise of retrocomputing and retrogaming has created a lot of interest in old-school “pixelated” graphics. You can use a combination of\n\n’sandmethods to turn a modern, high-resolution image into a “retro” one like the one below:\n\nHere’s the code that produces this effect:\n\nThe code above takes advantage of the\n\nmethod’s optionalparameter, which specifies how to draw pixels when resizing the image. When making an image larger, the “nearest neighbor” resampling method creates a “retro” pixel effect.\n\nclass provides themethod for quick image flipping.takes the following arguments:\n\nHere’s how you would create a horizontal mirror image of the original:\n\nThe resulting image can be seen below. Notice that the puffin with the open beak is now on the left side of the photo:\n\narguments rotate the image counterclockwise 90, 180, and 270 degrees, respectively. The following rotates the image 180 degrees:\n\nTransposing an image means mirroring it along the diagonal line that runs from the top left to the bottom right, while tranversing it means mirroring it along the diagonal line running from the bottom left to the top right. This is yet another case where showing is better than telling, so let’s make the code do that.\n\nYou can rotate images with Pillow using\n\n’smethod. This takes an integer or float argument representing the degrees to rotate an image (positive for counterclockwise, negative for clockwise) and returns a newobject for the rotated image.\n\nBy default, the rotated image keeps the dimensions of the original image. This means that for angles other than multiples of 180, the image will be cut and/or padded to fit the original dimensions. Consider this code, which rotates an image 90 degrees counterclockwise:\n\nNotice that the image has been “clipped” to fit the original height, and its sides have been padded with black background (on some operating systems, the padding will be made of transparent pixels) to fit the original width.\n\nThe example below, where the original image is rotated 18 degrees counterclockwise, shows this “clipping” effect more clearly.\n\nThe resulting image is shown below:\n\nTo expand the dimensions of the rotated image to fit the entire view, you pass a second argument to\n\nNow the contents of the image will be fully visible, and the dimensions of the image will have increased to account for this:\n\n’smethod to create a new image by cropping a section from an existing one. This method takes a 4-tuple that defines the position and size of the cropped region, as shown in the method call example below:\n\nPillow’s coordinate system starts with (0, 0) in the upper left corner, with x increasing from left to right and y increasing from top to bottom:\n\nThe cropped section includes the left column and the upper row of pixels and goes up to — but doesn't include — the right column and bottom row of pixels. This is better explained with a diagram:\n\nHere’s an example that creates a new image by cropping the rectangle described below:\n\nPasting an Image onto Another Image\n\nPillow enables you to paste an image onto another one. Some example use cases where this could be useful is in the protection of publicly available images by adding watermarks on them, the branding of images by adding a company logo, and in any other case where there is a need to merge two images.\n\nclass’method pastes another image onto the current one. This is useful for protecting publicly available images by adding watermarks, branding images with a company logo, or simply creating compositions of two or more images.\n\nis unlike manymethods (but like) in that it modifies theobject in place rather than returning a new `one. Because of this, we'll first make a copy of our puffin image before performing the paste to continue with the other examples using the original.\n\nThe code above loads a new image,\n• A 2-tuple specifying the upper left corner of the pasted image,\n• a 4-tuple defining the left, upper, right, and lower pixel coordinates of the pasted image, or\n• , which simply pastes the image at the coordinates (0, 0).\n\n, and makes a copy of the puffin image. We want to paste the logo image onto the puffin image copy at the bottom right corner. The code calculates the coordinates for pasting the logo, which can be:\n\nIn this case, we’re pasting the logo using a 2-tuple coordinate:\n\nYou can see the result below:\n\n, transparent pixels are pasted as solid pixels by default. Hence the black (white on some OSs) box surrounding the logo. Most of the time, this isn't what you want. You can't have your watermark covering the underlying image's content. We would rather have transparent pixels appear as such.\n\nTo achieve this, you need to pass in an optional third argument to the\n\nmethod. This argument is anobject that acts as an opacity mask.\n\nAn opacity mask is an\n\nobject where only the alpha value is significant, while its green, red, and blue values are ignored. If a mask is provided as an optional third argument to, the method updates only the regions the mask indicated. You can use either, orimages for masks. Pasting an RGBA image and using it as the mask pastes only the opaque portion of the image — not its transparent background.\n\nThe code below provides an example of this approach:\n\nWith Pillow, you can also draw on an image using the ImageDraw module. You can draw lines, points, ellipses, rectangles, arcs, bitmaps, chords, pie slices, polygons, shapes, and text.\n\nThe code below draws a black rectangle with a fine white outline near the lower left corner of the puffin image from the previous code example. It then draws the text message “Hello, puffins!” in large white text inside the rectangle:\n\nConverting an image from color to grayscale\n\n’smethod can convert images between different pixel representations, such as the RGB (red-green-blue) format used by screens and the CMYK (cyan-magenta-yellow-black) format used in printing. Like mostmethods,returns a newobject.\n\nalso supports converting images to the(luminance) format, which is a grayscale image format. The code below converts our puffin image from color to grayscale monochrome:\n\nReducing the number of colors in an image\n\nIn addition to pixelation, another way to make an image look “retro” is to reduce the number of colors it uses to 256 or fewer. You can do this with a single call to\n\nThe code below reduces the number of colors in our puffin photo to 16, producing an effect that should remind you of 1990s computer graphics:\n\nmethod of Pillow’sclass makes it possible to split a multi-band image into individual bands, such as the R, G, and B bands from an RGB image.creates new images, each containing one band from the original image.\n\nhas an inverse function,, which merges a set of single band images into a new multi-band image.takes a mode and a tuple of images and combines them into a new image.\n\nThe code below takes the original “puffin” image, splits it into three images — one for each of the R, G, and B bands — and then merges them so that:\n\nPillow allows you to enhance an image by adjusting its contrast, color, brightness, and sharpness using classes in the\n\nHere’s code that boosts the contrast of the “puffin” image:\n\nHere’s the image after enhancing its contrast:\n\nThe code above adjusts the image contrast by a factor of 3; smaller values will produce more subtle effects. A factor of 1.0 returns a copy of the original image; lower factors produce images with lower contrast.\n\nBelow, we increase the color of the image. If we used a factor of\n\n, we would get a black and white image.\n\nBelow we make the image brighter. A factor of\n\nBelow, we make the image sharper. An enhancement factor of\n\nTo save an image, use\n\n’smethod. For example, here’s how you’d save the image from the Enhancing sharpness exercise above as a PNG file:\n\nPillow sees the file extension has been specified as\n\nand converts it to PNG before saving it to a file.\n\nTo save it as a JPEG image, use this:\n\nYou can provide a second argument to\n\nto explicitly specify a file format.will do the same thing as the previous save(). Usually, it's unnecessary to supply this second argument as Pillow will determine the file storage format to use from the filename extension, but if you're using non-standard extensions, you should always specify the format this way.\n\nIn this article, we've covered some of the more common image-processing operations in applications. Pillow is a powerful library, and we have yet to discuss everything it can do. If you want to find out more, be sure to read the documentation."
    }
]