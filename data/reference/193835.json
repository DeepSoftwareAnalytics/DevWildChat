[
    {
        "link": "https://forum.qt.io/topic/159449/qtreeview-with-lots-of-items-is-really-slow-can-it-be-optimised-or-is-something-buggy",
        "document": "\nâ€¢ I want to use a QTreeView with millions of items, however when the tree is initially processed during the MainWindow.show() it takes a ridiculous amount of time. One of the main points of using a separate model and view is that only the items being shown should need to be processed. A treeview in a gui window is only going to show 10s of items at a time, so should only need to process 10s of items initially. This should take next to no time. I made some sample code to test various views and QTableView is able to show a 2D list of millions of items in next to no time, as I would expect. However when I try to use QListView or QTreeView they both take a ridiculous amount of time. A QListView only shows a 1D list of items, so if anything would expect it to be faster than a QTableView?! To give an idea of the time differences using the different models, to setup and show a model with 70,000,000 items takes:\n\n QTableView with 70000000 items = 0.499 seconds\n\n QListView with 70000000 items = 152.768 seconds\n\n QTreeView with 70000000 items = 236.746 seconds As you can see the table view is able to process in less than 1 second, but the list and tree views both take minutes! Does anyone know if there is some optimisation I can do to fix this slow process time? Or is there perhaps a bug in the code for these? I have included the single file source code for testing all 3 models below.\n\n To test it for yourself do: \"\"\" Test code for abstract models that handle at least 10s of millions of items. For some reason there is a huge difference table model and the list and tree models. To setup and show a model with 1,000,000 items takes: 0.070 seconds for QAbstractTableModel 2.251 seconds for QAbstractListModel 3.447 seconds for QAbstractItemModel (for a tree view with 1 level of hierarchy) To setup and show a model with 70,000,000 items takes: time taken to display table with 70000000 items = 0.499 seconds time taken to display list with 70000000 items = 152.768 seconds time taken to display tree with 70000000 items = 236.746 seconds I would expect all models to perform similarly to the table model/view, which is able to handle 1 million items in just 70ms. The list model/view takes 35 times as long as table and only shows 1 column of data compared to the table's 2 columns of data?!?! The tree model/view takes 49 times as long as table! All models had 1 million items but were only showing the first 10 items on screen. Perhaps I am missing some optimisations for the views?\" Adding 'QTreeView.setUniformRowHeights' to the tree view made a big difference for usability. \"\"\" # Note: table view/model fails to complete loading if there are more than 71,582,788 items # 71,582,788 ok # 71,582,789 bad # # this seems to be getting looked at fixing it here: # https://bugreports.qt.io/browse/QTBUG-128179 # # the issue is: # 2147383647 // 30 == 71582788 # where 2147383647 is signed 32bit int max value and 30 is the row height. import sys import time from PySide6 import QtWidgets, QtCore from PySide6.QtCore import Qt from PySide6.QtTest import QAbstractItemModelTester COLUMN_NAMES = [\"Number\", \"Info\"] COLUMN_COUNT = len(COLUMN_NAMES) class BigListModel(QtCore.QAbstractListModel): \"\"\" List model that works like a list of items with multiple values. \"\"\" def __init__(self, parent, max_num_nodes=1000): # pylint: disable=unused-argument super().__init__() self.max_num_nodes = max_num_nodes def headerData(self, section: int, orientation: Qt.Orientation, role: Qt.DisplayRole): # print(\"BigListModel.headerData\") if orientation == Qt.Horizontal and role == Qt.DisplayRole: return COLUMN_NAMES[section] return None def rowCount(self, parent: QtCore.QModelIndex) -> int: # pylint: disable=unused-argument return self.max_num_nodes def columnCount(self, parent: QtCore.QModelIndex) -> int: # pylint: disable=unused-argument #return COLUMN_COUNT return 1 def data(self, index: QtCore.QModelIndex, role: int): # if not the role we handle, then return now if role != Qt.DisplayRole: return None row = index.row() if row < 0 or row >= self.max_num_nodes: return None return f\"info_{row+1}\" class BigTableModel(QtCore.QAbstractTableModel): \"\"\" Table model that works like a list of items with multiple values. \"\"\" def __init__(self, parent, max_num_nodes=1000): super().__init__(parent) self.max_num_nodes = max_num_nodes def isRootIndex(self, index: QtCore.QModelIndex) -> bool: \"\"\"Test if the provided index is the root of the tree.\"\"\" # Using this test in rowCount() is required to pass # QAbstractItemModelTester() testing successfully. # pylint: disable=invalid-name if not index.isValid(): return True return False def headerData(self, section: int, orientation: Qt.Orientation, role: Qt.DisplayRole): # print(\"BigTableModel.headerData\") if orientation == Qt.Horizontal and role == Qt.DisplayRole: return COLUMN_NAMES[section] return None def rowCount(self, parent: QtCore.QModelIndex) -> int: # rows in root item if self.isRootIndex(parent): return self.max_num_nodes # rows in child items return 0 def columnCount(self, parent: QtCore.QModelIndex) -> int: # pylint: disable=unused-argument return COLUMN_COUNT def data(self, index: QtCore.QModelIndex, role: int): # data() gets called once for every role for every index. # we can stop most calls now as we only support 'DisplayRole' if role != Qt.DisplayRole: return None row = index.row() if row < 0 or row >= self.max_num_nodes: return None col = index.column() if col==0: return f\"{row+1}\" if col==1: return f\"info_{row+1}\" return None class BigTreeModel(QtCore.QAbstractItemModel): \"\"\" Tree model that works like a list of items with multiple values. \"\"\" def __init__(self, parent, max_num_nodes: int = 1000): super().__init__(parent) self.max_num_nodes = max_num_nodes def isRootIndex(self, index: QtCore.QModelIndex) -> bool: \"\"\"Test if the provided index is the root of the tree.\"\"\" # pylint: disable=invalid-name if not index.isValid(): return True return False def headerData(self, section: int, orientation: Qt.Orientation, role: Qt.DisplayRole): # print(\"BigTreeModel.headerData\") if orientation == Qt.Horizontal and role == Qt.DisplayRole: return COLUMN_NAMES[section] return None def rowCount(self, parent: QtCore.QModelIndex) -> int: # rows in root item if self.isRootIndex(parent): return self.max_num_nodes # rows in child items return 0 def columnCount(self, parent: QtCore.QModelIndex) -> int: # pylint: disable=unused-argument # columns in root item if self.isRootIndex(parent): return COLUMN_COUNT # columns in child items return 0 def index(self, row: int, column: int , parent: QtCore.QModelIndex) -> QtCore.QModelIndex: \"\"\" Returns the index of the item in the model specified by the given row, column and parent index. \"\"\" # print(f\"index request for ({row}, {column}) in parent:{idx_to_str(parent)}\") # if not valid, then index on root? if self.isRootIndex(parent): return self.createIndex(row, column, None) # if parent isnt root, then it is either a child or invalid, either way # the return value is an invalid index as children can't have subchildren. return QtCore.QModelIndex() def data(self, index: QtCore.QModelIndex, role: int): # data() gets called once for every role for every index. # we can stop most calls now as we only support 'DisplayRole' if role != Qt.DisplayRole: return None # handle root node if self.isRootIndex(index): return None row = index.row() if row < 0 or row >= self.max_num_nodes: return None col = index.column() if col==0: return f\"{row+1}\" if col==1: return f\"info_{row+1}\" return None def parent(self, index: QtCore.QModelIndex) -> QtCore.QModelIndex: \"\"\" Returns the parent of the model item with the given index. If the item has no parent, an invalid QModelIndex is returned. \"\"\" # There seems to be no real difference between: # * returning the parent of a child item which is the root item. # root item being represented by QtCore.QModelIndex() # * return the parent of the root item: # root item parent also being represented by QtCore.QModelIndex() # if self.isRootIndex(index): # return QtCore.QModelIndex() # return QtCore.QModelIndex() # pylint: disable=unused-argument return QtCore.QModelIndex() class MainForm(QtWidgets.QMainWindow): \"\"\"Simple window to test abstract models.\"\"\" def __init__(self, parent, model_type, num_items, do_test): QtWidgets.QMainWindow.__init__(self, parent) # Setup the model self.max_num_nodes = num_items if model_type == \"list\": self.model = BigListModel(self, self.max_num_nodes) self.view = QtWidgets.QListView() # optimisations for list view self.view.setUniformItemSizes(True) elif model_type == \"table\": self.model = BigTableModel(self, self.max_num_nodes) self.view = QtWidgets.QTableView() # fix the 72m item limit (doesnt display properly, but at least doesnt freeze anymore) self.view.verticalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Fixed) self.view.verticalHeader().setSectionsMovable(False) self.view.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Fixed) self.view.horizontalHeader().setSectionsMovable(False) self.view.verticalHeader().hide() self.view.horizontalHeader().hide() self.view.verticalHeader().setEnabled(False) self.view.horizontalHeader().setEnabled(False) # no optimisations needed for table - it is fast! #print(f\"sorting = {self.view.isSortingEnabled()}\") elif model_type == \"tree\": self.model = BigTreeModel(self, self.max_num_nodes) self.view = QtWidgets.QTreeView() # optimisations for tree view self.view.setUniformRowHeights(True) # fix the 72m item limit # self.view.header().setSectionResizeMode(QtWidgets.QHeaderView.Fixed) # self.view.header().setSectionsMovable(False) # self.view.setHeaderHidden(True) # self.view.header().setEnabled(False) #print(f\"sorting = {self.view.isSortingEnabled()}\") if do_test: print(\"doing QAbstractItemModelTester() test\") fail_mode = QAbstractItemModelTester.FailureReportingMode.Fatal QAbstractItemModelTester(self.model, fail_mode, self) # Setup the view self.view.setModel(self.model) self.setCentralWidget(self.view) def main(): \"\"\" Usage: python BigItemModel.py [model_type] [num_items] [test] Params: model_type can be \"list\", \"table\" or \"tree\" (default is \"tree\") num_items is the number of items that the model will contain. (default is 1,000,000) test can be \"test\" to enable QAbstractItemModelTester() testing on the model used. (default is no testing done) Examples: python BigItemModel.py list python BigItemModel.py table 2000000 python BigItemModel.py tree 3000000 test \"\"\" model_type = \"tree\" num_items = 1000000 do_test = False if len(sys.argv) > 1: model_type = sys.argv[1] if len(sys.argv) > 2: num_items = int(sys.argv[2]) if len(sys.argv) > 3: if sys.argv[3].lower() == \"test\": do_test = True if model_type not in [\"list\", \"table\", \"tree\"]: print(f\"Invalid model type: {model_type}\") sys.exit(1) if num_items < 0 or num_items > 1000*1000000: print(f\"Invalid number of items: {num_items}\") sys.exit(2) app = QtWidgets.QApplication() start_time = time.time() form = MainForm(None, model_type, num_items, do_test) form.show() end_time = time.time() time_taken = end_time - start_time print(f\"time taken to display {model_type} with {num_items} items = {time_taken:.3f} seconds\") app.exec() if __name__ == '__main__': main()\nâ€¢ @Cipherstream\n\n I have taken a bit of time to try your code. I do not have an answer for the obviously timing differences we see. However I have a couple of observations which I would like to type in here while they are in front of me. They do not resolve your fundamental issue but I hope they are nonetheless of some interest. I use Ubuntu 24.04 running in a VirtualBox under a Windows host. My machine is probably a bit slower than yours. To keep the timings down I show results for the default 1 million items. The times do seem to scale correspondingly when I do try more rows. I do do all my test timings several times. time taken to display table with 1000000 items = 0.013 seconds time taken to display list with 1000000 items = 3.554 seconds time taken to display tree with 1000000 items = 6.189 seconds My first test is a bit orthogonal to your issue. I wanted to check how it behaved with PyQt6 instead as a comparison. I had to make a couple of changes to source to make it acceptable but nothing significant: time taken to display table with 1000000 items = 0.027 seconds time taken to display list with 1000000 items = 1.530 seconds time taken to display tree with 1000000 items = 2.983 seconds Except for the first, fast case (slower startup time??) PyQt6 is consistently twice the speed of PySide6. This is rather depressing if one prefers the Qt LGPL Python bindings over the third-party GPL one :( It is true that for PySide6 I am forced to use a Python venv while for PyQt6 I do not and can use the system Python. However they both use the same Python 3.12.3 executable. I then continued with the PySide (not PyQt) version. Then I had a look at code for the case. (I am not prepared to look into the case as that is such a different kettle of fish with parentage/hierarchies.) Against the case.\nâ€¢ Just FYI, for the case I did not find commenting in/out all your lines for the horizontal/vertical headers made any (noticeable) difference, even if we thought it might.\nâ€¢ For the case I agree the made that nearly 10x faster.\nâ€¢ I added (in addition to the uniform size). This made it 2x faster than your original code. Then I didn't see anything else obvious to further add to the case. I do realize these timings are still way out for the difference between table vs list view. For Qt very old answers/posts are often still as relevant as recent ones, and I came across [Qt-interest] Why QListView is so slow and QTableView is fast? from 2009 (!): QTableView can scale much larger and faster then QListView can. I\n\n have an application that has 101,000,000+ rows inside of a QTableView\n\n with no scroll or startup problems, while this would not be possible\n\n in a QListView. You can always use a QTableView and just turn off the\n\n headers if you just want a classic vertical list ala QListView. Take such an old post as you please, but it may be an indication that there has always been a fundamental speed/scaling difference between and . Everything else I came across basically said to use , which we know if a big help but clearly does not go far enough/explain the remaining fundamental difference. In order to progress much further I would need to rewrite your code in C++, have Qt source code (which I don't) and to see what is going on. I'm afraid that is too much for me. Good luck if you wish to report it on the Qt bug tracker to see if you get an immediate answer from someone who knows the code. In view of the foregoing I think you should simply use a where you might use a (which apparently is not suited to huge lists, perhaps being more aimed at presentation of small lists). is a different matter. I have some further plays and post if I have anything more useful to say, but don't hold your breath. Hope the above is of some (limited) interest nonetheless.\nâ€¢ I ran tests with my sample code changed to only use BigTableModel() for all 3 view types and with counters added to count the number of times the methods I provide are called. My model only has 4 methods in it:\n\n headerData(), rowCount(), columnCount() and data(). Possibly the underlying QAbstractTableModel code has the other methods in python code? I am not sure on how the underlying code is handled whether it is handled in C++ code or python code unless I provide my own implementations of the methods and virtual methods. I guess I could try adding methods to my model for every possible method and virtual method in order to count their usage and to see if adding them adds more slowdown. This is the result for call counts: 1,000,000 items time taken to display table with 1000000 items = 0.081 seconds data() cnt = 84 headerData() cnt = 1680 rowCount() cnt = 18 columnCount() cnt = 17 time taken to display list with 1000000 items = 5.859 seconds data() cnt = 85 headerData() cnt = 0 rowCount() cnt = 2000062 columnCount() cnt = 2000059 time taken to display tree with 1000000 items = 2.975 seconds data() cnt = 156 headerData() cnt = 54 rowCount() cnt = 1000039 columnCount() cnt = 1000042 10,000,000 items time taken to display table with 10000000 items = 0.138 seconds data() cnt = 84 headerData() cnt = 1680 rowCount() cnt = 18 columnCount() cnt = 17 time taken to display list with 10000000 items = 57.361 seconds data() cnt = 379 headerData() cnt = 0 rowCount() cnt = 20000474 columnCount() cnt = 20000471 time taken to display tree with 10000000 items = 28.985 seconds data() cnt = 493 headerData() cnt = 107 rowCount() cnt = 10000204 columnCount() cnt = 10000207 These results show that data() is only being called a sane amount of times, so shouldnt be responsible for the huge amount of time taken. However rowCount() and ColumnCount() are being called an insane amount of times xD Also their call counts scale linearly with the number of items, just like the time taken. AND the call counts for listview are double the call counts for treeview, just like how listview takes double the time that treeview takes. This makes a lot of sense. From the developers point of view they would assume that calls to data() could be costly, and so are careful about calls to it. As is seen in the sane amount of 493 calls to data() for 10million items in treeview. However developers would also probably assume that a call to rowCount() and columnCount() would be \"cheap\" computationally wise, so not worry about how many times it is called. And in fact it probably is fairly cheap when the code is all native C++, as seen in tests done by @IgKh where even 70m items only took around 2 seconds. However when rowCount() and columnCount() have to cross the boundary between C++ and python millions of times, it is no longer a cheap operation. Perhaps armed with this knowledge the underlying C++ code could be tweaked to either use \"cached\" values for row and column counts (at least during expensive operations such as setup) or to be mindful of the number of calls performed. I have often seen loops like: This could be refactored to only call columnCounbt() once instead of potentially millions of times: I don't know if this is the case here, but there is a good chance that something like it is occuring.\nâ€¢ @Cipherstream said in QTreeView with lots of items is really slow. Can it be optimised or is something buggy?: However when rowCount() and columnCount() have to cross the boundary between C++ and python millions of times, it is no longer a cheap operation. Well, let's examine this instead of guessing! As before I am just testing the case. With my starting code from where I am now: time taken to display list with 10000000 items = 17.531 seconds You show & each being called twice as many times as the 10 million items. So I go to and append the following at the end of it: for i in range(self.max_num_nodes * 2): if self.rowCount(parent) < 0 or self.columnCount(parent) < 0: print(\"Whoops!\") time taken to display list with 10000000 items = 27.802 seconds Well, that's a fair amount of the original time. 10 of the original 17 seconds are being spent just doing these calls. (It's then not hard to imagine something else taking up a lot of the remaining original 7 seconds.) You that \"crossing the boundary between C++ and Python\" is particularly expensive. So we'd better test without a Qt virtual method. We just copy the definitions of your & and rename the copies / and call those instead in the loop. time taken to display list with 10000000 items = 27.831 seconds So no virtual or C++<->Python boundaries to cross yet identical time. The huge overhead is just Python. Which leaves us with two (white? black?) elephants in the room, neither of which you are going to like:\nâ€¢ If you are going to have \"millions\" of items care about performance you had better not use Python. It seems it is demonstrably just not up to the job here. Although your point about \"wouldn't it be better if the original Qt C++ code cached the value of instead of calling the method so often\" may be valid you are peeing in the wind if you expect it to be written this way to help out, say, Python, if apparently the original C++ calls are perhaps inline or in any case vastly faster. It's just not going to happen, and would require an enormous rewrite of existing Qt code.\nâ€¢ Don't put a model with 10 million items in a UI view. Maybe it happens to be fast enough with a , for whatever reason, but not with a or , but it's just \"way too many\" for something intended to be shown to a user. And for the record, once those 10 million records are stored in a database I think you're going to be spending a lot of time (and memory) reading them all in, on top of the display time. I really expect any application wanting to show this many records to have some sort of \"paging\" mechanism, and perhaps in the case of the treeview display of nodes without their children initially and creating them on parent node expansion. Conclusion: Once we discover that something as \"insignificant\" as the fact that many calls to are in the Qt code and that alone is incredibly expensive for Python it becomes unsurprising that there may be a surprisingly large difference between the timings of the 3 types of view due to what may be innocuous differences in their code.\nâ€¢ @JonB\n\n I'll answer your shorter post first, since it is quicker :) Yes a display with 70 million items could indeed take up a lot of ram. However due to the model/view paradigm you can potentially look up the data as needed and not need to keep any items in memory. You might then say \"that sounds like a great case for fetch more\", however I did initially try using fetch more and as far as I could tell it was an iterative fetcher from index 0 upwards. So to get the last item in 70m items it would still have to fetch all 70m items. If instead I have a fileformat on disk with a header that says \"this file has 70m items\", I can just read in the header and know how many items my view needs to handle. The user then scrolls the scroll bar to the location they want to look at and only that data will then be accessed. So they could do ctrl+end to go to the end of the list and the model will only access the items displayed on the last \"page\" of the view. This does indeed work well like this. If you let this initial slow setup part finish and then attempt to move through the data, you can see that it only fetches the minimal amount of data needed. This is for an app similar to wireshark where you may indeed need to have millions of items/packet in the one view. Funnily enough while looking into this issue I came across the developers of wireshark also talking about this problem (as they also use Qt it seems) and arguing that yes they do indeed to handle that much data in a view, however they are not doing it in python hehe."
    },
    {
        "link": "https://stackoverflow.com/questions/6764329/optimizing-your-pyqt-applications",
        "document": "I'm not sure if this is exactly the same thing you are doing, but it sounds similar to something I have in some apps, where there is some list of custom widget. And it does significantly slow down when you are creating and destroying tons of widgets.\n\nIf its an issue of lesser amounts of total widgets, but just being created and deleted a lot, you can just create the widgets once, and only change the data of those widgets as information needs to be updated... as opposed to creating new widgets each time the information changes. That way you can even change the data from threads without having to worry about creating widgets.\n\nAnother situation is where you are displaying a list with custom widgets and there are a TON of results. I notice it always slows down when you have 1000's of custom widgets in a list. A trick my co-worker came up with was to have a fake kind of list where it is using a static number of slots in the display. Say, it shows 10 slots in the view. The scrollbar doesn't really scroll down across MORE widget...what it does is scrolls the DATA through the 10 visible widgets. You can a crazy performance increase doing that. But only if it is an acceptable display style for your application."
    },
    {
        "link": "https://stackoverflow.com/questions/72834216/qtreewidget-loading-large-numbers-of-items",
        "document": "After a lot of code restructuring and testing I can confirm that both 's suggestion:\n\nYou can create a QList of top level items and add children to each of the top level items using QTreeWidgetItem::addChild() or QTreeWidgetItem::addChildren(). And once you have the whole structure ready, you just call QTreeWidget::addTopLevelItems(). I.e. you insert all the items to the model in just one call.\n\nare the best solution! It might take some effort to restructure the code, but the result is great: no delays in rendering large numbers of items with.\n\nThank you both for the answer!"
    },
    {
        "link": "https://forum.qt.io/topic/1192/solved-big-performance-issue-with-treeview",
        "document": "I'm having big performance issues with a QTreeView and a custom model. I'm using PyQt 4.7.4 which is based on Qt 4.6.\n\nTo demonstrate the issue, I've created a 'one-child-per-parent' model, which is naturally as deep as it can get. Now, the issue becomes apparent when expanding the whole tree. It takes about 1.5 minutes to expand a tree of 5000 items on a Intel Core7 860. If I can't optimize performance, that would be a showstopper for my project, as I need to handle around 100000 items, however not as deeply nested. Profiling shows, that some methods like parent() of the QAbstractItemModel are called 12'503'272 times for a model with 5000 items!! This can't be the proper behaviour, can it?\n\nWhat's going on there? I would have thought it's Python related, but after having seen the profiling I'm puzzled.\n\nDoes anyone have similiar issues? Are there performance tipps besides the setting of the uniformRowHeights property? Or do I have to face the fact that Qt is not the right Gui toolkit for handling large data trees? (Which would be a shame, now that I've started to understand and to like it quite a lot.)\n\nAny thoughts and recommendations are highly appreciated."
    },
    {
        "link": "https://qtcentre.org/threads/51876-PyQt4-QTreeView-performance-issue",
        "document": "To copy to clipboard, switch view to plain text mode"
    },
    {
        "link": "https://stackoverflow.com/questions/27832814/qtreeview-or-qtreewidget",
        "document": "I want to implement in my program a tree with nested sub-levels, and I'm looking for which of those two kind(View/Widget) is best suited for my goal.\n\nI have a list of days with task that are either done/missed/failed, each task has a count of how many times it was done/missed/failed and lastly a score for that day.\n\nI want to display them like so:\n\nI made this example in QtCreator using a QTreeWidget, but I'm worried that it would be hard to modify the elements since they are stored somewhere else.\n\nAre my worries rational and should I go to the model/view structure, or can I easily get going with the QTreeWidget? The tree will be logging the task and thus will be constantly changing. Elements will only be added to it, not removed. And the days will be sorted from highest-lowest(day 2 is first, then day 1)"
    },
    {
        "link": "https://stackoverflow.com/questions/31167278/comparing-qtreeview-qabstractitemmodel-to-qtreewidget",
        "document": "I'm building a tool in PySide for Maya (3D software) that auto versions and saves files in a directory.\n\nI've spent the past few days trying to convert my initial QTreeWidget code into a model/view pattern with QTreeView and QAbstractItemModel to get tool tips and other functions, but I'm finding it harder than anticipated. When I'm learning a new coding language/technique I like to find two scripts that do the same thing- one with the new technique and one with the old technique. This way I can compare and breakdown what the new code is doing.\n\nMy big obstacle is that I'm having trouble finding a QTreeView sample that does what my QTreeWidget sample does. Also, most examples manually populate the QTreeView which doesn't help me much either. It would be great if someone could modify the QTreeView code so it does what my QTreeWidget code does. Comments on best practices for QTreeView would be great as well!\n\n1) gets a list of strings from a source and lists them in the first column\n\n2) gets the date from each string and places it in the second column"
    },
    {
        "link": "https://forum.qt.io/topic/64398/how-to-choose-between-qtreeview-qabstractitemmodel-vs-qtreewidget",
        "document": "QTreeWidget, QTableWidget, QListWidget are just convenience classes (for quick start of sorts. Documentation advises to use Model-View approach) which use Model-View architecture on low levels in any case. Meanwhile QTreeView-QAbstractItemModel approach gives you more flexibility during application developing despite it can look difficult first time.\n\nLet's consider an example like this: you displayed your information with QTreeWidget. Everything was looking good, but later your boss (or customer) asked you to show data as a table. You did similar steps for filling your newly created QTableWidget with data (QTreeWidget was deleted meanwhile so you had lost your previous results) and everything seems fine again. But later your boss asked you to show data both as a tree and as a table in different places of application. So you need to create tree widget from scratch again. Moreover you have duplicated data now so if it changes you need to be aware that you apply these changes to both widgets.\n\nWith Model-View approach your actions for that scenario could be these: fill model with data and show it like tree, then just change QTreeView to QTableView without model refilling and then just create another QTreeView and connect it to the same model. In that case you need to modify data once in model, and all connected views (maybe one, maybe two, maybe ten) will know about it and modify displayed content. So use Model-View approach everywhere instead of convenience widgets if you want to maintain your applications without bloody tears :-)"
    },
    {
        "link": "https://forum.qt.io/topic/64211/qtreewidget-vs-qtreeview",
        "document": "Your browser does not seem to support JavaScript. As a result, your viewing experience will be diminished, and you have been placed in read-only mode.\n\nPlease download a browser that supports JavaScript, or enable it if it's disabled (i.e. NoScript)."
    },
    {
        "link": "https://qtcentre.org/threads/51876-PyQt4-QTreeView-performance-issue",
        "document": "To copy to clipboard, switch view to plain text mode"
    }
]