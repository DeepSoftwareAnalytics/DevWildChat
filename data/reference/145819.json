[
    {
        "link": "https://learn.microsoft.com/en-us/cpp/cpp/abstract-classes-cpp?view=msvc-170",
        "document": "Abstract classes act as expressions of general concepts from which more specific classes can be derived. You can't create an object of an abstract class type. However, you can use pointers and references to abstract class types.\n\nYou create an abstract class by declaring at least one pure virtual member function. That's a virtual function declared by using the pure specifier ( ) syntax. Classes derived from the abstract class must implement the pure virtual function or they, too, are abstract classes.\n\nConsider the example presented in Virtual functions. The intent of class is to provide general functionality, but objects of type are too general to be useful. That means is a good candidate for an abstract class:\n\nThe only difference between this declaration and the previous one is that is declared with the pure specifier ( ).\n\nAbstract classes can't be used for:\n\nIf the constructor for an abstract class calls a pure virtual function, either directly or indirectly, the result is undefined. However, constructors and destructors for abstract classes can call other member functions.\n\nPure virtual functions in abstract classes can be defined, or have an implementation. You can only call such functions by using the fully qualified syntax:\n\nDefined pure virtual functions are helpful when you design class hierarchies whose base classes include pure virtual destructors. That's because base class destructors are always called during object destruction. Consider the following example:\n\nThe example shows how a Microsoft compiler extension lets you add an inline definition to pure virtual . You can also define it outside the class by using .\n\nWhen the object goes out of scope, the destructor for class is called. The compiler generates code to implicitly call the destructor for class after the destructor. The empty implementation for the pure virtual function ensures that at least some implementation exists for the function. Without it, the linker generates an unresolved external symbol error for the implicit call."
    },
    {
        "link": "https://stackoverflow.com/questions/9588788/good-practice-to-design-a-abcabstract-base-class-in-c",
        "document": "In java, we can define different interfaces and then later we can implement multiple interface for a concrete class.\n\nIn C++, generally speaking, we should avoid the usage of multiple inheritance, although multi-inheritance does have its edge on some situations.\n\nQuestion1> Based on the design of , should I improve any other things in order to make it a decent ABC?\n\nQuestion2> Is it true that a good should not contain member variables and instead variables should be kept in the subclasses?\n\nQuestion3> As I indicated in the comments, what if has to contain too many pure functions? Is there a better way?"
    },
    {
        "link": "https://geeksforgeeks.org/pure-virtual-functions-and-abstract-classes",
        "document": "Sometimes implementation of all functions cannot be provided in a base class because we don’t know the implementation. Such a class is called an abstract class.For example, let Shape be a base class. We cannot provide the implementation of function draw() in Shape, but we know every derived class must have an implementation of draw(). Similarly, an Animal class doesn’t have the implementation of move() (assuming that all animals move), but all animals must know how to move. We cannot create objects of abstract classes.\n\nA pure virtual function (or abstract function) in C++ is a virtual function for which we can have an implementation, But we must override that function in the derived class, otherwise, the derived class will also become an abstract class. A pure virtual function is declared by assigning 0 in the declaration.\n\nA pure virtual function is implemented by classes that are derived from an Abstract class.\n\n1. A class is abstract if it has at least one pure virtual function.\n\nIn the below C++ code, Test is an abstract class because it has a pure virtual function show().\n\n2. We can have pointers and references of abstract class type.\n\nFor example, the following program works fine.\n\n3. If we do not override the pure virtual function in the derived class, then the derived class also becomes an abstract class.\n\nThe following example demonstrates the same.\n\n4. An abstract class can have constructors.\n\nFor example, the following program compiles and runs fine.\n\n5. An abstract class in C++ can also be defined using struct keyword.\n\nIn Java, a class can be made abstract by using an abstract keyword. Similarly, a function can be made pure virtual or abstract by using an abstract keyword. See Abstract Classes in Java for more details.\n\nAn interface does not have an implementation of any of its methods, it can be considered as a collection of method declarations. In C++, an interface can be simulated by making all methods pure virtual. In Java, there is a separate keyword for the interface.\n\nWe can think of Interface as header files in C++, like in header files we only provide the body of the class that is going to implement it. Similarly in Java in Interface we only provide the body of the class and we write the actual code in whatever class implements it."
    },
    {
        "link": "https://ibm.com/docs/en/zos/2.4.0?topic=only-abstract-classes-c",
        "document": "An abstract class is a class that is designed to be specifically used as a base class. An abstract class contains at least one pure virtual function. You declare a pure virtual function by using a pure specifier ( ) in the declaration of a virtual member function in the class declaration.\n\nFunction is a pure virtual function. A function declaration cannot have both a pure specifier and a definition. For example, the compiler will not allow the following: You cannot use an abstract class as a parameter type, a function return type, or the type of an explicit conversion, nor can you declare an object of an abstract class. You can, however, declare pointers and references to an abstract class. The following example demonstrates this: struct A { virtual void f() = 0; }; struct B : A { virtual void f() { } }; // Error: // Class A is an abstract class // A g(); // Error: // Class A is an abstract class // void h(A); A& i(A&); int main() { // Error: // Class A is an abstract class // A a; A* pa; B b; // Error: // Class A is an abstract class // static_cast<A>(b); } Class is an abstract class. The compiler would not allow the function declarations or , declaration of object , nor the static cast of to type . The following is an example of an abstract class:Functionis a pure virtual function. A function declaration cannot have both a pure specifier and a definition. For example, the compiler will not allow the following:You cannot use an abstract class as a parameter type, a function return type, or the type of an explicit conversion, nor can you declare an object of an abstract class. You can, however, declare pointers and references to an abstract class. The following example demonstrates this:Classis an abstract class. The compiler would not allow the function declarationsor, declaration of object, nor the static cast ofto type\n\nVirtual member functions are inherited. A class derived from an abstract base class will also be abstract unless you override each pure virtual function in the derived class.\n\nThe compiler will not allow the declaration of object because is an abstract class; it inherited the pure virtual function from . The compiler will allow the declaration of object if you define function , as this overrides the inherited pure virtual function . Function needs to be overridden if you want to avoid the abstraction of .\n\nNote that you can derive an abstract class from a nonabstract class, and you can override a non-pure virtual function with a pure virtual function.\n\nThe default constructor of calls the pure virtual function both directly and indirectly (through ). You can call member functions from a constructor or destructor of an abstract class. However, the results of calling (directly or indirectly) a pure virtual function from its constructor are undefined. The following example demonstrates this:The default constructor ofcalls the pure virtual functionboth directly and indirectly (through)."
    },
    {
        "link": "https://stackoverflow.com/questions/65426888/defining-interfaces-abstract-classes-without-members-in-c",
        "document": "By an interface (C# terminology) I mean an abstract class with no data members. Thus, such a class only specifies a contract (a set of methods) that sub-classes must implement. My question is: How to implement such a class correctly in modern C++?\n\nThe C++ core guidelines [1] encourage the use of abstract class with no data members as interfaces [I.25 and C.121]. Interfaces should normally be composed entirely of public pure virtual functions and a default/empty virtual destructor [from C.121]. Hence I guess it should be declared with the keyword, since it only contains public members anyway.\n\nTo enable use and deletion of sub-class objects via pointers to the abstract class, the abstract class needs a public default virtual destructor [C.127]. \"A polymorphic class should suppress copying\" [C.67] by deleting the copy operations (copy assignment operator, copy constructor) to prevent slicing. I assume that this also extends to the move constructor and the move assignment operator, since those can also be used for slicing. For actual cloning, the abstract class may define a virtual method. (It's not completely clear how this should be done. Via smart pointers or from the Guidelines Support Library. The method using makes no sense to me, since the examples should not compile: the derived function still does not anything!?).\n\nIn C.129, the example uses interfaces with virtual inheritance only. If I understand correctly, it makes no difference if interfaces are derived (perhaps better: \"implemented\"?) using or , since they have no data that could be duplicated. The diamond problem (and related problems) don't exist for interfaces (which, I think, is the reason why languages such as C# don't allow/need multiple inheritance for classes). Is the virtual inheritance here done just for clarity? Is it good practice?\n\nIn summary, it seems that: An interface should consist only of public methods. It should declare a public defaulted virtual destructor. It should explicitly delete copy assignment, copy construction, move assignment and move construction. It may define a polymorphic clone method. I should be derived using .\n\nOne more thing that confuses me: An apparent contradiction: \"An abstract class typically doesn't need a constructor\" [C.126]. However, if one implements the rule of five by deleting all copy operations (following [C.67]), the class no longer has a default constructor. Hence sub-classes can never be instantiated (since sub-class constructors call base-class constructors) and thus the abstract base-class always needs to declare a default constructor?! Am I misunderstanding something?\n\nBelow is an example. Do you agree with this way to define and use an abstract class without members (interface)?"
    },
    {
        "link": "https://geeksforgeeks.org/inheritance-in-c",
        "document": "The capability of a class to derive properties and characteristics from another class is called Inheritance. Inheritance is one of the most important features of Object Oriented Programming in C++. In this article, we will learn about inheritance in C++, its modes and types along with the information about how it affects different properties of the class.\n\nSyntax of Inheritance in C++\n• derived_class_name : name of the new class, which will inherit the base class\n• access-specifier : Specifies the access mode which can be either of private, public or protected. If neither is specified, private is taken as default.\n• base-class-name : name of the base class.\n\nTo better understand inheritance and other OOP principles, enroll in our Complete C++ Course, which breaks down inheritance, polymorphism, and encapsulation in C++.\n\nExamples of Inheritance in C++\n\nThe following programs demonstrate how to implement inheritance in our C++ programs.\n\nExample 1: Program to Demonstrate the Simple Inheritance of a Class\n\nIn the above program, the ‘Child’ class is publicly inherited from the ‘Parent’ class so the public data members of the class ‘Parent’ will also be inherited by the class ‘Child’.\n\nExample 2: Access the Inherited Members of the Base Class in Derived Class\n\nIn the above example, we have accessed the public members of the base class in the derived class but we cannot access all the base class members directly in the derived class. It depends on the mode of inheritance and the access specifier in the base class.\n\nModes of Inheritance in C++\n\nMode of inheritance controls the access level of the inherited members of the base class in the derived class. In C++, there are 3 modes of inheritance:\n\nIf we derive a subclass from a public base class. Then the public member of the base class will become public in the derived class and protected members of the base class will become protected in the derived class.\n\nIf we derive a subclass from a Protected base class. Then both public members and protected members of the base class will become protected in the derived class.\n\nIf we derive a subclass from a Private base class. Then both public members and protected members of the base class will become private in the derived class. They can only be accessed by the member functions of the derived class.\n\nPrivate mode is the default mode that is applied when we don’t specify any mode.\n\nThe below table summarizes the above three modes and shows the access specifier of the members of the base class in the subclass when derived in public, protected and private modes:\n\nExample 1: Program to show different kinds of Inheritance Modes and their Member Access Levels\n\nExample 2: Program to Access the Private Members of the Base Class in Derived Class\n\nThe above program shows the method in which the private members of the base class remain encapsulated and are only accessible through controlled public or protected member functions.\n\nWe can also access the private members of the base class by declaring the derived class as friend class in the base class.\n\nTo know more about access modes in a C++ class, refer to the article – Access Modifiers in C++\n\nTypes Of Inheritance in C++\n\nThe inheritance can be classified on the basis of the relationship between the derived class and the base class. In C++, we have 5 types of inheritances:\n\nIn single inheritance, a class is allowed to inherit from only one class. i.e. one base class is inherited by one derived class only.\n\nMultiple Inheritance is a feature of C++ where a class can inherit from more than one class. i.e one subclass is inherited from more than one base class.\n\nHere, the number of base classes will be separated by a comma (‘, ‘) and the access mode for every base class must be specified and can be different.\n\nMUST READ – Multiple Inheritance in C++\n\nIn this type of inheritance, a derived class is created from another derived class and that derived class can be derived from a base class or any other derived class. There can be any number of levels.\n\nMUST READ – Multilevel Inheritance in C++\n\nIn this type of inheritance, more than one subclass is inherited from a single base class. i.e. more than one derived class is created from a single base class.\n\nHybrid Inheritance is implemented by combining more than one type of inheritance. For example: Combining Hierarchical inheritance and Multiple Inheritance will create hybrid inheritance in C++\n\nThere is no particular syntax of hybrid inheritance. We can just combine two of the above inheritance types.\n\nBelow image shows one of the combinations of hierarchical and multiple inheritances:\n\nIn multipath inheritance, a class is derived from two base classes and these two base classes in turn are derived from one common base class. An ambiguity can arise in this type of inheritance in the most derived class. This problem is also called diamond problem due to the diamond shape formed in the UML inheritance diagram.\n\nMUST READ – Hybrid Inheritance in C++\n\nConstructors and Destructors are generally defined by the programmer and if not, the compiler automatically creates them so they are present in every class in C++. Now, the question arises what happens to the constructor and destructor when a class is inherited by another class.\n\nIn C++ inheritance, the constructors and destructors are not inherited by the derived class, but we can call the constructor of the base class in derived class.\n• None The constructors will be called by the complier in the order in which they are inherited. It means that base class constructors will be called first, then derived class constructors will be called.\n• None The destructors will be called in reverse order in which the compiler is declared.\n• None We can also call the constructors and destructors manually in the derived class.\n\nMUST READ – Order of Constructor/ Destructor Call in C++\n\nIn Inheritance, we can redefine the base class member function in the derived class. This type of inheritance is called Function Overriding. Generally, in other programming languages, function overriding is runtime polymorphism but in C++, we can do it at both runtime and complile time. For runtime polymorphism, we have to use the virtual functions.\n\nMUST READ – Function Overriding in C++\n\nWhat are a base class and a derived class?\n\nWhat are the rules for calling a base class constructor in a derived class?"
    },
    {
        "link": "https://unstop.com/blog/inheritance-in-cpp",
        "document": "Multilevel Inheritance In C++ | Syntax, Uses And More (+Examples)\n\nStatic Member Function In C++: How to Use Them, Properties, & More\n\nC++ Find() In Vector | How To Find Element In Vector With Examples\n\nHow To Print A Vector In C++ | 8 Methods Explained With Examples\n\nDo-While Loop in C++: How It Works, Syntax, and Examples\n\nUnderstand The While Loop In C++ & Its Variations With Examples!\n\nSwitch Case In C++ (Statement), Uses, Break & More With Examples\n\nWhat Are Storage Classes In C++? A Detailed Guide With Examples\n\nLogical Operators In C++ | Use, Precedence & More (With Examples)\n\nNew Operator In C++ | Syntax, Working, Uses & More (+Examples)\n\nDifference Between Pointer And Reference In C++ (With Examples)\n\nThe 'this' Pointer In C++ | Declare, Use, Code Examples & More\n\nPointers in C++ | A Roadmap To All Pointer Types (With Examples)\n\nTypedef In C++ | Syntax, Application & How To Use (+Code Examples)\n\nInheritance In C++ & Its 5 Types Explained With Multiple Examples\n\nInheritance in C++ is a process by which a new class can inherit the attributes and methods of an existing class. The existing class is then called the parent class, and the inheriting class is called the child class.\n\nIn the world of programming, building efficient and maintainable software is a constant pursuit. In this endeavour, one of the most fundamental and powerful concepts is inheritance. It is a cornerstone of object-oriented programming (OOP) concepts that empower developers to create new classes that inherit attributes and behaviours from existing ones. The mechanism of inheritance in C++ programming fosters code reusability and lays the foundation for structuring and organizing code in a way that mirrors real-world relationships.\n\nIn this article, we will explore what inheritance in C++ is, how it works, its types and practical use cases with some real-life examples.\n\nWhat Is Inheritance In C++?\n\nInheritance in C++ language is a core concept of object-oriented programming (OOP) that allows you to create new classes (derived classes or child classes) based on existing classes (base classes or superclasses). It enables a subclass to inherit all the properties of the base class and add some new features to itself.\n\nLet’s understand it clearly with the help of a real-life example:\n\nTo begin with, let's assume that inheritance does not exist. Then, consider the term animal, which consists of all types of animals. Here, you will have to create classes for all different types of animals, like Dogs, Cats, and Tigers. The methods speed(), eating(), and running() will be the same for all three classes. If we avoid inheritance while creating these classes, then we have to write all these methods for each class as shown below:\n\nYou can see that this process leads to replication of the same code 3 times. That is, we created 3 individual/ independent classes, each of which has a repetition of the same methods. This increases the redundancy in code and makes it prone to error.\n\nIn contrast, if inheritance existed, then we could avoid this kind of situation. How? Well, you could create a parent class called Animal with the three methods. You could then inherit the three classes (Dogs, Cats, and Tigers) from the Animal class. This reduces unnecessary repetitions, making the code much more meaningful (refer to the diagram below).\n\nThis example showcases how inheritance simplifies code development by allowing new classes to inherit properties and behaviours from existing ones, promoting code reuse and maintainability.\n\nWhat Are Child And Parent Classes?\n\nInheritance introduces the concepts of the child (derived) and parent (base) classes. That is:\n• child class (derived) - the class that inherits from another class\n• parent class (base) - the class being inherited from\n\nA child class inherits properties and behaviours from a parent class, allowing you to create specialized classes while reusing common attributes and functionalities. Think of it as a family tree where the characteristics are passed down from parents to children. In the previously explained example, the Dog, Cat, and Tiger class (child) inherits the attributes and methods from the Animal class (parent).\n\nInheritance in C++ represents an is-a relationship between the child and parent classes. This means that an object of a child class is also an object of the parent class. For instance, if the Car class is derived from the Vehicle class, you can say that a car is-a vehicle, or if Cat is derived from Animal, you can also say that a cat is-a(an) animal.\n\nSyntax And Structure Of Inheritance In C++\n\nThe structure of inheritance in C++ contains a child class, which inherits the attributes and methods, and a parent class. The syntax for defining a parent and child class in all types of inheritance in C++ is explained below.\n• class: It is the keyword for creating a new class.\n• ParentClassName: It is the name of the base class or parent class.\n• ChildClassName: It is the name of the derived class or child class.\n• Visibility_mode: It is the access specifier that determines how inherited members are visible in the derived class (public, protected, or private).\n• If neither visibility mode is specified, it takes private as the default mode.\n• Private members of the base class never get inherited by the child class.\n• If the public members of the base class are privately inherited by the child class, then they become the private members of the child class. Thus, the public members of the base class are only accessible by the member functions of the child class, not by the object of the child class.\n\nWhen implementing inheritance in C++ programs, you must clearly indicate which class is inheriting from the other class. The syntax to be used when creating a child class that inherits the properties of the base class is given below.\n\nSyntax For Implementing Inheritance In C++:\n• The class keyword indicates that we are creating a new class and the colon symbol (:) is the indicator of inheritance in C++.\n• base_class_name is the name of the base class.\n• derived_class_name is the name of the class that will inherit the properties of a base class.\n• access_specifier defines the visibility mode through which the derived class has been created (public, private, or protected mode).\n\nIn a later section, we’ll discuss public, private, and protected modes of inheritance in C++ detail. But before that, let's understand how to implement inheritance in C++ with example program below.\n\nIn this simple C++ program, a class Dog is derived from the class Animal, and the speak() function is overridden in Dog to provide a specialized behaviour.\n• We begin by including the <iostream> header file for input/ output operations and namespace std to use its classes without calling it.\n• As mentioned in the code comments, we create a parent or base class Animal and define the speak() function, which prints a statement using the cout command. The use of a public access modifier makes the function publicly accessible.\n• Then, we create another class, Dog, which inherits the Animal class with the public access modifier. This is the child class.\n• Inside the Dog class, we use the public access modifier to create the speak() function that overrides the function from the base class.\n• In the main() function, we create two objects, animal and dog, of the Animal and Dog classes, respectively.\n• We then use the dot operator (>) and class objects to call the speak() methods from both classes.\n• The first call invokes the Base class function, and the second call invokes the method from the derived class.\n• The program finally terminates with a return 0 statement indicating successful execution without any errors.\n\nImportance Of Inheritance In C++\n\nInheritance is one of the fundamental features of object-oriented programming (OOP) and is especially important in C++. It allows you to create new classes based on existing classes, inheriting their attributes and behaviours. Here are some of the key reasons why inheritance in C++ is important:\n• Polymorphic Containers: Inheritance in C++, combined with polymorphism, enables you to create containers (e.g., arrays or collections) that can hold objects of different derived classes but still operate on them using common base class interfaces. This is valuable for creating data structures and algorithms that work with heterogeneous data.\n• Method Overriding: Inheritance in C++ allows derived classes to provide their own implementations of base class member functions through a mechanism called method overriding. This is particularly useful when you want to customize the behaviour of a derived class while maintaining a consistent interface defined in the base class.\n• Conceptual Modeling: Inheritance in C++ allows you to model real-world relationships between objects. For example, in a system for modelling animals, you can have a base class, Animal, and derived classes like Dog, Cat, and Bird, which accurately represent the inheritance hierarchy in the real world.\n• Encapsulation: Inheritance in C++ supports the principle of encapsulation, which involves bundling data and methods into a single unit (class). By inheriting from base classes, you can access and manipulate the data and methods of the base class within the derived class, following the access control rules defined in C++.\n• Behavioural Classification: Inheritance in C++ allows you to classify objects based on their behaviours or characteristics. For example, you can have a base class Vehicle and derived classes like Car and Motorcycle, which share common characteristics and behaviours specific to vehicles.\n• Template for Design Patterns: Many design patterns, such as the Factory, Singleton, and Strategy patterns, rely on inheritance to implement their solutions. Inheritance in C++ provides a foundation for creating and using these design patterns effectively.\n• Better Code Organization: The concept of inheritance in C++ helps in organizing and structuring your code in a more logical and systematic manner, making it easier to understand and navigate.\n• Framework and Library Design: Inheritance in C++ programs is crucial when designing frameworks and libraries. Frameworks often provide base classes with defined behaviours, allowing users to create derived classes tailored to their specific requirements. This approach encourages standardization and reuse in software development.\n\nCheck this out- Boosting Career Opportunities For Engineers Through E-School Competitions\n\nTypes Of Inheritance In C++\n\nThere are five different types of inheritance in C++ based on how the derived class inherits the base class features. These five types are as follows:\n\nIn this section, we will discuss all these types in greater detail with the help of code examples.\n\nIn single inheritance, a derived class inherits from a single base class, i.e., a child class inherits from a single parent class. As shown in the diagram above, class B (which is the subclass) inherits the properties of class A, which is the only parent class.\n\nFor example, consider Vehicle as a base class and a Car as the child class inherited only from it. It is also referred to as single level inheritance.\n\nSyntax For Single Inheritance In C++:\n• BaseClass and DerivedClass are the names of the base/ parent and derived/child classes, respectively.\n• The classes are created using the class keyword.\n• The access_modifier is the specifier that determines the mode of visibility of the inherited members in the derived class.\n\nLet’s understand single inheritance in C++ with an example program.\n\nWe begin the C++ code example by including essential header files and the namespace std to use its classes without the need to call it every time.\n• Then, we create a class P with two integer variables/ data members, x and y, that are initialized with the values 6 and 7, respectively.\n• We also define a product() function inside the P class, which calculates and returns the product of x and y, stored in variable z. The use of the public keyword makes the function publicly accessible to the inherited class objects.\n• Next, we create another class, C, which inherits the P class with the private access modifier. Inside the class-\n• We define a display() function, which further calls the product() function whose result is stored in the ans variable, and it prints a phrase using the cout command.\n• Also, we use the keyword public inside the class to define this function.\n• Inside the main() function, we create an object res of the derived class C.\n• Then, using the dot operator and the derived class object, we call the display() method, which invokes the product() function.\n• The product of x and y gets stored in the ans variable, and the output is printed to the console.\n\nIn multiple inheritance, a subclass inherits from multiple base classes, i.e., a child class inherits from more than one parent class. For example, say there are two base classes, Animal and FlyingObject. The former includes all types of animals, and the latter includes all types of flying objects. Then, a Bird class can be said to inherit from both Animal and FlyingObject classes.\n\nSyntax For Mulitple Inheritance In C++:\n• The class keyword indicates the creation of a new class.\n• B1 and B2 are the names for base classes or parent classes.\n• DerivedClass is the name of the derived class or child class. Note that we use the comma operator to separate the two base classes for the derived class.\n• The access_modifier determines how inherited members are visible in the derived class.\n\nLet’s look at an example showcasing the implementation of multiple inheritance in C++.\n\nIn the sample C++ program-\n• We first include the <iostream> header file and the namespace std and then create a class called Animal. Inside the class-\n• We define the member function animal(), which takes a string as input and displays it using the cout command.\n• The use of a public access modifier makes the function publicly accessible to the inherited class objects.\n• Next, we create another class Aerial, with a public member function aerial(), that takes a string as input and uses cout to print a phrase with the string.\n• Then, we create the class Bird, which inherits Animal and Aerial with a private access modifier. Inside the Bird class-\n• This function inherits the animal() and aerial() methods from the Animal and Aerial class, respectively.\n• Inside the main() function, we first create an object B of class Bird.\n• Then, using the dot operator and the object, we call the display() method while passing the string variable 'Eagle' as input.\n• This invokes the animal() and aerial() functions from the parent classes and prints the output to the console.\n\nAlso read: Multiple Inheritance In C++ & Diamond Problem Resolution (Examples)\n\nIn multilevel inheritance, a derived class becomes the base class for another derived class. As shown in the diagram above, class C inherits from class B, which in itself inherits from the class A. To better understand the concept, let's consider a simple example of the human biological relationships where we have three classes- Child, Parent, and Grandparents. Here, the Child class inherits from the Parent class, and the Parent class inherits from the Grandparent class.\n\nSyntax Of Multilevel Inheritance In C++:\n• The class keyword indicates the creation of classes, including two base classes with names B1 and B2 and a derived class with the name DerivedClass.\n• access_modifier is the access specifier that determines how inherited members are visible in the derived class.\n\nTo further understand the concept of multi level inheritance in C++, let's take a look at an example C++ code which showcases the implementation of the same.\n\nIn the code example above,\n• We create a class Vehicle and define a constructor Vehicle() inside it, with a public access modifier. The function prints a string message- 'This is a Vehicle.' and the newline escape sequence shifts the cursor to the next line.\n• Next, we create a derived class, FlyingObject, which inherits from Vehicle. Inside the class, we define the FlyingObject() constructor, which prints a phrase using cout. This makes the function publicly accessible to the inherited class objects.\n• Following this, we create another class, Aeroplane, which inherits the FlyingObject class with the public access modifier.\n• Inside the Aeroplane class, we use the public access modifier to define the display() constructor function, which inherits all the methods of the FlyingObject class.\n• Inside the main() function, we create an object obj of class Aeroplane.\n• This creation of the object of the Aeroplane class leads a chain of calls to constructors of all classes.\n• The constructors are called in the sequence of inheritance, i.e., first the constructor of the base class FlyingObject is invoked, which further invokes the constructor of the base class of FlyingObject, i.e., class Vehicle.\n• The output is printed to the console, and the program terminates with return 0.\n\nHybrid inheritance in C++ is a combination of more than one inheritance type within the same program. This is also called virtual inheritance in C++. For example, a complex hierarchy involving multiple types of inheritance. Since it is a combination of more than one inheritance, there is no fixed syntax for it. So, let's take a look at an example to get a better understanding of this concept.\n\nIn the code above-\n• We begin by including the necessary headers and then create a class X, with a public data member x (of data type int) and the getX() function. The function takes an input value of the x variable using cin command.\n• Next, we create a derived class Y, which publically inherits from class X. Inside the class, we declare an integer variable y and define the function getY().\n• The getY() function prompts the user to input a value for y using cout, and it reads the value using cin.\n• Following that, we create another class Z with an integer data member z and a getZ() function.\n• Next, we create another class, A, which inherits from both Y and Z. Inside the class A, we declare an integer variable, d, and define a Product() function.\n• The function invokes the functions from classes X, Y, Z, to get values for three variables, then calculates the product of the three variables using the multiplication arithmetic operator, and finally prints it to the console.\n• Inside the main() function, we create an object obj of class A and use this object with the dot operator to call the Product() function.\n• As a result, functions getX(), getY(), and getZ() get called, prompting the user to input values of x, y, and z.\n• After the values are entered, the Product() function calculates the product, and the output is printed to the console.\n\nNote- Here, x = 4, y = 5, and z = 6 are taken as input. There is a single inheritance between classes X and Y. Multiple inheritance between classes A, Y, and Z. Class A inherits classes Y and Z. Multilevel inheritance between classes A, Y, and Z. Class Y inherits class X, and class A inherits class Y.\n\nIn hierarchical inheritance, multiple derived classes inherit from a single base class, i.e., more than one child class inherits from a single parent class. For example, say we have a parent class Animal which consists of all types of animals. Then the Dog class, Cat class, Horse class, etc., are all sub-classes of Animal or all inherit from the Animal class.\n\nSyntax For Hierarchial Inhertiance In C++:\n• The keyword class indicates that we are declaring a class, and access_modifier indicates the mode of visibility for its members.\n• B, D1, D2, and D3 refer to the names of the base/ parent class and its derived classes.\n\nNow, let's look at a C++ program that showcases how hierarchical inheritance works in action.\n\nThe code example above shows how two classes, Mango and Durain, that inherit from the same base class, Fruit.\n• First, we create the class Fruit with a public member function display(). This makes the function publicly accessible to the inherited class objects.\n• The display() function prints the phrase 'This is a fruit.' to the console using the cout command.\n• Next, we create two derived classes, Mango and Durian, which inherit the Fruit class with the public access modifier. This way, Durian and Mango inherit the display method from the Fruit class.\n• Inside the main() function, we create two objects, obj1 of class Mango and another object, obj2 of class Durian.\n• We then use the dot operator to call the display() method on these objects, which they inherit from the Fruit class.\n• As a result, the display() function prints the string message twice. This shows that the inherited classes can access the member function of the class they inherit from.\n\nVisibility Modes Of Inheritance In C++\n\nVisibility modes control the accessibility of inherited members in the derived class. In other words, the visibility mode explains how the inherited members of the base class will be accessible to the derived class.\n\nThere are three access modes, i.e., public visibility mode, protected visibility mode, and private visibility mode. In this section, we will discuss these types of visibility modes in detail.\n\nPublic Visibility Mode Of Inheritance In C++\n\nPublic visibility mode is when we derive a class from a parent class with the public keyword. This is referred to as public inheritance, and all the members retain their visibility in the derived class.\n\nThat is, when we derive a class in public mode, the members of the base class that are public remain public in the derived class, members that are protected in the parent class remain protected in the derived class, and private members are inaccessible.\n• The class keyword is used for creating a new class.\n• BaseClass and DerivedClass are the names of the nase/ parent and the derived/ child class, respectively.\n• The public keyword/ access specifier makes all the members inherited from the BaseClass public only if the members being inherited are public in the BaseClass.\n\nIn this example for public visibility mode-\n• We create a class Animal after including the necessary header files and namespace.\n• Inside the Animal class, we define the speak() function, which prints a phrase using the cout command.\n• When defining the function, we use the public access modifier to ensure that it is publicly accessible to all derived classes from anywhere in the program.\n• Next, we create a class, Dog, which is derived from the Animal class, in public mode, which means objects of the Dog class can access the public members of the base class.\n• Inside the main() function, we create an object dog of the Dog class and use the dot operator to call the speak() function on the object.\n• This invokes the speak() function from the base class, and the output is printed to the console.\n\nSo, as shown, the Dog class is derived from Animal, and the speak function from the Animal class is publicly accessible to the Dog class.\n\nProtected Visibility Mode Of Inheritance In C++\n\nThe protected mode refers to the situation where we derive a class from a base class using the protected keyword. As a result of this, the protected and public members of the base class become protected in the derived class, and private members remain inaccessible.\n\nAnd these protected members can only be accessed by the derived class and its member functions. Also, any subclass can inherit these protected members, with the exception of private members.\n• The class keyword, BaseClass, and DerivedClass all remain the same from the syntax for private visibility mode.\n• The access specifier protected here indicates that the derived class has protected inheritance. That is, all its members are protected only if inherited members are public or protected in BaseClass.\n\nNow, let's take a look at an example to build a deeper understanding of this concept.\n\nIn the code example above,\n• We create a parent class Animal with a public member function speak(), which prints a phrase using the cout command.\n• Next, we create a derived class, Dog, using the protected keyword/ access modifier. This means that only the Dog class member functions can access the member functions of the Animal class, that too from inside the derived class only.\n• We then define a display() function inside Dog, which further calls on the speak() function from the base class.\n• Inside the main() function, we create an object dog of the Dog class and call the display method using the dot operator.\n• This invokes the speak() method inherited from the Animal class, and the result is shown in the output window.\n\nPrivate Visibility Mode Of Inheritance In C++\n\nThe private mode of visibility also referred to as private inheritance, is when we derive a class with the use of the public keyword. In this case, all the members of the parent class (i.e., public, protected, or private) become private when inherited by the child class.\n\nAs a result, these members are only accessible inside the derived class or their access is restricted outside of the derived class. Also, only the member functions or friend functions of the derived class can access these private members.\n• A major part of the syntax is the same as in the case of both the private and public visibility modes. The only difference is the access modifier and its implications.\n• The private access specifier implies that all the inherited members from the base class turn private for the derived class.\n\nIn the code example above-\n• We first create a parent class called Animal, which contains a public member function speak() that prints a phrase using the cout command. and This means that the function is publicly accessible to the derived class.\n• Next, we create a derived class, Dog, which inherits the Animal class with the private access modifier. This means that the member functions of the Animal class are only accessible inside the Dog class, not by its objects from outside of the class.\n• The Dog class also contains a public member function display(), which contains the speak() function in the code body.\n• Inside the main() function, we then create an object dog of the Dog class and use the dot operator to call the display() method.\n• As mentioned, we can't use the object to call the parent class member function directly since the derived class is in private mode.\n• So, we use the object to call the display() function, which further invokes the speak method from the Animal class.\n• The result is then printed on the output console before the program terminates with a return 0.\n\nIf we were to use the object of the Dog class to call the speak() function directly, it would have generated an error. This is because the derived class inherits the parent class in private mode (i.e., private inheritance). So, as the Dog class privately inherits the Animal class, the member function of the Animal class is accessible only inside the Dog class, not by its objects outside of the class.\n\nAccess modifiers, such as public, protected, and private, are used to control the visibility and accessibility of class members. They also play a role in inheritance in C++.\n• public: Members are accessible from any part of the program.\n• protected: Members are accessible within the class and inside its derived classes.\n• private: Members are accessible only within the class.\n\nWe use these access modifiers to define the visibility mode of a class for inheritance in C++, as discussed in the section above.\n\nThe private members are not inheritable from the base class to the derived class. This means the member functions of the base class are not accessible to the derived class and its objects. Private members of the base class can be inherited in the two following ways-\n• Changing the visibility mode of base class members from private to public. However, there is a point of concern with this method that is, it will remove the data-hiding property of the private access modifier.\n• Changing the visibility mode from private to protected. This method retains the data-hiding property of the private mode. Changing the private member to protected makes it inheritable and accessible within the class and to the member function of the derived class.\n\nIn the C++ code example-\n• We create a parent class called BaseClass with a protected member function called show(), which prints a phrase to the console using cout.\n• The protected keyword makes the member functions of the BaseClass accessible only within the parent class or by the derived class, not by the objects of the derived class.\n• We then create a DerivedClass class, which inherits the parent class with a public access modifier.\n• The DerivedClass contains a public member function display() which invokes the show() method from the base class.\n• Inside the main() function, we create an object obj of DerivedClass and use a dot operator to call the display() method.\n• As mentioned in the code comments, if we were to use the object to call the show() method, it would throw an error as the data is in protected mode. The data-hiding property will remain enforced.\n• So, when we call the display method, it, in turn, invokes the show() method, and the output is displayed, as seen in the output window.\n\nMember Function Overriding In Inheritance In C++\n\nMember function overriding allows derived classes to provide their own implementations of a function that is already defined in the base class. To achieve this, you use the virtual keyword in the base class.\n\nTo understand this, consider the relationship between RBI (The Reserve Bank of India) and other banks like SBI, HDFC, ICICI, etc. Since RBI is the parent/ governing body that stipulates rules and regulations, all the banks follow the same regulatory functions and orders. However, each bank can override certain aspects of the rules, for example, the amount of loan that the bank has given, etc.\n• virtual returnType functionName(parameters) { ... }: In the base class, a virtual member function named functionName is declared. The virtual keyword indicates that this function can be overridden by derived classes.\n• returnType specifies the data type of the value the function returns, and parameters refer to the function's input values.\n• { // Base class implementation }: Within the curly braces, you define the implementation of the functionName in the base class.\n• class Derived: public Base { ... }: This defines a derived class named Derived, publicly inheriting from the base class Base.\n• returnType functionName(parameters) override { ... }: In the derived class, you declare a function with the same name, return type, and parameter list as in the base class.\n• The override keyword explicitly indicates that this function is intended to override the base class function.\n• { // Derived class implementation }: Here, you provide the specific implementation of the functionName in the derived class.\n\nIn this example,\n• We define a base class Animal with a virtual function speak(). The speak() function prints Animal speaks.\n• Then, we create a derived class Dog that inherits from Animal. In the Dog class, we override the speak() function to print 'Dog barks'.\n• In the main() function, we create two objects, Animal and Dog, of the base and child class, respectively, using the new operator.\n• Then, we assign these objects to the pointers myAnimal and myDog.\n• Next, we use the objects and 'this' pointer to call the speak() function on both objects.\n• When we call myAnimal->speak(), it invokes the base class's speak() function, printing 'Animal speaks'.\n• When we call myDog->speak(), it invokes the overridden function in the Dog class, printing 'Dog barks'.\n• We delete the dynamically allocated objects to free memory.\n\nThe Diamond Problem | Inheritance In C++ & Ambiguity\n\nThe diamond problem is a specific issue that arises in object-oriented programming languages that support multiple inheritance in C++. It occurs when a class inherits from two or more classes that have a common base class. This situation can lead to ambiguity and complications in the inheritance hierarchy.\n\nFor example, from the above image, you can see that both Class B and Class C inherit Class A, i.e., they both inherit the same member functions of Class A. Also, Class D inherits both Class B and Class C, i.e., Class D indirectly will have two copies of Class A, one from Class B and another from Class C.\n\nIf we need to access the data member of Class A through the object of Class D, we must specify the path to access Class A, as the compiler can’t differentiate between the two copies of x in Class A in Class D.\n\nConsider the following classes:\n\nNow, the Car class consists of all car types (objects) and various functions like fuel consumption, average, breaking mechanism, etc. The classes FuelCar and ElectronicCar inherit from the parent class and have their own d definition of functions. So we have one parent class with two child classes.\n\nNext, the HybridCar class inherits properties from both the segment of fuel and electronic cars. Now, here, the diamond problem will occur as follows:\n• FuelCar and ElectronicCar both share some common properties inherited from the Car class.\n• So when the HybridCar inherits from FuelCar and ElectronicCar, it will have two sets of the shared features it indirectly inherits from the Car class.\n\nThis gives rise to a conflict or ambiguity in the properties inherited from Car by both FuelCar and ElectronicCar. That is, the HybridCar may not know which version of the shared feature to inherit. This creates a diamond-like shape in the inheritance hierarchy as follows:\n• FuelCar and ElectronicCar represent the derived classes, each inheriting from Car but potentially adding or modifying properties.\n• HybridCar represents a new generation that inherit from both FuelCar and ElectronicCar, potentially causing a conflict when there are conflicting properties or methods inherited from Car.\n\nWays To Avoid Ambiguity Inheritance In C++\n\nAvoiding ambiguity in programming is essential for writing clear and error-free code. Ambiguity occurs when the compiler or interpreter cannot determine the correct interpretation of a statement due to multiple possible meanings. There are two ways to avoid ambiguity these are-\n\nWe will discuss both these methods in detail in this section.\n\nYou can use the scope resolution operator (::) to specify which base class member you want to access, i.e., it lets you manually specify the path from which the data member will be accessed.\n\nIn the code example above,\n• We first define a parent class A with a public data member, x, of data type integers.\n• Next, we create two classes B and C, that inherit from class A in public mode. Both the classes contain one integer variable y and z respectively.\n• Then we create a fourth class D, which inherits from classes B and C. The use of public specifiers indicates public visibirly mode.\n• In the main() function, we first create an object obj of class D. Then-\n• obj.B :: x = 4 sets the x variable in class A through the B part of obj.\n• obj.z = 7 sets the z variable in class C.\n• obj.product = obj.B :: x * obj.y * obj.z; calculates the product of x, y, and z, and stores it in the product variable.\n• cout << \"The product is: \" << obj.product << \"\n\n\" prints the product on the console, after which the program terminates.\n\nAlthough the scope resolution operator removes the ambiguous situation. But still, there are two copies of the base class in the derived class. To resolve this problem, you can use the virtual keyword and employ virtual inheritance. Here's an example:\n\nIn the code example above,\n• First, we create a class A and use the public access specifier to declare the integer variable x. This makes the variable publicly accessible to the inherited classes.\n• Then, we create two other classes, class B and class C, both of which inherit class A in public mode with the virtual keyword. This makes only one copy of the base class to any derived child class, i.e., class D will have only one copy of x.\n• Inside classes B and C, we use the public access specifier to declare the variables y and z, respectively.\n• We then create class D, which inherits classes B and C with a public access specifier. Thus, it inherits the data members of B and C, with only one copy of the data members of class A.\n• Inside class D, we use the public access modifier and declare an integer variable product.\n• Inside the main() function, we create an object obj of class D. Since ambiguity is resolved, we can directly access the value of x without any error.\n• We then use the product data member of obj to store the product of x, y, and z.\n• Lastly, we use the cout class to display the product, as seen in the output window.\n\nWhy & When To Use Inheritance In C++?\n\nInheritance in C++ is a fundamental concept in object-oriented programming (OOP) that allows you to create new classes based on pre-existing classes.\n• Inheritance in C++ is used when you want to create a new class that shares attributes and behaviours of an existing class, forming an 'is-a' relationship.\n• It is particularly useful when you want to promote code reusability and maintainability by avoiding redundancy.\n• We also use inheritance in C++ when we have a hierarchy of related classes and we want to define a common base class that encapsulates shared functionality while allowing derived classes to extend or specialize that functionality.\n• Inheritance in C++ is also valuable when you want to leverage polymorphism to write more flexible and extensible code, enabling objects of different classes to be treated uniformly through a base class interface.\n\nHowever, it's essential to carefully consider the design of your class hierarchy to ensure it accurately reflects the relationships between your objects and that inheritance in C++ is the most appropriate solution for your specific problem, as overusing inheritance can lead to complex and tightly coupled code.\n\nAdvantages Of Inheritance In C++\n\nInheritance in C++ offers a wide range of advantages varying from reusability to enabling polymorphism in the code. Some of these are mentioned below:\n• Code Reusability: Inheritance allows you to create a new class (the derived or subclass) based on an existing class (the base or superclass). This reuse of code is one of the primary benefits of inheritance in C++. You can avoid duplicating code by inheriting and extending existing classes.\n• Hierarchy and Organization: Inheritance in C++ enables you to create a hierarchy of classes that model real-world relationships. For example, you can create a hierarchy of shapes with a base class Shape and derived classes like Circle and Rectangle. This hierarchy can make your code more organized and intuitive.\n• Polymorphism: Inheritance is closely tied to polymorphism, which allows objects of different derived classes to be treated as objects of the base class. This essential feature enables you to write more generic and flexible code that can work with various derived classes without knowing their specific types.\n• Easier Maintenance: When you need to make changes to shared functionality or properties, you can do so in the base class, and those changes will automatically apply to all derived classes. This way, inheritance in C++ reduces the risk of errors and makes maintenance more efficient.\n• Specialization: Derived classes can specialize and add unique key features or behaviours to the base class. This specialization allows you to model specific aspects of your application accurately while maintaining a common interface through inheritance in C++.\n• Extensibility: Derived classes can extend and customize the functionality of base classes. This is also called as transitive nature of inheritance. For example, functional overriding in derived classes to perform specialized functions.\n• Modularity: Inheritance in C++ enhances code organization and maintainability. This makes code more meaningful and logical to understand.\n\nThe Disadvantages Of Inheritance In C++\n\nThere are various disadvantages of inheritance in C++, some of which are mentioned below:\n• Inflexible Class Hierarchies: Inheritance in C++ creates a strong relationship between base and derived classes. Once a class inherits from another, it's challenging to change that relationship without affecting the entire class hierarchy. This can lead to inflexible designs.\n• Tight Coupling: Inheritance in C++ can lead to tight coupling between classes. Changes in the base class can potentially impact all derived classes, making the codebase more fragile and harder to maintain.\n• Complexity: As class hierarchies grow, they can become complex and challenging to understand. Overuse of inheritance in C++ can lead to deep hierarchies that are difficult to manage and navigate.\n• Difficulty in Testing: When you inherit from a base class, you inherit its behaviour and possibly its dependencies. This can make unit testing more challenging, as you might need to deal with the behaviour of the base class, which may not be desirable in certain test scenarios.\n• Limited Multiple Inheritance: C++ supports multiple inheritance, but it can be complex and lead to the diamond problem, where ambiguity arises if a class inherits from two classes that have a common base class. This can make code more challenging to maintain and understand.\n\nIn conclusion, inheritance in C++ is a pivotal mechanism for building robust, reusable, and well-organized software.\n• By inheriting properties and methods from base classes, we can create specialized derived classes, model real-world hierarchies, and enhance code reusability.\n• Whether you're designing intricate class hierarchies or building modular frameworks, a solid grasp of inheritance is invaluable.\n\nHowever, it's crucial to use this tool judiciously, considering factors like access specifiers, the diamond problem, and alternative strategies like composition. With careful planning and a clear understanding of inheritance in C++, you can craft elegant, maintainable, and adaptable C++ programs that stand the test of time.\n\nAlso read- 51 C++ Interview Questions For Freshers & Experienced (With Answers)\n\nQ. What are C++ access modifiers?\n\nAccess modifiers are the keywords that control the visibility or access of class members to the derived class. They also play a crucial role in inheritance in C++. These are public, protected, and private.\n• public: Members are accessible from any part of the program.\n• protected: Members are accessible within the class and inside its derived classes.\n• private: Members are accessible only within the class.\n\nQ. What are the two levels of inheritance in C++?\n\nThere are two levels of Inheritance in C++, which are-\n• Single-Level Inheritance- In single inheritance, a derived class inherits from a single base class, i.e., a child class inherits from a single parent class. For example, consider Vehicle as a base class and a Car as the child class inherited only from it.\n• Multilevel Inheritance- In multilevel inheritance, a subclass becomes the base class for another derived class. For example, a Child class inherits from the Parent class, and a Parent class inherits from the Grandparent class.\n\nQ. What is inheritance in C++ and its syntax?\n\nInheritance in C++ is a core concept of object-oriented programming (OOP) that allows you to create new classes (derived classes or subclasses) based on existing classes (base classes or superclasses). It enables a subclass to inherit all the properties of the base class and add some new features to itself.\n\nSyntax Of Inheritance In C++:\n• class: It is the keyword for creating a new class.\n• ParentClassName: It is the name of the base class or parent class.\n• ChildClassName: It is the name of the derived class or child class.\n• Visibility_mode: It is the access specifier that determines how inherited members are visible in the derived class (public, protected, or private).\n\nQ. What is a constructor in C++?\n\nIn C++, a constructor is a special member function within a class that gets called automatically when we create an object of that class. Its primary purpose is to initialize the object's data members and perform all necessary setup tasks. Also, constructors have the same name as the class, and they do not have a return type.\n\nA constructor typically initializes the object's state, allocates resources if necessary, and prepares the object for use. Here's a concise explanation of constructors in C++ with an example.\n\nIn the code example above,\n• We first create a class Myclass and use the public access modifier to define the constructor member function Myclass(). This makes the function publicly accessible.\n• Inside the main() function, we create an object obj of Myclass.\n• This will automatically call the constructor function and execute it.\n• It will show its output, as seen in the output window.\n\nQ. Explain polymorphism in C++ with an example.\n\nPolymorphism in C++ is a cool way of saying that objects can act differently based on their types, even if they belong to the same family of classes. Imagine it as a chameleon that can change color to camouflage with its surroundings. In C++, this is made possible through the use of base and derived classes. A base class sets up a blueprint for functions, and then its derived classes give their unique spin to those functions.\n• The Shape class is defined as the base class with a virtual function draw().\n• The Circle class is derived from Shape and overrides the draw() function to print 'Circle drawn'.\n• The Square class is also derived from Shape and overrides the draw() function to print 'Square drawn'.\n• The drawShape function takes the reference to an object from Shape class and calls the draw() function on it, allowing polymorphism.\n• In the main() function, instances of Circle and Square are created.\n\nQ. What is the scope resolution operator (::) in C++?\n\nThe scope resolution operator (::) in C++ is a critical element that serves various purposes in the codes/ programs. It is used to precisely specify the scope or context for accessing variables, functions, or members within C++ programs.\n• Accessing Global Entities: When there are variables or functions with the same name in different scopes (global and local), the scope resolution operator allows you to access the global version explicitly. This ensures that you're working with the targeted variable or function.\n• Accessing Static Class Members: When working with classes, especially static members (variables and functions), the scope resolution operator allows you to access these members associated with the class itself rather than any specific instance of the class.\n• Defining Member Functions Outside of Class: In C++, you can define member functions of a class outside of the class declaration for better organization and readability. The scope resolution operator specifies that the function belongs to a particular class.\n• Resolving Ambiguity: When you have variables or functions with the same name in different scopes (e.g., global and local), you can use the scope resolution operator to resolve the ambiguity and specify which one you want to use.\n\nThis compiles our discussion on inheritance in C++. Here are some more articles you might be interested in:\n• Logical Operators In C++ | Use, Precedence & More (With Examples)\n• Destructor In C++ | Understanding The Key To Cleanups (+ Examples)\n• C++ Exception Handling | Use Try, Catch, & Throw (+Examples)\n• Inline Function In C++ | Declare, Working, Examples & More!\n• Constant In C++ | Literals, Objects, Functions & More (+Examples)\n• Storage Classes In C++ & Its Types Explained (With Examples)"
    },
    {
        "link": "https://geeksforgeeks.org/multiple-inheritance-in-c",
        "document": "Multiple Inheritance is a feature of C++ where a class can inherit from more than one classes. The constructors of inherited classes are called in the same order in which they are inherited. For example, in the following program, B’s constructor is called before A’s constructor.\n\nA class can be derived from more than one base class.\n\n(i) A CHILD class is derived from FATHER and MOTHER class\n\n(ii) A PETROL class is derived from LIQUID and FUEL class.\n\nMultiple inheritance allows a class to inherit from more than one base class.\n\nThe destructors are called in reverse order of constructors.\n\nThe diamond problem The diamond problem occurs when two superclasses of a class have a common base class. For example, in the following diagram, the TA class gets two copies of all attributes of Person class, this causes ambiguities. \n\nFor example, consider the following program.\n\nIn the above program, constructor of ‘Person’ is called two times. Destructor of ‘Person’ will also be called two times when object ‘ta1’ is destructed. So object ‘ta1’ has two copies of all members of ‘Person’, this causes ambiguities. The solution to this problem is ‘virtual’ keyword. We make the classes ‘Faculty’ and ‘Student’ as virtual base classes to avoid two copies of ‘Person’ in ‘TA’ class.\n\nFor example, consider the following program.\n\nIn the above program, constructor of ‘Person’ is called once. One important thing to note in the above output is, the default constructor of ‘Person’ is called. When we use ‘virtual’ keyword, the default constructor of grandparent class is called by default even if the parent classes explicitly call parameterized constructor.\n\nHow to call the parameterized constructor of the ‘Person’ class?\n\nThe constructor has to be called in ‘TA’ class.\n\nFor example, see the following program.\n\nIn general, it is not allowed to call the grandparent’s constructor directly, it has to be called through parent class. It is allowed only when ‘virtual’ keyword is used.\n\nAs an exercise, predict the output of following programs."
    },
    {
        "link": "https://eecs280staff.github.io/notes/09_Inheritance.html",
        "document": "In addition to encapsulation and information hiding, C++ classes provide two features that are fundamental to object-oriented programming:\n• None Inheritance: the ability for a class to reuse the interface or functionality of another class.\n• None Subtype polymorphism: the ability to use an object of a more specific type where an object of a more general type is expected.\n\nWe will discuss inheritance today, deferring subtype polymorphism until next time.\n\nTo motivate the concept of inheritance, consider the following definitions of and ADTs:\n\nThe two ADTs are nearly identical – both have and member variables, with their corresponding get functions, and both have a member function that makes the appropriate chicken or duck sound. In terms of differences, chickens tend to cross roads (since they don’t fly very well), so we keep track of how often they do that. On the other hand, ducks are often accompanied by their ducklings, so we keep track of how many they have.\n\nIntuitively, it makes sense for and to share a lot of functionality, since chickens and ducks are both types of birds.\n\nThis “is-a” relationship, where a is a and a is also a , can be encoded with inheritance. We write as a base class, then write and as classes that inherit or derive from . We place the common functionality in , which then gets inherited by the derived classes.\n\nHere, all birds have a name and an age, and the generic sound a bird makes is “tweet”.\n\nFor more a more specific kind of bird, we obtain the functionality of the base class by deriving from it:\n\nThe syntax for deriving from a base class is to put a colon after the name of the derived class, then the keyword, then the name of the base class. This results in public inheritance, where it is part of the interface of that it derives from . Without the keyword, it would be private inheritance , where it is an implementation detail and not part of the interface that derives from .\n\nNow that derives from , it inherits the functionality of the class, and the public interface of is also supported by :\n\nFunctionality that is specific to a particular kind of bird goes in the class for that bird:\n\nHere, we have the additional data member ; and are inherited from . (They are not directly accessible from the class, however, since they are private. We will come back to this later.) Figure 36 illustrates the layout of and in memory.\n\nThe memory of actually consists of a piece, plus the additional members. Thus, the data members defined by are also included in a .\n\nIn order to properly initialize a derived-class object, its constructor must ensure that its base-class subobject is also appropriately initialized. The base class may have private member variables, which cannot be accessed from the derived class, so the derived class does not initialize the inherited members directly. Instead, it invokes a base-class constructor in the member-initializer list of its own constructors:\n\nIn C++, a derived-class constructor always invokes a constructor for the base class. If an explicit invocation does not appear in the member-initializer list, there is an implicit call to the default constructor. If the base class has no default constructor, an error results:\n\nFor completeness, the following is an implementation of as a derived class of :\n\nBy writing and deriving from it in both and , we have avoided duplication of the shared functionality.\n\nWe have already seen that in most cases, a constructor is invoked when a class-type object is created. Similarly, a destructor is invoked when a class-type object’s lifetime is over. For a local variable, this is when the variable goes out of scope. The following illustrates an example: The class has a custom destructor, written as , which runs when a object is dying. Here, we just have both the constructor and destructor print messages to standard out. The following is printed when the code is run: We will cover destructors in more detail later in the course. For now, we concern ourselves solely with the order in which constructors and destructors execute when we have derived classes. When there are multiple objects that are constructed and destructed, C++ follows a “socks-and-shoes” ordering: when we put on socks and shoes in the morning, we put on socks first, then our shoes. In the evening, however, when we take them off, we do so in the reverse order: first our shoes, then our socks. In the case of a derived class, C++ will always construct the base-class subobject before initializing the derived-class pieces. Destruction is in the reverse order: first the derived-class destructor runs, then the base-class one. The following illustrates this order: The following results from running the code: When creating a object, the invocation of the constructor is the first thing that happens in the constructor. This is true regardless of whether or not an explicit call to the constructor appears, and regardless of ordering of the member-initializer list. Then the rest of the constructor runs. When a object is dying, first the code in the destructor runs. Then the code in the destructor automatically runs. (It is generally erroneous to invoke the base-class destructor explicitly, since the compiler always does so implicitly.) The following code creates both a and a object: Assuming that has a destructor that prints out , the code prints the following: We see the same ordering in construction and destruction. Furthermore, we see that because is constructed before , it is destructed after – socks-and-shoes ordering here as well.\n\nWhen a member access is applied to an object, the compiler follows a specific process to look up the given name:\n• None The compiler starts by looking for a member with that name in the compile-time or static type of the object. (We will discuss static and dynamic types next time.)\n• None If no member with that name is found, the compiler repeats the process on the base class of the given type. If the type has no base class, a compiler error is generated.\n• None If a member with the given name is found, the compiler then checks whether or not the member is accessible and whether the member can be used in the given context. If not, a compiler error is generated – the lookup process does not proceed further. As an example, consider the following member accesses:\n• None For , the compiler first looks for a member defined in the class. Since does not define such a member, the compiler looks for a member in its base class. There is indeed a member in , so the compiler then checks that the member is accessible and is a function that can be called with no arguments. These checks succeed, so the lookup process terminates successfully.\n• None For , the compiler looks for a member in . There is one, so it then checks to make sure it is accessible and is a function that can be called with no arguments. This succeeds, and at runtime, it is that is called. The function is hidden, since the name lookup process never gets to it.\n• None For , the compiler looks for an member in . There is none, so the compiler looks in . There is such a member, so the compiler checks whether it is accessible from the given context. The member is private, so this check fails, and the compiler reports an error.\n• None For , the compiler looks for an member in . There is none, so the compiler looks in . There is no such member, and has no base class, so the compiler reports an error. As another example, consider the following code: When looking up , the compiler finds a member in . However, it is a member function, which cannot be assigned to an . Thus, the compiler reports an error – it does not consider the hidden that is defined in . Similarly, when looking up , the compiler finds a member in . Though it is a function, it cannot be called with a string literal, so the compiler reports an error. Again, the compiler does not consider the that is defined in ; that member is hidden by the defined in . To summarize, C++ does not consider the context in which a member is used until after its finds a member of the given name. This is in contrast to some other languages, which consider context in the lookup process itself. On occasion, we wish to access a hidden member rather than the member that hides it. The most common case is when a derived-class version of a function calls the base-class version as part of its functionality. The following illustrates this in : // baby chicks make more of a tweeting rather than clucking noise By using the scope-resolution operator, we are specifically asking for the version of , enabling access to it even though it is hidden. The code above does have a problem: it accesses the member of , which, though it is not hidden, is private and so not accessible to . There are two solutions to this problem:\n• None We can declare to be protected, which allows derived classes of to access the member but not the outside world.\n• None We can use the public function instead. The former strategy is not desirable; since the member variable is an implementation detail, making it protected exposes implementation details to the derived classes. Instead, we should use a get function to abstract the implementation detail. We could choose to make such a function protected, so that it is part of the interface that derived classes have access to but not the outside world. For , we already have a public get function, so we can just use that: // baby chicks make more of a tweeting rather than clucking noise"
    },
    {
        "link": "https://w3schools.com/cpp/cpp_inheritance.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    }
]