[
    {
        "link": "https://stackoverflow.com/questions/10966776/reading-and-writing-json-file-java",
        "document": "I'm trying to read a JSON file into a data structure so that I can count a bunch of elements.\n\nThe JSON file is of the format . Now in this array of objects, I need to find the relationship of the first string field (let's say association) to the array field (names of the members). I need to figure out how many associations each of these members belong to.\n\nI'm currently using json-simple and this is how I've done it.\n\nWondering if there is a simpler way in simple-json itself or if there are other libraries that better."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-read-and-write-json-files-in-java",
        "document": "How to Read and Write JSON Files in Java?\n\nJSON (JavaScript Object Notation) is simple but powe­rful.. It helps the server and the client to share information. Applications like­ Java use special tools, or libraries, that re­ad JSON. In Java, some libraries make it easy to read and write JSON files. One popular library is Jackson.\n\nIn this article, we will learn how to read and write JSON files in Java.\n\nThe proje­ct needs the Jackson library. You can add this manually by downloading the JAR files or using a build tool like­ Maven or Gradle.\n\nNow, let's create a simple Java project using Visual Studio Code and Maven.\n\nOpen the command prompt and run the following commands to initialize a new Maven project.\n\nThis command will generate a basic Maven project structure. Below we can see the Maven project builds successfully.\n\nOpen the pom.xml file in the project folder then add the Jackson dependency into it.\n\nIn the src/main/java/com/example folder, create two Java files: JsonFileReader.java and JsonFileWriter.java.\n\nExplanation of the above Program:\n• None We declare that the­ class is part of the com.example\n• None After that, we import classe­s we need to handle­ JSON with the Jackson library.\n• ObjectMapper provides us functionality in writing JSON. ObjectNode is used a JSON object.\n• JsonFileWriter main method, and it throws an IOException . This shows that input/output exce­ptions could happen.\n• ObjectMappe­r instance is created. It coverting Java obje­cts into JSON\n• ObjectNode is created next. It helps structure of the JSON object.\n• None Then some Key-value­ pairs added to the JSON object. The­ put method adds them in. Put can add Strings, numbers, and othe­r types.\n• None At the last, ObjectMapper's write­Value method is used. It write­s the JSON object to a file calle­d \"mydata.json\". This can sometimes cause an IOExce­ption, so it's declared in the main method's throws clause­.\n\nExplanation of the above Program:\n• None We declare that the­ class is part of the com.example package­.\n• None After that, we import classe­s we need to handle­ JSON\n• None Jackson's ObjectMapper provides us functionality in re­ading JSON. ObjectNode\n• JsonFileReader main method, and it throws an IOException . This shows that input/output exce­ptions could happen.\n• ObjectMappe­r instance is created. It coverting Java obje­cts into JSON.\n• readTree method is used to read the contents of the JSON file \"mydata.json\" and converts it into a JsonNode object.\n• None The get method is used to extract values from the JsonNode. The .asText() .asInt() methods are used to convert the values to the appropriate Java types.\n• None And at last, the extracted values are printed to the console.\n\nTo run the project, use below maven commands.\n\nThis Java code uses the Jackson library. It shows how to write and read JSON files. The JsonFileWriter class makes a JSON object and stores it in a file. The JsonFileReader class reads the JSON data from the file. It turns it into a JsonNode and pulls out specific values. We use ObjectMapper and ObjectNode to make it easier to flip between Java objects and JSON. Things covered include adding key-value pairs and writing files. We also include extracting data afterwards. This is a basic guide for read and write json in Java and helps how to use JSON files in Java."
    },
    {
        "link": "https://stackoverflow.com/questions/10926353/how-to-read-json-file-into-java-with-simple-json-library",
        "document": "The whole file is an array and there are objects and other arrays (e.g. cars) in the whole array of the file.\n\nAs you say, the outermost layer of your JSON blob is an array. Therefore, your parser will return a . You can then get s from the array ...\n\nFor reference, see \"Example 1\" on the json-simple decoding example page."
    },
    {
        "link": "https://howtodoinjava.com/java/library/json-simple-read-write-json-examples",
        "document": "JSON.simple is a lightweight JSON processing library that can be used to read and write JSON files and strings. The encoded/decoded JSON will be in full compliance with JSON specification (RFC4627).\n\nIn this Java JSON tutorial, we will first see a quick example of writing to a JSON file and then we will read JSON from the file.\n• Easy to use by reusing Map and List interfaces.\n\nTo write JSON test into the file, we will be working with mainly two classes:\n• : To write data in json arrays. Use its method to add objects of type .\n• : To write json objects. Use it’s method to populate fields.\n\nAfter populating the above objects, use instance to write the JSON file.\n\nTo read JSON from file, we will use the JSON file we created in the previous example.\n• First of all, we will create instance to parse JSON file.\n• Use to read JSON file and pass it to parser.\n• Start reading the JSON objects one by one, based on their type i.e. and ."
    },
    {
        "link": "https://geeksforgeeks.org/working-with-json-data-in-java",
        "document": "JSON stands for JavaScript Object Notation which is a lightweight text-based open standard designed which is easy for human-readable data interchange. In general, JSON is extended from JavaScript. JSON is language-independent and It is easy to read and write. The file extension of JSON is .json.\n\nIn the below given example, you will see how you can store values in JSON format. Consider student information where Stu_id, Stu_Name, Course is an entities you need to store then in JSON format you can store these values in key values pair form. Let’s have a look.\n\nIt is the method by which we can access means read or write JSON data in Java Programming Language. Here we simply use the json.simple library to access this feature through Java means we can encode or decode JSON Object using this json.simple library in Java Programming Language. Now, the json.simple package for Java contains the following files in it. So to access we first have to install json.simple package.\n\n \n\nFor installation first, we required to set the json-simple.jar classpath or add the Maven dependency in different cases.\n\nStep 1: Download the json.simple using this link: Download link for json.sample\n\nStep 2: There is one more method to add the Maven dependency, so for that, we have to add the code given below to our pom.xml file.\n\nThe above-downloaded .jar file contains these Java source files in it :\n\nJSON Object Encoding in Java: As we discussed above, this json.simple library is used to read/write or encode/decode JSON objects in Java. So let’s see how we can code for encoding part of the JSON object using JSONObject function. Now we create a java file mainEncoding.java and save the below-written code in it.\n\nNow we will see how we can code for decoding part of the JSON object using JSONObjectfunction. Now we create a java file mainDecoding.java and save the below-written code in it."
    },
    {
        "link": "https://nodejs.org/api/fs.html",
        "document": "The module enables interacting with the file system in a way modeled on standard POSIX functions.\n\nTo use the promise-based APIs:\n\nTo use the callback and sync APIs:\n\nAll file system operations have synchronous, callback, and promise-based forms, and are accessible using both CommonJS syntax and ES6 Modules (ESM).\n\nThe common objects are shared by all of the file system API variants (promise, callback, and synchronous). When using the async iterator, the <fs.Dir> object will be automatically closed after the iterator exits. Asynchronously close the directory's underlying resource handle. Subsequent reads will result in errors. A promise is returned that will be fulfilled after the resource has been closed. Passing an invalid callback to the argument now throws instead of . Asynchronously close the directory's underlying resource handle. Subsequent reads will result in errors. The will be called after the resource handle has been closed. Synchronously close the directory's underlying resource handle. Subsequent reads will result in errors. The read-only path of this directory as was provided to , , or . Asynchronously read the next directory entry via as an <fs.Dirent>. A promise is returned that will be fulfilled with an <fs.Dirent>, or if there are no more directory entries to read. Directory entries returned by this function are in no particular order as provided by the operating system's underlying directory mechanisms. Entries added or removed while iterating over the directory might not be included in the iteration results. Asynchronously read the next directory entry via as an <fs.Dirent>. After the read is completed, the will be called with an <fs.Dirent>, or if there are no more directory entries to read. Directory entries returned by this function are in no particular order as provided by the operating system's underlying directory mechanisms. Entries added or removed while iterating over the directory might not be included in the iteration results. Synchronously read the next directory entry as an <fs.Dirent>. See the POSIX documentation for more detail. If there are no more directory entries to read, will be returned. Directory entries returned by this function are in no particular order as provided by the operating system's underlying directory mechanisms. Entries added or removed while iterating over the directory might not be included in the iteration results. Asynchronously iterates over the directory until all entries have been read. Refer to the POSIX documentation for more detail. Entries returned by the async iterator are always an <fs.Dirent>. The case from is handled internally. See <fs.Dir> for an example. Directory entries returned by this iterator are in no particular order as provided by the operating system's underlying directory mechanisms. Entries added or removed while iterating over the directory might not be included in the iteration results. A representation of a directory entry, which can be a file or a subdirectory within the directory, as returned by reading from an <fs.Dir>. The directory entry is a combination of the file name and file type pairs. Additionally, when or is called with the option set to , the resulting array is filled with <fs.Dirent> objects, rather than strings or <Buffer>s. The file name that this <fs.Dirent> object refers to. The type of this value is determined by the passed to or . The path to the parent directory of the file this <fs.Dirent> object refers to. The property is no longer read-only. Accessing this property emits a warning. It is now read-only. A successful call to method will return a new <fs.FSWatcher> object. All <fs.FSWatcher> objects emit a event whenever a specific watched file is modified.\n• <string> The type of change event that has occurred\n• <string> | <Buffer> The filename that changed (if relevant/available) Emitted when something changes in a watched directory or file. See more details in . The argument may not be provided depending on operating system support. If is provided, it will be provided as a <Buffer> if is called with its option set to , otherwise will be a UTF-8 string. Emitted when the watcher stops watching for changes. The closed <fs.FSWatcher> object is no longer usable in the event handler. Emitted when an error occurs while watching the file. The errored <fs.FSWatcher> object is no longer usable in the event handler. Stop watching for changes on the given <fs.FSWatcher>. Once stopped, the <fs.FSWatcher> object is no longer usable. When called, requests that the Node.js event loop not exit so long as the <fs.FSWatcher> is active. Calling multiple times will have no effect. By default, all <fs.FSWatcher> objects are \"ref'ed\", making it normally unnecessary to call unless had been called previously. When called, the active <fs.FSWatcher> object will not require the Node.js event loop to remain active. If there is no other activity keeping the event loop running, the process may exit before the <fs.FSWatcher> object's callback is invoked. Calling multiple times will have no effect. A successful call to method will return a new <fs.StatWatcher> object. When called, requests that the Node.js event loop not exit so long as the <fs.StatWatcher> is active. Calling multiple times will have no effect. By default, all <fs.StatWatcher> objects are \"ref'ed\", making it normally unnecessary to call unless had been called previously. When called, the active <fs.StatWatcher> object will not require the Node.js event loop to remain active. If there is no other activity keeping the event loop running, the process may exit before the <fs.StatWatcher> object's callback is invoked. Calling multiple times will have no effect. Instances of <fs.ReadStream> are created and returned using the function. Emitted when the <fs.ReadStream>'s underlying file descriptor has been closed.\n• <integer> Integer file descriptor used by the <fs.ReadStream>. Emitted when the <fs.ReadStream>'s file descriptor has been opened. Emitted when the <fs.ReadStream> is ready to be used. The number of bytes that have been read so far. The path to the file the stream is reading from as specified in the first argument to . If is passed as a string, then will be a string. If is passed as a <Buffer>, then will be a <Buffer>. If is specified, then will be . This property is if the underlying file has not been opened yet, i.e. before the event is emitted. Objects returned from , , , and their synchronous counterparts are of this type. If in the passed to those methods is true, the numeric values will be instead of , and the object will contain additional nanosecond-precision properties suffixed with . objects are not to be created directly using the keyword. If the <fs.Stats> object was obtained from calling on a symbolic link which resolves to a directory, this method will return . This is because returns information about a symbolic link itself and not the path it resolves to. This method is only valid when using . The numeric identifier of the device containing the file. The file system specific \"Inode\" number for the file. The number of hard-links that exist for the file. The numeric user identifier of the user that owns the file (POSIX). The numeric group identifier of the group that owns the file (POSIX). The size of the file in bytes. If the underlying file system does not support getting the size of the file, this will be . The number of blocks allocated for this file. The timestamp indicating the last time this file was accessed expressed in milliseconds since the POSIX Epoch. The timestamp indicating the last time this file was modified expressed in milliseconds since the POSIX Epoch. The timestamp indicating the last time the file status was changed expressed in milliseconds since the POSIX Epoch. The timestamp indicating the creation time of this file expressed in milliseconds since the POSIX Epoch. Only present when is passed into the method that generates the object. The timestamp indicating the last time this file was accessed expressed in nanoseconds since the POSIX Epoch. Only present when is passed into the method that generates the object. The timestamp indicating the last time this file was modified expressed in nanoseconds since the POSIX Epoch. Only present when is passed into the method that generates the object. The timestamp indicating the last time the file status was changed expressed in nanoseconds since the POSIX Epoch. Only present when is passed into the method that generates the object. The timestamp indicating the creation time of this file expressed in nanoseconds since the POSIX Epoch. The timestamp indicating the last time this file was accessed. The timestamp indicating the last time this file was modified. The timestamp indicating the last time the file status was changed. The timestamp indicating the creation time of this file. The , , , properties are numeric values that hold the corresponding times in milliseconds. Their precision is platform specific. When is passed into the method that generates the object, the properties will be bigints, otherwise they will be numbers. The , , , properties are bigints that hold the corresponding times in nanoseconds. They are only present when is passed into the method that generates the object. Their precision is platform specific. , , , and are object alternate representations of the various times. The and number values are not connected. Assigning a new number value, or mutating the value, will not be reflected in the corresponding alternate representation. The times in the stat object have the following semantics:\n• \"Access Time\": Time when file data last accessed. Changed by the , , and system calls.\n• \"Modified Time\": Time when file data last modified. Changed by the , , and system calls.\n• \"Change Time\": Time when file status was last changed (inode data modification). Changed by the , , , , , , , , and system calls.\n• \"Birth Time\": Time of file creation. Set once when the file is created. On file systems where birthtime is not available, this field may instead hold either the or (ie, Unix epoch timestamp ). This value may be greater than or in this case. On Darwin and other FreeBSD variants, also set if the is explicitly set to an earlier value than the current using the system call. Prior to Node.js 0.12, the held the on Windows systems. As of 0.12, is not \"creation time\", and on Unix systems, it never was. Objects returned from and its synchronous counterpart are of this type. If in the passed to those methods is , the numeric values will be instead of . Instances of <fs.WriteStream> are created and returned using the function. Emitted when the <fs.WriteStream>'s underlying file descriptor has been closed.\n• <integer> Integer file descriptor used by the <fs.WriteStream>. Emitted when the <fs.WriteStream>'s file is opened. Emitted when the <fs.WriteStream> is ready to be used. The number of bytes written so far. Does not include data that is still queued for writing. Closes . Optionally accepts a callback that will be executed once the is closed. The path to the file the stream is writing to as specified in the first argument to . If is passed as a string, then will be a string. If is passed as a <Buffer>, then will be a <Buffer>. This property is if the underlying file has not been opened yet, i.e. before the event is emitted. Returns an object containing commonly used constants for file system operations. The following constants are exported by and . Not every constant will be available on every operating system; this is especially important for Windows, where many of the POSIX specific definitions are not available. For portable applications it is recommended to check for their presence before use. To use more than one constant, use the bitwise OR operator. The following constants are meant for use as the parameter passed to , , and . Flag indicating that the file is visible to the calling process. This is useful for determining if a file exists, but says nothing about permissions. Default if no mode is specified. Flag indicating that the file can be read by the calling process. Flag indicating that the file can be written by the calling process. Flag indicating that the file can be executed by the calling process. This has no effect on Windows (will behave like ). The definitions are also available on Windows. The following constants are meant for use with . If present, the copy operation will fail with an error if the destination path already exists. If present, the copy operation will attempt to create a copy-on-write reflink. If the underlying platform does not support copy-on-write, then a fallback copy mechanism is used. If present, the copy operation will attempt to create a copy-on-write reflink. If the underlying platform does not support copy-on-write, then the operation will fail with an error. The definitions are also available on Windows. The following constants are meant for use with . Flag indicating to create the file if it does not already exist. Flag indicating that opening a file should fail if the flag is set and the file already exists. Flag indicating that if path identifies a terminal device, opening the path shall not cause that terminal to become the controlling terminal for the process (if the process does not already have one). Flag indicating that if the file exists and is a regular file, and the file is opened successfully for write access, its length shall be truncated to zero. Flag indicating that data will be appended to the end of the file. Flag indicating that the open should fail if the path is not a directory. Flag indicating reading accesses to the file system will no longer result in an update to the information associated with the file. This flag is available on Linux operating systems only. Flag indicating that the open should fail if the path is a symbolic link. Flag indicating that the file is opened for synchronized I/O with write operations waiting for file integrity. Flag indicating that the file is opened for synchronized I/O with write operations waiting for data integrity. Flag indicating to open the symbolic link itself rather than the resource it is pointing to. When set, an attempt will be made to minimize caching effects of file I/O. Flag indicating to open the file in nonblocking mode when possible. When set, a memory file mapping is used to access the file. This flag is available on Windows operating systems only. On other operating systems, this flag is ignored. On Windows, only , , , , , , , and are available. The following constants are meant for use with the <fs.Stats> object's property for determining a file's type. Bit mask used to extract the file type code. On Windows, only , , , , and , are available. The following constants are meant for use with the <fs.Stats> object's property for determining the access permissions for a file. File mode indicating readable, writable, and executable by others. On Windows, only and are available.\n\nBecause they are executed asynchronously by the underlying thread pool, there is no guaranteed ordering when using either the callback or promise-based methods. For example, the following is prone to error because the operation might complete before the operation: It is important to correctly order the operations by awaiting the results of one before invoking the other: Or, when using the callback APIs, move the call into the callback of the operation: Most operations accept file paths that may be specified in the form of a string, a <Buffer>, or a <URL> object using the protocol. String paths are interpreted as UTF-8 character sequences identifying the absolute or relative filename. Relative paths will be resolved relative to the current working directory as determined by calling . Example using an absolute path on POSIX: Example using a relative path on POSIX (relative to ): For most module functions, the or argument may be passed as a <URL> object using the protocol. On Windows, <URL>s with a host name convert to UNC paths, while <URL>s with drive letters convert to local absolute paths. <URL>s with no host name and no drive letter will result in an error: <URL>s with drive letters must use as a separator just after the drive letter. Using another separator will result in an error. On all other platforms, <URL>s with a host name are unsupported and will result in an error: A <URL> having encoded slash characters will result in an error on all platforms: On Windows, <URL>s having encoded backslash will result in an error: Paths specified using a <Buffer> are useful primarily on certain POSIX operating systems that treat file paths as opaque byte sequences. On such systems, it is possible for a single file path to contain sub-sequences that use multiple character encodings. As with string paths, <Buffer> paths may be relative or absolute: Example using an absolute path on POSIX: On Windows, Node.js follows the concept of per-drive working directory. This behavior can be observed when using a drive path without a backslash. For example can potentially return a different result than . For more information, see this MSDN page. On POSIX systems, for every process, the kernel maintains a table of currently open files and resources. Each open file is assigned a simple numeric identifier called a file descriptor. At the system-level, all file system operations use these file descriptors to identify and track each specific file. Windows systems use a different but conceptually similar mechanism for tracking resources. To simplify things for users, Node.js abstracts away the differences between operating systems and assigns all open files a numeric file descriptor. The callback-based , and synchronous methods open a file and allocate a new file descriptor. Once allocated, the file descriptor may be used to read data from, write data to, or request information about the file. Operating systems limit the number of file descriptors that may be open at any given time so it is critical to close the descriptor when operations are completed. Failure to do so will result in a memory leak that will eventually cause an application to crash. The promise-based APIs use a <FileHandle> object in place of the numeric file descriptor. These objects are better managed by the system to ensure that resources are not leaked. However, it is still required that they are closed when operations are completed: All callback and promise-based file system APIs (with the exception of ) use libuv's threadpool. This can have surprising and negative performance implications for some applications. See the documentation for more information. The following flags are available wherever the option takes a string.\n• : Open file for appending. The file is created if it does not exist.\n• : Like but fails if the path exists.\n• : Open file for reading and appending. The file is created if it does not exist.\n• : Like but fails if the path exists.\n• : Open file for appending in synchronous mode. The file is created if it does not exist.\n• : Open file for reading and appending in synchronous mode. The file is created if it does not exist.\n• : Open file for reading. An exception occurs if the file does not exist.\n• : Open file for reading in synchronous mode. An exception occurs if the file does not exist.\n• : Open file for reading and writing. An exception occurs if the file does not exist.\n• : Open file for reading and writing in synchronous mode. Instructs the operating system to bypass the local file system cache. This is primarily useful for opening files on NFS mounts as it allows skipping the potentially stale local cache. It has a very real impact on I/O performance so using this flag is not recommended unless it is needed. This doesn't turn or into a synchronous blocking call. If synchronous operation is desired, something like should be used.\n• : Open file for writing. The file is created (if it does not exist) or truncated (if it exists).\n• : Like but fails if the path exists.\n• : Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).\n• : Like but fails if the path exists. can also be a number as documented by ; commonly used constants are available from . On Windows, flags are translated to their equivalent ones where applicable, e.g. to , or to , as accepted by . The exclusive flag ( flag in ) causes the operation to return an error if the path already exists. On POSIX, if the path is a symbolic link, using returns an error even if the link is to a path that does not exist. The exclusive flag might not work with network file systems. On Linux, positional writes don't work when the file is opened in append mode. The kernel ignores the position argument and always appends the data to the end of the file. Modifying a file rather than replacing it may require the option to be set to rather than the default . The behavior of some flags are platform-specific. As such, opening a directory on macOS and Linux with the flag, as in the example below, will return an error. In contrast, on Windows and FreeBSD, a file descriptor or a will be returned. On Windows, opening an existing hidden file using the flag (either through , , or ) will fail with . Existing hidden files can be opened for writing with the flag. A call to or can be used to reset the file contents."
    },
    {
        "link": "https://geeksforgeeks.org/node-js-file-system",
        "document": "The fs (File System) module in Node.js provides an API for interacting with the file system. It allows you to perform operations such as reading, writing, updating, and deleting files and directories, which are essential for server-side applications and scripts.\n\nTo handle file operations like creating, reading, deleting, etc., Node.js provides an inbuilt module called FS (File System). Node.js gives the functionality of file I/O by providing wrappers around the standard POSIX functions. All file system operations can have synchronous and asynchronous forms depending upon user requirements. To use this File System module, use the require() method:\n• Asynchronous and Synchronous Methods: Provides both non-blocking and blocking methods for various file operations.\n• Error Handling: Includes robust error handling to manage issues such as file not found or permission errors.\n• Directory Management: Allows creation, deletion, and listing of directories.\n\nWhat is Synchronous and Asynchronous approach?\n\nThey are called blocking functions as it waits for each operation to complete, only after that, it executes the next operation, hence blocking the next command from execution i.e. a command will not be executed until & unless the query has finished executing to get all the result from previous commands.\n\nThey are called non-blocking functions as it never waits for each operation to complete, rather it executes all operations in the first go itself. The result of each operation will be handled once the result is available i.e. each command will be executed soon after the execution of the previous command. While the previous command runs in the background and loads the result once it is finished processing the data.\n\nIf your operations are not doing very heavy lifting like querying huge data from DB then go ahead with Synchronous way otherwise Asynchronous way.\n\nIn an Asynchronous way, you can show some progress indicator to the user while in the background you can continue with your heavyweight works. This is an ideal scenario for GUI based apps.\n\nExample of asynchronous and synchronous:\n\nCreate a text file named input.txt with the following content:\n\nNow let us create a js file named main.js with the following code:\n\nThe fs.open() method is used to create, read, or write a file. The fs.readFile() method is only for reading the file and fs.writeFile() method is only for writing to the file, whereas fs.open() method does several operations on a file. First, we need to load the fs class which is a module to access the physical file system.\n• path: It holds the name of the file to read or the entire path if stored at other locations.\n• flags: Flags indicate the behavior of the file to be opened. All possible values are ( r, r+, rs, rs+, w, wx, w+, wx+, a, ax, a+, ax+).\n• mode: Sets the mode of file i.e. r-read, w-write, r+ -readwrite. It sets to default as readwrite.\n• data: Contents of the file. It is called after the open operation is executed.\n\nExample: Let us create a js file named main.js having the following code to open a file input.txt for reading and writing.\n\nThe fs.read() method is used to read the file specified by fd. This method reads the entire file into the buffer.\n• fd: This is the file descriptor returned by fs.open() method.\n• buffer: This is the buffer that the data will be written to.\n• offset: This is the offset in the buffer to start writing at.\n• length: This is an integer specifying the number of bytes to read.\n• position: This is an integer specifying where to begin reading from in the file. If the position is null, data will be read from the current file position.\n• callback: It is a callback function that is called after reading of the file. It takes two parameters:\n\nExample: Let us create a js file named main.js having the following code:\n\nThis method will overwrite the file if the file already exists. The fs.writeFile() method is used to asynchronously write the specified data to a file. By default, the file would be replaced if it exists. The ‘options’ parameter can be used to modify the functionality of the method.\n• path: It is a string, Buffer, URL, or file description integer that denotes the path of the file where it has to be written. Using a file descriptor will make it behave similarly to fs.write() method.\n• data: It is a string, Buffer, TypedArray, or DataView that will be written to the file.\n• options: It is a string or object that can be used to specify optional parameters that will affect the output. It has three optional parameters:\n• encoding: It is a string value that specifies the encoding of the file. The default value is ‘utf8’.\n• mode: It is an integer value that specifies the file mode. The default value is 0o666.\n• flag: It is a string value that specifies the flag used while writing to the file. The default value is ‘w’.\n• callback: It is the function that would be called when the method is executed.\n• err: It is an error that would be thrown if the operation fails.\n\nExample: Let us create a js file named main.js having the following code:\n\nThe fs.appendFile() method is used to synchronously append the data to the file.\n• filepath: It is a String that specifies the file path.\n• data: It is mandatory and it contains the data that you append to the file.\n• options: It is an optional parameter that specifies the encoding/mode/flag.\n• Callback: Function is mandatory and is called when appending data to file is completed.\n\nExample 1: Let us create a js file named main.js having the following code:\n\nThe fs.close() method is used to asynchronously close the given file descriptor thereby clearing the file that is associated with it. This will allow the file descriptor to be reused for other files. Calling fs.close() on a file descriptor while some other operation is being performed on it may lead to undefined behavior.\n• fd: It is an integer that denotes the file descriptor of the file for which to be closed.\n• callback: It is a function that would be called when the method is executed.\n• err: It is an error that would be thrown if the method fails.\n\nExample: Let us create a js file named main.js having the following code:\n\nThe fs.unlink() method is used to remove a file or symbolic link from the filesystem. This function does not work on directories, therefore it is recommended to use fs.rmdir() to remove a directory.\n• path: It is a string, Buffer or URL which represents the file or symbolic link which has to be removed.\n• callback: It is a function that would be called when the method is executed.\n• err: It is an error that would be thrown if the method fails.\n\nExample: Let us create a js file named main.js having the following code:\n• None Provides detailed error messages to help with troubleshooting.\n\nThe fs module is a fundamental tool for file operations in Node.js, offering a range of methods to handle files and directories effectively. Its versatility and robust error handling make it essential for building reliable server-side applications."
    },
    {
        "link": "https://nodejs.org/download/release/v4.7.0/docs/api/fs.html",
        "document": "File I/O is provided by simple wrappers around standard POSIX functions. To use this module do . All the methods have asynchronous and synchronous forms.\n\nThe asynchronous form always takes a completion callback as its last argument. The arguments passed to the completion callback depend on the method, but the first argument is always reserved for an exception. If the operation was completed successfully, then the first argument will be or .\n\nWhen using the synchronous form any exceptions are immediately thrown. You can use try/catch to handle exceptions or allow them to bubble up.\n\nHere is an example of the asynchronous version:\n\nHere is the synchronous version:\n\nWith the asynchronous methods there is no guaranteed ordering. So the following is prone to error:\n\nIt could be that is executed before . The correct way to do this is to chain the callbacks.\n\nIn busy processes, the programmer is strongly encouraged to use the asynchronous versions of these calls. The synchronous versions will block the entire process until they complete--halting all connections.\n\nThe relative path to a filename can be used. Remember, however, that this path will be relative to .\n\nMost fs functions let you omit the callback argument. If you do, a default callback is used that rethrows errors. To get a trace to the original call site, set the environment variable:\n\nObjects returned from are of this type.\n• <String> The filename that changed (if relevant/available)\n\nEmitted when something changes in a watched directory or file. See more details in .\n\nStop watching for changes on the given .\n• <Number> Integer file descriptor used by the ReadStream.\n\nEmitted when the ReadStream's file is opened.\n\nEmitted when the 's underlying file descriptor has been closed using the method.\n\nThe path to the file the stream is reading from.\n\nObjects returned from , and and their synchronous counterparts are of this type.\n\nFor a regular file would return a string very similar to this:\n\nPlease note that , , , and are instances of object and to compare the values of these objects you should use appropriate methods. For most general uses will return the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC and this integer should be sufficient for any comparison, however there are additional methods which can be used for displaying fuzzy information. More details can be found in the MDN JavaScript Reference page.\n\nThe times in the stat object have the following semantics:\n• \"Access Time\" - Time when file data last accessed. Changed by the , , and system calls.\n• \"Modified Time\" - Time when file data last modified. Changed by the , , and system calls.\n• \"Change Time\" - Time when file status was last changed (inode data modification). Changed by the , , , , , , , , and system calls.\n• \"Birth Time\" - Time of file creation. Set once when the file is created. On filesystems where birthtime is not available, this field may instead hold either the or (ie, unix epoch timestamp ). Note that this value may be greater than or in this case. On Darwin and other FreeBSD variants, also set if the is explicitly set to an earlier value than the current using the system call.\n\nPrior to Node v0.12, the held the on Windows systems. Note that as of v0.12, is not \"creation time\", and on Unix systems, it never was.\n• <Number> Integer file descriptor used by the WriteStream.\n\nEmitted when the WriteStream's file is opened.\n\nEmitted when the 's underlying file descriptor has been closed using the method.\n\nThe number of bytes written so far. Does not include data that is still queued for writing.\n\nThe path to the file the stream is writing to.\n\nTests a user's permissions for the file specified by . is an optional integer that specifies the accessibility checks to be performed. The following constants define the possible values of . It is possible to create a mask consisting of the bitwise OR of two or more values.\n• - File is visible to the calling process. This is useful for determining if a file exists, but says nothing about permissions. Default if no is specified.\n• - File can be read by the calling process.\n• - File can be written by the calling process.\n• - File can be executed by the calling process. This has no effect on Windows (will behave like ).\n\nThe final argument, , is a callback function that is invoked with a possible error argument. If any of the accessibility checks fail, the error argument will be populated. The following example checks if the file can be read and written by the current process.\n\nUsing to check for the accessibility of a file before calling , or is not recommended. Doing so introduces a race condition, since other processes may change the file's state between the two calls. Instead, user code should open/read/write the file directly and handle the error raised if the file is not accessible.\n\nThe \"not recommended\" examples above check for accessibility and then use the file; the \"recommended\" examples are better because they use the file directly and handle the error, if any.\n\nIn general, check for the accessibility of a file only if the file won’t be used directly, for example when its accessibility is a signal from another process.\n\nSynchronous version of . This throws if any accessibility checks fail, and does nothing otherwise.\n\nAsynchronously append data to a file, creating the file if it does not yet exist. can be a string or a buffer.\n\nIf is a string, then it specifies the encoding. Example:\n\nAsynchronous chmod(2). No arguments other than a possible exception are given to the completion callback.\n\nAsynchronous chown(2). No arguments other than a possible exception are given to the completion callback.\n\nAsynchronous close(2). No arguments other than a possible exception are given to the completion callback.\n\nBe aware that, unlike the default value set for on a readable stream (16 kb), the stream returned by this method has a default value of 64 kb for the same parameter.\n\nis an object or string with the following defaults:\n\ncan include and values to read a range of bytes from the file instead of the entire file. Both and are inclusive and start at 0. The can be any one of those accepted by .\n\nIf is specified, will ignore the argument and will use the specified file descriptor. This means that no event will be emitted. Note that should be blocking; non-blocking s should be passed to .\n\nIf is false, then the file descriptor won't be closed, even if there's an error. It is your responsibility to close it and make sure there's no file descriptor leak. If is set to true (default behavior), on or the file descriptor will be closed automatically.\n\nsets the file mode (permission and sticky bits), but only if the file was created.\n\nAn example to read the last 10 bytes of a file which is 100 bytes long:\n\nIf is a string, then it specifies the encoding.\n\nis an object or string with the following defaults:\n\nmay also include a option to allow writing data at some position past the beginning of the file. Modifying a file rather than replacing it may require a mode of rather than the default mode . The can be any one of those accepted by .\n\nLike , if is specified, will ignore the argument and will use the specified file descriptor. This means that no event will be emitted. Note that should be blocking; non-blocking s should be passed to .\n\nIf is a string, then it specifies the encoding.\n\nTest whether or not the given path exists by checking with the file system. Then call the argument with either true or false. Example:\n\nUsing to check for the existence of a file before calling , or is not recommended. Doing so introduces a race condition, since other processes may change the file's state between the two calls. Instead, user code should open/read/write the file directly and handle the error raised if the file does not exist.\n\nThe \"not recommended\" examples above check for existence and then use the file; the \"recommended\" examples are better because they use the file directly and handle the error, if any.\n\nIn general, check for the existence of a file only if the file won’t be used directly, for example when its existence is a signal from another process.\n\nSynchronous version of . Returns if the file exists, otherwise.\n\nAsynchronous fchmod(2). No arguments other than a possible exception are given to the completion callback.\n\nAsynchronous fchown(2). No arguments other than a possible exception are given to the completion callback.\n\nAsynchronous fdatasync(2). No arguments other than a possible exception are given to the completion callback.\n\nAsynchronous fstat(2). The callback gets two arguments where is a object. is identical to , except that the file to be stat-ed is specified by the file descriptor .\n\nAsynchronous fsync(2). No arguments other than a possible exception are given to the completion callback.\n\nAsynchronous ftruncate(2). No arguments other than a possible exception are given to the completion callback.\n\nChange the file timestamps of a file referenced by the supplied file descriptor.\n\nAsynchronous lchmod(2). No arguments other than a possible exception are given to the completion callback.\n\nOnly available on Mac OS X.\n\nAsynchronous lchown(2). No arguments other than a possible exception are given to the completion callback.\n\nAsynchronous link(2). No arguments other than a possible exception are given to the completion callback.\n\nAsynchronous lstat(2). The callback gets two arguments where is a object. is identical to , except that if is a symbolic link, then the link itself is stat-ed, not the file that it refers to.\n\nAsynchronous mkdir(2). No arguments other than a possible exception are given to the completion callback. defaults to .\n\nAsynchronous file open. See open(2). can be:\n• None - Open file for reading. An exception occurs if the file does not exist.\n• None - Open file for reading and writing. An exception occurs if the file does not exist.\n• None - Open file for reading in synchronous mode. Instructs the operating system to bypass the local file system cache. This is primarily useful for opening files on NFS mounts as it allows you to skip the potentially stale local cache. It has a very real impact on I/O performance so don't use this flag unless you need it. Note that this doesn't turn into a synchronous blocking call. If that's what you want then you should be using\n• None - Open file for reading and writing, telling the OS to open it synchronously. See notes for about using this with caution.\n• None - Open file for writing. The file is created (if it does not exist) or truncated (if it exists).\n• None - Like but fails if exists.\n• None - Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).\n• None - Like but fails if exists.\n• None - Open file for appending. The file is created if it does not exist.\n• None - Like but fails if exists.\n• None - Open file for reading and appending. The file is created if it does not exist.\n• None - Like but fails if exists.\n\nsets the file mode (permission and sticky bits), but only if the file was created. It defaults to , readable and writable.\n\nThe callback gets two arguments .\n\nThe exclusive flag ( flag in open(2)) ensures that is newly created. On POSIX systems, is considered to exist even if it is a symlink to a non-existent file. The exclusive flag may or may not work with network file systems.\n\ncan also be a number as documented by open(2); commonly used constants are available from . On Windows, flags are translated to their equivalent ones where applicable, e.g. to , or to , as accepted by CreateFileW.\n\nOn Linux, positional writes don't work when the file is opened in append mode. The kernel ignores the position argument and always appends the data to the end of the file.\n\nSynchronous version of . Returns an integer representing the file descriptor.\n\nRead data from the file specified by .\n\nis the buffer that the data will be written to.\n\nis the offset in the buffer to start writing at.\n\nis an integer specifying the number of bytes to read.\n\nis an integer specifying where to begin reading from in the file. If is , data will be read from the current file position.\n\nThe callback is given the three arguments, .\n\nAsynchronous readdir(3). Reads the contents of a directory. The callback gets two arguments where is an array of the names of the files in the directory excluding and .\n\nSynchronous readdir(3). Returns an array of filenames excluding and .\n\nAsynchronously reads the entire contents of a file. Example:\n\nThe callback is passed two arguments , where is the contents of the file.\n\nIf no encoding is specified, then the raw buffer is returned.\n\nIf is a string, then it specifies the encoding. Example:\n\nSynchronous version of . Returns the contents of the .\n\nIf the option is specified then this function returns a string. Otherwise it returns a buffer.\n\nAsynchronous readlink(2). The callback gets two arguments .\n\nAsynchronous realpath(2). The gets two arguments . May use to resolve relative paths. is an object literal of mapped paths that can be used to force a specific path resolution or avoid additional calls for known real paths.\n\nSynchronous version of . Returns the number of .\n\nSynchronous realpath(2). Returns the resolved path. is an object literal of mapped paths that can be used to force a specific path resolution or avoid additional calls for known real paths.\n\nAsynchronous rename(2). No arguments other than a possible exception are given to the completion callback.\n\nAsynchronous rmdir(2). No arguments other than a possible exception are given to the completion callback.\n\nAsynchronous stat(2). The callback gets two arguments where is a object. See the section for more information.\n\nAsynchronous symlink(2). No arguments other than a possible exception are given to the completion callback. The argument can be set to , , or (default is ) and is only available on Windows (ignored on other platforms). Note that Windows junction points require the destination path to be absolute. When using , the argument will automatically be normalized to absolute path.\n\nHere is an example below:\n\nIt creates a symbolic link named \"new-port\" that points to \"foo\".\n\nAsynchronous truncate(2). No arguments other than a possible exception are given to the completion callback. A file descriptor can also be passed as the first argument. In this case, is called.\n\nAsynchronous unlink(2). No arguments other than a possible exception are given to the completion callback.\n\nStop watching for changes on . If is specified, only that particular listener is removed. Otherwise, all listeners are removed and you have effectively stopped watching .\n\nCalling with a filename that is not being watched is a no-op, not an error.\n\nNote: is more efficient than and . should be used instead of and when possible.\n\nChange file timestamps of the file referenced by the supplied path.\n\nNote: the arguments and of the following related functions does follow the below rules:\n• If the value is a numberable string like , the value would get converted to corresponding number.\n• If the value is or , the value would get converted to .\n\nWatch for changes on , where is either a file or a directory. The returned object is a .\n\nThe second argument is optional. The if provided should be an object. The supported boolean members are and . indicates whether the process should continue to run as long as files are being watched. indicates whether all subdirectories should be watched, or only the current directory. This applies when a directory is specified, and only on supported platforms (See Caveats).\n\nThe listener callback gets two arguments . is either or , and is the name of the file which triggered the event.\n\nThe API is not 100% consistent across platforms, and is unavailable in some situations.\n\nThe recursive option is only supported on OS X and Windows.\n\nThis feature depends on the underlying operating system providing a way to be notified of filesystem changes.\n• On Linux systems, this uses .\n• On BSD systems, this uses .\n• On OS X, this uses for files and 'FSEvents' for directories.\n• On SunOS systems (including Solaris and SmartOS), this uses .\n• On Windows systems, this feature depends on .\n• On Aix systems, this feature depends on , which must be enabled.\n\nIf the underlying functionality is not available for some reason, then will not be able to function. For example, watching files or directories can be unreliable, and in some cases impossible, on network file systems (NFS, SMB, etc), or host file systems when using virtualization software such as Vagrant, Docker, etc.\n\nYou can still use , which uses stat polling, but it is slower and less reliable.\n\nOn Linux and OS X systems, resolves the path to an inode and watches the inode. If the watched path is deleted and recreated, it is assigned a new inode. The watch will emit an event for the delete but will continue watching the original inode. Events for the new inode will not be emitted. This is expected behavior.\n\nProviding argument in the callback is only supported on Linux and Windows. Even on supported platforms, is not always guaranteed to be provided. Therefore, don't assume that argument is always provided in the callback, and have some fallback logic if it is null.\n\nWatch for changes on . The callback will be called each time the file is accessed.\n\nThe argument may be omitted. If provided, it should be an object. The object may contain a boolean named that indicates whether the process should continue to run as long as files are being watched. The object may specify an property indicating how often the target should be polled in milliseconds. The default is .\n\nThe gets two arguments the current stat object and the previous stat object:\n\nThese stat objects are instances of .\n\nIf you want to be notified when the file was modified, not just accessed, you need to compare and .\n\nNote: when an operation results in an error, it will invoke the listener once, with all the fields zeroed (or, for dates, the Unix Epoch). In Windows, and fields will be , instead of zero. If the file is created later on, the listener will be called again, with the latest stat objects. This is a change in functionality since v0.10.\n\nNote: is more efficient than and . should be used instead of and when possible.\n\nWrite to the file specified by .\n\nand determine the part of the buffer to be written.\n\nrefers to the offset from the beginning of the file where this data should be written. If , the data will be written at the current position. See pwrite(2).\n\nThe callback will be given three arguments where specifies how many bytes were written from .\n\nNote that it is unsafe to use multiple times on the same file without waiting for the callback. For this scenario, is strongly recommended.\n\nOn Linux, positional writes don't work when the file is opened in append mode. The kernel ignores the position argument and always appends the data to the end of the file.\n\nWrite to the file specified by . If is not a Buffer instance then the value will be coerced to a string.\n\nrefers to the offset from the beginning of the file where this data should be written. If the data will be written at the current position. See pwrite(2).\n\nThe callback will receive the arguments where specifies how many bytes the passed string required to be written. Note that bytes written is not the same as string characters. See .\n\nUnlike when writing , the entire string must be written. No substring may be specified. This is because the byte offset of the resulting data may not be the same as the string offset.\n\nNote that it is unsafe to use multiple times on the same file without waiting for the callback. For this scenario, is strongly recommended.\n\nOn Linux, positional writes don't work when the file is opened in append mode. The kernel ignores the position argument and always appends the data to the end of the file.\n\nAsynchronously writes data to a file, replacing the file if it already exists. can be a string or a buffer.\n\nThe option is ignored if is a buffer. It defaults to .\n\nIf is a string, then it specifies the encoding. Example:\n\nNote that it is unsafe to use multiple times on the same file without waiting for the callback. For this scenario, is strongly recommended.\n\nSynchronous versions of . Returns the number of bytes written."
    },
    {
        "link": "https://w3schools.com/nodejs/nodejs_filesystem.asp",
        "document": "The Node.js file system module allows you to work with the file system on your computer.\n\nTo include the File System module, use the method:\n\nCommon use for the File System module:\n\nThe method is used to read files on your computer.\n\nAssume we have the following HTML file (located in the same folder as Node.js):\n\nCreate a Node.js file that reads the HTML file, and return the content:\n\nSave the code above in a file called \"demo_readfile.js\", and initiate the file:\n\nIf you have followed the same steps on your computer, you will see the same result as the example: http://localhost:8080\n\nThe File System module has methods for creating new files:\n\nThe method appends specified content to a file. If the file does not exist, the file will be created:\n\nThe method takes a \"flag\" as the second argument, if the flag is \"w\" for \"writing\", the specified file is opened for writing. If the file does not exist, an empty file is created:\n\nThe method replaces the specified file and content if it exists. If the file does not exist, a new file, containing the specified content, will be created:\n\nThe File System module has methods for updating files:\n\nThe method appends the specified content at the end of the specified file:\n\nThe method replaces the specified file and content:\n\nTo delete a file with the File System module, use the method.\n\nThe method deletes the specified file:\n\nTo rename a file with the File System module, use the method.\n\nThe method renames the specified file:\n\nYou can also use Node.js to upload files to your computer.\n\nRead how in our Node.js Upload Files chapter."
    },
    {
        "link": "https://node.readthedocs.io/en/latest/api/fs",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/16822074/javascript-turning-my-authentication-function-into-a-promise",
        "document": "If you want a half hour introduction to promises in video form I'd suggest my talk from JSConf.eu: http://youtu.be/qbKWsbJ76-s\n\nI get the impression from your question that you haven't really looked at promises before (and from some of the other answers that not everyone else has either).\n\nJavaScript promises are defined in the Promises/A+ specification. It's very easy to read so worth a look. Not all promises follow this spec (jQuery being the only really noteworthy exception) but you can find a list of compliant implementations here\n\nIf you want to see how promises are implemented, promise is one of the simplest (it also has among the fastest performance). DISCLAIMER: I wrote this one\n\nPromise is extremely limited though, so without lots of extensions it's not of much use. I'd recommend you use Q to start with as it's one of the most popular and has lots of features that make using it much simpler. Q also fits best with most of the thinking in future specifications.\n\nIf you are using Mongoose as your database driver it comes with its own implementation of Promises/A+ so you could just use that:\n\nWhat's going on here is that is returning a \"promise\" because it was called without a callback. The handler attached by adds a callback. It also returns a new promise and any errors from the first promise are automatically propagated to the new promise. If an error is thrown inside the callback that new promise is \"rejected\". If the callback returns a value then the new promise is \"fulfilled\" with that value.\n\nHaving defined our function like that we can call it:\n\nIf at some point we want to handle that error, we can do so by attaching an error handler:\n\nThe only issue is that if throws an error it will get silenced (which is bad). If you are done chaining calls onto a promise you need to end that chain.\n\nIf you are using the promises built into mongoose then you call end\n\nIf you were using Q promises then you would call done\n\nIf you have a mongoose promise that you want to convert to a Q promise you can simply pass it to :\n\nIf you're not using Mongoose\n\nIf you're not using Mongoose and you need to create a Q promise from scratch you use Q.promise\n\nThere's also a shortcut for handling node style APIs:\n\nFinally, if you're wondering why promises work the way they do or you think their design is silly in some way, https://github.com/kriskowal/q/blob/master/design/README.js is an excellent guide. It takes you through the development of a promise library from the ground up, starting pretty much exactly where you are with thinking \"callbacks aren't quite good enough\" all the way up to a full promise library."
    },
    {
        "link": "https://forum.freecodecamp.org/t/nodejs-call-function-to-authneticate-got-promise-back/464845",
        "document": "Hi folks,\n\n I have a little problem that I try to solve. In Node I create an API. To call it I let the user also submit an authentication code/token that needs to be verified before proceeding with the request.\n\n Now let’s say I call a function “user”, in this function I call a function auth in another file. The token is there, but first I get back a Promise { false }.\n\nHere’s the one I call via the API:\n\nThe auth-function I am calling in the auth-file is:\n\nAs you can see I work with many console-logs, but this helped me to see what is happening.\n\nSo I get back a Promise with false two times rather than a right result. In the end I get the API returning the data I want, but it feels like Auth is not working correctly. How can I fix this and understand the issue?"
    },
    {
        "link": "https://stackoverflow.com/questions/45041462/node-js-when-to-use-promises-vs-callbacks",
        "document": "I don't remember from where I got this stuff but might be helpful in understanding promises better.\n\nPromises are not callbacks. A promise represents the future result of an asynchronous operation. Of course, writing them the way you do, you get little benefit. But if you write them the way they are meant to be used, you can write asynchronous code in a way that resembles synchronous code and is much more easy to follow: ADVANTAGES 1. Readability over callbacks 2. Easy to catch errors. 3. Simultaneous callbacks\n\n1. Readability over callbacks Promises provide a more succinct and clear way of representing sequential asynchronous operations in javascript. They are effectively a different syntax for achieving the same effect as callbacks. The advantage is increased readability. Something like this\n\nis much more readable than the equivalent of passing each of those individual functions as callbacks, like\n\n2. Easy to catch errors. Certainly, not much less code, but much more readable. But this is not the end. Let's discover the true benefits: What if you wanted to check for any error in any of the steps? It would be hell to do it with callbacks, but with promises, is a piece of cake:\n\n3. Simultaneous callbacks And even better: What if those 3 calls to api, api2, api3 could run simultaneously (e.g. if they were AJAX calls) but you needed to wait for the three? Without promises, you should have to create some sort of counter. With promises, using the ES6 notation, is another piece of cake and pretty neat:\n\nHope you see Promises in a new light now."
    },
    {
        "link": "https://mongodb.com/docs/drivers/node/v4.10/fundamentals/promises",
        "document": "The Node.js driver uses the asynchronous Javascript API to communicate with your MongoDB cluster. Asynchronous Javascript allows you to execute operations without waiting for the processing thread to become free. This helps prevent your application from becoming unresponsive when executing long-running operations. For more information about asynchronous Javascript, see the MDN web documentation on Asynchronous Javascript . This section describes two features of asynchronous Javascript -- and -- that you can use with the Node.js driver to access the results of your method calls to your MongoDB cluster.\n\nA Promise is an object returned by the asynchronous method call that allows you to access information on the eventual success or failure of the operation that they wrap. The Promise is in the Pending state if the operation is still running, Fulfilled if the operation completed successfully, and Rejected if the operation threw an exception. For more information on Promises and related terminology, see the MDN documentation on Promises . Most driver methods that communicate with your MongoDB cluster such as , , and return Promise objects and already contain logic to handle the success or failure of the operation. You can define your own logic that executes once the Promise reaches the Fulfilled or Rejected state by appending the method. The first parameter of is the method that gets called when the Promise reaches the Fulfilled state and the optional second parameter is the method that gets called when it reaches the Rejected state. The method returns a Promise to which you can append additional methods. When you append one or more methods to a Promise, each call passes its execution result to the next one. This pattern is called Promise chaining. The following code snippet shows an example of Promise chaining by appending a single method. If you only need to handle Promise transitions to the Rejected state, rather than passing a first parameter to , you can instead use the method which accepts a single callback, executed when the Promise transitions to the Rejected state. The method is often appended at the end of a Promise chain to handle any exceptions thrown. The following code snippet demonstrates appending a method to the end of a Promise chain. Certain methods in the driver such as return a instead of a Promise. To determine what type each method returns, refer to the Node.js API documentation . If you are using functions, you can use the operator on a Promise to pause further execution until the Promise reaches either the Fulfilled or Rejected state and returns. Since the operator waits for the resolution of the Promise, you can use it in place of Promise chaining to sequentially execute your logic. The following code snippet uses to execute the same logic as the first Promise chaining example. For additional information, see the MDN documentation on await .\n\nCallbacks are deprecated in the Node.js driver version 4.10 and will be removed in a future release. We recommend that you use Promises or Async/Await instead. If your application requires the use of callbacks, you can use the MongoDB Node.js driver with optional callback support , which wraps the Node.js driver and provides optional callback support. A callback is a method that gets called after another method has finished executing. This allows the enclosing method to continue to execute other commands until the original operation completes. Callbacks are often used to enforce the order of processing commands. In the MongoDB Node.js driver, you can optionally declare a callback method to async operations that normally return Promises. Once the operation completes execution, the callback method executes as shown in the following code snippet: For more information on the callback method signature for the specific driver method, see the API documentation . If you specify a callback, the method does not return a Promise.\n\nOne common mistake when using methods is to forget to use operator on Promises to get the value of the result rather than the Promise object. Consider the following example in which we iterate over a cursor using , which returns a Promise that resolves to a boolean that indicates whether additional results exist, and which returns a Promise that resolves to the next entry the cursor is pointing to. Since the call to returns a , the conditional statement returns regardless of the value that it resolves to. If we alter the code to the call to only, as demonstrated in the following code snippet, it throws the following error: . While is not called until after the result of returns, the call to returns a Promise which evaluates to rather than the value it resolves to, similar to the prior example. The code attempts to call on a Cursor that has already returned its results and closed as a result. If we alter the code to only the call to as shown in the following example, the console prints Promise objects rather than the document objects. Use before both the and method calls to ensure that you are operating on the correct return values as demonstrated in the following code: For additional information on using Promises and Callbacks with the MongoDB Node.js driver, see this MongoDB University course video on asynchronous Javascript programming ."
    },
    {
        "link": "https://geeksforgeeks.org/promises-in-node-js",
        "document": "Promises are a fundamental concept in asynchronous programming in JavaScript, especially in NodeJS, where non-blocking I/O operations are key to performance. Promises allow us to handle asynchronous operations more efficiently than traditional callback functions, leading to cleaner, more readable code.\n\nPromises are a way to handle asynchronous operations in NodeJS, providing a cleaner and more readable approach compared to callbacks. They represent the eventual completion (or failure) of an asynchronous operation.\n\nIt acts as a placeholder for a result that is not immediately available but will be at some point in the future. Promises are used to manage asynchronous operations such as file reading, network requests, or database queries.\n\nA Promise can be in one of three states\n• Pending: The initial state; the asynchronous operation is still in progress.\n• Fulfilled: The operation was completed successfully, and a result is available.\n• Rejected: The operation failed, and an error or reason is provided.\n• None The Promise is created with the resolve() function immediately resolving the value “Success”.\n• None The .then() method is used to handle the resolved value, logging it to the console.\n\nHow Do Promises Work in Node.js?\n\nIn NodeJS, asynchronous tasks such as reading files, making HTTP requests, or querying a database are handled without blocking the execution of other code. Traditionally, callbacks were used to handle these asynchronous tasks. However, callbacks can quickly lead to callback hell—a situation where callbacks are nested within callbacks, making the code difficult to read and maintain.\n\nPromises help mitigate this issue by providing a more structured way to handle asynchronous operations. Instead of nesting functions, Promises allow chaining of operations, leading to cleaner and more understandable code.\n\nA Promise is created using the new Promise() constructor. The constructor takes a single argument—a function known as the executor function—which is invoked immediately. The executor function takes two arguments:\n• resolve: A function to call if the asynchronous operation is successful.\n• reject: A function to call if the asynchronous operation fails.\n• Creating a Promise : We create a new Promise that simulates a task taking 2 seconds.\n• Resolving or Rejecting: After 2 seconds, the task either resolves with a success message or rejects with a failure message, based on the success variable.\n• Handling the Promise : We use .then() to handle a successful resolution and .catch() to handle any errors.\n\nError handling is important in asynchronous JavaScript. Promises provide a cleaner way to manage errors compared to callbacks. Using .catch() at the end of a promise chain simplifies error management.\n• None The promise randomly resolves or rejects based on a generated number.\n• None The .catch() block handles any rejections that occur in the promise or any of the .then handlers.\n\nOutput (if an error occurs during the first fetch):\n\nPromise chaining allows you to execute asynchronous operations sequentially. Each .then() receives the result of the previous one. This creates a readable and maintainable flow for asynchronous code.\n• None Promises are chained using .then().\n• None Each .then() receives the result from the previous promise.\n• None .catch() handles any errors in the chain.\n\nPromise.all() allows you to execute multiple promises concurrently. It resolves when all promises have resolved, or rejects if any promise rejects.\n• None p1, p2, and p3 are promises that resolve after different time intervals.\n• None If all promises resolve, the .then() block is executed with an array of the resolved values.\n• None If any promise rejects, the .catch() block is executed with the rejection reason.\n\nWhy Moved from Callbacks to Promises (Callback Hell Issue)\n\nCallbacks were the original way to handle asynchronous operations in JavaScript. However, deeply nested callbacks can lead to “callback hell,” making code difficult to read and maintain. Promises offer a cleaner and more structured approach.\n• None This code shows how nested callbacks make asynchronous code hard to read. Each step depends on the previous one, creating a “pyramid of doom.”\n• None Error handling is also complex, with repetitive if (err) checks at each level. This can become difficult to manage as the code grows.\n• None The deep nesting makes it hard to visualize the overall flow of the asynchronous operations.\n\nSame example with Promises\n\nPromises offer a cleaner and more structured way to handle asynchronous operations, avoiding the “callback hell” of nested callbacks. They make asynchronous code easier to read, write, and maintain.\n• None This code uses .then() chaining to sequence the asynchronous operations. Each .then() receives the result from the previous one.\n• None The .catch() block at the end handles any errors that might occur in any of the promises, making error management much simpler.\n• Inverted Control Flow: The logic for handling results is scattered within the nested callbacks, making it difficult to follow the overall flow of the program.\n• Error Handling Complexity: Error handling becomes cumbersome, with repetitive if (err) checks at each level of nesting. It’s easy to miss handling errors in some branches\n\nIn JavaScript, Promises are used to handle asynchronous operations, allowing you to attach callback functions that execute when the operation is completed or fails.\n• None fetchData returns a Promise that resolves after 1 second.\n• None processData takes the fetched data and returns a Promise that resolves after another second.\n• None are chained to handle the results sequentially.\n• None method handles any errors that occur during the asynchronous operations.\n\nBest Practices for Using Promises in NodeJS\n• Use async/await for cleaner code : Simplifies asynchronous code, making it more readable and maintainable.\n• Handle errors with .catch() or try/catch : Ensures that errors in promise chains are caught and handled appropriately.\n• Use Promise.all() for parallel operations : Executes multiple promises concurrently and waits for all to complete.\n\nWhat is a Promise in NodeJS?\n\nHow do I handle errors in Promises?\n\nWhat is the difference between Promise.all() and Promise.race()?\n\nWhat is “promise hell” and how can I avoid it?"
    }
]