[
    {
        "link": "https://numpy.org/doc/2.1/reference/generated/numpy.arctan2.html",
        "document": "The quadrant (i.e., branch) is chosen so that is the signed angle in radians between the ray ending at the origin and passing through the point (1,0), and the ray ending at the origin and passing through the point (x2, x1). (Note the role reversal: the “y-coordinate” is the first function parameter, the “x-coordinate” is the second.) By IEEE convention, this function is defined for x2 = +/-0 and for either or both of x1 and x2 = +/-inf (see Notes for specific values).\n\nThis function is not defined for complex-valued arguments; for the so-called argument of complex values, use .\n\nx-coordinates. If , they must be broadcastable to a common shape (which becomes the shape of the output). out ndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default , locations within it where the condition is False will remain uninitialized. For other keyword-only arguments, see the ufunc docs. Array of angles in radians, in the range . This is a scalar if both x1 and x2 are scalars.\n\narctan2 is identical to the function of the underlying C library. The following special values are defined in the C standard: [1]\n\nNote that +0 and -0 are distinct floating point numbers, as are +inf and -inf.\n\nConsider four points in different quadrants:\n\nNote the order of the parameters. is defined also when x2 = 0 and at several other special points, obtaining values in the range :"
    },
    {
        "link": "https://numpy.org/doc/2.0/reference/generated/numpy.arctan2.html",
        "document": "The quadrant (i.e., branch) is chosen so that is the signed angle in radians between the ray ending at the origin and passing through the point (1,0), and the ray ending at the origin and passing through the point (x2, x1). (Note the role reversal: the “y-coordinate” is the first function parameter, the “x-coordinate” is the second.) By IEEE convention, this function is defined for x2 = +/-0 and for either or both of x1 and x2 = +/-inf (see Notes for specific values).\n\nThis function is not defined for complex-valued arguments; for the so-called argument of complex values, use .\n\nx-coordinates. If , they must be broadcastable to a common shape (which becomes the shape of the output). out ndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default , locations within it where the condition is False will remain uninitialized. For other keyword-only arguments, see the ufunc docs. Array of angles in radians, in the range . This is a scalar if both x1 and x2 are scalars.\n\narctan2 is identical to the function of the underlying C library. The following special values are defined in the C standard: [1]\n\nNote that +0 and -0 are distinct floating point numbers, as are +inf and -inf.\n\nConsider four points in different quadrants:\n\nNote the order of the parameters. is defined also when x2 = 0 and at several other special points, obtaining values in the range :"
    },
    {
        "link": "https://numpy.org/devdocs/reference/generated/numpy.arctan2.html",
        "document": "The quadrant (i.e., branch) is chosen so that is the signed angle in radians between the ray ending at the origin and passing through the point (1,0), and the ray ending at the origin and passing through the point (x2, x1). (Note the role reversal: the “y-coordinate” is the first function parameter, the “x-coordinate” is the second.) By IEEE convention, this function is defined for x2 = +/-0 and for either or both of x1 and x2 = +/-inf (see Notes for specific values).\n\nThis function is not defined for complex-valued arguments; for the so-called argument of complex values, use .\n\nx-coordinates. If , they must be broadcastable to a common shape (which becomes the shape of the output). out ndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs. This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result. Elsewhere, the out array will retain its original value. Note that if an uninitialized out array is created via the default , locations within it where the condition is False will remain uninitialized. For other keyword-only arguments, see the ufunc docs. Array of angles in radians, in the range . This is a scalar if both x1 and x2 are scalars.\n\narctan2 is identical to the function of the underlying C library. The following special values are defined in the C standard: [1]\n\nNote that +0 and -0 are distinct floating point numbers, as are +inf and -inf."
    },
    {
        "link": "https://geeksforgeeks.org/numpy-arctan2-python",
        "document": "The numpy.arctan2() method computes element-wise arc tangent of arr1/arr2 choosing the quadrant correctly. The quadrant is chosen so that arctan2(x1, x2) is the signed angle in radians between the ray ending at the origin and passing through the point (1, 0), and the ray ending at the origin and passing through the point (x2, x1). \n\n\n\nSyntax : numpy.arctan2(arr1, arr2, casting = ‘same_kind’, order = ‘K’, dtype = None, ufunc ‘arctan’) \n\nParameters : \n\narr1 : [array_like] real valued; y-coordinates \n\narr2 : [array_like] real valued; x-coordinates. It must match shape of y-coordinates. \n\nout : [ndarray, array_like [OPTIONAL]] array of same shape as x. \n\nwhere : [array_like, optional] True value means to calculate the universal functions(ufunc) at that position, False value means to leave the value in the output alone.\n\nNote : \n\n2pi Radians = 360 degrees \n\nThe convention is to return the angle z whose real part lies in [-pi/2, pi/2].\n\nReturn : Element-wise arc tangent of arr1/arr2. The values are in the closed interval [-pi / 2, pi / 2]."
    },
    {
        "link": "https://docs.scipy.org/doc/numpy-1.9.0/reference/generated/numpy.arctan2.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/56207448/efficient-quaternions-to-euler-transformation",
        "document": "I'm using the following Python function to convert quaternions to Euler angles:\n\nI would like to transform a Pandas DataFrame, which has columns \"w\", \"quat_x\", \"quat_y\" and \"quat_z\", to Eueler angles. Currently, I'm iterating over each row of the DataFrame using a for loop and call the function on each row. This is very slow because I have more than 400'000 rows.\n\nIs there a more efficient way to do it? For example, I could pass the DataFrame (or inidividual Series) to but then the problem is to change so that it can handle DataFrames instead of integers."
    },
    {
        "link": "https://stackoverflow.com/questions/73447882/implementing-quaternions-to-euler-angle-conversion-in-python",
        "document": "I am trying to write a custom function that takes a quaternion and outputs the Euler angles. I thought it was quite easy: I am using the formulas found here while also looking at the C++ implementation in the same page. The function looks like this:\n\nTo be sure of having the good results, I am comparing my conversion with the one performed by this page.\n\nIt seems that my results are completely off. As an example compare the results of my function for a specific quaternion:\n\nTo the results of the page linked above:\n\nThe formulas seem quite straightforward to me, and I cannot see any self-evident mistake in the implementation. Can someone explain to me what I am doing wrong ?\n\nI found out that there is a class that support the conversion between quaternion and euler angle. If I do:\n\nI have exactly the same results as my custom function. Now I am even more confused."
    },
    {
        "link": "https://github.com/joycesudi/quaternion",
        "document": "This Python module provides conversion functions between quaternions and other rotation parameterizations (axis-angle, rotation matrix, Euler angles).\n\nChoosing how to represent the orientation of a solid in three-dimensional space is a fairly complex problem. The aim is to arrive at a compact (no dependent elements) and unique way of describing the orientation of the solid, while guaranteeing numerical stability. The scientific literature presents several choices for parameterizing the orientation of a rigid body: Cardan angles, Euler angles, Cartesian rotation vectors, rotation matrix, Rodrigues parameters, etc.\n\nTo avoid the gimbal lock phenomenon (representation singularity) that occurs for some of the above parameterizations, quaternions can be used as rotation parameters.\n\nIntroduced by Irish mathematician William R. Hamilton (1843), quaternions are hypercomplex numbers using 4 variables (a scalar real part and 3 imaginary components) to represent the orientation of a rigid body. This representation introduces a holonomic constraint equation related to the normalization of the quaternion.\n\nQuaternion is given by the quadruplet :\n\nCompact writing compared to the rotation matrix ● Numerical stability ● No singularity (Cardan blocking)\n\nLet and , two quaternions each representing a given rotation, the product defines the sequence of rotations then .\n\nKnowing the axis and angle of a rotation , we can convert it to a quaternion defining the same rotation as follows:\n\nThe function in the module performs this conversion.\n\nGiven a quaternion p = ⟨e0, e1, e2, e3⟩, the axis of rotation u and the angle of rotation θ can be obtained from the following equations:\n\nThe function in the module performs this conversion.\n\nGiven a quaternion representing the orientation of a given solid, the 3x3 matrix corresponding to this orientation is given by :\n\nThe function in the module performs this conversion.\n\nConsider the following rotation matrix R:\n\nThe quaternion defining the orientation equivalent to this rotation matrix can be defined in 2 steps.\n\nStep 1: We first compute but not their signs.\n\nStep 2: Identify the signs by finding the largest absolute value of and assuming its sign is positive. We then calculate the remaining components of the quaternion as table below. Division by the largest amplitude reduces errors in numerical numerical accuracy.\n\nThe reason for this ambiguity over the signs of the quaternion components is that the quaternions and define the same rotation. The function in the module performs this conversion.\n\nIntroduced by Swiss mathematician and physicist Leonhard Euler, the three Euler angles (roll, pitch, yaw) are used to define the orientation of a rigid body. Roll can be defined as the orientation with respect to the X axis, pitch as the orientation with respect to the Y axis, and yaw as the orientation with respect to the Z axis.\n\nThere are dozens of mutually exclusive ways of defining Euler angles (Conventions XYX, XYZ, XZX, XZY, YXY, YXZ, YZX, YZY, ZXY, ZXZ, ZYX, ZYZ). We therefore need to define which convention is used in our code.\n\nWe have used the following definition of Euler angles in the developed software.\n• Yaw-pitch-roll rotation order (ZYX convention), rotating respectively around axes Z, Y and X axes\n• Active rotation (the point is rotated, not the coordinate system)\n\nBased on this definition, let u (roll angle), v (pitch angle) and w (yaw angle) define a given orientation, the equivalent quaternion is determined as follows:\n\nThe function in the module performs this conversion.\n\nThe conversion of a quaternion into Euler angles (using the definition of Euler angles given in the previous paragraph) is given by the following equations:\n\nEuler angles are susceptible to Cardan blocking (singularity of representation). The preceding equations provide a general solution for determining Euler angles. In the special case where the pitch angle v is equal to +90° or -90°, it becomes impossible to calculate the other 2 angles (roll and yaw), as the function is not defined for the two null arguments. This is because, for a pitch angle of +90° or -90°, the roll and yaw axes are aligned. There is no single solution in this configuration: any orientation can be described using an infinite number of combinations of yaw and roll angles.\n\nTo manage the Cardan lock, we first determine the value of the pitch angle. Depending on whether it is +90° or -90°, we calculate the other 2 angles.\n\nThe function in the module performs this conversion.\n\nKey notes: Of the rotation parameterizations presented, only Euler angles are susceptible to Cardan blocking, quaternions and rotation matrices are not."
    },
    {
        "link": "https://discussions.unity.com/t/python-code-for-converting-quaternion-to-euler-angles/197145",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/AskProgramming/comments/b47sjp/converting_quaternions_to_euler_angles_in_python",
        "document": "For my Senior design project I'm trying to convert Quaternions to Euler Angles but I'm having some issues. I have two functions that take values from my BNO055 sensor and simply displays the values and helps to distinguish if the conversion function is working properly (Shown below)\n\nThis is my conversion function that I am using but I'm not entirely sure the math is 100% correct as I've sourced it from multiple places.\n\nWhen I run my program I check the output and use an online converter(Converter) to see if the input Quaternion gives me the same Euler angle that the sensor does but they don't quite match up, sometimes being off by a few decimal places other times being off by whole numbers. If someone could check to see if my math is correct that would be much appreciated because I think thats where the problem is. Also if you have any good sources on quaternions to euler angle conversions please let me know! I've found a few but they talk more about what a quaternion is and I'm only interested in just converting it into a euler angle. Thanks for the help!\n\nEdit: I also have sample output if needed"
    }
]