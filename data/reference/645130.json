[
    {
        "link": "https://learnopengl.com/Getting-started/Shaders",
        "document": "As mentioned in the Hello Triangle chapter, shaders are little programs that rest on the GPU. These programs are run for each specific section of the graphics pipeline. In a basic sense, shaders are nothing more than programs transforming inputs to outputs. Shaders are also very isolated programs in that they're not allowed to communicate with each other; the only communication they have is via their inputs and outputs.\n\nIn the previous chapter we briefly touched the surface of shaders and how to properly use them. We will now explain shaders, and specifically the OpenGL Shading Language, in a more general fashion.\n\nShaders are written in the C-like language GLSL. GLSL is tailored for use with graphics and contains useful features specifically targeted at vector and matrix manipulation.\n\nShaders always begin with a version declaration, followed by a list of input and output variables, uniforms and its function. Each shader's entry point is at its function where we process any input variables and output the results in its output variables. Don't worry if you don't know what uniforms are, we'll get to those shortly.\n\nA shader typically has the following structure:\n\nWhen we're talking specifically about the vertex shader each input variable is also known as a . There is a maximum number of vertex attributes we're allowed to declare limited by the hardware. OpenGL guarantees there are always at least 16 4-component vertex attributes available, but some hardware may allow for more which you can retrieve by querying :\n\nThis often returns the minimum of which should be more than enough for most purposes.\n\nGLSL has, like any other programming language, data types for specifying what kind of variable we want to work with. GLSL has most of the default basic types we know from languages like C: , , , and . GLSL also features two container types that we'll be using a lot, namely and . We'll discuss matrices in a later chapter.\n\nA vector in GLSL is a 2,3 or 4 component container for any of the basic types just mentioned. They can take the following form ( represents the number of components):\n\nMost of the time we will be using the basic since floats are sufficient for most of our purposes.\n\nComponents of a vector can be accessed via where is the first component of the vector. You can use , , and to access their first, second, third and fourth component respectively. GLSL also allows you to use for colors or for texture coordinates, accessing the same components.\n\nThe vector datatype allows for some interesting and flexible component selection called . Swizzling allows us to use syntax like this:\n\nYou can use any combination of up to 4 letters to create a new vector (of the same type) as long as the original vector has those components; it is not allowed to access the component of a for example. We can also pass vectors as arguments to different vector constructor calls, reducing the number of arguments required:\n\nVectors are thus a flexible datatype that we can use for all kinds of input and output. Throughout the book you'll see plenty of examples of how we can creatively manage vectors.\n\nShaders are nice little programs on their own, but they are part of a whole and for that reason we want to have inputs and outputs on the individual shaders so that we can move stuff around. GLSL defined the and keywords specifically for that purpose. Each shader can specify inputs and outputs using those keywords and wherever an output variable matches with an input variable of the next shader stage they're passed along. The vertex and fragment shader differ a bit though.\n\nThe vertex shader should receive some form of input otherwise it would be pretty ineffective. The vertex shader differs in its input, in that it receives its input straight from the vertex data. To define how the vertex data is organized we specify the input variables with location metadata so we can configure the vertex attributes on the CPU. We've seen this in the previous chapter as . The vertex shader thus requires an extra layout specification for its inputs so we can link it with the vertex data.\n\nThe other exception is that the fragment shader requires a color output variable, since the fragment shaders needs to generate a final output color. If you fail to specify an output color in your fragment shader, the color buffer output for those fragments will be undefined (which usually means OpenGL will render them either black or white).\n\nSo if we want to send data from one shader to the other we'd have to declare an output in the sending shader and a similar input in the receiving shader. When the types and the names are equal on both sides OpenGL will link those variables together and then it is possible to send data between shaders (this is done when linking a program object). To show you how this works in practice we're going to alter the shaders from the previous chapter to let the vertex shader decide the color for the fragment shader.\n\nYou can see we declared a variable as a output that we set in the vertex shader and we declare a similar input in the fragment shader. Since they both have the same type and name, the in the fragment shader is linked to the in the vertex shader. Because we set the color to a dark-red color in the vertex shader, the resulting fragments should be dark-red as well. The following image shows the output:\n\nThere we go! We just managed to send a value from the vertex shader to the fragment shader. Let's spice it up a bit and see if we can send a color from our application to the fragment shader!\n\nare another way to pass data from our application on the CPU to the shaders on the GPU. Uniforms are however slightly different compared to vertex attributes. First of all, uniforms are . Global, meaning that a uniform variable is unique per shader program object, and can be accessed from any shader at any stage in the shader program. Second, whatever you set the uniform value to, uniforms will keep their values until they're either reset or updated.\n\nTo declare a uniform in GLSL we simply add the keyword to a shader with a type and a name. From that point on we can use the newly declared uniform in the shader. Let's see if this time we can set the color of the triangle via a uniform:\n\nWe declared a uniform in the fragment shader and set the fragment's output color to the content of this uniform value. Since uniforms are global variables, we can define them in any shader stage we'd like so no need to go through the vertex shader again to get something to the fragment shader. We're not using this uniform in the vertex shader so there's no need to define it there.\n\nThe uniform is currently empty; we haven't added any data to the uniform yet so let's try that. We first need to find the index/location of the uniform attribute in our shader. Once we have the index/location of the uniform, we can update its values. Instead of passing a single color to the fragment shader, let's spice things up by gradually changing color over time:\n\nFirst, we retrieve the running time in seconds via . Then we vary the color in the range of - by using the function and store the result in .\n\nThen we query for the location of the uniform using . We supply the shader program and the name of the uniform (that we want to retrieve the location from) to the query function. If returns , it could not find the location. Lastly we can set the uniform value using the function. Note that finding the uniform location does not require you to use the shader program first, but updating a uniform does require you to first use the program (by calling ), because it sets the uniform on the currently active shader program.\n\nNow that we know how to set the values of uniform variables, we can use them for rendering. If we want the color to gradually change, we want to update this uniform every frame, otherwise the triangle would maintain a single solid color if we only set it once. So we calculate the and update the uniform each render iteration:\n\nThe code is a relatively straightforward adaptation of the previous code. This time, we update a uniform value each frame before drawing the triangle. If you update the uniform correctly you should see the color of your triangle gradually change from green to black and back to green.\n\nCheck out the source code here if you're stuck.\n\nAs you can see, uniforms are a useful tool for setting attributes that may change every frame, or for interchanging data between your application and your shaders, but what if we want to set a color for each vertex? In that case we'd have to declare as many uniforms as we have vertices. A better solution would be to include more data in the vertex attributes which is what we're going to do now.\n\nWe saw in the previous chapter how we can fill a VBO, configure vertex attribute pointers and store it all in a VAO. This time, we also want to add color data to the vertex data. We're going to add color data as 3 s to the array. We assign a red, green and blue color to each of the corners of our triangle respectively:\n\nSince we now have more data to send to the vertex shader, it is necessary to adjust the vertex shader to also receive our color value as a vertex attribute input. Note that we set the location of the attribute to 1 with the layout specifier:\n\nSince we no longer use a uniform for the fragment's color, but now use the output variable we'll have to change the fragment shader as well:\n\nBecause we added another vertex attribute and updated the VBO's memory we have to re-configure the vertex attribute pointers. The updated data in the VBO's memory now looks a bit like this:\n\nKnowing the current layout we can update the vertex format with :\n\nThe first few arguments of are relatively straightforward. This time we are configuring the vertex attribute on attribute location . The color values have a size of s and we do not normalize the values.\n\nSince we now have two vertex attributes we have to re-calculate the stride value. To get the next attribute value (e.g. the next component of the position vector) in the data array we have to move s to the right, three for the position values and three for the color values. This gives us a stride value of 6 times the size of a in bytes (= bytes). \n\n Also, this time we have to specify an offset. For each vertex, the position vertex attribute is first so we declare an offset of . The color attribute starts after the position data so the offset is in bytes (= bytes).\n\nRunning the application should result in the following image:\n\nCheck out the source code here if you're stuck.\n\nThe image may not be exactly what you would expect, since we only supplied 3 colors, not the huge color palette we're seeing right now. This is all the result of something called in the fragment shader. When rendering a triangle the rasterization stage usually results in a lot more fragments than vertices originally specified. The rasterizer then determines the positions of each of those fragments based on where they reside on the triangle shape.\n\n Based on these positions, it all the fragment shader's input variables. Say for example we have a line where the upper point has a green color and the lower point a blue color. If the fragment shader is run at a fragment that resides around a position at of the line, its resulting color input attribute would then be a linear combination of green and blue; to be more precise: blue and green.\n\nThis is exactly what happened at the triangle. We have 3 vertices and thus 3 colors, and judging from the triangle's pixels it probably contains around 50000 fragments, where the fragment shader interpolated the colors among those pixels. If you take a good look at the colors you'll see it all makes sense: red to blue first gets to purple and then to blue. Fragment interpolation is applied to all the fragment shader's input attributes.\n\nWriting, compiling and managing shaders can be quite cumbersome. As a final touch on the shader subject we're going to make our life a bit easier by building a shader class that reads shaders from disk, compiles and links them, checks for errors and is easy to use. This also gives you a bit of an idea how we can encapsulate some of the knowledge we learned so far into useful abstract objects.\n\nWe will create the shader class entirely in a header file, mainly for learning purposes and portability. Let's start by adding the required includes and by defining the class structure:\n\nThe shader class holds the ID of the shader program. Its constructor requires the file paths of the source code of the vertex and fragment shader respectively that we can store on disk as simple text files. To add a little extra we also add several utility functions to ease our lives a little: activates the shader program, and all functions query a uniform location and set its value.\n\nWe're using C++ filestreams to read the content from the file into several objects:\n\nNext we need to compile and link the shaders. Note that we're also reviewing if compilation/linking failed and if so, print the compile-time errors. This is extremely useful when debugging (you are going to need those error logs eventually):\n\nSimilarly for any of the uniform setter functions:\n\nAnd there we have it, a completed shader class. Using the shader class is fairly easy; we create a shader object once and from that point on simply start using it:\n\nHere we stored the vertex and fragment shader source code in two files called and . You're free to name your shader files however you like; I personally find the extensions and quite intuitive.\n\nYou can find the source code here using our newly created shader class. Note that you can click the shader file paths to find the shaders' source code.\n• Adjust the vertex shader so that the triangle is upside down: solution.\n• Specify a horizontal offset via a uniform and move the triangle to the right side of the screen in the vertex shader using this offset value: solution.\n• Output the vertex position to the fragment shader using the keyword and set the fragment's color equal to this vertex position (see how even the vertex position values are interpolated across the triangle). Once you managed to do this; try to answer the following question: why is the bottom-left side of our triangle black?: solution."
    },
    {
        "link": "https://stackoverflow.com/questions/51297676/best-practices-for-coding-compiling-debugging-and-maintaining-shader-programs",
        "document": "The absolute minimum is to have access to GLSL compile and link logs here example:\n• just look for in the code.\n\nFor really hard stuff its best to write your shader as CPU side C++ code and when fully debugged then run it as shader. But for that you would need to write some kind of framework that would emulate shaders. For starters you need vector and matrix arithmetics from GLSL. It is not that easy to code it but there are also another options like GLM. I am using my template but just to enable datatypes its around 228 KByte of hideous code due to its getters setters for more info look here:\n• GLSL like vec template for C++\n\nAnd another absolute minimum is handling input and output. As the fun part is usually located in fragment itst often enough to process only fragment shader this way so you need just 2 nested loops looping through test image calling your shader function and setting the pixel according to its result. I usually place to emulate texture access and that is in nutshell all. For example these shaders I would not be possible to debug otherwise:\n\nAs was mentioned in comments for simpler shaders you can write them in any C++ IDE to enable syntax highlight. But its a good idea to write/debug the stuff in your target App where you simply add some subwindow where you render the GLSL info logs as opening text file after each compilation is a dull click work.\n\nWhen I started coding shaders I was tired of such and write my own IDE for shaders. Its buggy and far from perfect but it fulfills my needs. It looks like this:\n\nLink to it is in (edit3) here:\n• How do I get textures to work in OpenGL?\n\nThere are some similar tools out there but having my own with source code allows a whole lot of stuff like using targets app CPU side code etc ...\n\nAnother very useful thing is to be able to print some variable value from fragment shader. Exactly that I was able to do like this:\n\nyou just need to decide correct conditions for entire area of the print (so the value you are printing is the same while printing all its pixels). This help me a lot especially to use 3D textures and geometry encoded in textures for the first time...\n\nHowever in most cases you can use color output instead of debug prints but having the ability to print actual numbers can save you a lot of time."
    },
    {
        "link": "https://cs.utexas.edu/~fussell/courses/cs354/handouts/Addison.Wesley.OpenGL.Programming.Guide.8th.Edition.Mar.2013.ISBN.0321773039.pdf",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/GraphicsProgramming/comments/wmojdn/help_for_compute_shader_opengl_46",
        "document": "Hi guys, i'm new to opengl (currently using 4.6) and i'm trying to use a simple compute shader.\n\nGiven some vec3, the shader should just increment the values according to the id of the invocation that work on each vec3.\n\nProblem is, i get strange 0 values at fixed intervals, like each 4 values i get a 0....i think this has something to do with the layout but i'm not sure, since std430 should take care of that.\n\nI'll put the code in the following images, been trying to fix this on my own for ages now"
    },
    {
        "link": "https://registry.khronos.org/OpenGL/specs/gl/glspec46.core.pdf",
        "document": ""
    },
    {
        "link": "https://glm.g-truc.net/0.9.8/index.html",
        "document": "OpenGL Mathematics (GLM) is a header only C++ mathematics library for graphics software based on the OpenGL Shading Language (GLSL) specifications. GLM provides classes and functions designed and implemented with the same naming conventions and functionalities than GLSL so that anyone who knows GLSL, can use GLM as well in C++. This project isn't limited to GLSL features. An extension system, based on the GLSL extension conventions, provides extended capabilities: matrix transformations, quaternions, data packing, random numbers, noise, etc... This library works perfectly with OpenGL but it also ensures interoperability with other third party libraries and SDK. It is a good candidate for software rendering (raytracing / rasterisation), image processing, physic simulations and any development context that requires a simple and convenient mathematics library.\n• GLM is written in C++98 but can take advantage of C++11 when supported by the compiler. It is a platform independent library with no dependence and it officially supports the following compilers: For more information about GLM, please have a look at the manual and the API reference documentation. The source code and the documentation, including this manual, are licensed under the Happy Bunny License (Modified MIT) or the MIT License. Thanks for contributing to the project by submitting issues for bug reports and feature requests. Any feedback is welcome at glm@g-truc.net."
    },
    {
        "link": "https://github.com/g-truc/glm",
        "document": "OpenGL Mathematics (GLM) is a header only C++ mathematics library for graphics software based on the OpenGL Shading Language (GLSL) specifications.\n\nGLM provides classes and functions designed and implemented with the same naming conventions and functionality than GLSL so that anyone who knows GLSL, can use GLM as well in C++.\n\nThis project isn't limited to GLSL features. An extension system, based on the GLSL extension conventions, provides extended capabilities: matrix transformations, quaternions, data packing, random numbers, noise, etc...\n\nThis library works perfectly with OpenGL but it also ensures interoperability with other third party libraries and SDK. It is a good candidate for software rendering (raytracing / rasterisation), image processing, physics simulations and any development context that requires a simple and convenient mathematics library.\n\nGLM is written in C++98 but can take advantage of C++11 when supported by the compiler. It is a platform independent library with no dependence and it officially supports the following compilers:\n\nFor more information about GLM, please have a look at the manual and the API reference documentation. The source code and the documentation are licensed under either the Happy Bunny License (Modified MIT) or the MIT License.\n\nThanks for contributing to the project by submitting pull requests.\n\nAnd then in your :\n\nIf your prefer to use header-only version of GLM\n\nYou can add glm to your CMake project to be built together.\n• Unit tests are not build by default, set to required.\n• Enables only warnings as errors while building unit tests\n• Added and to GLM_EXT_scalar_common and GLM_EXT_vector_common\n• Added GLM_FORCE_UNRESTRICTED_FLOAT to prevent static asserts when using other scalar types with function expecting floats.\n• Fixed discards the sign of result for angles in range (2pi-1, 2pi) #1038\n• Removed ban on using with CUDA host code #1041\n• Added , , and function to and extensions with tests\n• Added to store quat data as w,x,y,z instead of x,y,z,w #983\n• Added GLM_EXT_scalar_integer extension with power of two and multiple scalar functions\n• Added GLM_EXT_vector_integer extension with power of two and multiple vector functions\n• Fixed for g++6 where -std=c++1z sets __cplusplus to 201500 instead of 201402 #921\n• Added GLM_FORCE_INTRINSICS to enable SIMD instruction code path. By default, it's disabled allowing constexpr support by default. #865\n• Fixed being defined as unsigned char with some compiler #839\n• Added and overload with max ULPs parameters for scalar numbers #121\n• Added to silent GLM warnings when using language extensions but using W4 or Wpedantic warnings #814 #775\n• Added to enable aligned types and SIMD instruction are not enabled. This disable #816\n• Fixed default initialization with vector and quaternion types using #812\n• Added missing and with epsilon for quaternion types to GLM_GTC_quaternion\n• Added GLM_EXT_matrix_relational: and with epsilon for matrix types\n• Added a section to the manual for contributing to GLM\n• Redesigned constexpr support which excludes both SIMD and #783\n• Clarified refract valid range of the indices of refraction, between -1 and 1 inclusively #806\n• Fixed invalid conversion from int scalar with vec4 constructor when using SSE instruction\n• Fixed infinite loop in random functions when using negative radius values using an assert #739\n• Added GLM_GTX_matrix_factorisation to factor matrices in various forms #654\n• Added GLM_EXT_vector_relational: extend and to take an epsilon argument\n• Added separate functions to use both negative one and zero near clip plans #680\n• Added to use GLM on platforms that don't support double #627\n• No more default initialization of vector, matrix and quaternion types\n• Added error for including of different versions of GLM #619\n• Added GLM_FORCE_IGNORE_VERSION to ignore error caused by including different version of GLM #619\n• Reduced warnings when using very strict compilation flags #646\n• Removed doxygen references to GLM_GTC_half_float which was removed in 0.9.4\n• Fixed references to which was removed #642\n• Fixed when OpenMP is not enabled\n• Fixed Visual C++ internal error when declaring a global vec type with siwzzle expression enabled #594\n• Fixed with Clang and libstlc++ which wasn't using C++11 STL features. #604\n• Added warning messages when using but the compiler is known to not fully support the requested C++ version #555\n• Added right and left handed projection and clip control support #447 #415 #119\n• Added and to GLM_GTC_packing for RGB9E5 #416\n• Added and to GLM_GTC_integer, fast round on positive values\n• Improved SIMD and swizzle operators interactions with GCC and Clang #474\n• Use Cuda built-in function for abs function implementation with Cuda compiler\n• No more warnings for use of long long\n• Fixed to not do any unintentional backface culling\n• Fixed long long warnings when using C++98 on GCC and Clang #482\n• Fixed long long warnings when using C++98 on GCC and Clang #482\n• Fixed to_string when used with GLM_FORCE_INLINE #506\n• Fixed intersectRayTriangle to not do any unintentional backface culling\n• Fixed outerProduct definitions and operator signatures for mat2x4 and vec4 #475\n• Fixed various 'X is not defined' warnings #468\n• Added to_string for quat and dual_quat in GTX_string_cast #375\n• Fixed builtin bitscan never being used #392\n• Added static components and precision members to all vector and quat types #350\n• Added support of defaulted functions to GLM types, to use them in unions #366\n• Don't show status message in 'FindGLM' if 'QUIET' option is set. #317\n• Fixed use of libstdc++ with Clang #351\n• Added display of GLM version with other GLM_MESSAGES\n• Clean up GLM_MESSAGES compilation log to report only detected capabilities\n• Fixed missing explicit conversion when using integer log2 with *vec1 types\n• Fixed Android build issue, STL C++11 is not supported by the NDK #284\n• Added GTX_scalar_multiplication for C++ 11 compiler only #242\n• Added GTX_range for C++ 11 compiler only #240\n• Added support of precision and integers to linearRand #230\n• Rely on C++11 to implement isinf and isnan\n• Undetected C++ compiler automatically compile with GLM_FORCE_CXX98 and GLM_FORCE_PURE\n• Added not function (from GLSL specification) on VC12\n• Used std features within GLM without redeclaring\n• Added explicit cast from quat to mat3 and mat4 #275\n• Fixed std::nextafter not supported with C++11 on Android #217\n• Fixed implicit conversion from another tvec2 type to another tvec2 #241\n• Fixed lack of consistency of quat and dualquat constructors\n• Fixed glm::isinf and glm::isnan for with Android NDK 9d #191\n• Fixed lerp when cosTheta is close to 1 in quaternion slerp #210\n• Fixed std::nextafter not supported with C++11 on Android #213\n• Fixed corner cases in exp and log functions for quaternions #199\n• Added instruction set auto detection with Visual C++ using _M_IX86_FP - /arch compiler argument\n• Added support for all extensions but GTX_string_cast to CUDA\n• Fixed non power of two matrix products\n• Fixed angle and orientedAngle that sometimes return NaN values (#145)\n• Fixed error 'inverse' is not a member of 'glm' from glm::unProject (#146)\n• Fixed mismatch between some declarations and definitions\n• Replaced C cast by C++ casts\n• Fixed .length() that should return a int and not a size_t\n• Removed the normalization of the up argument of lookAt function (#114)\n• Replaced GLM traits by STL traits when possible\n• Added creating of a quaternion from two vectors\n• Fixed detection to select the last known compiler if newer version #106\n• Fixed is_int and is_uint code duplication with GCC and C++11 #107\n• Fixed test suite build while using Clang in C++11 mode\n• Removed ms extension mode to CMake when no using Visual C++\n• Added pedantic mode to CMake test suite for Clang and GCC\n• Added use of GCC frontend on Unix for ICC and Visual C++ fronted on Windows for ICC\n• Fixed language detection on GCC when the C++0x mode isn't enabled #95\n• Fixed slerp when costheta is close to 1 #65\n• Added assert in inversesqrt to detect division by zero #61\n• Fixed glm::perspective when zNear is zero #71\n• Fixed C++11 mode for GCC, couldn't be enabled without MS extensions\n• Clarify the license applying on the manual\n• Fixed isnan and isinf on Android with Clang\n• Autodetected C++ version using __cplusplus value\n• Fixed mix for bool and bvec* third parameter\n• Fixed 0x2013 dash character in comments that cause issue in Windows Japanese mode\n• Fixed quat slerp using mix function when cosTheta close to 1\n• Added GLM_FORCE_RADIANS so that all functions takes radians for arguments\n• Fixed detection of Clang and LLVM GCC on MacOS X\n• Removed VIRTREV_xstream and the incompatibility generated with GCC\n• Fixed many warnings across platforms and compilers\n• Fixed errors and warnings in VC with C++ extensions disabled\n• Clarify that GLM is a header only library.\n• Added == and != operators for every types.\n• New method to use extension."
    },
    {
        "link": "https://stackoverflow.com/questions/44705398/about-glm-quaternion-rotation",
        "document": "I want to make some rotation by quaternion.\n\nThe glm library was done this very well.\n\nThe following was my codes:\n\nMy question is which in many articles the formula of the rotation by quaternion was\n\nIt's weird. In glm the vector \"v\" just multiply by the quaternion \"q\" can do the rotation."
    },
    {
        "link": "http://glm.g-truc.net/glm.pdf",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/38145042/quaternion-to-matrix-using-glm",
        "document": "I am trying to convert quat in glm to mat4.\n\nWhen i run the program it shows the error \"error: ‘quaternion’ has not been declared\".\n\nCan anyone help me with this?"
    }
]