[
    {
        "link": "https://numpy.org/doc/2.2/reference/generated/numpy.argmax.html",
        "document": "Returns the indices of the maximum values along an axis.\n\nBy default, the index is into the flattened array, otherwise along the specified axis. If provided, the result will be inserted into this array. It should be of the appropriate shape and dtype. If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the array. Array of indices into the array. It has the same shape as with the dimension along axis removed. If keepdims is set to True, then the size of axis will be 1 with the resulting array having same shape as .\n\nIn case of multiple occurrences of the maximum values, the indices corresponding to the first occurrence are returned.\n\nIndexes of the maximal elements of a N-dimensional array:"
    },
    {
        "link": "https://geeksforgeeks.org/numpy-argmax-python",
        "document": "The numpy.argmax() function returns indices of the max element of the array in a particular axis.\n\nNote : \n\nThese codes won’t run on online IDE’s. Please run them on your systems to explore the working."
    },
    {
        "link": "https://analyticsvidhya.com/blog/2023/12/all-you-need-to-know-about-numpys-argmax-function",
        "document": "All You Need to Know About NumPy’s argmax() Function\n\nNumPy is a powerful library for numerical operations in Python, providing support for large, multi-dimensional arrays and matrices. One of the many useful functions in NumPy is the argmax() function, which emerges as a gem, offering a dynamic solution to pinpoint the indices of maximum values along a designated axis within an array. This article delves into NumPy’s argmax() depths, unraveling its syntax, parameters, return values, and practical use cases.\n\nAt its core, the argmax() function in NumPy returns the indices of the maximum values along a specified axis in an array. It allows us to efficiently find the position of the maximum element in an array, which can be useful in various scenarios. Examples include finding the most frequent element, identifying the dominant color in an image, or selecting the best model in machine learning.\n\nThe Basics of argmax in Python\n\nBefore diving into the details of the np.argmax() function, let’s first understand the basics of argmax in Python. The argmax() function is a built-in function in Python that returns the maximum value index in an iterable. It can be used with lists, tuples, or other iterable objects. However, when working with arrays and matrices, NumPy’s argmax() function provides a more efficient and convenient solution.\n\nThe np.argmax() function in NumPy is a part of the numpy module and is used to find the indices of the maximum values along a specified axis in an array. It takes an array as input and returns an array of indices corresponding to the maximum values along the specified axis.\n\nThe syntax of the np.argmax() function is as follows:\n\nHere, arr is the input array for which we want to find the indices of the maximum values. The axis parameter specifies the axis along which the maximum values are to be determined. If not provided, the function will consider the flattened array. The out parameter allows us to specify an alternate output array to place the result.\n\nThe np.argmax() function returns an array of indices corresponding to the maximum values along the specified axis. If the input array has multiple dimensions, the function will return a tuple of arrays, each representing the indices along a particular axis.\n\nFinding the Maximum Value in an Array\n\nUsing NumPy’s argmax() function, we can simply pass the array as the input and omit the axis parameter to find the maximum value in an array. The function will return the maximum value index in the flattened array.\n\nFinding the Index of the Maximum Value\n\nTo find the maximum value index along a specific axis in a multi-dimensional array, we can specify the axis parameter in the np.argmax() function. This allows us to find the maximum value and corresponding index along a particular dimension.\n\nWhen working with multi-dimensional arrays, the np.argmax() function returns a tuple of arrays, each representing the indices along a particular axis. We can access the indices for each axis using indexing.\n\nFinding the Most Frequent Element in an Array\n\nOne practical use case of the argmax() function is finding the most frequent element in an array. By using the np.argmax() function along with the np.bincount() function, we can easily determine the index of the most frequent element.\n\nIdentifying the Dominant Color in an Image\n\nIn image processing, the argmax() function can be used to identify the dominant color in an image. We can determine the dominant color by reshaping the image array and finding the maximum value index along the axis representing the color channels.\n\nSelecting the Best Model in Machine Learning\n\nIn machine learning, the argmax() function can select the best model based on evaluation metrics. By calculating the performance metrics for each model and using the np.argmax() function, we can easily determine the model’s index with the highest performance.\n\nTips and Tricks for Using argmax in Python\n\nIn some cases, there might be ties or multiple maximum values in an array. To handle such scenarios, we can use the np.where() function along with the np.argmax() function to get all the indices of the maximum values.\n\nWhen working with large arrays, performance optimization becomes crucial. To improve the performance of the argmax() function, we can use the np.argmax() function along with the np.ndarray.max() method, which is faster than using np.max().\n\nThe argmin() function in NumPy is the counterpart of the argmax() function. While argmax() returns the indices of the maximum values, argmin() returns the indices of the minimum values along a specified axis in an array. Both functions are useful in various scenarios, such as finding the minimum or maximum element in an array or identifying the least or most significant feature in a dataset.\n\nNumPy’s argmax() and max() functions serve different purposes. The argmax() function returns the indices of the maximum values along a specified axis, while the max() function returns the maximum values. The argmax() function is primarily used when we need to find the position of the maximum value, whereas the max() function is used when we only need the maximum value itself.\n\nWhen using the argmax() function, it is important to ensure that the input array is valid and of the correct data type. Invalid input or incompatible data types can lead to unexpected results or errors. It is recommended to handle such scenarios by validating the input and using appropriate error-handling techniques, such as try-except blocks.\n\nDebugging is essential when working with complex functions like argmax(). Suppose you encounter any issues or unexpected results. In that case, it is helpful to use debugging techniques such as printing intermediate values, checking the shape and data type of arrays, and verifying the input and output at each step.\n\nIn conclusion, NumPy’s argmax() function is a powerful tool for finding the maximum values’ indices along an array’s specified axis. It provides a convenient and efficient solution for various use cases, such as finding the most frequent element, identifying the dominant color in an image, or selecting the best model in machine learning. By understanding the syntax, parameters, and return value of the np.argmax() function, along with practical examples and tips, you can leverage this function effectively in your Python projects.\n\nWant to learn more about libraries and functions in Python? Enroll today in our AI/ML Blackbelt course and master the intricacies of advanced Python functionalities essential for harnessing the power of artificial intelligence and machine learning. Elevate your skills and embark on a transformative learning journey with industry-leading experts. Don’t miss out on this opportunity to become a proficient Python programmer in the exciting field of AI/ML. Join us and unlock the full potential of your coding abilities!"
    },
    {
        "link": "https://stackoverflow.com/questions/28697993/numpy-what-is-the-logic-of-the-argmin-and-argmax-functions",
        "document": "By adding the argument, NumPy looks at the rows and columns individually. When it's not given, the array is flattened into a single 1D array.\n\nmeans that the operation is performed down the columns of a 2D array in turn.\n\nFor example returns the index of the minimum value in each of the four columns. The minimum value in each column is shown in bold below:\n\nOn the other hand, means that the operation is performed across the rows of .\n\nThat means returns because has three rows. The index of the minimum value in the first row is 0, the index of the minimum value of the second and third rows is 2:"
    },
    {
        "link": "https://realpython.com/numpy-max-maximum",
        "document": "NumPy’s function efficiently finds maximum values within an array, making it a key tool for data analysis in Python. This tutorial guides you through using and , handling missing values, and explores advanced features like broadcasting for comparing arrays of different shapes.\n\nBy the end of this tutorial, you’ll understand that:\n• NumPy’s function finds the maximum value within a single array, working with both one-dimensional and multi-dimensional arrays.\n• Conversely, compares two arrays element-wise to find the maximum values.\n• and are equivalent in NumPy.\n• You can use to find the maximum value in an array while ignoring values, preventing them from affecting the result.\n\nThis tutorial includes a very short introduction to NumPy, so even if you’ve never used NumPy before, you should be able to jump right in.\n\nWith the background provided here, you’ll be ready to continue exploring the wealth of functionality to be found in the NumPy library.\n\nNumPy’s : The Maximum Element in an Array In this section, you’ll become familiar with , a versatile tool for finding maximum values in various circumstances. Note: NumPy has both a package-level function and an method named . They work in the same way, though the package function requires the target array name as its first parameter. In what follows, you’ll be using the function and the method interchangeably. Python also has a built-in function that can calculate maximum values of iterables. You can use this built-in to find the maximum element in a one-dimensional NumPy array, but it has no support for arrays with more dimensions. When dealing with NumPy arrays, you should stick to NumPy’s own maximum functions and methods. For the rest of this tutorial, will always refer to the NumPy version. is the tool that you need for finding the maximum value or values in a single array. Ready to give it a go? To illustrate the function, you’re going to create an array named containing the test scores obtained by the students in Professor Newton’s linear algebra class. Each row represents one student, and each column contains the scores on a particular test. So column contains all the student scores for the first test, column contains the scores for the second test, and so on. Here’s the array: You can copy and paste this code into your Python console if you want to follow along. To simplify the formatting before copying, click at the top right of the code block. You can do the same with any of the Python code in the examples. Once you’ve done that, the array is in memory. You can ask the interpreter for some of its attributes: The and attributes, as above, confirm that you have rows representing students and columns representing tests, for a total of test scores. Suppose now that you want to find the top score achieved by any student on any test. For Professor Newton’s little linear algebra class, you could find the top score fairly quickly just by examining the data. But there’s a quicker method that’ll show its worth when you’re dealing with much larger datasets, containing perhaps thousands of rows and columns. Try using the array’s method: The method has scanned the whole array and returned the largest element. Using this method is exactly equivalent to calling . But perhaps you want some more detailed information. What was the top score for each test? Here you can use the parameter: The new parameter tells NumPy to find the largest value out of all the rows. Since has five columns, NumPy does this for each column independently. This produces five numbers, each of which is the maximum value in that column. The parameter uses the standard convention for indexing dimensions. So refers to the rows of an array, and refers to the columns. The top score for each student is just as easy to find: This time, NumPy has returned an array with eight elements, one per student. The array contains one row per student. The parameter told NumPy to find the maximum value for each student, across the columns. Therefore, each element of the output contains the highest score attained by the corresponding student. Perhaps you want the top scores per student, but you’ve decided to exclude the first and last tests. Slicing does the trick: You can understand the slice notation as follows. The first index range, represented by the lone , selects all the rows in the slice. The second index range after the comma, , tells NumPy to take the columns, starting at column and ending column before the last. The result of the slice is stored in a new array named . With a bit of practice, you’ll learn to do array slicing on the fly, so you won’t need to create the intermediate array explicitly: Here you’ve performed the slice and the method call in a single line, but the result is the same. NumPy returns the per-student set of maximum for the restricted set of tests. So now you know how to find maximum values in any completely filled array. But what happens when a few array values are missing? This is pretty common with real-world data. To illustrate, you’ll create a small array containing a week’s worth of daily temperature readings, in Celsius, from a digital thermometer, starting on Monday: It seems the thermometer had a malfunction on Saturday, and the corresponding temperature value is missing, a situation indicated by the value. This is the special value Not a Number, which is commonly used to mark missing values in real-world data applications. So far, so good. But a problem arises if you innocently try to apply to this array: Since reports a missing value, NumPy’s default behavior is to flag this by reporting that the maximum, too, is unknown. For some applications, this makes perfect sense. But for your application, perhaps you’d find it more useful to ignore the Saturday problem and get a maximum value from the remaining, valid readings. NumPy has provided the function to take care of such situations: This function ignores any values and returns the largest numerical value, as expected. Notice that is a function in the NumPy library, not a method of the object. You’ve now seen the most common examples of NumPy’s maximum-finding capabilities for single arrays. But there are a few more NumPy functions related to maximum values that are worth knowing about. For example, instead the maximum values in an array, you might want the indices of the maximum values. Let’s say you want to use your array to identify the student who did best on each test. The method is your friend here: It appears that student obtained the top score on every test but one. Student did best on the fourth test. You’ll recall that you can also apply as a function of the NumPy package, rather than as a method of a NumPy array. In this case, the array must be supplied as the first argument of the function. For historical reasons, the package-level function has an alias, , which is identical in every respect apart from the name: In the code above, you’ve called as a method of the object, and as a stand-alone library function with as its first parameter. You’ve also called the alias in the same way. All three calls produce exactly the same results. Now you’ve seen how to use , , or to find maximum values for an array along various axes. You’ve also used to find the maximum values while ignoring values, as well as or to find the indices of the maximum values. You won’t be surprised to learn that NumPy has an equivalent set of minimum functions: , , , , , and . You won’t deal with those here, but they behave exactly like their maximum cousins.\n\nAnother common task in data science involves comparing two similar arrays. NumPy’s function is the tool of choice for finding maximum values across arrays. Since always involves two input arrays, there’s no corresponding method. The function expects the input arrays as its first two parameters. Continuing with the previous example involving class scores, suppose that Professor Newton’s colleague—and archrival—Professor Leibniz is also running a linear algebra class with eight students. Construct a new array with the values for Leibniz’s class: The new array, , has the same shape as . You’d like to compare the two classes, student by student and test by test, to find the higher score in each case. NumPy has a function, , specifically designed for comparing two arrays in an element-by-element manner. Check it out in action: If you visually check the arrays and , then you’ll see that has indeed picked out the higher of the two scores for each [row, column] pair of indices. What if you only want to compare the best test results in each class? You can combine and to get that effect: As before, each call to returns an array of maximum scores for all the students in the relevant class, one element for each test. But this time, you’re feeding those returned arrays into the function, which compares the two arrays and returns the higher score for each test across the arrays. You can combine those operations into one by dispensing with the intermediate arrays, and : This gives the same result as before, but with less typing. You can choose whichever method you prefer. Remember the array from an earlier example? If you use a second week’s temperature records with the function, you may spot a familiar problem. First, you’ll create a new array to hold the new temperatures: There are missing values in the data, too. Now see what happens if you apply the function to these two temperature arrays: All the values in both arrays have popped up as missing values in the output. There’s a good reason for NumPy’s approach to propagating . Often it’s important for the integrity of your results that you keep track of the missing values, rather than brushing them under the rug. But here, you just want to get the best view of the weekly maximum values. The solution, in this case, is another NumPy package function, : Now, two of the missing values have simply been ignored, and the remaining floating-point value at that index has been taken as the maximum. But the Saturday temperature can’t be fixed in that way, because both source values are missing. Since there’s no reasonable value to insert here, just leaves it as a . Just as and have the parallel minimum functions and , so too do and have corresponding functions, and , that mirror their functionality for minimum values.\n\nYou’ve now seen examples of all the basic use cases for NumPy’s and , plus a few related functions. Now you’ll investigate some of the more obscure optional parameters to these functions and find out when they can be useful. When you call a function in Python, a value or object is returned. You can use that result immediately by printing it or writing it to disk, or by feeding it directly into another function as an input parameter. You can also save it to a new variable for future reference. If you call the function in the Python REPL but don’t use it in one of those ways, then the REPL prints out the return value on the console so that you’re aware that something has been returned. All of this is standard Python stuff, and not specific to NumPy. NumPy’s array functions are designed to handle huge inputs, and they often produce huge outputs. If you call such a function many hundreds or thousands of times, then you’ll be allocating very large amounts of memory. This can slow your program down and, in an extreme case, might even cause a memory or stack overflow. This problem can be avoided by using the parameter, which is available for both and , as well as for many other NumPy functions. The idea is to pre-allocate a suitable array to hold the function result, and keep reusing that same chunk of memory in subsequent calls. You can revisit the temperature problem to create an example of using the parameter with the function. You’ll also use the parameter to control the type of the returned array: The initial values in don’t matter, since they’ll be overwritten. But the array’s shape is important in that it must match the output shape. The displayed result looks like the output that you received from the original example. So what’s changed? The difference is that you now have the same data stored in : The return value has been stored in the variable, which you previously created with the right shape to accept that return value. Since you also specified when you declared this buffer, NumPy will do its best to convert the output data to that type. Remember to use the buffer contents before they’re overwritten by the next call to this function. Another parameter that’s occasionally useful is . This applies a filter to the input array or arrays, so that only those values for which the condition is will be included in the comparison. The other values will be ignored, and the corresponding elements of the output array will be left unaltered. In most cases, this will leave them holding arbitrary values. For the sake of the example, suppose you’ve decided, for whatever reason, to ignore all scores less than for calculating the per-student maximum values in Professor Newton’s class. Your first attempt might go like this: ValueError: reduction operation 'maximum' does not have an identity, so to use a where mask one has to specify 'initial' The problem here is that NumPy doesn’t know what to do with the students in rows and , who didn’t achieve a single test score of or better. The solution is to provide an parameter: With the two new parameters, and , considers only the elements greater than or equal to . For the rows where there is no such element, it returns the value of instead. So the lucky students at indices and got their best score boosted to by this operation! The original array is untouched. You’ve learned how to use to compare arrays with identical shapes. But it turns out that this function, along with many others in the NumPy library, is much more versatile than that. NumPy has a concept called broadcasting that provides a very useful extension to the behavior of most functions involving two arrays, including . Whenever you call a NumPy function that operates on two arrays, and , it checks their properties to see if they’re compatible. If they have exactly the same , then NumPy just matches the arrays element by element, pairing up the element at with the element at . works like this too. Broadcasting enables NumPy to operate on two arrays with different shapes, provided there’s still a sensible way to match up pairs of elements. The simplest example of this is to broadcast a single element over an entire array. You’ll explore broadcasting by continuing the example of Professor Newton and his linear algebra class. Suppose he asks you to ensure that none of his students receives a score below . Here’s how you might do it: You’ve applied the function to two arguments: , whose is (8, 5), and the single scalar parameter . You can think of this second parameter as a 1 × 1 array that’ll be stretched inside the function to cover eight rows and five columns. The stretched array can then be compared element by element with , and the pairwise maximum can be returned for each element of the result. The result is the same as if you had compared with an array of its own shape, (8, 5), but with the value in each element. This stretching is just conceptual—NumPy is smart enough to do all this without actually creating the stretched array. So you get the notational convenience of this example without compromising efficiency. You can do much more with broadcasting. Professor Leibniz has noticed Newton’s skulduggery with his array, and decides to engage in a little data manipulation of her own. Leibniz’s plan is to artificially boost all her students’ scores to be at least equal to the average score for a particular test. This will have the effect of increasing all the below-average scores—and thus produce some quite misleading results! How can you help the professor achieve her somewhat nefarious ends? Your first step is to use the array’s method to create a one-dimensional array of means per test. Then you can use and broadcast this array over the entire matrix: The broadcasting happens in the highlighted function call. The one-dimensional array has been conceptually stretched to match the two-dimensional array. The output array has the same as the larger of the two input arrays, . So, what are the rules for broadcasting? A great many NumPy functions accept two array arguments. is just one of these. Arrays that can be used together in such functions are termed compatible, and their compatibility depends on the number and size of their dimensions—that is, on their . The simplest case occurs if the two arrays, say and , have identical shapes. Each element in is matched, for the function’s purposes, to the element at the same index address in . Broadcasting rules get more interesting when and have different shapes. The elements of compatible arrays must somehow be unambiguously paired together so that each element of the larger array can interact with an element of the smaller array. The output array will have the of the larger of the two input arrays. So compatible arrays must follow these rules:\n• If one array has fewer dimensions than the other, only the trailing dimensions are matched for compatibility. The trailing dimensions are those that are present in the of both arrays, counting from the right. So if is and is , then and are compatible because are the trailing dimensions of each. You can completely ignore the two leftmost dimensions of .\n• Even if the trailing dimensions aren’t equal, the arrays are still compatible if one of those dimensions is equal to in either array. So if is as before and is or or or , then is still compatible with in each case. You can get a feel for the broadcasting rules by playing around in the Python REPL. You’ll be creating some toy arrays to illustrate how broadcasting works and how the output array is generated: There’s nothing really new to see here yet. You’ve created two arrays of identical and applied the operation to them. Notice that the handy method lets you build arrays of any shape. You can verify that the result is the element-by-element maximum of the two inputs. The fun starts when you experiment with comparing two arrays of different shapes. Try slicing to make a new array, : The two arrays, and , are compatible because the new array’s second dimension is , and the other dimensions match. Notice that the of the result of the operation is the same as . That’s because , the smaller array, is being broadcast over . The result of a broadcast operation between arrays will always have the of the larger array. Now you can try an even more radical slicing of : Once again, the trailing dimensions of and are all either equal or , so the arrays are compatible and the broadcast works. The result has the same as . Perhaps the most extreme type of broadcasting occurs when one of the array parameters is passed as a scalar: NumPy automatically converts the second parameter, , to an with , determines that this converted parameter is compatible with the first, and duly broadcasts it over the entire 2 × 3 × 4 array . : operands could not be broadcast together with shapes (2,3,4) (2,2,4) If you refer back to the broadcasting rules above, you’ll see the problem: the second dimensions of and don’t match, and neither is equal to , so the two arrays are incompatible. You can read more about broadcasting in Look Ma, No Loops: Array Programming With NumPy. There’s also a good description of the rules in the NumPy docs. The broadcasting rules can be confusing, so it’s a good idea to play around with some toy arrays until you get a feel for how it works!\n\nIn this tutorial, you’ve explored the NumPy library’s and operations to find the maximum values within or across arrays.\n• Why NumPy has its own function, and how you can use it\n• How the function differs from , and when it’s needed\n• Which practical applications exist for each function\n• How you can handle missing data so your results make sense\n• How you can apply your knowledge to the complementary task of finding minimum values Along the way, you’ve learned or refreshed your knowledge of the basics of NumPy syntax. NumPy is a hugely popular library because of its powerful support for array operations. Now that you’ve mastered the details of NumPy’s and , you’re ready to use them in your applications, or continue learning about more of the hundreds of array functions supported by NumPy. Free Bonus: Click here to get access to a free NumPy Resources Guide that points you to the best tutorials, videos, and books for improving your NumPy skills. If you’re interested in using NumPy for data science, then you’ll also want to investigate pandas, a very popular data-science library built on top of NumPy. You can learn about it in The Pandas DataFrame: Make Working With Data Delightful. And if you want to produce compelling images from data, take a look at Python Plotting With Matplotlib (Guide). The applications of NumPy are limitless. Wherever your NumPy adventure takes you next, go forth and matrix-multiply!"
    },
    {
        "link": "https://realpython.com/python-f-strings",
        "document": "Python f-strings offer a concise and efficient way to interpolate variables, objects, and expressions directly into strings. By prefixing a string with or , you can embed expressions within curly braces ( ), which are evaluated at runtime.\n\nThis makes f-strings faster and more readable compared to older approaches like the modulo ( ) operator or the string method. Additionally, f-strings support advanced string formatting using Python’s string format mini-language.\n\nBy the end of this tutorial, you’ll understand that:\n• An f-string in Python is a string literal prefixed with or , allowing for the embedding of expressions within curly braces .\n• To include dynamic content in an f-string, place your expression or variable inside the braces to interpolate its value into the string.\n• An f-string error in Python often occurs due to syntax issues, such as unmatched braces or invalid expressions within the string.\n• Python 3.12 improved f-strings by allowing nested expressions and the use of backslashes.\n\nThis tutorial will guide you through the features and advantages of f-strings, including interpolation and formatting. By familiarizing yourself with these features, you’ll be able to effectively use f-strings in your Python projects.\n\nBefore Python 3.6, you had two main tools for interpolating values, variables, and expressions inside string literals: You’ll get a refresher on these two string interpolation tools in the following sections. You’ll also learn about the string formatting capabilities that these tools offer in Python. The modulo operator ( ) was the first tool for string interpolation and formatting in Python and has been in the language since the beginning. Here’s what using this operator looks like in practice: In this quick example, you use the operator to interpolate the value of your variable into a string literal. The interpolation operator takes two operands:\n• A string literal containing one or more conversion specifiers\n• The object or objects that you’re interpolating into the string literal The conversion specifiers work as replacement fields. In the above example, you use the combination of characters as a conversion specifier. The symbol marks the start of the specifier, while the letter is the conversion type and tells the operator that you want to convert the input object into a string. If you want to insert more than one object into your target string, then you can use a tuple. Note that the number of objects in the tuple must match the number of format specifiers in the string: In this example, you use a tuple of values as the right-hand operand to . Note that you’ve used a string and an integer. Because you use the specifier, Python converts both objects to strings. You can also use dictionaries as the right-hand operand in your interpolation expressions. To do this, you need to create conversion specifiers that enclose key names in parentheses: This syntax provides a readable approach to string interpolation with the operator. You can use descriptive key names instead of relying on the positional order of values. When you use the operator for string interpolation, you can use conversion specifiers. They provide some string formatting capabilities that take advantage of conversion types, conversion flags, and some characters like the period ( ) and the asterisk ( ). Consider the following example: In the first example, you use the conversion specifier to represent currency values. The letter tells the operator to convert to a floating-point number. The part defines the precision to use when converting the input. In the second example, you use to align the age value five positions to the right. Note: Formatting with the modulo operator is inspired by formatting used in C and many other programming languages. Even though the operator provides a quick way to interpolate and format strings, it has a few issues that lead to common errors. For example, it’s difficult to interpolate tuples in your strings: : not all arguments converted during string formatting In this example, the operator fails to display the tuple of data because it interprets the tuple as two separate values. You can fix this issue by wrapping the data in a single-item tuple: This syntax fixes the issue, and now your string successfully shows the tuple of data. However, the syntax is hard to read, understand, and remember, isn’t it? Another issue with the operator is its limited formatting capabilities and the lack of support for Python’s string formatting mini-language, which provides a powerful tool to format your strings. The method is an improvement compared to the operator because it fixes a couple of issues and supports the string formatting mini-language. With , curly braces delimit the replacement fields: For the method to work, you must provide replacement fields using curly brackets. If you use empty brackets, then the method interpolates its arguments into the target string based on position. You can manually specify the interpolation order by referencing the position of each argument to using zero-based indices. For example, the code below switches the arguments to in the target string: In this example, you use numeric indices to manually define the order in which you want to interpolate the values that you pass as arguments to . You can also use keyword arguments in the call to the method and enclose the argument names in your replacement fields: This example showcases how interpolates keyword arguments by their names into the target string. This construct considerably improves your code’s readability compared to the previous example and to the examples using the operator. Finally, the method allows you to use dictionaries to provide the values that you want to interpolate into your strings: In this example, you use a dictionary containing the data to interpolate. Then, you use the dictionary unpacking operator ( ) to provide the arguments to . The method supports format specifiers. These are strings that you insert into replacement fields to format the values that you want to interpolate. Consider the following examples: In the first example, you use the format specifier. This specifier tells to format the input value as a floating-point number with a precision of two. This way, you can represent currency values. In the second example, you use the format specifier. In this case, you’re telling to format the input value using the symbol as a filler character. The symbol centers the input value by inserting symbols on both sides to reach thirty characters. Format specifiers provide a remarkable improvement over the limited formatting capabilities of the operator. These specifiers have a straightforward syntax that makes up the string formatting mini-language. Thankfully, f-strings also support the string formatting mini-language, which is another cool feature of theirs. So, you won’t have to use if you don’t need to. In the upcoming sections, you’ll write a few more examples of formatting strings using the mini-language with f-strings.\n\nDoing String Interpolation With F-Strings in Python F-strings joined the party in Python 3.6 with PEP 498. Also called formatted string literals, f-strings are string literals that have an before the opening quotation mark. They can include Python expressions enclosed in curly braces. Python will replace those expressions with their resulting values. So, this behavior turns f-strings into a string interpolation tool. In the following sections, you’ll learn about f-strings and use them to interpolate values, objects, and expressions in your string literals. F-strings make the string interpolation process intuitive, quick, and concise. The syntax is similar to what you used with , but it’s less verbose. You only need to start your string literal with a lowercase or uppercase and then embed your values, objects, or expressions in curly brackets at specific places: Look how readable and concise your string is now that you’re using the f-string syntax. You don’t need operators or methods anymore. You just embed the desired objects or expressions in your string literal using curly brackets. It’s important to note that Python evaluates f-strings at runtime. So, in this example, both and are interpolated into the string literal when Python runs the line of code containing the f-string. Python can only interpolate these variables because you defined them before the f-string, which means that they must be in scope when Python evaluates the f-string. You can embed almost any Python expression in an f-string. This allows you to do some nifty things. You could do something pretty straightforward, like the following: When Python runs this f-string, it multiplies by and immediately interpolates the resulting value into the final string. The example above is quite basic. However, f-strings are more powerful than that. You could also use other Python expressions, including function and method calls, and even comprehensions or other more complex expressions: In the first f-string, you embed a call to the string method in the first replacement field. Python runs the method call and inserts the uppercased name into the resulting string. In the second example, you create an f-string that embeds a list comprehension. The comprehension creates a new list of powers of .\n\nThe expressions that you embed in an f-string are evaluated at runtime. Then, Python formats the result using the special method under the hood. This method supports the string formatting protocol. This protocol underpins both the method, which you already saw, and the built-in function: The function takes a value and a format specifier as arguments. Then, it applies the specifier to the value to return a formatted value. The format specifier must follow the rules of the string formatting mini-language. Just like the method, f-strings also support the string formatting mini-language. So, you can use format specifiers in your f-strings too: Note that the format specifiers in these examples are the same ones that you used in the section on . In this case, the embedded expression comes before the format specifier, which always starts with a colon. This syntax makes the string literals readable and concise. You can create a wide variety of format specifiers. Some common formats include currencies, dates, and the representation of numeric values. Consider the following examples of string formatting: \"Comma as thousand separators and two decimals: 'Comma as thousand separators and two decimals: 1,234,567.99' These examples show how flexible the format specifiers can be. You can use them to create almost any string format. Note how in the second example, you’ve used curly brackets to embed variables or expressions in your format specifiers. This possibility allows you to create dynamic specifiers, which is pretty cool. In the last example, you format a which can be formatted with special date format specifiers.\n\nSo far, you’ve learned that f-strings provide a quick and readable way to interpolate values, objects, and expressions into string literals. They also support the string formatting mini-language, so you can create format specifiers to format the objects that you want to insert into your strings. In the following sections, you’ll learn about a few additional features of f-strings that may be relevant and useful in your day-to-day coding. Using an Object’s String Representations in F-Strings Python’s f-strings support two flags with special meaning in the interpolation process. These flags are closely related to how Python manages the string representation of objects. These flags are: Interpolates the string representation from the method Interpolates the string representation from the method The special method generally provides a user-friendly string representation of an object, while the method returns a developer-friendly representation. To illustrate how these methods work under the hood, consider the following class: This class has two instance attributes, and . The method returns a string that consists of an informative message for users of your class. This message should be useful for end users rather than developers. Note: To dive deeper into the and methods, check out When Should You Use. vs in Python? In contrast, the method returns a string that’s a developer-friendly representation of the object. In short, the representation tells the developer how the current instance was created. Ideally, the developer should be able to copy this string representation and create an equivalent object. How does this discussion about string representation affect f-strings? When you create your f-strings, you can choose which string representation to use with the and flags: In the first f-string, you use the tag to interpolate the string representation that returns. In the second f-string, you use the flag to interpolate the developer-friendly string representation of your current object. These two flags are pretty relevant for you as a Python developer. Depending on your code’s intended audience, you can decide which one to use. In general, it should be the one that provides more value to your users. It’s important to note that the operator also supports equivalent conversion types, and , which work the same as the and flags in f-strings. F-strings have another cool feature that can be useful, especially during your debugging process. The feature helps you self-document some of your expressions. For example, say that you’re dealing with a minor bug or issue in your code, and you want to know the value of a variable at a given moment in the code’s execution. For this quick check, you can insert a call to like the following: You can use a variable name followed by an equal sign ( ) in an f-string to create a self-documented expression. When Python runs the f-string, it builds an expression-like string containing the variable’s name, the equal sign, and the variable’s current value. This f-string feature is useful for inserting quick debugging checks in your code. Note that the whitespaces around the equal sign aren’t required but they are reflected in the output: Even though the whitespaces aren’t required, they can improve your code’s readability and the output’s format. F-strings are a bit faster than both the modulo operator ( ) and the method. That’s another cool characteristic. In the script below, you use the module to measure the execution time that it takes to build a string using the modulo operator, the method, and an f-string: In this script, the function takes care of measuring the execution time of the three different string interpolation tools. The function inside the loop runs each interpolation tool a million times and returns the total execution time. Then, the function prints the result to the screen. Note how your f-string in the call to takes advantage of format specifiers to conveniently format the code’s output. If you run the script from your command line, then you’ll get an output similar to the following. Of course, the numbers will be different for you: This output shows that f-strings are a bit faster than the operator and the method, which is the slowest tool because of all the required function calls. So, f-strings are readable, concise, and also fast.\n\nNow that you’ve learned why f-strings are great, you’re probably eager to get out there and start using them in your code. However, you need to know that f-strings up to Python 3.11 have a few limitations regarding the expressions that you can embed in curly brackets and a few other details. Fortunately, Python 3.12 lifted those limitations by removing the old f-string parser and providing a new implementation of f-strings based on the PEG parser of Python 3.9. In the following sections, you’ll learn about the limitations and how Python 3.12 fixed them. Python supports several different types of quotation marks as delimiters in string literals. You can use single ( ) and double quotes ( ). You can also use triple single ( ) and triple double quotes ( ). All these string delimiters work for f-strings as well. This feature allows you to insert quotation marks in f-strings. It also lets you introduce string literals in the embedded expressions and even create nested f-strings. A typical use case of using different quotation marks in an f-string is when you need to use an apostrophe or access a dictionary key in an embedded expression: In this example, you have a dictionary with a person’s data. To define the f-string, you use double quotes. To access the dictionary key, you use single quotes. In the contraction, you use a single quote as an apostrophe. So, where’s the quote-related limitation of f-strings up to Python 3.11? The problem is that you can’t reuse quotation marks in an f-string: In this example, when you try to reuse double quotes to access the dictionary key, your f-string fails, and Python raises a exception. Fortunately, the new f-strings in Python 3.12 solved this issue, allowing you to reuse quotes: In this example, you reuse the double quotes in your embedded expressions, and the f-string works correctly. The limitation is gone. However, it may not be clear if reusing quotations in this example is cleaner than differentiating nested strings with different quotation marks. There’s another f-string limitation that’s closely related to quotation marks. You can only nest as many f-strings as there are quote delimiters in Python: The number of nesting levels in an f-string up to Python 3.11 is limited by the available string delimiters, which are , , , and . So, you only have four delimiters that you can use to differentiate your levels of nesting. In Python 3.12, this limitation is removed because you can reuse quotation marks: Before the new f-string implementation, there was no formal limit on how many levels of nesting you could have. However, the fact that you couldn’t reuse string quotes imposed a natural limit on the allowed levels of nesting in f-string literals. Starting with Python 3.12, you can reuse quotes, so there are no limits for nesting f-strings. Another limitation of f-strings before 3.12 is that you can’t use backslash characters in embedded expressions. Consider the following example, where you try to concatenate strings using the newline ( ) escape sequence: In this example, you get a because f-strings don’t allow backslash characters inside expressions delimited by curly brackets. Again, the new f-string implementation that comes with Python 3.12 solves the issue: The new f-string implementation lifted the limitation of using backslash characters in embedded expressions, so you can now use escape sequences in your f-strings. F-strings up to Python 3.11 don’t allow you to use the symbol in embedded expressions. Because of that, you can’t insert comments in embedded expressions. If you try to do it, then you’ll get a syntax error: When you use to introduce a comment in an f-string, you get a . Fortunately, the new f-strings in Python 3.12 also fix this problem: Now you can add inline comments if you ever need to clarify something in the embedded expressions of an f-string. Another improvement is that you can add line breaks inside the curly braces, similar to what you can do inside parentheses outside f-strings. You don’t even need to use the triple-quoted multiline strings to do this. Python’s new PEG parser opens the door to many improvements in the language. From the user’s perspective, one of the most valuable improvements is that you now have better error messages. These enhanced error messages weren’t available for f-strings up to Python 3.11 because they didn’t use the PEG parser. So, the error messages related to f-strings were less specific and clear. Python 3.12 came along to fix this issue, too. Take a look at the following example, which compares the error message for an incorrect f-string in both 3.11 and 3.12: File , line File , line : f-string: expecting '=', or '!', or ':', or '}' The error message in the first example is generic and doesn’t point to the exact location of the error within the offending line. Additionally, the expression is surrounded by parentheses, which adds noise to the problem because the original code doesn’t include parentheses. In Python 3.12, the error message is more verbose. It signals the exact location of the problem in the affected line. Additionally, the exception message provides some suggestions that might help you fix the issue. In this specific example, the suggestions aren’t that useful because they focus on an operator that’s possibly wrong. However, having the exact location where the problem happened gives you a strong clue. You have a missing operand in the embedded expression.\n\nEven though f-strings are a pretty cool and popular Python feature, they’re not the one-size-fits-all solution. Sometimes the modulo operator ( ) or the method provides a better solution. Sometimes, they’re your only option. It all depends on your specific use case. In the following sections, you’ll learn about a few situations where f-strings may not be the best option. To kick things off, you’ll start with a use case that’s closely related to your code’s readability. That’s when you want to interpolate values from a dictionary into a given string. Interpolating dictionary values into a string may be a common requirement in your code. Because you now know that f-strings are neat, you may think of using them for this task. You end up with a piece of code that looks like the following: That’s great! The code works just fine. However, it doesn’t look clean because of all those dictionary key lookups embedded in the string. The f-string looks cluttered and may be hard to read. How about using the method? Here’s a new version of your code: In this example, you use direct names instead of dictionary lookups in the replacement fields. The only additional requirement is that you need to use the dictionary unpacking operator ( ) in the call to . Now, the string looks cleaner and is also a bit shorter than the version using an f-string. As an additional gain, it’s important to note that the number of replacement fields in the string doesn’t have to match the number of keys in the input dictionary. The method will ignore unnecessary keys. You also have the option of using the modulo operator, though: This time, the string is even shorter. You use direct names in the replacement fields and don’t have to use the dictionary unpacking operator because the modulo operator unpacks the dictionary for you. However, some may say that the replacement fields aren’t that readable and that the modulo operator has limited formatting capabilities. So, what version do you prefer? Share your thoughts in the comments! Providing logging messages is a common example of those use cases where you shouldn’t use f-strings or . The module runs string interpolation lazily to optimize performance according to the selected logging level. For example, you may have a hundred debugging messages but only ten warning messages in your code. If you use an f-string or the method to construct your logging messages, then Python will interpolate all the strings regardless of the logging level that you’ve chosen. However, if you use the operator and provide the values to interpolate as arguments to your logging functions, then you’ll optimize the interpolation process. The module will only interpolate those strings that belong to the current and higher logging levels. Consider the following example: In this example, you use the modulo operator syntax to create the logging message. Then, you pass the value that you want to interpolate as an argument to the logging functions. Because is the default logging level, only the messages at this level and higher will be logged. That’s why the function doesn’t generate any output. In the above call to , the string interpolation never happens because you’re using a higher logging level. However, if you use like in the code below, then the interpolation will always happen: If you call a million times inside a loop, then Python will eagerly evaluate its argument, and the interpolation will happen a million times. This behavior will add performance overhead to your code. That’s why the module does the interpolation lazily. The lazy nature of how does string formatting can make a difference, and it’s only possible using the modulo operator. Using any string interpolation tool is a bad idea when you’re building SQL queries with dynamic parameters. In this scenario, interpolation tools invite SQL injection attacks. To illustrate the problem, say that you’re working with a PostgresSQL database using the Psycopg 2 adapter, and you want to run a query to get all the users with a given role or set of privileges. You come up with one of the following queries: All of these strings directly insert the query parameter into the final query without any validation or security check. If you run any of these queries using the method, then the database won’t be able to perform any security checks on the parameters, which makes your code prone to SQL injection attacks. Note: The code in the above example doesn’t run because of the missing library and the assumption of a certain database structure and setup. It’s a demonstrative code example only. To avoid the risk of SQL injection, you can use the operator syntax to build the query template and then provide the query parameter as the second argument to the method in a tuple or list: In this example, you use the operator syntax to create the query template. Then, you provide the parameters as an independent argument to . In this case, the database system will use the specified type and value of when executing the query. This practice offers protection against SQL injection. Note: You should only use the modulo operator syntax in the string literal that represents the query template. You shouldn’t use the operator and the actual sequence of parameters to build the final query. Just let do the hard work and build the final query for you in a safer way. In short, you must avoid using any string interpolation tool to build dynamic queries beforehand. Instead, use the operator syntax to build the query template and pass the query parameters to in a sequence. When you want to provide internationalization and localization in a Python project, the method is the way to go: You can support multiple languages using string templates. Then, you can handle localized string formatting based on the user’s locale. The method will allow you to dynamically interpolate the appropriate strings depending on the user’s language selection.\n\nIf you’re working on porting a legacy codebase to modern Python, and one of your goals is to convert all your strings into f-strings, then you can use the project. This tool allows you to convert traditional strings into f-strings quickly. To use , you need to install it first: This command downloads and installs in your current Python environment. Once you have it installed, you can use the command against your code files. For example, say that you have the following Python file: If you want to update this file and start using f-strings instead of the operator, then you can just run the following command: This command tells to update the content of your file by replacing strings that use the operator and the method with equivalent f-strings. Note that this command will modify your files in place. So, after running the command, will look something like the following: That’s cool, isn’t it? You can also run against a complete directory containing a large Python codebase. It’ll scan every file and convert the old strings into f-strings. So, the tool is quite useful if you’re modernizing your codebase."
    },
    {
        "link": "https://reddit.com/r/learnpython/comments/fqhlxm/are_fstrings_good_practice",
        "document": "Better than this?.."
    },
    {
        "link": "https://stackoverflow.com/questions/42097052/can-i-import-pythons-3-6s-formatted-string-literals-f-strings-into-older-3-x",
        "document": "The new Python 3.6 f-strings seem like a huge jump in string usability to me, and I would love to jump in and adopt them whole heartedly on new projects which might be running on older interpreters. 2.7, 3.3-3.5 support would be great but at the very least I would like to use these in Python 3.5 code bases. How can I import 3.6's formatted string literals for use by older interpreters?\n\nI understand that formatted string literals like are not breaking changes, so would not be included in a call. But the change is not back-ported (AFAIK) I would need to be sure that whatever new code I write with f-strings is only ran on Python 3.6+ which is a deal breaker for a lot of projects."
    },
    {
        "link": "https://realpython.com/python-string-formatting",
        "document": "String formatting is essential in Python for creating dynamic and well-structured text by inserting values into strings. This tutorial covers various methods, including f-strings, the method, and the modulo operator ( ). Each method has unique features and benefits for different use cases. The string formatting mini-language provides additional control over the output format, allowing for aligned text, numeric formatting, and more.\n\nBy the end of this tutorial, you’ll understand that:\n• String formatting in Python involves inserting and formatting values within strings using interpolation.\n• Python supports different types of string formatting, including f-strings, the method, and the modulo operator ( ).\n• F-strings are generally the most readable and efficient option for eager interpolation in Python.\n• While f-strings are more readable and efficient compared to and the operator, the method supports lazy evaluation.\n\nTo get the most out of this tutorial, you should be familiar with Python’s string data type and the available string interpolation tools. Having a basic knowledge of the string formatting mini-language is also a plus.\n\nString interpolation involves generating strings by inserting other strings or objects into specific places in a base string or template. For example, here’s how you can do some string interpolation using an f-string: In this quick example, you first have a Python variable containing a string object, . Then, you create a new string using an f-string. In this string, you insert the content of your variable using a replacement field. When you run this last line of code, Python builds a final string, . The insertion of into the f-string is an interpolation. Note: To dive deeper into string interpolation, check out the String Interpolation in Python: Exploring Available Tools tutorial. When you do string interpolation, you may need to format the interpolated values to produce a well-formatted final string. To do this, you can use different string interpolation tools that support string formatting. In Python, you have these three tools: The first two tools support the string formatting mini-language, a feature that allows you to fine-tune your strings. The third tool is a bit old and has fewer formatting options. However, you can use it to do some minimal formatting. Note: The built-in function is yet another tool that supports the format specification mini-language. This function is typically used for date and number formatting, but you won’t cover it in this tutorial. In the following sections, you’ll start by learning a bit about the string formatting mini-language. Then, you’ll dive into using this language, f-strings, and the method to format your strings. Finally, you’ll learn about the formatting capabilities of the modulo operator.\n\nPython 3.6 added a string interpolation and formatting tool called formatted string literals, or f-strings for short. As you’ve already learned, f-strings let you embed Python objects and expressions inside your strings. To create an f-string, you must prefix the string with an or and insert replacement fields in the string literal. Each replacement field must contain a variable, object, or expression: In the first example, you define an f-string that embeds the number directly into the resulting string. In the second example, you insert two variables and an expression into the string. Formatted string literals are a Python parser feature that converts f-strings into a series of string constants and expressions. These are then joined up to build the final string. Using the Formatting Mini-Language With F-Strings When you use f-strings to create strings through interpolation, you need to use replacement fields. In f-strings, you can define a replacement field using curly brackets ( ) as in the examples below: Inside the brackets, you can insert Python objects and expressions. In this example, you’d like the resulting string to display the currency values using a proper format. However, you get a string that shows the currency values with at most one digit on its decimal part. To format the values and always display two digits on its decimal part, you can use a format specifier: In this example, note that each replacement field contains a string that starts with a colon. That’s a format specifier. The part tells Python that you want to format the value as a floating-point number ( ) with two decimal places ( ). Note: To learn more about the formatting mini-language and its syntax, check out the Python’s Format Mini-Language for Tidy Strings tutorial. If you’re interested in formatting floating-point numbers specifically, then you can also read How to Format Floats Within F-Strings in Python. The string formatting mini-language is a powerful tool with several cool features, including the following: In the following sections, you’ll explore how to use f-strings, the method, and the string formatting mini-language to format the values that you insert into your strings through interpolation. You can use f-strings and the string formatting mini-language to format the values that you interpolate into your strings in multiple ways. To illustrate, say that you want to write a Python function to build a grades report for your students. The student data is in a dictionary that looks like the following: \"Needs to participate more.\" The dictionary has the key to store the student’s name. Then, it has the key to hold a list of dictionaries containing the student’s performance in each subject. Your function may look like the following: Thank you for reviewing the progress report. In this function, you’re doing several things. Here’s a line-by-line breakdown:\n• Line 5 computes the average of the grades.\n• Line 6 defines the average grade subreport. In this part of the report, you use the format specifier to express the average grade as a floating-point number with two decimal places.\n• Line 8 defines the first line of the subject subreport.\n• Line 10 adds more information to the subject subreport.\n• Line 11 formats the subject’s name. To do this, you use the format specifier, which tells Python to align the name to the left within characters.\n• Line 12 formats the grade. In this case, the format specifier tells Python to display the grade using up to three characters. A leading space is used if the grade doesn’t have three digits.\n• Lines 16 to 21 build the final report and return it to the caller. Now that you’ve gone through the complete code, it’s time to try out your function. Go ahead and run the following code: History Grade: 78 Comment: Needs to participate more. Thank you for reviewing the progress report. Your report looks pretty nice! It provides general information about the student at the top and grade details for every subject.\n\nYou can also use the method to format values during string interpolation. In most cases, you’d use the method for lazy interpolation. In this type of interpolation, you define a template string in some part of your code and then interpolate values in another part: In both examples, you create a string template and then use the method to interpolate the required values. Using the Formatting Mini-Language With The method also supports the string formatting mini-language. This feature allows you to nicely format the interpolated values when you create strings through interpolation. To illustrate, consider the example you wrote in the section about using the formatting mini-language with f-strings. Here’s how to do it with the method: Again, the resulting string displays the currency values using a proper format that shows two decimal places. Now it’s time for a couple of practical examples of using the method and the string formatting mini-language to format your strings. For the first example, say that you need to create a sales report for your company. You’d like to create a report template and fill it with the appropriate data when someone requires it. In this situation, you can create the following report template: In this report template, you have a few format specifiers. Here’s a summary of their specific meanings:\n• displays the interpolated value aligned to the right within a space of characters. The dot after the colon works as the fill character. The other format specifiers, and , have a similar effect. Note that the field widths were chosen by trial and error to make the report line up nicely.\n• displays the preceding number using a comma as the thousands separator.\n• shows a value as a floating-point number using two decimal places and a comma as the thousands separator. Now, you can code a function to generate the actual report: This function takes the sales data and the report template as arguments. Then, it computes the required values and calls on the template. Go ahead and give this function a try by running the following code: Cool! You have a nicely formatted sales report. You can experiment on your own and tweak the format specifiers further as an exercise. For example, you can improve the date format. However, note that dates have their own formatting, which you can learn about in the Formatting Dates section of the tutorial about Python’s string formatting mini-language. You can also take advantage of the method when your data is stored in dictionaries. For example, here’s how you can update the function using the method: Thank you for reviewing the progress report. In the first lines of code, you create string templates to display the information about each subject and also the final report. In , you create a dictionary with the required data to build the student report. Next, you interpolate the data into the report template using with the dictionary as an argument. Note that to fill the string templates, you use the operator to unpack the data from the input dictionary.\n\nStrings in Python have a built-in operation that you can access with the modulo operator ( ). This operator lets you do positional and named string interpolation. If you’ve ever worked with the function in C, then the syntax will be familiar. Here’s a toy example: The substring is a conversion specifier that works as a replacement field. It tells Python where to substitute the value of , represented as a string. To build a conversion specifier, you need two or more characters. Here’s a quick summary of the accepted characters and their corresponding order in the specifier:\n• The character marks the start of the specifier.\n• An optional mapping key in parentheses allows you to use named replacement fields like .\n• An optional conversion flag affects how some conversion types display.\n• An optional minimum field width allows you to define the number of characters to display.\n• An optional precision consists of a dot character ( ) followed by the desired precision.\n• An optional length modifier is an or for long and short integers.\n• A conversion type specifies how the output string will be formatted, mimicking different data types. Several conversion types are available for the modulo operator in Python. They allow you to control the output’s format in some way. For example, you can convert numbers to hexadecimal notation or add whitespace padding to generate nicely formatted tables and reports. Here’s a summary of the conversion types currently available in Python: A percentage character ( ) in the result if no argument is converted With all these conversion types, you can process your interpolated values to display them using different representation types. Note: It’s important to note that f-strings and the method also support the conversion types listed above. For details on this topic, check out the Converting Between Type Representations section in the Python’s Format Mini-Language for Tidy Strings tutorial. Here are a few examples of how to use some of the above specifiers in your strings: In these examples, you’ve used different conversion types to display values using different type representations. Now, check out the examples below to see other formatting options in action: In the first example, you use named replacement fields in parentheses and a dictionary to provide the values you want to interpolate. In the second example, you provide a minimum width for your string in characters. The third example is a dynamic variation of the second. Note how the symbol allows you to insert the desired width dynamically. Finally, you use the precision option to display a floating-point number using different precisions. You use two, four, and eight digits after the decimal separator, respectively. Unfortunately, the modulo operator doesn’t support the string formatting mini-language, so if you use this tool to interpolate and format your strings, then your formatting options are more limited than when you use f-strings or . The modulo operator also supports what’s known as conversion flags. Here’s a quick summary of the currently available flags: Left-justifies the value (overrides the conversion if both are given) Adds a sign character ( or ) before the value These flags help you apply some additional formatting options to your strings. Consider the following quick examples: In these examples, you demonstrate the effect of the flag, which prepends the appropriate prefix to the input number depending on the base you use. This flag is mostly used with integer values. Here are some more examples of using different flags: In the first example, you add zero padding to the input value. Next, you have an example of how to use the minus sign to align a value to the left in a width of ten characters. The space flag allows you to add a space before positive numbers. This space disappears when the value is negative. Finally, you use the plus sign so the string always displays whether the input value is positive or negative.\n\nDeciding Which String Formatting Tool to Use You’ve learned about three different tools for string formatting up to this point. Having several choices for one task can be confusing. In the end, what tool should you use? If you want readable syntax, good performance, and you’re doing eager interpolation, then f-strings are for you. On the other hand, if you need a tool for doing lazy string interpolation, then the method is the way to go. In contrast, the modulo operator ( ) is an old-fashioned tool not commonly used in modern Python. You could say that this tool is almost dead. However, you may find it in legacy Python code, so it’s good to know how it works. The following table compares the three tools using several comparison criteria: F-strings are the clear winner in terms of readability. However, they don’t allow you to do lazy interpolation. There’s no way to use an f-string to create a reusable string template that you can interpolate later in your code. If you want a universal tool with all the features, then the method is the way to go.\n\nNow that you have some experience with string formatting tools in Python, you can use the questions and answers below to check your understanding and recap what you’ve learned. These FAQs are related to the most important concepts you’ve covered in this tutorial. Click the Show/Hide toggle beside each question to reveal the answer: What is string formatting in Python?Show/Hide String formatting in Python is the process of applying a specific format to a given value when creating a new string through interpolation. This allows you to embed variables and expressions into strings and control the appearance of the resulting output. How do you format a string in Python?Show/Hide You can format a string in Python using several methods: f-strings, the method, and the modulo operator ( ). What are the different types of string formatting in Python?Show/Hide The different types of string formatting in Python include f-strings for embedding expressions inside string literals, the method for creating string templates and filling them with values, and the modulo operator ( ), an older method used in legacy code similar to C’s function. Which string formatting method is best in Python?Show/Hide The string formatting method you choose will depend on the use case. While f-strings are best for readability and performance in modern Python and ideal for eager interpolation, the method is useful for lazy interpolation and when you need reusable templates. The modulo operator ( ), on the other hand, is mostly for maintaining legacy code and isn’t recommended for new projects. Python’s string formatting mini-language offers several features, including string alignment, type conversion, numeric formatting, and dynamic formatting. These features provide enhanced control over how interpolated values are presented in the final string. Get Your Code: Click here to download the free sample code you’ll use to learn about Python’s string formatting tools. Test your knowledge with our interactive “Python String Formatting: Available Tools and Their Features” quiz. You’ll receive a score upon completion to help you track your learning progress: Python String Formatting: Available Tools and Their Features You can take this quiz to test your understanding of the available tools for string formatting in Python, as well as their strengths and weaknesses. These tools include f-strings, the .format() method, and the modulo operator."
    },
    {
        "link": "https://mehedi-khan.medium.com/python-string-formatting-best-practices-4765104bc243",
        "document": "Below is an example tutorial on Python string formatting best practices with code examples. This tutorial assumes a basic understanding of Python programming.\n\nString formatting is a crucial aspect of Python programming and there are multiple ways to achieve it. In This tutorial, we’ll explore the best practices for string formatting is Python, focusing on readability, flexibility, and performance.\n\nThe old-style formatting using is still valid, but it’s considered outdated. However, it’s essential to be aware of it for understanding legacy code.\n\nThe method provides a more flexible and readable way to format strings. It allows for positional and keyword arguments.\n\nF-strings are a concise and efficient way to format strings introduced in Python 3.6. They allow embedding expressions inside string literals.\n\nTemplate string provide a simple and safe way for string formatting. They are less powerful than f-string but useful in certain scenarios.\n\nF-strings are concise and offer better readability. Use them whenever possible, especially in Python 3.6 and above.\n\nWhen using , consider using named placeholders for improved readability.\n\nc. Be Mindful of Escape Characters\n\nEscape characters (\n\n, \\t, etc.) may behave differently in different formatting methods. Be cautious and double-check when using them.\n\nIn performance-critical scenarios, f-strings are generally faster than other formatting methods. However, the difference might be negligible for most applications.\n\nString formatting in Python offers multiple approaches, each with its strengths. Choose the method that aligns with your Python version and project requirements. F-strings are recommended for modern Python projects due to their readability and efficiency.\n\nFeel free to experiment with the examples and incorporate these best practices into your Python projects!"
    }
]