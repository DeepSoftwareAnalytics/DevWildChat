[
    {
        "link": "https://webpack.js.org/api/module-methods",
        "document": "This section covers all methods available in code compiled with webpack. When using webpack to bundle your application, you can pick from a variety of module syntax styles including ES6, CommonJS, and AMD.\n\nWhile webpack supports multiple module syntaxes, we recommend following a single syntax for consistency and to avoid odd behaviors/bugs. Actually webpack would enforce the recommendation for files, files or files when their nearest parent file contains a field with a value of either or . Please pay attention to these enforcements before you read on:\n• or with in\n• No CommonJS allowed, for example, you can't use , or\n• File extensions are required when importing, e.g, you should use instead of (you can disable this enforcement with )\n• or with in\n• Neither nor is available\n\nVersion 2 of webpack supports ES6 module syntax natively, meaning you can use and without a tool like babel to handle this for you. Keep in mind that you will still probably need babel for other ES6+ features. The following methods are supported by webpack:\n\nStatically the s of another module.\n\nYou can also Data URI:\n\nExport anything as a or named export.\n\nDynamically load modules. Calls to are treated as split points, meaning the requested module and its children are split out into a separate chunk.\n\nIt is not possible to use a fully dynamic import statement, such as . Because could potentially be any path to any file in your system or project.\n\nThe must contain at least some information about where the module is located. Bundling can be limited to a specific directory or set of files so that when you are using a dynamic expression - every module that could potentially be requested on an call is included. For example, will cause every file in the directory to be bundled into the new chunk. At run time, when the variable has been computed, any file like or will be available for consumption.\n\nInline comments to make features work. By adding comments to the import, we can do things such as name our chunk or select different modes. For a full list of these magic comments see the code below followed by an explanation of what these comments do.\n\nWhen using , it does not remain as-is; instead, it gets replaced based on the . For modules, it is replaced with , and for other cases, it defaults to . This ensures that relative URLs work correctly, aligning with the base URL context.\n\nThe comment can control whether webpack processes a specific import or URL reference. It works in certain cases out of the box but doesn’t support all cases by default due to performance reasons.\n\nWe support in the following cases:\n\nA name for the new chunk. Since webpack 2.6.0, the placeholders and are supported within the given string to an incremented number or the actual resolved filename respectively. Adding this comment will cause our separate chunk to be named [my-chunk-name].js instead of [id].js.\n\nSet for specific dynamic imports. It's also possible to set a global default value for all dynamic imports by using the option.\n\nSince webpack 2.6.0, different modes for resolving dynamic imports can be specified. The following options are supported:\n• : Generates a single lazy-loadable chunk that can satisfy all calls to . The chunk will be fetched on the first call to , and subsequent calls to will use the same network response. Note that this only makes sense in the case of a partially dynamic statement, e.g. , where multiple module paths that can potentially be requested.\n• : Generates no extra chunk. All modules are included in the current chunk and no additional network requests are made. A is still returned but is already resolved. In contrast to a static import, the module isn't executed until the call to is made.\n• : Tries to load the module if the module function has already been loaded in some other way (e.g. another chunk imported it or a script containing the module was loaded). A is still returned, but only successfully resolves if the chunks are already on the client. If the module is not available, the is rejected. A network request will never be performed. This is useful for universal rendering when required chunks are always manually served in initial requests (embedded within the page), but not in cases where app navigation will trigger an import not initially served.\n\nTells the browser that the resource is probably needed for some navigation in the future. Check out the guide for more information on how webpackPrefetch works.\n\nTells the browser that the resource might be needed during the current navigation. Check out the guide for more information on how webpackPreload works.\n\nA regular expression that will be matched against during import resolution. Only modules that match will be bundled.\n\nA regular expression that will be matched against during import resolution. Any module that matches will not be bundled.\n\nTells webpack to only bundle the specified exports of a dynamically ed module. It can decrease the output size of a chunk. Available since webpack 5.0.0-beta.18.\n\nThe goal of CommonJS is to specify an ecosystem for JavaScript outside the browser. The following CommonJS methods are supported by webpack:\n\nSynchronously retrieve the exports from another module. The compiler will ensure that the dependency is available in the output bundle.\n\nIt's possible to enable magic comments for as well, see for more.\n\nSynchronously retrieve a module's ID. The compiler will ensure that the dependency is available in the output bundle. It is recommended to treat it as an opaque value which can only be used with or (best to avoid such usage).\n\nSee for more information.\n\nMultiple requires of the same module result in only one module execution and only one export. Therefore a cache in the runtime exists. Removing values from this cache causes new module execution and a new export.\n\nSplit out the given to a separate bundle that will be loaded asynchronously. When using CommonJS module syntax, this is the only way to dynamically load dependencies. Meaning, this code can be run within execution, only loading the if certain conditions are met.\n\nThe following parameters are supported in the order specified above:\n• : An array of strings declaring all modules required for the code in the to execute.\n• : A function that webpack will execute once the dependencies are loaded. An implementation of the function is sent as a parameter to this function. The function body can use this to further modules it needs for execution.\n• : A function that is executed when webpack fails to load the dependencies.\n• : A name given to the chunk created by this particular . By passing the same to various calls, we can combine their code into a single chunk, resulting in only one bundle that the browser must load.\n\nAsynchronous Module Definition (AMD) is a JavaScript specification that defines an interface for writing and loading modules. The following AMD methods are supported by webpack:\n\nIf are provided, will be called with the exports of each dependency (in the same order). If are not provided, is called with , and (for compatibility!). If this function returns a value, this value is exported by the module. The compiler ensures that each dependency is available.\n\nThis will export the provided . The here can be anything except a function.\n\nSimilar to , this will split the given into a separate bundle that will be loaded asynchronously. The will be called with the exports of each dependency in the array.\n\nThe internal enables you to use the following methods for exporting and requiring within your modules:\n\nExport the given . The label can occur before a function declaration or a variable declaration. The function name or variable name is the identifier under which the value is exported.\n\nMake all exports from the dependency available in the current scope. The label can occur before a string. The dependency must export values with the label. CommonJS or AMD modules cannot be consumed.\n\nAside from the module syntaxes described above, webpack also allows a few custom, webpack-specific methods:\n\nSpecify a whole group of dependencies using a path to the , an option to , a for more fine grained control of the modules included, and a to define the way how loading will work. Underlying modules can then be resolved later on:\n\nIf is set to , the underlying modules will be loaded asynchronously:\n\nThe full list of available modes and their behavior is described in documentation.\n\nInclude a without executing it. This can be used for optimizing the position of a module in the output chunks.\n\nThis will result in the following output:\n\nWithout it would be duplicated in both anonymous chunks.\n\nSimilar to , but this won't pull the into the bundle. It's what is considered a \"weak\" dependency.\n\nIf the module source contains a require that cannot be statically analyzed, critical dependencies warning is emitted."
    },
    {
        "link": "https://webpack.js.org/configuration/module",
        "document": "These options determine how the different types of modules within a project will be treated.\n\nAn array of rules applied by default for modules.\n\nStarting with webpack 5.87.0, falsy values including , , , and are allowed to pass to to conditionally disable specific rules.\n\nIt's possible to configure all generators' options in one place with a .\n\nSimilar to the , you can configure all parsers' options in one place with a .\n\nThis option enables the handling of at-rules in CSS files. When set to , statements are processed, allowing modular inclusion of styles from other CSS files.\n\nThis option enables the use of ES modules named export for CSS exports. When set to , the CSS module will export its classes and styles using named exports.\n\nWhen is for CSS modules, you can retrieve CSS classes using various import methods. Named exports are redirected to improve developer experience (DX), facilitating a smooth transition from default exports to named exports:\n\nWhen is enabled (default behavior), you can use only named exports to import CSS classes.\n\nBy enabling , you adopt a more modular and maintainable approach to managing CSS in JavaScript projects, leveraging ES module syntax for clearer and more explicit imports.\n\nThis option enables or disables the handling of URLs in functions such as , , , and within CSS files. When enabled, these URLs are resolved and processed by webpack.\n\nIt's allowed to configure those options in as well to target specific modules.\n\nNote that only comment is supported at the moment:\n\nSpecify the global fetchPriority for dynamic import.\n\nSpecifies the behavior of invalid export names in and .\n\nSpecifies the behavior of invalid export names in .\n\nSet the module to or mode. This can affect the module's behavior, as some behaviors differ between strict and non-strict modes.\n\nSpecifies the behavior of invalid export names in . This might be useful to disable during the migration from to when reexporting types in TypeScript.\n\nThe value for is available since webpack 5.23.0. When used, webpack would generate relative URLs for syntax, i.e., there's no base URL included in the result URL:\n• This is useful for SSR (Server side rendering) when base URL is not known by server (and it saves a few bytes). To be identical it must also be used for the client build.\n• Also for static site generators, mini-css-plugin and html-plugin, etc. where server side rendering is commonly needed.\n\nThe depth of json dependency flagged as . By default, it is set to in production mode, and in development mode.\n\nPrevent webpack from parsing any files matching the given regular expression(s). Ignored files should not have calls to , , or any other importing mechanism. This can boost build performance when ignoring large libraries.\n\ncan be also used as a way to deliberately prevent expansion of all , , etc. calls for cases when those calls are unreachable at runtime. For example, when building a project for target and using a third-party library that was prebuilt for both browser and Node.js and it requires Node.js built-ins e.g. .\n\nCache the resolution of module requests. There are a couple of defaults for :\n• if is enabled and the module appears to come from node modules, otherwise.\n\nAn array of Rules which are matched to requests when modules are created. These rules can modify how the module is created. They can apply loaders to the module, or modify the parser.\n\nAs of webpack 5.87.0, falsy values such as , , and can be used to conditionally disable a rule.\n\nA Rule can be separated into three parts — Conditions, Results and nested Rules.\n\nThere are two input values for the conditions:\n• The resource: An absolute path to the file requested. It's already resolved according to the rules.\n• The issuer: An absolute path to the file of the module which requested the resource. It's the location of the import.\n\nExample: When we within , the resource is and the issuer is .\n\nIn a Rule the properties , , and are matched with the resource and the property is matched with the issuer.\n\nWhen using multiple conditions, all conditions must match.\n\nRule results are used only when the Rule condition matches.\n\nThere are two output values of a Rule:\n• Applied loaders: An array of loaders applied to the resource.\n• Parser options: An options object which should be used to create the parser for this module.\n\nFor compatibility also these properties: , .\n\nThe property affects the loader category. Whether it's a normal, pre- or post- loader.\n\nNested rules can be specified under the properties and .\n\nThese rules are evaluated only when the parent Rule condition matches. Each nested rule can contain its own conditions.\n\nThe order of evaluation is as follows:\n\nA that allows you to match the import assertion of a dependency and apply specific rules based on the assertion type.\n\nIn this example, is used to apply to any module imported with the assertion , ensuring that JSON files are processed correctly.\n\nA that allows you to match the child compiler name.\n\nSpecifies the category of the loader. No value means normal loader.\n\nThere is also an additional category \"inlined loader\" which are loaders applied inline of the import/require.\n\nThere are two phases that all loaders enter one after the other:\n• Pitching phase: the pitch method on loaders is called in the order . See Pitching Loader for details.\n• Normal phase: the normal method on loaders is executed in the order . Transformation on the source code of a module happens in this phase.\n\nAll normal loaders can be omitted (overridden) by prefixing in the request.\n\nAll normal and pre loaders can be omitted (overridden) by prefixing in the request.\n\nAll normal, post and pre loaders can be omitted (overridden) by prefixing in the request.\n\nInline loaders and prefixes should not be used as they are non-standard. They may be used by loader generated code.\n\nExclude all modules matching any of these conditions. If you supply a option, you cannot also supply a . See and for details.\n\nInclude all modules matching any of these conditions. If you supply a option, you cannot also supply a . See and for details.\n\nA to match against the module that issued the request. In the following example, the for the request would be the path to the file.\n\nThis option can be used to apply loaders to the dependencies of a specific module or set of modules.\n\nAllows to filter/match by layer of the issuer.\n\nSpecify the layer in which the module should be placed in. A group of modules could be united in one layer which could then be used in split chunks, stats or entry options.\n\nis a shortcut to . See and for details.\n\nis an alias to . See for details.\n\nYou can match config rules to data uri with .\n\n, , , and are already included by default as mimetype.\n\nAn array of from which only the first matching Rule is used when the Rule matches.\n\nand are shortcuts to . See and for details.\n\nAn object with parser options. All applied parser options are merged.\n\nParsers may inspect these options and disable or reconfigure themselves accordingly. Most of the default plugins interpret the values as follows:\n• Setting the option to disables the parser.\n• Setting the option to or leaving it enables the parser.\n\nHowever, parser plugins may accept more than only a boolean. For example, the internal can accept an object instead of to add additional options for a particular Rule.\n\nIf is an then option may be an object or a function that describes a condition whether to encode file contents to Base64 or emit it as a separate file into the output directory.\n\nIf is an or then option may be an object that describes the encoding of the module source or a function that encodes module's source by a custom algorithm.\n\nSee Asset Modules guide for additional information and use cases.\n\nIf a module source size is less than then module will be injected into the bundle as a Base64-encoded string, otherwise module file will be emitted into the output directory.\n\nWhen a function is given, returning tells webpack to inject the module into the bundle as Base64-encoded string, otherwise module file will be emitted into the output directory.\n\nWhen is used as an object, you can configure two properties:\n• encoding: When set to , module source will be encoded using Base64 algorithm. Setting to false will disable encoding.\n• mimetype: A mimetype for data URI. Resolves from module resource extension by default.\n\nWhen used a a function, it executes for every module and must return a data URI string.\n\nOpt out of writing assets from Asset Modules, you might want to use it in Server side rendering cases.\n\nThe same as but for specific rule. Overrides and works only with and module types.\n\nEmit the asset in the specified folder relative to 'output.path'. This should only be needed when custom 'publicPath' is specified to match the folder structure there.\n\nA matched with the resource. See details in conditions.\n\nA matched with the resource query. This option is used to test against the query section of a request string (i.e. from the question mark onwards). If you were to , the following condition would match:\n\nIf is set to then option may be a function that implements custom logic to parse module's source and convert it to a JavaScript . It may be useful to import , and other non-JSON files as JSON, without specific loaders:\n\nAn array of that is also used when the Rule matches.\n\nIndicate what parts of the module contain side effects. See Tree Shaking for details.\n\nInclude all modules that pass test assertion. If you supply a option, you cannot also supply a . See and for details.\n\nsets the type for a matching module. This prevents defaultRules and their default importing behaviors from occurring. For example, if you want to load a file through a custom loader, you'd need to set the to to bypass webpack's built-in json importing.\n\nSee use case of module type here. Make sure to enable to use .\n\nStarting with webpack 5.87.0 falsy values such as can be used to conditionally disable specific use entry.\n\ncan be an array of UseEntry which are applied to modules. Each entry specifies a loader to be used.\n\nPassing a string (i.e. ) is a shortcut to the loader property (i.e. ).\n\nLoaders can be chained by passing multiple loaders, which will be applied from right to left (last to first configured).\n\ncan also be a function which receives the object argument describing the module being loaded, and must return an array of items.\n\nThe object parameter has the following fields:\n• : The current webpack compiler (can be undefined)\n• : The path to the module that is importing the module being loaded\n• : Always the path to the module being loaded\n• : The path to the module being loaded, it is usually equal to except when the resource name is overwritten via in request string\n\nThe same shortcut as an array can be used for the return value (i.e. ).\n\nResolving can be configured on module level. See all available options on resolve configuration page. All applied resolve options get deeply merged with higher level resolve.\n\nFor example, let's imagine we have an entry in , and a to demonstrate the module level resolve.\n\nWhen creating a bundle with this configuration, will output 'default footer'. Let's set for files, and alias to .\n\nWhen creating a bundle with updated configuration, will output 'overridden footer'.\n\nWhen enabled, you should provide the file extension when ing a module in files or any other files when their nearest parent file contains a field with a value of , otherwise webpack would fail the compiling with a error. And webpack won't resolve directories with filenames defined in the , you have to specify the filename yourself.\n\nA that allows you to match the imports based on specific conditions provided with the keyword, enabling different rules to be applied based on the content type.\n\nIn this example, is used to apply to any module imported with the condition .\n\nConditions can be one of these:\n• A string: To match the input must start with the provided string. I. e. an absolute directory path, or absolute path to the file.\n• A RegExp: It's tested with the input.\n• A function: It's called with the input and must return a truthy value to match.\n• An array of Conditions: At least one of the Conditions must match.\n• An object: All properties must match. Each property has a defined behavior.\n\n: All Conditions must NOT match.\n\nIt must have a property being a string. It is resolved relative to the configuration with the loader resolving options (resolveLoader).\n\nIt can have an property being a string or object. This value is passed to the loader, which should interpret it as loader options.\n\nFor compatibility a property is also possible, which is an alias for the property. Use the property instead.\n\nNote that webpack needs to generate a unique module identifier from the resource and all loaders including options. It tries to do this with a of the options object. This is fine in 99.9% of cases, but may be not unique if you apply the same loaders with different options to the resource and the options have same stringified values.\n\nIt also breaks if the options object cannot be stringified (i.e. circular JSON). Because of this you can have a property in the options object which is used as unique identifier.\n\nA can also be a function which receives the object argument describing the module being loaded, and must return a non-function object. This can be used to vary the loader options on a per-module basis.\n\nThe object parameter has the following fields:\n• : The current webpack compiler (can be undefined)\n• : The path to the module that is importing the module being loaded\n• : Always the path to the module being loaded\n• : The path to the module being loaded, it is usually equal to except when the resource name is overwritten via in request string\n\nThese options describe the default settings for the context created when a dynamic dependency is encountered.\n\nExample for an dynamic dependency: .\n\nExample for an dynamic dependency: .\n\nExample for an dynamic dependency: .\n\nHere are the available options with their defaults:\n• should include the whole directory:\n• should not include subdirectories by default:\n• makes missing exports an error instead of warning\n• Set the inner regular expression for partial dynamic dependencies :"
    },
    {
        "link": "https://webpack.js.org/loaders/exports-loader",
        "document": "Disclaimer: exports-loader is a third-party package maintained by community members, it potentially does not have the same support, security policy or license as webpack, and it is not maintained by webpack.\n\nAllow to setup exports / for source files.\n\nUseful when a source file does not contain exports or something does not export.\n\nFor further hints on compatibility issues, check out Shimming of the official docs.\n\nTo begin, you'll need to install :\n\nThe or (space) allow to separate the , and of export. The documentation and syntax examples can be read here.\n\nThen add the loader to the desired statement or calls. For example:\n\nDescription of string values can be found in the documentation below.\n\nAnd run via your preferred method.\n\nAllows to use a string to describe an export.\n\nThe or (space) allow to separate the , and of export.\n• \n• if is - can be and ,\n• if is - can be and\n• - name of an exported value (required)\n• - alias of an exported value (may be omitted)\n• - generates ES module named exports and exports a value equal to the filename under other name., for it will be and , generates .\n\nAllows to use an object to describe an export.\n• - can be or for the type ( module format), and or for the type ( module format) (may be omitted)\n• - name of an exported value (required)\n• - alias of an exported value (may be omitted)\n\nAllow to specify multiple exports. Each item can be a or an .\n\nPlease take a moment to read our contributing guidelines if you haven't yet done so."
    },
    {
        "link": "https://github.com/webpack/webpack/issues/706",
        "document": "I'm writing a library with ES6 module notation. The main module exports only a default object:\n\nInside other ES6 modules, Webpack seems to handle this well, extracting the when needed. But when exporting my library to, e.g., UMD, the entire object is exported.\n\nI'd like the option to export instead. Right now, my build-process fixes this with a simple search/replace operation on the Webpack output:\n\nIt works, but it's not ideal."
    },
    {
        "link": "https://stackoverflow.com/questions/56449654/module-exports-with-es6-import-for-webpack-config-ts-in-typescript",
        "document": "I'm using webpack with typescript with the config its self in typescript. Instructions here\n\nIn my root I have\n\nI then have two projects each with their own\n\nThis all works absolutely fine. Here's a full example of this factory style.\n\nMy problem is when I try to change to change\n\nTo an es6 import. This is even provided as a suggestion by VS code.\n\nWhen I apply this change I get\n\nHere's my I already have enabled. Suggested here.\n\nBut I added anyway... and again. It still fails.\n\nMy final attempt before smashing my head into the table was to change\n\nDelete the in the and export the directly as . But at that point what's the point of . Not to mention it also doesn't bloody work (same issue as before)\n\nWhat am I missing here? Why can't I simply replace with\n\nHere's my for running this"
    },
    {
        "link": "https://stackoverflow.com/questions/55583400/unable-to-import-javascript-class-typeerror-class-is-not-a-constructor",
        "document": "I'm having a really weird issue with importing my class into another module. In my start.js file, I can import the worker module and it runs the script fine. However, when it gets to the socket module and tries to import the worker module, I get the following error.\n\nWhen I console log worker in the socket.js constructor, it shows as an empty object. When I console log it in the start.js, it shows as a function.\n\nI know this has to be something very simple that I'm overlooking, but I just can't see it.\n\nI have a start.js file where I import my worker module and start my app.\n\nThe worker module (worker.js) imports my socket server module and connects to the socket server.\n\nMy socket server module (socket.js) also imports (worker.js) so that I can use the startJob function within the socket.on('process') event as Worker.startJob()."
    },
    {
        "link": "https://stackoverflow.com/questions/10107198/javascript-not-a-constructor-exception-while-creating-objects",
        "document": "What could be wrong? I googled around a lot, but I still can't figure out what I am doing wrong.\n\nI then try to create an instance like this:\n\nI am defining an object like this:\n\nThe code as posted in the question cannot generate that error, because is not a user-defined function / valid constructor. You've probably done something like this: function Project(a,b,c) {} Project = {}; // or possibly Project = new Project new Project(1,2,3); // -> TypeError: Project is not a constructor Variable declarations using are hoisted and thus always evaluated before the rest of the code. So, this can also be causing issues: function Project(){} function localTest() { new Project(1,2,3); // `Project` points to the local variable, // not the global constructor! //...some noise, causing you to forget that the `Project` constructor was used var Project = 1; // Evaluated first }\n\nFor my project, the problem turned out to be a circular reference created by the require() calls: y.js: var x = require(\"./x.js\"); var y = function() { console.log(\"result is \" + x(); } module.exports = y; x.js: var y = require(\"./y.js\"); var my_y = new y(); // <- TypeError: y is not a constructor var x = function() { console.log(\"result is \" + my_y; } module.exports = x; The reason is that when it is attempting to initialize y, it creates a temporary \"y\" object (not class, object!) in the dependency system that is somehow not yet a constructor. Then, when x.js is finished being defined, it can continue making y a constructor. Only, x.js has an error in it where it tries to use the non-constructor y.\n\nI just had a similar error when trying to use the BS5ModalJS in conjunction with webpack, meaning I was trying to import the js file. Because the single .js file provided was designed to be used via the script tags, it took a while for me to realise that to avoid the \"BSModal is not a constructor\" error, I had to go into their code and add: without getting that error. So if you're using webpack, perhaps make sure the classes and functions are exported (and therefore available) to the callers.\n\nIn my case I'd forgotten the open and close parantheses at the end of the definition of the function wrapping all of my code in the exported module. I.e. I had: The compiler doesn't complain, but the require statement in the importing module doesn't set the variable it's being assigned to, so it's undefined at the point you try to construct it and it will give the error.\n\nI had a similar error and my problem was that the name and case of the variable name and constructor name were identical, which doesn't work since javascript interprets the intended constructor as the newly created variable. function project(name){ this.name = name; } //elsewhere... //this is no good! name/case are identical so javascript barfs. let project = new project('My Project'); Simply changing case or variable name fixes the problem, though: //with a capital 'P' function Project(name){ this.name = name; } //elsewhere... //works! class name/case is dissimilar to variable name let project = new Project('My Project');\n\nTo add the solution I found to this problem when I had it, I was including a class from another file and the file I tried to instantiate it in gave the \"not a constructor\" error. Ultimately the issue was a couple unused requires in the other file before the class was defined. I'm not sure why they broke it, but removing them fixed it. Always be sure to check if something might be hiding in between the steps you're thinking about."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import",
        "document": "A module namespace object is an object that describes all exports from a module. It is a static object that is created when the module is evaluated. There are two ways to access the module namespace object of a module: through a namespace import ( import * as name from moduleName ), or through the fulfillment value of a dynamic import.\n\nThe module namespace object is a sealed object with prototype. This means all string keys of the object correspond to the exports of the module and there are never extra keys. All keys are enumerable in lexicographic order (i.e. the default behavior of ), with the default export available as a key called . In addition, the module namespace object has a property with the value , used in .\n\nThe string properties are non-configurable and writable when you use to get their descriptors. However, they are effectively read-only, because you cannot re-assign a property to a new value. This behavior mirrors the fact that static imports create \"live bindings\" — the values can be re-assigned by the module exporting them, but not by the module importing them. The writability of the properties reflects the possibility of the values changing, because non-configurable and non-writable properties must be constant. For example, you can re-assign the exported value of a variable, and the new value can be observed in the module namespace object.\n\nEach (normalized) module specifier corresponds to a unique module namespace object, so the following is generally true:\n\nExcept in one curious case: because a promise never fulfills to a thenable, if the module exports a function called , that function will automatically get called when the dynamic import's promise is fulfilled, as part of the promise resolution process.\n\nThis aggressive caching ensures that a piece of JavaScript code is never executed more than once, even if it is imported multiple times. Future imports don't even result in HTTP requests or disk access. If you do need to re-import and re-evaluate a module without restarting the entire JavaScript environment, one possible trick is to use a unique query parameter in the module specifier. This works in non-browser runtimes that support URL specifiers too.\n\nNote that this can lead to memory leaks in a long-running application, because the engine cannot safely garbage-collect any module namespace objects. Currently, there is no way to manually clear the cache of module namespace objects.\n\nModule namespace object caching only applies to modules that are loaded and linked successfully. A module is imported in three steps: loading (fetching the module), linking (mostly, parsing the module), and evaluating (executing the parsed code). Only evaluation failures are cached; if a module fails to load or link, the next import may try to load and link the module again. The browser may or may not cache the result of the fetch operation, but it should follow typical HTTP semantics, so handling such network failures should not be different from handling failures."
    },
    {
        "link": "https://github.com/evanw/esbuild/issues/1073",
        "document": "I want to use typescript and its dynamic feature to do something but I realized that the esbuild didn't compile the 'import * as'\n\n For example:\n\nand I build the thing with following configuration:\n\nit is built successfully but when I ran dist/main.js error came out.\n\n \n\n this behavior is different from using tsc because esbuild warp the lib in main.ts like this:\n\n \n\n so the values function gets the and it goes error\n\n but tsc warp like this\n\n \n\n the default is gone and the class is still a class rather than a getter\n\nand I've read https://esbuild.github.io/content-types/#es-module-interop and realized that I should explicitly indicate the thing I was importing like rather than \"import *\", but is there any way to maintain the original behavior from tsc to keep the dynamic import functional?"
    },
    {
        "link": "https://kinsta.com/blog/errors-in-javascript",
        "document": "Murphy’s law states that whatever can go wrong will eventually go wrong. This applies a tad too well in the world of programming. If you create an application, chances are you’ll create bugs and other issues. Errors in JavaScript are one such common issue!\n\nA software product’s success depends on how well its creators can resolve these issues before hurting their users. And JavaScript, out of all programming languages, is notorious for its average error handling design.\n\nIf you’re building a JavaScript application, there’s a high chance you’ll mess up with data types at one point or another. If not that, then you might end up replacing an undefined with a null or a triple equals operator ( ) with a double equals operator ( ).\n\nIt’s only human to make mistakes. This is why we will show you everything you need to know about handling errors in JavaScript.\n\nThis article will guide you through the basic errors in JavaScript and explain the various errors you might encounter. You’ll then learn how to identify and fix these errors. There are also a couple of tips to handle errors effectively in production environments.\n\nCheck Out Our Video Guide to Handling JavaScript Errors\n\nErrors in programming refer to situations that don’t let a program function normally. It can happen when a program doesn’t know how to handle the job at hand, such as when trying to open a non-existent file or reaching out to a web-based API endpoint while there’s no network connectivity.\n\nThese situations push the program to throw errors to the user, stating that it doesn’t know how to proceed. The program collects as much information as possible about the error and then reports that it can not move ahead.\n\nIntelligent programmers try to predict and cover these scenarios so that the user doesn’t have to figure out a technical error message like “404” independently. Instead, they show a much more understandable message: “The page could not be found.”\n\nErrors in JavaScript are objects shown whenever a programming error occurs. These objects contain ample information about the type of the error, the statement that caused the error, and the stack trace when the error occurred. JavaScript also allows programmers to create custom errors to provide extra information when debugging issues.\n\nNow that the definition of a JavaScript error is clear, it’s time to dive into the details.\n\nErrors in JavaScript carry certain standard and custom properties that help understand the cause and effects of the error. By default, errors in JavaScript contain three properties:\n• message: A string value that carries the error message\n• name: The type of error that occurred (We’ll dive deep into this in the next section)\n• stack: The stack trace of the code executed when the error occurred.\n\nAdditionally, errors can also carry properties like columnNumber, lineNumber, fileName, etc., to describe the error better. However, these properties are not standard and may or may not be present in every error object generated from your JavaScript application.\n\nA stack trace is the list of method calls a program was in when an event such as an exception or a warning occurs. This is what a sample stack trace accompanied by an exception looks like:\n\nAs you can see, it starts by printing the error name and message, followed by a list of methods that were being called. Each method call states the location of its source code and the line at which it was invoked. You can use this data to navigate through your codebase and identify which piece of code is causing the error.\n\nThis list of methods is arranged in a stacked fashion. It shows where your exception was first thrown and how it propagated through the stacked method calls. Implementing a catch for the exception will not let it propagate up through the stack and crash your program. However, you might want to leave fatal errors uncaught to crash the program in some scenarios intentionally.\n\nMost people usually consider errors and exceptions as the same thing. However, it’s essential to note a slight yet fundamental difference between them.\n\nTo understand this better, let’s take a quick example. Here is how you can define an error in JavaScript:\n\nAnd this is how the object becomes an exception:\n\nHowever, most people tend to use the shorthand form which defines error objects while throwing them:\n\nThis is standard practice. However, it’s one of the reasons why developers tend to mix up exceptions and errors. Therefore, knowing the fundamentals is vital even though you use shorthands to get your work done quickly.\n\nThere’s a range of predefined error types in JavaScript. They are automatically chosen and defined by the JavaScript runtime whenever the programmer doesn’t explicitly handle errors in the application.\n\nThis section will walk you through some of the most common types of errors in JavaScript and understand when and why they occur.\n\nA RangeError is thrown when a variable is set with a value outside its legal values range. It usually occurs when passing a value as an argument to a function, and the given value doesn’t lie in the range of the function’s parameters. It can sometimes get tricky to fix when using poorly documented third-party libraries since you need to know the range of possible values for the arguments to pass in the correct value.\n\nSome of the common scenarios in which RangeError occurs are:\n• Trying to create an array of illegal lengths via the Array constructor.\n• Passing bad values to numeric methods like , , , etc.\n\nA ReferenceError occurs when something is wrong with a variable’s reference in your code. You might have forgotten to define a value for the variable before using it, or you might be trying to use an inaccessible variable in your code. In any case, going through the stack trace provides ample information to find and fix the variable reference that is at fault.\n\nSome of the common reasons why ReferenceErrors occur are:\n• Trying to access block-scoped variables outside of their scopes.\n• Referencing a global variable from an external library (like $ from jQuery) before it’s loaded.\n\nThese errors are one of the simplest to fix since they indicate an error in the syntax of the code. Since JavaScript is a scripting language that is interpreted rather than compiled, these are thrown when the app executes the script that contains the error. In the case of compiled languages, such errors are identified during compilation. Thus, the app binaries are not created until these are fixed.\n\nSome of the common reasons why SyntaxErrors might occur are:\n• Improper alignment of curly braces or other characters\n\nIt’s a good practice to use a linting tool in your IDE to identify such errors for you before they hit the browser.\n\nTypeError is one of the most common errors in JavaScript apps. This error is created when some value doesn’t turn out to be of a particular expected type. Some of the common cases when it occurs are:\n• Invoking objects that are not methods.\n• Attempting to access properties of null or undefined objects\n\nThere are a lot more possibilities where a TypeError can occur. We’ll look at some famous instances later and learn how to fix them.\n\nThe InternalError type is used when an exception occurs in the JavaScript runtime engine. It may or may not indicate an issue with your code.\n\nMore often than not, InternalError occurs in two scenarios only:\n• When a patch or an update to the JavaScript runtime carries a bug that throws exceptions (this happens very rarely)\n• When your code contains entities that are too large for the JavaScript engine (e.g. too many switch cases, too large array initializers, too much recursion)\n\nThe most appropriate approach to solve this error is to identify the cause via the error message and restructure your app logic, if possible, to eliminate the sudden spike of workload on the JavaScript engine.\n\nURIError occurs when a global URI handling function such as is used illegally. It usually indicates that the parameter passed to the method call did not conform to URI standards and thus was not parsed by the method properly.\n\nDiagnosing these errors is usually easy since you only need to examine the arguments for malformation.\n\nAn EvalError occurs when an error occurs with an function call. The function is used to execute JavaScript code stored in strings. However, since using the function is highly discouraged due to security issues and the current ECMAScript specifications don’t throw the class anymore, this error type exists simply to maintain backward compatibility with legacy JavaScript code.\n\nIf you’re working on an older version of JavaScript, you might encounter this error. In any case, it’s best to investigate the code executed in the function call for any exceptions.\n\nWhile JavaScript offers an adequate list of error type classes to cover for most scenarios, you can always create a new error type if the list doesn’t satisfy your requirements. The foundation of this flexibility lies in the fact that JavaScript allows you to throw anything literally with the command.\n\nSo, technically, these statements are entirely legal:\n\nHowever, throwing a primitive data type doesn’t provide details about the error, such as its type, name, or the accompanying stack trace. To fix this and standardize the error handling process, the class has been provided. It’s also discouraged to use primitive data types while throwing exceptions.\n\nYou can extend the class to create your custom error class. Here is a basic example of how you can do this:\n\nAnd you can use it in the following way:\n\nAnd you can then identify it using the keyword:\n\nNow that you understand the common error types and how to create your custom ones, it’s time to look at some of the most common errors you’ll face when writing JavaScript code.\n\nCheck Out Our Video Guide to The Most Common JavaScript Errors\n\nThis error occurs in Google Chrome under a few various scenarios. First, it can happen if you call a recursive function and it doesn’t terminate. You can check this out yourself in the Chrome Developer Console:\n\nSo to solve such an error, make sure to define the border cases of your recursive function correctly. Another reason why this error happens is if you have passed a value that is out of a function’s parameter’s range. Here’s an example:\n\nThe error message will usually indicate what is wrong with your code. Once you make the changes, it will be resolved.\n\nThis error occurs when you set a property on an undefined reference. You can reproduce the issue with this code:\n\nTo fix this error, initialize the reference with a value before accessing its properties. Here’s how it looks when fixed:\n\nThis is one of the most frequently occurring errors in JavaScript. This error occurs when you attempt to read a property or call a function on an undefined object. You can reproduce it very easily by running the following code in a Chrome Developer console:\n\nAn undefined object is one of the many possible causes of this error. Another prominent cause of this issue can be an improper initialization of the state while rendering the UI. Here’s a real-world example from a React application:\n\nThe app starts with an empty state container and is provided with some items after a delay of 2 seconds. The delay is put in place to imitate a network call. Even if your network is super fast, you’ll still face a minor delay due to which the component will render at least once. If you try to run this app, you’ll receive the following error:\n\nThis is because, at the time of rendering, the state container is undefined; thus, there exists no property on it. Fixing this error is easy. You just need to provide an initial default value to the state container.\n\nNow, after the set delay, your app will show a similar output:\n\nThe exact fix in your code might be different, but the essence here is to always initialize your variables properly before using them.\n\n4. TypeError: ‘undefined’ is not an object\n\nThis error occurs in Safari when you try to access the properties of or call a method on an undefined object. You can run the same code from above to reproduce the error yourself.\n\nThe solution to this error is also the same — make sure that you have initialized your variables correctly and they are not undefined when a property or method is accessed.\n\n5. TypeError: null is not an object\n\nThis is, again, similar to the previous error. It occurs on Safari, and the only difference between the two errors is that this one is thrown when the object whose property or method is being accessed is instead of . You can reproduce this by running the following piece of code:\n\nSince is a value explicitly set to a variable and not assigned automatically by JavaScript. This error can occur only if you’re trying to access a variable you set by yourself. So, you need to revisit your code and check if the logic that you wrote is correct or not.\n\nThis error occurs in Chrome when you try to read the length of a or object. The cause of this issue is similar to the previous issues, but it occurs quite frequently while handling lists; hence it deserves a special mention. Here’s how you can reproduce the problem:\n\nHowever, in the newer versions of Chrome, this error is reported as . This is how it looks now:\n\nThe fix, again, is to ensure that the object whose length you’re trying to access exists and is not set to .\n\nThis error occurs when you try to invoke a method that doesn’t exist in your script, or it does but can not be referenced in the calling context. This error usually occurs in Google Chrome, and you can solve it by checking the line of code throwing the error. If you find a typo, fix it and check if it solves your issue.\n\nIf you have used the self-referencing keyword in your code, this error might arise if is not appropriately bound to your context. Consider the following code:\n\nIf you execute the above code, it will throw the error we discussed. It happens because the anonymous function passed as the event listener is being executed in the context of the .\n\nIn contrast, the function is defined in the context of the .\n\nTo solve this, you must pass the proper reference to the function by binding it with the method:\n\nThis error occurs when you try to access a reference not defined in the calling scope. This usually happens when handling events since they often provide you with a reference called in the callback function. This error can occur if you forget to define the event argument in your function’s parameters or misspell it.\n\nThis error might not occur in Internet Explorer or Google Chrome (as IE offers a global event variable and Chrome attaches the event variable automatically to the handler), but it can occur in Firefox. So it’s advisable to keep an eye out for such small mistakes.\n\nThis is an error that arises out of carelessness. If you try to assign a new value to a constant variable, you’ll be met with such a result:\n\nWhile it seems easy to fix right now, imagine hundreds of such variable declarations and one of them mistakenly defined as instead of ! Unlike other scripting languages like PHP, there’s minimal difference between the style of declaring constants and variables in JavaScript. Therefore it’s advisable to check your declarations first of all when you face this error. You could also run into this error if you forget that the said reference is a constant and use it as a variable. This indicates either carelessness or a flaw in your app’s logic. Make sure to check this when trying to fix this issue.\n\nA script error occurs when a third-party script sends an error to your browser. This error is followed by (unknown) because the third-party script belongs to a different domain than your app. The browser hides other details to prevent leaking sensitive information from the third-party script.\n\nYou can not resolve this error without knowing the complete details. Here’s what you can do to get more information about the error:\n• Add the attribute in the script tag.\n• Set the correct header on the server hosting the script.\n• [Optional] If you don’t have access to the server hosting the script, you can consider using a proxy to relay your request to the server and back to the client with the correct headers.\n\nOnce you can access the details of the error, you can then set down to fix the issue, which will probably be with either the third-party library or the network.\n\nHow to Identify and Prevent Errors in JavaScript\n\nWhile the errors discussed above are the most common and frequent in JavaScript, you’ll come across, relying on a few examples can never be enough. It’s vital to understand how to detect and prevent any type of error in a JavaScript application while developing it. Here is how you can handle errors in JavaScript.\n\nThe most fundamental way of handling errors that have been thrown either manually or by the runtime is to catch them. Like most other languages, JavaScript offers a set of keywords to handle errors. It’s essential to know each of them in-depth before you set down to handle errors in your JavaScript app.\n\nThe first and most basic keyword of the set is . As evident, the throw keyword is used to throw errors to create exceptions in the JavaScript runtime manually. We have already discussed this earlier in the piece, and here’s the gist of this keyword’s significance:\n• You can anything, including numbers, strings, and objects.\n• However, it’s not advisable to throw primitive data types such as strings and numbers since they don’t carry debug information about the errors.\n\nThe keyword is used to indicate that a block of code might throw an exception. Its syntax is:\n\nIt’s important to note that a block must always follow the block to handle errors effectively.\n\nThe keyword is used to create a catch block. This block of code is responsible for handling the errors that the trailing block catches. Here is its syntax:\n\nAnd this is how you implement the and the blocks together:\n\nUnlike C++ or Java, you can not append multiple blocks to a block in JavaScript. This means that you can not do this:\n\nInstead, you can use an statement or a switch case statement inside the single catch block to handle all possible error cases. It would look like this:\n\nThe keyword is used to define a code block that is run after an error has been handled. This block is executed after the try and the catch blocks.\n\nAlso, the finally block will be executed regardless of the result of the other two blocks. This means that even if the catch block cannot handle the error entirely or an error is thrown in the catch block, the interpreter will execute the code in the finally block before the program crashes.\n\nTo be considered valid, the try block in JavaScript needs to be followed by either a catch or a finally block. Without any of those, the interpreter will raise a SyntaxError. Therefore, make sure to follow your try blocks with at least either of them when handling errors.\n\nThe method is available to all HTML elements for handling any errors that may occur with them. For instance, if an tag cannot find the image whose URL is specified, it fires its onerror method to allow the user to handle the error.\n\nTypically, you would provide another image URL in the onerror call for the tag to fall back to. This is how you can do that via JavaScript:\n\nHowever, you can use this feature to create a global error handling mechanism for your app. Here’s how you can do it:\n\nWith this event handler, you can get rid of the multiple blocks lying around in your code and centralize your app’s error handling similar to event handling. You can attach multiple error handlers to the window to maintain the Single Responsibility Principle from the SOLID design principles. The interpreter will cycle through all handlers until it reaches the appropriate one.\n\nWhile simple and linear functions allow error handling to remain simple, callbacks can complicate the affair.\n\nConsider the following piece of code:\n\nThe above function demonstrates an asynchronous condition in which a function takes some time to process operations and returns the result later with the help of a callback.\n\nIf you try to enter a string instead of 4 in the function call, you’ll get as a result.\n\nThis needs to be handled properly. Here’s how:\n\nThis should solve the problem ideally. However, if you try passing a string to the function call, you’ll receive this:\n\nEven though you have implemented a try-catch block while calling the function, it still says the error is uncaught. The error is thrown after the catch block has been executed due to the timeout delay.\n\nThis can occur quickly in network calls, where unexpected delays creep in. You need to cover such cases while developing your app.\n\nHere’s how you can handle errors properly in callbacks:\n\nNow, the output at the console will be:\n\nThis indicates that the error has been appropriately handled.\n\nMost people tend to prefer promises for handling asynchronous activities. Promises have another advantage — a rejected promise doesn’t terminate your script. However, you still need to implement a catch block to handle errors in promises. To understand this better, let’s rewrite the function using Promises:\n\nThe timeout from the previous code has been isolated into the function for understanding. If you try to enter a string instead of 4, the output that you get will be similar to this:\n\nAgain, this is due to the throwing the error after everything else has completed execution. The solution to this issue is simple. Simply add a call to the promise chain like this:\n\nNow the output will be:\n\nYou can observe how easy it is to handle errors with promises. Additionally, you can chain a block and the promise call to add code that will run after error handling has been completed.\n\nAlternatively, you can also handle errors in promises using the traditional try-catch-finally technique. Here’s how your promise call would look like in that case:\n\nHowever, this works inside an asynchronous function only. Therefore the most preferred way to handle errors in promises is to chain and to the promise call.\n\nthrow/catch vs onerror() vs Callbacks vs Promises: Which is the Best?\n\nWith four methods at your disposal, you must know how to choose the most appropriate in any given use case. Here’s how you can decide for yourselves:\n\nYou will be using this method most of the time. Make sure to implement conditions for all possible errors inside your catch block, and remember to include a finally block if you need to run some memory clean-up routines after the try block.\n\nHowever, too many try/catch blocks can make your code difficult to maintain. If you find yourself in such a situation, you might want to handle errors via the global handler or the promise method.\n\nWhen deciding between asynchronous try/catch blocks and promise’s , it’s advisable to go with the async try/catch blocks since they will make your code linear and easy to debug.\n\nIt’s best to use the method when you know that your app has to handle many errors, and they can be well-scattered throughout the codebase. The method enables you to handle errors as if they were just another event handled by your application. You can define multiple error handlers and attach them to your app’s window on the initial rendering.\n\nHowever, you must also remember that the method can be unnecessarily challenging to set up in smaller projects with a lesser scope of error. If you’re sure that your app will not throw too many errors, the traditional throw/catch method will work best for you.\n\nError handling in callbacks and promises differs due to their code design and structure. However, if you choose between these two before you have written your code, it would be best to go with promises.\n\nThis is because promises have an inbuilt construct for chaining a and a block to handle errors easily. This method is easier and cleaner than defining additional arguments/reusing existing arguments to handle errors.\n\nKeep Track of Changes With Git Repositories\n\nMany errors often arise due to manual mistakes in the codebase. While developing or debugging your code, you might end up making unnecessary changes that may cause new errors to appear in your codebase. Automated testing is a great way to keep your code in check after every change. However, it can only tell you if something’s wrong. If you don’t take frequent backups of your code, you’ll end up wasting time trying to fix a function or a script that was working just fine before.\n\nThis is where git plays its role. With a proper commit strategy, you can use your git history as a backup system to view your code as it evolved through the development. You can easily browse through your older commits and find out the version of the function working fine before but throwing errors after an unrelated change.\n\nYou can then restore the old code or compare the two versions to determine what went wrong. Modern web development tools like GitHub Desktop or GitKraken help you to visualize these changes side by side and figure out the mistakes quickly.\n\nA habit that can help you make fewer errors is running code reviews whenever you make a significant change to your code. If you’re working in a team, you can create a pull request and have a team member review it thoroughly. This will help you use a second pair of eyes to spot out any errors that might have slipped by you.\n\nBest Practices for Handling Errors in JavaScript\n\nThe above-mentioned methods are adequate to help you design a robust error handling approach for your next JavaScript application. However, it would be best to keep a few things in mind while implementing them to get the best out of your error-proofing. Here are some tips to help you.\n\nWe introduced custom errors early in this guide to give you an idea of how to customize the error handling to your application’s unique case. It’s advisable to use custom errors wherever possible instead of the generic class as it provides more contextual information to the calling environment about the error.\n\nOn top of that, custom errors allow you to moderate how an error is displayed to the calling environment. This means that you can choose to hide specific details or display additional information about the error as and when you wish.\n\nYou can go so far as to format the error contents according to your needs. This gives you better control over how the error is interpreted and handled.\n\n2. Do Not Swallow Any Exceptions\n\nEven the most senior developers often make a rookie mistake — consuming exceptions levels deep down in their code.\n\nYou might come across situations where you have a piece of code that is optional to run. If it works, great; if it doesn’t, you don’t need to do anything about it.\n\nIn these cases, it’s often tempting to put this code in a try block and attach an empty catch block to it. However, by doing this, you’ll leave that piece of code open to causing any kind of error and getting away with it. This can become dangerous if you have a large codebase and many instances of such poor error management constructs.\n\nThe best way to handle exceptions is to determine a level on which all of them will be dealt and raise them until there. This level can be a controller (in an MVC architecture app) or a middleware (in a traditional server-oriented app).\n\nThis way, you’ll get to know where you can find all the errors occurring in your app and choose how to resolve them, even if it means not doing anything about them.\n\n3. Use a Centralized Strategy for Logs and Error Alerts\n\nLogging an error is often an integral part of handling it. Those who fail to develop a centralized strategy for logging errors may miss out on valuable information about their app’s usage.\n\nAn app’s event logs can help you figure out crucial data about errors and help to debug them quickly. If you have proper alerting mechanisms set up in your app, you can know when an error occurs in your app before it reaches a large section of your user base.\n\nIt’s advisable to use a pre-built logger or create one to suit your needs. You can configure this logger to handle errors based on their levels (warning, debug, info, etc.), and some loggers even go so far as to send logs to remote logging servers immediately. This way, you can watch how your application’s logic performs with active users.\n\nAnother good point to keep in mind while defining your error handling strategy is to keep the user in mind.\n\nAll errors that interfere with the normal functioning of your app must present a visible alert to the user to notify them that something went wrong so the user can try to work out a solution. If you know a quick fix for the error, such as retrying an operation or logging out and logging back in, make sure to mention it in the alert to help fix the user experience in real-time.\n\nIn the case of errors that don’t cause any interference with the everyday user experience, you can consider suppressing the alert and logging the error to a remote server for resolving later.\n\nThe Node.js environment supports middlewares to add functionalities to server applications. You can use this feature to create an error-handling middleware for your server.\n\nThe most significant benefit of using middleware is that all of your errors are handled centrally in one place. You can choose to enable/disable this setup for testing purposes easily.\n\nHere’s how you can create a basic middleware:\n\nYou can then use this middleware in your app like this:\n\nYou can now define custom logic inside the middleware to handle errors appropriately. You don’t need to worry about implementing individual error handling constructs throughout your codebase anymore.\n\nWhen Node.js apps encounter programmer errors, they might not necessarily throw an exception and try to close the app. Such errors can include issues arising from programmer mistakes, like high CPU consumption, memory bloating, or memory leaks. The best way to handle these is to gracefully restart the app by crashing it via the Node.js cluster mode or a unique tool like PM2. This can ensure that the app doesn’t crash upon user action, presenting a terrible user experience.\n\nYou can never be sure that you have covered every possible error that can occur in your app. Therefore, it’s essential to implement a fallback strategy to catch all uncaught exceptions from your app.\n\nHere’s how you can do that:\n\nYou can also identify if the error that occurred is a standard exception or a custom operational error. Based on the result, you can exit the process and restart it to avoid unexpected behavior.\n\nSimilar to how you can never cover for all possible exceptions, there’s a high chance that you might miss out on handling all possible promise rejections. However, unlike exceptions, promise rejections don’t throw errors.\n\nSo, an important promise that was rejected might slip by as a warning and leave your app open to the possibility of running into unexpected behavior. Therefore, it’s crucial to implement a fallback mechanism for handling promise rejection.\n\nHere’s how you can do that:\n\nLike any other programming language, errors are quite frequent and natural in JavaScript. In some cases, you might even need to throw errors intentionally to indicate the correct response to your users. Hence, understanding their anatomy and types is very crucial.\n\nMoreover, you need to be equipped with the right tools and techniques to identify and prevent errors from taking down your application.\n\nIn most cases, a solid strategy to handle errors with careful execution is enough for all types of JavaScript applications.\n\nAre there any other JavaScript errors that you still haven’t been able to resolve? Any techniques for handling JS errors constructively? Let us know in the comments below!"
    }
]