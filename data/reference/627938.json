[
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/lang/String.html",
        "document": "\n• Returns the length of this string. The length is equal to the number of Unicode code units in the string. the length of the sequence of characters represented by this object.\n• if, and only if, . Returnsif, and only if, is if is , otherwise\n• value at the specified index. An index ranges from to . The first value of the sequence is at index , the next at index , and so on, as for array indexing. Returns thevalue at the specified index. An index ranges fromto. The firstvalue of the sequence is at index, the next at index, and so on, as for array indexing. If the value specified by the index is a surrogate, the surrogate value is returned. - the index of the value. the value at the specified index of this string. The first value is at index . - if the argument is negative or not less than the length of this string.\n• values (Unicode code units) and ranges from to . Returns the character (Unicode code point) at the specified index. The index refers tovalues (Unicode code units) and ranges fromto If the value specified at the given index is in the high-surrogate range, the following index is less than the length of this , and the value at the following index is in the low-surrogate range, then the supplementary code point corresponding to this surrogate pair is returned. Otherwise, the value at the given index is returned. - the index to the values the code point value of the character at the - if the argument is negative or not less than the length of this string.\n• values (Unicode code units) and ranges from to Returns the character (Unicode code point) before the specified index. The index refers tovalues (Unicode code units) and ranges fromto If the value at is in the low-surrogate range, is not negative, and the value at is in the high-surrogate range, then the supplementary code point value of the surrogate pair is returned. If the value at is an unpaired low-surrogate or a high-surrogate, the surrogate value is returned. - the index following the code point that should be returned the Unicode code point value before the given index. - if the argument is less than 1 or greater than the length of this string.\n• Returns the number of Unicode code points in the specified text range of this . The text range begins at the specified and extends to the at index . Thus the length (in s) of the text range is . Unpaired surrogates within the text range count as one code point each. - the index to the first of the text range. - the index after the last of the text range. the number of Unicode code points in the specified text range - if the is negative, or is larger than the length of this , or is larger than .\n• Returns the index within this that is offset from the given by code points. Unpaired surrogates within the text range given by and count as one code point each. - the index to be offset the index within this - if is negative or larger then the length of this , or if is positive and the substring starting with has fewer than code points, or if is negative and the substring before has fewer than the absolute value of code points.\n• Copies characters from this string into the destination character array. The first character to be copied is at index ; the last character to be copied is at index (thus the total number of characters to be copied is ). The characters are copied into the subarray of starting at index and ending at index: - index of the first character in the string to copy. - index after the last character in the string to copy. - the start offset in the destination array. - If any of the following is true:\n• is greater than the length of this string\n• Copies characters from this string into the destination byte array. Each byte receives the 8 low-order bits of the corresponding character. The eight high-order bits of each character are not copied and do not participate in the transfer in any way. The first character to be copied is at index ; the last character to be copied is at index . The total number of characters to be copied is . The characters, converted to bytes, are copied into the subarray of starting at index and ending at index: - Index of the first character in the string to copy - Index after the last character in the string to copy - The start offset in the destination array - If any of the following is true:\n• is greater than the length of this String\n• into a sequence of bytes using the named charset, storing the result into a new byte array. Encodes thisinto a sequence of bytes using the named charset, storing the result into a new byte array. The behavior of this method when this string cannot be encoded in the given charset is unspecified. The class should be used when more control over the encoding process is required. - The name of a supported charset - If the named charset is not supported\n• into a sequence of bytes using the given Encodes thisinto a sequence of bytes using the given charset , storing the result into a new byte array. This method always replaces malformed-input and unmappable-character sequences with this charset's default replacement byte array. The class should be used when more control over the encoding process is required. - The Charset to be used to encode the\n• into a sequence of bytes using the platform's default charset, storing the result into a new byte array. Encodes thisinto a sequence of bytes using the platform's default charset, storing the result into a new byte array. The behavior of this method when this string cannot be encoded in the default charset is unspecified. The class should be used when more control over the encoding process is required.\n• Compares this string to the specified object. The result is if and only if the argument is not and is a object that represents the same sequence of characters as this object. - The object to compare this against if the given object represents a equivalent to this string, otherwise\n• Compares this string to the specified . The result is if and only if this represents the same sequence of characters as the specified . This method synchronizes on the . - The to compare this against if this represents the same sequence of characters as the specified , otherwise\n• Compares this string to the specified . The result is if and only if this represents the same sequence of char values as the specified sequence. Note that if the is a then the method synchronizes on it. - The sequence to compare this against if this represents the same sequence of char values as the specified sequence, otherwise\n• to another , ignoring case considerations. Two strings are considered equal ignoring case if they are of the same length and corresponding characters in the two strings are equal ignoring case. Compares thisto another, ignoring case considerations. Two strings are considered equal ignoring case if they are of the same length and corresponding characters in the two strings are equal ignoring case. Two characters and are considered the same ignoring case if at least one of the following is true:\n• The two characters are the same (as compared by the operator)\n• Applying the method to each character produces the same result\n• Applying the method to each character produces the same result - The to compare this against if the argument is not and it represents an equivalent ignoring case; otherwise\n• object is compared lexicographically to the character sequence represented by the argument string. The result is a negative integer if this object lexicographically precedes the argument string. The result is a positive integer if this object lexicographically follows the argument string. The result is zero if the strings are equal; returns exactly when the . Compares two strings lexicographically. The comparison is based on the Unicode value of each character in the strings. The character sequence represented by thisobject is compared lexicographically to the character sequence represented by the argument string. The result is a negative integer if thisobject lexicographically precedes the argument string. The result is a positive integer if thisobject lexicographically follows the argument string. The result is zero if the strings are equal;returnsexactly when the method would return This is the definition of lexicographic ordering. If two strings are different, then either they have different characters at some index that is a valid index for both strings, or their lengths are different, or both. If they have different characters at one or more index positions, let k be the smallest such index; then the string whose character at position k has the smaller value, as determined by using the < operator, lexicographically precedes the other string. In this case, returns the difference of the two character values at position in the two string -- that is, the value: If there is no index position at which they differ, then the shorter string lexicographically precedes the longer string. In this case, returns the difference of the lengths of the strings -- that is, the value: If there is no index position at which they differ, then the shorter string lexicographically precedes the longer string. In this case,returns the difference of the lengths of the strings -- that is, the value: - the to be compared. the value if the argument string is equal to this string; a value less than if this string is lexicographically less than the string argument; and a value greater than if this string is lexicographically greater than the string argument.\n• with normalized versions of the strings where case differences have been eliminated by calling on each character. Compares two strings lexicographically, ignoring case differences. This method returns an integer whose sign is that of callingwith normalized versions of the strings where case differences have been eliminated by callingon each character. Note that this method does not take locale into account, and will result in an unsatisfactory ordering for certain locales. The java.text package provides collators to allow locale-sensitive ordering. - the to be compared. a negative integer, zero, or a positive integer as the specified String is greater than, equal to, or less than this String, ignoring case considerations.\n• Tests if two string regions are equal. A substring of this object is compared to a substring of the argument other. The result is true if these substrings represent identical character sequences. The substring of this object to be compared begins at index and has length . The substring of other to be compared begins at index and has length . The result is if and only if at least one of the following is true:\n• is greater than the length of this object.\n• is greater than the length of the other argument.\n• There is some nonnegative integer k less than such that: k k - the starting offset of the subregion in this string. - the starting offset of the subregion in the string argument. - the number of characters to compare. if the specified subregion of this string exactly matches the specified subregion of the string argument; otherwise.\n• Tests if two string regions are equal. A substring of this object is compared to a substring of the argument . The result is if these substrings represent character sequences that are the same, ignoring case if and only if is true. The substring of this object to be compared begins at index and has length . The substring of to be compared begins at index and has length . The result is if and only if at least one of the following is true:\n• is greater than the length of this object.\n• is greater than the length of the other argument.\n• is and there is some nonnegative integer k less than such that:\n• is and there is some nonnegative integer k less than such that: and: - the starting offset of the subregion in this string. - the starting offset of the subregion in the string argument. - the number of characters to compare. if the specified subregion of this string matches the specified subregion of the string argument; otherwise. Whether the matching is exact or case insensitive depends on the argument.\n• Tests if the substring of this string beginning at the specified index starts with the specified prefix. - where to begin looking in this string. if the character sequence represented by the argument is a prefix of the substring of this object starting at index ; otherwise. The result is if is negative or greater than the length of this object; otherwise the result is the same as the result of the expression\n• Tests if this string starts with the specified prefix. if the character sequence represented by the argument is a prefix of the character sequence represented by this string; otherwise. Note also that will be returned if the argument is an empty string or is equal to this object as determined by the method.\n• Tests if this string ends with the specified suffix. if the character sequence represented by the argument is a suffix of the character sequence represented by this object; otherwise. Note that the result will be if the argument is the empty string or is equal to this object as determined by the method.\n• object is computed as using arithmetic, where is the ith character of the string, is the length of the string, and indicates exponentiation. (The hash value of the empty string is zero.) Returns a hash code for this string. The hash code for aobject is computed asusingarithmetic, whereis theth character of the string,is the length of the string, andindicates exponentiation. (The hash value of the empty string is zero.) a hash code value for this object.\n• occurs in the character sequence represented by this object, then the index (in Unicode code units) of the first such occurrence is returned. For values of in the range from 0 to 0xFFFF (inclusive), this is the smallest value k such that: is true. For other values of , it is the smallest value k such that: is true. In either case, if no such character occurs in this string, then is returned. Returns the index within this string of the first occurrence of the specified character. If a character with valueoccurs in the character sequence represented by thisobject, then the index (in Unicode code units) of the first such occurrence is returned. For values ofin the range from 0 to 0xFFFF (inclusive), this is the smallest valuesuch that:is true. For other values of, it is the smallest valuesuch that:is true. In either case, if no such character occurs in this string, thenis returned. the index of the first occurrence of the character in the character sequence represented by this object, or if the character does not occur.\n• Returns the index within this string of the first occurrence of the specified character, starting the search at the specified index. If a character with value occurs in the character sequence represented by this object at an index no smaller than , then the index of the first such occurrence is returned. For values of in the range from 0 to 0xFFFF (inclusive), this is the smallest value k such that: is true. For other values of , it is the smallest value k such that: is true. In either case, if no such character occurs in this string at or after position , then is returned. is true. For other values of, it is the smallest valuesuch that:is true. In either case, if no such character occurs in this string at or after position, thenis returned. There is no restriction on the value of . If it is negative, it has the same effect as if it were zero: this entire string may be searched. If it is greater than the length of this string, it has the same effect as if it were equal to the length of this string: is returned. All indices are specified in values (Unicode code units). - the index to start the search from. the index of the first occurrence of the character in the character sequence represented by this object that is greater than or equal to , or if the character does not occur.\n• in the range from 0 to 0xFFFF (inclusive), the index (in Unicode code units) returned is the largest value k such that: is true. For other values of , it is the largest value k such that: is true. In either case, if no such character occurs in this string, then is returned. The is searched backwards starting at the last character. Returns the index within this string of the last occurrence of the specified character. For values ofin the range from 0 to 0xFFFF (inclusive), the index (in Unicode code units) returned is the largest valuesuch that:is true. For other values of, it is the largest valuesuch that:is true. In either case, if no such character occurs in this string, thenis returned. Theis searched backwards starting at the last character. the index of the last occurrence of the character in the character sequence represented by this object, or if the character does not occur.\n• in the range from 0 to 0xFFFF (inclusive), the index returned is the largest value k such that: is true. For other values of , it is the largest value k such that: is true. In either case, if no such character occurs in this string at or before position , then is returned. Returns the index within this string of the last occurrence of the specified character, searching backward starting at the specified index. For values ofin the range from 0 to 0xFFFF (inclusive), the index returned is the largest valuesuch that:is true. For other values of, it is the largest valuesuch that:is true. In either case, if no such character occurs in this string at or before position, thenis returned. All indices are specified in values (Unicode code units). - the index to start the search from. There is no restriction on the value of . If it is greater than or equal to the length of this string, it has the same effect as if it were equal to one less than the length of this string: this entire string may be searched. If it is negative, it has the same effect as if it were -1: -1 is returned. the index of the last occurrence of the character in the character sequence represented by this object that is less than or equal to , or if the character does not occur before that point.\n• Returns the index within this string of the first occurrence of the specified substring. The returned index is the smallest value k for which: If no such value of k exists, then is returned. If no such value ofexists, thenis returned. - the substring to search for. the index of the first occurrence of the specified substring, or if there is no such occurrence.\n• Returns the index within this string of the first occurrence of the specified substring, starting at the specified index. The returned index is the smallest value k for which: If no such value of k exists, then is returned. If no such value ofexists, thenis returned. - the substring to search for. - the index from which to start the search. the index of the first occurrence of the specified substring, starting at the specified index, or if there is no such occurrence.\n• . Returns the index within this string of the last occurrence of the specified substring. The last occurrence of the empty string \"\" is considered to occur at the index value The returned index is the largest value k for which: If no such value of k exists, then is returned. If no such value ofexists, thenis returned. - the substring to search for. the index of the last occurrence of the specified substring, or if there is no such occurrence.\n• Returns the index within this string of the last occurrence of the specified substring, searching backward starting at the specified index. The returned index is the largest value k for which: If no such value of k exists, then is returned. If no such value ofexists, thenis returned. - the substring to search for. - the index to start the search from. the index of the last occurrence of the specified substring, searching backward from the specified index, or if there is no such occurrence.\n• Returns a string that is a substring of this string. The substring begins with the character at the specified index and extends to the end of this string. - if is negative or larger than the length of this object.\n• and extends to the character at index . Thus the length of the substring is . Returns a string that is a substring of this string. The substring begins at the specifiedand extends to the character at index. Thus the length of the substring is - if the is negative, or is larger than the length of this object, or is larger than .\n• Returns a character sequence that is a subsequence of this sequence. An invocation of this method of the form behaves in exactly the same way as the invocation behaves in exactly the same way as the invocation This method is defined so that the class can implement the interface. - if or is negative, if is greater than , or if is greater than\n• Concatenates the specified string to the end of this string. If the length of the argument string is , then this object is returned. Otherwise, a object is returned that represents a character sequence that is the concatenation of the character sequence represented by this object and the character sequence represented by the argument string. - the that is concatenated to the end of this . a string that represents the concatenation of this object's characters followed by the string argument's characters.\n• in this string with . Returns a string resulting from replacing all occurrences ofin this string with If the character does not occur in the character sequence represented by this object, then a reference to this object is returned. Otherwise, a object is returned that represents a character sequence identical to the character sequence represented by this object, except that every occurrence of is replaced by an occurrence of . \"mesquite in your cellar\".replace('e', 'o') returns \"mosquito in your collar\" \"the war of baronets\".replace('r', 'y') returns \"the way of bayonets\" \"sparring with a purple porpoise\".replace('p', 't') returns \"starring with a turtle tortoise\" \"JonL\".replace('q', 'x') returns \"JonL\" (no change) a string derived from this string by replacing every occurrence of with .\n• Tells whether or not this string matches the given regular expression An invocation of this method of the form str regex yields exactly the same result as the expression - the regular expression to which this string is to be matched if, and only if, this string matches the given regular expression - if the regular expression's syntax is invalid\n• Returns true if and only if this string contains the specified sequence of char values. - the sequence to search for true if this string contains , false otherwise\n• Replaces the first substring of this string that matches the given regular expression with the given replacement. An invocation of this method of the form str regex repl yields exactly the same result as the expression Note that backslashes ( ) and dollar signs ( ) in the replacement string may cause the results to be different than if it were being treated as a literal replacement string; see . Use to suppress the special meaning of these characters, if desired. - the regular expression to which this string is to be matched - the string to be substituted for the first match - if the regular expression's syntax is invalid\n• Replaces each substring of this string that matches the given regular expression with the given replacement. An invocation of this method of the form str regex repl yields exactly the same result as the expression Note that backslashes ( ) and dollar signs ( ) in the replacement string may cause the results to be different than if it were being treated as a literal replacement string; see . Use to suppress the special meaning of these characters, if desired. - the regular expression to which this string is to be matched - the string to be substituted for each match - if the regular expression's syntax is invalid\n• Replaces each substring of this string that matches the literal target sequence with the specified literal replacement sequence. The replacement proceeds from the beginning of the string to the end, for example, replacing \"aa\" with \"b\" in the string \"aaa\" will result in \"ba\" rather than \"ab\". - The sequence of char values to be replaced\n• Splits this string around matches of the given regular expression The array returned by this method contains each substring of this string that is terminated by another substring that matches the given expression or is terminated by the end of the string. The substrings in the array are in the order in which they occur in this string. If the expression does not match any part of the input then the resulting array has just one element, namely this string. When there is a positive-width match at the beginning of this string then an empty leading substring is included at the beginning of the resulting array. A zero-width match at the beginning however never produces such empty leading substring. The parameter controls the number of times the pattern is applied and therefore affects the length of the resulting array. If the limit n is greater than zero then the pattern will be applied at most n - 1 times, the array's length will be no greater than n, and the array's last entry will contain all input beyond the last matched delimiter. If n is non-positive then the pattern will be applied as many times as possible and the array can have any length. If n is zero then the pattern will be applied as many times as possible, the array can have any length, and trailing empty strings will be discarded. The string , for example, yields the following results with these parameters: An invocation of this method of the form str. regex n yields the same result as the expression - the result threshold, as described above the array of strings computed by splitting this string around matches of the given regular expression - if the regular expression's syntax is invalid\n• Splits this string around matches of the given regular expression This method works as if by invoking the two-argument method with the given expression and a limit argument of zero. Trailing empty strings are therefore not included in the resulting array. The string , for example, yields the following results with these expressions: the array of strings computed by splitting this string around matches of the given regular expression - if the regular expression's syntax is invalid\n• joined together with a copy of the specified . Note that if an element is null, then is added. Returns a new String composed of copies of thejoined together with a copy of the specifiedNote that if an element is null, thenis added. - the delimiter that separates each element - the elements to join together. a new that is composed of the separated by the - If or is\n• composed of copies of the joined together with a copy of the specified . For example, List<String> strings = new LinkedList<>(); strings.add(\"Java\");strings.add(\"is\"); strings.add(\"cool\"); String message = String.join(\" \", strings); //message returned is: \"Java is cool\" Set<String> strings = new LinkedHashSet<>(); strings.add(\"Java\"); strings.add(\"is\"); strings.add(\"very\"); strings.add(\"cool\"); String message = String.join(\"-\", strings); //message returned is: \"Java-is-very-cool\" Note that if an individual element is , then is added. Returns a newcomposed of copies of thejoined together with a copy of the specifiedNote that if an individual element is, thenis added. - a sequence of characters that is used to separate each of the in the resulting - an that will have its joined together. a new that is composed from the argument - If or is\n• to lower case using the rules of the given . Case mapping is based on the Unicode Standard version specified by the may be a different length than the original . Converts all of the characters in thisto lower case using the rules of the given. Case mapping is based on the Unicode Standard version specified by the class. Since case mappings are not always 1:1 char mappings, the resultingmay be a different length than the original Examples of lowercase mappings are in the following table: - use the case transformation rules for this locale\n• to lower case using the rules of the default locale. This is equivalent to calling . Converts all of the characters in thisto lower case using the rules of the default locale. This is equivalent to calling Note: This method is locale sensitive, and may produce unexpected results if used for strings that are intended to be interpreted locale independently. Examples are programming language identifiers, protocol keys, and HTML tags. For instance, in a Turkish locale returns , where '\\u0131' is the LATIN SMALL LETTER DOTLESS I character. To obtain correct results for locale insensitive strings, use .\n• to upper case using the rules of the given . Case mapping is based on the Unicode Standard version specified by the may be a different length than the original . Converts all of the characters in thisto upper case using the rules of the given. Case mapping is based on the Unicode Standard version specified by the class. Since case mappings are not always 1:1 char mappings, the resultingmay be a different length than the original Examples of locale-sensitive and 1:M case mappings are in the following table. - use the case transformation rules for this locale\n• to upper case using the rules of the default locale. This method is equivalent to . Converts all of the characters in thisto upper case using the rules of the default locale. This method is equivalent to Note: This method is locale sensitive, and may produce unexpected results if used for strings that are intended to be interpreted locale independently. Examples are programming language identifiers, protocol keys, and HTML tags. For instance, in a Turkish locale returns , where '\\u0130' is the LATIN CAPITAL LETTER I WITH DOT ABOVE character. To obtain correct results for locale insensitive strings, use .\n• Returns a string whose value is this string, with any leading and trailing whitespace removed. If this object represents an empty character sequence, or the first and last characters of character sequence represented by this object both have codes greater than (the space character), then a reference to this object is returned. Otherwise, if there is no character with a code greater than in the string, then a object representing an empty string is returned. Otherwise, let k be the index of the first character in the string whose code is greater than , and let m be the index of the last character in the string whose code is greater than . A object is returned, representing the substring of this string that begins with the character at index k and ends with the character at index m-that is, the result of . This method may be used to trim whitespace (as defined above) from the beginning and end of a string. A string whose value is this string, with any leading and trailing white space removed, or this string if it has no leading or trailing white space.\n• This object (which is already a string!) is itself returned.\n• Converts this string to a new character array. a newly allocated character array whose length is the length of this string and whose contents are initialized to contain the character sequence represented by this string.\n• Returns a formatted string using the specified format string and arguments. The locale always used is the one returned by . - Arguments referenced by the format specifiers in the format string. If there are more arguments than format specifiers, the extra arguments are ignored. The number of arguments is variable and may be zero. The maximum number of arguments is limited by the maximum dimension of a Java array as defined by . The behaviour on a argument depends on the conversion. - If a format string contains an illegal syntax, a format specifier that is incompatible with the given arguments, insufficient arguments given the format string, or other illegal conditions. For specification of all possible formatting errors, see the Details section of the formatter class specification.\n• Returns a formatted string using the specified locale, format string, and arguments. - The locale to apply during formatting. If is then no localization is applied. - Arguments referenced by the format specifiers in the format string. If there are more arguments than format specifiers, the extra arguments are ignored. The number of arguments is variable and may be zero. The maximum number of arguments is limited by the maximum dimension of a Java array as defined by . The behaviour on a argument depends on the conversion. - If a format string contains an illegal syntax, a format specifier that is incompatible with the given arguments, insufficient arguments given the format string, or other illegal conditions. For specification of all possible formatting errors, see the Details section of the formatter class specification\n• Returns the string representation of the argument. if the argument is , then a string equal to ; otherwise, the value of is returned.\n• Returns the string representation of the array argument. The contents of the character array are copied; subsequent modification of the character array does not affect the returned string. a that contains the characters of the character array.\n• array argument. Returns the string representation of a specific subarray of thearray argument. The argument is the index of the first character of the subarray. The argument specifies the length of the subarray. The contents of the subarray are copied; subsequent modification of the character array does not affect the returned string. a that contains the characters of the specified subarray of the character array. - if is negative, or is negative, or is larger than .\n• a that contains the characters of the specified subarray of the character array. - if is negative, or is negative, or is larger than .\n• a that contains the characters of the character array.\n• Returns the string representation of the argument. if the argument is , a string equal to is returned; otherwise, a string equal to is returned.\n• Returns the string representation of the argument. a string of length containing as its single character the argument .\n• argument. The representation is exactly the one returned by the method of one argument.\n• argument. The representation is exactly the one returned by the method of one argument.\n• argument. The representation is exactly the one returned by the method of one argument.\n• argument. The representation is exactly the one returned by the method of one argument.\n• A pool of strings, initially empty, is maintained privately by the class . When the intern method is invoked, if the pool already contains a string equal to this object as determined by the method, then the string from the pool is returned. Otherwise, this object is added to the pool and a reference to this object is returned. It follows that for any two strings and , is if and only if is . All literal strings and string-valued constant expressions are interned. String literals are defined in section 3.10.5 of the . a string that has the same contents as this string, but is guaranteed to be from a pool of unique strings."
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api?java/lang/String.html",
        "document": "JavaScript is disabled on your browser.\n\nThis document is designed to be viewed using the frames feature. If you see this message, you are using a non-frame-capable web client. Link to Non-frame version."
    },
    {
        "link": "https://stackoverflow.com/questions/31450073/can-anybody-explain-me-how-the-contains-method-work-in-string-class",
        "document": "is an interface, and so can accept anything that implements that interface. One of the classes that implements it is , but there are others as well.\n\ndefines a method, , which converts the character sequence to a .\n\ndefines an method that accepts a substring and tells you whether it's in the string by returning the index at which it appears in the string. It returns -1 if the substring isn't in the string.\n\nSo tells you whether the string contains the substring defined by the ."
    },
    {
        "link": "https://w3schools.com/java/ref_string_contains.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://cs.usfca.edu/~cs272/javadoc/api/java.base/java/lang/String.html",
        "document": ""
    },
    {
        "link": "https://runestone.academy/ns/books/published/csawesome/Unit6-Arrays/topic-6-3-arrays-with-foreach.html",
        "document": "There is a special kind of loop that can be used with arrays that is called an enhanced for loop or a for each loop. This loop is much easier to write because it does not involve an index variable or the use of the []. It just sets up a variable that is set to each value in the array successively.\n\nTo set up a for-each loop, use for (type variable : arrayname) where the type is the type for elements in the array, and read it as “for each variable value in arrayname”. You may have used a similar loop in AP CSP Pseudocode or App Inventor with lists like below.\n\nSee the examples below in Java that loop through an int and a String array. Notice the type of the loop variable is the type of the array.\n\nUse the enhanced for each loop with arrays whenever you can, because it cuts down on errors. You can use it whenever you need to loop through all the elements of an array and don’t need to know their index and don’t need to change their values. It starts with the first item in the array (the one at index 0) and continues through in order to the last item in the array. This type of loop can only be used with arrays and some other collections of items like ArrayLists which we will see in the next unit.\n\nWhat if we had a loop that incremented all the elements in the array. Would that work with an enhanced for-each loop? Unfortunately not! Because only the variable in the loop changes, not the real array values. We would need an indexed loop to modify array elements. Try it in the Active Code below or in the Java visualizer by clicking the CodeLens button and step through the code to see why it doesn’t work. The for-each loop below cannot change the values in the array because only the loop variable value will change. Run it with the CodeLens button to see why this is. Then, change the loop to an indexed for loop to make it change the array values. public class IncrementLoop { public static void main(String[] args) { int[] values = {6, 2, 1, 7, 12, 5}; // Can this loop increment the values? for (int val : values) { val++; System.out.println(\"New val: \" + val); } // Print out array to see if they really changed System.out.println(\"Array after the loop: \"); for (int v : values) { System.out.print(v + \" \"); } } } ==== // Test for Lesson 6.3.3 - IncrementLoop import static org.junit.Assert.*; import org.junit.*; import java.io.*; public class RunestoneTests extends CodeTestHelper { public RunestoneTests() { super(\"IncrementLoop\"); } @Test public void test1() { String output = getMethodOutput(\"main\"); String expect = \"New val: 7\n\n\" + \"New val: 3\n\n\" + \"New val: 2\n\n\" + \"New val: 8\n\n\" + \"New val: 13\n\n\" + \"New val: 6\n\n\" + \"Array after the loop:\n\n\" + \"7 3 2 8 13 6\"; boolean passed = getResults(expect, output, \"main()\"); assertTrue(passed); } @Test public void test2() { String target = \"for (int * = #; * ? *.length; *~)\"; boolean passed = checkCodeContains(\"for loop\", target); assertTrue(passed); } } Enhanced for each loops cannot be used in all situations. Only use for-each loops when you want to loop through all the values in an array without changing their values.\n• None Do not use for each loops if you need the index.\n• None Do not use for each loops if you need to change the values in the array.\n• None Do not use for each loops if you want to loop through only part of an array or in a different order. 6-3-4: What are some of the reasons you would use an enhanced for-each loop instead of a for loop?\n• This style of loop does access every element of the array, but using a for-each loop also means the user can access elements through the variable name.\n• Correct! For-each loops access all elements and enable users to use a variable name to refer to array elements, but do not allow users to modify elements directly.\n• For-each loops, as well as allowing users to refer to array elements, run through every element. For-each loops also do not allow users to modify elements directly.\n• All of the Above.\n• For-each loops access all of an array's elements and allow users to refer to elements through a variable, but do not allow users to modify elements directly. 6-3-5: What is the output of the following code segment?\n• The array is unchanged because the foreach loop cannot modify the array elements.\n• Remember that the foreach loop cannot modify the array elements, but it also uses multiplication, not addition.\n• Remember that the foreach loop cannot modify the array elements. Only the variable num will be doubled, not the original array values.\n• None The code will not compile.\n\nHere is an object-oriented example that has the array as a private instance variable in the class and provides a public method average that uses a for-each loop. You can use the Java visualizer or the Code Lens button to step through this code. public class ArrayWorker { private int[] values; public ArrayWorker(int[] theValues) { values = theValues; } public double getAverage() { double total = 0; for (int val : values) { total = total + val; } return total / values.length; } public static void main(String[] args) { int[] numArray = {2, 6, 7, 12, 5}; ArrayWorker aWorker = new ArrayWorker(numArray); System.out.println(aWorker.getAverage()); } } ==== // Test for Lesson 6.3.3 - IncrementLoop import static org.junit.Assert.*; import org.junit.*; import java.io.*; public class RunestoneTests extends CodeTestHelper { public RunestoneTests() { super(\"ArrayWorker\"); } @Test public void test1() { String output = getMethodOutput(\"main\"); String expect = \"6.4\"; boolean passed = getResults(expect, output, \"main()\", true); assertTrue(passed); } } The following method has the correct code to return the largest value in an integer array called (an instance variable of the current object), but the code is mixed up. Drag the blocks from the left into the correct order on the right and indent them correctly as well. You will be told if any of the blocks are in the wrong order or not indented correctly. public int getLargest() { --- int largest = vals[0]; --- for (int item : vals) { --- if (item > largest) { --- largest = item; --- } // end if --- } // end for return largest; --- } // end method If you want to step through the correct code to see what it does in the Java Visualizer click on the following Java visualizer link. 6-3-8: Given that is an array of integers and is an integer value, which of the following best describes the conditions under which the following code segment will return true?\n• Whenever the first element in array is equal to target.\n• This would be true if the loop started at the end of the array and moved toward the beginning. But, it will loop from the first element to the last.\n• Whenever array contains any element which equals target.\n• This would be true if temp was only set to the result of checking if the current element in the array is equal to target when it is false. But, it is reset each time through the loop.\n• Whenever the last element in array is equal to target.\n• The variable temp is assigned to the result of checking if the current element in the array is equal to target. The last time through the loop it will check if the last element is equal to val.\n• Whenever only 1 element in array is equal to target.\n• There is no count of the number of times the array element is equal to target.\n\nIn the last lesson, you created a spellcheck method using a for loop. In this lesson, you will use enhanced for each loops instead.\n• None Write a new version of the method to use an enhanced for-each loop instead of an indexed for-loop. It should take a word as a parameter and return true if it is in the dictionary array. It should return false if it is not found.\n• None Write a method that takes a String array of words which represents sentence of text and then calls your method to check if each word in that text is spelled correctly. It should count and print out the misspelled words, and return the number of misspelled words. Some helper code is provided in the main method that will split a String of words into a String array, and remove punctuation and convert to lowercase, before calling this method. Write a spellcheck() method using an enhanced for-each loop that takes a word as a parameter and returns true if it is in the dictionary array. Return false if it is not found. Write a checkText() method that takes a String[] parameter which is a sentence of text and then calls your spellcheck method above to check if each word in that text is spelled correctly using an enhanced for-each loop. It should return a count of the misspelled words. import java.io.*; import java.nio.file.*; import java.util.*; public class SpellChecker { // This dictionary includes 10,000 English words read in from the dictionary // file private String[] dictionary = new String[10000]; /* Write a spellcheck() method using an enhanced for each loop * that takes a word as a parameter and returns true if it is * in the dictionary array. Return false if it is not found. */ /* Write a checkText() method that takes a String[] parameter which is a sentence * of text in a String array and then calls your spellcheck method above * to check if each word in that text is spelled correctly. * Use an enhanced for each loop. * It should count and print out the misspelled words, and return the count. */ // Do not change \"throws IOException\" which is needed for reading in the input // file public static void main(String[] args) throws IOException { SpellChecker checker = new SpellChecker(); /* // Uncomment to test your method String word = \"catz\"; System.out.println(word + \" is spelled correctly? \" + checker.spellcheck(word)); System.out.println(word + \" is spelled correctly? \" + checker.spellcheck(\"cat\")); // Testing checkText method String text = \"Catz are cool aminals!\"; // replace punctuation symbols with empty string text = text.replaceAll(\"\\\\p{Punct}\", \"\"); // convert to lowercase text = text.toLowerCase(); // split the text into a String array String[] words = text.split(\" \"); // Call your checkText method int numErrors = checker.checkText(words); System.out.println(\"There were \" + numErrors + \" spelling errors in \" + text); */ } // The constructor reads in the dictionary from a file public SpellChecker() throws IOException { // Let's use java.nio method readAllLines and convert to an array! List lines = Files.readAllLines(Paths.get(\"dictionary.txt\")); dictionary = lines.toArray(dictionary); /* The old java.io.* Scan/File method of reading in files, replaced by java.nio above // create File object File dictionaryFile = new File(\"dictionary.txt\"); //Create Scanner object to read File Scanner scan = new Scanner(dictionaryFile); // Reading each line of the file // and saving it in the array int i = 0; while(scan.hasNextLine()) { String line = scan.nextLine(); dictionary[i] = line; i++; } scan.close(); */ } } ==== // Test for challenge-6-3-spell-checker import static org.junit.Assert.*; import org.junit.*; import java.io.*; public class RunestoneTests extends CodeTestHelper { public RunestoneTests() { super(\"SpellChecker\"); } @Test public void testMain() throws IOException { String output = getMethodOutput(\"main\"); String[] lines = output.split(\"\\\\s+\"); boolean passed = lines.length >= 2; passed = getResults( \"2+ lines of output\", lines.length + \" lines of output\", \"Expected output\", passed); assertTrue(passed); } @Test public void test3() { Object[] args = {\"dogz\"}; String output = getMethodOutput(\"spellcheck\", args); String expect = \"false\"; boolean passed = getResults(expect, output, \"spellcheck(\\\"dogz\\\")\"); assertTrue(passed); } @Test public void test4() { Object[] args = {\"dog\"}; String output = getMethodOutput(\"spellcheck\", args); String expect = \"true\"; boolean passed = getResults( expect, output, \"spellcheck(\\\"dog\\\") (If false, spellcheck may be returning false too\" + \" soon!)\"); assertTrue(passed); } @Test public void testFor() throws IOException { String target = \"for (int * = #; * ? #; *~)\"; boolean passed = checkCodeNotContains(\"for loop\", target); assertTrue(passed); } @Test public void testForEach() { boolean passed = checkCodeContains(\"for each loop\", \"for(String * : dictionary)\"); assertTrue(passed); } @Test public void testSignature() { boolean passed = checkCodeContains( \"Signature public int checkText(String[])\", \"public int checkText(String[]\"); assertTrue(passed); } @Test public void testCheckText1() { String[] sentence = {\"dogz\", \"are\", \"cool\", \"tuu\"}; Object[] args = {sentence}; String output = getMethodOutput(\"checkText\", args); String expect = \"2\"; boolean passed = getResults( expect, output, \"number of spelling errors in checkText({\\\"dogz\\\",\" + \" \\\"are\\\",\\\"cool\\\",\\\"tuu\\\"})\"); assertTrue(passed); } @Test public void testCheckText2() { String[] sentence = {\"dogs\", \"are\", \"cool\", \"too\"}; Object[] args = {sentence}; String output = getMethodOutput(\"checkText\", args); String expect = \"0\"; boolean passed = getResults( expect, output, \"number of spelling errors in checkText({\\\"dogs\\\",\" + \" \\\"are\\\",\\\"cool\\\",\\\"too\\\"})\"); assertTrue(passed); } }\n\nDesign an Array of Objects for your Community¶ In Unit 5, you came up with a class of your own choice relevant to your community. In lessons 6.1 and 6.2, you created an array to hold objects of your class and traversed the array with a loop. In this challenge, we will create a new class that holds your array of objects and add a method that print the array elements and a method that finds a certain object in the array using enhanced for loops. We encourage you to continue working in pairs. Here is an example of a Student class and a StudentArray class that searches for a student with a specific name. In Java, when you are working with multiple classes on your own computer, each class is usually in its own file that matches the class name. On Runestone, when you are working with multiple classes, only the class that has the main method should be public, and the other classes should start with instead of . Run the StudentArray class below. Note that it uses the class Student below it and creates an array of Students. Using the StudentArray print() method as a guide, write a StudentArray method called findAndPrint() which takes a String name as an argument, and uses an enhanced for-loop to traverse the array to find a Student in the array with the same name. If the argument equals the Student object’s name (using its getName() method), then print out that student’s info. Call it from the main method to test it. public class StudentArray { private Student[] array; private int size = 3; // Creates an array of the default size public StudentArray() { array = new Student[size]; } // Creates aan array of the given size public StudentArray(int size) { array = new Student[size]; } // Adds Student s to the array at index i public void add(int i, Student s) { array[i] = s; } // prints the array of students public void print() { for (Student s : array) { // this will call Student's toString() method System.out.println(s); } } /* Write a findAndPrint(name) method */ public static void main(String[] args) { // Create an object of this class and pass in size 3 StudentArray roster = new StudentArray(3); // Add new Student objects at indices 0-2 roster.add(0, new Student(\"Skyler\", \"skyler@sky.com\", 123456)); roster.add(1, new Student(\"Ayanna\", \"ayanna@gmail.com\", 789012)); roster.add(2, new Student(\"Dakota\", \"dak@gmail.com\", 112233)); roster.print(); System.out.println(\"Finding student Ayanna: \"); // uncomment to test // roster.findAndPrint(\"Ayanna\"); } } class Student { private String name; private String email; private int id; public Student(String initName, String initEmail, int initId) { name = initName; email = initEmail; id = initId; } public String getName() { return name; } public String getEmail() { return email; } public int getId() { return id; } // toString() method public String toString() { return id + \": \" + name + \", \" + email; } } ==== import static org.junit.Assert.*; import org.junit.*; import java.io.*; public class RunestoneTests extends CodeTestHelper { public RunestoneTests() { super(\"StudentArray\"); } @Test public void test1() { String target = \"findAndPrint(String\"; boolean passed = checkCodeContains(\"findAndPrint method header with String paramenter\", target); assertTrue(passed); } @Test public void test2() { String target = \"roster.findAndPrint(\"; boolean passed = checkCodeContains( \"call to roster.findAndPrint method (uncommented in main)\", target); assertTrue(passed); } @Test public void testForEach() { String target = \"for(Student\"; String code = getCode().replaceAll(\"\\\\s\", \"\"); int index = code.indexOf(\"findAndPrint(String\"); boolean passed = false; if (index > 0) { code = code.substring(index, index + 200); int num = countOccurences(code, target); passed = num == 1; } getResults( \"true\", \"\" + passed, \"Checking that findAndPrint() contains an enhanced for loop for Student in array\", passed); assertTrue(passed); } @Test public void testEquals() { boolean passed = checkCodeContains(\"use of equals method\", \".equals(\"); assertTrue(passed); } @Test public void testGetName() { boolean passed = checkCodeContains(\"use of getName() method\", \".getName()\"); assertTrue(passed); } }\n• None Copy your array of objects code from last lesson 6.2.\n• None Using the class above as your guide, separate it into your class and a public array class that puts the array of objects in a private instance variable. The main method should be in this class.\n• None Write a print() method that uses an enhanced for-loop to print out the array elements.\n• None Write a findAndPrint() method with an argument that looks for a certain attribute of the objects in the array using an enhanced for-loop, and prints out all the data for the object it finds. Copy your class from the last last lesson 6.2 below after the ClassNameArray class. Delete the public from in front of that class. On Runestone, only the class that has the main method should be public. Complete the ClassNameArray class substituting in your Class name and using the StudentArray class above as a guide. You should add a print() method and a findAndPrint() method that uses enhanced for loops. public class ClassNameArray // Change ClassName to your class name { // Declare an array of your class type // Write a constructor // Write an add() method that adds an object to your array at a certain index // Write a print() method using an enhanced for loop // Write a findAndPrint(attribute) method using an enhanced for loop public static void main(String[] args) { // Declare an object of ClassNameArray with your class name // Call its add method to add enough new objects to fill the array // Call its print method // Call its findAndPrint method } } // Copy in your class but do not make it public class // Add your class name here - do not make it public { // Copy your class from lesson 6.2 below. } ==== import static org.junit.Assert.*; import org.junit.*; import java.io.*; public class RunestoneTests extends CodeTestHelper { @Test public void testLoop() { String target = \"for\"; String code = getCode(); int num = countOccurences(code, target); boolean passed = num >= 2; getResults(\"2\", \"\" + num, \"Checking that at least 2 enhanced for loops are used\", passed); assertTrue(passed); } @Test public void testPrint() { String target = \"public void print(\"; boolean passed = checkCodeContains(\"print() method\", target); assertTrue(passed); } @Test public void test1() { String target = \"findAndPrint(\"; boolean passed = checkCodeContains(\"findAndPrint method\", target); assertTrue(passed); } }"
    },
    {
        "link": "https://freecodecamp.org/news/enhanced-for-loops-in-java-how-to-use-foreach-loops-on-arrays",
        "document": "You can use enhanced loops in Java to achieve the same results as a loop. An enhanced loop is also known as a loop in Java.\n\nEnhanced loops simplify the way you create loops. They are mostly used to iterate through an array or collection of variables.\n\nIn this tutorial, you'll learn the syntax and how to use the loop (enhanced loop) in Java.\n\nHere's what the syntax of a loop in Java looks like:\n\nIn the syntax above:\n• dataType denotes the data type of the array.\n• variable denotes a variable assigned to each element in the array during the iteration (you'll understand this through the examples that follow).\n• array denotes the array to be looped through.\n\nLet's take a look at some examples to help you understand how a loop works.\n\nIn the code above, we created an array called .\n\nTo loop through and print all the numbers in the array, we made use of a loop: .\n\nIn the parenthesis for the loop, we created an integer variable called which would be used to loop through the array.\n\n= first element in the array (2). This gets printed out.\n\n= second element in the array (4). This current value gets printed out.\n\n= third element in the array (6). This current value gets printed out.\n\n= fourth element in the array (8). This current value gets printed out.\n\nThe value of keeps changing to the current index during the iteration process until it gets to the end of the array. After each index is printed out, it moves to the next index.\n\nYou can also see it this way: \"For every in the array, print )\".\n\nIn the code above, we're multiplying the value of each element by two using the variable: .\n\nThe process here is the same with the last example. When becomes an element in the array, it doubles the element's value and prints it to the console.\n\nYou can use loops in Java to iterate through elements of an array or collection.\n\nThey simplify how you create loops. For instance, the syntax of a loop requires that you create a variable, a condition that specifies when the loop should terminate, and an increment/decrement value.\n\nWith loops, all you need is a variable and the array to be looped through.\n\nBut this doesn't mean that you should always go for loops.\n\nloops give you more control over what happens during the iteration process – controlling and tracking what happens at every index or some indexes.\n\nOn the other hand, loops can be used when you have no use for tracking each index. The code just runs through for every element in the array.\n\nYou can learn more about loops in Java by reading this article."
    },
    {
        "link": "https://zerotomastery.io/blog/enhanced-for-loop-java",
        "document": "Loops are important for controlling the flow of execution in Java.\n\nWithout loops, we would have a lot of duplications, as well as some very weird constructions in our code.\n\nYou might know some of these loops already:\n\nLoops are the backbone of many operations, from processing data, controlling the user interface, or executing a set of statements repeatedly under specific conditions, such as a counter for the loop, or a boolean expression for the (do) loop.\n\nAlways improving, Java 5 introduced the enhanced for loop as a part of its syntax enrichment.\n\nThe enhanced loop, otherwise known as a loop, offers a simplified way to iterate over collections and arrays.\n\nUnlike the traditional loop that relies on a counter to navigate through elements, the enhanced loop abstracts the counter, providing direct access to each element.\n\nThis means that the loop is not only syntactically sleeker but also reduces the chances of errors, such as from off-by-one mistakes leading to , making the code more readable and maintainable.\n\nIn this article, we’ll take a deeper look into the enhanced ( ) loop in Java, how it works, some use cases, best practices, and more.\n\nWith that out of the way, let’s get into this guide!\n\nThe enhanced loop is a way of iterating through elements in arrays and collections in Java.\n\nIt simplifies the traditional loop syntax and eliminates the need for manual index management, making your code more readable and less prone to errors.\n\nThe syntax of the enhanced for loop is elegantly simple.\n\nSo let’s break this down:\n• : The loop starts with the for keyword, indicating the start of the loop block\n• parentheses: Inside the parentheses, we first declare a variable of the same type as the elements in the array or collection. This variable will temporarily hold each element as the loop iterates through the collection\n• : This is the type of the elements in the array or collection you are iterating over\n• Colon: The colon ( ) symbol is used to separate the variable declaration from the collection being iterated.\n• : Is a temporary variable that holds the current element from the array or collection on each iteration\n• : The array or collection you want to iterate through\n• : This is the code you want to execute for every element in the array. In this body, you can use and that will be holding the value of the element you’re currently iterating over\n\nA quick note on the temporary variable creation and scope\n\nThe temporary variable created in the enhanced loop is particularly noteworthy.\n• This variable is created at the beginning of each iteration, and exists only within the scope of the loop, meaning it cannot be accessed outside the loop\n• Also, the value of this variable changes every iteration, and is assigned the value of the current element from the array or collection that the loop is looping over. The scope of this temporary variable is limited to the loop itself\n\nBasic example of the enhanced loop\n\nTo help you understand the loop a little easier, let’s walk through some examples.\n\nWe’ll start with a very basic example where we’re going to iterate over the elements of a collection of integers.\n\nSuppose we have an array of integers, and we want to print each value:\n\nIn this example:\n• is the collection (in this case, an array) being iterated over\n• Each iteration of the loop assigns the next value in the numbers array and prints it until all elements are processed\n\nNow that we have seen a very basic example, let’s spice things up a bit and have a look at some more real-life cases.\n\nPractical use cases for the foreach loop\n\nThe enhanced loop finds its strength in simplifying data processing tasks.\n\nLet's explore this with two practical use cases in the context of an Inventory Management System.\n\nIn an inventory system, you often need to loop through lists of products, perhaps to display them, calculate total inventory value, or update their status.\n\nConsider an of objects, where is a class representing items in your inventory.\n\nThe enhanced loop makes it straightforward to access each object in the .\n\nIt completely eliminates the need for an index variable and so reduces the risk of index-related errors. The code also becomes more intuitive and readable and is going to be of great help in maintaining our business applications.\n\nIn the same inventory system, managing customer data is equally important. This could involve iterating over a set of customer records to generate reports, send notifications, or update profiles.\n\nSuppose we have a of objects, where is a class encapsulating customer information.\n\nUsing the enhanced for loop with a like this demonstrates that we can use it with different types of collections.\n\nAgain, the enhanced loop simplifies the process of iterating over a set where elements are unordered and unique. As a result, the code becomes cleaner and more focused on business logic rather than loop control mechanics.\n\nSo, let’s compare and contrast both of the loops next.\n\nThe enhanced loop doesn’t eliminate the need for the traditional loop, and so if you want to use either of them effectively, then you need to understand them both.\n\nThis section is going to give you a comparative overview, focusing on syntax, use cases, and when to prefer one over the other.\n\nAfter having seen this schematic compare and contrast overview, let’s talk about when to use each one.\n\nWhen to use the enhanced loop ( )\n\nWhen your primary concern is to process each element in a collection or array and the index of the element is not required, the enhanced loop is the way to go.\n\nIt's more readable and to the point, especially when dealing with collections where index management is not straightforward.\n\nWhen to use the traditional loop\n\nIn scenarios where you need to keep track of the index of elements, such as when accessing two arrays simultaneously or when the index is used in calculations, the traditional loop is necessary.\n\nAlso, situations where you need to manipulate the loop counter, like skipping certain elements or changing the step size, require the traditional loop.\n\nWell, the traditional loop offers more flexibility in terms of iteration patterns. It allows backward iteration, conditional continuation, and other complex patterns that are not possible with the enhanced loop.\n\nLet’s have a look at a scenario where we cannot use the enhanced loop…\n\nWhen index-based control is essential, we need to use the traditional loop.\n\nIn a financial reporting system, precision and custom calculations are often the norm. Also, these systems often require the manipulation of data, based on their position or relation to other data points.\n\nLet’s say that we are given the task of generating a detailed expense report where each line item may need to be compared with previous entries, or calculations may depend on the position of the item in the list.\n\nHere’s how to do that:\n\nIn this example, each object in the is processed alongside a corresponding adjustment value, stored in a parallel array.\n\nThis operation requires simultaneous access to both the expenses list and the adjustments array, which can only be achieved through index-based iteration.\n\nAs you have seen, choosing between the enhanced and traditional loops in Java is not just a matter of syntax preference but also involves considerations of what is possible with each of the two loops.\n\nLet’s explore the best practices for selecting the right loop for your situation and tips for writing clean, efficient code.\n\nThe enhanced loop is optimized for iterating over collections and arrays.\n\nThis loop can lead to more efficient bytecode, especially in the case of collections. However, in scenarios where the loop's body is minimal, the overhead of the iterator (in collections) or the hidden index (in arrays) can slightly affect performance.\n\nThe traditional loop offers tight control over the iteration process, which can be more performant in scenarios requiring complex index manipulations or non-sequential access patterns. The manual control of indices, however, can introduce performance overhead if not handled correctly, such as unnecessary recalculations or bounds checking.\n\nGenerally speaking, it’s a best practice to use the enhanced loop for straightforward iterations over arrays or collections where the index is not needed. While we should opt for the traditional loop when dealing with parallel arrays or when specific index manipulation is required.\n\nThere’s also a (somewhat obvious) best practice that is true for both loops, and that is that it's best to avoid unnecessary calculations inside loops where possible to reduce computational load.\n\nAnd as always, make sure to test for performance, and when in doubt (or when performance is very critical), do an a/b test between the traditional and the enhanced loop.\n\nLet’s see one slightly more advanced example before wrapping up this article.\n\nBy now you should be fairly comfortable with the basic usage of the enhanced for loop, so let’s see if we can push it a little and expand beyond the basics.\n\nHere’s how you can iterate through a two-dimensional array:\n\nIn this example, the outer loop iterates over each row (which is itself an array), and the inner loop iterates over each element within that row.\n\nAlright, and that’s it. Let’s go over the most important points and wrap up.\n\nPhew! Did you get all that?\n\nAnd that’s it for the enhanced loop.\n\nI know we covered quite a few things here, so hopefully you managed to grasp what we've been talking about.\n• The enhanced loop (also known as a ) loop in Java offers a simplified, error-resistant way to iterate over arrays and collections\n• The traditional loop is still needed for index-based operations and complex iteration patterns\n• Performance considerations, readability, and the specific requirements of the task should guide the choice of loop\n• Advanced techniques, like using the enhanced loop with multidimensional arrays can address more complex scenarios effectively\n• In order to find out which approach is best, I encourage you to experiment with both loops and measure the difference in performance\n• Both the enhanced and traditional loops have their place in Java programming. Experimenting with both, understanding their nuances, and knowing when to use each one will up your Java skills.\n\nIf in doubt, always aim for code that not only works but is also well-structured and intuitive for others (and your future self) to understand. Keep that in mind, and you’ll pick these techniques up in no time!\n\nBe sure to check out my complete Java programming course here or watch the first few videos for free if you struggled with anything in this post, or simply want to improve your Java skills.\n\nThe course will teach you Java coding from scratch, solidify your knowledge with exercises, help you build fun projects, and gain the skills you need to get hired as a Java Developer in 2025!\n\nNo prior programming knowledge is required. Just a willingness and enthusiasm to learn Java.\n\nAnd better still? When you join the course, not only do you have access to all the training content, but you can also ask questions of me and other Java Developers inside our private Discord channel, so you’ll never be stuck for long!"
    },
    {
        "link": "https://stackoverflow.com/questions/1006395/fastest-way-to-iterate-an-array-in-java-loop-variable-vs-enhanced-for-statement",
        "document": "In Java, is it faster to iterate through an array the old-fashioned way,\n\nOr using the more concise form,\n\nFor an ArrayList, is the answer the same?\n\nOf course for the vast bulk of application code, the answer is it makes no discernible difference so the more concise form should be used for readability. However the context I'm looking at is heavy duty technical computation, with operations that must be performed billions of times, so even a tiny speed difference could end up being significant."
    },
    {
        "link": "https://stackoverflow.com/questions/9530699/enhanced-for-loop-array-of-objects",
        "document": "Ok so I have a class called Dog() which takes two parameters, a string and an integer.\n\n This class has a method called bark(), which prints a string depending on the integer passed into the Dog() constructor.\n\nI also have a class called Kennel() which creates an array of 5 Dog()s... looks like this:\n\nFor starters, this works, but seems wrong. Why do I have to start with Dog[] ... new Dog[5]? Maybe stupid question... I'm new to this.\n\nAnyway... What I have been asked to do is use the \"enhanced\" for loop to iterate through the array calling bark().\n\nSo with a traditional for loop it would look like this:\n\nSimple stuff, right? But how do I implement this using the for(type item : array) syntax?"
    }
]