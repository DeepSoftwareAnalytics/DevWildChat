[
    {
        "link": "https://geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7",
        "document": "How to find Shortest Paths from Source to all Vertices using Dijkstra’s Algorithm\n\nGiven a weighted graph and a source vertex in the graph, find the shortest paths from the source to all the other vertices in the given graph.\n\nNote: The given graph does not contain any negative edge.\n\nThe idea is to generate a SPT (shortest path tree) with a given source as a root. Maintain an Adjacency Matrix with two sets,\n• None One set contains vertices included in the shortest-path tree,\n• None The other set includes vertices not yet included in the shortest-path tree.\n\nAt every step of the algorithm, find a vertex that is in the other set (set not yet included) and has a minimum distance from the source.\n\nBelow is the implementation of the above approach:\n\nWe use a boolean array sptSet[] to represent the set of vertices included in SPT. If a value sptSet[v] is true, then vertex v is included in SPT, otherwise not. Array dist[] is used to store the shortest distance values of all vertices.\n\n// A utility function to find the vertex with the minimum // distance value, from the set of vertices not yet included // the shortest distance from src to i // sptSet[i] will be true if vertex i // Distance of source vertex from itself is always 0 // Pick the minimum distance vertex from the set of // If no valid vertex is found, stop. // Update dist value of the adjacent vertices // Update dist[v] only if it is not in sptSet, // there is an edge from u to v, and total weight // of path from src to v through u is smaller // than current value of dist[v] // Number of vertices in the graph // A utility function to find the vertex with minimum // distance value, from the set of vertices not yet included // The output array. dist[i] will hold the // sptSet[i] will be true if vertex i is // path tree or shortest distance from src to i is // Initialize all distances as INFINITE and stpSet[] as // Distance of source vertex from itself is always 0 // Pick the minimum distance vertex from the set of // vertices not yet processed. u is always equal to // src in the first iteration. // Update dist value of the adjacent vertices of the // Update dist[v] only if is not in sptSet, // there is an edge from u to v, and total // weight of path from src to v through u is // smaller than current value of dist[v] /* Let us create the example graph discussed above */ // A utility function to find the vertex with minimum // distance value, from the set of vertices not yet // the shortest distance from src to i // sptSet[i] will true if vertex i is included in // Initialize all distances as INFINITE and stpSet[] // Distance of source vertex from itself is always 0 // Pick the minimum distance vertex from the set // of vertices not yet processed. u is always // equal to src in first iteration. // Update dist value of the adjacent vertices of // Update dist[v] only if is not in sptSet, // there is an edge from u to v, and total // weight of path from src to v through u is // smaller than current value of dist[v] /* Let us create the example graph discussed above // This code is contributed by Aakash Hasija # A utility function to find the vertex with # minimum distance value, from the set of vertices # not yet included in shortest path tree # Search not nearest vertex not in the # the set of vertices not yet processed. # x is always equal to src in first iteration # Put the minimum distance vertex in the # Update dist value of the adjacent vertices # of the picked vertex only if the current # distance is greater than new distance and # the vertex in not in the shortest path tree \\ # This code is contributed by Divyanshu Mehta and Updated by Pranav Singh Sambyal // value, from the set of vertices // not yet included in shortest // from itself is always 0 // from the set of vertices not yet // processed. u is always equal to // Update dist value of the adjacent // Update dist[v] only if is not in // sptSet, there is an edge from u // to v, and total weight of path // from src to v through u is smaller // than current value of dist[v] /* Let us create the example // This code is contributed by ChitraNayal // value, from the set of vertices // not yet included in shortest // from itself is always 0 // from the set of vertices not yet // processed. u is always equal to // Update dist value of the adjacent // Update dist[v] only if is not in // sptSet, there is an edge from u // to v, and total weight of path // from src to v through u is smaller // than current value of dist[v] // This code is contributed by rag2127\n• None The code calculates the shortest distance but doesn’t calculate the path information. Create a parent array, update the parent array when distance is updated and use it to show the shortest path from source to different vertices.\n• None The time Complexity of the implementation is O(V2) , it can be reduced to O(E*log V) with the help of a binary heap.\n\nWhy Dijkstra’s Algorithms fails for the Graphs having Negative Edges ?\n\nThe problem with negative weights arises from the fact that Dijkstra’s algorithm assumes that once a node is added to the set of visited nodes, its distance is finalized and will not change. However, in the presence of negative weights, this assumption can lead to incorrect results.\n\nConsider the following graph for the example:\n\nIn the above graph, A is the source node, among the edges A to B and A to C , A to B is the smaller weight and Dijkstra assigns the shortest distance of B as 2, but because of existence of a negative edge from C to B , the actual shortest distance reduces to 1 which Dijkstra fails to detect.\n\nNote: We use Bellman Ford’s Shortest path algorithm in case we have negative edges in the graph.\n\nDijkstra’s Algorithm using Adjacency List and Heap in O(E*logV):\n\n// Prints shortest paths from src to all other vertices // Create a vector for distances and initialize all // Insert source itself in priority queue and initialize /* Looping till priority queue becomes empty (or all // The first vertex in pair is the minimum distance // Get all adjacent of u. // Get vertex label and weight of current // If there is shorted path to v through u. // Java program for the above approach // Prints shortest paths from src to all other vertices // Create a list for distances and initialize all // Insert source itself in priority queue and /* Looping till priority queue becomes empty (or all // The first vertex in pair is the minimum // Get all adjacent of u. // Get vertex label and weight of current // If there is a shorter path to v through # Function to add an edge to the adjacency list # Function to find the shortest paths from source to all other vertices # Create a priority queue to store vertices that are being preprocessed # Create an array for distances and initialize all distances as infinite (INF) # Insert source itself in the priority queue and initialize its distance as 0 # Loop until the priority queue becomes empty # Extract the vertex with minimum distance from the priority queue # Get all adjacent vertices of u # If there is a shorter path to v through u // Function to add an edge to the adjacency list // Function to find the shortest paths from source to all // Create a priority queue to store vertices that are // Create an array for distances and initialize all // Insert source itself in the priority queue and // Loop until the priority queue becomes empty // Extract the vertex with minimum distance from the // Get all adjacent vertices of u // If there is a shorter path to v through u\n\nTime Complexity: O(E*logV), Where E is the number of edges and V is the number of vertices. \n\n Auxiliary Space: O(V), Where V is the number of vertices.\n• Google maps uses Dijkstra algorithm to show shortest distance between source and destination.\n• computer networking , Dijkstra’s algorithm forms the basis for various routing protocols, such as OSPF (Open Shortest Path First) and IS-IS (Intermediate System to Intermediate System).\n• None Transportation and traffic management systems use Dijkstra’s algorithm to optimize traffic flow, minimize congestion, and plan the most efficient routes for vehicles.\n• None Airlines use Dijkstra’s algorithm to plan flight paths that minimize fuel consumption, reduce travel time.\n• None Dijkstra’s algorithm is applied in electronic design automation for routing connections on integrated circuits and very-large-scale integration (VLSI) chips.\n• None Shortest path with one curved edge in an undirected Graph\n• None 1st to Kth shortest path lengths in given Graph\n• None Number of ways to reach at destination in shortest time"
    },
    {
        "link": "https://geeksforgeeks.org/shortest-path-in-a-directed-graph-by-dijkstras-algorithm",
        "document": "Given a directed graph and a source vertex in the graph, the task is to find the shortest distance and path from source to target vertex in the given graph where edges are weighted (non-negative) and directed from parent vertex to source vertices.\n• None Mark all vertices unvisited. Create a set of all unvisited vertices.\n• None Assign zero distance value to source vertex and infinity distance value to all other vertices.\n• None For current vertex, consider all of its unvisited children and calculate their tentative distances through the current. (distance of current + weight of the corresponding edge) Compare the newly calculated distance to the current assigned value (can be infinity for some vertices) and assign the smaller one.\n• None After considering all the unvisited children of the current vertex, mark the current as visited and remove it from the unvisited set.\n• None Similarly, continue for all the vertex until all the nodes are visited.\n\nBelow is the implementation of the above approach:\n\n\"%d and %d are not \" \"{0} and {1} are not \" \"Distance of {}th vertex from source vertex {} is: {}\" \"{0} and {1} are not \"\n\nTime Complexity: O((E+V)*logV))\n\nAuxiliary Space: O(V + E)\n\nRelated articles: We have already discussed the shortest path in directed graph using Topological Sorting, in this article: Shortest path in Directed Acyclic graph"
    },
    {
        "link": "https://w3schools.com/dsa/dsa_algo_graphs_dijkstra.php",
        "document": "Dijkstra's algorithm finds the shortest path from one vertex to all other vertices.\n\nIt does so by repeatedly selecting the nearest unvisited vertex and calculating the distance to all the unvisited neighboring vertices.\n\nDijkstra's algorithm is often considered to be the most straightforward algorithm for solving the shortest path problem.\n\nDijkstra's algorithm is used for solving single-source shortest path problems for directed or undirected paths. Single-source means that one vertex is chosen to be the start, and the algorithm will find the shortest path from that vertex to all other vertices.\n\nDijkstra's algorithm does not work for graphs with negative edges. For graphs with negative edges, the Bellman-Ford algorithm that is described on the next page, can be used instead.\n\nTo find the shortest path, Dijkstra's algorithm needs to know which vertex is the source, it needs a way to mark vertices as visited, and it needs an overview of the current shortest distance to each vertex as it works its way through the graph, updating these distances when a shorter distance is found.\n\nIn the animation above, when a vertex is marked as visited, the vertex and its edges become faded to indicate that Dijkstra's algorithm is now done with that vertex, and will not visit it again.\n\nRun the simulation below to get a more detailed understanding of how Dijkstra's algorithm runs on a specific graph, finding the shortest distances from vertex D.\n\nThis simulation shows how distances are calculated from vertex D to all other vertices, by always choosing the next vertex to be the closest unvisited vertex from the starting point.\n\nFollow the step-by-step description below to get all the details of how Dijkstra's algorithm calculates the shortest distances.\n\nConsider the Graph below.\n\nWe want to find the shortest path from the source vertex D to all other vertices, so that for example the shortest path to C is D->E->C, with path weight 2+4=6.\n\nTo find the shortest path, Dijkstra's algorithm uses an array with the distances to all other vertices, and initially sets these distances to infinite, or a very big number. And the distance to the vertex we start from (the source) is set to 0.\n\nThe image below shows the initial infinite distances to other vertices from the starting vertex D. The distance value for vertex D is 0 because that is the starting point.\n\nDijkstra's algorithm then sets vertex D as the current vertex, and looks at the distance to the adjacent vertices. Since the initial distance to vertices A and E is infinite, the new distance to these are updated with the edge weights. So vertex A gets the distance changed from inf to 4, and vertex E gets the distance changed to 2. As mentioned on the previous page, updating the distance values in this way is called 'relaxing'.\n\nAfter relaxing vertices A and E, vertex D is considered visited, and will not be visited again.\n\nThe next vertex to be chosen as the current vertex must the vertex with the shortest distance to the source vertex (vertex D), among the previously unvisited vertices. Vertex E is therefore chosen as the current vertex after vertex D.\n\nThe distance to all adjacent and not previously visited vertices from vertex E must now be calculated, and updated if needed.\n\nThe calculated distance from D to vertex A, via E, is 2+4=6. But the current distance to vertex A is already 4, which is lower, so the distance to vertex A is not updated.\n\nThe distance to vertex C is calculated to be 2+4=6, which is less than infinity, so the distance to vertex C is updated.\n\nSimilarly, the distance to node G is calculated and updated to be 2+5=7.\n\nThe next vertex to be visited is vertex A because it has the shortest distance from D of all the unvisited vertices.\n\nThe calculated distance to vertex C, via A, is 4+3=7, which is higher than the already set distance to vertex C, so the distance to vertex C is not updated.\n\nVertex A is now marked as visited, and the next current vertex is vertex C because that has the lowest distance from vertex D between the remaining unvisited vertices.\n\nVertex F gets updated distance 6+5=11, and vertex B gets updated distance 6+2=8.\n\nCalculated distance to vertex G via vertex C is 6+5=11 which is higher than the already set distance of 7, so distance to vertex G is not updated.\n\nVertex C is marked as visited, and the next vertex to be visited is G because is has the lowest distance between the remaining unvisited vertices.\n\nVertex F already has a distance of 11. This is lower than the calculated distance from G, which is 7+5=12, so the distance to vertex F is not updated.\n\nVertex G is marked as visited, and B becomes the current vertex because it has the lowest distance of the remaining unvisited vertices.\n\nThe new distance to F via B is 8+2=10, because it is lower than F's existing distance of 11.\n\nVertex B is marked as visited, and there is nothing to check for the last unvisited vertex F, so Dijkstra's algorithm is finished.\n\nEvery vertex has been visited only once, and the result is the lowest distance from the source vertex D to every other vertex in the graph.\n\nTo implement Dijkstra's algorithm, we create a class. The represents the graph with its vertices and edges:\n\nLine 3: We create the to hold all the edges and edge weights. Initial values are set to .\n\nLine 4: is the number of vertices in the graph.\n\nLine 5: The holds the names of all the vertices.\n\nLine 7-10: The method is used to add an edge from vertex to vertex , with edge weight .\n\nLine 12-14: The method is used to add a vertex to the graph. The index where the vertex should belong is given with the argument, and is the name of the vertex.\n\nThe class also contains the method that runs Dijkstra's algorithm:\n\nLine 18-19: The initial distance is set to infinity for all vertices in the array, except for the start vertex, where the distance is 0.\n\nLine 20: All vertices are initially set to to mark them as not visited in the array.\n\nLine 23-28: The next current vertex is found. Outgoing edges from this vertex will be checked to see if shorter distances can be found. It is the unvisited vertex with the lowest distance from the start.\n\nLine 30-31: If the next current vertex has not been found, the algorithm is finished. This means that all vertices that are reachable from the source have been visited.\n\nLine 33: The current vertex is set as visited before relaxing adjacent vertices. This is more effective because we avoid checking the distance to the current vertex itself.\n\nLine 35-39: Distances are calculated for not visited adjacent vertices, and updated if the new calculated distance is lower.\n\nAfter defining the class, the vertices and edges must be defined to initialize the specific graph, and the complete code for this Dijkstra's algorithm example looks like this:\n\nTo run Dijkstra's algorithm on directed graphs, very few changes are needed.\n\nSimilarly to the change we needed for cycle detection for directed graphs, we just need to remove one line of code so that the adjacency matrix is not symmetric anymore.\n\nLet's implement this directed graph and run Dijkstra's algorithm from vertex D.\n\nHere is the implementation of Dijkstra's algorithm on the directed graph, with D as the source vertex:\n\nThe image below shows us the shortest distances from vertex D as calculated by Dijkstra's algorithm.\n\nThis result is similar to the previous example using Dijkstra's algorithm on the undirected graph. However, there's a key difference: in this case, vertex B cannot be visited from D, and this means that the shortest distance from D to F is now 11, not 10, because the path can no longer go through vertex B.\n\nWith a few adjustments, the actual shortest paths can also be returned by Dijkstra's algorithm, in addition to the shortest path values. So for example, instead of just returning that the shortest path value is 10 from vertex D to F, the algorithm can also return that the shortest path is \"D->E->C->B->F\".\n\nTo return the path, we create a array to keep the previous vertex in the shortest path for each vertex. The array can be used to backtrack to find the shortest path for every vertex.\n\nLine 7 and 29: The array is first initialized with values, then it is updated with the correct predecessor for each vertex as the shortest path values are updated.\n\nLine 33-42: The method uses the array and returns a string with the shortest path from start to end vertex.\n\nLet's say we are only interested in finding the shortest path between two vertices, like finding the shortest distance between vertex D and vertex F in the graph below.\n\nDijkstra's algorithm is normally used for finding the shortest path from one source vertex to all other vertices in the graph, but it can also be modified to only find the shortest path from the source to a single destination vertex, by just stopping the algorithm when the destination is reached (visited).\n\nThis means that for the specific graph in the image above, Dijkstra's algorithm will stop after visiting F (the destination vertex), before visiting vertices H, I and J because they are farther away from D than F is.\n\nBelow we can see the status of the calculated distances when Dijkstra's algorithm has found the shortest distance from D to F, and stops running.\n\nIn the image above, vertex F has just got updated with distance 10 from vertex B. Since F is the unvisited vertex with the lowest distance from D, it would normally be the next current vertex, but since it is the destination, the algorithm stops. If the algorithm did not stop, J would be the next vertex to get an updated distance 11+2=13, from vertex I.\n\nThe code below is Dijkstra's algorithm implemented to find the shortest path to a single destination vertex:\n\nLine 20-23: If we are about to choose the destination vertex as the current vertex and mark it as visited, it means we have already calculated the shortest distance to the destination vertex, and Dijkstra's algorithm can be stopped in this single destination case.\n\nWith \\(V\\) as the number of vertices in our graph, the time complexity for Dijkstra's algorithm is\n\nThe reason why we get this time complexity is that the vertex with the lowest distance must to be search for to choose the next current vertex, and that takes \\(O(V)\\) time. And since this must to be done for every vertex connected to the source, we need to factor that in, and so we get time complexity \\(O(V^2)\\) for Dijkstra's algorithm.\n\nBy using a Min-heap or Fibonacci-heap data structure for the distances instead (not yet explained in this tutorial), the time needed to search for the minimum distance vertex is reduced from \\(O(V)\\) to \\(O( \\log{V})\\), which results in an improved time complexity for Dijkstra's algorithm\n\nWhere \\(V\\) is the number of vertices in the graph, and \\(E\\) is the number of edges.\n\nThe improvement we get from using a Min-heap data structure for Dijkstra's algorithm is especially good if we have a large and sparse graph, which means a graph with a large number of vertices, but not as many edges.\n\nThe implementation of Dijkstra's algorithm with the Fibonacci-heap data structure is better for dense graphs, where each vertex has an edge to almost every other vertex."
    },
    {
        "link": "https://stackoverflow.com/questions/8379866/using-dijkstra-algorithm-to-find-shortest-path-in-an-adjacency-matrix",
        "document": "I have a homework assignment where I'm supposed to find the cheapest airfares between two cities, taking into account layovers.\n\nWe are required to use an adjacency matrix along with Dijkstra's algorithm. I'm looking at the algorithm in my book, as well as wikipedia (among other sites). I'm confused because in the parameter for the algorithm it has:\n\nWhat I'm having a hard time understanding- especially when looking at the entire pseudocode- is why it only takes one vertex as an argument? I need to find the cheapest airfare(shortest path) between two vertices. Why does the algorithm only require one?"
    },
    {
        "link": "https://favtutor.com/blogs/dijkstras-algorithm-cpp",
        "document": "We uphold a strict editorial policy that emphasizes factual accuracy, relevance, and impartiality. Our content is crafted by top technical writers with deep knowledge in the fields of computer science and data science, ensuring each piece is meticulously reviewed by a team of seasoned editors to guarantee compliance with the highest standards in educational content creation and publishing.\n\nIn this article, we will study what is the graph and what is Dijkstra's algorithm. Further, we will study the example of Dijkstra's algorithm and its c++ code along with its corresponding output. We will also further study the practical application of this algorithm in the real world. So let's get started!\n\nThe graph is a non-linear data structure that involves nodes and edges. The nodes are the vertices and edges are the lines that connect the two nodes in the graph. Therefore, the graph can be defined as a set of vertices and a set of edges that connect the nodes. If we consider Facebook as a graph then the collection of people on Facebook is considered as nodes and the connection between them can be considered as edges. Therefore, graphs are the data structures used to display the \"connection\" between the pairs of elements. The below image shows the graphical representation of the graph.\n\nGenerally, there are two types of graph possible:\n• Undirected Graph: Using an Undirected graph, for every pair of connected nodes, you can go from one node to another in both directions.\n• Directed Graph: You can only go from one node to another in a specific direction for every pair of connected nodes using the directed graph. You can make use of arrows as an edge connecting two nodes. \n\nMoreover, a weighted graph is a graph that consists of edges with some specific \"weight\" or \"cost.\" The weight of the edge can represent time, distance, or anything that models the \"connection\" between pair of nodes.\n\nDijkstra’s algorithm is also known as the shortest path algorithm. It is an algorithm used to find the shortest path between nodes of the graph. The algorithm creates the tree of the shortest paths from the starting source vertex from all other points in the graph. It differs from the minimum spanning tree as the shortest distance between two vertices may not be included in all the vertices of the graph. The algorithm works by building a set of nodes that have a minimum distance from the source. Here, Dijkstra's algorithm uses a greedy approach to solve the problem and find the best solution.\n\nDijkstra's algorithm only works with the graph that possesses positive weights. While running an algorithm, the weights of the edges have to be added to find the shortest path between the nodes. If there is negative weight in the graph, then the algorithm will fail to work. Remember that once you mark the node as \"visited,\" the current path to the node is the shortest path to reach that node. Therefore, if you have negative weights, it can alter this step if the total weight is decreased.\n\nMoreover, while understanding Dijkstra's algorithm, the question arises that whether it is BFS or DFS? Well, it is neither. Dijkstra's algorithm is a priority first algorithm. However, between BFS and DFS algorithms, the priority will be more to BFS rather than DFS. Basically, you can find some essential structure of BFS inside Dijkstra's algorithm, but honestly, it is much more than the BFS algorithm.\n\nAlgorithm for Dijkstra’s in C++\n\nTo know how Dijkstra's algorithm works behind the scene, look at the below steps to understand it in detail:\n• First of all, we will mark all vertex as unvisited vertex\n• Then, we will mark the source vertex as 0 and all other vertices as infinity\n• Calculate the path length of all the neighboring vertex from the current vertex by adding the weight of the edge in the current vertex\n• Now, if the new path length is smaller than the previous path length then replace it otherwise ignore it\n• Mark the current vertex as visited after visiting the neighbor vertex of the current vertex\n• Select the vertex with the smallest path length as the new current vertex and go back to step 4.\n• Repeat this process until all the vertex are marked as visited.\n\nOnce we go through the algorithm, we can backtrack the source vertex and find our shortest path.\n\nPseudocode of Dijkstra’s Algorithm in C++\n\nLet us consider the below example to understand the algorithm. Here we are given a weighted graph, and we will choose vertex 'A' as the source vertex of the graph.\n\nAs the algorithm generates the shortest path from the source vertex to every other vertex, we will set the distance of the source vertex to itself as '0'. The distance from the source vertex to all other vertex is not determined yet, and therefore, we will represent it using infinity.\n\nFor now, the list of unvisited nodes will be: {B, C, D, E}\n\nHere, we will start checking the distance from node 'A' to its adjacent vertex. You can see the adjacent vertexes are 'B' and 'C' with weights '10' and '3', respectively. Remember that you don't have to add the two vertexes to the shortest path immediately.\n\nFirstly, we will update the distance from infinity to given weights. Then we have to select the node closest to the source node depending on the updated weights. Mark it as visited and add it to the path.\n\nAs shown below, we update vertex B from infinity to 10 and vertex C from infinity to 3.\n\nNow select the vertex with the smaller path length as visited vertex and put it in the answer. Therefore, the list of unvisited nodes is {B, D, E}\n\nNow, we have to analyze the new adjacent vertex to find the shortest path. So we will visit the neighboring nodes of the visited vertex and update the path lengths as required. Here, we have B, D, and E as adjacent vertex to node 'A' and node 'C.' Therefore, we will update the path of all three vertexes from infinity to their respective weights as shown in the image below.\n\nNote that node 'B' is directly connected adjacent to node 'A,' hence, node 'B' weight will be the same as displayed. But for Node 'D' and node 'E,' the path is calculated via node 'C,' and hence the weight of that vertex will be 11 and 5 because we add the weight of the edges from path A->C->D and A->C->E respectively.\n\nNow, choosing the shortest path from the above table results in choosing the node 'E' with the shortest distance of 5 from the source vertex. And hence the list of unvisited nodes is {B, D}\n\nRepeat the process until all vertices have been visited. Here, vertex 'B' and vertex 'D' are both considered adjacent vertex, and the shortest distance of both the vertex from the source node does not change, as shown in the figure below.\n\nTherefore, the weight of vertex 'B' is minimum compared to vertex 'D,' so we will mark it as a visited node and add it to the path. The list of the unvisited nodes will be {D}\n\nAfter visiting vertex 'B,' we are left with visiting vertex 'D.' If you carefully notice, the distance from source vertex to vertex 'D' can be modified from the previous one, i.e., instead of visiting vertex 'D' directly via vertex 'C,' we can visit it via vertex 'B' with the total distance of 9. That is because we add the weight of the edges like A->C->B->D (3+4+2=9) as shown below.\n\nTherefore, the final output of the algorithm will be {A, C, E, B, D}\n\nThe time complexity of Dijkstra's algorithm is O(V^2), where V is the number of vertices in the graph. However, if the input graph is represented using an adjacency list (method of representation of graph), then the time complexity can be reduced to O(E log V) using a binary heap.\n\nThe space complexity of Dijkstra's algorithm is O(V), where V is the total number of vertices of the graph. This is because we have to store all these vertices in the list as an output.\n• Dijkstra’s algorithm is used as a routing protocol required by the routers to update their forwarding table.\n• It is used to find the shortest distance between two locations along the path on google maps.\n• It is used in telephone networking to find the shortest path for finding the nearest switching station for transmission.\n• Dijkstra’s algorithm is used to find the shortest path between users measured through handshakes or connections among them.\n• Dijkstra’s algorithm is used to minimize the number of hops in computer networks.\n\nGraphs are used as a connection between objects, people, or entities, and Dijkstra's algorithm will help you find the shortest distance between two points in a graph. As Dijkstra's algorithm has its own importance in the real world, it is most recommended to learn and understand it in detail."
    },
    {
        "link": "https://geeksforgeeks.org/dijkstras-shortest-path-algorithm-using-priority_queue-stl",
        "document": "Given a graph and a source vertex in graph, find shortest paths from source to all vertices in the given graph.\n• None Dijkstra’s Algorithm for Adjacency Matrix Representation (In C/C++ with time complexity O(v\n• None Dijkstra’s Algorithm for Adjacency List Representation (In C with Time Complexity O(ELogV))\n• None Dijkstra’s shortest path algorithm using set in STL (In C++ with Time Complexity O(ELogV))\n\nThe second implementation is time complexity wise better but is really complex as we have implemented our own priority queue. The Third implementation is simpler as it uses STL. The issue with third implementation is, it uses set which in turn uses Self-Balancing Binary Search Trees. For Dijkstra’s algorithm, it is always recommended to use heap (or priority queue) as the required operations (extract minimum and decrease key) match with speciality of heap (or priority queue). However, the problem is, priority_queue doesn’t support decrease key. To resolve this problem, do not update a key, but insert one more copy of it. So we allow multiple instances of same vertex in priority queue. This approach doesn’t require decrease key operation and has below important properties.\n• None Whenever distance of a vertex is reduced, we add one more instance of vertex in priority_queue. Even if there are multiple instances, we only consider the instance with minimum distance and ignore other instances.\n• None The time complexity remains O(ELogV)) as there will be at most O(E) vertices in priority queue and O(Log E) is same as O(Log V)\n\nBelow is algorithm based on above idea.\n\nBelow implementation of above idea:\n\n// In a weighted graph, we need to store vertex // and weight pair for every edge // function to add an edge to graph // Prints shortest paths from src to all other vertices // are being preprocessed. This is weird syntax in C++. // Refer below link for details of this syntax // Create a vector for distances and initialize all // Insert source itself in priority queue and initialize /* Looping till priority queue becomes empty (or all // The first vertex in pair is the minimum distance // vertex label is stored in second of pair (it // has to be done this way to keep the vertices // sorted distance (distance must be first item // 'i' is used to get all adjacent vertices of a // Get vertex label and weight of current // If there is shorted path to v through u. // create the graph given in above figure // Java program for the above approach // Inner class to represent a pair of vertex and its // Method to add an edge to the graph // Method to find the shortest paths from source vertex // Main class containing the main method to test the graph // Finding and printing the shortest paths from // This code is contributed by Susobhan Akhuli # Python program for the above approach # In a weighted graph, store vertex and weight pair for every edge # Function to add an edge to the graph # Prints shortest paths from src to all other vertices # The first element of the tuple is the distance, and the second is the vertex label # Create a list for distances and initialize all # Looping until the priority queue becomes empty # The first element in the tuple is the minimum distance vertex # Extract it from the priority queue # Iterate over all adjacent vertices of a vertex # If there is a shorter path to v through u # Driver program to test methods of the graph class # Create the graph given in the above figure # This code is contributed by Susobhan Akhuli // C# program for the above approach // function to add an edge to graph // Create a vector for distances and initialize all // Insert source itself in the sorted set and initialize /* Looping till the sorted set becomes empty (or all // The first vertex in tuple is the minimum distance // vertex, extract it from the sorted set. // vertex label is stored in the second element of the tuple. // (it has to be done this way to keep the vertices // sorted by distance, where distance must be the first item // 'i' is used to get all adjacent vertices of a // Get vertex label and weight of the current // If there is a shorter path to v through u. // Driver program to test methods of the graph class // Create the graph given in the above figure // This code is contributed by Susobhan Akhuli // Driver program to test methods of the graph class // create the graph given in the provided C++ code\n\nSpace Complexity:O(V2) , here V is number of Vertices.\n\nA Quicker Implementation using vector of pairs representation of weighted graph :\n\n// Prints shortest paths from src to all other vertices // are being preprocessed. This is weird syntax in C++. // Refer below link for details of this syntax // Create a vector for distances and initialize all // Insert source itself in priority queue and initialize /* Looping till priority queue becomes empty (or all // The first vertex in pair is the minimum distance // vertex label is stored in second of pair (it // has to be done this way to keep the vertices // sorted distance (distance must be first item // Get all adjacent of u. // Get vertex label and weight of current // If there is shorted path to v through u. // Java program for the above approach // Prints shortest paths from src to all other vertices // Create a list for distances and initialize all // Insert source itself in priority queue and /* Looping till priority queue becomes empty (or all // The first vertex in pair is the minimum // queue. vertex label is stored in second of // pair (it has to be done this way to keep the // Get all adjacent of u. // Get vertex label and weight of current // If there is a shorter path to v through // This code is contributed by Susobhan Akhuli # Function to add an edge to the adjacency list # Function to find the shortest paths from source to all other vertices # Create a priority queue to store vertices that are being preprocessed # Create an array for distances and initialize all distances as infinite (INF) # Insert source itself in the priority queue and initialize its distance as 0 # Loop until the priority queue becomes empty # Extract the vertex with minimum distance from the priority queue # Get all adjacent vertices of u # If there is a shorter path to v through u # Call the main function to execute the program // C# program for the above approach // Function to add an edge to the graph // Function to print shortest paths from source to all // Create an array for distances and initialize all // Insert source itself in priority queue and // Get all adjacent vertices of u // If there is a shorter path to v through u // This code is contributed by Susobhan Akhuli // Function to add an edge to the adjacency list // Function to find the shortest paths from source to all other vertices // Create a priority queue to store vertices that are being preprocessed // Create an array for distances and initialize all distances as infinite (INF) // Insert source itself in the priority queue and initialize its distance as 0 // Loop until the priority queue becomes empty // Extract the vertex with minimum distance from the priority queue // Get all adjacent vertices of u // If there is a shorter path to v through u // Call the main function to execute the program\n\nThe time complexity of Dijkstra’s algorithm using a priority queue implemented with a binary heap is O(Elog(V)), where E is the number of edges and V is the number of vertices in the graph.\n\nThe space complexity of this implementation is O(V+E), where V is the number of vertices and E is the number of edges.\n\n// Define a comparator method to compare distance of two nodes // While the priority queue is not empty // Pop the node with the minimum distance from priority queue // Get the vertex and distance // Get the adjacency list of the vertex // For every adjacent node of the vertex // If the node is not yet visited // If the node is not present in the map // Put the node in the map // Get the node from the map // Check if the new distance is less than the current distance of the node // Push the node to the priority queue // For every key in the map // Add the distance of the node to the result // If u[i] is not present in map // Add the edge to the adjacency list // If v[i] is not present in map // Add the edge to the adjacency list // If the vertex is present in map // Add the adjacency list to the main adjacency list // Print the result in the specified format #define a comparator method to compare distance of two nodes #while the priority queue is not empty #pop the node with minimum distance from priority queue #get the vertex and distance #get the adjacent list of the vertex #for every adjacent node of the vertex #if the node is not yet visited #if the node is not present in map #check if the new distance is less than the current distance of the node #add the distance of the node to the result #if the u[i] is not present in map #add the edge to the adjacency list #if the v[i] is not present in map #add the edge to the adjacency list #if the vertex is present in map #add the adjacency list to the main adjacency list // Function to implement Dijkstra Algorithm to find the shortest distance // While the priority queue is not empty // Pop the node with minimum distance from priority queue // Get the vertex and distance // Get the adjacent list of the vertex // For every adjacent node of the vertex // If the node is not yet visited // If the node is not present in map // Add the node to the adjacency list // Check if the new distance is less than the current distance of the node // Check if map[key] is not empty // Add the distance of the node to the result // If the u[i] is not present in map // Add the node to the adjacency list // If the v[i] is not present in map // Add the node to the adjacency list // If the vertex is present in map // Add the adjacency list to the main adjacency list // This code is contributed by shivamgupta0987654321\n\nTime Complexity: O(ElogV)\n\nThe time complexity is O(ElogV) where E is the number of edges and V is the number of vertices. This is because, for each vertex, we need to traverse all its adjacent vertices and update their distances, which takes O(E) time. Also, we use a Priority Queue which takes O(logV) time for each insertion and deletion.\n\nSpace Complexity: O(V)\n\nThe space complexity is O(V) as we need to maintain a visited array of size V, a map of size V and a Priority Queue of size V.\n\nFurther Optimization We can use a flag array to store what all vertices have been extracted from priority queue. This way we can avoid updating weights of items that have already been extracted. Please see this for optimized implementa Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above"
    },
    {
        "link": "https://takeuforward.org/data-structure/dijkstras-algorithm-using-priority-queue-g-32",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/16994136/priority-queues-and-dijkstra",
        "document": "Explain to me how to construct a priority queue and why you have to construct that way as though the limit of my my experiences with priority queues is knowing what a queue is (I have never used one in my life).\n\nWhen I'm looking at this website: http://comsci.liu.edu/~jrodriguez/cs631sp08/c++priorityqueue.html\n\nI understand that Time is so that you have a queue of Times, Compare Time is what determines the priority of which a time is placed into the queue, but why does need to be in the constructor?\n\nAbout Dijkstra: I'm implementing a graph as a vector of nodes, which each node containing a list of all its neighbors positions in that vector), so it looks something like this:\n\nHow would I implement this part of Dijkstra:\n\nfor dist[v] = infinity, I'm assuming I set the value of every node to infinity, but what variable would allow me to do that? And for previous[v], what does it mean by undefined?"
    },
    {
        "link": "https://geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7",
        "document": "How to find Shortest Paths from Source to all Vertices using Dijkstra’s Algorithm\n\nGiven a weighted graph and a source vertex in the graph, find the shortest paths from the source to all the other vertices in the given graph.\n\nNote: The given graph does not contain any negative edge.\n\nThe idea is to generate a SPT (shortest path tree) with a given source as a root. Maintain an Adjacency Matrix with two sets,\n• None One set contains vertices included in the shortest-path tree,\n• None The other set includes vertices not yet included in the shortest-path tree.\n\nAt every step of the algorithm, find a vertex that is in the other set (set not yet included) and has a minimum distance from the source.\n\nBelow is the implementation of the above approach:\n\nWe use a boolean array sptSet[] to represent the set of vertices included in SPT. If a value sptSet[v] is true, then vertex v is included in SPT, otherwise not. Array dist[] is used to store the shortest distance values of all vertices.\n\n// A utility function to find the vertex with the minimum // distance value, from the set of vertices not yet included // the shortest distance from src to i // sptSet[i] will be true if vertex i // Distance of source vertex from itself is always 0 // Pick the minimum distance vertex from the set of // If no valid vertex is found, stop. // Update dist value of the adjacent vertices // Update dist[v] only if it is not in sptSet, // there is an edge from u to v, and total weight // of path from src to v through u is smaller // than current value of dist[v] // Number of vertices in the graph // A utility function to find the vertex with minimum // distance value, from the set of vertices not yet included // The output array. dist[i] will hold the // sptSet[i] will be true if vertex i is // path tree or shortest distance from src to i is // Initialize all distances as INFINITE and stpSet[] as // Distance of source vertex from itself is always 0 // Pick the minimum distance vertex from the set of // vertices not yet processed. u is always equal to // src in the first iteration. // Update dist value of the adjacent vertices of the // Update dist[v] only if is not in sptSet, // there is an edge from u to v, and total // weight of path from src to v through u is // smaller than current value of dist[v] /* Let us create the example graph discussed above */ // A utility function to find the vertex with minimum // distance value, from the set of vertices not yet // the shortest distance from src to i // sptSet[i] will true if vertex i is included in // Initialize all distances as INFINITE and stpSet[] // Distance of source vertex from itself is always 0 // Pick the minimum distance vertex from the set // of vertices not yet processed. u is always // equal to src in first iteration. // Update dist value of the adjacent vertices of // Update dist[v] only if is not in sptSet, // there is an edge from u to v, and total // weight of path from src to v through u is // smaller than current value of dist[v] /* Let us create the example graph discussed above // This code is contributed by Aakash Hasija # A utility function to find the vertex with # minimum distance value, from the set of vertices # not yet included in shortest path tree # Search not nearest vertex not in the # the set of vertices not yet processed. # x is always equal to src in first iteration # Put the minimum distance vertex in the # Update dist value of the adjacent vertices # of the picked vertex only if the current # distance is greater than new distance and # the vertex in not in the shortest path tree \\ # This code is contributed by Divyanshu Mehta and Updated by Pranav Singh Sambyal // value, from the set of vertices // not yet included in shortest // from itself is always 0 // from the set of vertices not yet // processed. u is always equal to // Update dist value of the adjacent // Update dist[v] only if is not in // sptSet, there is an edge from u // to v, and total weight of path // from src to v through u is smaller // than current value of dist[v] /* Let us create the example // This code is contributed by ChitraNayal // value, from the set of vertices // not yet included in shortest // from itself is always 0 // from the set of vertices not yet // processed. u is always equal to // Update dist value of the adjacent // Update dist[v] only if is not in // sptSet, there is an edge from u // to v, and total weight of path // from src to v through u is smaller // than current value of dist[v] // This code is contributed by rag2127\n• None The code calculates the shortest distance but doesn’t calculate the path information. Create a parent array, update the parent array when distance is updated and use it to show the shortest path from source to different vertices.\n• None The time Complexity of the implementation is O(V2) , it can be reduced to O(E*log V) with the help of a binary heap.\n\nWhy Dijkstra’s Algorithms fails for the Graphs having Negative Edges ?\n\nThe problem with negative weights arises from the fact that Dijkstra’s algorithm assumes that once a node is added to the set of visited nodes, its distance is finalized and will not change. However, in the presence of negative weights, this assumption can lead to incorrect results.\n\nConsider the following graph for the example:\n\nIn the above graph, A is the source node, among the edges A to B and A to C , A to B is the smaller weight and Dijkstra assigns the shortest distance of B as 2, but because of existence of a negative edge from C to B , the actual shortest distance reduces to 1 which Dijkstra fails to detect.\n\nNote: We use Bellman Ford’s Shortest path algorithm in case we have negative edges in the graph.\n\nDijkstra’s Algorithm using Adjacency List and Heap in O(E*logV):\n\n// Prints shortest paths from src to all other vertices // Create a vector for distances and initialize all // Insert source itself in priority queue and initialize /* Looping till priority queue becomes empty (or all // The first vertex in pair is the minimum distance // Get all adjacent of u. // Get vertex label and weight of current // If there is shorted path to v through u. // Java program for the above approach // Prints shortest paths from src to all other vertices // Create a list for distances and initialize all // Insert source itself in priority queue and /* Looping till priority queue becomes empty (or all // The first vertex in pair is the minimum // Get all adjacent of u. // Get vertex label and weight of current // If there is a shorter path to v through # Function to add an edge to the adjacency list # Function to find the shortest paths from source to all other vertices # Create a priority queue to store vertices that are being preprocessed # Create an array for distances and initialize all distances as infinite (INF) # Insert source itself in the priority queue and initialize its distance as 0 # Loop until the priority queue becomes empty # Extract the vertex with minimum distance from the priority queue # Get all adjacent vertices of u # If there is a shorter path to v through u // Function to add an edge to the adjacency list // Function to find the shortest paths from source to all // Create a priority queue to store vertices that are // Create an array for distances and initialize all // Insert source itself in the priority queue and // Loop until the priority queue becomes empty // Extract the vertex with minimum distance from the // Get all adjacent vertices of u // If there is a shorter path to v through u\n\nTime Complexity: O(E*logV), Where E is the number of edges and V is the number of vertices. \n\n Auxiliary Space: O(V), Where V is the number of vertices.\n• Google maps uses Dijkstra algorithm to show shortest distance between source and destination.\n• computer networking , Dijkstra’s algorithm forms the basis for various routing protocols, such as OSPF (Open Shortest Path First) and IS-IS (Intermediate System to Intermediate System).\n• None Transportation and traffic management systems use Dijkstra’s algorithm to optimize traffic flow, minimize congestion, and plan the most efficient routes for vehicles.\n• None Airlines use Dijkstra’s algorithm to plan flight paths that minimize fuel consumption, reduce travel time.\n• None Dijkstra’s algorithm is applied in electronic design automation for routing connections on integrated circuits and very-large-scale integration (VLSI) chips.\n• None Shortest path with one curved edge in an undirected Graph\n• None 1st to Kth shortest path lengths in given Graph\n• None Number of ways to reach at destination in shortest time"
    },
    {
        "link": "https://tpointtech.com/cpp-dijkstra-algorithm-using-priority-queue",
        "document": "C++ Dijkstra Algorithm using the priority queue In this article, we will see the implementation of the Dijkstra algorithm using the priority queue of C++ STL. Dijkstra algorithm is used to find the shortest path from the source to the destination in an undirected graph. A graph having weight on the edges is given as below: Let us consider a source vertex 0, we have to find the shortest path from the source vertex to all the vertices in the graph. We will create a class Graph with data members as\n• int v - To store the number of vertices in the graph\n• List of pairs - To store the vertex and the weight associated with a particular vertex. We need a constructor to allocate the memory of the adjacency list. Graph(int vertex) { this->V = vertex; // Allocate the number of vertices adj = list<pair> [vertex]; // Allocate memory for adjacency list } How to add an edge to the graph? The list of pairs created has two arguments. One will contain the vertex, and the other will contain the weight associated with it. As the graph is bidirectional, we can add the same weight to the opposite vertex. void addanEdge(int u, int v, int w) { adj[u].push_back(make_pair(v,w)); // add v to w adj[v].push_back(make_pair(u,w)); add w to v // To add a vertex with weight associated with it }\n• Mark initial distance from the source is infinite.\n• Create an empty priority_queue PQ. Every item of PQ is a pair (weight, vertex). Weight (or distance) is used as the first item of pair as the first item is by default used to compare two pairs.\n• Insert source vertex into PQ and make its distance as 0.\n• Until the priority queue defined as PQ does not become empty. Perform the operations a and b.\n• Extract minimum distance vertex from PQ and let it be u.\n• Loop through all adjacent of u and do\n\nFollowing for every vertex v.\n\n// If there is a shorter path to v\n\n// through u.\n\nIf dist[v] > dist[u] + weight(u, v) // distance of ( v) > distance of (u) and weight from u to v\n• Insert v into the pq (Even if v is\n\nalready there)\n• Loop through the dist[] array to print the shortest paths from source to all the vertices. #include <bits/stdc++.h> using namespace std; #define INF 0x3f3f3f3f // The distance to other vertices is initialized as infinite // iPair ==> Integer Pair typedef pair<int, int> iPair; class Graph // Graph structure { int V; // No. of vertices in the graph list<pair<int, int>>* adj; // the list of pair to store vertex and its weight public: // Constructor that accept number of vertices in graph Graph(int V) // allocate the vertex memory { this->V = V; // assign the vertex adj = new list<iPair>[V]; // allocate space for vertices } void addEdge(int u, int v, int w); // add edges in the graph // prints shortest path from s void shortestPathingraph(int s); // pass source vertex }; void Graph::addEdge(int u, int v, int w) // add an edge { adj[u].push_back(make_pair(v, w)); // make a pair of vertex and weight and // add it to the list adj[v].push_back(make_pair(u, w)); // add oppositely by making a pair of weight and vertex } // Calling function outside the Graph class void Graph::shortestPathingraph(int src) // src is the source vertex { // Create a priority queue to store vertices that // are being preprocessed. priority_queue<iPair, vector<iPair>, greater<iPair>> pq; vector<int> dist(V, INF); // All distance from source are infinite pq.push(make_pair(0, src)); // push spurce node into the queue dist[src] = 0; // distance of source will be always 0 while (!pq.empty()) { // While queue is not empty // Extract the first minimum distance from the priority queue // vertex label is stored in second of pair (it // has to be done this way to keep the vertices // sorted distance int u = pq.top().second; pq.pop(); // 'i' is used to get all adjacent vertices of a vertex list<pair<int, int>>::iterator i; for (i = adj[u].begin(); i != adj[u].end(); ++i) { // Get vertex label and weight of current adjacent // of u. int v = (*i).first; int weight = (*i).second; // If there is shorted path to v through u. if (dist[v] > dist[u] + weight) { // Updating distance of v dist[v] = dist[u] + weight; pq.push(make_pair(dist[v], v)); } } } printf(\"Vertex \\tDistance from Source\n\n\"); // Print the result for (int i = 0; i < V; ++i) printf(\"%d \\t\\t %d\n\n\", i, dist[i]); // The shortest distance from source } int main() { int V = 9; // vertices in given graph are 9 Graph g(V); // call Constructor by creating an object of graph g.addEdge(0, 1, 4); // add root node with neighour vertex and weight g.addEdge(0, 7, 8); g.addEdge(1, 2, 8); g.addEdge(1, 7, 11); g.addEdge(2, 3, 7); g.addEdge(2, 8, 2); g.addEdge(2, 5, 4); g.addEdge(3, 4, 9); g.addEdge(3, 5, 14); g.addEdge(4, 5, 10); g.addEdge(5, 6, 2); g.addEdge(6, 7, 1); g.addEdge(6, 8, 6); g.addEdge(7, 8, 7); g.shortestPathingraph(0); // call the function to find shortest path of graph return 0; // end of main function() }"
    }
]