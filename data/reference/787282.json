[
    {
        "link": "https://petsc.org/main/manual/getting_started",
        "document": "Though PETSc has a large API, conceptually, it’s rather simple. There are three abstract basic data objects (classes): index sets, , vectors, , and matrices, . Plus, a larger number of abstract algorithm objects (classes) starting with: preconditioners, , Krylov solvers, , and so forth. Let represent any of these objects. Objects are created with The object is initially empty, and little can be done with it. A particular implementation of the class is associated with the object by setting the object’s “type”, where type is merely a string name of an implementation class using Some objects support subclasses, which are specializations of the type. These are set with For example, within one may do The abstract class can embody any ODE/DAE integrator scheme. This example creates an additive Runge-Kutta ODE/DAE IMEX integrator, whose type name is , using a 3rd-order scheme with an L-stable implicit part, whose subtype name is . To allow PETSc objects to be runtime configurable, PETSc objects provide a universal way of selecting types (classes) and subtypes at runtime from what is referred to as the PETSc “options database”. The code above can be replaced with now, both the type and subtype can be conveniently set from the command line The object’s type (implementation class) or subclass can also be changed at any time simply by calling again (though to override command line options, the call to must be made _after_ ). For example: Since the later call always overrides the earlier call, the second form shown is rarely – if ever – used, as it is less flexible than configuring command line settings. The standard methods on an object are of the general form. Particular types and subtypes of objects may have their own methods, which are given in the form where Name and SubName are the type and subtype names (for example, as above and . Most “set” operations have options database versions with the same names in lower case, separated by underscores, and with the word “set” removed. For example, can be set at the command line with A special subset of type-specific methods is ignored if the type does not match the function name. These are usually setter functions that control some aspect specific to the subtype. Note that we leveraged this functionality in the MPI example above (MPI Parallelism) by calling for a number of different matrix types. As another example, // ignored if the type is not KSPGMRES These allow cleaner application code since it does not have many if statements to avoid inactive methods. That is, one does not need to write code like Many “get” routines give one temporary access to an object’s internal data. They are used in the style Objects obtained with a “get” routine should be returned with a “restore” routine, generally within the same function. Objects obtained with a “create” routine should be freed with a “destroy” routine. There may be variants of the “get” routines that give more limited access to the obtained object. For example, // one can read but not write with x[] // don't forget to restore x after you are done with it Objects can be displayed (in a large number of ways) with Where is an abstract object that can represent standard output, an ASCII or binary file, a graphical window, etc. The second variant allows the user to delay until runtime the decision of what viewer and format to use to view the object or if to view the object at all. The user may wish to override or provide custom functionality in many situations. This is handled via callbacks, which the library will call at the appropriate time. The most general way to apply a callback has this form: where is a callback setter such as . is what will be called by the library, is an optional data structure (array, struct, PETSc object) that is used by and is an optional function that will be called when is destroyed to free anything in . The use of the allows users to “set and forget” data structures that will not be needed elsewhere but still need to be deleted when no longer needed. Here is an example of the use of a full-fledged callback Occasionally, routines to set callback functions take additional data objects that will be used by the object but are not context data for the function. For example, The vector is an optional argument provided by the user, which will be used as work-space by . Note that this callback does not provide a way for the user to have the destroyed when the object is destroyed; the users must ensure that they free it at an appropriate time. There is no logic to the various ways PETSc accepts callback functions in different places in the code. See Tao use of PETSc and callbacks for a cartoon on callbacks in ."
    },
    {
        "link": "https://petsc.org/release/manual/mat",
        "document": "PETSc provides a variety of matrix implementations because no single matrix format is appropriate for all problems. Currently, we support dense storage and compressed sparse row storage (both sequential and parallel versions) for CPU and GPU based matrices, as well as several specialized formats. Additional specialized formats can be easily added.\n\nThis chapter describes the basics of using PETSc matrices in general (regardless of the particular format chosen) and discusses tips for efficient use of the several simple uniprocess and parallel matrix types. The use of PETSc matrices involves the following actions: create a particular type of matrix, insert values into it, process the matrix, use the matrix for various computations, and finally destroy the matrix. The application code does not need to know or care about the particular storage formats of the matrices.\n\nSome people like to use matrix-free methods, which do not require explicit storage of the matrix, for the numerical solution of partial differential equations. Similarly, users may already have a custom matrix data structure and routines for that data structure and would like to wrap their code up into a ; that is, provide their own custom matrix type. To use the PETSc provided matrix-free matrix that uses finite differencing to approximate the matrix-vector product use , see Matrix-Free Methods. To provide your own matrix operations (such as ) use the following command to create a structure without ever actually generating the matrix: Here and are the global matrix dimensions (rows and columns), and are the local matrix dimensions, and is a pointer to data needed by any user-defined shell matrix operations; the manual page has additional details about these parameters. Most matrix-free algorithms require only the application of the linear operator to a vector. To provide this action, the user must write a routine with the calling sequence and then associate it with the matrix, , by using the command Here is the name of the operation for matrix-vector multiplication. Within each user-defined routine (such as ), the user should call to obtain the user-defined context, , that was set by . This shell matrix can be used with the iterative linear equation solvers discussed in the following chapters. The routine can be used to set any other matrix operations as well. The file (source) provides a complete list of matrix operations, which have the form , where is the name (in all capital letters) of the user interface routine (for example, \\(\\to\\) ). All user-provided functions have the same calling sequence as the usual matrix interface routines, since the user-defined functions are intended to be accessed through the same interface, e.g., \\(\\to\\) . The final argument for needs to be cast to a , since the final argument could (depending on the ) be a variety of different functions. Note that can also be used as a “backdoor” means of introducing user-defined changes in matrix operations for other storage formats (for example, to override the default LU factorization routine supplied within PETSc for the format). However, we urge anyone who introduces such changes to use caution, since it would be very easy to accidentally create a bug in the new routine that could affect other routines as well. See also Matrix-Free Methods for details on one set of helpful utilities for using the matrix-free approach for nonlinear solvers.\n\nIn many iterative calculations (for instance, in a nonlinear equations solver), it is important for efficiency purposes to reuse the nonzero structure of a matrix, rather than determining it anew every time the matrix is generated. To retain a given matrix but reinitialize its contents, one can employ This routine will zero the matrix entries in the data structure but keep all the data that indicates where the nonzeros are located. In this way a new matrix assembly will be much less expensive, since no memory allocations or copies will be needed. Of course, one can also explicitly set selected matrix elements to zero by calling . By default, if new entries are made in locations where no nonzeros previously existed, space will be allocated for the new entries. To prevent the allocation of additional memory and simply discard those new entries, one can use the option Once the matrix has been assembled, one can factor it numerically without repeating the ordering or the symbolic factorization. This option can save some computational time, although it does require that the factorization is not done in-place. In the numerical solution of elliptic partial differential equations, it can be cumbersome to deal with Dirichlet boundary conditions. In particular, one would like to assemble the matrix without regard to boundary conditions and then at the end apply the Dirichlet boundary conditions. In numerical analysis classes this process is usually presented as moving the known boundary conditions to the right-hand side and then solving a smaller linear system for the interior unknowns. Unfortunately, implementing this requires extracting a large submatrix from the original matrix and creating its corresponding data structures. This process can be expensive in terms of both time and memory. One simple way to deal with this difficulty is to replace those rows in the matrix associated with known boundary conditions, by rows of the identity matrix (or some scaling of it). This action can be done with the command For sparse matrices this removes the data structures for certain rows of the matrix. If the pointer is , it even removes the diagonal entry. If the pointer is not null, it uses that given value at the pointer location in the diagonal entry of the eliminated rows. One nice feature of this approach is that when solving a nonlinear problem such that at each iteration the Dirichlet boundary conditions are in the same positions and the matrix retains the same nonzero structure, the user can call in the first iteration. Then, before generating the matrix in the second iteration the user should call From that point, no new values will be inserted into those (boundary) rows of the matrix. The functions and can also be used if for each process one provides the Dirichlet locations in the local numbering of the matrix. A drawback of is that it destroys the symmetry of a matrix. Thus one can use Note that with all of these for a given assembled matrix it can be only called once to update the x and b vector. It cannot be used if one wishes to solve multiple right-hand side problems for the same matrix since the matrix entries needed for updating the b vector are removed in its first use. Once the zeroed rows are removed the new matrix has possibly many rows with only a diagonal entry affecting the parallel load balancing. The preconditioner removes all the zeroed rows (and associated columns and adjusts the right-hand side based on the removed columns) and then rebalances the resulting rows of smaller matrix across the processes. Thus one can use to set the Dirichlet points and then solve with the preconditioner . Note if the original matrix was symmetric the smaller solved matrix will also be symmetric. Another matrix routine of interest is which converts the matrix to new matrix, , that has either the same or different format. Set to to copy the matrix, keeping the same matrix format. See (source) for other available matrix types; standard ones are , , , and . In certain applications it may be necessary for application codes to directly access elements of a matrix. This may be done by using the the command (for local rows only) The argument returns the number of nonzeros in that row, while and returns the column indices (with indices starting at zero) and values in the row. If only the column indices are needed (and not the corresponding matrix elements), one can use for the argument. Similarly, one can use for the argument. The user can only examine the values extracted with ; the values cannot be altered. To change the matrix entries, one must use . Once the user has finished using a row, he or she must call to free any space that was allocated during the call to .\n\nMany sparse matrix operations can be optimized by dividing the computation into two stages: a symbolic stage that creates any required data structures and does all the computations that do not require the matrices’ numerical values followed by one or more uses of a numerical stage that use the symbolically computed information. Examples of such operations include , , , and . PETSc uses two different API’s to take advantage of these optimizations. The first approach explicitly divides the computation in the API. This approach is used, for example, with , . The caller can take advantage of their knowledge of changes in the nonzero structure of the sparse matrices to call the appropriate routines as needed. In fact, they can use to determine if a new symbolic computation is needed. The drawback of this approach is that the caller of these routines has to manage the creation of new matrices when the nonzero structure changes. The second approach, as exemplified by , does not expose the two stages explicit in the API, instead a flag, is passed through the API to indicate if a symbolic data structure is already available or needs to be computed. Thus is called first, then can be called repeatedly with new numerical values in the A matrix. In theory, if the nonzero structure of A changes, the symbolic computations for B could be redone automatically inside the same B matrix when there is a change in the nonzero state of the A matrix. In practice, in PETSc, the for most PETSc routines only works if the nonzero structure does not change and the code may crash otherwise. The advantage of this approach (when the nonzero structure changes are handled correctly) is that the calling code does not need to keep track of the nonzero state of the matrices; everything “just works”. However, the caller must still know when it is the first call to the routine so the flag is being used. If the underlying implementation language supported detecting a yet to be initialized variable at run time, the flag would not be need. PETSc uses two approaches because the same programming problem was solved with two different ways during PETSc’s early development. A better model would combine both approaches; an explicit separation of the stages and a unified operation that internally utilized the two stages appropriately and also handled changes to the nonzero structure. Code could be simplified in many places with this approach, in most places the use of the unified API would replace the use of the separate stages.\n\nFor almost all unstructured grid computation, the distribution of portions of the grid across the process’s work load and memory can have a very large impact on performance. In most PDE calculations the grid partitioning and distribution across the processes can (and should) be done in a “pre-processing” step before the numerical computations. However, this does not mean it need be done in a separate, sequential program; rather, it should be done before one sets up the parallel grid data structures in the actual program. PETSc provides an interface to the ParMETIS (developed by George Karypis; see the PETSc installation instructions for directions on installing PETSc to use ParMETIS) to allow the partitioning to be done in parallel. PETSc does not currently provide directly support for dynamic repartitioning, load balancing by migrating matrix entries between processes, etc. For problems that require mesh refinement, PETSc uses the “rebuild the data structure” approach, as opposed to the “maintain dynamic data structures that support the insertion/deletion of additional vector and matrix rows and columns entries” approach. Partitioning in PETSc is organized around the object. One first creates a parallel matrix that contains the connectivity information about the grid (or other graph-type object) that is to be partitioned. This is done with the command The argument indicates the number of rows of the graph being provided by the given process, is the total number of columns; equal to the sum of all the . The arguments and are the row pointers and column pointers for the given rows; these are the usual format for parallel compressed sparse row storage, using indices starting at 0, not 1. This, of course, assumes that one has already distributed the grid (graph) information among the processes. The details of this initial distribution is not important; it could be simply determined by assigning to the first process the first \\(n_0\\) nodes from a file, the second process the next \\(n_1\\) nodes, etc. For example, we demonstrate the form of the and for a triangular grid where we Note that elements are not connected to themselves and we only indicate edge connections (in some contexts single vertex connections between elements may also be included). We use a space above to denote the transition between rows in the matrix; and Once the connectivity matrix has been created the following code will generate the renumbering required for the new partition The resulting contains for each local node the new global number of that node. The resulting contains the new process number that each local node has been assigned to. Now that a new numbering of the nodes has been determined, one must renumber all the nodes and migrate the grid information to the correct process. The command generates, see Application Orderings, an object that can be used in conjunction with the and to move the relevant grid information to the correct process and renumber the nodes etc. In this context, the new ordering is the “application” ordering so converts old global indices to new global indices and converts new global indices back to old global indices. PETSc does not currently provide tools that completely manage the migration and node renumbering, since it will be dependent on the particular data structure you use to store the grid information and the type of grid information that you need for your application. We do plan to include more support for this in the future, but designing the appropriate general user interface and providing a scalable implementation that can be used for a wide variety of different grids requires a great deal of time. See Finite Difference Jacobian Approximations and Matrix Factorization for discussions on performing graph coloring and computing graph reorderings to reduce fill in sparse matrix factorizations. Jennifer B Erway and Roummel F Marcia. On solving large-scale limited-memory quasi-newton equations. Linear Algebra and its Applications, 515:196–225, 2017. Jennifer B Erway and Roummel F Marcia. On solving large-scale limited-memory quasi-Newton equations. Linear Algebra and its Applications, 515:196–225, 2017. J. C. Gilbert and C. Lemarechal. Some numerical experiments with variable-storage quasi-newton algorithms. Mathematical Programming, 45:407–434, 1989. Andreas Griewank. Broyden updating, the good and the bad! Optimization Stories, Documenta Mathematica. Extra Volume: Optimization Stories, pages 301–315, 2012."
    },
    {
        "link": "https://petsc.org/release/manualpages/Mat/MatCreateTranspose",
        "document": "Creates a new matrix object that behaves like A’\n\nThe transpose A’ is NOT actually formed! Rather the new matrix object performs the matrix-vector product by using the on the original matrix"
    },
    {
        "link": "https://publications.anl.gov/anlpubs/2019/12/155920.pdf",
        "document": ""
    },
    {
        "link": "https://petsc.org/release/faq",
        "document": ""
    },
    {
        "link": "https://petsc.org/release/manual/mat",
        "document": "PETSc provides a variety of matrix implementations because no single matrix format is appropriate for all problems. Currently, we support dense storage and compressed sparse row storage (both sequential and parallel versions) for CPU and GPU based matrices, as well as several specialized formats. Additional specialized formats can be easily added.\n\nThis chapter describes the basics of using PETSc matrices in general (regardless of the particular format chosen) and discusses tips for efficient use of the several simple uniprocess and parallel matrix types. The use of PETSc matrices involves the following actions: create a particular type of matrix, insert values into it, process the matrix, use the matrix for various computations, and finally destroy the matrix. The application code does not need to know or care about the particular storage formats of the matrices.\n\nSome people like to use matrix-free methods, which do not require explicit storage of the matrix, for the numerical solution of partial differential equations. Similarly, users may already have a custom matrix data structure and routines for that data structure and would like to wrap their code up into a ; that is, provide their own custom matrix type. To use the PETSc provided matrix-free matrix that uses finite differencing to approximate the matrix-vector product use , see Matrix-Free Methods. To provide your own matrix operations (such as ) use the following command to create a structure without ever actually generating the matrix: Here and are the global matrix dimensions (rows and columns), and are the local matrix dimensions, and is a pointer to data needed by any user-defined shell matrix operations; the manual page has additional details about these parameters. Most matrix-free algorithms require only the application of the linear operator to a vector. To provide this action, the user must write a routine with the calling sequence and then associate it with the matrix, , by using the command Here is the name of the operation for matrix-vector multiplication. Within each user-defined routine (such as ), the user should call to obtain the user-defined context, , that was set by . This shell matrix can be used with the iterative linear equation solvers discussed in the following chapters. The routine can be used to set any other matrix operations as well. The file (source) provides a complete list of matrix operations, which have the form , where is the name (in all capital letters) of the user interface routine (for example, \\(\\to\\) ). All user-provided functions have the same calling sequence as the usual matrix interface routines, since the user-defined functions are intended to be accessed through the same interface, e.g., \\(\\to\\) . The final argument for needs to be cast to a , since the final argument could (depending on the ) be a variety of different functions. Note that can also be used as a “backdoor” means of introducing user-defined changes in matrix operations for other storage formats (for example, to override the default LU factorization routine supplied within PETSc for the format). However, we urge anyone who introduces such changes to use caution, since it would be very easy to accidentally create a bug in the new routine that could affect other routines as well. See also Matrix-Free Methods for details on one set of helpful utilities for using the matrix-free approach for nonlinear solvers.\n\nIn many iterative calculations (for instance, in a nonlinear equations solver), it is important for efficiency purposes to reuse the nonzero structure of a matrix, rather than determining it anew every time the matrix is generated. To retain a given matrix but reinitialize its contents, one can employ This routine will zero the matrix entries in the data structure but keep all the data that indicates where the nonzeros are located. In this way a new matrix assembly will be much less expensive, since no memory allocations or copies will be needed. Of course, one can also explicitly set selected matrix elements to zero by calling . By default, if new entries are made in locations where no nonzeros previously existed, space will be allocated for the new entries. To prevent the allocation of additional memory and simply discard those new entries, one can use the option Once the matrix has been assembled, one can factor it numerically without repeating the ordering or the symbolic factorization. This option can save some computational time, although it does require that the factorization is not done in-place. In the numerical solution of elliptic partial differential equations, it can be cumbersome to deal with Dirichlet boundary conditions. In particular, one would like to assemble the matrix without regard to boundary conditions and then at the end apply the Dirichlet boundary conditions. In numerical analysis classes this process is usually presented as moving the known boundary conditions to the right-hand side and then solving a smaller linear system for the interior unknowns. Unfortunately, implementing this requires extracting a large submatrix from the original matrix and creating its corresponding data structures. This process can be expensive in terms of both time and memory. One simple way to deal with this difficulty is to replace those rows in the matrix associated with known boundary conditions, by rows of the identity matrix (or some scaling of it). This action can be done with the command For sparse matrices this removes the data structures for certain rows of the matrix. If the pointer is , it even removes the diagonal entry. If the pointer is not null, it uses that given value at the pointer location in the diagonal entry of the eliminated rows. One nice feature of this approach is that when solving a nonlinear problem such that at each iteration the Dirichlet boundary conditions are in the same positions and the matrix retains the same nonzero structure, the user can call in the first iteration. Then, before generating the matrix in the second iteration the user should call From that point, no new values will be inserted into those (boundary) rows of the matrix. The functions and can also be used if for each process one provides the Dirichlet locations in the local numbering of the matrix. A drawback of is that it destroys the symmetry of a matrix. Thus one can use Note that with all of these for a given assembled matrix it can be only called once to update the x and b vector. It cannot be used if one wishes to solve multiple right-hand side problems for the same matrix since the matrix entries needed for updating the b vector are removed in its first use. Once the zeroed rows are removed the new matrix has possibly many rows with only a diagonal entry affecting the parallel load balancing. The preconditioner removes all the zeroed rows (and associated columns and adjusts the right-hand side based on the removed columns) and then rebalances the resulting rows of smaller matrix across the processes. Thus one can use to set the Dirichlet points and then solve with the preconditioner . Note if the original matrix was symmetric the smaller solved matrix will also be symmetric. Another matrix routine of interest is which converts the matrix to new matrix, , that has either the same or different format. Set to to copy the matrix, keeping the same matrix format. See (source) for other available matrix types; standard ones are , , , and . In certain applications it may be necessary for application codes to directly access elements of a matrix. This may be done by using the the command (for local rows only) The argument returns the number of nonzeros in that row, while and returns the column indices (with indices starting at zero) and values in the row. If only the column indices are needed (and not the corresponding matrix elements), one can use for the argument. Similarly, one can use for the argument. The user can only examine the values extracted with ; the values cannot be altered. To change the matrix entries, one must use . Once the user has finished using a row, he or she must call to free any space that was allocated during the call to .\n\nMany sparse matrix operations can be optimized by dividing the computation into two stages: a symbolic stage that creates any required data structures and does all the computations that do not require the matrices’ numerical values followed by one or more uses of a numerical stage that use the symbolically computed information. Examples of such operations include , , , and . PETSc uses two different API’s to take advantage of these optimizations. The first approach explicitly divides the computation in the API. This approach is used, for example, with , . The caller can take advantage of their knowledge of changes in the nonzero structure of the sparse matrices to call the appropriate routines as needed. In fact, they can use to determine if a new symbolic computation is needed. The drawback of this approach is that the caller of these routines has to manage the creation of new matrices when the nonzero structure changes. The second approach, as exemplified by , does not expose the two stages explicit in the API, instead a flag, is passed through the API to indicate if a symbolic data structure is already available or needs to be computed. Thus is called first, then can be called repeatedly with new numerical values in the A matrix. In theory, if the nonzero structure of A changes, the symbolic computations for B could be redone automatically inside the same B matrix when there is a change in the nonzero state of the A matrix. In practice, in PETSc, the for most PETSc routines only works if the nonzero structure does not change and the code may crash otherwise. The advantage of this approach (when the nonzero structure changes are handled correctly) is that the calling code does not need to keep track of the nonzero state of the matrices; everything “just works”. However, the caller must still know when it is the first call to the routine so the flag is being used. If the underlying implementation language supported detecting a yet to be initialized variable at run time, the flag would not be need. PETSc uses two approaches because the same programming problem was solved with two different ways during PETSc’s early development. A better model would combine both approaches; an explicit separation of the stages and a unified operation that internally utilized the two stages appropriately and also handled changes to the nonzero structure. Code could be simplified in many places with this approach, in most places the use of the unified API would replace the use of the separate stages.\n\nFor almost all unstructured grid computation, the distribution of portions of the grid across the process’s work load and memory can have a very large impact on performance. In most PDE calculations the grid partitioning and distribution across the processes can (and should) be done in a “pre-processing” step before the numerical computations. However, this does not mean it need be done in a separate, sequential program; rather, it should be done before one sets up the parallel grid data structures in the actual program. PETSc provides an interface to the ParMETIS (developed by George Karypis; see the PETSc installation instructions for directions on installing PETSc to use ParMETIS) to allow the partitioning to be done in parallel. PETSc does not currently provide directly support for dynamic repartitioning, load balancing by migrating matrix entries between processes, etc. For problems that require mesh refinement, PETSc uses the “rebuild the data structure” approach, as opposed to the “maintain dynamic data structures that support the insertion/deletion of additional vector and matrix rows and columns entries” approach. Partitioning in PETSc is organized around the object. One first creates a parallel matrix that contains the connectivity information about the grid (or other graph-type object) that is to be partitioned. This is done with the command The argument indicates the number of rows of the graph being provided by the given process, is the total number of columns; equal to the sum of all the . The arguments and are the row pointers and column pointers for the given rows; these are the usual format for parallel compressed sparse row storage, using indices starting at 0, not 1. This, of course, assumes that one has already distributed the grid (graph) information among the processes. The details of this initial distribution is not important; it could be simply determined by assigning to the first process the first \\(n_0\\) nodes from a file, the second process the next \\(n_1\\) nodes, etc. For example, we demonstrate the form of the and for a triangular grid where we Note that elements are not connected to themselves and we only indicate edge connections (in some contexts single vertex connections between elements may also be included). We use a space above to denote the transition between rows in the matrix; and Once the connectivity matrix has been created the following code will generate the renumbering required for the new partition The resulting contains for each local node the new global number of that node. The resulting contains the new process number that each local node has been assigned to. Now that a new numbering of the nodes has been determined, one must renumber all the nodes and migrate the grid information to the correct process. The command generates, see Application Orderings, an object that can be used in conjunction with the and to move the relevant grid information to the correct process and renumber the nodes etc. In this context, the new ordering is the “application” ordering so converts old global indices to new global indices and converts new global indices back to old global indices. PETSc does not currently provide tools that completely manage the migration and node renumbering, since it will be dependent on the particular data structure you use to store the grid information and the type of grid information that you need for your application. We do plan to include more support for this in the future, but designing the appropriate general user interface and providing a scalable implementation that can be used for a wide variety of different grids requires a great deal of time. See Finite Difference Jacobian Approximations and Matrix Factorization for discussions on performing graph coloring and computing graph reorderings to reduce fill in sparse matrix factorizations. Jennifer B Erway and Roummel F Marcia. On solving large-scale limited-memory quasi-newton equations. Linear Algebra and its Applications, 515:196–225, 2017. Jennifer B Erway and Roummel F Marcia. On solving large-scale limited-memory quasi-Newton equations. Linear Algebra and its Applications, 515:196–225, 2017. J. C. Gilbert and C. Lemarechal. Some numerical experiments with variable-storage quasi-newton algorithms. Mathematical Programming, 45:407–434, 1989. Andreas Griewank. Broyden updating, the good and the bad! Optimization Stories, Documenta Mathematica. Extra Volume: Optimization Stories, pages 301–315, 2012."
    },
    {
        "link": "https://mcs.anl.gov/petsc/documentation/tutorials/INL05/tutorial.pdf",
        "document": ""
    },
    {
        "link": "https://petsc.org/release/manual/getting_started",
        "document": "Though PETSc has a large API, conceptually, it’s rather simple. There are three abstract basic data objects (classes): index sets, , vectors, , and matrices, . Plus, a larger number of abstract algorithm objects (classes) starting with: preconditioners, , Krylov solvers, , and so forth. Let represent any of these objects. Objects are created with The object is initially empty, and little can be done with it. A particular implementation of the class is associated with the object by setting the object’s “type”, where type is merely a string name of an implementation class using Some objects support subclasses, which are specializations of the type. These are set with For example, within one may do The abstract class can embody any ODE/DAE integrator scheme. This example creates an additive Runge-Kutta ODE/DAE IMEX integrator, whose type name is , using a 3rd-order scheme with an L-stable implicit part, whose subtype name is . To allow PETSc objects to be runtime configurable, PETSc objects provide a universal way of selecting types (classes) and subtypes at runtime from what is referred to as the PETSc “options database”. The code above can be replaced with now, both the type and subtype can be conveniently set from the command line The object’s type (implementation class) or subclass can also be changed at any time simply by calling again (though to override command line options, the call to must be made _after_ ). For example: Since the later call always overrides the earlier call, the second form shown is rarely – if ever – used, as it is less flexible than configuring command line settings. The standard methods on an object are of the general form. Particular types and subtypes of objects may have their own methods, which are given in the form where Name and SubName are the type and subtype names (for example, as above and . Most “set” operations have options database versions with the same names in lower case, separated by underscores, and with the word “set” removed. For example, can be set at the command line with A special subset of type-specific methods is ignored if the type does not match the function name. These are usually setter functions that control some aspect specific to the subtype. Note that we leveraged this functionality in the MPI example above (MPI Parallelism) by calling for a number of different matrix types. As another example, // ignored if the type is not KSPGMRES These allow cleaner application code since it does not have many if statements to avoid inactive methods. That is, one does not need to write code like Many “get” routines give one temporary access to an object’s internal data. They are used in the style Objects obtained with a “get” routine should be returned with a “restore” routine, generally within the same function. Objects obtained with a “create” routine should be freed with a “destroy” routine. There may be variants of the “get” routines that give more limited access to the obtained object. For example, // one can read but not write with x[] // don't forget to restore x after you are done with it Objects can be displayed (in a large number of ways) with Where is an abstract object that can represent standard output, an ASCII or binary file, a graphical window, etc. The second variant allows the user to delay until runtime the decision of what viewer and format to use to view the object or if to view the object at all. The user may wish to override or provide custom functionality in many situations. This is handled via callbacks, which the library will call at the appropriate time. The most general way to apply a callback has this form: where is a callback setter such as . is what will be called by the library, is an optional data structure (array, struct, PETSc object) that is used by and is an optional function that will be called when is destroyed to free anything in . The use of the allows users to “set and forget” data structures that will not be needed elsewhere but still need to be deleted when no longer needed. Here is an example of the use of a full-fledged callback Occasionally, routines to set callback functions take additional data objects that will be used by the object but are not context data for the function. For example, The vector is an optional argument provided by the user, which will be used as work-space by . Note that this callback does not provide a way for the user to have the destroyed when the object is destroyed; the users must ensure that they free it at an appropriate time. There is no logic to the various ways PETSc accepts callback functions in different places in the code. See Tao use of PETSc and callbacks for a cartoon on callbacks in ."
    },
    {
        "link": "https://mcs.anl.gov/petsc/petsc-3.5/src/mat/interface/matrix.c.html",
        "document": ""
    },
    {
        "link": "https://petsc.org/main/src/mat/interface/matrix.c.html",
        "document": ""
    }
]