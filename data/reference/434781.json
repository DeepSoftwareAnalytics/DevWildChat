[
    {
        "link": "https://paypal.com/us/cshelp/article/how-do-i-convert-my-pem-format-certificate-to-pkcs12-ts1020",
        "document": "To convert your PEM certificate to a PKCS12 certificate, use a third-party tool. PayPal recommends OpenSSL, which you can download at www.openssl.org . The following instructions assume that you retain the default certificate filename of \"cert_key_pem.txt.\"\n\n1. Open a command prompt and navigate to the directory that contains the cert_key_pem.txt file.\n\n2. Execute the following OpenSSL command to create a PKCS12 (.p12) file:\n\n\n\nopenssl pkcs12 -export -inkey cert_key_pem.txt -in cert_key_pem.txt -out cert_key.p12\n\n\n\nNote: To convert a PKCS12 certificate to PEM, use the following command:\n\n\n\nopenssl pkcs12 -in cert_key.p12 -out cert_key.pem -nodes\n\n\n\n3. After you enter the command, you'll be prompted to enter an Export Password. Choose a password or phrase and note the value you enter (PayPal Developer documentation calls this the \"private key password.\") \n\n4. A file called cert_key.p12 is created in this directory. This is your .p12 file."
    },
    {
        "link": "https://paypal.com/na/cshelp/article/how-do-i-convert-my-pem-format-certificate-to-pkcs12-ts1020",
        "document": "To convert your PEM certificate to a PKCS12 certificate, use a third-party tool. PayPal recommends OpenSSL, which you can download at www.openssl.org . The following instructions assume that you retain the default certificate filename of \"cert_key_pem.txt.\"\n\n1. Open a command prompt and navigate to the directory that contains the cert_key_pem.txt file.\n\n2. Execute the following OpenSSL command to create a PKCS12 (.p12) file:\n\n\n\nopenssl pkcs12 -export -inkey cert_key_pem.txt -in cert_key_pem.txt -out cert_key.p12\n\n\n\nNote: To convert a PKCS12 certificate to PEM, use the following command:\n\n\n\nopenssl pkcs12 -in cert_key.p12 -out cert_key.pem -nodes\n\n\n\n3. After you enter the command, you'll be prompted to enter an Export Password. Choose a password or phrase and note the value you enter (PayPal Developer documentation calls this the \"private key password.\") \n\n4. A file called cert_key.p12 is created in this directory. This is your .p12 file."
    },
    {
        "link": "https://stackoverflow.com/questions/15144046/converting-pkcs12-certificate-into-pem-using-openssl",
        "document": "I have OpenSSL x64 on Windows 7 which I downloaded from openssl-for-windows on Google Code. I'm attempting to run:\n\nbut I get an error.\n\nHow do I extract the certificate in PEM from PKCS#12 store using OpenSSL?"
    },
    {
        "link": "https://help.hcl-software.com/appscan/Standard/10.0.1/en-US/t_ConvertthepfxCertificatetopemFormat068.html",
        "document": "PEM certificates are not supported, they must be converted to PKCS#12 (PFX/P12) format.\n\nThis conversion can be done using an external tool such as OpenSSL, as described below."
    },
    {
        "link": "https://stackoverflow.com/questions/10994116/openssl-convert-pem-containing-only-rsa-private-key-to-pkcs12",
        "document": "Currently I have a .PEM file containing only a private key. I need to convert this file into a .PKCS12 file. Currently I'm trying to use openssl to achieve this and I'm running into some problems.\n\nThe .PEM file I'm using is of the form:\n\nI use the following Openssl command to attempt to convert this .PEM file into a .PKCS12:\n\nThe console then hangs with the message:\n\nWhat am Im doing wrong?\n\nAny help would be appriciated."
    },
    {
        "link": "https://stackoverflow.com/questions/16244182/need-help-converting-p12-certificate-into-jks",
        "document": "Here are some great answers, but I have figured out, in some cases some p12 certificates may not work under some circumstances if converted to jks. For example we had the jks, generated in keytool from Java 11, which were OK for the application running in tomcat 9 on Java 11, but certificate created in the same way then did not work in Tomcat 10 with java 17 in the case the application runs in the compatibility mode with the old javax libraries, so there is not clear, which libraries are in the reality how used for the access of the jks keystore from Java application.\n\nWe then got the \"Invalid keystore format\" exceptions for such keystores on such infrastructure.\n\nAlso is important with which Java version the keytool is keystore is generated.\n\nBut I got the information, if the PKCS12 keystore is once \"prepared to be fully java-compatible\" - please do not ask me, what does it mean :-) - then it works - it seems not all p12 certificates are the same. And really, this also was our case - so in the case you need to store in jks the client certificate originally delivered in p12 format to access some remote service as the client, then you might find this script handsome - it first reconverts the p12 certificate through pem and then creates the jks keystore and then also renames the imported key in the keystore to be named with the alias which is requested.\n\nIt is called for example like this (the above script is in file ):"
    },
    {
        "link": "https://docs.oracle.com/en/database/other-databases/nosql-database/24.4/security/import-key-pair-java-keystore.html",
        "document": "This section describes how to import an existing private/public key pair into Java keystore. This is useful if you have your own tools for generating a CA signed key pair. The procedure assumes you already have the root and intermediate certificates as well as the private key and its signed certificate.\n• Build the certificate chain and convert the private key and certificate files into a PKCS12 file.\n• Finally, to complete the preparation of the Java keystore, perform the procedures for creating the server and client truststore described in the previous section."
    },
    {
        "link": "https://stackoverflow.com/questions/32116235/how-do-i-import-a-pkcs12-certificate-into-a-java-keystore",
        "document": "To learn more, see our tips on writing great answers .\n\nThanks for contributing an answer to Stack Overflow!\n\nBy clicking “Post Your Answer”, you agree to our terms of service and acknowledge you have read our privacy policy."
    },
    {
        "link": "https://webfarmr.eu/import-pkcs12-private-keys-into-jks-keystores-using-java-keytool",
        "document": "This is very simple yet when I googled around I saw erratic answers such as ‘it is not possible’ or ‘you have to write java code’.\n\nAs a matter of fact, keytool (a key management utility shipped in Sun’s JDK) lets you do it simply.\n• What do you want to do?\n\n Convert alice.p12 to alice.jks\n• Why do you want to do that?\n\n In Metro, a WS stack, it is common to use JKS as a format for storing private keys\n• How do you convert then?\n\n See below\n\n\n\n Keytool’s documentation refers to the following option\n\nSo in fact in our case, converting from alice.p12 to alice.jks is extremely simple:"
    },
    {
        "link": "https://docs.oracle.com/en/java/javase/17/docs/specs/man/keytool.html",
        "document": "The command is a key and certificate management utility. It enables users to administer their own public/private key pairs and associated certificates for use in self-authentication (where a user authenticates themselves to other users and services) or data integrity and authentication services, by using digital signatures. The command also enables users to cache the public keys (in the form of certificates) of their communicating peers.\n\nA certificate is a digitally signed statement from one entity (person, company, and so on), which says that the public key (and some other information) of some other entity has a particular value. When data is digitally signed, the signature can be verified to check the data integrity and authenticity. Integrity means that the data hasn't been modified or tampered with, and authenticity means that the data comes from the individual who claims to have created and signed it.\n\nThe command also enables users to administer secret keys and passphrases used in symmetric encryption and decryption (Data Encryption Standard). It can also display other security-related information.\n\nThe command stores the keys and certificates in a keystore.\n\nThe command uses the and security properties to determine which algorithms are considered a security risk. It emits warnings when disabled or legacy algorithms are being used. The and security properties are defined in the file (located in the JDK's directory).\n\nThe following notes apply to the descriptions in Commands and Options:\n• None All command and option names are preceded by a hyphen sign ( ).\n• None Only one command can be provided.\n• None Options for each command can be provided in any order.\n• None There are two kinds of options, one is single-valued which should be only provided once. If a single-valued option is provided multiple times, the value of the last one is used. The other type is multi-valued, which can be provided multiple times and all values are used. The only multi-valued option currently supported is the option used to generate X.509v3 certificate extensions.\n• None All items not italicized or in braces ({ }) or brackets ([ ]) are required to appear as is.\n• None Braces surrounding an option signify that a default value is used when the option isn't specified on the command line. Braces are also used around the , , and options, which have meaning only when they appear on the command line. They don't have any default values.\n• None Brackets surrounding an option signify that the user is prompted for the values when the option isn't specified on the command line. For the option, if you don't specify the option on the command line, then the command first attempts to use the keystore password to recover the private/secret key. If this attempt fails, then the command prompts you for the private/secret key password.\n• None Items in italics (option values) represent the actual values that must be supplied. For example, here is the format of the command: When you specify a command, replace cert_file with the actual file name, as follows:\n• None Option values must be enclosed in quotation marks when they contain a blank (space).\n\nThe keytool commands and their options can be grouped by the tasks that they perform.\n\nCommands for Creating or Adding Data to the Keystore:\n\nCommands for Importing Contents from Another Keystore:\n\nCommands for Creating or Adding Data to the Keystore\n\nThe following are the available options for the command:\n• None { alias}: Alias name of the entry to process\n• None { name [ arg]}: Adds a security provider by name (such as SunPKCS11) with an optional configure argument. The value of the security provider is the name of a security provider that is defined in a module. For compatibility reasons, the SunPKCS11 provider can still be loaded with even if it is now defined in a module. This is the only module included in the JDK that needs a configuration, and therefore the most widely used with the option. For legacy security providers located on classpath and loaded by reflection, should still be used.\n• None { class [ arg]}: Add security provider by fully qualified class name with an optional configure argument. For example, if is a legacy provider loaded via reflection, Use the command to generate a certificate as a response to a certificate request file (which can be created by the command). The command reads the request either from infile or, if omitted, from the standard input, signs it by using the alias's private key, and outputs the X.509 certificate into either outfile or, if omitted, to the standard output. When is specified, the output format is Base64-encoded PEM; otherwise, a binary DER is created. The value specifies the algorithm that should be used to sign the certificate. The startdate argument is the start time and date that the certificate is valid. The days argument tells the number of days for which the certificate should be considered valid. When dname is provided, it is used as the subject of the generated certificate. Otherwise, the one from the certificate request is used. The value shows what X.509 extensions will be embedded in the certificate. Read Common Command Options for the grammar of . The option enables you to create certificate chains. The following example creates a certificate, , that contains three certificates in its certificate chain. The following commands creates four key pairs named , , , and : The following two commands create a chain of signed certificates; signs and signs , all of which are self-issued: The following command creates the certificate and stores it in the file, which is signed by . As a result, should contain , , and in its certificate chain: The following are the available options for the command:\n• None { alias}: Alias name of the entry to process\n• None { name}: Group name. For example, an Elliptic Curve name.\n• None { name [ arg]}: Add security provider by name (such as SunPKCS11) with an optional configure argument.\n• None { class [ arg] }: Add security provider by fully qualified class name with an optional configure argument. Use the command to generate a key pair (a public key and associated private key). When the option is not specified, the public key is wrapped in an X.509 v3 self-signed certificate and stored as a single-element certificate chain. When the option is specified, a new certificate is generated and signed by the designated signer and stored as a multiple-element certificate chain (containing the generated certificate itself, and the signer???s certificate chain). The certificate chain and private key are stored in a new keystore entry that is identified by its alias. The value specifies the algorithm to be used to generate the key pair, and the value specifies the size of each key to be generated. The value specifies the algorithm that should be used to sign the certificate. This algorithm must be compatible with the value. The value specifies the named group (for example, the standard or predefined name of an Elliptic Curve) of the key to be generated. Only one of and can be specified. The value specifies the alias of a for the signer that already exists in the keystore. This option is used to sign the certificate with the signer???s private key. This is especially useful for key agreement algorithms (i.e. the value is , , , or ) as these keys cannot be used for digital signatures, and therefore a self-signed certificate cannot be created. The value specifies the password of the signer???s private key. It can be specified if the private key of the signer entry is protected by a password different from the store password. The value specifies the X.500 Distinguished Name to be associated with the value of . If the option is not specified, the issuer and subject fields of the self-signed certificate are populated with the specified distinguished name. If the option is specified, the subject field of the certificate is populated with the specified distinguished name and the issuer field is populated with the subject field of the signer's certificate. If a distinguished name is not provided at the command line, then the user is prompted for one. The value of is a password used to protect the private key of the generated key pair. If a password is not provided, then the user is prompted for it. If you press the Return key at the prompt, then the key password is set to the same password as the keystore password. The value must have at least six characters. The value of specifies the issue time of the certificate, also known as the \"Not Before\" value of the X.509 certificate's Validity field. The option value can be set in one of these two forms: With the first form, the issue time is shifted by the specified value from the current time. The value is a concatenation of a sequence of subvalues. Inside each subvalue, the plus sign (+) means shift forward, and the minus sign (-) means shift backward. The time to be shifted is nnn units of years, months, days, hours, minutes, or seconds (denoted by a single character of , , , , , or respectively). The exact value of the issue time is calculated by using the method on each subvalue, from left to right. For example, the issue time can be specified by: With the second form, the user sets the exact issue time in two parts, year/month/day and hour:minute:second (using the local time zone). The user can provide only one part, which means the other part is the same as the current date (or time). The user must provide the exact number of digits shown in the format definition (padding with 0 when shorter). When both date and time are provided, there is one (and only one) space character between the two parts. The hour should always be provided in 24-hour format. When the option isn't provided, the start date is the current time. The option can only be provided one time. The value of date specifies the number of days (starting at the date specified by , or the current date when isn't specified) for which the certificate should be considered valid. The following are the available options for the command:\n• None { alias}: Alias name of the entry to process\n• None { name [ arg]}: Add security provider by name (such as SunPKCS11) with an optional configure argument.\n• None { class [ arg]}: Add security provider by fully qualified class name with an optional configure argument. Use the command to generate a secret key and store it in a new identified by . The value of specifies the algorithm to be used to generate the secret key, and the value of specifies the size of the key that is generated. The value is a password that protects the secret key. If a password is not provided, then the user is prompted for it. If you press the Return key at the prompt, then the key password is set to the same password that is used for the . The value must contain at least six characters. The following are the available options for the command:\n• None { alias}: Alias name of the entry to process\n• None { name [ arg]}: Add security provider by name (such as SunPKCS11) with an optional configure argument.\n• None { class [ arg]}: Add security provider by fully qualified class name with an optional configure argument. Use the command to read the certificate or certificate chain (where the latter is supplied in a PKCS#7 formatted reply or in a sequence of X.509 certificates) from file, and store it in the entry identified by . If file is not specified, then the certificate or certificate chain is read from . The command can import X.509 v1, v2, and v3 certificates, and PKCS#7 formatted certificate chains consisting of certificates of that type. The data to be imported must be provided either in binary encoding format or in printable encoding format (also known as Base64 encoding) as defined by the Internet RFC 1421 standard. In the latter case, the encoding must be bounded at the beginning by a string that starts with , and bounded at the end by a string that starts with . You import a certificate for two reasons: To add it to the list of trusted certificates, and to import a certificate reply received from a certificate authority (CA) as the result of submitting a Certificate Signing Request (CSR) to that CA. See the command in Commands for Generating a Certificate Request. The type of import is indicated by the value of the option. If the alias doesn't point to a key entry, then the command assumes you are adding a trusted certificate entry. In this case, the alias shouldn't already exist in the keystore. If the alias does exist, then the command outputs an error because a trusted certificate already exists for that alias, and doesn't import the certificate. If points to a key entry, then the command assumes that you're importing a certificate reply. The following are the available options for the command:\n• None { alias}: Alias name of the entry to process\n• None { name [ arg]}: Add security provider by name (such as SunPKCS11) with an optional configure argument.\n• None { class [ arg]}: Add security provider by fully qualified class name with an optional configure argument. Use the command to imports a passphrase and store it in a new identified by . The passphrase may be supplied via the standard input stream; otherwise the user is prompted for it. The option provides a password to protect the imported passphrase. If a password is not provided, then the user is prompted for it. If you press the Return key at the prompt, then the key password is set to the same password as that used for the . The value must contain at least six characters.\n\nCommands for Importing Contents from Another Keystore\n\nYou can use to display a list of commands or to display help information about a specific command.\n• None To display help information about a specific command, enter:\n\nThe option can appear for all commands except . When the option appears, it signifies verbose mode, which means that more information is provided in the output.\n\nThe option argument can appear for any command. When the option is used, the specified option string is passed directly to the Java interpreter. This option doesn't contain any spaces. It's useful for adjusting the execution environment or memory usage. For a list of possible interpreter options, enter or at the command line.\n\nThese options can appear for all commands operating on a keystore:\n\nA pre-configured options file is a Java properties file that can be specified with the option. Each property represents the default option(s) for a keytool command using \"keytool.command_name\" as the property name. A special property named \"keytool.all\" represents the default option(s) applied to all commands. A property value can include which will be expanded to the system property associated with it. If an option value includes white spaces inside, it should be surrounded by quotation marks (\" or '). All property names must be in lower case.\n\nWhen is launched with a pre-configured options file, the value for \"keytool.all\" (if it exists) is prepended to the command line first, with the value for the command name (if it exists) comes next, and the existing options on the command line at last. For a single-valued option, this allows the property for a specific command to override the \"keytool.all\" value, and the value specified on the command line to override both. For multiple-valued options, all of them will be used by .\n\nFor example, given the following file named :\n\nwhich is equivalent to\n\nbecause is a single-valued option and the value specified on the command line overrides the preconfigured options file.\n\nThe following examples show the defaults for various option values:\n\nWhen generating a certificate or a certificate request, the default signature algorithm ( option) is derived from the algorithm of the underlying private key to provide an appropriate level of security strength as follows:\n• None An RSASSA-PSS signature algorithm uses a algorithm as its hash and MGF1 algorithms.\n• None EdDSA supports 2 key sizes: Ed25519 and Ed448. When generating an EdDSA key pair using , a user can specify or to generate Ed25519 or Ed448 key pairs. When no is specified, an Ed25519 key pair is generated. A user can also directly specify or to generate a key pair with the expected key size.\n\nTo improve out of the box security, default key size and signature algorithm names are periodically updated to stronger values with each release of the JDK. If interoperability with older releases of the JDK is important, make sure that the defaults are supported by those releases. Alternatively, you can use the or options to override the default values at your own risk.\n\nThe command supports these named extensions. The names aren't case-sensitive.\n\nWhen name is OID, the value is the hexadecimal dumped Definite Encoding Rules (DER) encoding of the for the extension excluding the OCTET STRING type and length bytes. Other than standard hexadecimal numbers (0-9, a-f, A-F), any extra characters are ignored in the HEX string. Therefore, both 01:02:03:04 and 01020304 are accepted as identical values. When there is no value, the extension has an empty value field.\n\nA special name , used only in , denotes how the extensions included in the certificate request should be honored. The value for this name is a comma-separated list of (all requested extensions are honored), name{ [ | ]} (the named extension is honored, but it uses a different attribute), and (used with , denotes an exception). Requested extensions aren't honored by default.\n\nIf, besides the option, another named or OID option is provided, this extension is added to those already honored. However, if this name (or OID) also appears in the honored value, then its value and criticality override that in the request. If an extension of the same type is provided multiple times through either a name or an OID, only the last extension is used.\n\nThe extension is always created. For non-self-signed certificates, the is created.\n\nUsers should be aware that some combinations of extensions (and other certificate fields) may not conform to the Internet standard. See Certificate Conformance Warning.\n\nThe following examples describe the sequence actions in creating a keystore for managing public/private key pairs and certificates from trusted entities.\n• None Importing the Certificate Reply from the CA\n\nCreate a keystore and then generate the key pair.\n\nYou can enter the command as a single line such as the following:\n\nThe command creates the keystore named in the working directory (provided it doesn't already exist), and assigns it the password specified by . It generates a public/private key pair for the entity whose distinguished name is , , , and a two-letter country code of . It uses the RSA key generation algorithm to create the keys; both are 2048 bits\n\nThe command uses the default SHA256withRSA signature algorithm to create a self-signed certificate that includes the public key and the distinguished name information. The certificate is valid for 180 days, and is associated with the private key in a keystore entry referred to by . The private key is assigned the password specified by .\n\nThe command is significantly shorter when the option defaults are accepted. In this case, only is required, and the defaults are used for unspecified options that have default values. You are prompted for any required values. You could have the following:\n\nIn this case, a keystore entry with the alias is created, with a newly generated key pair and a certificate that is valid for 90 days. This entry is placed in your home directory in a keystore named . is created if it doesn't already exist. You are prompted for the distinguished name information, the keystore password, and the private key password.\n\nThe rest of the examples assume that you responded to the prompts with values equal to those specified in the first command. For example, a distinguished name of myname mygroup mycompany mycountry).\n\nGenerating the key pair created a self-signed certificate; however, a certificate is more likely to be trusted by others when it is signed by a CA.\n\nTo get a CA signature, complete the following process:\n• This creates a CSR for the entity identified by the default alias and puts the request in the file named .\n• None Submit to a CA, such as DigiCert.\n\nThe CA authenticates you, the requestor (usually offline), and returns a certificate, signed by them, authenticating your public key. In some cases, the CA returns a chain of certificates, each one authenticating the public key of the signer of the previous certificate in the chain.\n\nTo import a certificate for the CA, complete the following process:\n• None Before you import the certificate reply from a CA, you need one or more trusted certificates either in your keystore or in the keystore file. See in Commands.\n• None If the certificate reply is a certificate chain, then you need the top certificate of the chain. The root CA certificate that authenticates the public key of the CA.\n• None If the certificate reply is a single certificate, then you need a certificate for the issuing CA (the one that signed it). If that certificate isn't self-signed, then you need a certificate for its signer, and so on, up to a self-signed root CA certificate. The keystore ships with a set of root certificates issued by the CAs of the Oracle Java Root Certificate program. If you request a signed certificate from a CA, and a certificate authenticating that CA's public key hasn't been added to , then you must import a certificate from that CA as a trusted certificate. A certificate from a CA is usually self-signed or signed by another CA. If it is signed by another CA, you need a certificate that authenticates that CA's public key. For example, you have obtained a X file from a company that is a CA and the file is supposed to be a self-signed certificate that authenticates that CA's public key. Before you import it as a trusted certificate, you should ensure that the certificate is valid by:\n• None Viewing it with the command or the command without using the option. Make sure that the displayed certificate fingerprints match the expected fingerprints.\n• None Calling the person who sent the certificate, and comparing the fingerprints that you see with the ones that they show or that a secure public key repository shows. Only when the fingerprints are equal is it assured that the certificate wasn't replaced in transit with somebody else's certificate (such as an attacker's certificate). If such an attack takes place, and you didn't check the certificate before you imported it, then you would be trusting anything that the attacker signed.\n• None Replace the self-signed certificate with a certificate chain, where each certificate in the chain authenticates the public key of the signer of the previous certificate in the chain, up to a root CA. If you trust that the certificate is valid, then you can add it to your keystore by entering the following command: This command creates a trusted certificate entry in the keystore from the data in the CA certificate file and assigns the values of the alias to the entry.\n\nImporting the Certificate Reply from the CA\n\nAfter you import a certificate that authenticates the public key of the CA that you submitted your certificate signing request to (or there is already such a certificate in the file), you can import the certificate reply and replace your self-signed certificate with a certificate chain.\n\nThe certificate chain is one of the following:\n• None Returned by the CA when the CA reply is a chain.\n• None Constructed when the CA reply is a single certificate. This certificate chain is constructed by using the certificate reply and trusted certificates available either in the keystore where you import the reply or in the keystore file.\n\nFor example, if you sent your certificate signing request to DigiCert, then you can import their reply by entering the following command:\n\nIn this example, the returned certificate is named .\n\nIf you used the command to sign a Java Archive (JAR) file, then clients that use the file will want to authenticate your signature.\n\nOne way that clients can authenticate you is by importing your public key certificate into their keystore as a trusted entry. You can then export the certificate and supply it to your clients.\n• None Copy your certificate to a file named by entering the following command: In this example, the entry has an alias of .\n• None With the certificate and the signed JAR file, a client can use the command to authenticate your signature.\n\nUse the command to import an entire keystore into another keystore. This imports all entries from the source keystore, including keys and certificates, to the destination keystore with a single command. You can use this command to import entries from a different type of keystore. During the import, all new entries in the destination keystore will have the same alias names and protection passwords (for secret keys and private keys). If the command can't recover the private keys or secret keys from the source keystore, then it prompts you for a password. If it detects alias duplication, then it asks you for a new alias, and you can specify a new alias or simply allow the command to overwrite the existing one.\n\nFor example, import entries from a typical JKS type keystore into a PKCS #11 type hardware-based keystore, by entering the following command:\n\nThe command can also be used to import a single entry from a source keystore to a destination keystore. In this case, besides the options you used in the previous example, you need to specify the alias you want to import. With the option specified, you can also specify the destination alias name, protection password for a secret or private key, and the destination protection password you want as follows:\n\nThe following are commands used to generate key pairs and certificates for three entities:\n\nEnsure that you store all the certificates in the same keystore.\n\nA keystore is a storage facility for cryptographic keys and certificates. Keystores can have different types of entries. The two most applicable entry types for the command include the following: Key entries: Each entry holds very sensitive cryptographic key information, which is stored in a protected format to prevent unauthorized access. Typically, a key stored in this type of entry is a secret key, or a private key accompanied by the certificate chain for the corresponding public key. See Certificate Chains. The command can handle both types of entries, while the tool only handles the latter type of entry, that is private keys and their associated certificate chains. Trusted certificate entries: Each entry contains a single public key certificate that belongs to another party. The entry is called a trusted certificate because the keystore owner trusts that the public key in the certificate belongs to the identity identified by the subject (owner) of the certificate. The issuer of the certificate vouches for this, by signing the certificate. All keystore entries (key and trusted certificate entries) are accessed by way of unique aliases. An alias is specified when you add an entity to the keystore with the command to generate a secret key, the command to generate a key pair (public and private key), or the command to add a certificate or certificate chain to the list of trusted certificates. Subsequent commands must use this same alias to refer to the entity. For example, you can use the alias to generate a new public/private key pair and wrap the public key into a self-signed certificate with the following command. See Certificate Chains. This example specifies an initial passwd required by subsequent commands to access the private key associated with the alias . If you later want to change Duke's private key password, use a command such as the following: This changes the initial passwd to newpasswd. A password shouldn't be specified on a command line or in a script unless it is for testing purposes, or you are on a secure system. If you don't specify a required password option on a command line, then you are prompted for it. The class provided in the package supplies well-defined interfaces to access and modify the information in a keystore. It is possible for there to be multiple different concrete implementations, where each implementation is that for a particular type of keystore. Currently, two command-line tools ( and ) make use of keystore implementations. Because the class is , users can write additional security applications that use it. In JDK 9 and later, the default keystore implementation is . This is a cross platform keystore based on the RSA PKCS12 Personal Information Exchange Syntax Standard. This standard is primarily meant for storing or transporting a user's private keys, certificates, and miscellaneous secrets. There is another built-in implementation, provided by Oracle. It implements the keystore as a file with a proprietary keystore type (format) named . It protects each private key with its individual password, and also protects the integrity of the entire keystore with a (possibly different) password. Keystore implementations are provider-based. More specifically, the application interfaces supplied by are implemented in terms of a Service Provider Interface (SPI). That is, there is a corresponding abstract class, also in the , which defines the Service Provider Interface methods that providers must implement. The term provider refers to a package or a set of packages that supply a concrete implementation of a subset of services that can be accessed by the Java Security API. To provide a keystore implementation, clients must implement a provider and supply a subclass implementation, as described in Steps to Implement and Integrate a Provider. Applications can choose different types of keystore implementations from different providers, using the factory method supplied in the class. A keystore type defines the storage and data format of the keystore information, and the algorithms used to protect private/secret keys in the keystore and the integrity of the keystore. Keystore implementations of different types aren't compatible. The command works on any file-based keystore implementation. It treats the keystore location that is passed to it at the command line as a file name and converts it to a , from which it loads the keystore information.)The commands can read a keystore from any location that can be specified with a URL. For and , you can specify a keystore type at the command line, with the option. If you don't explicitly specify a keystore type, then the tools choose a keystore implementation based on the value of the property specified in the security properties file. The security properties file is called , and resides in the security properties directory: Each tool gets the value and then examines all the currently installed providers until it finds one that implements a keystores of that type. It then uses the keystore implementation from that provider.The class defines a static method named that lets applications retrieve the value of the property. The following line of code creates an instance of the default keystore type as specified in the property: The default keystore type is , which is a cross-platform keystore based on the RSA PKCS12 Personal Information Exchange Syntax Standard. This is specified by the following line in the security properties file: To have the tools utilize a keystore implementation other than the default, you can change that line to specify a different keystore type. For example, if you want to use the Oracle's keystore implementation, then change the line to the following: Case doesn't matter in keystore type designations. For example, would be considered the same as . A certificate (or public-key certificate) is a digitally signed statement from one entity (the issuer), saying that the public key and some other information of another entity (the subject) has some specific value. The following terms are related to certificates:\n• None Public Keys: These are numbers associated with a particular entity, and are intended to be known to everyone who needs to have trusted interactions with that entity. Public keys are used to verify signatures.\n• None Digitally Signed: If some data is digitally signed, then it is stored with the identity of an entity and a signature that proves that entity knows about the data. The data is rendered unforgeable by signing with the entity's private key.\n• None Identity: A known way of addressing an entity. In some systems, the identity is the public key, and in others it can be anything from an Oracle Solaris UID to an email address to an X.509 distinguished name.\n• None Signature: A signature is computed over some data using the private key of an entity. The signer, which in the case of a certificate is also known as the issuer.\n• None Private Keys: These are numbers, each of which is supposed to be known only to the particular entity whose private key it is (that is, it is supposed to be kept secret). Private and public keys exist in pairs in all public key cryptography systems (also referred to as public key crypto systems). In a typical public key crypto system, such as DSA, a private key corresponds to exactly one public key. Private keys are used to compute signatures.\n• None Entity: An entity is a person, organization, program, computer, business, bank, or something else you are trusting to some degree. Public key cryptography requires access to users' public keys. In a large-scale networked environment, it is impossible to guarantee that prior relationships between communicating entities were established or that a trusted repository exists with all used public keys. Certificates were invented as a solution to this public key distribution problem. Now a Certification Authority (CA) can act as a trusted third party. CAs are entities such as businesses that are trusted to sign (issue) certificates for other entities. It is assumed that CAs only create valid and reliable certificates because they are bound by legal agreements. There are many public Certification Authorities, such as DigiCert, Comodo, Entrust, and so on. You can also run your own Certification Authority using products such as Microsoft Certificate Server or the Entrust CA product for your organization. With the command, it is possible to display, import, and export certificates. It is also possible to generate self-signed certificates. The X.509 standard defines what information can go into a certificate and describes how to write it down (the data format). All the data in a certificate is encoded with two related standards called ASN.1/DER. Abstract Syntax Notation 1 describes data. The Definite Encoding Rules describe a single way to store and transfer that data. All X.509 certificates have the following data, in addition to the signature:\n• None Version: This identifies which version of the X.509 standard applies to this certificate, which affects what information can be specified in it. Thus far, three versions are defined. The command can import and export v1, v2, and v3 certificates. It generates v3 certificates.\n• None X.509 Version 1 has been available since 1988, is widely deployed, and is the most generic.\n• None X.509 Version 2 introduced the concept of subject and issuer unique identifiers to handle the possibility of reuse of subject or issuer names over time. Most certificate profile documents strongly recommend that names not be reused and that certificates shouldn't make use of unique identifiers. Version 2 certificates aren't widely used.\n• None X.509 Version 3 is the most recent (1996) and supports the notion of extensions where anyone can define an extension and include it in the certificate. Some common extensions are: KeyUsage (limits the use of the keys to particular purposes such as ) and AlternativeNames (allows other identities to also be associated with this public key, for example. DNS names, email addresses, IP addresses). Extensions can be marked critical to indicate that the extension should be checked and enforced or used. For example, if a certificate has the KeyUsage extension marked critical and set to , then when this certificate is presented during SSL communication, it should be rejected because the certificate extension indicates that the associated private key should only be used for signing certificates and not for SSL use.\n• None Serial number: The entity that created the certificate is responsible for assigning it a serial number to distinguish it from other certificates it issues. This information is used in numerous ways. For example, when a certificate is revoked its serial number is placed in a Certificate Revocation List (CRL).\n• None Signature algorithm identifier: This identifies the algorithm used by the CA to sign the certificate.\n• None Issuer name: The X.500 Distinguished Name of the entity that signed the certificate. This is typically a CA. Using this certificate implies trusting the entity that signed this certificate. In some cases, such as root or top-level CA certificates, the issuer signs its own certificate.\n• None Validity period: Each certificate is valid only for a limited amount of time. This period is described by a start date and time and an end date and time, and can be as short as a few seconds or almost as long as a century. The validity period chosen depends on a number of factors, such as the strength of the private key used to sign the certificate, or the amount one is willing to pay for a certificate. This is the expected period that entities can rely on the public value, when the associated private key has not been compromised.\n• None Subject name: The name of the entity whose public key the certificate identifies. This name uses the X.500 standard, so it is intended to be unique across the Internet. This is the X.500 Distinguished Name (DN) of the entity. For example, These refer to the subject's common name (CN), organizational unit (OU), organization (O), and country (C).\n• None Subject public key information: This is the public key of the entity being named with an algorithm identifier that specifies which public key crypto system this key belongs to and any associated key parameters. The command can create and manage keystore key entries that each contain a private key and an associated certificate chain. The first certificate in the chain contains the public key that corresponds to the private key. When keys are first generated, the chain usually starts off containing a single element, a self-signed certificate. See -genkeypair in Commands. A self-signed certificate is one for which the issuer (signer) is the same as the subject. The subject is the entity whose public key is being authenticated by the certificate. When the command is called to generate a new public/private key pair, it also wraps the public key into a self-signed certificate (unless the option is specified). Later, after a Certificate Signing Request (CSR) was generated with the command and sent to a Certification Authority (CA), the response from the CA is imported with , and the self-signed certificate is replaced by a chain of certificates. At the bottom of the chain is the certificate (reply) issued by the CA authenticating the subject's public key. The next certificate in the chain is one that authenticates the CA's public key. In many cases, this is a self-signed certificate, which is a certificate from the CA authenticating its own public key, and the last certificate in the chain. In other cases, the CA might return a chain of certificates. In this case, the bottom certificate in the chain is the same (a certificate signed by the CA, authenticating the public key of the key entry), but the second certificate in the chain is a certificate signed by a different CA that authenticates the public key of the CA you sent the CSR to. The next certificate in the chain is a certificate that authenticates the second CA's key, and so on, until a self-signed root certificate is reached. Each certificate in the chain (after the first) authenticates the public key of the signer of the previous certificate in the chain. Many CAs only return the issued certificate, with no supporting chain, especially when there is a flat hierarchy (no intermediates CAs). In this case, the certificate chain must be established from trusted certificate information already stored in the keystore. A different reply format (defined by the PKCS #7 standard) includes the supporting certificate chain in addition to the issued certificate. Both reply formats can be handled by the command. The top-level (root) CA certificate is self-signed. However, the trust into the root's public key doesn't come from the root certificate itself, but from other sources such as a newspaper. This is because anybody could generate a self-signed certificate with the distinguished name of, for example, the DigiCert root CA. The root CA public key is widely known. The only reason it is stored in a certificate is because this is the format understood by most tools, so the certificate in this case is only used as a vehicle to transport the root CA's public key. Before you add the root CA certificate to your keystore, you should view it with the option and compare the displayed fingerprint with the well-known fingerprint obtained from a newspaper, the root CA's Web page, and so on. The file represents a system-wide keystore with CA certificates. System administrators can configure and manage that file with the command by specifying as the keystore type. The keystore file ships with a default set of root CA certificates. For Linux, OS X, and Windows, you can list the default certificates with the following command: The initial password of the keystore file is . System administrators should change that password and the default access permission of that file upon installing the SDK. It is important to verify your file. Because you trust the CAs in the file as entities for signing and issuing certificates to other entities, you must manage the file carefully. The file should contain only certificates of the CAs you trust. It is your responsibility to verify the trusted root CA certificates bundled in the file and make your own trust decisions. To remove an untrusted CA certificate from the file, use the option of the command. You can find the file in the JDK's directory. Contact your system administrator if you don't have permission to edit this file. Certificates are often stored using the printable encoding format defined by the Internet RFC 1421 standard, instead of their binary encoding. This certificate format, also known as Base64 encoding, makes it easy to export certificates to other applications by email or through some other mechanism. Certificates read by the and commands can be in either this format or binary encoded. The command by default outputs a certificate in binary encoding, but will instead output a certificate in the printable encoding format, when the option is specified. The command by default prints the SHA-256 fingerprint of a certificate. If the option is specified, then the certificate is printed in human-readable format. If the option is specified, then the certificate is output in the printable encoding format. In its printable encoding format, the encoded certificate is bounded at the beginning and end by the following text: X.500 Distinguished Names are used to identify entities, such as those that are named by the and (signer) fields of X.509 certificates. The command supports the following subparts:\n• None commonName: The common name of a person such as Susan Jones.\n• None organizationUnit: The small organization (such as department or division) name. For example, Purchasing.\n• None localityName: The locality (city) name, for example, Palo Alto.\n• None stateName: State or province name, for example, California. When you supply a distinguished name string as the value of a option, such as for the command, the string must be in the following format: All the following items represent actual values and the previous keywords are abbreviations for the following: A sample command using such a string is: Case doesn't matter for the keyword abbreviations. For example, CN, cn, and Cn are all treated the same. Order matters; each subcomponent must appear in the designated order. However, it isn't necessary to have all the subcomponents. You can use a subset, for example: If a distinguished name string value contains a comma, then the comma must be escaped by a backslash (\\) character when you specify the string on a command line, as in: It is never necessary to specify a distinguished name string on a command line. When the distinguished name is needed for a command, but not supplied on the command line, the user is prompted for each of the subcomponents. In this case, a comma doesn't need to be escaped by a backslash (\\).\n\nImportant: Be sure to check a certificate very carefully before importing it as a trusted certificate.\n\nView the certificate first with the command or the command without the option. Ensure that the displayed certificate fingerprints match the expected ones. For example, suppose someone sends or emails you a certificate that you put it in a file named . Before you consider adding the certificate to your list of trusted certificates, you can execute a command to view its fingerprints, as follows:\n\nView the certificate first with the command or the command without the option. Ensure that the displayed certificate fingerprints match the expected ones. For example, suppose someone sends or emails you a certificate that you put it in a file named . Before you consider adding the certificate to your list of trusted certificates, you can execute a command to view its fingerprints, as follows:\n\nThen call or otherwise contact the person who sent the certificate and compare the fingerprints that you see with the ones that they show. Only when the fingerprints are equal is it guaranteed that the certificate wasn't replaced in transit with somebody else's certificate such as an attacker's certificate. If such an attack took place, and you didn't check the certificate before you imported it, then you would be trusting anything the attacker signed, for example, a JAR file with malicious class files inside.\n\nIt isn't required that you execute a command before importing a certificate. This is because before you add a certificate to the list of trusted certificates in the keystore, the command prints out the certificate information and prompts you to verify it. You can then stop the import operation. However, you can do this only when you call the command without the option. If the option is specified, then there is no interaction with the user.\n\nMost commands that operate on a keystore require the store password. Some commands require a private/secret key password. Passwords can be specified on the command line in the and options. However, a password shouldn't be specified on a command line or in a script unless it is for testing, or you are on a secure system. When you don't specify a required password option on a command line, you are prompted for it.\n\nInternet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile defined a profile on conforming X.509 certificates, which includes what values and value combinations are valid for certificate fields and extensions.\n\nThe command doesn't enforce all of these rules so it can generate certificates that don't conform to the standard, such as self-signed certificates that would be used for internal testing purposes. Certificates that don't conform to the standard might be rejected by the JDK or other applications. Users should ensure that they provide the correct options for , , and so on.\n\nBefore you add the certificate to the keystore, the command verifies it by attempting to construct a chain of trust from that certificate to a self-signed certificate (belonging to a root CA), using trusted certificates that are already available in the keystore.\n\nIf the option was specified, then additional certificates are considered for the chain of trust, namely the certificates in a file named .\n\nIf the command fails to establish a trust path from the certificate to be imported up to a self-signed certificate (either from the keystore or the file), then the certificate information is printed, and the user is prompted to verify it by comparing the displayed certificate fingerprints with the fingerprints obtained from some other (trusted) source of information, which might be the certificate owner. Be very careful to ensure the certificate is valid before importing it as a trusted certificate. The user then has the option of stopping the import operation. If the option is specified, then there is no interaction with the user.\n\nWhen you import a certificate reply, the certificate reply is validated with trusted certificates from the keystore, and optionally, the certificates configured in the keystore file when the option is specified.\n\nThe methods of determining whether the certificate reply is trusted are as follows:\n• None If the reply is a single X.509 certificate, then the command attempts to establish a trust chain, starting at the certificate reply and ending at a self-signed certificate (belonging to a root CA). The certificate reply and the hierarchy of certificates is used to authenticate the certificate reply from the new certificate chain of aliases. If a trust chain can't be established, then the certificate reply isn't imported. In this case, the command doesn't print the certificate and prompt the user to verify it, because it is very difficult for a user to determine the authenticity of the certificate reply.\n• None If the reply is a PKCS #7 formatted certificate chain or a sequence of X.509 certificates, then the chain is ordered with the user certificate first followed by zero or more CA certificates. If the chain ends with a self-signed root CA certificate and the option was specified, the command attempts to match it with any of the trusted certificates in the keystore or the keystore file. If the chain doesn't end with a self-signed root CA certificate and the option was specified, the command tries to find one from the trusted certificates in the keystore or the keystore file and add it to the end of the chain. If the certificate isn't found and the option isn't specified, the information of the last certificate in the chain is printed, and the user is prompted to verify it.\n\nIf the public key in the certificate reply matches the user's public key already stored with , then the old certificate chain is replaced with the new certificate chain in the reply. The old chain can only be replaced with a valid , and so the password used to protect the private key of the entry is supplied. If no password is provided, and the private key password is different from the keystore password, the user is prompted for it.\n\nThis command was named in earlier releases. This old name is still supported in this release. The new name, , is preferred."
    }
]