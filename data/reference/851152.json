[
    {
        "link": "https://docs.unity3d.com/550/Documentation/Manual/class-Rigidbody.html",
        "document": "Rigidbodies enable your GameObjects to act under the control of physics. The Rigidbody can receive forces and torque to make your objects move in a realistic way. Any GameObject must contain a Rigidbody to be influenced by gravity, act under added forces via scripting, or interact with other objects through the NVIDIA PhysX physics engine.\n\nRigidbodies allow your GameObjects to act under control of the physics engine. This opens the gateway to realistic collisions, varied types of joints, and other very cool behaviors. Manipulating your GameObjects by adding forces to a Rigidbody creates a very different feel and look than adjusting the Transform Component directly. Generally, you shouldn’t manipulate the Rigidbody and the Transform of the same GameObject - only one or the other.\n\nThe biggest difference between manipulating the Transform versus the Rigidbody is the use of forces. Rigidbodies can receive forces and torque, but Transforms cannot. Transforms can be translated and rotated, but this is not the same as using physics. You’ll notice the distinct difference when you try it for yourself. Adding forces/torque to the Rigidbody will actually change the object’s position and rotation of the Transform component. This is why you should only be using one or the other. Changing the Transform while using physics could cause problems with collisions and other calculations.\n\nRigidbodies must be explicitly added to your GameObject before they will be affected by the physics engine. You can add a Rigidbody to your selected object from Components->Physics->Rigidbody in the menu. Now your object is physics-ready; it will fall under gravity and can receive forces via scripting, but you may need to add a Collider or a Joint to get it to behave exactly how you want.\n\nWhen an object is under physics control, it moves semi-independently of the way its transform parents move. If you move any parents, they will pull the Rigidbody child along with them. However, the Rigidbodies will still fall down due to gravity and react to collision events.\n\nTo control your Rigidbodies, you will primarily use scripts to add forces or torque. You do this by calling AddForce() and AddTorque() on the object’s Rigidbody. Remember that you shouldn’t be directly altering the object’s Transform when you are using physics.\n\nFor some situations, mainly creating ragdoll effects, it is neccessary to switch control of the object between animations and physics. For this purpose Rigidbodies can be marked isKinematic. While the Rigidbody is marked isKinematic, it will not be affected by collisions, forces, or any other part of the physics system. This means that you will have to control the object by manipulating the Transform component directly. Kinematic Rigidbodies will affect other objects, but they themselves will not be affected by physics. For example, Joints which are attached to Kinematic objects will constrain any other Rigidbodies attached to them and Kinematic Rigidbodies will affect other Rigidbodies through collisions.\n\nColliders are another kind of component that must be added alongside the Rigidbody in order to allow collisions to occur. If two Rigidbodies bump into each other, the physics engine will not calculate a collision unless both objects also have a Collider attached. Collider-less Rigidbodies will simply pass through each other during physics simulation.\n\nAdd a Collider with the Component->Physics menu. View the Component Reference page of any individual Collider for more specific information:\n• Mesh Collider - creates a collider from the object’s mesh, cannot collide with another Mesh Collider\n• Wheel Collider - specifically for creating cars or other moving vehicles\n\nCompound Colliders are combinations of primitive Colliders, collectively acting as a single Collider. They come in handy when you have a model that would be too complex or costly in terms of performance to simulate exactly, and want to simulate the collision of the shape in an optimal way using simple approximations. To create a Compound Collider, create child objects of your colliding object, then add a Collider component to each child object. This allows you to position, rotate, and scale each Collider easily and independently of one another. You can build your compound collider out of a number of primitive colliders and/or convex mesh colliders.\n\nIn the above picture, the Gun Model GameObject has a Rigidbody attached, and multiple primitive Colliders as child GameObjects. When the Rigidbody parent is moved around by forces, the child Colliders move along with it. The primitive Colliders will collide with the environment’s Mesh Collider, and the parent Rigidbody will alter the way it moves based on forces being applied to it and how its child Colliders interact with other Colliders in the Scene.\n\nMesh Colliders can’t normally collide with each other. If a Mesh Collider is marked as Convex, then it can collide with another Mesh Collider. The typical solution is to use primitive Colliders for any objects that move, and Mesh Colliders for static background objects.\n\nContinuous collision detection is a feature to prevent fast-moving colliders from passing each other. This may happen when using normal (Discrete) collision detection, when an object is one side of a collider in one frame, and already passed the collider in the next frame. To solve this, you can enable continuous collision detection on the rigidbody of the fast-moving object. Set the collision detection mode to Continuous to prevent the rigidbody from passing through any static (ie, non-rigidbody) MeshColliders. Set it to Continuous Dynamic to also prevent the rigidbody from passing through any other supported rigidbodies with collision detection mode set to Continuous or Continuous Dynamic. Continuous collision detection is supported for Box-, Sphere- and CapsuleColliders. Note that continuous collision detection is intended as a safety net to catch collisions in cases where objects would otherwise pass through each other, but will not deliver physically accurate collision results, so you might still consider decreasing the fixed Time step value in the TimeManager inspector to make the simulation more precise, if you run into problems with fast moving objects.\n\nUse the right size\n\nThe size of the your GameObject’s mesh is much more important than the mass of the Rigidbody. If you find that your Rigidbody is not behaving exactly how you expect - it moves slowly, floats, or doesn’t collide correctly - consider adjusting the scale of your mesh asset. Unity’s default unit scale is 1 unit = 1 meter, so the scale of your imported mesh is maintained, and applied to physics calculations. For example, a crumbling skyscraper is going to fall apart very differently than a tower made of toy blocks, so objects of different sizes should be modeled to accurate scale.\n\nIf you are modeling a human make sure the model is around 2 meters tall in Unity. To check if your object has the right size compare it to the default cube. You can create a cube using GameObject > 3D Object > Cube. The cube’s height will be exactly 1 meter, so your human should be twice as tall.\n\nIf you aren’t able to adjust the mesh itself, you can change the uniform scale of a particular mesh asset by selecting it in Project View and choosing Assets->Import Settings… from the menu. Here, you can change the scale and re-import your mesh.\n\nIf your game requires that your GameObject needs to be instantiated at different scales, it is okay to adjust the values of your Transform’s scale axes. The downside is that the physics simulation must do more work at the time the object is instantiated, and could cause a performance drop in your game. This isn’t a terrible loss, but it is not as efficient as finalizing your scale with the other two options. Also keep in mind that non-uniform scales can create undesirable behaviors when Parenting is used. For these reasons it is always optimal to create your object at the correct scale in your modeling application.\n• The relative Mass of two Rigidbodies determines how they react when they collide with each other.\n• Making one Rigidbody have greater Mass than another does not make it fall faster in free fall. Use Drag for that.\n• A low Drag value makes an object seem heavy. A high one makes it seem light. Typical values for Drag are between .001 (solid block of metal) and 10 (feather).\n• If you are directly manipulating the Transform component of your object but still want physics, attach a Rigidbody and make it Kinematic.\n• If you are moving a GameObject through its Transform component but you want to receive Collision/Trigger messages, you must attach a Rigidbody to the object that is moving.\n• You cannot make an object stop rotating just by setting its Angular Drag to infinity."
    },
    {
        "link": "https://docs.unity3d.com/Manual/class-Rigidbody.html",
        "document": "Use the Rigidbody component to apply a Rigidbody to your GameObjectThe fundamental object in Unity scenes, which can represent characters, props, scenery, cameras, waypoints, and more. A GameObject’s functionality is defined by the Components attached to it. More info\n\nSee in Glossary. A Rigidbody provides a physics-based way to control the movement and position of a GameObject. Instead of the Transform properties, you can use simulated physics forces and torque to move the GameObject, and let the physics engineA system that simulates aspects of physical systems so that objects can accelerate correctly and be affected by collisions, gravity and other forces. More info\n\nSee in Glossary calculate the results. For more information, see Introduction to Rigidbody Physics.\n\nTo monitor the performance of a Rigidbody, use the Physics Debug Visualization tool.\n\nDefine the mass of the GameObject (in kilograms). Mass is set to 1 by default. As in real life, mass does not affect how quickly an item falls under gravity. To simulate resistance forces that slow down movement, use Drag. Define the decay rate of a Rigidbody’s linear velocity, to simulate drag, air resistance, or friction. Low values produce a slower decay rate, so that the GameObject moves faster for longer (this is useful for simulating heavy real-world objects). High values produce a faster decay rate, so that the GameObject slows down over a short amount of time (this is useful for simulating lightweight real-world objects). Define the decay rate of a Rigidbody’s rotational velocity, to simulate drag, air resistance, or friction. Low values produce a slower decay rate, so that the GameObject moves faster for longer (this is useful for simulating heavy real-world objects). High values produce a faster decay rate, so that the GameObject slows down over a short amount of time (this is useful for simulating lightweight real-world objects). Note that you cannot make the GameObject stop rotating just by setting its Angular Drag to infinity. Angular Drag is set to 0.05 by default. Automatic Center Of Mass \n\n Represents the average position of all mass in a Rigidbody for the purposes of physics calculations. By default it is computed from all colliders belonging to the Rigidbody, but can be modified via script. More info Enable Automatic Center Of Mass to use the physics system’s predicted center of mass for the Rigidbody, based on its shape and scale. Disable to set your own X, Y and Z coordinates for the center of mass. Enable Automatic Tensor to use the physics system’s predicted tensor and tensor rotation for the Rigidbody, based on all connected colliders \n\n An invisible shape that is used to handle physical collisions for an object. A collider doesn’t need to be exactly the same shape as the object’s mesh - a rough approximation is often more efficient and indistinguishable in gameplay. More info . Like mass, an inertia tensor defines how much force or torque is required to make a Rigidbody move; however, while mass affects linear movement, inertia tensor affects rotational movement. Disable to set your own X, Y and Z coordinates for the tensor instead (see properties below). Define the inertia tensor of this Rigidbody. The higher the Inertia Tensor value is, the more torque is required to make the Rigidbody rotate on its axis. Define the rotation of the inertia tensor. Toggle the effects of gravity on the Rigidbody. If enabled, the physics system applies a force to move the GameObject in the direction of simulated gravity (by default, down the y axis). Use Gravity is enabled by default. Toggle between physics-based and kinematic movement for the GameObject. When Is Kinematic is enabled, the physics system cannot apply forces to move or rotate the GameObject, instead, Unity can only move and rotate it via its Transform. See Introduction to Rigidbody physics: Rigidbody without physics-based movement for details. Is Kinematic is disabled by default. The Interpolate setting on a Rigidbody provides two options to smooth the appearance of a Rigidbody’s motion if it appears jittery at run time. These options are Interpolate and Extrapolate.\n\n\n\nBoth interpolation and extrapolation calculate the pose of the Rigidbody (that is, the position and rotation) between physics updates. Which one you should choose depends on which option produces the best visual outcome for your use case.\n\n\n\nFor detailed information on the Interpolate property, see Apply interpolation to a Rigidbody. Apply no interpolation or extrapolation. This is the default option. Use the pose and velocity of the Rigidbody from the previous two physics updates to calculate and apply the pose of the Rigidbody in the current frame.\n\n\n\nInterpolate is more accurate than Extrapolate, but it has a time lag of one physics update. It’s usually best for situations where accuracy is important; for example, if the Rigidbody’s velocity varies, or if there are other physics elements that influence the Rigidbody’s movement. Use the pose and velocity of the Rigidbody from the previous physics update, and predict the pose of the Rigidbody in the next physics update, to calculate and predict the pose in the current frame.\n\n\n\nExtrapolate makes the Rigidbody appear to move slightly ahead of where it should be, and can be slightly inaccurate. It’s usually best for situations where accuracy is not important; for example, if the Rigidbody moves at a constant velocity, and there are no other physics elements that influence the Rigidbody’s movement. Define how the physics system detects collisions between this Rigidbody’s collider and other colliders in the scene. Unity generates one collision per pair of colliders, and determines the method of collision detection based on this Collision Detection property. \n\n\n\nCollision Detection is set to Discrete by default. For more information on each collision detection type, see Continuous collision detection \n\n A collision detection method that calculates and resolves collisions over the entire physics simulation step. This can prevent fast-moving objects from tunnelling through walls during a simulation step. More info . The physics system uses discrete collision \n\n A collision occurs when the physics engine detects that the colliders of two GameObjects make contact or overlap, when at least one has a Rigidbody component and is in motion. More info detection to calculate collisions for this Rigidbody’s collider. Select Discrete if this Rigidbody is not involved in any fast-moving collisions. Discrete collision detection \n\n An automatic process performed by Unity which determines whether a moving GameObject with a Rigidbody and collider component has come into contact with any other colliders. More info is not very computationally intensive. The physics system uses sweep-based CCD to calculate collisions between this Rigidbody’s collider and any static colliders (that is, colliders without an associated Rigidbody). Select Continuous if this Rigidbody is involved in fast-moving collisions with static colliders. Sweep-based CCD is more computationally intensive than Discrete or Continuous Speculative. The physics system uses sweep-based CCD to calculate collisions between this Rigidbody’s collider and all other colliders, except for those that are set to Discrete collision detection. Select Continuous Dynamic if this Rigidbody is involved in fast-moving collisions with any colliders. Sweep-based CCD is more computationally intensive than Discrete or Continuous Speculative. The physics system uses speculative continuous collision detection \n\n A collision detection method that inflates broad-phase AABB of moving objects according to their velocities. This enables support for effects like rotations. More info to calculate collisions between this Rigidbody’s collider and all other colliders. Select Continuous Speculative if collision accuracy is not important for this Rigidbody. Speculative collision detection is more computationally intensive than Discrete, but less computationally intensive than Continuous or Continuous Dynamic. Stops the Rigidbody moving in the world X, Y and Z axes selectively. Stops the Rigidbody rotating around the local X, Y and Z axes selectively.\n\nThe Layer Overrides section provides properties that allow you to override the project-wide Layer-based collision detection settings for all colliders attached to this Rigidbody."
    },
    {
        "link": "https://discussions.unity.com/t/rigidbody2d-position-doesnt-teleport-the-object-with-the-interpolation-settings-on/856090",
        "document": ""
    },
    {
        "link": "https://discussions.unity.com/t/teleport-a-rigidbody/423729",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/Unity3D/comments/97mge2/unity3d_question_about_teleporting_a_physicsy",
        "document": "Hi. As a programmer, tho very new to gaming Engines, i am making a small practice game, with a ball rolling around the screen. And i want it, to wrap around - rolling of the screen to the right, to come in again from the left etc.\n\nI have produced code that does that, so far so good. However, the ball is moved by physics (AddForce, AddTorque) yet it is teleported by directly moving it's transform.\n\nMy code seems to work fine, however, various sources tell me, that it's a bad idea, to directly move a physics-y object. Unfortunately, none of the sources told me why exactly (other than \"oh, it messes with stuff\").\n\nI seen advice, to temporarily make the object kinematic for the duration of the move and/or to temporarily store the physics properties to re-apply after the move (or even to a new instance in the new location). Seems kinda messy.\n\nSo, what i want to know is:\n\nIn which cases exactly does modifying a physics objects transform cause specific problems? (As specific/technical as possible). Are there clear-cut cases, where it always fails or is guaranteed safe to do?\n\nWhat is the proper way to teleport a physics-y object?"
    },
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Rigidbody-position.html",
        "document": "For some reason your suggested change could not be submitted. Please <a>try again</a> in a few minutes. And thank you for taking the time to help us improve the quality of Unity Documentation.\n\nThank you for helping us improve the quality of Unity Documentation. Although we cannot accept all submissions, we do read each suggested change from our users and will make updates where applicable.\n\nRigidbody.position allows you to get and set the position of a Rigidbody using the physics engine. If you change the position of a Rigibody using Rigidbody.position, the transform will be updated after the next physics simulation step. This is faster than updating the position using Transform.position, as the latter will cause all attached Colliders to recalculate their positions relative to the Rigidbody.\n\n\n\nIf you want to continuously move a rigidbody use MovePosition instead, which takes interpolation into account."
    },
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Rigidbody.MovePosition.html",
        "document": "Suggest a change Thank you for helping us improve the quality of Unity Documentation. Although we cannot accept all submissions, we do read each suggested change from our users and will make updates where applicable. Close For some reason your suggested change could not be submitted. Please <a>try again</a> in a few minutes. And thank you for taking the time to help us improve the quality of Unity Documentation. Close Switch to Manual\n\nRigidbody.MovePosition moves a Rigidbody and complies with the interpolation settings. When Rigidbody interpolation is enabled, Rigidbody.MovePosition creates a smooth transition between frames. Unity moves a Rigidbody in each call. The occurs in world space. To teleport a Rigidbody from one position to another, use Rigidbody.position instead of MovePosition."
    },
    {
        "link": "https://discussions.unity.com/t/how-to-propagate-rigidbody-position-back-to-transform/852727",
        "document": ""
    },
    {
        "link": "https://discussions.unity.com/t/rigid-body-vs-transform/583960",
        "document": ""
    },
    {
        "link": "https://discussions.unity.com/t/how-does-rb2d-moveposition-interact-with-physics2d-simulate/784342",
        "document": ""
    }
]