[
    {
        "link": "https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenTextures.xhtml",
        "document": "Specifies an array in which the generated texture names are stored.\n\nreturns texture names in . There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to .\n\nThe generated textures have no dimensionality; they assume the dimensionality of the texture target to which they are first bound (see glBindTexture).\n\nTexture names returned by a call to are not returned by subsequent calls, unless they are first deleted with glDeleteTextures."
    },
    {
        "link": "https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindTexture.xhtml",
        "document": "Specifies the target to which the texture is bound. Must be one of GL_TEXTURE_1D , GL_TEXTURE_2D , GL_TEXTURE_3D , GL_TEXTURE_1D_ARRAY , GL_TEXTURE_2D_ARRAY , GL_TEXTURE_RECTANGLE , GL_TEXTURE_CUBE_MAP , GL_TEXTURE_CUBE_MAP_ARRAY , GL_TEXTURE_BUFFER , GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY .\n\nlets you create or use a named texture. Calling with set to , , , , , , , , , or and set to the name of the new texture binds the texture name to the target. When a texture is bound to a target, the previous binding for that target is automatically broken.\n\nTexture names are unsigned integers. The value zero is reserved to represent the default texture for each texture target. Texture names and the corresponding texture contents are local to the shared object space of the current GL rendering context; two rendering contexts share texture names only if they explicitly enable sharing between contexts through the appropriate GL windows interfaces functions.\n\nYou must use glGenTextures to generate a set of new texture names.\n\nWhen a texture is first bound, it assumes the specified target: A texture first bound to becomes one-dimensional texture, a texture first bound to becomes two-dimensional texture, a texture first bound to becomes three-dimensional texture, a texture first bound to becomes one-dimensional array texture, a texture first bound to becomes two-dimensional array texture, a texture first bound to becomes rectangle texture, a texture first bound to becomes a cube-mapped texture, a texture first bound to becomes a cube-mapped array texture, a texture first bound to becomes a buffer texture, a texture first bound to becomes a two-dimensional multisampled texture, and a texture first bound to becomes a two-dimensional multisampled array texture. The state of a one-dimensional texture immediately after it is first bound is equivalent to the state of the default at GL initialization, and similarly for the other texture types.\n\nWhile a texture is bound, GL operations on the target to which it is bound affect the bound texture, and queries of the target to which it is bound return state from the bound texture. In effect, the texture targets become aliases for the textures currently bound to them, and the texture name zero refers to the default textures that were bound to them at initialization.\n\nA texture binding created with remains active until a different texture is bound to the same target, or until the bound texture is deleted with glDeleteTextures.\n\nOnce created, a named texture may be re-bound to its same original target as often as needed. It is usually much faster to use to bind an existing named texture to one of the texture targets than it is to reload the texture image using glTexImage1D, glTexImage2D, glTexImage3D or another similar function."
    },
    {
        "link": "https://open.gl/textures",
        "document": "Just like VBOs and VAOs, textures are objects that need to be generated first by calling a function. It shouldn't be a surprise at this point what this function is called.\n\nTextures are typically used for images to decorate 3D models, but in reality they can be used to store many different kinds of data. It's possible to have 1D, 2D and even 3D textures, which can be used to store bulk data on the GPU. An example of another use for textures is storing terrain information. This article will pay attention to the use of textures for images, but the principles generally apply to all kinds of textures.\n\nJust like other objects, textures have to be bound to apply operations to them. Since images are 2D arrays of pixels, it will be bound to the target.\n\nThe pixels in the texture will be addressed using texture coordinates during drawing operations. These coordinates range from to where is conventionally the bottom-left corner and is the top-right corner of the texture image. The operation that uses these texture coordinates to retrieve color information from the pixels is called sampling. There are different ways to approach this problem, each being appropriate for different scenarios. OpenGL offers you many options to control how this sampling is done, of which the common ones will be discussed here.\n\nThe first thing you'll have to consider is how the texture should be sampled when a coordinate outside the range of to is given. OpenGL offers 4 ways of handling this:\n• : The integer part of the coordinate will be ignored and a repeating pattern is formed.\n• : The texture will also be repeated, but it will be mirrored when the integer part of the coordinate is odd.\n• : The coordinate will simply be clamped between and .\n• : The coordinates that fall outside the range will be given a specified border color.\n\nThese explanations may still be a bit cryptic and since OpenGL is all about graphics, let's see what all of these cases actually look like:\n\nThe wrapping can be set per coordinate, where the equivalent of in texture coordinates is called . Texture parameter are changed with the functions as demonstrated here.\n\nAs before, the here indicates the type of the value you want to specify. If you use and you want to change the border color, you need to change the value of by passing an RGBA float array:\n\nThis operation will set the border color to red.\n\nSince texture coordinates are resolution independent, they won't always match a pixel exactly. This happens when a texture image is stretched beyond its original size or when it's sized down. OpenGL offers various methods to decide on the sampled color when this happens. This process is called filtering and the following methods are available:\n• : Returns the pixel that is closest to the coordinates.\n• : Returns the weighted average of the 4 pixels surrounding the given coordinates.\n\nBefore discussing mipmaps, let's first see the difference between nearest and linear interpolation. The original image is 16 times smaller than the rectangle it was rasterized on.\n\nWhile linear interpolation gives a smoother result, it isn't always the most ideal option. Nearest neighbour interpolation is more suited in games that want to mimic 8 bit graphics, because of the pixelated look.\n\nYou can specify which kind of interpolation should be used for two separate cases: scaling the image down and scaling the image up. These two cases are identified by the keywords and .\n\nAs you've seen, there is another way to filter textures: mipmaps. Mipmaps are smaller copies of your texture that have been sized down and filtered in advance. It is recommended that you use them because they result in both a higher quality and higher performance.\n\nGenerating them is as simple as calling the function above, so there's no excuse for not using them! Note that you do have to load the texture image itself before mipmaps can be generated from it.\n\nTo use mipmaps, select one of the four mipmap filtering methods.\n• : Uses the mipmap that most closely matches the size of the pixel being textured and samples with nearest neighbour interpolation.\n• : Uses the two mipmaps that most closely match the size of the pixel being textured and samples with nearest neighbour interpolation.\n\nThere are some other texture parameters available, but they're suited for specialized operations. You can read about them in the specification.\n\nNow that the texture object has been configured it's time to load the texture image. This is done by simply loading an array of pixels into it:\n\nThe first parameter after the texture target is the level-of-detail, where is the base image. This parameter can be used to load your own mipmap images. The second parameter specifies the internal pixel format, the format in which pixels should be stored on the graphics card. Many different formats are available, including compressed formats, so it's certainly worth taking a look at all of the options. The third and fourth parameters specify the width and height of the image. The fifth parameter should always have a value of per the specification. The next two parameter describe the format of the pixels in the array that will be loaded and the final parameter specifies the array itself. The function begins loading the image at coordinate , so pay attention to this.\n\nBut how is the pixel array itself established? Textures in graphics applications will usually be a lot more sophisticated than simple patterns and will be loaded from files. Best practice is to have your files in a format that is natively supported by the hardware, but it may sometimes be more convenient to load textures from common image formats like JPG and PNG. Unfortunately OpenGL doesn't offer any helper functions to load pixels from these image files, but that's where third-party libraries come in handy again! The SOIL library will be discussed here along with some of the alternatives.\n\nSOIL (Simple OpenGL Image Library) is a small and easy-to-use library that loads image files directly into texture objects or creates them for you. You can start using it in your project by linking with and adding the directory to your include path. It includes Visual Studio project files to compile it yourself.\n\nAlthough SOIL includes functions to automatically create a texture from an image, it uses features that aren't available in modern OpenGL. Because of this we'll simply use SOIL as image loader and create the texture ourselves.\n\nYou can start configuring the texture parameters and generating mipmaps after this.\n\nYou can clean up the image data right after you've loaded it into the texture.\n\nOther libraries that support a wide range of file types like SOIL are DevIL and FreeImage. If you're just interested in one file type, it's also possible to use libraries like libpng and libjpeg directly. If you're looking for more of an adventure, have a look at the specification of the BMP and TGA file formats, it's not that hard to implement a loader for them yourself.\n\nAs you've seen, textures are sampled using texture coordinates and you'll have to add these as attributes to your vertices. Let's modify the last sample from the previous chapter to include these texture coordinates. The new vertex array will now include the and coordinates for each vertex:\n\nThe vertex shader needs to be modified so that the texture coordinates are interpolated over the fragments:\n\nJust like when the color attribute was added, the attribute pointers need to be adapted to the new format:\n\nAs two floats were added for the coordinates, one vertex is now 7 floats in size and the texture coordinate attribute consists of 2 of those floats.\n\nNow just one thing remains: providing access to the texture in the fragment shader to sample pixels from it. This is done by adding a uniform of type , which will have a default value of 0. This only needs to be changed when access has to be provided to multiple textures, which will be considered in the next section.\n\nFor this sample, the image of the kitten used above will be loaded using the SOIL library. Make sure that it is located in the working directory of the application.\n\nTo sample a pixel from a 2D texture using the sampler, the function can be called with the relevant sampler and texture coordinate as parameters. We'll also multiply the sampled color with the color attribute to get an interesting effect. Your fragment shader will now look like this:\n\nWhen running this application, you should get the following result:\n\nIf you get a black screen, make sure that your shaders compiled successfully and that the image is correctly loaded. If you can't find the problem, try comparing your code to the sample code.\n\nThe sampler in your fragment shader is bound to texture unit . Texture units are references to texture objects that can be sampled in a shader. Textures are bound to texture units using the function you've used before. Because you didn't explicitly specify which texture unit to use, the texture was bound to . That's why the default value of for the sampler in your shader worked fine.\n\nThe function specifies which texture unit a texture object is bound to when is called.\n\nThe amount of texture units supported differs per graphics card, but it will be at least 48. It is safe to say that you will never hit this limit in even the most extreme graphics applications.\n\nTo practice with sampling from multiple textures, let's try blending the images of the kitten and one of a puppy to get the best of both worlds! Let's first modify the fragment shader to sample from two textures and blend the pixels:\n\nThe function here is a special GLSL function that linearly interpolates between two variables based on the third parameter. A value of will result in the first value, a value of will result in the second value and a value in between will result in a mixture of both values. You'll have the chance to experiment with this in the exercises.\n\nNow that the two samplers are ready, you'll have to assign the first two texture units to them and bind the two textures to those units. This is done by adding the proper calls to the texture loading code.\n\nThe texture units of the samplers are set using the function you've seen in the previous chapter. It simply accepts an integer specifying the texture unit. Make sure that at least the wrap texture parameters are set for both textures. This code should result in the following image.\n\nAs always, have a look at the sample source code if you have trouble getting the program to work.\n\nNow that texture sampling has been covered in this chapter, you're finally ready to dive into transformations and ultimately 3D. The knowledge you have at this point should be sufficient for producing most types of 2D games, except for transformations like rotation and scaling which will be covered in the next chapter.\n• Animate the blending between the textures by adding a uniform. (Solution)\n• Draw a reflection of the kitten in the lower half of the rectangle. (Solution)\n• Now try adding distortion with and the time variable to simulate water. (Expected result, Solution)"
    },
    {
        "link": "https://docs.gl/gl2/glGenTextures",
        "document": "Specifies an array in which the generated texture names are stored.\n\nreturns texture names in . There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to .\n\nThe generated textures have no dimensionality; they assume the dimensionality of the texture target to which they are first bound (see glBindTexture).\n\nTexture names returned by a call to are not returned by subsequent calls, unless they are first deleted with glDeleteTextures."
    },
    {
        "link": "https://docs.gl/gl3/glGenTextures",
        "document": "Specifies an array in which the generated texture names are stored.\n\nreturns texture names in . There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to .\n\nThe generated textures have no dimensionality; they assume the dimensionality of the texture target to which they are first bound (see glBindTexture).\n\nTexture names returned by a call to are not returned by subsequent calls, unless they are first deleted with glDeleteTextures."
    },
    {
        "link": "https://stackoverflow.com/questions/17598572/how-to-read-write-a-binary-file",
        "document": "this questions is linked with the question How to write binary data file on C and plot it using Gnuplot by CAMILO HG. I know that the real problem have two parts: 1) Write the binary data file, 2) Plot it using Gnuplot.\n\nThe first part has been very clearly answered here, so I do not have something to add.\n\nFor the second, the easy way is send the people to the Gnuplot manual, and I sure someone find a good answer, but I do not find it in the web, so I am going to explain one solution (which must be in the real question, but I new in stackoverflow and I can not answer there):\n\nAfter write your binary data file using , you should create a very simple program in C, a reader. The reader only contains the same structure as the writer, but you use instead . So it is very ease to generate this program: copy in the file the writing part of your original code and change write for read (and \"wb\" for \"rb\"). In addition, you could include some checks for the data, for example, if the length of the file is correct. And finally, your program need to print the data in the standard output using a .\n\nFor be clear: your program run like this\n\nOkey, with this program, in Gnuplot you only need to pipe the standard output of the reader to the Gnuplot, something like this:\n\nThis line, run the program reader, and the output is connected with Gnuplot and it plot the data.\n\n*Because Gnuplot is going to read the output of the program, you must know what can Gnuplot read and plot and what can not."
    },
    {
        "link": "https://engineering.purdue.edu/ece264/16au/hw/HW13",
        "document": "This is for Fall 2016 (9 years ago)\n\n// Credit: Prof. Yung-Hsiang Lu and Prof. Cheng-Kok Koh created earlier assignments upon which this one is based. Text from that assignment has been copied with permission.\n\nIn this exercise, you will write code to read, write, and crop BMP image files.\n\nA BMP file has the following format:\n\nThe header has 54 bytes, which are divided into the following fields. Note that the #pragma directive ensures that the header structure is really 54-byte long by using 1-byte alignment.\n\nNote that the number of bytes each field occupies can be obtained by dividing the number 16 or 32 by 8. For example, the field \"type\" occupies 2 bytes. These fields are all integers. An \"uint\" means unsigned, and \"int\" means signed. For example the fields \"width\" and \"height\" are signed integers. However, for simplicity, all the BMP files we have will contain only positive integers. You may assume that in your code. Also, we are dealing wih uncompressed BMP format (compression field is 0).\n\nBecause of the packing specified in the bmp.h file, you should be able to use fread to read in the first 54 bytes of a BMP file and store 54 bytes in a BMPHeader structure.\n\nAmong all these fields in the BMPHeader structure, you have to pay attention to the following fields:\n\nWe will further explain bits, width, height, and imagesize later. You should use the following structure to store a BMP file, the header for the first 54 bytes of a given BMP file, and data should point to a location that is big enough (of imagesize) to store the image data (color information of each pixel).\n\nNow, let's examine the fields bits, width, height, and imagesize in greater details. The bits field records the number of bits used to represent a pixel. For this exercise (and the next exercise and assignment), we are dealing with BMP files with only 24 bits per pixel or 16 bits per pixel. For 24-bit representation, 8 bits (1 byte) for RED, 8 bits for GREEN, and 8 bits for BLUE. For 16-bit representation, each color is represented using 5 bits (the most significant bit is not used). For this exercise, we will use only 24-bit BMP files to test your functions. However, your code should be able to handle 16-bit format as well. (Note that the header format is actually more complicated for 16-bit format. However, for this exercise and the next exercise and assignment, we will use the same header format for both 24-bit and 16-bit BMP files for simplicity. So yes, we are abusing the format!)\n\nThe width field gives you the number of pixels per row. Therefore, the total number of bytes required to represent a row of pixel for a 24-bit representation is width * 3. However, the BMP format requires each row to be padded at the end such that each row is represented by multiples of 4 bytes of data. For example, if there is only one pixel in each row, we need an additional byte to pad a row. If there are two pixels per row, 2 additional bytes. If there are three pixels per row, 3 additional bytes. If there are four pixels per row, we don't have too perform padding. We require you to assign value 0 to each of the padding byte.\n\nThe height field gives you the number of rows. Row 0 is the bottom of the image. The file is organized such that the bottom row follows the header, and the top row is at the end of the file. Within each row, the left most pixel has a lower index. Therefore, the first byte in data, i.e., data[0], belongs to the bottom left pixel.\n\nThe imagesize field is height * amount of data per row. Note that the amount of date per row includes padding at the end of each row.\n\nYou can visualize the one-dimensional data as a three-dimensional array, which is organized as rows of pixels, with each pixel represented by 3 bytes of colors (24-bit representation) or 2 bytes of colors (16-bit representation). However, because of padding, you cannot easily typecast the one-dimensional data as a 3-dimensional array. Instead, you can first typecast it as a two dimensional array, rows of pixels. For each row of data, you can typecast it as a two-dimensional array, where the first dimension captures pixels from left to right, the second dimension is the color of each pixel (3 bytes or 2 bytes).\n\nThe Wikipedia article on the BMP file format has a nice diagram and more complete details about this format.\n\nIn this assignment, you will need to handle run-time errors. These are not the same as bugs in your code. These are problems (or special conditions) that might arise due to the inputs from the caller of a function that you write. For example, a file may be inaccessible or corrupt, or may fail and return NULL.\n\nFor purposes of this assignment, the error-handling strategy will be two-pronged:\n• Return a special value if the operation failed. For functions that return a , you will return NULL if the operation failed.\n• Return an error message via pass-by-address. Normally, the caller will pass the address of . If the operation is successful, the callee will do nothing with it. However, if there is a failure, the callee will return a newly heap-allocated string. It is the caller's responsibility to free it.\n\nYou will do this for all functions in this assignment that take a parameter called .\n\nHere is a sketch of the basic pattern we are describing:\n\nEXIT_SUCCESS and EXIT_FAILURE are constants defined as 0 and 1, respectively, in stdlib.h. Although we haven't been using these so far in ECE 264, they are actually better than simply returning 0 and 1.\n\nThis assignment includes a warm-up exercise to help you get ready. This accounts for 20% of your score for HW13. Scoring will be relatively light, but the usual base requirements apply.\n• Read a text file\n\n Create a function that reads the contents of a file and returns it as a string on the heap. The caller is responsible for freeing that memory. Use , , and .\n• Write a text file\n\n Create a function that writes the given content to a file at the specified path. Use , , and .\n• Write a Point \n\n Write a function that writes a single Point to a file at the specified path. Use , , and . For the class, please copy-paste the following struct type into your file: This will be a binary file. This is preparation for working with binary files for images, which work the same way. In general, you will use for binary files.\n• Read a Point \n\n Create a function that reads a from the file at the specified path into a on the stack. No or are necessary for this one. Use , , and .\n\nThe structure of the warmup.c file is described in the Requirements table below. You should write your own warmup.c. You may add helper functions, if you wish.\n\nIn a hurry, and don't need the practice? This warm-up is here to help you learn what you need to succeed on the rest of this assignment—not to add additional work. Therefore, we give you an option. Those who feel that they do not need the practice may \"opt out\". by modifying warmup.c so that it does nothing but print the following message exactly and then exit:\n\nIf you do that, then your score for HW13 will be based solely on the rest of this assignment. If you leave the warmup.c undone, if you do not turn in a warmup.c, or if the message it prints does not match perfectly, then you will receive 0 for the warmup portion of this assignment (20%).\n\nUse test-driven development to do this assignment incrementally. At least 12 stages must be explicitly marked with comments in your in test_bmp.c. It will look similar to this:\n\nThis aspect of the assignment will be checked, but only to the degree that we can do so efficiently (i.e., possibly very lightly). Nevertheless, you should follow it in earnest for your own benefit.\n\nRemember: Your code should never be broken for more than about 10-15 minutes at a time.\n\nWe have provided a bmp.h file and some test image files. You must use our bmp.h. To obtain these, run . You may use other BMP image files of your choice*, but not all BMP files will work with this code (e.g., grayscale, other color depths, etc.), so your may wish to stick with the supplied files to test.\n\nAny image files that you turn in must be G-rated and not violate any copyrights (i.e., your own images or else freely licensed). Provide credit in your bmp.c file in the form of a comment like:\n\nHow much work is this?\n\nThis assignment is designed to be of similar difficulty to HW12. As usual… Do not depend on this estimate. Your mileage may vary in either direction.\n• How can I view the contents of a BMP directly?\n\n The best way to inspect binary data is with a hex dump. From bash, you can type . Since it will probably be long, you will want to view in vim. One way to do that is type from bash. Another way is to open the file in vim and then type . (Do not save!)\n\n \n\n Suppose you have the following tiny 6x6 BMP image: . (Yes, it really is only 6 pixels by 6 pixels. Don't worry. A larger version is included in one of the diagrams below.)\n\n \n\n To get a hex dump right on the command line, you could type this at bash: It will be more convenient to view in vim, so we type this from bash instead. (Don't forget the \"-\" at the end!) Here is the hex dump, a you will see it. Don't worry if this looks cryptic. Read on and you will understand it completely.\n\n \n\n \n\n You can break this apart using the information about the BMP file format above. Here is the same hex dump, this time with some annotations. \n\n \n\n For this and other binary file formats, you can understand what value goes where by simply looking at the specification and a hex dump of the binary file."
    },
    {
        "link": "https://stackoverflow.com/questions/58226958/how-do-i-properly-read-and-write-binary-files-c",
        "document": "I see the following problems in your code:\n\nYou are using the wrong argument to in\n\nThey need to be , , or . I prefer since it works regardless of the type of .\n\nYou have a typo in\n\nIt needs to be\n\nYou are not using the right index to read into and write from .\n\nThe loop for writing needs to be fixed similarly."
    },
    {
        "link": "https://geeksforgeeks.org/basics-file-handling-c",
        "document": "File handling in C is the process in which we create, open, read, write, and close operations on a file. C language provides different functions such as fopen(), fwrite(), fread(), fseek(), fprintf(), etc. to perform input, output, and many different C file operations in our program.\n\nWhy do we need File Handling in C?\n\nSo far the operations using the C program are done on a prompt/terminal which is not stored anywhere. The output is deleted when the program is closed. But in the software industry, most programs are written to store the information fetched from the program. The use of file handling is exactly what the situation calls for.\n\nIn order to understand why file handling is important, let us look at a few features of using files:\n• Reusability: The data stored in the file can be accessed, updated, and deleted anywhere and anytime providing high reusability.\n• Portability: Without losing any data, files can be transferred to another in the computer system. The risk of flawed coding is minimized with this feature.\n• Efficient: A large amount of input may be required for some programs. File handling allows you to easily access a part of a file using few instructions which saves a lot of time and reduces the chance of errors.\n• Storage Capacity: Files allow you to store a large amount of data without having to worry about storing everything simultaneously in a program.\n\nTypes of Files in C\n\nA file can be classified into two types based on the way the file stores the data. They are as follows:\n\nA text file contains data in the form of ASCII characters and is generally used to store a stream of characters.\n• None Each line in a text file ends with a new line character (‘\n\n’).\n• None It can be read or written by any text editor.\n• None They are generally stored with .txt\n• None Text files can also be used to store the source code.\n\nA binary file contains data in binary form (i.e. 0’s and 1’s) instead of ASCII characters. They contain data that is stored in a similar manner to how it is stored in the main memory.\n• None The binary files can be created only from within a program and their contents can only be read by a program.\n• None More secure as they are not easily readable.\n• None They are generally stored with .bin\n\nC file operations refer to the different possible operations that we can perform on a file in C such as:\n• fopen() with attributes as “a” or “a+” or “w” or “w+”\n\nThe highlighted text mentions the C function used to perform the file operations.\n\nA file pointer is a reference to a particular position in the opened file. It is used in file handling to perform all file operations such as read, write, close, etc. We use the FILE macro to declare the file pointer variable. The FILE macro is defined inside <stdio.h> header file.\n\nFile Pointer is used in almost all the file operations in C.\n\nFor opening a file in C, the fopen() function is used with the filename or file path along with the required access modes.\n• file_name: name of the file when present in the same directory as the source file. Otherwise, full path.\n• access_mode: Specifies for what operation the file is being opened.\n• None If the file is opened successfully, returns a file pointer to it.\n• None If the file is not opened, then returns NULL.\n\nFile opening modes or access modes specify the allowed operations on the file to be opened. They are passed as an argument to the fopen() function. Some of the commonly used file access modes are listed below:\n\nSearches file. If the file is opened successfully fopen( ) loads it into memory and sets up a pointer that points to the first character in it. If the file cannot be opened fopen( ) returns NULL. Open for reading in binary mode. If the file does not exist, fopen( ) returns NULL. Open for writing in text mode. If the file exists, its contents are overwritten. If the file doesn’t exist, a new file is created. Returns NULL, if unable to open the file. Open for writing in binary mode. If the file exists, its contents are overwritten. If the file does not exist, it will be created. Searches file. If the file is opened successfully fopen( ) loads it into memory and sets up a pointer that points to the last character in it. It opens only in the append mode. If the file doesn’t exist, a new file is created. Returns NULL, if unable to open the file. Open for append in binary mode. Data is added to the end of the file. If the file does not exist, it will be created. Searches file. It is opened successfully fopen( ) loads it into memory and sets up a pointer that points to the first character in it. Returns NULL, if unable to open the file. Open for both reading and writing in binary mode. If the file does not exist, fopen( ) returns NULL. Searches file. If the file exists, its contents are overwritten. If the file doesn’t exist a new file is created. Returns NULL, if unable to open the file. Open for both reading and writing in binary mode. If the file exists, its contents are overwritten. If the file does not exist, it will be created. Searches file. If the file is opened successfully fopen( ) loads it into memory and sets up a pointer that points to the last character in it. It opens the file in both reading and append mode. If the file doesn’t exist, a new file is created. Returns NULL, if unable to open the file. Open for both reading and appending in binary mode. If the file does not exist, it will be created.\n\nAs given above, if you want to perform operations on a binary file, then you have to append ‘b’ at the last. For example, instead of “w”, you have to use “wb”, instead of “a+” you have to use “a+b”.\n\nThe file is not opened because it does not exist in the source directory. But the fopen() function is also capable of creating a file if it does not exist. It is shown below\n\nThe fopen() function can not only open a file but also can create a file if it does not exist already. For that, we have to use the modes that allow the creation of a file if not found such as w, w+, wb, wb+, a, a+, ab, and ab+.\n\nThe file read operation in C can be performed using functions fscanf() or fgets(). Both the functions performed the same operations as that of scanf and gets but with an additional parameter, the file pointer. There are also other functions we can use to read from a file. Such functions are listed below:\n\nSo, it depends on you if you want to read the file line by line or character by character.\n\nThe getc() and some other file reading functions return EOF (End Of File) when they reach the end of the file while reading. EOF indicates the end of the file and its value is implementation-defined.\n\nThe file write operations can be performed by the functions fprintf() and fputs() with similarities to read operations. C programming also provides some other functions that can be used to write data to a file such as:\n\nThe fclose() function is used to close the file. After successful file operations, you must always close a file to remove it from the memory.\n\nwhere the file_pointer is the pointer to the opened file.\n\nExamples of File Handing in C\n\nExample 1: Program to Create a File, Write in it, And Close the File\n\nThis program will create a file named GfgTest.c in the same directory as the source file which will contain the following text: “GeeksforGeeks-A Computer Science Portal for Geeks”.\n\nExample 2: Program to Open a File, Read from it, And Close the File\n\nThis program reads the text from the file named GfgTest.c which we created in the previous example and prints it in the console.\n\nTill now, we have only discussed text file operations. The operations on a binary file are similar to text file operations with little difference.\n\nTo open a file in binary mode, we use the rb, rb+, ab, ab+, wb, and wb+ access mode in the fopen() function. We also use the .bin file extension in the binary filename.\n\nWe use fwrite() function to write data to a binary file. The data is written to the binary file in the from of bits (0’s and 1’s).\n• ptr: pointer to the block of memory to be written.\n• size: size of each element to be written (in bytes).\n\nExample: Program to write to a Binary file using fwrite()\n\nThe fread() function can be used to read data from a binary file in C. The data is read from the file in the same form as it is stored i.e. binary form.\n• ptr: pointer to the block of memory to read.\n• size: the size of each element to read(in bytes).\n\nExample: Program to Read from a binary file using fread()\n\nIf we have multiple records inside a file and need to access a particular record that is at a specific position, so we need to loop through all the records before it to get the record. Doing this will waste a lot of memory and operational time. To reduce memory consumption and operational time we can use fseek() which provides an easier way to get to the required data. fseek() function in C seeks the cursor to the given record in the file.\n\nThe rewind() function is used to bring the file pointer to the beginning of the file. It can be used in place of fseek() when you want the file pointer at the start.\n\nMore Functions for C File Operations\n\nThe following table lists some more functions that can be used to perform file operations or assist in performing them."
    },
    {
        "link": "https://quora.com/What-is-the-best-way-to-read-the-first-few-bytes-of-a-BMP-file-using-C",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://freeglut.sourceforge.net/docs/api.php",
        "document": "OpenGL is a trademark of Silicon Graphics, Inc. X Window System is a trademark of X Consortium, Inc. Spaceball is a registered trademark of Spatial Systems Inc.\n\nThe authors have taken care in preparation of this documentation but make no expressed or implied warranty of any kind and assumes no responsibility for errors or omissions. No liability is assumed for incidental or consequential damages in connection with or arising from the use of information or programs contained herein.\n\nThe OpenGL programming world owes a tremendous debt to Mr. Mark J. Kilgard for writing the OpenGL Utility Toolkit, or GLUT. The GLUT library of functions allows an application programmer to create, control, and manipulate windows independent of what operating system the program is running on. By hiding the dependency on the operating system from the application programmer, he allowed people to write truly portable OpenGL applications.\n\nMr. Kilgard copyrighted his library and gave it a rather unusual license. Under his license, people are allowed freely to copy and distribute the libraries and the source code, but they are not allowed to modify it. For a long time this did not matter because the GLUT library worked so well and because Mr. Kilgard was releasing updates on a regular basis. But with the passage of time, people started wanting some slightly different behaviours in their windowing system. When Mr. Kilgard stopped supporting the GLUT library in 1999, having moved on to bigger and better things, this started to become a problem.\n\nIn December 1999, Mr. Pawel Olzsta started work on an open-source clone of the GLUT library. This open-source clone, which does not use any of the GLUT source code, has evolved into the present freeglut library. This documentation specifies the application program interface to the freeglut library.\n\nIn developing the freeglut library, we have taken careful steps to ensure consistency in function operation across the board, in such a manner as to maintain compatibility with GLUT's behavior whenever possible. In this section some of the important conventions of freeglut, and their compatibility with GLUT, are made explicit.\n\nThere is considerable confusion about the \"right thing to do\" concerning window size and position. GLUT itself is not consistent between Windows and UNIX/X11; since platform independence is a virtue for freeglut, we decided to break with GLUT's behaviour. \n\n Under UNIX/X11, it is apparently not possible to get the window border sizes in order to subtract them off the window's initial position until some time after the window has been created. Therefore we decided on the following behavior, both under Windows and under UNIX/X11:\n• When you create a window with position (x,y) and size (w,h), the upper left hand corner of the outside of the window (the non-client area) is at (x,y) and the size of the drawable (client) area is (w,h). The coordinates taken by and , as well as the coordinates provided by freeglut when it calls the callback, specify the top-left of the non-client area of the window. By default only positive-signed coordinates are supported. If GLUT_ALLOW_NEGATIVE_WINDOW_POSITION is enabled, then negative coordinates are supported. An exception for exists as it's always supported negative window coordinates.\n• When you query the size and position of the window using , freeglut will return the size of the drawable area--the (w,h) that you specified when you created the window--and the coordinates of the upper left hand corner of the drawable (client) area--which is the (x,y) position of the window you specified when you created it.\n\nGLUT was created as a tool to help teach OpenGL programming. To simplify development, callbacks were used for handling display, input, and other events. But at the time it was developed, the purpose, or for some other unknown reason, the callbacks lacked any user-provided data argument. This has caused considerable difficulties for any significantly advanced usage of GLUT, and now freeglut. This has prevented any attempt to wrap freeglut in a C++ wrapper, make per-window, per-callback data structure, and potentially made it undesirable to modern C developers who tend to be well versed in \"don't use globals\". To combat these complaints and issues, many callbacks (with some deprecated callbacks excluded) support user-data callbacks provided through additional functions provided in freeglut. All callbacks that support user-data callbacks are marked as such.\n\nThe general rule to follow is to take the freeglut callback function and append \"Ucall\" to the end of the function, add an additional argument to the end of the argument list of both the freeglut function and the callback function. This will pass the user-data to the callback when it's invoked.\n\nSince the freeglut library was developed in order to update GLUT, it is natural that there will be some differences between the two. Each function in the API notes any differences between the GLUT and the freeglut function behaviours. The important ones are summarized here.\n\nOne of the commonest complaints about the GLUT library was that once an application called , it never got control back. There was no way for an application to loop in GLUT for a while, possibly as a subloop while a specific window was open, and then return to the calling function. A new function, , has been added to allow this functionality. Another function, , has also been added to allow the application to tell freeglut to clean up and close down.\n\nAnother difficulty with GLUT, especially with multiple-window programs, is that if the user clicks on the \"x\" in the window header the application exits immediately. The application programmer can now set an option, , to specify whether execution should continue, whether GLUT should return control to the main program, or whether GLUT should simply exit (the default).\n\nFunction to leave fullscreen window mode, , or to toggle between fullscreen and normal window mode, , have been added.\n\nSeveral new callbacks have been added and several callbacks which were specific to Silicon Graphics hardware have not been implemented. Most or all of the new callbacks are listed in the GLUT Version 4 \"glut.h\" header file but did not make it into the documentation. The new callbacks consist of regular and special key release callbacks, a joystick callback, a menu state callback (with one argument, distinct from the menu status callback which has three arguments), a window status callback (also with one argument), and a window position callback. Unsupported callbacks are the two Tablet callbacks. If the user has a need for an unsupported callback he should contact the freeglut development team.\n\nNew functions have been added to render full character strings (including carriage returns) rather than rendering one character at a time. More functions return the widths of character strings and the font heights, in pixels for bitmapped fonts and in OpenGL units for the stroke fonts.\n\nTwo functions have been added to render a wireframe and a solid rhombic dodecahedron. Furthermore, solid and wireframe versions of the original teacup and teaspoon that accompanied the famous Newell teapot. As these geometry functions are often used for teaching purposes, can now be used to visualize the normal vectors for each vertex. Lastly, to support drawing these objects with shaders, three functions have been added with which users can provide the addresses of the Coordinate, Normal and Texture Coordinate vertex attribs: , , and . Texture coordinates are only generated for the teaset.\n\nglutGetProcAddress is a wrapper for the glXGetProcAddressARB and wglGetProcAddress functions.\n\nThe and functions specify a desired position and size for windows that freeglut will create in the future.\n\nThe and functions specify a desired position and size for windows that freeglut will create in the future. The position is measured in pixels from the upper left hand corner of the screen, with \"x\" increasing to the right and \"y\" increasing towards the bottom of the screen. The size is measured in pixels. freeglut does not promise to follow these specifications in creating its windows, but it certainly makes an attempt to.\n\nThe position and size of a window are a matter of some subtlety. Most windows have a usable area surrounded by a border and with a title bar on the top. The border and title bar are commonly called \"decorations.\" The position of the window unfortunately varies with the operating system. On both Linux and Windows, you specify the coordinates of the upper left-hand corner of the window's decorations. Also for both operating systems, the size of the window is the size of the usable interior.\n\n With information can be acquired about the current window's size, position and decorations. Note however that according to freeglut's conventions, the information returned about the window coordinates does not correspond to the coordinates used when setting window position. In addition, GLUT only accepts positive window coordinates, and ignores all negative window coordinates. But if GLUT_ALLOW_NEGATIVE_WINDOW_POSITION is enabled, then negative window coordinates can be used. This is useful for multi-montitor setups where the second monitor may be in the negative desktop space of the primary monitor, as now the window can be placed on the additional monitors. Furthermore, this flag also determines how negative coordinates and sizes are interpreted for subwindows.\n\nWindows has some additional quirks which the application programmer should know about. First, the minimum y-coordinate of a window decoration is zero. (This is a feature of freeglut and can be adjusted if so desired.) Second, there appears to be a minimum window width on Windows which is 104 pixels. The user may specify a smaller width, but the Windows system calls ignore it. It is also impossible to make a window narrower than this by dragging on its corner.\n\nFor some reason, GLUT is not affected by the 104-pixel minimum window width. If the user clicks on the corner of a window which is narrower than this amount, the window will immediately snap out to this width, but the application can call and make a window narrower again.\n\nIf GLUT_ALLOW_NEGATIVE_WINDOW_POSITION is enabled, will accept negative window coordinates.\n\nglutInitDisplayString support is limited: any of the tokens recognized by GLUT are also recognized by freeglut, but any statements with comparators cannot (yet: do help develop this!) be handled. Any spec (comparator and value) after the token is ignored. However, many of these values can be set with glutSetOption for now...\n\nThe and functions specify callbacks that will be called upon warnings and errors issued from within freeglut so that the user can deal with these. Useful for rerouting to another output sink (e.g., logging) and also to avoid exit(1) being called upon error. As with other glutInit* functions, these can be set before glutInit is called, so any output from the library can be handled by the user.\n\nThe users callback is passed a format string and a variable argument list that can be passed to functions such as .\n\n Note that there are the preprocessor definitions and , which affect freeglut's warning and error behavior when no user callback is defined. If defined at library (not client app!) compile time--by default it is, warnings and errors are printed to . If not defined, warnings and errors are muted (not printed to stderr), though errors still trigger deinitialization and exit. Whether and is defined does not affect whether the client callback is called, it only affects whether warnings and errors are printed to when no callback is defined.\n\nGLUT does not provide these functions.\n\nAfter an application has finished initializing its windows and menus, it enters an event loop. Within this loop, freeglut polls the data entry devices (keyboard, mouse, etc.) and calls the application's appropriate callbacks.\n\nIn GLUT, control never returned from the event loop (as invoked by the function) to the calling function. This prevented an application from having re-entrant code, in which GLUT could be invoked from within a callback, and it prevented the application from doing any post-processing (such as freeing allocated memory) after GLUT had closed down. freeglut allows the application programmer to specify more direct control over the event loop by means of two new functions. The first, , processes a single iteration of the event loop and allows the application to use a different event loop controller or to contain re-entrant code. The second, , causes the event loop to exit nicely; this is preferable to the application's calling from within a GLUT callback.\n\nThe function causes the program to enter the window event loop. An application should call this function at most once. It will call any application callback functions as required to process mouse clicks, mouse motion, key presses, and so on.\n\nIn GLUT, there was absolutely no way for the application programmer to have control return from the function to the calling function. freeglut allows the programmer to force this by setting the option and invoking the function from one of the callbacks. Stopping the program this way is preferable to simply calling from within a callback because this allows freeglut to free allocated memory and otherwise clean up after itself. (I know I just said this, but I think it is important enough that it bears repeating.)\n\nThe function processes a single iteration in the freeglut event loop.\n\nThe function causes freeglut to process one iteration's worth of events in its event loop. This allows the application to control its own event loop and still use the freeglut windowing system.\n\nGLUT does not include this function.\n\nThe function causes freeglut to stop its event loop.\n\nThe function causes freeglut to stop the event loop. If the option has been set to or , control will return to the function which called ; otherwise the application will exit.\n\nIf the application has two nested calls to and calls , the behaviour of freeglut is undefined. It may leave only the inner nested loop or it may leave both loops. If the reader has a strong preference for one behaviour over the other he should contact the freeglut Programming Consortium and ask for the code to be fixed.\n\nGLUT does not include this function.\n\nThe function creates a subwindow of an existing window.\n\nCreates a subwindow of window that is at location x and y relative to the window's upper-left corner, and is of the specified width and height. The newly created window ID is returned by . By default, the position coordinates will only allow windows within the bounds of the parent. Negative coordinates be treated as coordinates from the opposite edge for a given axis. In addition, the width of the window will be taken into account. For example, if the parent window is 100 pixels wide, and the x is 10, and width is 20, the subwindow will be located at . If x is -10, then the subwindow will be located at 70 . If the width or height are negative, then the dimension is taken as a subtraction of the parent dimension. For example, if the parent window is 100 pixels wide, and the x is 10, and width is 20, the subwindow will have a size of 20. If width is -20, then the subwindow will have a width of 70 .\n\nIf GLUT_ALLOW_NEGATIVE_WINDOW_POSITION is enabled, the window behavior differs. Negative window coordinates are now accepted and may result in windows outside of the viewing area, depending on the platform of operation. Negative width and height are still used as a subtraction of the parent window dimension, but they do not take x or y into account. For example, if the parent window is 100 pixels wide, and the x is 10, and width is 20, the subwindow will be located at . If x is -10, then the subwindow will be located at . If the parent window is 100 pixels wide, and the x is 10, and width is 20, the subwindow will have a size of 20. If width is -20, then the subwindow will have a width of 80 .\n\nGLUT does not support negative x or y. Nor does it have GLUT_ALLOW_NEGATIVE_WINDOW_POSITION which changes the the functionality of .\n\nThe , set the window title for when the window is in a visible state and when it is in an iconified state respectively.\n\nNormally a window system displays a title for every top-level window in the system. The initial title is set when you call glutCreateWindow(). By means of the function you can set the titles for your top-level freeglut windows. If you just want one title for the window over the window's entire life, you should set it when you open the window with glutCreateWindow().\n\n sets the title to be displayed for the window when it is in iconified (minimized) state.\n\ndoes nothing in GLUT on Windows, but is emulated on Windows by freeglut.\n\nThe , and functions are used to transition the current window between fullscreen and normal mode.\n\nThe function causes the current window to enter fullscreen mode, to go back to the window size and position as it was before entering fullscreen mode, and toggles between fullscreen and normal mode.\n\n In multi-monitor setups on Windows 2000 and newer, the window will become fullscreen on the monitor that it overlaps the most.\n\n Calls to these functions are ignored for gamemode and child windows.\n\n Use to query fullscreen state of current window.\n\nGLUT does not include the and functions.\n\nfreeglut does not allow overlays, although it does \"answer the mail\" with function stubs so that GLUT-based programs can compile and link against freeglut without modification.\n\nIf the reader needs overlays, he should contact the freeglut Programming Consortium and ask for them to be implemented. He should also be prepared to assist in the implementation.\n\nThe function is not implemented in freeglut.\n\nThe function is not implemented in freeglut.\n\nThe function is not implemented in freeglut.\n\nThe function is not implemented in freeglut.\n\nThe function is not implemented in freeglut.\n\nThe function is not implemented in freeglut.\n\nThe function is not implemented in freeglut.\n\nThe function is not implemented in freeglut.\n\nThe function is not implemented in freeglut.\n\nThe function is not implemented in freeglut.\n\nThe and functions are not implemented in freeglut.\n\nThe and functions are not implemented in freeglut.\n\nsets the (bitmap) font to be used for drawing the specified menu.\n\nOnly bitmap fonts ( , see here for a list) can be used as menu fonts. A warning is issued and the request is ignored if the supplied font is a stroke font, or an unknown font.\n\nGLUT does not provide this function.\n\nThe function sets the global idle callback. freeglut calls the idle callback when there are no inputs from the user.\n\nThe function specifies the function that freeglut will call to perform background processing tasks such as continuous animation when window system events are not being received. If enabled, this function is called continuously from freeglut while no events are received. The callback function has no parameters and returns no value. freeglut does not change the current window or the current menu before invoking the idle callback; programs with multiple windows or menus must explicitly set the current window and current menu and not rely on its current setting. \n\n The amount of computation and rendering done in an idle callback should be minimized to avoid affecting the program's interactive response. In general, no more than a single frame of rendering should be done in a single invocation of an idle callback. Note that no actual drawing to the framebuffer should be done from the idle callback, this is not supported. While it might work on some platforms, it will not on others or might stop working in the future. Drawing should be done in the callback.\n\n Calling with a NULL argument disables the call to an idle callback.\n\nApplication programmers should note that if they have specified the \"continue execution\" action on window closure, freeglut will continue to call the idle callback after the user has closed a window by clicking on the \"x\" in the window header bar. If the idle callback renders a particular window (this is considered bad form but is frequently done anyway), the programmer should supply a window closure callback for that window which changes or disables the idle callback.\n\nThe function sets the window's position callback. freeglut calls the position callback when the window is repositioned/moved programatically or by the user.\n\nWhen freeglut calls this callback, it provides the new position on the screen of the top-left of the , that is, the same coordinates used by and . To get the position on the screen of the top-left of the client area, use and . See freeglut's conventions for more information.\n\nThis function is not implemented in GLUT.\n\nThe function sets the window's close callback. freeglut calls the close callback when the window is about to be destroyed.\n\nThe function specifies the function that freeglut will call to notify the application that a window is about to be closed, either because it is requested using , because the user clicked on the \"x\" in the window header (for top-level windows only), or due to a pending closure of a subwindow's parent window. In the first case, the closure callback is not invoked from the call, but at a later time point.\n\n freeglut sets the current window to the window which is about to be closed when the callback is invoked. The window can thus be retrieved in the callback using .\n\n Users looking to prevent freeglut from exiting when a window is closed, should look into using glutSetOption to set . Some settings will prevent the application from exiting when a window is closed.\n\n Please note that , a deprecated function, is an alias to .\n\nThis function is not implemented in GLUT.\n\nThe function sets the window's special key press callback. freeglut calls the special key press callback when the user presses a special key.\n\nThe window's new special key press callback function \n\n The key whose press triggers the callback \n\n The x-coordinate of the mouse relative to the window at the time the key is pressed \n\n The y-coordinate of the mouse relative to the window at the time the key is pressed\n\nThe function specifies the function that freeglut will call when the user presses a special key on the keyboard. The callback function has one argument: the name of the function to be invoked (\"called back\") at the time at which the special key is pressed. The function returns no value. freeglut sets the current window to the window which is active when the callback is invoked. \"Special keys\" are the function keys, the arrow keys, the Page Up and Page Down keys, and the Insert key. The Delete key is considered to be a regular key. \n\n Calling with a NULL argument disables the call to the window's special key press callback.\n\nThe argument may take one of the following defined constant values:\n• - Page Up and Page Down keys\n\nThe function sets the window's key release callback. freeglut calls the key release callback when the user releases a key.\n\nThe window's new key release callback function \n\n The key whose release triggers the callback \n\n The x-coordinate of the mouse relative to the window at the time the key is released \n\n The y-coordinate of the mouse relative to the window at the time the key is released\n\nThe function specifies the function that freeglut will call when the user releases a key from the keyboard. The callback function has one argument: the name of the function to be invoked (\"called back\") at the time at which the key is released. The function returns no value. Freeglut sets the current window to the window which is active when the callback is invoked. \n\n While freeglut checks for upper or lower case letters, it does not do so for non-alphabetical characters. Nor does it account for the Caps-Lock key being on. The operating system may send some unexpected characters to freeglut, such as \"8\" when the user is pressing the Shift key. freeglut also invokes the callback when the user releases the Control, Alt, or Shift keys, among others. Releasing the Delete key causes this function to be invoked with a value of 127 for . \n\n Calling with a NULL argument disables the call to the window's key release callback.\n\nThis function is not implemented in GLUT versions before Version 4. It has been designed to be as close to GLUT as possible. Users who find differences should contact the freeglut Programming Consortium to have them fixed.\n\nThe function sets the window's special key release callback. freeglut calls the special key release callback when the user releases a special key.\n\nThe window's new special key release callback function \n\n The key whose release triggers the callback \n\n The x-coordinate of the mouse relative to the window at the time the key is released \n\n The y-coordinate of the mouse relative to the window at the time the key is released\n\nThe function specifies the function that freeglut will call when the user releases a special key from the keyboard. The callback function has one argument: the name of the function to be invoked (\"called back\") at the time at which the special key is released. The function returns no value. freeglut sets the current window to the window which is active when the callback is invoked. \"Special keys\" are the function keys, the arrow keys, the Page Up and Page Down keys, and the Insert key. The Delete key is considered to be a regular key. \n\n Calling with a NULL argument disables the call to the window's special key release callback.\n\nThe argument may take one of the following defined constant values:\n• - Page Up and Page Down keys\n\nThis function is not implemented in GLUT versions before Version 4. It has been designed to be as close to GLUT as possible. Users who find differences should contact the freeglut Programming Consortium to have them fixed.\n\nThe function sets the window's mouse wheel callback. freeglut calls the mouse wheel callback when the user spins the mouse wheel.\n\nIf the mouse wheel is spun over your (sub)window, freeglut will report this via the MouseWheel callback. is the wheel number, is +/- 1, and and are the mouse coordinates.\n\n\n\n If you do not register a wheel callback, wheel events will be reported as mouse buttons.\n\nThis function is not implemented in GLUT.\n\nThe function is implemented in freeglut on X11 and Windows only. On other platforms, function stubs are provided so that GLUT-based programs can compile and link against freeglut without modification.\n\nThe function sets the window's Spaceball motion callback. freeglut invokes this callback when the user push/pull Spaceball cap in x, y, and z directions.\n\nThe x, y, and z arguments indicate the amount of translation in integer along x, y, and z axis respectively.\n\nThe x, y, and z axes form a common OpenGL right-handed coordinate system. A positive value of x, y, or z indicates movement along the positive direction of the respective axis, while the negative one denotes movement along negative direction.\n\nThe function is implemented in freeglut on X11 and Windows only. On other platforms, function stubs are provided so that GLUT-based programs can compile and link against freeglut without modification.\n\nThe function sets the window's Spaceball rotation callback. freeglut invokes this callback when the user rotates/twists Spaceball cap.\n\nThe rx, ry, and rz arguments indicate the amount of rotation in integer with respect to x, y, and z axis respectively.\n\nThe x, y, and z axes form a common OpenGL right-handed coordinate system. Positive value of rx, ry, or rz indicates counter-clock wise rotation along the respective axis, while negative one denotes clock wise rotation.\n\nThe function is implemented in freeglut on X11 and Windows only. On other platforms, function stubs are provided so that GLUT-based programs can compile and link against freeglut without modification.\n\nThe function sets the window's Spaceball button callback. freeglut invokes this callback when the user presses/releases one of the Spaceball buttons.\n\nThe button argument may take one of the following defined constant values:\n\nThe updown argument may take one of the two defined constant values:\n• GLUT_DOWN, GLUT_UP indicating if button is pressed or released.\n\nThe defines for the button argument of the callback are not provided by GLUT, but the numerical values returned are the same.\n\nThe function sets the global dials&buttons box callback. freeglut calls the callback when there is input from the box buttons.\n\nThe Dials&Buttons box is an ancient device presenting several pushable or rotatable buttons, sending the events to the computer via serial I/O.\n\n See http://www.reputable.com/sgipix/sgi-dialnbutton1.jpg [1] for instance.\n\nThe function sets the global dials&buttons box callback. freeglut calls the callback when there is input from the box dials.\n\nThe Dials&Buttons box is an ancient device presenting several pushable or rotatable buttons, sending the events to the computer via serial I/O.\n\n See http://www.reputable.com/sgipix/sgi-dialnbutton1.jpg [1] for instance.\n\nThe function is not implemented in freeglut, although the library does \"answer the mail\" to the extent that a call to the function will not produce an error..\n\nThe function is not implemented in freeglut.\n\nThe function is not implemented in freeglut, although the library does \"answer the mail\" to the extent that a call to the function will not produce an error..\n\nThe function is not implemented in freeglut.\n\nThe and the functions set the window's visibility and windowStatus callbacks for the current window. Setting one overwrites the other. freeglut calls these callbacks when the visibility status of a window changes.\n\nis deprecated and superseded by the more informative .\n\n For , the state callback parameter is one of GLUT_HIDDEN, GLUT_FULLY_RETAINED, GLUT_PARTIALLY_RETAINED, or GLUT_FULLY_COVERED depending on the current window status of the window. GLUT_HIDDEN means that the window is not shown (often meaning that the window is iconified). GLUT_FULLY_RETAINED means that the window is fully retained (no pixels belonging to the window are covered by other windows). GLUT_PARTIALLY_RETAINED means that the window is partially retained (some but not all pixels belonging to the window are covered by other windows). GLUT_FULLY_COVERED means the window is shown but no part of the window is visible, i.e., until the window's status changes, all further rendering to the window is discarded.\n\n GLUT considers a window visible if any pixel of the window is visible or any pixel of any descendant window is visible on the screen.\n\n GLUT applications are encouraged to disable rendering and/or animation when windows have a status of either GLUT_HIDDEN or GLUT_FULLY_COVERED.\n\n If the window status callback for a window is disabled and later re-enabled, the window status of the window is undefined; any change in window window status will be reported, that is if you disable a window status callback and re-enable the callback, you are guaranteed the next window status change will be reported.\n\n Setting the window status callback for a window disables the visibility callback set for the window (and vice versa). The visibility callback is set with , and its state callback parameter is either GLUT_NOT_VISIBLE or GLUT_VISIBLE depending on the current visibility of the window. GLUT_VISIBLE does not distinguish a window being totally versus partially visible. GLUT_NOT_VISIBLE means no part of the window is visible, i.e., until the window's visibility changes, all further rendering to the window is discarded.\n\n Not all window managers support such finegrained callback messages or can even ensure basic correctness. On Windows, there are no notifications if the visibility status of a window changes and freeglut might be in visible state even if the window is fully obscured by other windows.\n\nAllows you to set some general state/option variables.\n\nStores the into a state variable named by .\n\nThe following state variables can be set:\n• GLUT_ACTION_ON_WINDOW_CLOSE - Controls what happens when a window is closed by the user or system. GLUT_ACTION_EXIT will immediately exit the application (default, GLUT's behavior). GLUT_ACTION_GLUTMAINLOOP_RETURNS will immediately return from the main loop. GLUT_ACTION_CONTINUE_EXECUTION will contine execution of remaining windows.\n• GLUT_INIT_DISPLAY_MODE - Set the display mode for a new window, see\n• GLUT_INIT_WINDOW_X - Set the initial horizontal position of new windows.\n• GLUT_INIT_WINDOW_Y - Set the initial vertical position of new windows.\n• GLUT_INIT_WINDOW_WIDTH - Set the width of new windows.\n• GLUT_INIT_WINDOW_HEIGHT - Set the height of new windows.\n• GLUT_RENDERING_CONTEXT - Set to either GLUT_CREATE_NEW_CONTEXT or GLUT_USE_CURRENT_CONTEXT to indicate whether to share the current OpenGL rendering context with new windows.\n• GLUT_WINDOW_CURSOR - Set the current window's cursor as if by glutSetCursor().\n• GLUT_AUX - Set the number of auxiliary buffers requested for new windows if GLUT_AUX was set in the displayMode.\n• GLUT_MULTISAMPLE - Set the number of samples to request for new windows if GLUT_MULTISAMPLE was set in the displayMode.\n• GLUT_GEOMETRY_VISUALIZE_NORMALS - Set whether freeglut's geometric object rendering functions also visualize the object's normals or not.\n• GLUT_STROKE_FONT_DRAW_JOIN_DOTS - Set whether join dots are drawn between line segments when drawing letters of stroke fonts or not.\n• GLUT_ALLOW_NEGATIVE_WINDOW_POSITION - Set if negative positions can be used for window coordinates.\n\nThis function is not implemented in GLUT.\n\nThe following state variables may be queried with . The returned value is an integer.\n\nThese queries are with respect to the current window:\n• GLUT_WINDOW_BORDER_HEIGHT - height of non-client area above window, including both border and caption (if any)\n• GLUT_WINDOW_BUFFER_SIZE - number of color (including alpha) or color index bits per pixel\n• GLUT_WINDOW_STENCIL_SIZE - number of bits per stencil value\n• GLUT_WINDOW_DEPTH_SIZE - number of bits per depth value\n• GLUT_WINDOW_RED_SIZE - number of bits per red value\n• GLUT_WINDOW_GREEN_SIZE - number of bits per green value\n• GLUT_WINDOW_BLUE_SIZE - number of bits per blue value\n• GLUT_WINDOW_ALPHA_SIZE - number of bits per alpha value\n• GLUT_WINDOW_ACCUM_RED_SIZE - number of red bits in the accumulation buffer\n• GLUT_WINDOW_ACCUM_GREEN_SIZE - number of green bits in the accumulation buffer\n• GLUT_WINDOW_ACCUM_BLUE_SIZE - number of blue bits in the accumulation buffer\n• GLUT_WINDOW_ACCUM_ALPHA_SIZE - number of alpha bits in the accumulation buffer\n• GLUT_WINDOW_DOUBLEBUFFER - 1 if the color buffer is double buffered, 0 otherwise\n• GLUT_WINDOW_RGBA - 1 if the color buffers are RGB[A], 0 for color index\n• GLUT_WINDOW_COLORMAP_SIZE - number of entries in the window's colormap\n• GLUT_WINDOW_NUM_SAMPLES - number of samples per pixel if using multisampling\n• GLUT_WINDOW_STEREO - 1 if the window supports stereo, 0 otherwise\n• GLUT_WINDOW_FORMAT_ID - on Windows, return the pixel format number of the current window\n• GLUT_FULL_SCREEN - 1 if window is currently in fullscreen mode\n\nThese queries do not depend on the current window.\n• GLUT_SCREEN_WIDTH - width of the screen in pixels\n• GLUT_SCREEN_HEIGHT - height of the screen in pixels\n• GLUT_SCREEN_WIDTH_MM - width of the screen in millimeters\n• GLUT_SCREEN_HEIGHT_MM - height of the screen in millimeters\n• GLUT_MENU_NUM_ITEMS - number of items in the current menu\n• GLUT_DISPLAY_MODE_POSSIBLE - return 1 if the current display mode is supported, 0 otherwise\n• GLUT_INIT_DISPLAY_MODE - display mode last set by glutInitDisplayMode or glutSetOption(GLUT_INIT_DISPLAY_MODE, value)\n• GLUT_ELAPSED_TIME - time (in milliseconds) elapsed since glutInit or glutGet(GLUT_ELAPSED_TIME) was first called\n• GLUT_INIT_STATE - 1 if freeglut has been initialized through a call to\n• GLUT_VERSION - Return value will be X*10000+Y*100+Z where X is the major version, Y is the minor version and Z is the patch level. This query is only supported in freeglut (version 2.0.0 or later).\n• GLUT_ALLOW_NEGATIVE_WINDOW_POSITION - 1 if negative window positions are enabled, 0 otherwise\n\nName of an OpenGL or GLUT function.\n\nis useful for dealing with OpenGL extensions. If an application calls OpenGL extension functions directly, that application will only link/run with an OpenGL library that supports the extension. By using a function pointer returned from glutGetProcAddress(), the application will avoid this hard dependency and be more portable and interoperate better with various implementations of OpenGL.\n\nBoth OpenGL functions and freeglut functions can be queried with this function.\n\nGLUT does not include this function.\n\nfreeglut supports two types of font rendering: bitmap fonts, which are rendered using the function call, and stroke fonts, which are rendered as sequences of OpenGL line segments. Because they are rendered as bitmaps, the bitmap fonts tend to render more quickly than stroke fonts, but they are less flexible in terms of scaling and rendering. Bitmap font characters are positioned with calls to the functions while stroke font characters use the OpenGL transformations to position characters.\n\nIt should be noted that freeglut fonts are similar but not identical to GLUT fonts. At the moment, freeglut fonts do not support the \"`\" (backquote) and \"|\" (vertical line) characters; in their place it renders asterisks.\n• - A variable-width font with every character fitting in a rectangle of 13 pixels high by at most 8 pixels wide.\n• - A variable-width font with every character fitting in a rectangle of 15 pixels high by at most 9 pixels wide.\n\nfreeglut calls to advance the cursor by the width of a character and to render carriage returns when appropriate. It does not use any display lists in it rendering in bitmap fonts.\n\nfreeglut does not use any display lists in its rendering of stroke fonts. It calls to advance the cursor by the width of a character and to render carriage returns when appropriate.\n\nThe function renders a single bitmapped character in the current window using the specified font.\n\nThe bitmapped font to use in rendering the character \n\n The ASCII code of the character to be rendered\n\nThe function renders the given character in the specified bitmap font. freeglut automatically sets the necessary pixel unpack storage modes and restores the existing modes when it has finished. Before the first call to the application program should call to set the position of the character in the window. The function advances the cursor position as part of its call to and so the application does not need to call again for successive characters on the same line.\n\nNonexistent characters are rendered as asterisks. The rendering position in freeglut is apparently off from GLUT's position by a few pixels vertically and one or two pixels horizontally.\n\nThe function renders a string of bitmapped characters in the current window using the specified font.\n\nThe bitmapped font to use in rendering the character string \n\n String of characters to be rendered\n\nThe function renders the given character string in the specified bitmap font. freeglut automatically sets the necessary pixel unpack storage modes and restores the existing modes when it has finished. Before calling the application program should call to set the position of the string in the window. The function handles carriage returns. Nonexistent characters are rendered as asterisks.\n\nGLUT does not include this function.\n\nThe function returns the width in pixels of a single bitmapped character in the specified font.\n\nThe bitmapped font to use in calculating the character width \n\n The ASCII code of the character\n\nThe function returns the width of the given character in the specified bitmap font. Because the font is bitmapped, the width is an exact integer.\n\nNonexistent characters return the width of an asterisk.\n\nThe function returns the width in pixels of a string of bitmapped characters in the specified font.\n\nThe bitmapped font to use in calculating the character width \n\n String of characters whose width is to be calculated\n\nThe function returns the width in pixels of the given character string in the specified bitmap font. Because the font is bitmapped, the width is an exact integer: the return value is identical to the sum of the character widths returned by a series of calls to . The width of nonexistent characters is counted to be the width of an asterisk.\n\nIf the string contains one or more carriage returns, freeglut calculates the widths in pixels of the lines separately and returns the largest width.\n\nGLUT does not include this function.\n\nThe function returns the height in pixels of the specified font.\n\nThe bitmapped font to use in calculating the character height\n\nThe function returns the height of a character in the specified bitmap font. Because the font is bitmapped, the height is an exact integer. The fonts are designed such that all characters have (nominally) the same height.\n\nGLUT does not include this function.\n\nThe function renders a single stroke character in the current window using the specified font.\n\nThe stroke font to use in rendering the character \n\n The ASCII code of the character to be rendered\n\nThe function renders the given character in the specified stroke font. Before the first call to the application program should call the OpenGL transformation (positioning and scaling) functions to set the position of the character in the window. The function advances the cursor position by a call to and so the application does not need to call the OpenGL positioning functions again for successive characters on the same line.\n\nThe function renders a string of characters in the current window using the specified stroke font.\n\nThe stroke font to use in rendering the character string \n\n String of characters to be rendered\n\nThe function renders the given character string in the specified stroke font. Before calling the application program should call the OpenGL transformation (positioning and scaling) functions to set the position of the string in the window. The function handles carriage returns. Nonexistent characters are rendered as asterisks.\n\nGLUT does not include this function.\n\nThe function returns the width in model units of a single character in the specified stroke font, rounded to an int.\n\nThe stroke font to use in calculating the character width \n\n The ASCII code of the character\n\nThe function returns the width of the given character in the specified stroke font. Because the font is a stroke font, the width is actually a floating-point number; the function rounds it to the nearest integer for the return value.\n\nNonexistent characters return the width of an asterisk.\n\nThe function returns the width in model units of a single character in the specified stroke font.\n\nThe stroke font to use in calculating the character width \n\n The ASCII code of the character\n\nThe function returns the width of the given character in the specified stroke font. Function was included in an unreleased GLUT 3.8.\n\nNonexistent characters return the width of an asterisk.\n\nThe function returns the width in model units of a string of characters in the specified stroke font, rounded to an int.\n\nThe stroke font to use in calculating the character width \n\n String of characters whose width is to be calculated\n\nThe function returns the width in model units of the given character string in the specified stroke font. Because the font is a stroke font, the width of an individual character is a floating-point number. freeglut adds the floating-point widths and rounds the final result to return the integer value. Thus the return value may differ from the sum of the character widths returned by a series of calls to . The width of nonexistent characters is counted to be the width of an asterisk.\n\nIf the string contains one or more carriage returns, freeglut calculates the widths in pixels of the lines separately and returns the largest width.\n\nThe function returns the width in model units of a string of characters in the specified stroke font.\n\nThe stroke font to use in calculating the character width \n\n String of characters whose width is to be calculated\n\nThe function returns the width in model units of the given character string in the specified stroke font. The return value is equal to the sum of the character widths returned by a series of calls to . Function was included in an unreleased GLUT 3.8. The width of nonexistent characters is counted to be the width of an asterisk.\n\nIf the string contains one or more carriage returns, freeglut calculates the widths in pixels of the lines separately and returns the largest width.\n\nThe function returns the height in pixels of the specified font.\n\nThe stroke font to use in calculating the character height\n\nThe function returns the height of a character in the specified stroke font. The application programmer should note that, unlike the other freeglut font functions, this one returns a floating-point number. The fonts are designed such that all characters have (nominally) the same height.\n\nGLUT does not include this function.\n\nfreeglut includes twenty two routines for generating easily-recognizable 3-d geometric objects. These routines are effectively the same ones that are included in the GLUT library, and reflect the functionality available in the aux toolkit described in the OpenGL Programmer's Guide. They are included to allow programmers to create with a single line of code a three-dimensional object which can be used to test a variety of OpenGL functionality. None of the routines generates a display list for the object which it draws. The functions generate normals appropriate for lighting but, except for the teapot functions, do not generate texture coordinates. Do note that depth testing (GL_LESS) should be enabled for the correct drawing of the nonconvex objects, i.e., the glutTorus, glutSierpinskiSponge, glutTeapot, glutTeacup and glutTeaspoon.\n\n Also see the option that can be set with . Lastly, see , , and if you wish to use these objects with shaders.\n\nThe and functions draw a wireframe and solid sphere respectively.\n\nThe desired radius of the sphere\n\nThe desired number of slices (divisions in the longitudinal direction) in the sphere\n\nThe desired number of stacks (divisions in the latitudinal direction) in the sphere. The number of points in this direction, including the north and south poles, is\n\nThe and functions render a sphere centered at the origin of the modeling coordinate system. The north and south poles of the sphere are on the positive and negative Z-axes respectively and the prime meridian crosses the positive X-axis.\n\nNone that we know of.\n\nThe and functions draw a wireframe and solid torus (donut shape) respectively.\n\nThe radius of the tube.\n\nThe distance from the center of the Torus to the center of the tube.\n\nThe desired number of segments in a single outer circle of the torus\n\nThe desired number of outer circles around the origin of the torus\n\nThe and functions render a torus centered at the origin of the modeling coordinate system. The torus is circularly symmetric about the Z-axis and starts at the positive X-axis.\n\nNone that we know of.\n\nThe and functions draw a wireframe and solid cone respectively.\n\nThe desired radius of the cylinder\n\nThe desired height of the cylinder\n\nThe desired number of slices around the cylinder\n\nThe desired number of segments between the base and the top of the cylinder (the number of points, including the tip, is )\n\nThe and functions draw a wireframe and solid cone respectively.\n\nThe desired radius of the base of the cone\n\nThe desired height of the cone\n\nThe desired number of slices around the base of the cone\n\nThe desired number of segments between the base and the tip of the cone (the number of points, including the tip, is )\n\nThe and functions render a right circular cone with a base centered at the origin and in the X-Y plane and its tip on the positive Z-axis. The wire cone is rendered with triangular elements.\n\nNone that we know of.\n\nThe and functions draw a wireframe and solid cube respectively.\n\nThe desired length of an edge of the cube\n\nThe and functions render a cube of the desired size, centered at the origin. Its faces are normal to the coordinate directions.\n\nNone that we know of.\n\nThe and functions draw a wireframe and solid tetrahedron (four-sided Platonic solid) respectively.\n\nThe and functions render a tetrahedron whose corners are each a distance of one from the origin. The length of each side is 2/3 sqrt(6). One corner is on the positive X-axis and another is in the X-Y plane with a positive Y-coordinate.\n\nNone that we know of.\n\nThe and functions draw a wireframe and solid octahedron (eight-sided Platonic solid) respectively.\n\nThe and functions render an octahedron whose corners are each a distance of one from the origin. The length of each side is sqrt(2). The corners are on the positive and negative coordinate axes.\n\nNone that we know of.\n\nThe and functions draw a wireframe and solid dodecahedron (twelve-sided Platonic solid) respectively.\n\nThe and functions render a dodecahedron whose corners are each a distance of sqrt(3) from the origin. The length of each side is sqrt(5)-1. There are twenty corners; interestingly enough, eight of them coincide with the corners of a cube with sizes of length 2.\n\nNone that we know of.\n\nThe and functions draw a wireframe and solid icosahedron (twenty-sided Platonic solid) respectively.\n\nThe and functions render an icosahedron whose corners are each a unit distance from the origin. The length of each side is slightly greater than one. Two of the corners lie on the positive and negative X-axes.\n\nNone that we know of.\n\nThe and functions draw a wireframe and solid rhombic dodecahedron (twelve-sided semi-regular solid) respectively.\n\nThe and functions render a rhombic dodecahedron whose corners are at most a distance of one from the origin. The rhombic dodecahedron has faces which are identical rhombuses (rhombi?) but which have some vertices at which three faces meet and some vertices at which four faces meet. The length of each side is sqrt(3)/2. Vertices at which four faces meet are found at (0, 0, +/- 1) and (+/- sqrt(2)/2, +/- sqrt(2)/2, 0).\n\nGLUT does not include these functions.\n\nThe and functions draw a wireframe and solid teapot respectively, the and functions a wireframe and solid teacup, and the and functions a wireframe and solid teaspoon.\n\nThe desired size of the teapot, teacup and teaspoon - relative to a \"standard\" size\n\nThe and functions render a teapot of the desired size, centered at the origin. This is the famous teapot created by Martin Newell. The other functions render the teacup and teaspoon he used in the table scene figure in his PhD thesis. Vertex data retrieved from: ftp://ftp.funet.fi/pub/sci/graphics/packages/objects/teasetorig.gz.\n\nOpenGL's default state assumes that front facing polygons (for the purpose of face culling) have vertices that wind counter clockwise when projected into window space. This teapot, teacup and teaspoon are rendered with their front facing polygon vertices winding clockwise. For OpenGL's default back face culling to work, you should use:\n\nThis bug reflect issues in the original teaset's vertex data (and is thus present in GLUT too).\n\nGLUT only has the teapot and misses the rest of the teaset.\n\nTo draw shapes with shaders (OpenGL 2 and later), one need to upload vertices and associated normal vectors and texture coordinates to vertex attributes of your shaders. Use these functions to set the indices (addresses) of the vertex attributes in your currently active shaders before calling the above geometry functions, and freeglut will upload the object geometry there. Texture coordinates are only generated for the teapot, teacup and teaspoon.\n\nThe index (address) of the vertex attribute\n\nGLUT does not include these functions.\n\nSpecify the display mode that should be entered when GameMode is entered. Default is the current display mode of the monitor on which the GameMode screen will be opened.\n\nUsage\n\n A string is passed to this function that specifies a combination of resolution, pixel depth (ignored on Linux) and refresh rate. Valid formats are:\n\nAttempt to change to the requested display mode and open the GameMode window, or close the GameMode window and return to the original display mode. For multi-monitor display setups, freeglut can be told on which monitor the gamemode window should be opened by providing the command line option to .\n\nThe following state variables may be queried with . The returned value is an integer.\n• GLUT_GAME_MODE_ACTIVE - 1 if currently in GameMode\n• GLUT_GAME_MODE_DISPLAY_CHANGED - 1 if currently in GameMode\n• GLUT_GAME_MODE_POSSIBLE - 1 if display mode requested with is possible\n\nThese queries return information about the current display mode if in GameMode, or about the requested display mode entering GameMode:\n\nThese functions are not implemented in freeglut.\n• Support a 2-fingers gesture such as pinch-to-zoom on the touchscreen, while the mouse pointer or touchpad is performing an unrelated action, not part of the touchscreen gesture (may not be possible on some platforms).\n• Avoid touch id conflicts between touchscreen and touchpad/gamepad on Android; a possible work-around is to shift the device id in the touch id.\n\nSince this extra support comes at the cost of extra complexity, we're considering whether/how to implement it.\n\nThese new callbacks were added:\n• : called when the context is initialized or re-initialized (e.g. after a pause). Has user-data callback function.\n• : called when the application's status changes, with event identifying the state entered. Has user-data callback function. Possible states:\n• application goes on a pause (or a stop) → GLUT_APPSTATUS_PAUSE\n• application comes back from a pause → GLUT_APPSTATUS_RESUME. Is called after the callback.\n• Android support is further described at the Android page.\n\nThe and functions set whether repeated key presses (generated by keeping a key depressed) are passed on to the keyboard callbacks. allows to globally switch off key repeat, while offers control over this behavior on a per-window basis.\n\nGLUT_KEY_REPEAT_OFF to globally switch key repeat off, or GLUT_KEY_REPEAT_ON and GLUT_KEY_REPEAT_DEFAULT to globally switch key repeat on.\n\n if non-zero, key repeat is switched off for the current window.\n\nIf key repeat is globally switched off through , it cannot be reenabled on a per-window basis with . If you want per-window control of key repeat, set to and use to switch off key repeat for the windows for which you don't want it.\n\nNate Robbins' port of GLUT to win32 did not implement , but freeglut's behavior should conform on all platforms to GLUT's behavior on X11.\n\nThe following environment variables are recognized by freeglut:\n• GLUT_FPS - specifies a time interval (in milliseconds) for reporting framerate messages to stderr. For example, if FREEGLUT_FPS is set to 5000, every 5 seconds a message will be printed to stderr showing the current frame rate. The frame rate is measured by counting the number of times glutSwapBuffers() is called over the time interval.\n\nFurthermore, on windows, there is a resource file identifier GLUT_ICON that you can specify for your executable file. It specifies the icon that goes in the upper left-hand corner of the freeglut windows. Your application's resource file should contain the line:\n\n \n\n where icon.ico is the filename of your icon. The One demo includes such an icon as an example.\n\nApplication programmers who are porting their GLUT programs to freeglut may continue to include in their programs. Programs which use the freeglut-specific extensions to GLUT should include . One possible arrangement is as follows:\n\nIt was initially planned to define , , , etc., but this was only done for . This constant still exist in current freeglut releases but is deprecated.\n\nThe freeglut version can be queried at runtime by calling glutGet(GLUT_VERSION). The result will be X*10000+Y*100+Z where X is the major version, Y is the minor version and Z is the patch level.\n\nThis may be used as follows:"
    },
    {
        "link": "https://www3.ntu.edu.sg/home/ehchua/programming/opengl/CG_Introduction.html",
        "document": "An Introduction on OpenGL with 2D Graphics\n\nTo set up OpenGL, depending on your programming platform, read:\n• How to write OpenGL programs in C/C++.\n• How to write OpenGL programs in Java: JOGL or LWJGL.\n• How to write OpenGL|ES programs in Android.\n\nExample 1: Setting Up OpenGL and GLUT ( )\n\nMake sure that you can run the \" \" described in \"How to write OpenGL programs in C/C++\", reproduced below:\n\nThe header \" \" is needed for the Windows platform only.\n\nWe also included the GLUT header, which is guaranteed to include \" \" (for GL Utility) and \" \" (for Core OpenGL).\n\nThe rest of the program will be explained in due course.\n\nOpenGL (Open Graphics Library) is a cross-platform, hardware-accelerated, language-independent, industrial standard API for producing 3D (including 2D) graphics. Modern computers have dedicated GPU (Graphics Processing Unit) with its own memory to speed up graphics rendering. OpenGL is the software interface to graphics hardware. In other words, OpenGL graphic rendering commands issued by your applications could be directed to the graphic hardware and accelerated.\n\nWe use 3 sets of libraries in our OpenGL programs:\n• : consists of hundreds of commands, which begin with a prefix \" \" (e.g., , , , ). The Core OpenGL models an object via a set of geometric primitives such as point, line and polygon.\n• : built on-top of the core OpenGL to provide important utilities (such as setting camera view and projection) and more building models (such as qradric surfaces and polygon tessellation). GLU commands start with a prefix \" \" (e.g., , ).\n• : OpenGL is designed to be independent of the windowing system or operating system. GLUT is needed to interact with the Operating System (such as creating a window, handling key and mouse inputs); it also provides more building models (such as sphere and torus). GLUT commands start with a prefix of \" \" (e.g., , ). GLUT is platform independent, which is built on top of platform-specific OpenGL extension such as GLX for X Window System, WGL for Microsoft Window, and AGL, CGL or Cocoa for Mac OS.\n\n Quoting from the opengl.org: \"GLUT is designed for constructing small to medium sized OpenGL programs. While GLUT is well-suited to learning OpenGL and developing simple OpenGL applications, GLUT is not a full-featured toolkit so large applications requiring sophisticated user interfaces are better off using native window system toolkits. GLUT is simple, easy, and small.\"\n\n Alternative of GLUT includes SDL, ....\n• : \"GLEW is a cross-platform open-source C/C++ extension loading library. GLEW provides efficient run-time mechanisms for determining which OpenGL extensions are supported on the target platform.\" Source and pre-build binary available at http://glew.sourceforge.net/. A standalone utility called \" \" (under the \" \" directory) can be used to produce the list of OpenGL functions supported by your graphics system.\n\nTry building and runnng this OpenGL C/C++ program:\n\nThe expected output and the coordinates are as follows. Take note that 4 shapes have pure color, and 2 shapes have color blending from their vertices.\n\nI shall explain the program in the following sections.\n\nOpenGL operates as a state machine, and maintain a set of state variables (such as the foreground color, background color, and many more). In a state machine, once the value of a state variable is set, the value persists until a new value is given.\n\nFor example, we set the \"clearing\" (background) color to black once in . We use this setting to clear the window in the repeatedly ( is called back whenever there is a window re-paint request) - the clearing color is not changed in the entire program.\n\nAnother example: If we use function to set the current foreground color to \"red\", then \"red\" will be used for all the subsequent vertices, until we use another function to change the foreground color.\n\nIn a state machine, everything shall remain until you explicitly change it!\n• begins with lowercase (for core OpenGL), (for OpenGL Utility) or (for OpenGL Utility Toolkit).\n• followed by the purpose of the function, in camel case (initial-capitalized), e.g., to specify the drawing color, to define the position of a vertex.\n• followed by specifications for the parameters, e.g., takes three parameters. takes two parameters. \n\n (This is needed as C Language does not support function overloading. Different versions of the function need to be written for different parameter lists.)\n\nThe convention can be expressed as follows:\n\nThe function may take 2, 3, or 4 parameters, in type of ( ), ( ), ( ) or ( ). The ' ' (for vector) denotes that the parameters are kept in an array of 2, 3, or 4 elements, and pass into the function as an array pointer.\n• Floating-point numbers: (32-bit), (64-bit), and (between 0.0 and 1.0).\n• (unsigned char with 0 for false and non-0 for true).\n\nThe OpenGL types are defined via in \" \" as follows:\n\nOpenGL's constants begins with \" \", \" \" or \" \", in uppercase separated with underscores, e.g., .\n\nThe is meant for carrying out one-time OpenGL initialization tasks, such as setting the clearing color. is invoked once (and only once) in .\n\nThe function is known as a callback event handler. An event handler provides the response to a particular event (such as key-press, mouse-click, window-paint). The function is meant to be the handler for window-paint event. The OpenGL graphics system calls back in response to a window-paint request to re-paint the window (e.g., window first appears, window is restored after minimized, and window is resized). Callback means that the function is invoked by the system, instead of called by the your program.\n\nThe runs when the window first appears and once per subsequent re-paint request. Observe that we included OpenGL graphics rendering code inside the function, so as to re-draw the entire window when the window first appears and upon each re-paint request.\n\nGLUT provides high-level utilities to simplify OpenGL programming, especially in interacting with the Operating System (such as creating a window, handling key and mouse inputs). The following GLUT functions were used in the above program:\n• : initializes GLUT, must be called before other GL/GLUT functions. It takes the same arguments as the .\n• : creates a window with the given title.\n• : specifies the initial window width and height, in pixels.\n• : positions the top-left corner of the initial window at (x, y). The coordinates (x, y), in term of pixels, is measured in window coordinates, i.e., origin (0, 0) is at the top-left corner of the screen; x-axis pointing right and y-axis pointing down.\n• : registers the callback function (or event handler) for handling window-paint event. The OpenGL graphic system calls back this handler when it receives a window re-paint request. In the example, we register the function as the handler.\n• : enters the infinite event-processing loop, i.e, put the OpenGL graphics system to wait for events (such as re-paint), and trigger respective event handlers (such as ).\n\nIn the function of the example:\n\nWe initialize the GLUT and create a window with a title, an initial size and position.\n\nWe register function as the callback handler for window-paint event. That is, runs when the window first appears and whenever there is a request to re-paint the window.\n\nWe call the to perform all the one-time initialization operations. In this example, we set the clearing (background) color once, and use it repeatably in the function.\n\nWe then put the program into the event-handling loop, awaiting for events (such as window-paint request) to trigger off the respective event handlers (such as ).\n\nWe use function to set the foreground color, and function to set the background (or clearing) color.\n• Color is typically specified in in the range and .\n• Color can be specified using RGB (Red-Green-Blue) or RGBA (Red-Green-Blue-Alpha) components. The 'A' (or alpha) specifies the transparency (or opacity) index, with value of 1 denotes opaque (non-transparent and cannot see-thru) and value of 0 denotes total transparent. We shall discuss alpha later.\n\nIn the above example, we set the background color via in , with R=0, G=0, B=0 (black) and A=1 (opaque and cannot see through).\n\nIn , we set the vertex color via for subsequent vertices. For example, R=1, G=0, B=0 (red).\n\nIn OpenGL, an object is made up of geometric primitives such as triangle, quad, line segment and point. A primitive is made up of one or more vertices. OpenGL supports the following primitives:\n\nA geometric primitive is defined by specifying its vertices via function, enclosed within a pair and .\n\nspecifies the type of geometric object, such as , , , , and . For types that end with ' ', you can define multiple objects of the same type in each / pair. For example, for , each set of three 's defines a triangle.\n\nThe vertices are usually specified in precision. It is because integer is not suitable for trigonometric operations (needed to carry out transformations such as rotation). Precision of is sufficient for carrying out intermediate operations, and render the objects finally into pixels on screen (with resolution of says 800x600, integral precision). precision is often not necessary.\n\nIn the above example:\n\nWe set the color to red (R=1, G=0, B=0). All subsequent vertices will have the color of red. Take note that in OpenGL, color (and many properties) is applied to vertices rather than primitive shapes. The color of the a primitive shape is interpolated from its vertices.\n\nWe similarly define a second quad in green.\n\nFor the third quad (as follows), the vertices have different color. The color of the quad surface is interpolated from its vertices, resulting in a shades of white to dark gray, as shown in the output.\n\nThe following diagram shows the OpenGL 2D Coordinate System, which corresponds to the everyday 2D Cartesian coordinates with origin located at the bottom-left corner.\n\nThe default OpenGL 2D clipping-area (i.e., what is captured by the camera) is an orthographic view with x and y in the range of -1.0 and 1.0, i.e., a 2x2 square with centered at the origin. This clipping-area is mapped to the viewport on the screen. Viewport is measured in pixels.\n\nStudy the above example to convince yourself that the 2D shapes created are positioned correctly on the screen.\n\nTry dragging the corner of the window to make it bigger or smaller. Observe that all the shapes are distorted.\n\nWe can handle the re-sizing of window via a callback handler , which can be programmed to adjust the OpenGL clipping-area according to the window's aspect ratio.\n\nClipping Area: Clipping area refers to the area that can be seen (i.e., captured by the camera), measured in OpenGL coordinates.\n\nThe function can be used to set the clipping area of 2D orthographic view. Objects outside the clipping area will be clipped away and cannot be seen.\n\nTo set the clipping area, we need to issue a series of commands as follows: we first select the so-called projection matrix for operation, and reset the projection matrix to identity. We then choose the 2D orthographic view with the desired clipping area, via .\n\nViewport: Viewport refers to the display area on the window (screen), which is measured in pixels in screen coordinates (excluding the title bar).\n\nThe clipping area is mapped to the viewport. We can use function to configure the viewport.\n\nSuppose the the clipping area's (left, right, bottom, top) is (-1.0, 1.0, -1.0, 1.0) (in OpenGL coordinates) and the viewport's (xTopLeft, xTopRight, width, height) is (0, 0, 640, 480) (in screen coordinates in pixels), then the bottom-left corner (-1.0, -1.0) maps to (0, 0) in the viewport, the top-right corner (1.0, 1.0) maps to (639, 479). It is obvious that if the aspect ratios for the clipping area and the viewport are not the same, the shapes will be distorted.\n\nTake note that in the earlier example, the windows' size of 320x320 has a square shape, with a aspect ratio consistent with the default 2x2 squarish clipping-area.\n\nA function, which is called back when the window first appears and whenever the window is re-sized, can be used to ensure consistent aspect ratio between clipping-area and viewport, as shown in the above example. The graphics sub-system passes the window's width and height, in pixels, into the .\n\nWe compute the aspect ratio of the new re-sized window, given its new and provided by the graphics sub-system to the callback function .\n\nWe set the viewport to cover the entire new re-sized window, in pixels. \n\n Try setting the viewport to cover only a quarter (lower-right qradrant) of the window via .\n\nWe set the aspect ratio of the clipping area to match the viewport. To set the clipping area, we first choose the operate on the projection matrix via . OpenGL has two matrices, a projection matrix (which deals with camera projection such as setting the clipping area) and a model-view matrix (for transforming the objects from their local spaces to the common world space). We reset the projection matrix via .\n\nFinally, we invoke to set the clipping area with an aspect ratio matching the viewport. The shorter side has the range from -1 to +1, as illustrated below:\n\nWe need to register the callback handler with GLUT via in the as follows:\n\nIn the above function, we specify the initial window size to , which is non-squarish. Try re-sizing the window and observe the changes.\n\nNote that the runs at least once when the window first appears. It is then called back whenever the window is re-shaped. On the other hand, the runs once (and only once); and the runs in response to window re-paint request (e.g., after the window is re-sized).\n\nIn the above sample, we positioned each of the shapes by defining their vertices with respective to the same origin (called world space). It took me quite a while to figure out the absolute coordinates of these vertices.\n\nInstead, we could position each of the shapes by defining their vertices with respective to their own center (called model space or local space). We can then use translation and/or rotation to position the shapes at the desired locations in the world space, as shown in the following revised function.\n\nTranslation and rotation are parts of so-called model transform, which transform from the objects from the local space (or model space) to the common world space. To carry out model transform, we set the matrix mode to mode-view matrix ( ) and reset the matrix. (Recall that in the previous example, we set the matrix mode to projection matrix ( ) to set the clipping area.)\n\nOpenGL is operating as a state machine. That is, once a state is set, the value of the state persists until it is changed. In other words, once the coordinates are translated or rotated, all the subsequent operations will be based on this coordinates.\n\nTranslation is done via function:\n\nTake note that function must be placed outside the / , where as can be placed inside / .\n\nRotation is done via function:\n\nTake note that the rotational angle is measured in degrees (instead of radians) in OpenGL.\n\nIn the above example, we translate within the x-y plane (z=0) and rotate about the z-axis (which is normal to the x-y plane).\n\nTo perform animation (e.g., rotating the shapes), you could register an callback handler with GLUT, via command. The graphic system will call back the function when there is no other event to be processed.\n\nIn the function, you could issue command to post a window re-paint request, which in turn will activate function.\n\nTake note that the above is equivalent to registering as the function.\n\nDouble buffering uses two display buffers to smoothen animation. The next screen is prepared in a back buffer, while the current screen is held in a front buffer. Once the preparation is done, you can use command to swap the front and back buffers.\n\nTo use double buffering, you need to make two changes:\n• In the , include this line before creating the window:\n• In the function, replace with , which swap the front and back buffers.\n\nDouble buffering should be used in animation. For static display, single buffering is sufficient. (Many graphics hardware always double buffered, so it is hard to see the differences.)\n\nThe following program rotates all the shapes created in our previous example using idle function with double buffering.\n\nIn the above example, instead of accumulating all the translations and undoing the rotations, we use to save the current state, perform transformations, and restore the saved state via . (In the above example, we can also use to reset the matrix before the next transformations.)\n\nWe define a global variable called to keep track of the rotational angle of all the shapes. We will later use to rotate all the shapes to this angle.\n\nAt the end of each refresh (in ), we update the rotational angle of all the shapes.\n\nInstead of which flushes the framebuffer for display immediately, we enable double buffering and use to swap the front- and back-buffer during the VSync for smoother display.\n\nWe define an function, which posts a re-paint request and invoke , if there is no event outstanding. We register this function in via .\n\nWhen double buffering is enabled, synchronizes with the screen refresh interval (VSync). That is, the buffers will be swapped at the same time when the monitor is putting up a new frame. As the result, function, at best, refreshes the animation at the same rate as the refresh rate of the monitor (60Hz for LCD/LED monitor). It may operates at half the monitor refresh rate (if the computations takes more than 1 refresh interval), one-third, one-fourth, and so on, because it need to wait for the VSync.\n\nWith , we have no control to the refresh interval. We could register a function with GLUT via . The function will be called back at the specified fixed interval.\n\nThe following modifications rotate all the shapes created in the earlier example counter-clockwise by 2 degree per 30 milliseconds.\n\nWe replace the function by a function, which post a re-paint request to invoke , after the timer expired.\n\nIn , we register the function, and activate the immediately (with initial timer = 0).\n• : requests a display with the specified mode, such as color mode ( , , ), single/double buffering ( , ), enable depth ( ), joined with a bit ' '.\n\nThis example shows a ball bouncing inside the window. Take note that circle is not a primitive geometric shape in OpenGL. This example uses to compose a circle.\n\nWe can register callback functions to handle keyboard inputs for normal and special keys, respectively.\n• : registers callback handler for special key (such as arrow keys and function keys).\n\nExample 8: Switching between Full-Screen and Windowed-mode ( )\n\nFor the bouncing ball program, the following special-key handler toggles between full-screen and windowed modes using F1 key.\n\n[TODO] Using to draw a Circle is inefficient (due to the compute-intensive and functions). Try using GLU's quadric.\n\nFor the bouncing ball program, the following key and special-key handlers provide exits with ESC (27), increase/decrease y speed with up-/down-arrow key, increase/decrease x speed with left-/right-arrow key, increase/decrease ball's radius with PageUp/PageDown key.\n\nSimilarly, we can register callback function to handle mouse-click and mouse-motion.\n• : registers callback handler for mouse motion (when the mouse is clicked and moved).\n\nFor the bouncing ball program, the following mouse handler pause the movement with left-mouse click, and resume with right-mouse click."
    },
    {
        "link": "https://codeproject.com/Articles/80923/The-OpenGL-and-GLUT-A-Powerful-Graphics-Library-an",
        "document": "One Quick Note to Get Started\n\nTo use OpenGL and GLUT, download OpenGL from http://www.videotutorialsrock.com/opengl2.exe.\n\nSimply install OpenGL and unzip the GLUT sources to the locations stated below. This will enable you to compile the code given. Note if your header file causes problems, then delete the GL to make the header file<glut.h>. So what is OpenGL, GLUT, and why would we want to use them? Those questions are the focus of this article.\n\nOpenGL is an interface to graphics hardware. GL stands for Graphics Library. As such, it is mainly a low-level graphics library specification. GL provides commands for specifying geometric objects in two or three dimensions, and for controlling how these objects are drawn on the display. Objects, in this case, are points, lines, polygons, images, and bitmaps. OpenGL does provide commands for performing windowing tasks or for obtaining user input. These commands are provided the OpenGL Utility Kit (GLUT). GLUT provides commands to create windows, subwindows, and menus; and to handle input from various devices via a callback function. When installing OpenGL, you must install the most recent version of GLUT, which provides four files: glut.h, glut.lib, glut.def, and glut32.dll. When working with GLUT on visual Studio, the header and library files must be placed in the VC++ include and library directories, respectively. The definition file has a relation to the DLLs, but the gllut32.dll must be placed in the %windir%\\system32 directory.\n\nSince OpenGL drawing commands are limited to those that generate simple geometric primitives (points, lines, and polygons), the OpenGL Utility Toolkit (GLUT) has been created to aid in the development of more complicated three-dimensional objects such as a sphere, a torus, and even a teapot. GLUT may not be satisfactory for full-featured OpenGL applications, but it is a useful starting point for learning OpenGL.\n\nGLUT is designed to fill the need for a window system independent programming interface for OpenGL programs. The interface is designed to be simple yet still meet the needs of useful OpenGL programs. Removing window system operations from OpenGL is a sound decision because it allows the OpenGL graphics system to be retargeted to various systems including powerful but expensive graphics workstations as well as mass-production graphics systems like video games, set-top boxes for interactive television, and PCs. GLUT simplifies the implementation of programs using OpenGL rendering. The GLUT application programming interface (API) requires very few routines to display a graphics scene rendered using OpenGL. The GLUT routines also take relatively few parameters.\n\nSo Show Me Some Code\n\nWhile it is early in the article, examine this code and how the code body is structured. Then examine the output, which is a window containing a basic triangle:\n\nWhen compiled on Visual Studio or on the command line, here is the output. But take care to notice the sequence of the functions that ensue the main body:\n\nRoutines beginning with the - prefix are used to initialize GLUT state. The primary initialization routine is that should only be called exactly once in a GLUT program. No non- - prefixed GLUT or OpenGL routines should be called before . The other - routines may be called before . The reason is these routines can be used to set default window initialization state that might be modified by the command processing done in . For example, can be called before to indicate 400 by 400 is the program’s default window size. Setting the initial window size or position before allows the GLUT program user to specify the initial size or position using command line arguments. is used to initialize the GLUT library.\n\nAn is a pointer to the program’s unmodified variable from . Upon return, the value pointed to by will be updated, because extracts any command line options intended for the GLUT library. argv The program’s unmodified variable from . Like , the data for will be updated because extracts any command line options understood by the GLUT library. will initialize the GLUT library and negotiate a session with the window system. During this process, may cause the termination of the GLUT program with an error message to the user if GLUT cannot be properly initialized. Examples of this situation include the failure to connect to the window system, the lack of window system support for OpenGL, and invalid command line options. also processes command line options, but the specific options parse are window system dependent.\n\n, : and the initial window position and size respectively.\n\nWindows created by will be requested to be created with the current initial window position and size. The initial value of the initial window position GLUT state is and . If either the X or Y component to the initial window position is negative, the actual window position is left to the window system to determine. The initial value of the size GLUT state is 300 by 300. The size components must be greater than zero. The intent of the initial window position and size values is to provide a suggestion to the window system for a window’s initial size and position. The window system is not obligated to use this information. Therefore, GLUT programs should not assume the window was created at the specified size or position. A GLUT program should use the window’s reshape callback to determine the true size of the window.\n\ncreates a top-level window. The name will be provided to the window system as the window’s name. The intent is that the window system will label the window with the name. Implicitly, the current window is set to the newly created window. Each created window has a unique associated OpenGL context. State changes to a window’s associated OpenGL context can be done immediately after the window is created. The display state of a window is initially for the window to be shown. But the window’s display state is not actually acted upon until is entered. This means until is called, rendering to a created window is ineffective because the window cannot yet be displayed. The value returned is a unique small integer identifier for the window. The range of allocated identifiers starts at one. This window identifier can be used when calling .\n\nsets the display callback for the current window. When GLUT determines that the normal plane for the window needs to be redisplayed, the display callback for the window is called. Before the callback, the current window is set to the window needing to be redisplayed and (if no overlay display callback is registered) the layer in use is set to the normal plane. The display callback is called with no parameters. The entire normal plane region should be redisplayed in response to the callback (this includes ancillary buffers if your program depends on their state). GLUT determines when the display callback should be triggered based on the window’s redisplay state.\n\nThe redisplay state for a window can be either set explicitly by calling or implicitly as the result of window damage reported by the window system. Multiple posted redisplays for a window are coalesced by GLUT to minimize the number of display callbacks called. When an overlay is established for a window, but there is no overlay display callback registered, the display callback is used for redisplaying both the overlay and normal plane (that is, it will be called if either the redisplay state or overlay redisplay state is set). In this case, the layer in use is not implicitly changed on entry to the display callback. When a window is created, no display callback exists for the window. It is the responsibility of the programmer to install a display callback for the window before the window is shown. A display callback must be registered for any window that is shown. If a window becomes displayed without a display callback being registered, a fatal error occurs. Passing to is illegal as of GLUT 3.0; there is no way to “deregister” a display callback (though another callback routine can always be registered). Upon return from the display callback, the normal damaged state of the window (returned by calling is cleared. If there is no overlay display callback registered, the overlay damaged state of the window (returned by calling is also cleared.\n\nAfter a GLUT program has done initial setup such as creating windows and menus, GLUT programs enter the GLUT event processing loop by calling . enters the GLUT event processing loop. Notice that this is the last API called in the basic program shown above.\n\nenters the GLUT event processing loop. This routine should be called at most once in a GLUT program. Once called, this routine will never return. It will call as necessary any callbacks that have been registered. GLUT supports two types of windows: top-level windows and subwindows. Both types support OpenGL rendering and GLUT callbacks. There is a single identifier space for both types of windows.\n\nHere is code written similar to that above. But when you compile it using the cl.exe VC++ compiler driver, that shape rotates and changes size:\n\nThe output is as the above description states. Now let’s examine this Graphics Library further by adding some functionality to the code:\n\nThis is the result:\n\nThe code above contained more functions and a floating point to indicate that we were dealing drawing a geometric shape. But before we get into those types of functions and some 3D applications, we will review the steps taken thus far.\n\nWhat You Should Know About Windows and GLUT\n\nis the first function that should be called, it parses the parameters that are window system specific for example the parameter that is used to let X11 begin exported to other screens. Be sure to call this with as first parameter, because the function wants a pointer not the plain . So you would call\n\nsets the initial display mode, you should pass an OR'ed chain of modes, there are various options like , , , , , , , , , , , . I will just mention that says you want to use the RGBA color model (default), says you want to use double buffering, this means that you create 2 virtual screens one that is visible and one in the background, on this in the background changes are being made and you swap the buffers using the function. uses single buffering, which is not really advised for an animation but this is default if you don't specify something else. If you use (color index mode) you should manually take care of the color map using the function, refer to the manpage for more information.\n\nsets the initial position of the window but this is easily overwritten by your window manager.\n\ncreates the window for you, the you pass will be the title of the window, the window is only displayed when is entered (see what you should know about actually starting the program and displaying the window for more information). This returns an integer, this integer is the window identifier, some functions need this identifier to know which window you mean, an example is the following: .\n\ndestroys a window, the parameter is the window identifier mentioned above. The program isn't killed when you destroy the window, only the window is destroyed. (See example below.)\n\nWhat You Should Know About Events and GLUT\n\nIn order to understand the following, I will first explain what a callback is. When a certain event occurs, you want a program to do something. So in case of event E call, method/function/procedure M. A callback just occurred. Within this part, you define which function has to be called when an event happens. (An event is something that happens: you move the mouse, press a key, resize the window,... mostly generated by the user). Now I will define the most commonly used GLUT callbacks.\n\nThis specifies the function that needs to be called when the window is redrawn. This function is called when the window if shown for the first time, when it is popped up, when the contents was damaged (by moving another window over it). It is also possible to force a redraw see below. An example might look like:\n\nTo make you display function you would put the following line in your source code:\n\nWhen you put somewhere in your code, this means that the function defined using will be called at the next opportunity. It marks the current window as needing a redraw.\n\nThe callback defined using is called whenever the window is being moved and/or resized. The arguments are the new width and the new height of the window.\n\nDefines a callback that is called periodically, you can register multiple callbacks but you can't unregister them, you should ignore these callbacks by setting the value so the method would ignore it. is the number of milliseconds in which the callback will be trigger at least.\n\nA callback for keyboard events, key is the ASCII value of the key pressed and x and y are the coordinates of the mouse at the moment of the keypress.\n\nA callback triggered on mouse clicks. Button can be , or . State defines what you actually did, did you press the button or release the button, these are defined by or . And and are the coordinates of the mouse.\n\nCallback triggered when the mouse is moved while one or more buttons are pressed. and are the coordinates.\n\nAs we will see in shortly, the program is started when you enter the main loop which waits for events, this can be compared to something like:\n\nBut not every time there occurs an event that needs to be handled that where the idling comes in. This is when the comes in. This function is useful when some continuous animation is needed.\n\nImportant note: You can undo most callbacks by passing NULL as the function name.\n\nWhat You Should Know About Creating 3D Objects in GLUT\n\nAnother advantage of glut is that glut has some pre defined primitives that you can put on the screen in an easy way. I will list the primitives below, most parameters speak for themselves. Each primitive comes in a solid or in a wireframe taste.\n\nRenders a sphere centered around the origin, slices are the number of subdivision around the Z axis, stacks the number of subdivisions along the Z axis. Note that the and parameters are part of OpenGL (see the gl prefix) and not part of glut.\n\nSize is the length of the sides.\n\nbase is the radius of the base.\n\nRenders a solid or wireframe 12-sided regular solid. Centered around the origin and with a radius equal to the square root of 3.\n\nRenders a solid or wireframe 4-sided regular solid. Centered around the origin and with a radius equal to the square root of 3.\n\nRenders a solid or wireframe 20-sided regular solid. Centered around the origin and with a radius equal to 1.0.\n\nRenders a solid or wireframe 8-sided regular solid. Centered around the origin and with a radius equal to 1.0.\n\nWhat You Should Know About Menus in GLUT\n\nThis function defines the callback that has to be called when a menu item was selected. This callback function has one parameter, the value. (The programmer has to define a value for each menu item he defines see for more information). This function returns an , this is the menu identifier. This identifier is needed when you would want to attach this menu as a submenu.\n\nYou can set the current menu by calling and passing the menu identifier as parameter, using you can query which menu is the current menu.\n\nThis adds an entry to the menu with the label defined by name and the second parameter is the value that will be passed to the callback function. The menu is being added to the current menu. Each menu entry that is being added is added at the bottom of the current menu.\n\nThis adds the menu identified by the menu identifier as a submenu with a given name to the current menu. The program won't work if it contains an infinite loop of menus.\n\nThis attaches the current menu to a certain (mouse) event, you can let a menu listen to a specified mouse button, button can be one of the following: , , and . You can also detach the menu using .\n\nAnd last but not least, this renders a teapot. Having reiterated these functions and how they are called to render graphics, consider this code. The source code below, opens a window, clears it with a black color and draws a teapot, it listens to keyboard presses and writes out the key that was pressed and the coordinates. The program terminates when the user presses \" \". This program only uses 2 OpenGL functions, the first one is that sets the (background) to black and that actually clears the window. In this example, no idlefunction is defined and I use single buffering (no double buffering) since no animation is needed:\n\nThis next example actually builds a robotic figure that can walk towards you when you right-click the surface image and choose one of the options that appears. The motion and transforms are largely trigonometric in nature. The products of the trigonometric components form the angles and the motion. Note that the shape of the robot is the summation of geometric shapes that are joined together: the sum of the parts forms the whole. Since the code is written in ANSI C, there are a lot of macro preprocessor directives. Study this code, as it can be expanded upon and serve as a cursor for actual game programming:\n\nCompile this code as an empty C++ Console Application where you add a new item (i.e., a code file) and paste this code in. I had no problem compiling it on the VC++ command line. Recall that you are in the bin directory, you must type vcvars32.bat to set the environment. Type ‘ ’ and your cursor will drop down one line and go to the far left with no prompt. Paste the code in this console space, and compile it with the cl.exe compiler:"
    },
    {
        "link": "https://stackoverflow.com/questions/10856832/building-a-static-library-for-glut-3-7-on-windows",
        "document": "I've been trying to compile glut as a static library without having to link with glut32.dll on runtime. I downloaded the glut windows source code but when I try to compile (default), I keep getting:\n\nFrom what I understand, glut32.lib should be compiled and created in {source}\\lib\\glut\\ but it's not there.\n\nAny help compiling a static library for glut would be appreciated.\n\nIt generated \\lib\\glut\\glut_8x13.lib not sure what the 8x13 is about but when I tried to link with it, I got some unresolved externals:"
    },
    {
        "link": "https://opengl.org/resources/libraries/glut/glut_downloads.php",
        "document": "2000/03/22 - GLUT 3 specification is now available in PDF format!\n\nGLUT (pronounced like the glut in gluttony) is the OpenGL Utility Toolkit, a window system independent toolkit for writing OpenGL programs. It implements a simple windowing application programming interface (API) for OpenGL. GLUT makes it considerably easier to learn about and explore OpenGL programming. GLUT provides a portable API so you can write a single OpenGL program that works on both Win32 PCs and X11 workstations.\n\nGLUT is designed for constructing small to medium sized OpenGL programs. While GLUT is well-suited to learning OpenGL and developing simple OpenGL applications, GLUT is not a full-featured toolkit so large applications requiring sophisticated user interfaces are better off using native window system toolkits like Motif. GLUT is simple, easy, and small. My intent is to keep GLUT that way.\n\nThe GLUT library supports the following functionality:\n• Utility routines to generate various solid and wire frame objects.\n\nThe GLUT library has both C, C++ (same as C), FORTRAN, and Ada programming bindings. The GLUT source code distribution is portable to nearly all OpenGL implementations for the X Window System and Windows 95 and NT. GLUT also works well with Brian Paul's Mesa, a freely available implementation of the OpenGL API.\n\nBecause GLUT is window system independent (as much as possible), GLUT can be implemented for window systems other than X. Implementations of GLUT for OS/2, NT & Windows 95, and the Mac have ben implemented, but only the Win32 and X11 versions are part of the official GLUT source code distrbution.\n\nThe current version of the GLUT API is 3. The current source code distribution is GLUT 3.7.\n\nGLUT is distributed in source code form; compiled libraries for Win32 are also available. The current version, 3.7, is in late beta. The programs and associated files contained in the distrbution were developed by Mark J. Kilgard (unless otherwise noted). The programs are not in the public domain, but they are freely distributable without licensing fees. These programs are provided without gurantee or warrantee expressed or implied.\n\nSince the data files for some of the new advanced GLUT examples are large, they are contained in a separate distribution.\n\nYou can still download the previous version of GLUT (GLUT 3.6), and the GLUT 3.6 data files.\n\nYou can also download GLUT from the University of North Carolina, Chapel Hill's SunSITE archive by either FTP or HTTP:\n\nWARNING: GLUT 3.7 and GLUT 3.6 are not on sunsite.unc.edu yet (just GLUT 3.5 currently).\n\nFor SGI users that want to save the hassle of compiling GLUT 3.6 by hand, you can download installable images for GLUT 3.6. Image images include:\n\nThe GLUT 3.6 images work with IRIX 5.3, IRIX 6.1, IRIX 6.2, IRIX 6.3, and IRIX 6.4. The installable images make it easy to install, upgrade, and remove GLUT. This is particularly true if you want N32 or 64-bit versions of GLUT. The N32 version refers to the new N32 object format that results in better performance from MIPS's current R4400, R8000, and R10000 processors. N32 is supported in IRIX 6.1 and later IRIX releases. The glut_dev.sw32.dev system is now marked for install by default since N32 is the default object format in IRIX 6.4.\n\nThe images are distributed as a file. You can either untar the file, or run on the tar file to automatically start SGI's Software Manager ( ). Otherwise, you can run or on the untar'ed files.\n\nDownload the GLUT 3.6 installable images by downloading this (shift Left in Netscape).\n\nIf your browser is configured to use tardist, try clicking the above link to start automatically. Note that not all the GLUT example source code in the source distribution is included with the GLUT images.\n\nRon Bielalski has built binaries of GLUT 3.7 beta for Solaris on SPARC processors in both 32 bit (16.5 MB) and 64 bit (18.3 MB) forms. John Martin has built binaries of GLUT 3.7 beta for Solaris on x86 in both 32 bit (15.2MB) and 64 bit (17.4MB) and forms. Note that these files are very large - they contain a completely built GLUT source tree, including all source and object files as well as the final headers and libraries. Please direct questions about GLUT for Solaris to graphics-help@eng.sun.com\n\nNate Robins and Paul Mayfield with help from Layne Christensen have implemented the original version of GLUT for Win32 (Windows 95,98,Me,NT,2000,XP). Here's a link to their GLUT for Windows web page. These pages include GLUT for Win32 dll, lib and header file (everything you need to get started programming with GLUT) and GLUT source code distribution (including a whole slew of great example programs + data).\n\nThe most signficant update to GLUT is the integration of the X Window System and Win32 versions of GLUT in a single source tree. GLUT works for either Win32 or X11 now. Nate Robins deserves the credit for this merging. To help Win32 users better utilize GLUT, PC-style files are available for download.\n\nYou will need a PC unzip utility that understands long file names to unzip these files correctly. Once you have the file unzipped, consult the file.\n\nIf you want just the GLUT header file, the , and files all pre-compiled for Intel platforms, you can simply download the file (149 kilobytes).\n\nYou can still download the previous version, GLUT 3.6:\n\n Download the zipped GLUT 3.6 source code distribution: \n\n Download the GLUT 3.6 image datafile distribution: \n\n Download the GLUT 3.6 headers and pre-compiled libraries:\n\nYou can also download pre-compiled GLUT 3.6 libraries for Windows NT Alpha platforms by downloading (82 kilobytes). GLUT for Alpha questions should be directed to Richard Readings ( ).\n\nThe OpenGL Utility Toolkit (GLUT) Programming Interface, API version 3 specifies all the routines in the GLUT API and how they operate. This document is available in HTML, PostScript, and PDF formats (the PDF version was generated and contributed by Richard Banks - thanks!). There have been no revisions since GLUT 3.2.\n\nThere is also a column on GLUT published in The X Journal available in PostScript. Unfortunately, The X Journal is no longer published, but back issues contain various other OpenGL columns using OpenGL with GLUT.\n\nGLUT is fully described in the book Programming OpenGL for the X Window System (Addison-Wesley, ISBN 0-201-48359-9). Consult this book for a full tutorial on GLUT.\n\nGLUT 3.0 involves an update to the GLUT API to version 3 so the GLUT library has new routines included in it implementing new functionality. There are also bug fixes, better support for IRIX 6.x's 64-bit and N32 object formats, and more sample programs.\n\nThe important new API additions are support for overlays, determining font character widths, new bitmap fonts, returning held down modifiers for mouse and keyboard events, and full screen windows.\n\nThere are a few minor bug fixes in the library. Various build problems on various built platforms have been resolved. GLUT 3.1 should build much cleanly on HP/UX, AIX, Linux, Solaris, and SunOS platforms now (cross finger). There are also a few more example programs. See the file for details.\n\nGLUT 3.2 fixed a few more minor bugs in the library. Mesa users will benefit from a hack to speed double-buffered damage regeneration. Man pages for the complete GLUT API are now included. The tests are expanded. New examples from Mesa distribution (converted to use GLUT) and advanced OpenGL programs from the Advanced OpenGL Rendering SIGGRAPH '96 class are now included. See the file for details.\n\nGLUT 3.3 is more portable; nearly all compiler warning are resolved. Lots of new GLUT-based OpenGL examples have been added or improved. Some new API has been added that will be codified with the GLUT 4 API revision. For example, an API for using InfiniteReality's dynamic video resize (DVR) capability is included. Also, a better way of getting window status is supported. There were some bug in the GLUT library itself that are now fixed. Some the warning or error messages weren't quite right. before a window is first displayed now ensures that the window need not be positioned by the user. See the file for details.\n\nAn Ada binding for SGI machines is included along with an Ada example. Many new sample programs. Several such as dinoshade.c demonstrate real-time rendering techniques relevant for games. Examples using Sam Leffler's libtiff library for loading, drawing, and writing TIFF image files. GLUT version of the facial animation \"geoview\" decibed in the Parke and Water's book Computer Facial Animation. New API interfaces to be made part of the GLUT 4 API update (not yet fully finalized though). for example. Improved portability and a few bug fixes.\n\nThe most significant change with GLUT 3.5 is unifying the X Window System and Win32 versions of GLUT into a single source code distribution. Henk Kok contributed several cool new demos ( , , ). All the demos build cleanly under Win32. Lots of bug fixes. Interesting new OpenGL rendering techniques are demonstrated in a number of new examples: , dinoshade, , , , , , , , . Also, Tom Davis contributed a user interface library called microUI (MUI) that is layered on top of GLUT.\n\nGLUT 3.6 has substantially improved the Win32 GLUT compliance and performance. Windows 95 & NT users should find GLUT 3.6 a substantial improvement over GLUT 3.5's Win32 support. Lots more demos and examples have been added. is a notable addition. Linas Vesptas's GLE Tubing and Extrusion library with documentation and example programs is now a part of GLUT. Many minor bugs were fixed.\n\nGLUT 3.7 adds a full-screen game mode for programs which wish to take over the entire display. The glsmap library for dynamic real-time sphere mapping is included, along with demos showing how to use glsmap for multiple reflections. A port of the Iris GL \"wave physics\" demo by Erik Larsen and a red-blue stereo demo program from Walter Vannini are included. Man pages are updated, and missing entry points added to the GLUT Ada bindings. Win32 performance improvements and bug fixes.\n\nI've collected a page of GLUT frequently asked questions that I expect about GLUT 3.6.\n\nIf you have benefited from using GLUT and have developed a cool GLUT program that you would like included with a future GLUT source code distribution, feel free to notify me by email about including it.\n\nPlease send email to to report bugs or problems with GLUT. Win32 GLUT programs can be sent to Nate Robins at ."
    }
]