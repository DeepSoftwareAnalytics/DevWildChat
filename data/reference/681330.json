[
    {
        "link": "https://helpch.at/docs/1.12.2/index.html?org/bukkit/scoreboard/Scoreboard.html",
        "document": ""
    },
    {
        "link": "https://bukkit.org/threads/tutorial-scoreboards-teams-with-the-bukkit-api.139655",
        "document": "\n• None //Adding prefixes (shows up in player list before the player's name, supports ChatColors)\n• None //Adding suffixes (shows up in player list after the player's name, supports ChatColors)\n• None //Making invisible players on the same team have a transparent body\n• None //Making it so players can't hurt others on the same team\n• None //Setting where to display the scoreboard/objective (either SIDEBAR, PLAYER_LIST or BELOW_NAME)\n• None //Setting the display name of the scoreboard/objective\n• None //If you are using custom player names (as shown above), then you have to do this:\n• None board. ChatColor. //Same as what I used above, case/color sensitive"
    },
    {
        "link": "https://jd.papermc.io/paper/1.12.2/index.html?org/bukkit/scoreboard/package-summary.html",
        "document": ""
    },
    {
        "link": "https://hub.spigotmc.org/javadocs/spigot/index.html?overview-summary.html",
        "document": "The documentation is for developing plugins and is split into the respective packages for each subject matter. This documentation does not cover running a server, contributing code back to the project, or setting up a workspace. Working knowledge of the Java language is a prerequisite for developing plugins.\n\nFor basic plugin development, see the . It covers the basic requirements of a plugin jar.\n\nFor handling events and triggered code, see the .\n\nNote: While the Bukkit API makes every effort to ensure stability, this is not guaranteed, especially across major versions. In particular the following is a (incomplete) list of things that are not API.\n• Implementing interfaces or extending classes. The Bukkit API is designed to only be implemented by server software. Unless a class/interface is obviously designed for extension (eg ), or explicitly marked as such, it should not be implemented or extended by plugins. Although this can sometimes work, it is not guaranteed to do so and resulting bugs will be disregarded.\n• Constructing inbuilt events. Although backwards compatibility is attempted where possible, it is sometimes not possible to add new fields to events without breaking existing constructors. To ensure that the API continues to evolve, event constructors are therefore not plugin API.\n• Implementation classes. Concrete implementation classes packaged with Bukkit (eg those beginning with Simple) are not API. You should access them via their interfaces instead.\n• The \"enumness\" of enums which implement . Such enums are liable to conversion to regular classes and therefore usages deriving from their status as an enum (including, but not limited to, use in switch statements and classes such as ) should be avoided."
    },
    {
        "link": "https://helpch.at/docs/1.12.2",
        "document": ""
    },
    {
        "link": "https://docs.papermc.io/paper/dev/plugin-yml",
        "document": "The file is the main configuration file for your plugin. It contains information about your plugin, such as its name, version, and description. It also contains information about the plugin's dependencies, permissions, and commands.\n\nThe file is located in the directory of your project.\n\nHere is an example of a file:\n\nThe name of your plugin. This is what will be displayed in the plugin list and log messages. This will be overridden in the logs if the prefix is set.\n\nThe current version of the plugin. This is shown in plugin info messages and server logs.\n\nThe main class of your plugin. This is the class that extends and is the entry point to your plugin.\n\nThis is the package path and class name of your main class.\n\nA short description of your plugin and what it does. This will be shown in the plugin info commands.\n\nThe author(s) of the plugin. This can be a single author or a list of authors.\n• These will be shown in the plugin info commands.\n\nThe contributors to the plugin that aren't the managing author(s).\n• These will be shown in the plugin info commands.\n\nThe website of the plugin. This is useful for linking to a GitHub repository or a plugin page.\n• This will be shown in the plugin info commands.\n\nThe version of the Paper API that your plugin is using. This doesn't include the minor version until 1.20.5. From 1.20.5 and onward, a minor version is supported. Servers with a version lower than the version specified here will refuse to load the plugin. The valid versions are 1.13 - .\n\nThis tells the server when to load the plugin. This can be or . Will default to if not specified.\n\nThe prefix of the plugin. This is what will be displayed in the log instead of the plugin name.\n\nThis is a list of libraries that your plugin depends on. These libraries will be downloaded from the Maven Central repository and added to the classpath. This removes the need to shade and relocate the libraries.\n\nThis is a list of permissions that your plugin uses. This is useful for plugins that use permissions to restrict access to certain features.\n\nThe description is the description of the permission node. This is what will be displayed in the permissions list. The default is the default value of the permission node. This can be / or / . This defaults to the value of if not specified, which in turn defaults to . Each permission node can have children. When set to , it will inherit the parent permission.\n\nThe default value that permissions that don't have a specified will have. This can be / or / .\n\nThis is a list of commands that your plugin uses. This is useful for plugins that use commands to provide features.\n• is the description of the command. This gives a brief description of what the command does.\n• is the usage of the command. This is what will be displayed when the player uses .\n• are a list of aliases that the command can be used with. This is useful for shortening the command.\n• is the permission node that the player needs to use the command. Note: Players will only see commands they have permission to use.\n• is the message that will be displayed when the player does not have permission to use the command.\n\nA list of plugins that your plugin depends on to load. They are specified by their plugin name.\n\nA list of plugins that your plugin depends on to have full functionality. They are specified by their plugin name.\n\nA list of plugins that your plugin should be loaded before. They are specified by their plugin name. This is useful if you want to load your plugin before another plugin for the other plugin to use your plugin's API.\n\nThis can be used to tell the server that this plugin will provide the functionality of some library or other plugin (like an alias system). Plugins that (soft)depend on the other plugin will treat your plugin as if the other plugin exists when resolving dependencies or using ."
    },
    {
        "link": "https://bukkit.org/threads/tut-bukkits-new-fileconfiguration-api-create-a-yaml-configuration.42775",
        "document": "I'm not sure but you could maybe assign config.getString to a local variable, then assign the local variable to np.\n\n//Tell plugin we are going to usa a config file\n\n\n\n //Get the name of the plugin from plugin.yml\n\n //Get the version number of the plugin from plugin.yml\n\n //Print to console that plugin is enabled\n\n //Get the name of the plugin from plugin.yml\n\n //Get the version number of the plugin from plugin.yml\n\n //Print to console that plugin is disabled\n\n \"You did the hello command\" //to get a string from the config file\n\n //if there is no config file, set defaults as well!\n\n //if the sender of the command is a player on the server->\n\n //then the player is a player\n\n //if the command the player on the server sent was \"/hello\"\n\n //Check if the player has permission to use the command or if the player is OP\n\n //Get the value of msg.hello.command and put it in the String named sendThis\n\n //Send the string sendThis to the player in chat\n\n //If player does not have permission for the command\n\n \"§cYou are not allowed to use this command.\" //Give him info that he can't use it\n\n \"This command is made to be executed in game only.\" //Display message if command is ran in console or similar"
    },
    {
        "link": "https://bukkit.fandom.com/wiki/Configuration_API_Reference",
        "document": "The Configuration API is a set of tools to help developers quickly parse and emit configuration files that are human readable and editable. Despite the name, the API can easily be used to store plugin data in addition to plugin configuration. Presently only YAML configurations can be used. The API however was designed to be extensible and allow for other implementations.\n\nThe Configuration API can be found in the org.bukkit.configuration and org.bukkit.configuration.file packages. Plugins that were created before version 1.1-R5 may have used an older and different implementation that resided in org.bukkit.util.configuration. These implementations are not compatible and the old package has since been removed.\n\nThis introduction assumes that you have some knowledge about proper object oriented design, Java, and the core design of Bukkit plugins. This page is not a substitute for the JavaDocs for the FileConfiguration Class\n\nYour plugin extends JavaPlugin, and in doing so, you inherited methods and fields from JavaPlugin. The inherited method, getConfig() returns an object of type FileConfiguration. This is the object that represents config.yml inside your plugin's data folder.\n\nThe first time getConfig() is invoked on your plugin, config.yml is loaded from disk, and default values are loaded from the jar. Subsequent invocations of getConfig() will return the existing FileConfiguration object that is in memory. Operations performed on this object will not be written to disk unless explicitly saved. Likewise, any modifications done after the file has been loaded will not be reflected in the object. If config.yml does not exist in your data folder, it is equivalent to an empty config.yml, and will load an empty FileConfiguration.\n\nWarning: if you assign the returned object from getConfig() DO NOT assign it to a static field\n\n Warning: if you do the above, assign getConfig() to the variable AGAIN after a reloadConfig\n\nA configuration file is organized into key value pairs where all keys are Strings. The value for the other keys may be a ConfigurationSection or a single piece of data. The getKeys(boolean) method returns the set of keys for the current FileConfigurationSection. The boolean value determines if the returned set is recursive, if true it will return the keys of the given section and their children keys, if false will only return keys of the given section. To get the keys of a particular section, the getKeys(boolean) method must be invoked on that particular section. To get the section you will have to invoke getConfigurationSection(String).\n\nThe Configuration API uses Paths to form a unique key to value pairs. A path is the set of keys used to associate a value. Each level is separated by the path separator, which is by default the '.' (period). For example the following YAML file has the following set of paths.\n\nA default config.yml should be provided in your jar for users. In the case that a config.yml is missing or incomplete, values will be loaded from included config.yml. The provided file must be named config.yml and be placed in the same directory as your plugin.yml. The file should have the intended structure of your config.yml. This file can be copied as is into the datafolder by invoking saveDefaultConfig() on the Appropriate instance of JavaPlugin.\n\nIf dynamic key-value pairs are required as default values, they can added as defaults to the configuration with invocations of addDefault(String, Object) and addDefaults(Map<String,Object>) methods.\n\nIn certain cases if you wish to append new key-value pairs to an existing config.yml you can set the copyDefaults to true for the ConfigurationOptions object.\n\nYou can create a copy of config.yml from the jar into the plugin's data folder by invoking JavaPlugin's saveDefaultConfig() method. saveDefaultConfig() will not overwrite an existing file.\n\nReading values from the configuration involves invoking one of the many getter methods. A complete list of getters can be found here. Every getter method takes a configuration path detailed above. Some of the commonly used getter methods are as follows\n\nIn the case of HashMaps as a value, they are treated differently than other forms of data. There is a restriction for Map types. It must use a String as a key, and the value but be either a boxed primitive, String, List, Map, or a ConfigurationSerializable type. They will lose their type.\n\nTo get a HashMap, a ConfigurationSection must must first be retrieved. You can return the configuration with getConfigurationSection method. The getValues method will return the values in the ConfigurationSection as a map, it takes a boolean which controls if the nested maps will be returned in the map. You can obtain the original map by invoking getValues(false) on the returned ConfigurationSection. Due to the way Java handles generic classes, type information will be lost, thus a cast will need to be performed to set the original type information. The API makes no guarantees that the cast you perform will be safe.\n\nWriting values involves invoking the set(String, Object) method on an instance of Configuration. Unlike the different get methods that FileConfiguration has, there is only one set method. Not all objects can be set, only primitive types, String, Lists, and types that implement ConfigurationSerializable, such as Vector and ItemStack, can be set. To erase a value supply null as a parameter. All changes made by set will only affect the copy of the configuration in memory, and will not persist beyond restarting the server until the configuration is saved. Following are some example uses:\n\nWhen HashMaps are used as a value, they are treated slightly differently. The Map must parameterized with a String type for the key, and the value must be parameterized as a boxed primitive, String, List, Map, or a ConfigurationSerializable.\n\nWhile you can use the set method to directly set a HashMap to a key, you cannot directly retrieve the Map back with the get method after reading directly from disk. The context above is to minimize unpredictability.\n\nTo set a HashMap, a ConfigurationSection must be created for that HashMap. You can only set HashMap where the key is a string the the value is something that is ConfigurationSerializable. The createSectionMethod\n\nIf any changes are made to the FileConfiguration with the set methods, or any Lists are mutated, you will need to save the changes to disk if you wish to keep these changes after the plugin is disabled. To save the file to disk, invoke the saveConfig method for your plugin, it will overwrite the file already there.\n\nIf you suspect that users have made changes to the config.yml in the data folder, those changes are not reflected in memory. Invoke the reloadConfig() method of your plugin to load from the disk again. It will destroy all changes in memory.\n\nIf for whatever reason you need another configuration file, you can use YamlConfiguration to make a new one.\n\nThis reads the file data.yml from your data folder, and returns a FileConfiguration. If the file does not exist, the FileConfiguration is empty. If you need a pre-made FileConfiguration to be used, you can instead use an InputStream.\n\nThis takes the InputStream from getResource, which gets a file embedded in the jar, and retreives a FileConfiguration from that.\n\nThe following are some more advanced topics, meant for more advanced plugins. If you only require the default config.yml, creating custom methods for reading, and saving, you will not need to go this far.\n\nEvery FileConfiguration instance is associated with a FileConfigurationOptions object. The FileConfigurationOptions object controls the behavior of the FileConfiguration it is associated with. FileConfiguration's options() method returns the FileConfigurationOption's responsible for it. With it you can check and set each option. There are currently four options. Be aware that the methods are overloaded, for example copyDefaults() which returns a boolean and copyDefaults(boolean) which returns it self, but has a side effect which changes the state.\n\nThe copyDefaults option changes the behavior of Configuration's save method. By default, the defaults of the configuration will not be written to the target save file. If set to true, it will write out the default values, to the target file. However, once written, you will not be able to tell the difference between a default and a value from the configuration.\n\nPathSeperator changes the character that is used to separate the different levels of the configuration. By default it is the \".\" (period) but it can be changed to any char.\n\nHeader is the comment block at the top of a YAML file, it is applied to the save output. The header is the only comment that Configuration API knows how to copy.\n\nIf copyHeader() returns true then the header will be copied on save, from the default source.\n\nIf you require additional YAML files, for storing configuration information or persisting additional game information you will need to write your own methods for accessing the additional configuration files. Modeled after JavaPlugin getConfig, reloadConfig, saveConfig methods, the following is an example how to write your own methods to read and save to custom configuration files. Since these config files belong to your plugin, you can put this method in your main class so that you can have the same access as you have with config.yml. You will have to write a set of these methods for each YAML file. The advantage here, is that you can use each set in the same manner as the provided methods for the default config.yml. Alternately, adding additional methods can keep the method count lower and allow access to multiple files.\n\nJavaPlugin implements methods for config.yml. A plugin needs to implement its own methods to access configuration files unique to the plugin. After implementing the methods for the plugin, they can be invoked in the same context as the inherited getConfig(), reloadConfig(), saveConfig(), and saveDefaultConfig() methods from JavaPlugin. The following can be made into a single class which allows access to any yaml file. Such a class can be found here\n\nFirst you will need to declare two fields and initialize them to null for each of the custom configuration files. One to hold the FileConfiguration object and one to hold the File object. The File object represents the file on the disk, and the FileConfiguration represents the contents of the configuration.\n\nThen, write the method that is responsible for loading the config from disk. It will load the file, and search the jar for a default customConfig.yml.\n\nNext, you need to write the getter method. Check if customConfig is null, if it is load from disk.\n\nFinally, write the save method, which saves changes and overwrites the file on disk.\n\nOptionally, you may want to write a method that mimics JavaPlugin's saveDefaultConfig() method.\n\nThe Configuration API, as mentioned above can store Java objects that implement the ConfigurationSerializable Interface. Object serialization facilitates easy saving and loading so plugin authors can focus on other parts of their plugin. It greatly simplifies tasks such as storing a Location in YAML, a developer can serialize a wrapper class, which provide methods to retrieve a Location.\n\n\n\nClasses, in addition to implementing the ConfigurationSerializable interface must also implment one of the following as noted in the Javadoc, so that they can be serialized by the API:\n• A static method \"deserialize\" that accepts a single Map and returns the class.\n• A static method \"valueOf\" that accepts a single Map and returns the class.\n\nIn order for a serialized object to be deserialized, it must also be registered with ConfigurationSerialization. The static registerClass method must be invoked once per class that has been serialized.\n\nThis statement must be placed in your onEnable method or some other location that gets called every time your plugin is initialized:\n\nWarning: Do not use a static block to execute the above; if you do so, it will not be called a second time when is used and you will encounter errors due to it not being registered!\n\nWhen classes are serialized they are marked with their fully qualified name.\n\nYou can provide an alias to your class so that it does not serialize with the fully qualified name of your class, but the alias instead. You provide the alias with the SerializableAs annotation to the class implementing ConfigurationSerializable.\n\nWhen registering a class with an alias, the alias must be provided on registration.\n\nBelow is the an example plugin that uses the new Configuration API to be display messages as an MOTD as players join, and for the player to retrieve the rules on command. It does not follow proper style and plugin layout to keep the number of lines to a minimum.\n\nThe default config.yml that is in the plugin's jar"
    },
    {
        "link": "https://spigotmc.org/threads/help-with-config-yml-comments.96844",
        "document": ""
    },
    {
        "link": "https://bukkit.org/threads/creating-and-managing-custom-yaml-files.473063",
        "document": "there were not any tutorials explaining how can I really make one, write to it, load it or save it"
    },
    {
        "link": "https://bukkit.fandom.com/wiki/Scheduler_Programming",
        "document": "This tutorial will guide you in using the scheduler provided by bukkit. It will allow you to defer the execution of code to a later time. This is not the same as registering a Listener, a block of code which is executed in response to an event in the game. Blocks of code may also be scheduled to be executed repeatedly at a fixed interval, with or without a delay. They will continue to execute until completed, or canceled, or your plugin is disabled.\n\nWhen using BukkitRunnable, with a separate class, scheduling work occurs in two steps for the programmer.\n• Define the work to be done, see the section Defining Work\n• Notify Bukkit when the work should be executed, see the section Scheduling Work\n\nAlternatively, work can be scheduled directly with the scheduler, this also occurs in two steps for the programmer.\n• Define the work to be done, in a Runnable or Callable\n• Then directly scheduling the work with the Bukkit Scheduler, see the section BukkitScheduler\n\nBukkitRunnable is an abstract implementation of Runnable. It also supports additional operations that a Runnable is not capable of, most conveniently, BukkitRunnables can schedule and cancel their own execution. However, if the BukkitRunnable did not schedule itself for execution, it cannot cancel itself from execution. BukkitRunnables are not schedulers, do not contain any scheduler logic, and are not expensive to create. Plugins should prefer defining a BukkitRunnable and calling the appropriate run method over directly scheduling a Runnable with the BukkitScheduler.\n\nPlugins should first extend BukkitRunnable to define work that needs to be done. In other words, the definition of the run method is what you want executed in accordance to a schedule.\n\nThis is an example definition of a task that can be scheduled.\n\nThis is an example of a definition of a task that will cancel itself when it has executed the specified number of times\n\nAfter defining the task, the plugin needs to schedule the task. BukkitRunnables are scheduled when the desired run method is invoked on an instance of the task. The list of methods for BukkitRunnable can be found in the Javadocs for BukkitRunnable. The different run methods all return a BukkitTask object\n\nThis is an example of a plugin which registers a listener and when a player joins, schedules a task to be run 20 ticks later.\n\nThis is example takes the above ExampleSelfCancelingTask and schedules it to run every 20 ticks after waiting 10 ticks.\n\nAn anonymous BukkitRunnable will allow you to schedule a task, without creating a new class with a name. This examples combines the above two basic examples.\n\nThis is an example of a plugin which registers a listener and when a player joins, schedules the above ExampleTask to run on an async thread.\n\nThe BukkitScheduler allows plugins to schedule a Runnable and/or a Callable , for execution at a later time. The list of methods for BukkitScheduler can be found in the Javadocs for BukkitScheduler.\n\nExample for directly scheduling an anonymous Runnable with the BukkitScheduler to run after 20 ticks.\n\nExample for directly scheduling an anonymous Runnable with the BukkitScheduler to run every twenty ticks, forever, starting from when you schedule it.\n\nExample for directly scheduling an anonymous Runnable with the BukkitScheduler using a lambda function as an async task.\n\nA BukkitTask object is returned whenever a Runnable is scheduled. This object represents the task the scheduled task being executed by the scheduler. For more information see, Javadocs for BukkitTask.\n\nA Callable given to the scheduler to call synchronously returns a Future. These are standard Java classes, for more information see, Javadocs for Callable and Javadocs for Future\n\nThe Bukkit API, with the exception of the scheduler package, is not thread safe nor guaranteed to be thread safe.\n• Asynchronous tasks should never access any API in Bukkit.\n• Do not access or modify shared collections from your asynchronous tasks. Normal collections are not thread-safe. This also applies to objects which are not thread safe.\n• If you want to schedule something at a fixed time, by calculating how many ticks until that point in time, you should use an asynchronous task. If you don't, lag will increase the delay."
    },
    {
        "link": "https://spigotmc.org/threads/bukkitrunnable-or-scheduler.261981",
        "document": ""
    },
    {
        "link": "https://bukkit.org/threads/creating-and-stopping-scheduled-bukkitrunnable-task.353575",
        "document": ""
    },
    {
        "link": "https://spigotmc.org/threads/bukkitrunnable-inside-a-method.331121",
        "document": ""
    },
    {
        "link": "https://bukkit.fandom.com/wiki/Scheduler_Programming/pt",
        "document": "This tutorial will guide you in using the scheduler provided by bukkit. It will allow you to defer the execution of code to a later time. This is not the same as registering a Listener, a block of code which is executed in response to an event in the game. Blocks of code may also be scheduled to be executed repeatedly at a fixed interval, with or without a delay. They will continue to execute until completed, or canceled, or your plugin is disabled.\n\nWhen using BukkitRunnable, with a separate class, scheduling work occurs in two steps for the programmer.\n• Define the work to be done, see the section Defining Work\n• Notify Bukkit when the work should be executed, see the section Scheduling Work\n\nAlternatively, work can be scheduled directly with the scheduler, this also occurs in two steps for the programmer.\n• Define the work to be done, in a Runnable or Callable\n• Then directly scheduling the work with the Bukkit Scheduler, see the section BukkitScheduler\n\nBukkitRunnable is an abstract implementation of Runnable. It also supports additional operations that a Runnable is not capable of, most conveniently, BukkitRunnables can schedule and cancel their own execution. However, if the BukkitRunnable did not schedule itself for execution, it cannot cancel itself from execution. BukkitRunnables are not schedulers, do not contain any scheduler logic, and are not expensive to create. Plugins should prefer defining a BukkitRunnable and calling the appropriate run method over directly scheduling a Runnable with the BukkitScheduler.\n\nPlugins should first extend BukkitRunnable to define work that needs to be done. In other words, the definition of the run method is what you want executed in accordance to a schedule.\n\nThis is an example definition of a task that can be scheduled.\n\nThis is an example of a definition of a task that will cancel itself when it has executed the specified number of times\n\nAfter defining the task, the plugin needs to schedule the task. BukkitRunnables are scheduled when the desired run method is invoked on an instance of the task. The list of methods for BukkitRunnable can be found in the Javadocs for BukkitRunnable. The different run methods all return a BukkitTask object\n\nThis is an example of a plugin which registers a listener and when a player joins, schedules a task to be run 20 ticks later.\n\nThis is example takes the above ExampleSelfCancelingTask and schedules it to run every 20 ticks after waiting 10 ticks.\n\nAn anonymous BukkitRunnable will allow you to schedule a task, without creating a new class with a name. This examples combines the above two basic examples.\n\nThe BukkitScheduler allows plugins to schedule a Runnable and/or a Callable , for execution at a later time. The list of methods for BukkitScheduler can be found in the Javadocs for BukkitScheduler.\n\nExample for directly scheduling an anonymous Runnable with the BukkitScheduler to run after 20 ticks.\n\nExample for directly scheduling an anonymous Runnable with the BukkitScheduler to run every twenty ticks, forever, starting from when you schedule it.\n\nA BukkitTask object is returned whenever a Runnable is scheduled. This object represents the task the scheduled task being executed by the scheduler. For more information see, Javadocs for BukkitTask.\n\nA Callable given to the scheduler to call synchronously returns a Future. These are standard Java classes, for more information see, Javadocs for Callable and Javadocs for Future\n\nThe Bukkit API, with the exception of the scheduler package, is not thread safe nor guaranteed to be thread safe.\n• Asynchronous tasks should never access any API in Bukkit.\n• Do not access or modify shared collections from your asynchronous tasks. Normal collections are not thread-safe. This also applies to objects which are not thread safe.\n• If you want to schedule something at a fixed time, by calculating how many ticks until that point in time, you should use an asynchronous task. If you don't, lag will increase the delay."
    }
]