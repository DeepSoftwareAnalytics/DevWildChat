[
    {
        "link": "https://geeksforgeeks.org/tcp-server-client-implementation-in-c",
        "document": "Prerequisites – Socket Programming in C/C++, TCP and UDP server using select, UDP Server-Client implementation in C\n\nIf we are creating a connection between client and server using TCP then it has a few functionalities like, TCP is suited for applications that require high reliability, and transmission time is relatively less critical. It is used by other protocols like HTTP, HTTPs, FTP, SMTP, Telnet. TCP rearranges data packets in the order specified. There is absolute guarantee that the data transferred remains intact and arrives in the same order in which it was sent. TCP does Flow Control and requires three packets to set up a socket connection before any user data can be sent. TCP handles reliability and congestion control. It also does error checking and error recovery. Erroneous packets are retransmitted from the source to the destination.\n\nThe entire process can be broken down into the following steps:\n\n\n\n\n\nThe entire process can be broken down into following steps:\n• None using bind(), Bind the socket to server address.\n• None using listen(), put the server socket in a passive mode, where it waits for the client to approach the server to make a connection\n• None using accept(), At this point, connection is established between client and server, and they are ready to transfer data.\n\n// Function designed for chat between client and server. // read the message from client and copy it in buffer // print buffer which contains the client contents // and send that buffer to client // if msg contains \"Exit\" then server exit and chat ended. // Binding newly created socket to given IP and verification // Now server is ready to listen and verification // Accept the data packet from client and verification // Function for chatting between client and server"
    },
    {
        "link": "https://geeksforgeeks.org/socket-programming-cc",
        "document": "Socket programming is a way of connecting two nodes on a network to communicate with each other. One socket(node) listens on a particular port at an IP, while the other socket reaches out to the other to form a connection. The server forms the listener socket while the client reaches out to the server.\n\nSocket programming in C is a powerful way to handle network communication.\n\nThe server is created using the following steps:\n• domain: integer, specifies communication domain. We use AF_ LOCAL as defined in the POSIX standard for communication between processes on the same host. For communicating between processes on different hosts connected by IPV4, we use AF_INET and AF_I NET 6 for processes connected by IPV6.\n• protocol: Protocol value for Internet Protocol(IP), which is 0. This is the same number that appears on the protocol field in the IP header of a packet.(man protocols for more details)\n\nThis helps in manipulating options for the socket referred by the file descriptor sockfd. This is completely optional, but it helps in reuse of address and port. Prevents error such as: “address already in use”.\n\nAfter the creation of the socket, the bind function binds the socket to the address and port number specified in addr(custom data structure). In the example code, we bind the server to the localhost, hence we use INADDR_ANY to specify the IP address.\n\nIt puts the server socket in a passive mode, where it waits for the client to approach the server to make a connection. The backlog, defines the maximum length to which the queue of pending connections for sockfd may grow. If a connection request arrives when the queue is full, the client may receive an error with an indication of ECONNREFUSED.\n\nIt extracts the first connection request on the queue of pending connections for the listening socket, sockfd, creates a new connected socket, and returns a new file descriptor referring to that socket. At this point, the connection is established between client and server, and they are ready to transfer data.\n\n1. Socket connection: Exactly the same as that of server’s socket creation\n\n2. Connect: The connect() system call connects the socket referred to by the file descriptor sockfd to the address specified by addr. Server’s address and port is specified in addr.\n\nHere we are exchanging one hello message between server and client to demonstrate the client/server model.\n• Connection Failures: Ensure that the client is trying to connect to the correct server address and port.\n• Port Binding Errors: If a port is already in use by another application, binding to that port will fail. Try using a different port or close the previous application using the port.\n• Blocking Sockets: By default, sockets are blocking. This means that calls like accept() or recv() will wait indefinitely if there is no client connection or data. You can set the socket to non-blocking mode if needed.\n\nNext: Socket Programming in C/C++: Handling multiple clients on server without multi threading"
    },
    {
        "link": "https://idiotdeveloper.com/tcp-client-server-implementation-in-c",
        "document": "In this tutorial, you will learn to implement a TCP client-server program in the C programming language. Here, the client and server would exchange messages and communicate with each other in an interactive way. In addition, you will also learn about the client-server architecture and other related concepts.\n\nA socket is a structure that allows communication between different processes on the same computer or different computers. A socket allows us to communicate by sending and receiving data over the network. In simple terms, it is a way for a computer to talk to other computers on the network.\n\nTCP refers to the Transmission Control Protocol. It is one of the main protocol used for communication over the internet. Some of the features of this protocol are:\n• It used three-way handshake to establish reliable connections.\n• TCP gurantees the delivery of the data packets.\n\nA client-server architecture is a model in computer networking, where the server provides some service to the client. In this architecture, the client computer sends a request to the server computer through a network (internet). The server accepts this request and sends the required data to the client.\n\nIn simple terms, we can say\n• Server is a remote computer which provides some services.\n• Client is the one that request the server for these services.\n\nHere, we will start the implementation of the client-server implementation in C. First, we start by implementing the server-side and then we begin with the client-side code.\n\nThe server-side process can be broken down into the following steps:\n• bind() – bind the TCP socket to the server address (ip and port).\n• accept() – connection is established between the client and server.\n• recv() and send () – communicate with each other.\n• close() – close the connection from the client.\n\nDefine the IP (Internet Protocol) address and port number, that would be used to create a socket. Here, we are using the localhost address for both the server and the client.\n\nHere, we define the required variables used later in this program.\n\nCreate a TCP (Transmission Control Protocol) socket that returns a socket descriptor. This socket descriptor would be used to communicate with the client.\n\nHere, we initialize the server address by providing the required IP and port number. The server keeps all the address information for both the server and the client in the sockaddr_in struct.\n\nBinding the socket descriptor with the server address information.\n\nNow, we listen for incoming connections from the clients.\n\nThe server handles only one client at a time. So, only one client would communicate and the rest would have to wait for the communication to get completed.\n\nTo communicate with all the clients, we start a while loop and the following things happen:\n• We receive a message from the client and print it on the console.\n• Next, the server send a reply message to the client.\n\nThe following sequences go on with other clients.\n\nThe client-side process can be broken down into the following steps:\n• recv() and send () – communicate with each other.\n\nWe begin by including all the required header files, defining the IP (Internet Protocol) address and the port number. We also define the required variable used later in this program.\n\nNOTE: Make sure that the IP address and the port number for the client are the same as the server.\n\nWe start by creating a TCP (Transmission Control Protocol) socket. The socket would be used to connect to the server and start communication.\n\nWe provide the required IP address and the port number to the required data structures.\n\nWe send a connection request to the server and wait for the server to accept the request.\n\nWe send a message to the server and wait for the reply.\n\nWe receive the reply from the server and print it on the console.\n\nAt last, we close the connection from the server.\n• How to implement TCP sockets in C\n\nIn this tutorial, you have learned to implement the TCP client-server architecture in the C programming language.\n\nStill, have some questions or queries? Just comment below. For more updates. Follow me."
    },
    {
        "link": "https://linuxhowtos.org/C_C++/socket.htm",
        "document": "from small one page howto to huge articles all in one place \n\n\n\n \n\n Poll\n\n What does your sytem tell when running \"ulimit -u\"?\n\n \n\n \n\n \n\n \n\n \n\n \n\n more, but not unlimited \n\n \n\n poll results\n\n\n\nLast additions:\n\n May 25th. 2007:\n\n April, 26th. 2006:\n\n You are here: Programming->C/C++\n\n\n\n This is a simple tutorial on using sockets for interprocess communication. This is a simple tutorial on using sockets for interprocess communication. Most interprocess communication uses the client server model. These terms refer to the two processes which will be communicating with each other. One of the two processes, the client, connects to the other process, the server, typically to make a request for information. A good analogy is a person who makes a phone call to another person. Most interprocess communication uses the. These terms refer to the two processes which will be communicating with each other. One of the two processes, the, connects to the other process, the, typically to make a request for information. A good analogy is a person who makes a phone call to another person. Notice that the client needs to know of the existence of and the address of the server, but the server does not need to know the address of (or even the existence of) the client prior to the connection being established. Notice also that once a connection is established, both sides can send and receive information. The system calls for establishing a connection are somewhat different for the client and the server, but both involve the basic construct of a socket.\n\nA socket is one end of an interprocess communication channel. The two processes \n\neach establish their own socket. The steps involved in establishing a socket on the client side are as follows:\n• Connect the socket to the address of the server using the connect() system call\n• Send and receive data. There are a number of ways to do this, but the simplest is to use the read() and write() system calls. The steps involved in establishing a socket on the server side are as follows:\n• Bind the socket to an address using the bind() system call. For a server socket on the Internet, an address consists of a port number on the host machine.\n• Listen for connections with the listen() system call\n• Accept a connection with the accept() system call. This call typically blocks until a client connects with the server.\n\n When a socket is created, the program has to specify the address domain and the socket type. Two processes can communicate with each other only if their sockets are of the same type and in the same domain. There are two widely used address domains, the unix domain, in which two processes which share a common file system communicate, and the Internet domain, in which two processes running on any two hosts on the Internet communicate. Each of these has its own address format. The address of a socket in the Unix domain is a character string which is basically an entry in the file system. The address of a socket in the Internet domain consists of the Internet address of the host machine (every computer on the Internet has a unique 32 bit address, often referred to as its IP address).\n\nIn addition, each socket needs a port number on that host.\n\nPort numbers are 16 bit unsigned integers. \n\nThe lower numbers are reserved in Unix for standard services. For example, the port number for the FTP server is 21. It is important that standard services be at the same port on all computers so that clients will know their addresses. \n\nHowever, port numbers above 2000 are generally available. There are two widely used socket types, stream sockets, and datagram sockets. Stream sockets treat communications as a continuous stream of characters, while datagram sockets have to read entire messages at once. Each uses its own communciations protocol. Stream sockets use TCP (Transmission Control Protocol), which is a reliable, stream oriented protocol, and datagram sockets use UDP (Unix Datagram Protocol), which is unreliable and message oriented. The examples in this tutorial will use sockets in the Internet domain using the TCP protocol. C code for a very simple client and server are provided for you. These communicate using stream sockets in the Internet domain. The code is described in detail below. However, before you read the descriptions and look at the code, you should compile and run the two programs to see what they do. Download these into files called and and compile them separately into two executables called and . They probably won't require any special compiling flags, but on some solaris systems you may need to link to the socket library by appending to your compile command. Ideally, you should run the client and the server on separate hosts on the Internet. Start the server first. Suppose the server is running on a machine called . When you run the server, you need to pass the port number in as an argument. You can choose any number between 2000 and 65535. If this port is already in use on that machine, the server will tell you this and exit. If this happens, just choose another port and try again. If the port is available, the server will block until it receives a connection from the client. Don't be alarmed if the server doesn't do anything; It's not supposed to do anything until a connection is made.\n\n To run the client you need to pass in two arguments, the name of the host on which the server is running and the port number on which the server is listening for connections. Here is the command line to connect to the server described above: \n\nThe client will prompt you to enter a message. \n\nIf everything works correctly, the server will display your message on stdout, send an acknowledgement message to the client and terminate. \n\nThe client will print the acknowledgement message from the server and then terminate. The client will prompt you to enter a message.If everything works correctly, the server will display your message on stdout, send an acknowledgement message to the client and terminate.The client will print the acknowledgement message from the server and then terminate. You can simulate this on a single machine by running the server in one window and the client in another. In this case, you can use the keyword as the first argument to the client. The server code uses a number of ugly programming constructs, and so we will go through it line by line. \n\nThis header file contains declarations used in most input and output and is typically included in all C programs. \n\nThis header file contains definitions of a number of data types used in system calls. These types are used in the next two include files. \n\nThe header file socket.h includes a number of definitions of structures needed for sockets. \n\nThe header file in.h contains constants and structures needed for internet domain addresses.\n\n \n\nThis function is called when a system call fails. It displays a message about the error on and then aborts the program. The This function is called when a system call fails. It displays a message about the error onand then aborts the program. The perror man page gives more information. \n\n and are file descriptors, i.e. array subscripts into the andare file descriptors, i.e. array subscripts into the file descriptor table . These two variables store the values returned by the socket system call and the accept system call. stores the port number on which the server accepts connections. stores the size of the address of the client. This is needed for the accept system call. is the return value for the and calls; i.e. it contains the number of characters read or written. \n\nThe server reads characters from the socket connection into this buffer. The server reads characters from the socket connection into this buffer. \n\nA is a structure containing an internet address. This structure is defined in .\n\n is a structure containing an internet address. This structure is defined in struct sockaddr_in\n\n{\n\n short sin_family; /* must be AF_INET */\n\n u_short sin_port;\n\n struct in_addr sin_addr;\n\n char sin_zero[8]; /* Not used, must be zero */\n\n}; \n\nAn structure, defined in the same header file, contains only one field, a unsigned long called . Anstructure, defined in the same header file, contains only one field, a unsigned long called The variable will contain the address of the server, and will contain the address of the client which connects to the server. \n\nThe user needs to pass in the port number on which the server will accept connections as an argument. This code displays an error message if the user fails to do this. The user needs to pass in the port number on which the server will accept connections as an argument. This code displays an error message if the user fails to do this. \n\nThe system call creates a new socket. It takes three arguments. The first is the address domain of the socket. Thesystem call creates a new socket. It takes three arguments. The first is the address domain of the socket. Recall that there are two possible address domains, the unix domain for two processes which share a common file system, and the Internet domain for any two hosts on the Internet. The symbol constant is used for the former, and for the latter (there are actually many other options which can be used here for specialized purposes). The second argument is the type of socket. Recall that there are two choices here, a stream socket in which characters are read in a continuous stream as if from a file or pipe, and a datagram socket, in which messages are read in chunks. The two symbolic constants are and . The third argument is the protocol. If this argument is zero (and it always should be except for unusual circumstances), the operating system will choose the most appropriate protocol. It will choose TCP for stream sockets and UDP for datagram sockets. The socket system call returns an entry into the file descriptor table (i.e. a small integer). This value is used for all subsequent references to this socket. If the socket call fails, it returns -1.\n\n \n\nIn this case the program displays and error message and exits. However, this system call is unlikely to fail. This is a simplified description of the socket call; there are numerous other choices for domains and types, but these are the most common. The socket() man page has more information. \n\nThe function sets all values in a buffer to zero. It takes two arguments, the first is a pointer to the buffer and the second is the size of the buffer. Thus, this line initializes to zeros. ---- \n\nThe port number on which the server will listen for connections is passed in as an argument, and this statement uses the function to convert this from a string of digits to an integer. The functionsets all values in a buffer to zero. It takes two arguments, the first is a pointer to the buffer and the second is the size of the buffer. Thus, this line initializesto zeros. ----The port number on which the server will listen for connections is passed in as an argument, and this statement uses thefunction to convert this from a string of digits to an integer. \n\nThe variable is a structure of type . This structure has four fields. The first field is , which contains a code for the address family. It should always be set to the symbolic constant . The variableis a structure of type. This structure has four fields. The first field is, which contains a code for the address family. It should always be set to the symbolic constant \n\nThe second field of is , which contain the port number. However, instead of simply copying the port number to this field, it is necessary to convert this to which converts a port number in host byte order to a port number in network byte order. The second field ofis, which contain the port number. However, instead of simply copying the port number to this field, it is necessary to convert this to network byte order using the functionwhich converts a port number in host byte order to a port number in network byte order. \n\nThe third field of is a structure of type which contains only a single field . This field contains the IP address of the host. For server code, this will always be the IP address of the machine on which the server is running, and there is a symbolic constant which gets this address. The third field ofis a structure of typewhich contains only a single field. This field contains the IP address of the host. For server code, this will always be the IP address of the machine on which the server is running, and there is a symbolic constantwhich gets this address. \n\nThe system call binds a socket to an address, in this case the address of the current host and port number on which the server will run. It takes three arguments, the socket file descriptor, the address to which is bound, and the size of the address to which it is bound. The second argument is a pointer to a structure of type , but what is passed in is a structure of type , and so this must be cast to the correct type. This can fail for a number of reasons, the most obvious being that this socket is already in use on this machine. The Thesystem call binds a socket to an address, in this case the address of the current host and port number on which the server will run. It takes three arguments, the socket file descriptor, the address to which is bound, and the size of the address to which it is bound. The second argument is a pointer to a structure of type, but what is passed in is a structure of type, and so this must be cast to the correct type. This can fail for a number of reasons, the most obvious being that this socket is already in use on this machine. The bind() manual has more information. \n\nThe system call allows the process to listen on the socket for connections. The first argument is the socket file descriptor, and the second is the size of the backlog queue, i.e., the number of connections that can be waiting while the process is handling a particular connection. This should be set to 5, the maximum size permitted by most systems. If the first argument is a valid socket, this call cannot fail, and so the code doesn't check for errors. The Thesystem call allows the process to listen on the socket for connections. The first argument is the socket file descriptor, and the second is the size of the backlog queue, i.e., the number of connections that can be waiting while the process is handling a particular connection. This should be set to 5, the maximum size permitted by most systems. If the first argument is a valid socket, this call cannot fail, and so the code doesn't check for errors. The listen() man page has more information. \n\nThe system call causes the process to block until a client connects to the server. Thus, it wakes up the process when a connection from a client has been successfully established. It returns a new file descriptor, and all communication on this connection should be done using the new file descriptor. The second argument is a reference pointer to the address of the client on the other end of the connection, and the third argument is the size of this structure. The Thesystem call causes the process to block until a client connects to the server. Thus, it wakes up the process when a connection from a client has been successfully established. It returns a new file descriptor, and all communication on this connection should be done using the new file descriptor. The second argument is a reference pointer to the address of the client on the other end of the connection, and the third argument is the size of this structure. The accept() man page has more information. bzero(buffer,256);\n\nn = read(newsockfd,buffer,255);\n\nif (n < 0) error(\"ERROR reading from socket\");\n\nprintf(\"Here is the message: %s\n\n\",buffer); \n\nNote that we would only get to this point after a client has successfully connected to our server. This code initializes the buffer using the function, and then reads from the socket. Note that the read call uses the new file descriptor, the one returned by , not the original file descriptor returned by . Note also that the will block until there is something for it to read in the socket, i.e. after the client has executed a . Note that we would only get to this point after a client has successfully connected to our server. This code initializes the buffer using thefunction, and then reads from the socket. Note that the read call uses the new file descriptor, the one returned by, not the original file descriptor returned by. Note also that thewill block until there is something for it to read in the socket, i.e. after the client has executed a It will read either the total number of characters in the socket or 255, whichever is less, and return the number of characters read. The read() man page has more information. n = write(newsockfd,\"I got your message\",18);\n\nif (n < 0) error(\"ERROR writing to socket\"); \n\nOnce a connection has been established, both ends can both read and write to the connection. Naturally, everything written by the client will be read by the server, and everything written by the server will be read by the client. This code simply writes a short message to the client. The last argument of write is the size of the message. The Once a connection has been established, both ends can both read and write to the connection. Naturally, everything written by the client will be read by the server, and everything written by the server will be read by the client. This code simply writes a short message to the client. The last argument of write is the size of the message. The write() man page has more information. \n\nThis terminates main and thus the program. Since main was declared to be of type int as specified by the ascii standard, some compilers complain if it does not return anything. This terminates main and thus the program. Since main was declared to be of type int as specified by the ascii standard, some compilers complain if it does not return anything. \n\nAs before, we will go through the program line by line. \n\nThe header files are the same as for the server with one addition. The file defines the structure , which will be used below. As before, we will go through the programline by line.The header files are the same as for the server with one addition. The filedefines the structure, which will be used below. \n\nThe function is identical to that in the server, as are the variables , and . The variable will contain the address of the server to which we want to connect. It is of type Thefunction is identical to that in the server, as are the variables, and. The variablewill contain the address of the server to which we want to connect. It is of type struct sockaddr_in The variable is a pointer to a structure of type . This structure is defined in the header file as follows: struct hostent\n\n{\n\n char *h_name; /* official name of host */\n\n char **h_aliases; /* alias list */\n\n int h_addrtype; /* host address type */\n\n int h_length; /* length of address */\n\n char **h_addr_list; /* list of addresses from name server */\n\n #define h_addr h_addr_list[0] /* address, for backward compatiblity */\n\n}; \n\nIt defines a host computer on the Internet. The members of this structure are: h_name Official name of the host.\n\nh_aliases A zero terminated array of alternate\n\n names for the host.\n\nh_addrtype The type of address being returned;\n\n currently always AF_INET.\n\nh_length The length, in bytes, of the address.\n\nh_addr_list A pointer to a list of network addresses\n\n for the named host. Host addresses are\n\n returned in network byte order. \n\nNote that is an alias for the first address in the array of network addresses. It defines a host computer on the Internet. The members of this structure are:Note thatis an alias for the first address in the array of network addresses. \n\nAll of this code is the same as that in the server. All of this code is the same as that in the server. \n\nThe variable [1] contains the name of a host on the Internet, e.g. . The function: \n\nTakes such a name as an argument and returns a pointer to a containing information about that host. The variable[1] contains the name of a host on the Internet, e.g.. The function:Takes such a name as an argument and returns a pointer to acontaining information about that host. The field contains the IP address.\n\n \n\nIf this structure is NULL, the system could not locate a host with this name. In the old days, this function worked by searching a system file called but with the explosive growth of the Internet, it became impossible for system administrators to keep this file current. Thus, the mechanism by which this function works is complex, often involves querying large databases all around the country. The gethostbyname() man page has more information. \n\nThis code sets the fields in . Much of it is the same as in the server. However, because the field is a character string, we use the function: \n\nwhich copies bytes from to . ---- \n\nThe function is called by the client to establish a connection to the server. It takes three arguments, the socket file descriptor, the address of the host to which it wants to connect (including the port number), and the size of this address. This function returns 0 on success and -1 if it fails. The This code sets the fields in. Much of it is the same as in the server. However, because the fieldis a character string, we use the function:which copiesbytes fromto. ----Thefunction is called by the client to establish a connection to the server. It takes three arguments, the socket file descriptor, the address of the host to which it wants to connect (including the port number), and the size of this address. This function returns 0 on success and -1 if it fails. The connect() man page has more information. Notice that the client needs to know the port number of the server, but it does not need to know its own port number. This is typically assigned by the system when is called. printf(\"Please enter the message: \");\n\n bzero(buffer,256);\n\n fgets(buffer,255,stdin);\n\n n = write(sockfd,buffer,strlen(buffer));\n\n if (n < 0)\n\n error(\"ERROR writing to socket\");\n\n bzero(buffer,256);\n\n n = read(sockfd,buffer,255);\n\n if (n < 0)\n\n error(\"ERROR reading from socket\");\n\n printf(\"%s\n\n\",buffer);\n\n return 0;\n\n} \n\nThe remaining code should be fairly clear. It prompts the user to enter a message, uses to read the message from stdin, writes the message to the socket, reads the reply from the socket, and displays this reply on the screen. The remaining code should be fairly clear. It prompts the user to enter a message, usesto read the message from stdin, writes the message to the socket, reads the reply from the socket, and displays this reply on the screen. The sample server code above has the limitation that it only handles one connection, and then dies. A \"real world\" server should run indefinitely and should have the capability of handling a number of simultaneous connections, each in its own process. This is typically done by forking off a new process to handle each new connection. The following code has a dummy function called .\n\n \n\nThis function will handle the connection after it has been established and provide whatever services the client requests. As we saw above, once a connection is established, both ends can use and to send information to the other end, and the details of the information passed back and forth do not concern us here.\n\n \n\nTo write a \"real world\" server, you would make essentially no changes to the main() function, and all of the code which provided the service would be in . To allow the server to handle multiple simultaneous connections, we make the following changes to the code:\n• Put the accept statement and the following code in an infinite loop.\n• After a connection is established, call #### to create a new process.\n• The child process will close #### and call #####, passing the new socket file descriptor as an argument. When the two processes have completed their conversation, as indicated by #### returning, this process simply exits.\n• The parent process closes ####. Because all of this code is in an infinite loop, it will return to the accept statement to wait for the next connection. while (1)\n\n {\n\n newsockfd = accept(sockfd,\n\n (struct sockaddr *) &cli_addr, &clilen);\n\n if (newsockfd < 0)\n\n error(\"ERROR on accept\");\n\n pid = fork();\n\n if (pid < 0)\n\n error(\"ERROR on fork\");\n\n if (pid == 0)\n\n {\n\n close(sockfd);\n\n dostuff(newsockfd);\n\n exit(0);\n\n }\n\n else\n\n close(newsockfd);\n\n } /* end of while */ \n\n for a complete server program which includes this change. This will run with the program client.c. for a complete server program which includes this change. This will run with the program client.c. Click here for a complete server program which includes this change. This will run with the program client.c. The above code has a problem; if the parent runs for a long time and accepts many connections, each of these connections will create a zombie when the connection is terminated. A zombie is a process which has terminated but but cannot be permitted to fully die because at some point in the future, the parent of the process might execute a and would want information about the death of the child. Zombies clog up the process table in the kernel, and so they should be prevented. Unfortunately, the code which prevents zombies is not consistent across different architectures. When a child dies, it sends a SIGCHLD signal to its parent. On systems such as AIX, the following code in is all that is needed. \n\nThis says to ignore the SIGCHLD signal. However, on systems running SunOS, you have to use the following code: \n\nThe function will be called whenever the parent receives a SIGCHLD signal (i.e. whenever a child dies). This will in turn call which will receive the signal. The WNOHANG flag is set, which causes this to be a non-blocking wait (one of my favorite This says to ignore the SIGCHLD signal. However, on systems running SunOS, you have to use the following code:The functionwill be called whenever the parent receives a SIGCHLD signal (i.e. whenever a child dies). This will in turn callwhich will receive the signal. The WNOHANG flag is set, which causes this to be a non-blocking wait (one of my favorite oxymorons ). This example showed a stream socket in the Internet domain. This is the most common type of connection. A second type of connection is a datagram socket. You might want to use a datagram socket in cases where there is only one message being sent from the client to the server, and only one message being sent back. There are several differences between a datagram socket and a stream socket.\n• Datagrams are unreliable, which means that if a packet of information gets lost somewhere in the Internet, the sender is not told (and of course the receiver does not know about the existence of the message). In contrast, with a stream socket, the underlying TCP protocol will detect that a message was lost because it was not acknowledged, and it will be retransmitted without the process at either end knowing about this.\n• Message boundaries are preserved in datagram sockets. If the sender sends a datagram of 100 bytes, the receiver must read all 100 bytes at once. This can be contrasted with a stream socket, where if the sender wrote a 100 byte message, the receiver could read it in two chunks of 50 bytes or 100 chunks of one byte.\n• The communication is done using special system calls #### and #### rather than the more generic #### and ####.\n• There is a lot less overhead associated with a datagram socket because connections do not need to be established and broken down, and packets do not need to be acknowledged. This is why datagram sockets are often used when the service to be provided is short, such as a time-of-day service. Click here for the server code using a datagram socket. Click here for the client code using a datagram socket. These two programs can be compiled and run in exactly the same way as the server and client using a stream socket. Most of the server code is similar to the stream socket code. Here are the differences. \n\nNote that when the socket is created, the second argument is the symbolic constant SOCK_DGRAM instead of SOCK_STREAM. The protocol will be UDP, not TCP. ---- \n\nServers using datagram sockets do not use the or the system calls. After a socket has been bound to an address, the program calls to read a message. This call will block until a message is received. The system call takes six arguments. The first three are the same as those for the call, the socket file descriptor, the buffer into which the message will be read, and the maximum number of bytes. The fourth argument is an integer argument for flags. This is ordinarily set to zero. The fifth argument is a pointer to a Note that when the socket is created, the second argument is the symbolic constant SOCK_DGRAM instead of SOCK_STREAM. The protocol will be UDP, not TCP. ----Servers using datagram sockets do not use theor thesystem calls. After a socket has been bound to an address, the program callsto read a message. This call will block until a message is received. Thesystem call takes six arguments. The first three are the same as those for thecall, the socket file descriptor, the buffer into which the message will be read, and the maximum number of bytes. The fourth argument is an integer argument for flags. This is ordinarily set to zero. The fifth argument is a pointer to a sockaddr_in structure . When the call returns, the values of this structure will have been filled in for the other end of the connection (the client). The size of this structure will be in the last argument, a pointer to an integer. This call returns the number of bytes in the message. (or -1 on an error condition). The recfrom() man page has more information. \n\nTo send a datagram, the function is used. This also takes six arguments. The first three are the same as for a call, the socket file descriptor, the buffer from which the message will be written, and the number of bytes to write. The fourth argument is an int argument called flags, which is normally zero. The fifth argument is a pointer to a structure. This will contain the address to which the message will be sent. Notice that in this case, since the server is replying to a message, the values of this structure were provided by the recvfrom call. The last argument is the size of this structure. Note that this is not a pointer to an int, but an int value itself. The To send a datagram, the functionis used. This also takes six arguments. The first three are the same as for acall, the socket file descriptor, the buffer from which the message will be written, and the number of bytes to write. The fourth argument is an int argument called flags, which is normally zero. The fifth argument is a pointer to astructure. This will contain the address to which the message will be sent. Notice that in this case, since the server is replying to a message, the values of this structure were provided by the recvfrom call. The last argument is the size of this structure. Note that this is not a pointer to an int, but an int value itself. The sendto() man page has more information. The client code for a datagram socket client is the same as that for a stream socket with the following differences.\n• the socket system call has SOCK_DGRAM instead of SOCK_STREAM as its second argument.\n• there is no **** system call\n• instead of **** and ****, the client uses **** and **** which are described in detail above. Here is the code for a client and server which communicate using a stream socket in the Unix domain. The only difference between a socket in the Unix domain and a socket in the Internet domain is the form of the address. Here is the address structure for a Unix Domain address, defined in the header file. \n\nThe field has the form of a path name in the Unix file system. This means that both client and server have to be running the same file system. Once a socket has been created, it remain until it is explicitly deleted, and its name will appear with the command, always with a size of zero. Sockets in the Unix domain are virtually identical to named pipes (FIFOs). The fieldhas the form of a path name in the Unix file system. This means that both client and server have to be running the same file system. Once a socket has been created, it remain until it is explicitly deleted, and its name will appear with thecommand, always with a size of zero. Sockets in the Unix domain are virtually identical to named pipes (FIFOs). There are a number of different ways to design servers. These models are discussed in detail in a book by Douglas E. Comer and David L. Stevens entiteld Internetworking with TCP/IP Volume III:Client Server Programming and Applications published by Prentice Hall in 1996. These are summarized here. \n\nThe typical server in the Internet domain creates a stream socket and forks off a process to handle each new connection that it receives. This model is appropriate for services which will do a good deal of reading and writing over an extended period of time, such as a telnet server or an ftp server. This model has relatively high overhead, because forking off a new process is a time consuming operation, and because a stream socket which uses the TCP protocol has high kernel overhead, not only in establishing the connection but also in transmitting information. However, once the connection has been established, data transmission is reliable in both directions. \n\nServers which provide only a single message to the client often do not involve forking, and often use a datagram socket rather than a stream socket. Examples include a finger daemon or a timeofday server or an echo server (a server which merely echoes a message sent by the client). These servers handle each message as it receives them in the same process. There is much less overhead with this type of server, but the communication is unreliable. A request or a reply may get lost in the Internet, and there is no built-in mechanism to detect and handle this. \n\nA server which needs the capability of handling several clients simultaneous, but where each connection is I/O dominated (i.e. the server spends most of its time blocked waiting for a message from the client) is a candidate for a single process, concurrent server. In this model, one process maintains a number of open connections, and listens at each for a message. Whenever it gets a message from a client, it replies quickly and then listens for the next one. This type of service can be done \n\n rate this article:\n\ncurrent rating: average rating: 1.2 (41066 votes) (1=very good 6=terrible)\n\nYour rating:\n\n \n\nback"
    },
    {
        "link": "https://dev.to/sanjayrv/a-beginners-guide-to-socket-programming-in-c-5an5",
        "document": "Hi all👋🏽 This is my first blog. I never had thoughts about writing blogs. I then came across why beginners should start blogging as they learn new things here, so here we go.\n\nMy career began 6 months ago as a backend developer working on node.js and express👨‍💻. I was thoroughly enjoying this phase of learning and coding. Eventually the project got over and in the new project I was to work on socket programming.\n\nI was more or less as clueless and sweating as this guy xD.\n\n \n\n But this was only in the beginning. Let's us go through the concepts of socket programming to feel better📈\n\nWithout wasting any time, let us start.\n\nSockets allow communication between two different processes on the same or different machines.\n\nSocket programming is a way of connecting two nodes on a network to communicate with each other. One socket (node) listens on a particular port at an IP, while other socket reaches out to the other to form a connection. Server forms the listener socket while client reaches out to the server.\n\nClient/Server communication involves two components, namely a client and a server. There are usually multiple clients in communication with a single server. The clients send requests to the server and the server responds to the client requests.\n\nClient is sometimes on and initiates requests to the server whenever interested. It needs to know the address of the server.\n\nServer is always on and services requests from many clients. It doesn’t initiate contact with any clients.\n\nHow to use sockets?\n• Set up a Socket (Prepare to communicate)\n• Initiate the connection to the server\n• Send and receive packets (Exchange data with the server)\n• Do stuff with the data (e.g., display a Web page)\n• Set up a Socket (Prepare to communicate)\n• Associate server’s IP address and port no. with the socket\n• Wait to hear from a client\n• Indicate how many connections can be pending on the socket\n• Accept an incoming connection from a client, create a new socket s_new for the client.\n• Send and receive packets (Exchange data with the client over the new socket s_new)\n• Repeat 2.2-3.4 with the next connection request\n\nLet us see how each step is done.\n\nBoth client and server need to setup the socket\n\n \n\n Returns a socket descriptor on success, -1 on failure.\n\nOnly the server needs to bind.\n• sockfd is a file descriptor socket() that is returned.\n\nstruct sockaddr_in { \n\n short sin_family; // e.g. AF_INET \n\n unsigned short sin_port; // e.g. htons(3490)‏ \n\n struct in_addr sin_addr; // see struct in_addr below \n\n char sin_zero[8]; // zero this if you want to \n\n };\n• addrlen is the size of the address structure\n\nOnly the server needs to listen\n• backlog specifies the maximum number of pending connections the kernel should queue for the socket. Listen returns 0 if OK, -1 on error\n\nOnly the server can accept the incoming client connections.\n• fromaddr is a pointer to store the client address\n• addrlen is a pointer to store the returned size of addr. accept() takes the first connection off the queue for sockfd and create a new socket (the return value) for communicating with the client. accept() return a new socket descriptor if OK, -1 on error\n\nThe client need not bind, listen or accept. All client needs to do is to just connect to the server.\n• toaddr contains the IP address and port number of the serve\n• addrlen is length of the socket address structure connect() returns 0 if connection is successful and -1 on error\n• \n• Read up to n bytes from sockfd into buffer\n• Returns the number of bytes read on success (0 indicates end of file), -1 on error.\n• \n• Write up to n bytes from buffer to sockfd\n• Returns the number of bytes written on success, -1 on error.\n\nDon't forget to close the socket descriptor after all the effort we've put.\n\n\n\nIf I could learn socket programming, you can too!\n\n Happy Programming!!"
    },
    {
        "link": "https://geeksforgeeks.org/multithreading-in-c",
        "document": "A thread is a single sequence stream within a process. Because threads have some of the properties of processes, they are sometimes called lightweight processes.\n\nWhat are the differences between process and thread?\n\nThreads are not independent from each other unlike processes. As a result, threads shares with other threads their code section, data section and OS resources like open files and signals. But, like processes, a thread has its own program counter (PC), a register set, and a stack space.\n\nWhy Multithreading? Threads are popular way to improve application through parallelism. For example, in a browser, multiple tabs can be different threads. MS word uses multiple threads, one thread to format the text, other thread to process inputs, etc.\n\nThreads operate faster than processes due to following reasons:\n\n2) Context switching between threads is much faster.\n\nSee http://www.personal.kent.edu/~rmuhamma/OpSystems/Myos/threads.htm for more details.\n\nCan we write multithreading programs in C?\n\nUnlike Java, multithreading is not supported by the language standard. POSIX Threads (or Pthreads) is a POSIX standard for threads. Implementation of pthread is available with gcc compiler.\n\nA simple C program to demonstrate use of pthread basic functions\n\nPlease note that the below program may compile only with C compilers with pthread library.\n\nIn main(), we declare a variable called thread_id, which is of type pthread_t, which is an integer used to identify the thread in the system. After declaring thread_id, we call pthread_create() function to create a thread.\n\nThe first argument is a pointer to thread_id which is set by this function.\n\nThe second argument specifies attributes. If the value is NULL, then default attributes shall be used.\n\nThe third argument is name of function to be executed for the thread to be created.\n\nThe fourth argument is used to pass arguments to the function, myThreadFun.\n\nThe pthread_join() function for threads is the equivalent of wait() for processes. A call to pthread_join blocks the calling thread until the thread with identifier equal to the first argument terminates.\n\nHow to compile above program?\n\nTo compile a multithreaded program using gcc, we need to link it with the pthreads library. Following is the command used to compile the program.\n\nA C program to show multiple threads with global and static variables\n\nAs mentioned above, all threads share data segment. Global and static variables are stored in data segment. Therefore, they are shared by all threads. The following example program demonstrates the same.\n\nPlease note that above is simple example to show how threads work. Accessing a global variable in a thread is generally a bad idea. What if thread 2 has priority over thread 1 and thread 1 needs to change the variable. In practice, if it is required to access global variable by multiple threads, then they should be accessed using a mutex."
    },
    {
        "link": "https://stackoverflow.com/questions/35061854/creating-multiple-threads-in-c",
        "document": "I am just a beginner in Programming using C.For my college project I want to create a multi-threaded server application to which multiple clients can connect and transfer there data which can be saved in a database.\n\nAfter going through many tutorials I got confused about how to create multiple threads using pthread_create.\n\nSomewhere it was done like:\n\nand somewhere it was like\n\nI tried by implementing both in my application and seems to be working fine. Which approach of the above two is correct which I should follow. sorry for bad english and description."
    },
    {
        "link": "https://stackoverflow.com/questions/14160873/c-programming-error-handling",
        "document": "I want my code to be able to handle the error cases, such as unsuccessful return of functions. For instance, ,normally I use the function herebelow:\n\nConsidering the error cases, would it be correct to call the same function till it returns 0(for this specific function) as it is done below?\n\nCan I apply the same logic to the other C functions that returns a value? Otherwise, how would you suggest to handle error cases (for the function returns) without exiting from the program?"
    },
    {
        "link": "https://cs.kent.edu/~ruttan/sysprog/lectures/multi-thread/multi-thread.html",
        "document": ""
    },
    {
        "link": "https://codequoi.com/en/threads-mutexes-and-concurrent-programming-in-c",
        "document": "For efficiency or by necessity, a program can be concurrent rather than sequential. Thanks to its concurrent programming and with its child processes or threads and mutexes, it will be able to perform multiple tasks simultaneously.\n\nIn a previous article, we came to understand how to create child processes, which are one way to implement concurrent programming. Here, we will concentrate on threads and how to deal with the dangers that come with their shared memory with mutexes.\n\nAs opposed to sequential programming, concurrent programming allows a program to perform several tasks simultaneously instead of having to wait for the result of one operation to move onto the next. The operating system itself uses this concept to meet its users expectations. If we had to wait for a song to finish to be able to open our browser, or if we had to restart the computer to kill a program caught in an infinite loop, we’d die of frustration!\n\nThere are three ways to implement concurrency in our programs: processes, threads, and multiplexing. Let’s concentrate on threads.\n\nAn execution thread is a logical sequence of instructions inside a process that is automatically managed by the operating system’s kernel. A regular sequential program has a single thread, but modern operating systems allow us to create several threads in our programs, all of which run in parallel.\n\nEach one of a process’s threads has its own context: its own ID, its own stack, its own instruction pointer, it’s own processor register. But since all of the threads are part of the same process, they share the same virtual memory address space: the same code, the same heap, the same shared libraries and the same open file descriptors.\n\nA thread’s context has a smaller footprint in terms of resources than the context of a process. Which means that it is much faster for the system to create a thread than it is to create a process. Switching from one thread to the other, compared to switching from one process to another is also quicker.\n\nThreads don’t have the strict parent-child hierarchy that processes do. Rather, they form a group of peers regardless of which thread created which other thread. The only distinction the “main” thread has is being the first one to exist at the beginning of the process. This means that within the same process, any thread can wait for any other thread to complete, or kill any other thread.\n\nAdditionally, any thread can read and write to the same virtual memory, which makes communication between threads much easier than communication between processes. We will later examine the problems that can arise from this shared memory.\n\nThe standard interface in C to manipulate threads is POSIX with its <pthread.h> library. It contains around sixty functions to create and join threads, as well as to manage their shared memory. We will only study a fraction of these in this article. In order to compile a program using this library, we can’t forget to link it with :\n\nWe can create a new thread from any other thread of the program with the function. Its prototype is:\n\nLet’s examine each argument we must supply:\n• thread: a pointer towards a type variable, to store the ID of the thread we will be creating.\n• attr: an argument that allows us to change the default attributes of the new thread. This is beyond the scope of this article, and in general, passing here suffices.\n• start_routine: the function where the thread will start its execution. This function will have as its prototype: . When the thread reaches the end of this function, it will be done with its tasks.\n• arg: a pointer towards an argument to pass to the thread’s function. If we’d like to pass several parameters to this function, we will need to give it a pointer to a data structure.\n\nWhen the function ends, the thread variable we gave it should contain the newly created thread’s ID. The function itself returns 0 if the creation was successful, or en error code if not.\n\nIn order to block the execution of a thread until another thread finishes, we can use the function:\n\nIts parameters are as follows:\n• thread: the ID of the thread that this thread should wait for. The specified thread must be joinable (meaning not detached - see below).\n• retval: a pointer towards a variable that can contain the return value of the thread’s routine function (the function we supplied at its creation). Here, we will not need this value: a simple will suffice.\n\nThe function returns 0 for success, or an error code for failure.\n\nLet’s note that we can only wait for the termination of a specific thread. There is no way to wait for the first terminated thread without specifying an ID, as the function for child processes does.\n\nBut in some cases, it is possible and preferable to not wait for the end of certain theads at all. In that case, we can detach the thread to tell the operating system that it can reclaim its resources right away when it finishes its execution. For that, we use the function (usually right after that thread’s creation):\n\nHere, all we have to supply if the thread’s ID. We get 0 in return if the operation was a success, or non-zero if there was an error. After detaching the thread, other threads will not be able to kill or wait for this thread with .\n\nLet’s write a small, simple program that creates two threads and joins them. The routine of each thread only consists of writing its own ID followed by a roughly-translated philosophic quote from the French novelist Victor Hugo.\n\nWhen we compile and run this test, we can see that both threads were created and print their IDs correctly. If we run the program several times in a row, we might notice that the threads are always created in order, but sometimes, the main writes its message before the thread and vice versa. This shows that each thread is indeed executing in parallel to the main thread, and not sequentially.\n\nOne of the greatest qualities of threads is that they all share their process’s memory. Each thread does have its own stack, but the other threads can very easily gain access to it with a simple pointer. What’s more, the heap and any open file descriptors are totally shared between threads.\n\nThis shared memory and the ease with which a thread can access another thread’s memory clearly also has its share of danger: it can cause nasty synchronization errors.\n\nLet’s go back to our previous example and modify it to see how the shared virtual memory of threads can cause issues. We will create two threads and give each of them a pointer towards a variable in the main containing an unsigned integer, . Each thread will iterate a certain number of times (defined in the macro) and increment the count at each iteration. Since there are two threads, we will of course expect the final count to be exactly twice .\n\nCompletely by chance, the first time we run the program, the result could be correct. But things aren’t always as they appear! The second time we run it, the result is totally incorrect. If we continue to run the program several more times in a row, we’ll even come to realize that it is wrong much more often than right… And it isn’t even predictably wrong: the final count varies a lot from one run to the next. So what is happening, here?\n\nIf we examine the results closely, we can see that the final count is correct if and only if the first thread finishes counting before the second one starts. Whenever their executions overlap, the result is wrong, and always less than the expected result.\n\nSo the problem is that both threads often access the same memory area at the same time. Let’s say the count is currently 10. Thread 1 reads the value 10. More accurately, it copies that value 10 to its register in order to manipulate it. Then, it adds 1 to get a result of 11. But before it can save the result in the memory area pointed to by the count variable, thread 2 reads the value 10. Thread 2 then increments it to 11 as well. Both threads then save their result and there we have it! Instead of incrementing the count once for each thread, they ended up only incrementing it by one in total… That’s why we’re loosing counts and our final result is so wrong.\n\nThis situation is called a data race. It happens when a program is subject to the progression or timing of other uncontrollable events. It is impossible to predict if the operating system will choose the correct sequencing for our threads.\n\nIndeed, if we compile the program with the and options and then run it, like this:\n\nWe will get an alert: “WARNING: ThreadSanitizer: data race”.\n\nSo is there a way to stop a thread from reading a value while another one modifies it? Yes, thanks to mutexes!\n\nA mutex (short for \" mut ual ex clusion\") is a synchronization primitive. It is essentially a lock that allows us to regulate access to data and prevent shared resources being used at the same time.\n\nWe can think of a mutex as the lock of a bathroom door. One thread locks it to indicate that the bathroom is occupied. The other threads will just have to patiently stand in line until the door is unlocked before they can take their turn in the bathroom.\n\nThanks to the header, we can declare a mutex type variable like this:\n\nBefore we can use it, we first need to initialize it with the function which has the following prototype:\n\nThere are two parameters to supply:\n• mutex: the pointer to a variable of type, the mutex we want to initialize.\n• mutexattr: a pointer to specific attributes for the mutex. We will not worry about this parameter here, we can just say .\n\nThe function only ever returns 0.\n\nThen, in order to lock and unlock our mutex, we need two other functions. Their prototypes are as follows:\n\nIf the mutex is unlocked, locks it and the calling thread becomes its owner. In this case, the function ends immediately. However, if the mutex is already locked by another thread, suspends the execution of the calling thread until the mutex is unlocked.\n\nThe function unlocks a mutex. The mutex to be unlocked is assumed to be locked by the calling thread, and the function only sets it to unlocked. Let’s be careful to note that this function does not check if the mutex is in fact locked and that the calling thread is actually its owner: a mutex could therefore be unlocked by a thread that did not lock it in the first place. We will need to be careful about arranging and in our code, otherwise, we might get “lock order violation” errors.\n\nBoth of these functions return 0 for success and an error code otherwise.\n\nWhen we no longer need a mutex, we should destroy it with the following function:\n\nThis function destroys an unlocked mutex, freeing whatever resources it might hold. In the LinuxThreads implementation of POSIX threads, no resources are associated with mutexes. In that case, doesn’t do anything other than check that the mutex isn’t locked.\n\nWe can now solve our previous example’s problem of incorrect final count by using a mutex. For this, we need to create a small structure that will contain our variable and the mutex that will protect it. We can then pass this structure to our threads’ routines.\n\n// This structure contains the count as well as the mutex // that will protect the access to the variable. // pointer to the structure in main // Print the count before this thread starts iterating. // In order to read the value of count, we lock the mutex: // Increment the counter at each iteration // Lock the mutex for the duration of the incrementation // Print the final count when this thread finishes its // own count, without forgetting to lock the mutex: // There is only on thread here (main thread), so we can safely // initialize count without using the mutex. // Since each thread counts TIMES_TO_COUNT times and that // we have 2 threads, we expect the final count to be // (Here we can read the count without worrying about // the mutex because all threads have been joined and // there can be no data race between threads) \"%sMain: OK. Total count is %u%s // Destroy the mutex at the end of the program:\n\nLet’s see if our result is still incorrect now:\n\nThere! Our result is now always right, every time we run the program, even if the second thread starts counting before the first is finished.\n\nHowever, mutexes can often provoke deadlocks. It’s a situation in which each thread waits for a resource held by another thread. For example, thread T1 acquired mutex M1 and is waiting for mutex M2. Meanwhile thread T2 acquired mutex M2 and is waiting for mutex M1. In this situation, the program stays perpetually pending and must be killed.\n\nA deadlock can also happen when a thread is waiting for a mutex that it already owns!\n\nLet’s try to demonstrate a deadlock. In this example, we will have two threads that need to lock two mutexes, and before being able to increment a counter. The routines of the two threads will be slightly different: the first thread will lock first, while thread 2 will start by locking …\n\nAs we can see in the following output, most of the time, there is no problem with this configuration because the first thread has a small head start on the second one. But sometimes, both threads lock their first mutexes exactly at the same time, in which case the program stays blocked because the threads are caught in a deadlock.\n\nStudying this second result, we can clearly see that the first thread locked and the second locked . The first thread now wants to lock and the second wants , but neither have any way of getting those mutexes. They are deadlocked.\n\nThere are several ways to deal with deadlocks like these. Among other things, we can:\n• ignore them, but only if we can prove that they will never happen. For example when the time intervals between resource requests are very long and far between.\n• correct them when they happen by killing a thread or by redistributing resources, for example.\n• prevent and correct them before they happen.\n• avoid them by imposing a strict order for resource acquisition. This is the solution to our previous example: the threads should both ask for first.\n• avoid them by forcing a thread to release a resource before asking for new ones, or before renewing its request.\n\nThere is no “best” solution that will solve all deadlock cases. The best method to deal with a particular deadlock depends on the situation.\n\nThe most important thing to remember when testing any program that makes use of threads, is to test the same thing many times in a row. Oftentimes, synchronization errors won’t be apparent on the first or second or even third run. It depends on the order the operating system chooses for the execution of each thread. By running the same test over and over, we may see a large variation in the results.\n\nThere are some tools we can use to help us detect thread-related errors like possible data races, deadlocks and lock order violations:\n• The flag we can add at compilation. The option displays the specific files and line numbers involved.\n• The thread error detection tool Helgrind that we can run our program with, like this: .\n• DRD, another thread error detection tool that we can also run our program with, like this: .\n\nBeware of using both and valgrind, they do not play well together!\n\nAnd as always, we can’t forget to check for memory leaks with and !\n\nA little tip to share, a nagging question to ask, or a strange discovery to discuss about threads or mutexes? I’d love to read and respond to it all in the comments. Happy coding !"
    }
]