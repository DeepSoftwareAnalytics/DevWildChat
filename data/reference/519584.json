[
    {
        "link": "https://stackoverflow.com/questions/63167612/python-understanding-os-listdir-method",
        "document": "I am still a beginner with python and I would like to understand what the following code does.\n\nAs it can be seen, I have inserted a path to the folder containing the images. However, when I print the content, it is empty. Please, could anyone explain what could be the reason as well as the way for solving it?"
    },
    {
        "link": "https://w3schools.com/python/ref_os_listdir.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://ioflood.com/blog/python-os-listdir",
        "document": "Are you finding it challenging to list files and directories in Python? You’re not alone. Many developers find themselves in a maze when it comes to navigating through directories in Python, but there’s a function that can make this process a breeze.\n\nJust like a seasoned librarian, Python’s os.listdir() function can help you navigate through your directories. This function is a powerful tool that can list all files and directories in a specific directory, providing a versatile and handy tool for various tasks.\n\nIn this guide, we’ll walk you through the process of using os.listdir() in Python, from its basic usage to more advanced techniques. We’ll cover everything from the fundamentals of Python’s os module to handling common issues and their solutions.\n\nSo, let’s dive in and start mastering os.listdir() in Python!\n\nTL;DR: How Do I List Files and Directories in Python?\n\nIn this example, we import the os module and use the function to list all files and directories in the current directory, denoted by ‘.’. The output is a list of file and directory names.\n\nThe function in Python is a straightforward and effective way to list files and directories in a specific directory. It is part of the os module, which provides a portable way of using operating system dependent functionality.\n\nTo use , you first need to import the os module. Here’s how you can do it:\n\nNow that the os module is imported, you can use . The function takes a single argument: the path of the directory you want to list files and directories from. If no argument is given, it defaults to the current directory (‘.’).\n\nHere’s an example of how to use to list files and directories in the current directory:\n\nIn this example, returns a list of all files and directories in the current directory. The output is a list of file and directory names.\n\nThe function is a simple yet powerful tool for listing files and directories in Python. It’s easy to use and works across all platforms, making it a versatile tool for any Python developer.\n\nHowever, does not differentiate between files and directories. It simply returns all entries in the specified directory. If you need to distinguish between files and directories, you’ll need to use additional functions from the os module, which we’ll cover in the advanced use section.\n\nOne potential pitfall when using is that it does not handle exceptions by default. If you try to list files and directories from a non-existent directory or a directory you do not have permission to access, will raise an exception. We’ll discuss how to handle these exceptions in the troubleshooting and considerations section.\n\nWhile the basic use of is quite straightforward, you can use it in conjunction with other functions from the os module for more complex tasks. In this section, we’ll discuss how to use to not only list files and directories, but also distinguish between them and manipulate them.\n\nOne common use case is to separate files from directories. To do this, you can use the function, which checks if a given path is a directory. Here’s an example:\n\nIn this example, we use list comprehensions to separate files and directories. We use to check if each entry returned by is a directory. If it is, we add it to the directories list. If it’s not, we add it to the files list.\n\nAnother advanced use of is to manipulate files and directories. For instance, you can rename all files in a directory with a specific extension. To do this, you can use the function. Here’s an example:\n\nIn this example, we iterate over each file in the current directory. If a file ends with ‘.txt’, we rename it to end with ‘.bak’ instead. We use to rename the files.\n\nThese are just a few examples of how you can use in more complex ways. By combining it with other functions from the os module, you can perform a wide range of tasks related to file and directory manipulation.\n\nWhile is a powerful and commonly used function to list files and directories in Python, it’s not the only way to do it. There are other modules in Python that provide similar functionality. In this section, we’ll introduce two alternative methods: the module and the module.\n\nThe module is used to find all pathnames matching a specified pattern. Here’s an example of how to use it to list all ‘.txt’ files in the current directory:\n\nIn this example, returns a list of all ‘.txt’ files in the current directory. The output is a list of file names.\n\nOne advantage of using over is that can search for files with specific patterns, making it a powerful tool for more complex file searching tasks. However, does not differentiate between files and directories by default, just like .\n\nThe module offers an object-oriented approach to file and directory manipulation. It provides a more high-level and intuitive interface compared to . Here’s an example of how to use it to list all files in the current directory:\n\nIn this example, returns an iterator that produces objects for all files and directories in the current directory. We use list comprehensions and the and methods to separate files and directories.\n\nOne advantage of using over is that provides a more high-level and intuitive interface for file and directory manipulation. However, is only available in Python 3.4 and later, so it’s not suitable for codebases that need to support older versions of Python.\n\nIn conclusion, while is a simple and effective way to list files and directories in Python, there are alternative methods that offer different advantages. Depending on your specific needs and the complexity of your tasks, you might find the module or the module more suitable. We recommend trying out all three methods and choosing the one that fits your needs the best.\n\nWhile is a powerful tool, it’s not without its potential pitfalls. In this section, we’ll discuss some common issues you might encounter when using , such as handling and , and provide solutions and workarounds for each issue.\n\nraises a if the directory you’re trying to list files and directories from does not exist. Here’s an example:\n\nIn this example, we use a try/except block to catch the and print a custom error message. This is a simple way to handle non-existent directories.\n\nraises a if you don’t have permission to access the directory you’re trying to list files and directories from. Here’s an example:\n\nIn this example, we use a try/except block to catch the and print a custom error message. This is a simple way to handle directories you don’t have permission to access.\n\nIt’s important to note that does not return hidden files (files starting with a dot) by default. If you need to list hidden files, you’ll need to use other functions or modules, such as or the module with the pattern.\n\nIn conclusion, while is a powerful tool for listing files and directories in Python, it’s not without its potential pitfalls. By understanding these pitfalls and how to handle them, you can use more effectively and avoid common issues.\n\nThe module in Python provides a way of using operating system dependent functionality. It includes functions for interacting with the file system, such as creating, removing, and changing directories, and listing files and directories.\n\nThe function is part of the module. It uses an underlying system call to read the directory entries. On Unix and Linux, it uses the system call. On Windows, it uses the and functions.\n\nHere’s an example of how to use to list files and directories in the current directory:\n\nIn this example, returns a list of all files and directories in the current directory. The output is a list of file and directory names.\n\nThe function is a simple yet powerful tool for listing files and directories in Python. It’s easy to use and works across all platforms, making it a versatile tool for any Python developer.\n\nHowever, does not handle exceptions by default. If you try to list files and directories from a non-existent directory or a directory you do not have permission to access, will raise an exception. We’ll discuss how to handle these exceptions in the troubleshooting and considerations section.\n\nIn conclusion, the module, and in particular the function, is a fundamental part of file and directory manipulation in Python. Understanding how it works and how to use it effectively is crucial for any Python developer.\n\nExtending the Use of os.listdir()\n\nThe function is not just for small scripts or one-off tasks. It can also play a crucial role in larger scripts or projects. For instance, in a file management system or a web server, you might need to list files and directories to perform operations like file upload, download, or deletion.\n\nIn such cases, can be used in combination with other related functions from the os module, such as , , and , to build more complex and robust file handling mechanisms.\n\nHere’s an example of how to use and to list all files in a directory and its subdirectories recursively:\n\nIn this example, is used to iterate over all files in a directory and its subdirectories. is used to join the root directory and the file name to get the full path of each file.\n\nTo further your understanding and mastery of Python’s os module and the function, here are some additional resources:\n• Python OS Essentials: Quick Guide – Master the art of checking file existence, creating directories, and more with “os.”\n• None Navigating Pathlib in Python – Learn how “pathlib” simplifies file and directory operations in Python.\n• None Python File Renaming Techniques – Dive into the world of file renaming and understand renaming strategies.\n• None Python’s official file and directory access tutorial details the usage of the OS module for file and directory access.\n• None Real Python’s Python files guide can help you manage your files, with examples and tips.\n\nThese resources are a great starting point for anyone looking to master file and directory manipulation in Python.\n\nIn this comprehensive guide, we’ve unlocked the power of Python’s function, a versatile tool for listing files and directories in Python.\n\nWe started with the basics, learning how to use in its simplest form to list files and directories in a specific directory. We then delved deeper, exploring more advanced uses of , such as distinguishing between files and directories and manipulating them.\n\nWe also tackled common challenges you might face when using , such as handling and , providing solutions and workarounds for each issue.\n\nWe didn’t stop there. We also explored alternative approaches to listing files and directories in Python, comparing with other methods like the module and the module.\n\nWhether you’re just starting out with or you’re looking to enhance your file and directory manipulation skills in Python, we hope this guide has given you a deeper understanding of and its capabilities.\n\nWith its simplicity, versatility, and wide compatibility, is a powerful tool for listing files and directories in Python. Now, you’re well equipped to navigate the file system with Python. Happy coding!"
    },
    {
        "link": "https://geeksforgeeks.org/python-list-files-in-a-directory",
        "document": "Sometimes, while working with files in Python, a problem arises with how to get all files in a directory. In this article, we will cover different methods of how to list all file names in a directory in Python.\n\nWe will cover two modules and their respective functions for this tutorial on listing file names and details in a directory.\n\nWhat is a Directory in Python?\n\nA Directory, sometimes known as a folder, is a unit organizational structure in a computer’s file system for storing and locating files or more folders. Python now supports several APIs to list the directory contents. For instance, we can use the Path.iterdir, os.scandir, os.walk, Path.rglob, or os.listdir functions.\n\nHow to List Files in a Directory in Python\n\nThere are multiple ways of listing all the files in a directory. In this article, we will discuss the below modules and their functions to fetch the list of files in a directory. We will cover a total of 5 ways with examples to check the list of files in a directory.\n\nList Files in a Directory Using Os Module in Python\n\nWe can use these 3 methods of the OS module, to get a list of files in a directory.\n\nGet the list of files using os.listdir() method\n\nos.listdir() method gets the list of all files and directories in a specified directory. By default, it is the current directory. Beyond the first level of folders, os.listdir() does not return any files or folders.\n\nExample 1: Get a list of all files in a directory\n\nIn this example, the os module is imported to interact with the operating system. The listdir function is used to obtain a list of all files and directories in the specified path (“C://Users//Vanshi//Desktop//gfg”). The result is then printed, displaying the names of files and directories present in the specified location.\n\nExample 2: Get all the files and no folders\n\nIn this example, the Python program prompts the user for a folder path, and lists and prints the files in that directory, utilizing the os module for directory interaction and filtering files from the obtained list.\n\nExample 3: Get only ‘.txt’ files from the directory\n\nIn this example, the Python script utilizes the os module to iterate through files in the current directory. It selectively prints only the names of files ending with “.txt,” effectively listing text files present in the directory.\n\nOS.walk() generates file names in a directory tree. This function returns a list of files in a tree structure. The method loops through all of the directories in a tree.\n\nExample: Get only ‘.txt’ files in a directory\n\nIn this example, the Python script uses the os module to traverse through files in the specified directory (“C://Users//Vanshi//Desktop//gfg”) and its subdirectories. It identifies and prints the names of files with a “.txt” extension, populating the list variable with the desired text files.\n\nUsing os.scandir() method to list files in a Directory\n\nos.scandir() is an efficient version of os.listdir() function. It was later released by Python and is supported for Python 3.5 and greater.\n\nExample: List all files and directories in a directory.\n\nIn this example, the Python script utilizes the os module to list files and directories in the specified path (“C://Users//Vanshi//Desktop//gfg”). It employs os.scandir() to obtain an iterator of os.DirEntry objects representing entries in the directory.\n\nList Files in a Directory Using the Glob Module in Python\n\nThe glob module retrieves files/path names matching a specified pattern. Below are the ways by which we can list files in a directory using the glob module:\n\nUsing the glob() method to get all files in a directory\n\nWith glob.glob, we can use wild cards (“*, ?, [ranges]) to make path retrieval more simple and convenient.\n\nExample: Python file matching and printing using glob() method\n\nUsing iglob() method to list files in a directory\n\niglob() method can be used to print filenames recursively if the recursive parameter is set to True. This is used for big directories as it is more efficient than glob() method.\n\nExample: Print paths matching the specified pattern in a directory.\n\nIn this example, the Python script utilizes the glob module to find and print paths matching the specified pattern (“C:\\Users\\Vanshi\\Desktop\\gfg**\\*.txt”). It employs glob.iglob() to return an iterator, which is then used to print the paths of all text files present in the specified directory and its subdirectories.\n\nThese are the 5 ways you can use to get details of files and directories in a directory. Python has provided multiple built-in methods that you can use to know the files present in a directory. This tutorial showed easy methods with examples to understand how to get file listings with the os module and glob module.\n• None List all files of certain type in a directory using Python\n• None Listing out directories and files in Python\n• None Get list of files in directory with size\n\nHow do we get a list of files in a directory and subfolders in Python?\n\nHow to get a list of files in a directory sorted by name in Python?\n\nHow to get a list of all files in a folder and subfolders into notepad?\n\nHow to list files from a remote directory using Python?\n\nYou can list files from a remote directory using Python, but it typically requires using modules like (for SSH-based access) or libraries that support various protocols like FTP or HTTP. Here’s a simple example using for SSH-based access:\n\nThis example uses to connect to a remote host via SSH, lists files in a specified directory ( ), and returns a list of filenames. Adjust the , , , and variables according to your remote server setup."
    },
    {
        "link": "https://docs.python.org/3/library/os.html",
        "document": "This module provides a portable way of using operating system dependent functionality. If you just want to read or write a file see , if you want to manipulate paths, see the module, and if you want to read all the lines in all the files on the command line see the module. For creating temporary files and directories see the module, and for high-level file and directory handling see the module.\n\nNotes on the availability of these functions:\n• None The design of all built-in operating system dependent modules of Python is such that as long as the same functionality is available, it uses the same interface; for example, the function returns stat information about path in the same format (which happens to have originated with the POSIX interface).\n• None Extensions peculiar to a particular operating system are also available through the module, but using them is of course a threat to portability.\n• None All functions accepting path or file names accept both bytes and string objects, and result in an object of the same type, if a path or file name is returned.\n• None On VxWorks, os.popen, os.fork, os.execv and os.spawn*p* are not supported.\n• None On WebAssembly platforms, Android and iOS, large parts of the module are not available or behave differently. APIs related to processes (e.g. , ) and resources (e.g. ) are not available. Others like and are emulated or stubs. WebAssembly platforms also lack support for signals (e.g. , )."
    },
    {
        "link": "https://freecodecamp.org/news/lambda-sort-list-in-python",
        "document": "The method and the function let you sort iterable data like lists and tuples in ascending or descending order.\n\nThey take parameters with which you can modify how they perform the sorting. And one of those parameters could be a function or even a lambda function.\n\nIn this article, you’ll learn how to sort a list with the lambda function.\n• How to Sort a List in Python\n• How to Sort a List with the Lambda Function\n• How to Lambdasort with the Method\n• How to Lambdasort with the Function\n\nHow to Sort a List in Python\n\nYou can sort a list with the method and function.\n\nThe method takes two parameters – and . You can use a function as the key, but the reverse parameter can only take a Boolean.\n\nIf you specify the value of the reverse parameter as , the method will perform the sorting in descending order. And if you specify as the value of the , the sorting will be in ascending order. You don’t even need to specify false as the value because it’s the default.\n\nBut both parameters are optional, so the method still works fine without them:\n\nThe function, on the other hand, also works like . It takes the optional and parameters too, but it takes a compulsory parameter of the iterable you want to sort – making it ideal for sorting other iterables apart from a list.\n\nAs I pointed out earlier, you can also sort other iterables with the function. This is how I sorted a tuple with the function:\n\nRemember I also pointed out you can pass a function as the value for the key parameter of the method and function. This function can help you be more decisive with the way you want to sort the iterable list or tuple.\n\nFor example, the function and method would only sort by the first part of the string or number. But you can also sort by the second part by passing in a function as the key parameter. It is with this function that you will decide how you want to sort the list or other iterables.\n\nA lambda function would be ideal to do this because it takes one expression. But before we dive into sorting with a lambda function, let me remind you what the lambda function is.\n\nA lambda function is an anonymous function – a function you don’t write with the keyword. A lambda function can take many arguments, but it can only have one expression.\n\nSince you don’t define a lambda function with the keyword, how do you call it? You can assign a lambda function to a variable, then call it by the name of that variable.\n\nIn the example below, the lambda function has 3 arguments and adds them together:\n\nHow to Sort a List with the Lambda Function\n\nYou can “lambda sort” a list with both the method and the function. Let’s look at how to lambda sort with the method first.\n\nHow to Lambdasort with the Method\n\nLet’s take the names we sorted before and sort them by the second name. This lambda function would be ideal in sorting by the second name:\n\nThe lambda function splits a name and takes the second part of the name – the second name. The first part is the first name and it would be .\n\nYou can pass in this lambda function as the key parameter – sorting the names by the second names:\n\nYou can see the names got sorted by the alphabetical order of the second names. came first, and came last. Ann starts with A and Jack starts with J.\n\nIf you want, you can even pass in a function directly. What you need to do is to not call the function. You have to pass it in as an object.\n\nNow, let’s sort the numbers based on their last digits. In case you don’t know, if you use the remainder ( ) operator on two numbers, it divides the two numbers and returns the remainder:\n\nBut if you “mod” a number with multiple digits with 10, it returns the last digit of the number:\n\nThat’s how you can get the second number and sort the numbers based on it.\n\nHere’s how I sorted the numbers from the previous examples with a lambda function:\n\nAs you can see, this lambda function, is responsible for sorting the numbers based on each of the second digits. I passed in the number to the lambda function and got the last digit with . This lambda function runs through each of the numbers and gets their last digits.\n\nIf you want, you can even pass in a function directly as the key:\n\nHow to Lambdasort with the Function\n\nIn this example, we are going to sort a list of tuples using the jersey numbers of some footballers.\n\nThe only difference between the and method is that takes a compulsory iterable and does not.\n\nSo, to lambda sort with the function, all you need to do is pass in the list as the iterable and your lambda function as the key:\n\nThe lambda function that performed the sorting is this . The lambda went through all the tuples in the list, took the second index ( ), and used those to do the sorting.\n\nThis article showed you how to sort a list with the method and function using a lambda function.\n\nBut that was not all. We looked at how both the method and function work on their own without a lambda function. I also reminded you of what the lambda function is, so you could understand how I did the sorting with a lambda function.\n\nThank you for reading!"
    },
    {
        "link": "https://stackoverflow.com/questions/8966538/syntax-behind-sortedkey-lambda",
        "document": "I think all of the answers here cover the core of what the lambda function does in the context of quite nicely, however I still feel like a description that leads to an intuitive understanding is lacking, so here is my two cents.\n\nFor the sake of completeness, I'll state the obvious up front: returns a list of sorted elements and if we want to sort in a particular way or if we want to sort a complex list of elements (e.g. nested lists or a list of tuples) we can invoke the key argument.\n\nFor me, the intuitive understanding of the key argument, why it has to be callable, and the use of lambda as the (anonymous) callable function to accomplish this comes in two parts.\n• Using lamba ultimately means you don't have to write (define) an entire function. Lambda functions are created, used, and immediately destroyed - so they don't funk up your code with more code that will only ever be used once. This, as I understand it, is the core utility of the lambda function and its application for such a role is broad. Its syntax is purely a convention, which is in essence the nature of programmatic syntax in general. Learn the syntax and be done with it.\n\nLambda syntax is as follows:\n• The idea behind the argument is that it should take in a set of instructions that will essentially point the 'sorted()' function at those list elements which should be used to sort by. When it says , what it really means is: As I iterate through the list, one element at a time (i.e. ), I'm going to pass the current element to the function specifed by the key argument and use that to create a transformed list which will inform me on the order of the final sorted list.\n\nNotice that my lambda function told to check if each element was even or odd before sorting.\n\nBUT WAIT! You may (or perhaps should) be wondering two things.\n\nFirst, why are the odd numbers coming before the even numbers? After all, the key value seems to be telling the function to prioritize evens by using the operator in .\n\nSecond, why are the even numbers still out of order? 2 comes before 6, right?\n\nBy analyzing this result, we'll learn something deeper about how the 'key' argument really works, especially in conjunction with the anonymous lambda function.\n\nFirstly, you'll notice that while the odds come before the evens, the evens themselves are not sorted. Why is this?? Lets read the docs:\n\nWe have to do a little bit of reading between the lines here, but what this tells us is that the sort function is only called once, and if we specify the key argument, then we sort by the value that key function points us to.\n\nSo what does the example using a modulo return? A boolean value: , . So how does sorted deal with this key? It basically transforms the original list to a sequence of 1s and 0s.\n\nNow we're getting somewhere. What do you get when you sort the transformed list?\n\nOkay, so now we know why the odds come before the evens. But the next question is: Why does the 6 still come before the 2 in my final list? Well that's easy - it is because sorting only happens once! Those 1s still represent the original list values, which are in their original positions relative to each other. Since sorting only happens once, and we don't call any kind of sort function to order the original even numbers from low to high, those values remain in their original order relative to one another.\n\nThe final question is then this: How do I think conceptually about how the order of my boolean values get transformed back in to the original values when I print out the final sorted list?\n\nis a built-in method that (fun fact) uses a hybrid sorting algorithm called Timsort that combines aspects of merge sort and insertion sort. It seems clear to me that when you call it, there is a mechanic that holds these values in memory and bundles them with their boolean identity (mask) determined by (...!) the lambda function. The order is determined by their boolean identity calculated from the lambda function, but keep in mind that these sublists (of one's and zeros) are not themselves sorted by their original values. Hence, the final list, while organized by Odds and Evens, is not sorted by sublist (the evens in this case are out of order). The fact that the odds are ordered is because they were already in order by coincidence in the original list. The takeaway from all this is that when lambda does that transformation, the original order of the sublists are retained.\n\nSo how does this all relate back to the original question, and more importantly, our intuition on how we should implement with its key argument and lambda?\n\nThat lambda function can be thought of as a pointer that points to the values we need to sort by, whether its a pointer mapping a value to its boolean transformed by the lambda function, or if its a particular element in a nested list, tuple, dict, etc., again determined by the lambda function.\n\nLets try and predict what happens when I run the following code.\n\nMy call obviously says, \"Please sort this list\". The key argument makes that a little more specific by saying, 'for each element in , return the second index of that element, then sort all of the elements of the original list by the sorted order of the list calculated by the lambda function. Since we have a list of tuples, we can return an indexed element from that tuple using the lambda function.\n\nThe pointer that will be used to sort would be:\n\nApplying this to , we get:\n\nRun that code, and you'll find that this is the order. Try sorting a list of integers using this key function and you'll find that the code breaks (why? Because you cannot index an integer of course).\n\nThis was a long winded explanation, but I hope this helps to your intuition on the use of functions - as the key argument in , and beyond."
    },
    {
        "link": "https://stackoverflow.com/questions/3766633/how-to-sort-with-lambda-in-python",
        "document": "You're trying to use key functions with lambda functions.\n\nPython and other languages like C# or F# use lambda functions.\n\nAlso, when it comes to key functions and according to the documentation\n\nBoth list.sort() and sorted() have a key parameter to specify a function to be called on each list element prior to making comparisons. The value of the key parameter should be a function that takes a single argument and returns a key to use for sorting purposes. This technique is fast because the key function is called exactly once for each input record.\n\nSo, key functions have a parameter key and it can indeed receive a lambda function.\n\nIn Real Python there's a nice example of its usage. Let's say you have the following list\n\nand want to sort through its \"integers\". Then, you'd do something like\n\nand printing it would give\n\nIn your particular case, you're only missing to write before lambda. So, you'd want to use the following"
    },
    {
        "link": "https://reddit.com/r/pythontips/comments/1bk1obq/using_the_sorted_function_with_a_custom_key_to",
        "document": "Suppose you have a list of strings, and you want to sort them based on their length.\n\nYou can do this:\n\nThe argument is set to the function, which returns the length of each string."
    },
    {
        "link": "https://docs.python.org/3/howto/sorting.html",
        "document": "Python lists have a built-in method that modifies the list in-place. There is also a built-in function that builds a new sorted list from an iterable.\n\nIn this document, we explore the various techniques for sorting data using Python.\n\nA simple ascending sort is very easy: just call the function. It returns a new sorted list: You can also use the method. It modifies the list in-place (and returns to avoid confusion). Usually it’s less convenient than - but if you don’t need the original list, it’s slightly more efficient. Another difference is that the method is only defined for lists. In contrast, the function accepts any iterable.\n\nBoth and have a key parameter to specify a function (or other callable) to be called on each list element prior to making comparisons. \"This is a test string from Andrew\" ['a', 'Andrew', 'from', 'is', 'string', 'test', 'This'] The value of the key parameter should be a function (or other callable) that takes a single argument and returns a key to use for sorting purposes. This technique is fast because the key function is called exactly once for each input record. A common pattern is to sort complex objects using some of the object’s indices as keys. For example: The same technique works for objects with named attributes. For example: Objects with named attributes can be made by a regular class as shown above, or they can be instances of or a named tuple.\n\nThe key function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster. The module has , , and a function. Using those functions, the above examples become simpler and faster: The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age: The module provides another helpful tool for making key-functions. The function can reduce the arity of a multi-argument function making it suitable for use as a key-function.\n\nSorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. Notice how the two records for blue retain their original order so that is guaranteed to precede . This wonderful property lets you build complex sorts in a series of sorting steps. For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: This can be abstracted out into a wrapper function that can take a list and tuples of field and order to sort them on multiple passes. The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset.\n\nThis idiom is called Decorate-Sort-Undecorate after its three steps:\n• None First, the initial list is decorated with new values that control the sort order.\n• None Second, the decorated list is sorted.\n• None Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list, but including it gives two benefits:\n• None The sort is stable – if two items have the same key, their order will be preserved in the sorted list.\n• None The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. Now that Python sorting provides key-functions, this technique is not often needed.\n\nUnlike key functions that return an absolute value for sorting, a comparison function computes the relative ordering for two inputs. For example, a balance scale compares two samples giving a relative ordering: lighter, equal, or heavier. Likewise, a comparison function such as will return a negative value for less-than, zero if the inputs are equal, or a positive value for greater-than. It is common to encounter comparison functions when translating algorithms from other languages. Also, some libraries provide comparison functions as part of their API. For example, is a comparison function. To accommodate those situations, Python provides to wrap the comparison function to make it usable as a key function:\n• None For locale aware sorting, use for a key function or for a comparison function. This is necessary because “alphabetical” sort orderings can vary across cultures even if the underlying alphabet is the same.\n• None The reverse parameter still maintains sort stability (so that records with equal keys retain the original order). Interestingly, that effect can be simulated without the parameter by using the builtin function twice:\n• None The sort routines use when making comparisons between two objects. So, it is easy to add a standard sort order to a class by defining an method: However, note that can fall back to using if is not implemented (see for details on the mechanics). To avoid surprises, PEP 8 recommends that all six comparison methods be implemented. The decorator is provided to make that task easier.\n• None Key functions need not depend directly on the objects being sorted. A key function can also access external resources. For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names:"
    }
]