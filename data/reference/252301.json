[
    {
        "link": "https://requests.readthedocs.io",
        "document": "Requests is an elegant and simple HTTP library for Python, built for human beings.\n\nRequests allows you to send HTTP/1.1 requests extremely easily. There’s no need to manually add query strings to your URLs, or to form-encode your POST data. Keep-alive and HTTP connection pooling are 100% automatic, thanks to urllib3."
    },
    {
        "link": "https://realpython.com/python-requests",
        "document": "The Requests library is the de facto standard for making HTTP requests in Python. It abstracts the complexities of making requests behind a beautiful, simple API so that you can focus on interacting with services and consuming data in your application.\n\nThroughout this tutorial, you’ll see some of the most useful features that Requests has to offer as well as ways to customize and optimize those features for different situations that you may come across. You’ll also learn how to use Requests in an efficient way as well as how to prevent requests to external services from slowing down your application.\n\nIn this tutorial, you’ll learn how to:\n• Make requests using the most common HTTP methods\n• Customize your requests’ headers and data using the query string and message body\n• Inspect data from your requests and responses\n• Configure your requests to help prevent your application from backing up or slowing down\n\nFor the best experience working through this tutorial, you should have basic general knowledge of HTTP. That said, you still may be able to follow along fine without it.\n\nIn the upcoming sections, you’ll see how you can install and use in your application. If you want to play with the code examples that you’ll see in this tutorial, as well as some additional ones, then you can download the code examples and work with them locally:\n\nEven though the Requests library is a common staple for many Python developers, it’s not included in Python’s standard library. There are good reasons for that decision, primarily that the library can continue to evolve more freely as a self-standing project. Note: Requests doesn’t support asynchronous HTTP requests directly. If you need async support in your program, you should try out AIOHTTP or HTTPX. The latter library is broadly compatible with Requests’ syntax. Because Requests is a third-party library, you need to install it before you can use it in your code. As a good practice, you should install external packages into a virtual environment, but you may choose to install into your global environment if you’re planning to use it across multiple projects. Whether you’re working in a virtual environment or not, you’ll need to install : Once has finished installing , you can use it in your application. Importing looks like this: Now that you’re all set up, it’s time to begin your journey through Requests. Your first goal will be learning how to make a request.\n\nA is a powerful object for inspecting the results of the request. Make that same request again, but this time store the return value in a variable so that you can get a closer look at its attributes and behaviors: In this example, you’ve captured the return value of , which is an instance of , and stored it in a variable called . You can now use to see a lot of information about the results of your request. The first bit of information that you can gather from is the status code. A status code informs you of the status of the request. For example, a status means that your request was successful, whereas a status means that the resource you were looking for wasn’t found. There are many other possible status codes as well to give you specific insights into what happened with your request. By accessing , you can see the status code that the server returned: returned , which means that your request was successful and the server responded with the data that you were requesting. Sometimes, you might want to use this information to make decisions in your code: With this logic, if the server returns a status code, then your program will print . If the result is a , then your program will print . Requests goes one step further in simplifying this process for you. If you use a instance in a conditional expression, then it’ll evaluate to if the status code was smaller than , and otherwise. Therefore, you can simplify the last example by rewriting the statement: In the code snippet above, you implicitly check whether the of is between and . If it’s not, then you raise an exception that includes the non-success status code in an f-string. Note: This truth value test is possible because is an overloaded method on . This means that the adapted default behavior of takes the status code into account when determining the truth value of the object. Keep in mind that this method is not verifying that the status code is equal to . The reason for this is that other status codes within the to range, such as and , are also considered successful in the sense that they provide some workable response. For example, the status code tells you that the response was successful, but there’s no content to return in the message body. So, make sure you use this convenient shorthand only if you want to know if the request was generally successful. Then, if necessary, you’ll need to handle the response appropriately based on the status code. Let’s say you don’t want to check the response’s status code in an statement. Instead, you want to use Request’s built-in capacities to raise an exception if the request was unsuccessful. You can do this using : If you invoke , then Requests will raise an for status codes between and . If the status code indicates a successful request, then the program will proceed without raising that exception. Now, you know a lot about how to deal with the status code of the response that you got back from the server. However, when you make a request, you rarely only care about the status code of the response. Usually, you want to see more. Next, you’ll see how to view the actual data that the server sent back in the body of the response. The response of a request often has some valuable information, known as a payload, in the message body. Using the attributes and methods of , you can view the payload in a variety of different formats. To see the response’s content in , you use : While gives you access to the raw bytes of the response payload, you’ll often want to convert them into a string using a character encoding such as UTF-8. will do that for you when you access : Because the decoding of to a requires an encoding scheme, Requests will try to guess the encoding based on the response’s headers if you don’t specify one. You can provide an explicit encoding by setting before accessing : If you take a look at the response, then you’ll see that it’s actually serialized JSON content. To get a dictionary, you could take the that you retrieved from and deserialize it using . However, a simpler way to accomplish this task is to use : The of the return value of is a dictionary, so you can access values in the object by key: You can do a lot with status codes and message bodies. But, if you need more information, like metadata about the response itself, then you’ll need to look at the response’s headers. The response headers can give you useful information, such as the content type of the response payload and a time limit on how long to cache the response. To view these headers, access : returns a dictionary-like object, allowing you to access header values by key. For example, to see the content type of the response payload, you can access : There’s something special about this dictionary-like headers object, though. The HTTP specification defines headers as case-insensitive, which means that you’re able to access these headers without worrying about their capitalization: Whether you use the key or , you’ll get the same value. Now that you’ve seen the most useful attributes and methods of in action, you already have a good overview of Requests’ basic usage. You can get content from the Internet and work with the response that you receive. But there’s more to the Internet than plain and straightforward URLs. In the next section, you’ll take a step back and see how your responses change when you customize your requests to account for query string parameters.\n\nAccording to the HTTP specification, , , and the less common requests pass their data through the message body rather than through parameters in the query string. Using Requests, you’ll pass the payload to the corresponding function’s parameter. takes a dictionary, a list of tuples, bytes, or a file-like object. You’ll want to adapt the data that send in the body of your request to the specific needs of the service that you’re interacting with. For example, if your request’s content type is , then you can send the form data as a dictionary: You can also send that same data as a list of tuples: If, however, you need to send JSON data, then you can use the parameter. When you pass JSON data via , Requests will serialize your data and add the correct header for you. Like you learned earlier, the httpbin service accepts test requests and responds with data about the requests. For instance, you can use it to inspect a basic request: You can see from the response that the server received your request data and headers as you sent them. Requests also provides this information to you in the form of a that you’ll inspect in more detail in the next section.\n\nAuthentication helps a service understand who you are. Typically, you provide your credentials to a server by passing data through the header or a custom header defined by the service. All the functions of Requests that you’ve seen to this point provide a parameter called , which allows you to pass your credentials: The request succeeds if the credentials that you pass in the tuple to are valid. When you pass your credentials in a tuple to the parameter, Requests applies the credentials using HTTP’s Basic access authentication scheme under the hood. You may wonder where the string that Requests set as the value for your header comes from. In short, it’s a Base64-encoded string of the username and password with the prefix :\n• First, Requests combines the username and password that you provided, putting a colon in between them. So for the username and password , this becomes .\n• Then, Requests encodes this string in Base64 using . The encoding converts the string to .\n• Finally, Requests adds in front of this Base64 string. This is how the final value for the header becomes in the example shown above. HTTP Basic authentication isn’t very secure, because you can decode the username and password from the Base64 string. That’s why it’s important to always send these requests over HTTPS, which provides an additional layer of security by encrypting the entire HTTP request. You could make the same request by passing explicit Basic authentication credentials using : Though you don’t need to be explicit for Basic authentication, you may want to authenticate using another method. Requests provides other methods of authentication out of the box, such as and . A real-world example of an API that requires authentication is GitHub’s authenticated user API. This endpoint provides information about the authenticated user’s profile. If you try to make a request without credentials, then you’ll see that the status code is : If you don’t provide authentication credentials when accessing a service that requires them, then you’ll get an HTTP error code as a response. To make a request to GitHub’s authenticated user API, you first need to generate a personal access token with the read:user scope. Then you can pass this token as the second element in a tuple to : Like you learned previously, this approach passes the credentials to , which expects a username and a password and sends the credentials as a Base64-encoded string with the prefix : This works, but it’s not the right way to authenticate with a Bearer token—and using an empty string input for the superfluous username is awkward. With Requests, you can supply your own authentication mechanism to fix that. To try this out, create a subclass of and implement : \"\"\"Attach an API token to the Authorization header.\"\"\" Here, your custom mechanism receives a token, then includes that token in the header of your request, also setting the recommended prefix to the string. You can now use this custom token authentication to make your call to GitHub’s authenticated user API: Your custom created a well-formatted string for the header. You can now use this more intuitive way of interacting with a token-based authentication scheme such as the one that parts of GitHub’s API require. Note: While you could construct the authentication string outside of a custom authentication class and pass it directly with , this appoach is discouraged because it can lead to unexpected behavior. When you attempt to set your authentication credentials directly using , then Requests may internally overwrite your input. This can happen, for example, if you have a file that provides authentication credentials. Requests will attempt to get the credentials from the file if you don’t provide an authentication method using . Bad authentication mechanisms can lead to security vulnerabilities. Unless a service requires a custom authentication mechanism for some reason, you’ll always want to use a tried-and-true auth scheme like the built-in Basic authentication or OAuth, for example through Requests-OAuthlib. While you’re thinking about security, consider dealing with SSL certificates using Requests.\n\nAnytime the data that you’re trying to send or receive is sensitive, security is important. The way that you communicate with secure sites over HTTP is by establishing an encrypted connection using SSL, which means that verifying the target server’s SSL certificate is critical. The good news is that Requests does this for you by default. However, there are some cases where you might want to change this behavior. If you want to disable SSL certificate verification, then you pass to the parameter of the request function: InsecureRequestWarning: Unverified HTTPS request is being made to host Requests even warns you when you’re making an insecure request to help you keep your data safe! Note: Requests uses a package called to provide certificate authorities. This lets Requests know which authorities it can trust. Therefore, you should update frequently to keep your connections as secure as possible. Now that you know how to make all sorts of HTTP requests using Requests, authenticated or not, you may wonder about how you can make sure that your program works as quickly as possible. In the next section, you’ll learn about a few ways that you can improve performance with the help of Requests.\n\nWhen using Requests, especially in a production application environment, it’s important to consider performance implications. Features like timeout control, sessions, and retry limits can help you keep your application running smoothly. When you make an inline request to an external service, your system will need to wait for the response before moving on. If your application waits too long for that response, requests to your service could back up, your user experience could suffer, or your background jobs could hang. By default, Requests will wait indefinitely on the response, so you should almost always specify a timeout duration to prevent these issues from happening. To set the request’s timeout, use the parameter. can be an integer or float representing the number of seconds to wait on a response before timing out: In the first request, the request will time out after 1 second. In the second request, the request will time out after 3.05 seconds. You can also pass a tuple to with the following two elements:\n• Connect timeout: The time it allows for the client to establish a connection to the server\n• Read timeout: The time it’ll wait on a response once your client has established a connection Both of these elements should be numbers, and can be of type or : If the request establishes a connection within 3.05 seconds and receives data within 5 seconds of the connection being established, then the response will be returned as it was before. If the request times out, then the function will raise a exception: \"The request did not time out\" Your program can catch the exception and respond accordingly. Until now, you’ve been dealing with high-level APIs such as and . These functions are abstractions of what’s going on when you make your requests. They hide implementation details, such as how connections are managed, so that you don’t have to worry about them. Underneath those abstractions is a class called . If you need to fine-tune your control over how requests are being made or improve the performance of your requests, you may need to use a instance directly. Sessions are used to persist parameters across requests. For example, if you want to use the same authentication across multiple requests, then you can use a session: In this code example, you use a context manager to ensure that the session releases the resources when it doesn’t need them anymore. In line 7, you log in using your custom . You only need to log in once per session, and then you can make multiple authenticated requests. Requests will persist the credentials while the session exists. You then make two requests to the authenticated user API in lines 9 and 10 using instead of . The primary performance optimization of sessions comes in the form of persistent connections. When your app makes a connection to a server using a , it keeps that connection around in a connection pool. When your app wants to connect to the same server again, it’ll reuse a connection from the pool rather than establishing a new one. When a request fails, you may want your application to retry the same request. However, Requests won’t do this for you by default. To apply this functionality, you need to implement a custom transport adapter. Transport adapters let you define a set of configurations for each service that you’re interacting with. For example, say you want all requests to to retry two times before finally raising a . You’d build a transport adapter, set its parameter, and mount it to an existing : In this example, you’ve set up your session so that it’ll retry a maximum of two times when your request to GitHub’s API doesn’t work as expected. When you mount the —in this case, —to , then will adhere to its configuration for each request to . Note: While the implementation shown above works, you won’t see any effect of the retry behavior unless there’s something wrong with your network connection or GitHub’s servers. If you want to play around with code that builds on top of this example, and you’d like to inspect when the retries happen, then you’re in luck. You can download the materials of this tutorial and take a look at : Get Your Code: Click here to download the free sample code that shows you how to use Python’s Requests library. The code in this file improves on the example shown above by using the underlying to further customize the retry functionality. It also adds logging to display debugging output, which gives you a chance to monitor when Python attempted the retries. Requests comes packaged with intuitive implementations for timeouts, transport adapters, and sessions that can help you keep your code efficient and your application resilient."
    },
    {
        "link": "https://requests.readthedocs.io/en/master/user/quickstart",
        "document": "Eager to get started? This page gives a good introduction in how to get started with Requests.\n\nFirst, make sure that:\n\nLet’s get started with some simple examples.\n\nMaking a request with Requests is very simple. Now, let’s try to get a webpage. For this example, let’s get GitHub’s public timeline: Now, we have a object called . We can get all the information we need from this object. Requests’ simple API means that all forms of HTTP request are as obvious. For example, this is how you make an HTTP POST request: Nice, right? What about the other HTTP request types: PUT, DELETE, HEAD and OPTIONS? These are all just as simple: That’s all well and good, but it’s also only the start of what Requests can do.\n\nYou often want to send some sort of data in the URL’s query string. If you were constructing the URL by hand, this data would be given as key/value pairs in the URL after a question mark, e.g. . Requests allows you to provide these arguments as a dictionary of strings, using the keyword argument. As an example, if you wanted to pass and to , you would use the following code: You can see that the URL has been correctly encoded by printing the URL: Note that any dictionary key whose value is will not be added to the URL’s query string. You can also pass a list of items as a value:\n\nWe can read the content of the server’s response. Consider the GitHub timeline again: Requests will automatically decode content from the server. Most unicode charsets are seamlessly decoded. When you make a request, Requests makes educated guesses about the encoding of the response based on the HTTP headers. The text encoding guessed by Requests is used when you access . You can find out what encoding Requests is using, and change it, using the property: If you change the encoding, Requests will use the new value of whenever you call . You might want to do this in any situation where you can apply special logic to work out what the encoding of the content will be. For example, HTML and XML have the ability to specify their encoding in their body. In situations like this, you should use to find the encoding, and then set . This will let you use with the correct encoding. Requests will also use custom encodings in the event that you need them. If you have created your own encoding and registered it with the module, you can simply use the codec name as the value of and Requests will handle the decoding for you.\n\nThere’s also a builtin JSON decoder, in case you’re dealing with JSON data: In case the JSON decoding fails, raises an exception. For example, if the response gets a 204 (No Content), or if the response contains invalid JSON, attempting raises . This wrapper exception provides interoperability for multiple exceptions that may be thrown by different python versions and json serialization libraries. It should be noted that the success of the call to does not indicate the success of the response. Some servers may return a JSON object in a failed response (e.g. error details with HTTP 500). Such JSON will be decoded and returned. To check that a request is successful, use or check is what you expect.\n\nIn the rare case that you’d like to get the raw socket response from the server, you can access . If you want to do this, make sure you set in your initial request. Once you do, you can do this: In general, however, you should use a pattern like this to save what is being streamed to a file: Using will handle a lot of what you would otherwise have to handle when using directly. When streaming a download, the above is the preferred and recommended way to retrieve the content. Note that can be freely adjusted to a number that may better fit your use cases. An important note about using versus . will automatically decode the and transfer-encodings. is a raw stream of bytes – it does not transform the response content. If you really need access to the bytes as they were returned, use .\n\nIf you’d like to add HTTP headers to a request, simply pass in a to the parameter. For example, we didn’t specify our user-agent in the previous example: Note: Custom headers are given less precedence than more specific sources of information. For instance:\n• None Authorization headers set with will be overridden if credentials are specified in , which in turn will be overridden by the parameter. Requests will search for the netrc file at , , or at the path specified by the environment variable.\n• None Authorization headers will be removed if you get redirected off-host.\n• None Proxy-Authorization headers will be overridden by proxy credentials provided in the URL.\n• None Content-Length headers will be overridden when we can determine the length of the content. Furthermore, Requests does not change its behavior at all based on which custom headers are specified. The headers are simply passed on into the final request. Note: All header values must be a , bytestring, or unicode. While permitted, it’s advised to avoid passing unicode header values.\n\nTypically, you want to send some form-encoded data — much like an HTML form. To do this, simply pass a dictionary to the argument. Your dictionary of data will automatically be form-encoded when the request is made: The argument can also have multiple values for each key. This can be done by making either a list of tuples or a dictionary with lists as values. This is particularly useful when the form has multiple elements that use the same key: There are times that you may want to send data that is not form-encoded. If you pass in a instead of a , that data will be posted directly. For example, the GitHub API v3 accepts JSON-Encoded POST/PATCH data: Please note that the above code will NOT add the header (so in particular it will NOT set it to ). If you need that header set and you don’t want to encode the yourself, you can also pass it directly using the parameter (added in version 2.4.2) and it will be encoded automatically: Note, the parameter is ignored if either or is passed.\n\nYou can set the filename, content_type and headers explicitly: If you want, you can send strings to be received as files: In the event you are posting a very large file as a request, you may want to stream the request. By default, does not support this, but there is a separate package which does - . You should read the toolbelt’s documentation for more details about how to use it. For sending multiple files in one request refer to the advanced section. It is strongly recommended that you open files in binary mode. This is because Requests may attempt to provide the header for you, and if it does this value will be set to the number of bytes in the file. Errors may occur if you open the file in text mode.\n\nWe can view the server’s response headers using a Python dictionary: The dictionary is special, though: it’s made just for HTTP headers. According to RFC 7230, HTTP Header names are case-insensitive. So, we can access the headers using any capitalization we want: It is also special in that the server could have sent the same header multiple times with different values, but requests combines them so they can be represented in the dictionary within a single mapping, as per RFC 7230: A recipient MAY combine multiple header fields with the same field name into one “field-name: field-value” pair, without changing the semantics of the message, by appending each subsequent field value to the combined field value in order, separated by a comma.\n\nYou can tell Requests to stop waiting for a response after a given number of seconds with the parameter. Nearly all production code should use this parameter in nearly all requests. Failure to do so can cause your program to hang indefinitely: is not a time limit on the entire response download; rather, an exception is raised if the server has not issued a response for seconds (more precisely, if no bytes have been received on the underlying socket for seconds). If no timeout is specified explicitly, requests do not time out.\n\nIn the event of a network problem (e.g. DNS failure, refused connection, etc), Requests will raise a exception. will raise an if the HTTP request returned an unsuccessful status code. If a request times out, a exception is raised. If a request exceeds the configured number of maximum redirections, a exception is raised. All exceptions that Requests explicitly raises inherit from . Ready for more? Check out the advanced section."
    },
    {
        "link": "https://w3schools.com/python/ref_requests_post.asp",
        "document": "The method sends a POST request to the specified url.\n\nThe method is used when you want to send some data to the server.\n\nargs means zero or more of the named arguments in the parameter table below. Example:"
    },
    {
        "link": "https://scrapfly.io/blog/how-to-python-requests-post",
        "document": "How to Find All URLs on a Domain\n\nLearn how to efficiently find all URLs on a domain using Python and web crawling. Guide on how to crawl entire domain to collect all website data"
    },
    {
        "link": "https://devforum.roblox.com/t/accessing-the-roblox-api-the-comprehensive-tutorial/1161932",
        "document": "The Roblox API is extremely powerful - it can be used to create anything from group ranking bots to game statistics websites.\n\nAs a developer, there are two main ways you’ll want to access the Roblox API: sending the requests yourself or using one of the multiple wrappers for your favorite programming language. In this tutorial, I’ll go over both of these methods.\n\nIf you don’t feel like sending the requests yourself, multiple “wrapper libraries” exist that allow you to stop handling the boilerplate Roblox API code and start writing code that does what you want it to do in less time. These libraries have their own tutorials - feel free to use those rather than this one if you don’t want to deal with sending the requests yourself.\n\nThey can also allow you to have the freedom of sending your own requests without forcing you to deal with the Roblox API’s quirks. I’ve got a post explaining how to do this with ro.py, but other libraries have their own systems of doing this.\n\nIf you decide to use one of these libraries, most of this tutorial won’t be useful for you, so you should refer to documentation or tutorials for your own library. If you’re sending requests with your library, the Finding endpoints and Understanding documentation sections may be useful.\n\nHere’s a list of some of these libraries:\n\nThe first thing you’ll need to know when accessing the API is what endpoint you’ll need to do something. Try to stay away from endpoints on api.roblox.com or www.roblox.com - there are almost always better alternatives in subdomains.\n\nYou should also keep track of the official list of deprecated web endpoints for updates on when endpoints are disabled.\n\nRoblox has a “consolidated page” that contains most domains and endpoints that you can use to find the endpoint you need at https://api.roblox.com/docs?useConsolidatedPage=true. You can also access the documentation for an individual domain by appending /docs to the end of it (e.g. users.roblox.com > users.roblox.com/docs)\n\n@matthewdean has a list of Roblox subdomains available here which can be used as an alternative to the consolidated page. @juliaoverflow has a modified version of this list that you can access here if you’re having trouble finding what you’re looking for.\n\nSome domains don’t have documentation available, like realtime.roblox.com. For these endpoints, there’s not much you can do besides looking at the source code of other wrapper libraries or spying on the requests the Roblox website makes with your browser’s developer tools.\n\nEach documentation page contains a list of public endpoints available on that domain and lots of information about how to use them. Documentation for a single endpoint will look something like this:\n\nThe text in top left hand corner and the background color differ depending on the method of the request, most often GET or POST.\n\nThe Example Value contains an example of what the response from this endpoint might look like - this is useful when you want to build code that requests to an endpoint without sending a request to it yourself to figure out how it responds.\n\nThe Response Content Type determines what should be passed to the header - there’s almost never any reason to change this.\n\nThe Parameters change what data is passed to the endpoint when sending the request. The data is passed as a query string or as part of the URL for GET requests and is passed as a JSON body in almost all other requests.\n\nThe Response Messages will explain what different HTTP Status Codes mean when returned from the server - if you’re getting an error without enough information, you can check the response messages to see if that status code means something for that endpoint.\n\nThe “Try it out!” button will send a request to this endpoint with the data supplied in the Parameters. This will be useful for testing out an endpoint without writing code to send requests.\n\nHere’s an example of an endpoint’s POST documentation:\n\nThis one looks a little different - as you can see, we’ve got a parameter labeled , which just refers to the body of the request, as you can see from the “Parameter Type” to the right of it.\n\nWe also are able to change that data’s content type - you’ll almost always want to keep this on given most endpoints accept JSON.\n\nYou’ll also see an “Example Value” - this shows you an example of data you can pass as the request body. Clicking on that Example Value will immediately set the body to the example data:\n\nThis is extremely useful for quickly testing an endpoint before implementing it into your program.\n\nAt this point, you’re ready to use most of the endpoints that take in GET requests on these domains, as they won’t require authentication, like users.roblox.com/v1/users/userId. This endpoint returns response data that looks like this.\n\nYou’ll probably use this endpoint along with other endpoints on users.roblox.com quite a lot, as they are extremely useful for grabbing information about a user.\n\nHere’s an example of an error returned from the users.roblox.com/v1/users/userId endpoint:\n\nAs you can see, it’s an list containing objects with a , , and . The is an identifier used for an error on an endpoint. The is information about the error intended for the developer, and the is information about the error indented for the user. It isn’t always present and often isn’t as informative as the .\n\nWe can use this code along with the HTTP response code ( ) and the endpoint’s Response Messages from the documentation to find more information:\n\nIn this case, it’s just telling us what we already know from the .\n\nThere are many cases where the API just doesn’t give us useful information, like this:\n\nIn this case, we don’t get much information - the best we can do is use the documentation to try to figure out what’s wrong here.\n\nWe can only do so much without authenticating, though. Authenticating will allow us to send API requests as a logged-in user, which will allow you to write bots that can modify content on the Roblox platform (for example, ranking a user in a group). To do this, we need to get our .ROBLOSECURITY cookie.\n\nThe .ROBLOSECURITY cookie is a session token, which means that as soon as you log out with the Settings > Logout button you’ll invalidate this .ROBLOSECURITY token and your program will no longer be authenticated. I recommend using an alternate account while messing around with the Roblox API as to not accidentally do something irreversible on your main account.\n\nAs we’re now sending requests with cookies, it’s easier for us to use a “session” object that maintains our cookies on each new request. Your programming language of choice may not support a “session object”. Requests also allows us to save time by passing a dictionary containing cookies rather than passing a header. Due to the fact that your own requests library of choice may differ in features from my own, I’ll demonstrate the same thing with a cookie dictionary, a header, and a session.\n\nAt this point, we’re now authenticated - but there’s one thing missing. If we try to send a POST request, you’ll notice that the request still fails.\n\nThis code will output the following:\n\nThe status code is returned when the client is not permitted access to the resource despite providing authentication such as insufficient permissions of the authenticated account.\n\nIf you saw this while trying to write your own code to access the API, you might ask “why is this error coming up? My .ROBLOSECURITY token is correct, and it worked when I used the “Try it out!” button on the documentation page.”\n\nThe truth is that this error message isn’t referring to “token” as in your .ROBLOSECURITY token - it’s actually referring to a header that you have to supply to all requests that change data called the .\n\nTo handle this token, each time we send a request, we’ll save the - which is present in the response headers - to a value. Then, if the request failed with a status code of 403, we’ll send the request again with the we just got the first request as a request header.\n\nWith the Session object, we can just store the token in the dictionary, but you can pass them directly to each request as well.\n\nHere’s an example of that:\n\nThis program will send one request, check if the was present in the response, and if so will store it back into the session’s headers. We then repeat the first request again, and then outputs the status codes from both requests.\n\nThis code should output the following:\n\nThis solution works - but it doesn’t scale well. If we want to properly do this, we’ll put all of this logic in a function that handles our requests for us and then call that when sending requests. This is (essentially) what the request wrappers in Roblox API wrapper libraries do.\n\nHere’s an example of a function that wraps the function:\n\nNow that we’ve done this, it makes it marginally easier to send requests to the API.\n\nAt this point, you’re ready to roam free and send requests to the API yourself. I hope you found this tutorial informative, and if you have any more questions or have anything I should add, please reply to this post or send me a direct message."
    },
    {
        "link": "https://devforum.roblox.com/t/roblox-api-code-403-token-validation-failed-when-using-the-group-join-request-user-api-with-python/700127",
        "document": "Hello there. As you can probably guess from the title, this is an API problem that I am having. I am using Python and after trying to use the group join request user API, I have been getting the 403 (code 0) “Token Validation Failed” error. If it helps to know, I am using a cookie to perform this action. The cookie is valid since I’ve used it with other APIs, but I am getting this error on this one only. I am not too sure how to fix this since the API docs don’t give much information about it. The code I am using is:\n\nIf you are wondering, yes, the group ID is valid, yes, the account has permission to change ranks, and yes, the cookie is valid too.\n\nI do not know if this is caused because the account has 2FA on, but I’ve tested it with another account which does not and it still gives me the same error. I am really confused on what I’m supposed to do here to fix it, nor could I find another post (one was unanswered and the other was about another API and it was a whole different process from what I could see). If you could help me, that would be amazing. Thank you for your time and help."
    },
    {
        "link": "https://create.roblox.com/docs/cloud/auth/api-keys",
        "document": "Open Cloud authenticates and authorizes API access with the use of API keys, which allow you to add granular permissions and security control for accessing and utilizing certain resources in your experience, such as data stores and places.\n\nAll Open Cloud APIs require you to create an API key with valid permissions and include an x-api-key header in your request, which allows the application to authenticate to Open Cloud on your behalf.\n\nYou can create and configure API keys for your individually-owned experiences or group-owned experiences (A Roblox group allows multiple creators to work on the same experience, use the same assets, and share API keys).\n\nYou must be the group owner or assigned to a role within the group that has the API key admin permission in order to create an API key for your group. A group member can only create an API key with the same resource access permissions of their role. For example, only group members with the Create and edit group experiences permission can create an API key that can publish a place file.\n• None (Optional) Click the Creator Hub dropdown to select a group if you are creating the API key for a group.\n• None Enter a unique name for your API key. Use a name that can help you recall the purpose later, such as PLACE_PUBLISHING_KEY for publishing places to your experience.\n• None In the Access Permissions section, select an API from the Select API System menu and click the Add API System button. Repeat this step if you need to add multiple APIs to the key.\n• None Select the experience that you want to access with the API key.\n• None From the Experience Operations dropdown, select the operations that you want to enable for the API key. Many operations in the API reference include the required permission scopes. For example, the flush memory store operation requires the universe.memory-store:flush permission. For security reasons, give each API key the minimum number of required permissions. If an API key leaks, this principle of least privilege ensures that only a subset of your resources are compromised.\n• None In the Security section, explicitly set IP access to the key using CIDR notation, otherwise you can't use the API key. You can find the IP address of your local machine and add it to the Accepted IP Addresses section along with additional IP addresses for those that need access. If you don't have a fixed IP, or you are using the API key only in a local environment, you can just add 0.0.0.0/0 to the Accepted IP Addresses section to allow any IPs to use your API key.\n• None (Optional): To add additional protection for your resources, set an explicit expiration date so your key automatically stops working after that date.\n• None Copy and save the API key string to a secure location that is not a public repository of your code.\n• None Check your created API key on the API Extensions page of Creator Dashboard.\n\nGroup owners can manage group-owned API key permissions for group members to have different levels of control of API keys based on the roles and permissions within the group. There are also situations that automatically revoke API key management permissions for group members.\n\nAs a group owner, you can grant the Manage all API keys permission to roles within your group. Members with this permission have all the permissions that a group owner has for API keys, including the ability to create, view, edit, revoke, and audit all of the group's API keys.\n\nYou can also grant the Manage own API keys permission to roles within your group. This allows members to only create and view keys owned by them rather than being able to manage others' keys.\n\nThere are multiple situations that automatically revoke a group member's permission to manage group API keys:\n• None The member is assigned to a different role that doesn't have the permission. This can happen during a transfer of the group ownership.\n• None The member's permission is disabled on their currently assigned role.\n• None The member leaves or is removed from the group.\n• None The member's account is under moderation by Roblox.\n\nIn any of these cases, API keys generated by that user are given the Revoked status. To use these keys again, the group owner or a member with the Manage all API keys permission must regenerate the keys.\n\nTo further protect your resources, when creating an API key, specify IP addresses that can access the API key with either normal IP addresses or using the CIDR notation. A CIDR IP address looks like a normal IP address except it ends with a slash and a decimal that represents how many bits of the IP address are significant for network routing:\n\nThe former part is the IP address and the latter part is the netmask, counting the bits of 1s in binary format. In the previous example, 24 means 255.255.255.0 (24 1s) that allows all IPs between 192.168.0.0 and 192.168.0.255. Understanding CIDR format is particularly useful if you plan to run your applications on a server.\n\nAPI keys initially have an active status, but they can become inactive over their lifetime. To learn why an API key has changed status and how to return the API key back to an active status, see the following table."
    },
    {
        "link": "https://github.com/S0ftwareUpd8/roblox-api",
        "document": "{ : , : , : Last week we added a sewer escape and more! THIS WEEK we ve got a surprise, BETTER TRAINS! - No/Less sliding! 😃 - Better performance! ⚡️ - Longer trains! 🚂🚃🚃🚃 - No flinging! 🚀 - No more drifting trains! Stays on track! 🛤 💰 This summer, expect a new place to rob in Jailbreak! Coming soon! Welcome to Jailbreak! Live the life of a Police Officer or a Criminal. Stop crimes or cause them. Uphold the law or break the law. In this world, the choice is yours. Follow us on Twitter for EARLY update information! @asimo3089 @badccvoid @badimo Join our group to know right when we upload future updates and events! https://www.roblox.com/My/Groups.aspx?gid=3059674 Thumbnails by @ID0ntHaveAUse Icon/Thumbnails by @RBLXcrackop , : , : , : , : , : , : , : , : , : , : , : , : , : , : , : , : , : , : , : , : , : , : { : , : }, : , : , : , : , : , : , : , : , : , : }"
    },
    {
        "link": "https://devforum.roblox.com/t/how-to-use-the-roblox-web-api-endpoints/1829973",
        "document": "How to use the Roblox web API endpoints?\n\nIn this tutorial I will be explaining how you can use the Roblox web API endpoints. I decided to create this post because I know from personal experience I found it hard to learn how to use the API endpoints due to there being no real tutorial on how to use them and also no real YouTube videos; the only videos on YouTube is how to use things like Noblox.js which is good but not if you want to learn how to use the API directly so I want to give my knowledge to make it easier for everyone.\n• Issues with using the Roblox API endpoints\n• How to send get requests\n\nPlease before using this tutorial learn how to send basic API requests before attempting to use this tutorial. Although it will explain how to use the API endpoints I will not be going into major details into how to send requests.\n\nIssues with using the Roblox API endpoints:\n\nIn this section of the tutorial I will be going over two main issues you may encounter when using the Roblox APIs. These are that due to a quite recent update Roblox security cookie become invalid on change of the region your IP address is at and also changes Roblox does to there API endpoints don’t get announced very often.\n\nAs some of you may have seen if you use the Roblox API in any way at all currently it seems that when your IP region changes to a different one it will invalidate this cookie. This was a update that Roblox has done to reduce the amount of people having there accounts compromised due to that security cookie getting invalidated when used at a different region then the IP that created the cookie. This is a great update for Roblox account security but bad news for us devs who use hosting severs that are not on the same region then the cookie was created. A good way of fixing this issue is running your bot or what ever your using the API for on a server which is on the same region then the API was created at. There are other ways but I will not go into lots of details on this,\n\nThe next main issue is that Roblox does not often announce changes to the API endpoints. The reason for this is because the Roblox API endpoints are not officially supported for external use. The API endpoints are internal endpoints (the Open Cloud will be the supported API when they get it all complete). Roblox does sometimes announce changes like the recent one talking about the removal of some main API endpoints however this is not often announced. There is not much we can do untill the Open Cloud is complete which will be a very long time though for all the endpoints to be added to the Open Cloud.\n\nI will next be explaining how you can authenticate a request. Unlike the Roblox Open Cloud where you use an API key when using the API endpoints in general at the current moment you will be required to use a Roblox security cookie to use some of the endpoints. What is a Roblox security cookie? I expect that everyone who is looking into using the Roblox API endpoints directly themselves would know what the security cookie is but if you do not understand it is basically what the cookie is used for authenticating that someone is logged into the website. Due to this we can use this to our advantage and use it as the way to authenticate requests. You only need to authenticate some requests (mainly POST, DELETE and PATCH requests) however some GET requests also require authentication. Below you can view how to get the Roblox cookie.\n\nHow to get Roblox security cookie:\n\nAfter you have got the Roblox security you can use this to send requests. Quick note that you should not have your Roblox security in your main code but as something like an environment variable to keep it as secure as possible. You will then need to put this Roblox security cookie in your header of any Roblox API requests that require authentication. In the headder the cookie should be named “Cookie” and you also require “.ROBLOSECURITY=” in front of the security cookie.\n\nExample taken from the Roblox API wiki:\n\nAlthough we use the Roblox security cookie to authenticate requests we do also require to get something called a X-CSRF-Token. If we do not add the X-CSRF-Token and only have the Roblox security cookie then it will provide you a 403 status code with the error message of Token Validation Failed. The issue however is that X-CSRF-Token’s get auto get invalidated after a couple of minutes so due to this we need to get a new one ever so often. Lucky for us basically all requests that require authentication will provide you with a new X-CSRF-Token so due to this we can send the request with the X-CSRF-Token and if it is invalid then you can take the X-CSRF-Token from the invalid request and re-do the request. It is also highly recommend you save the X-CSRF-Token from a request and then only get a new one if the old one become invalid. By the way you should know this if you know how to send API requests but if the request is valid and works we should get a status code of 200 which means that the request was ok/valid.\n\nExample taken from the Roblox API wiki:\n\nIf we do the above with the Roblox cookie and the X-CSRF-Token then we should be able to send a request which requires authentication. Can be annoying with the X-CSRF-Token but just remember if it become invalid get the new X-CSRF-Token from the request header of the invalid request and then send the request again.\n\nHow to send get requests to the API endpoints\n\nI will next be explaining how to send GET requests that do not require authentication. Now if you understand the basics of sending requests to API endpoints you should already know how to send get requests to the Roblox API that do not require any authentication at all. It is very easy to do and you just send the request with the required headers and other things that you have inside of a request. Below I will leave a very basic example using axios.\n\nHow to send a post request to the Roblox API endpoint\n\nAgain like the get request as long as you understand how to send post requests you should have no trouble sending a post request. All you really need is to know how to send post requests and understand how to authenticate the request which I have explained in this tutorial. If you understand how to authenticate the request it is as simple as sending the required things in the request with the authentication requirement (cookie and X-CSRF-Token) in the header of the request.\n\nExample post request (have not tested it but you get the idea)\n\nI will not be going over this area that much due to there being lots of different possible errors that you can get but really you will just need to test around and see what errors you will get. Just a tip always check the status code but also the error message that you get. If the status code is 200 then you know that the request was sucessfull.\n\nYou can also check the error status codes here: HTTP response status codes - HTTP | MDN\n\nI hope that this tutorial has helped a bit to understand how to use the Roblox web API and also mainly how to authenticate request that require authentication. If you have any suggestions for me to add to this tutorial feel free to leave them in the comments (or direct message me here) and also if you have any questions or need any extra help that I have not included feel free to ask below and I will attempt to answer your questions.\n\nI recommend reading about the API in the wiki for it as there is much info there: https://robloxapi.wiki/wiki/Main_Page"
    }
]