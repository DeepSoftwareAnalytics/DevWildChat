[
    {
        "link": "https://stackoverflow.com/questions/57503997/windows-how-to-configure-multiple-versions-of-python-to-work-together",
        "document": "I installed Python 2.7 a long time ago on my PC (I am running Windows 10). Today I decided to install Python 3.7, but after typing 'python' into the command prompt the console printed 'python 2.7...'\n\nI have no idea as to what I should do. Would this be a problem with my path configuration? I considered uninstalling python 2.7 but I still want it installed on my computer."
    },
    {
        "link": "https://discuss.python.org/t/managing-multiple-python-version-without-any-tool/48620",
        "document": "It depends what you mean by “manage”. But it seems like you have very light-weight “management” in mind, so this is a very easy problem, and no external tools are really needed.\n\nFortunately for you, this is already built in. Just use the standard library module to create a virtual environment (which is exactly the sort of local environment you describe, except that it may use symlinks to installed Python interpreter etc. executables somewhere else, and it is not relocatable). It will have its own completely separate storage location for third-party packages, and will come with its own “activation” bash script for temporarily mangling PATH so that means the one in that environment. (It also adjusts the prompt via PS1 to remind you that the environment is “active”.) Running the script looks like ; while the environment is active, (a bash function created by the script) means to undo the changes.\n\nIf you want multiple different versions of Python, that is also trivial. Each installation already has a separate storage location for third-party packages (it must, because not all packages are compatible with all Python versions), and a separate standard library.\n\nIf you want to control which version of Python runs when you use a command like , outside of virtual environments, see the documentation for Python, and on Linux you should also consult your distro’s documentation. It might not be a good idea to alias or make permanent alterations to PATH - since the system may depend on system-provided scripts running with a specific system-provided Python version. Your system package manager might also provide convenience packages for this, which re-alias the commands and ensure nothing will break. (For example, Ubuntu users may find they can things with names like .)\n\nIf you want a virtual environment based off a specific version of Python, you just use its standard library module: ."
    },
    {
        "link": "https://reddit.com/r/learnpython/comments/uf4i6w/how_do_i_better_manage_my_python_versions_and",
        "document": "I'm a casual python user and one problem that has annoyed me is that over time on any particular computer of mine I'll often end up with multiple python versions, usually forgetting about some because they were installed by some program, or perhaps I installed the latest version and never bothered to uninstall a previous version. I'll often even forget where exactly a particular version is located on my computer. Another thing that annoys me is that every time I download a new version of python I have to reinstall all the packages I use.\n\nIs there some program I can use that keeps track of all my python versions and can automatically install packages in batch from a list?"
    },
    {
        "link": "https://stackoverflow.com/questions/4583367/how-to-run-multiple-python-versions-on-windows",
        "document": "How can I specify which I want to use?\n\nI had two versions of Python installed on my machine (versions 2.6 and 2.5). I want to run 2.6 for one project and 2.5 for another.\n\nRunning a different copy of Python is as easy as starting the correct executable. You mention that you've started a python instance, from the command line, by simply typing . What this does under Windows, is to trawl the environment variable, checking for an executable, either batch file ( ), command file ( ) or some other executable to run (this is controlled by the environment variable), that matches the name given. When it finds the correct file to run the file is being run. Now, if you've installed two python versions 2.5 and 2.6, the path will have both of their directories in it, something like but Windows will stop examining the path when it finds a match. What you really need to do is to explicitly call one or both of the applications, such as or . The other alternative is to create a shortcut to the respective calling one of them and the other ; you can then simply run on your command line.\n\nAdding two more solutions to the problem:\n• Use pylauncher (if you have Python 3.3 or newer there's no need to install it as it comes with Python already) and either add shebang lines to your scripts; - for scripts you want to be run with Python 2.5\n\n - for scripts you want to be run with Python 2.6 or instead of running command run pylauncher command ( ) specyfing which version of Python you want; virtualenv -p c:\\[path to Python 2.5]\\python.exe [path where you want to have virtualenv using Python 2.5 created]\\[name of virtualenv] virtualenv -p c:\\[path to Python 2.6]\\python.exe [path where you want to have virtualenv using Python 2.6 created]\\[name of virtualenv] then you can activate the first and work with Python 2.5 like this\n\n \n\n and when you want to switch to Python 2.6 you do\n\nWhen you install Python, it will not overwrite other installs of other major versions. So installing Python 2.5.x will not overwrite Python 2.6.x, although installing 2.6.6 will overwrite 2.6.5. So you can just install it. Then you call the Python version you want. For example: for Python 2.5 on windows and for Python 2.6 on windows, or When you install on Unix (including Linux and OS X) you will get a generic command installed, which will be the last one you installed. This is mostly not a problem as most scripts will explicitly call /usr/local/bin/python2.5 or something just to protect against that. But if you don't want to do that, and you probably don't you can install it like this: Note the \"altinstall\" that means it will install it, but it will not replace the command. On Windows you don't get a global command as far as I know so that's not an issue.\n\nThe easiest way to run multiple versions of python on windows is described below as follows:- 1)Download the latest versions of python from python.org/downloads by selecting the relevant version for your system. 2)Run the installer and select Add python 3.x to the path to set path automatically in python 3 (you just have to click the checkbox). For python 2 open up your python 2 installer, select whatever preferences you want but just remember to set Add python.exe to path to Will be installed on local hard drive, Now just click next and wait for the installer to finish. 3)When both the installations are complete. Right click on my computer--Go to properties--Select advanced system settings--Go to environment variables--Click on new under System variables and add a new system variable with variable name as PY_PYTHON and set this variable value to 3. Now click on OK and you should be done. 4)Now to test this open the command prompt. Once you are in there type python or py, It should open up python3. 5)Now exit out of python3 by typing exit(). Now type py -2 it should open python 2. If none of this works then restart the computer and if the problem still persists then uninstall everything and repeat the steps.\n\nThis is a simple and elegant solution to easily run 2 or more different versions of python without using scripts in Windows. Whatever the version of python, it will start from the Command prompt. I have python versions 3.6.6 and 3.9. The Environment Variable paths are normal and were automatically added when each version of python was installed. It's best to install python using the \"all users\" option. This way the python will simply install to: Open each of these python folders and find the python.exe file. Copy and paste the python.exe file into those same folders. Then carefully rename the copies to: Open a new Command Prompt terminal window. To run one or the other version of python, type: More versions of python can easily be added by repeating the same as shown above. Elegant and simple. Done.\n\nlet's say if we have python 3.7 and python 3.6 installed. they are respectively stored in following folder by default. if we want to use cmd prompt to install/run command in any of the above specific environment do this: There should be python.exe in each of the above folder. so when we try running any file for ex. (see image1) . we call that respective python.exe. by default it picks lower version of file. (means in this case it will use from python 3.6 ) so if we want to run using python3.7. just change the .exe file name. for ex. if I change to python37.exe and i want to use python3.7 to run hello.py I will use . or if i want to use python3.7 by default i will change the python.exe filename in python3.6 folder to something else . so that it will use python3.7 each time when I use only"
    },
    {
        "link": "https://realpython.com/intro-to-pyenv",
        "document": "Have you ever wanted to contribute to a project that supports multiple versions of Python but aren’t sure how you would easily test all the versions? Are you ever curious about the latest and greatest versions of Python? Maybe you’d like to try out these new features, but you don’t want to worry about messing up your development environment. Luckily, managing multiple versions of Python doesn’t have to be confusing if you use .\n\nThis article will provide you with a great overview of how to maximize your time spent working on projects and minimize the time spent in headaches trying to use the right version of Python.\n\nIn this article, you’ll learn how to:\n\nis a wonderful tool for managing multiple Python versions. Even if you already have Python installed on your system, it is worth having installed so that you can easily try out new language features or help contribute to a project that is on a different version of Python. Using is also a great way to install pre-release versions of Python so that you can test them for bugs. Why Not Use System Python? “System Python” is the Python that comes installed on your operating system. If you’re on Mac or Linux, then by default, when you type in your terminal, you get a nice Python REPL. So, why not use it? One way to look at it is that this Python really belongs to the operating system. After all, it came installed with the operating system. That’s even reflected when you run : Here, is available to all users as evidenced by its location . Chances are, this isn’t the version of Python you want either: To install a package into your system Python, you have to run . That’s because you’re installing the Python package globally, which is a real problem if another user comes along and wants to install a slightly older version of the package. Problems with multiple versions of the same package tend to creep up on you and bite you when you least expect it. One common way this problem presents itself is a popular and stable package suddenly misbehaving on your system. After hours of troubleshooting and Googling, you may find that you’ve installed the wrong version of a dependency, and it’s ruining your day. Even if your Python version is installed in , you’re still not safe. You will run into the same permissions and flexibility problems described above. In addition, you don’t really have much control over what version of Python comes installed on your OS. If you want to use the latest features in Python, and you’re on Ubuntu for example, you might just be out of luck. The default versions might be too old, which means you’ll just have to wait for a new OS to come out. Finally, some operating systems actually use the packaged Python for operation. Take for example, which makes heavy use of Python to do its job. If you install a new version of Python and aren’t careful to install it into your user space, you could seriously damage your ability to use your OS. The next logical place to look is package managers. Programs such as , , , or are typical next options. After all, this is how you install most packages to your system. Unfortunately, you’ll find some of the same problems using a package manager. By default, package managers tend to install their packages into the global system space instead of the user space. Again, these system level packages pollute your development environment and make it hard to share a workspace with others. Once again, you still don’t have control over what version of Python you can install. It’s true some repositories give you a greater selection, but by default, you’re looking at whatever version of Python your particular vendor is up to on any given day. Even if you do install Python from a package manager, consider what would happen if you’re writing a package and want to support and test on Python 3.4 - 3.7. What would happen on your system when you type ? How would you switch quickly between the different versions? You can certainly do it, but it is tedious and prone to error. Nevermind the fact that if you want PyPy, Jython, or Miniconda, then you’re probably just out of luck with your package manager. With these constraints in mind, let’s recap the criteria that would let you install and manage Python versions easily and flexibly:\n• Specify the exact Python version you want lets you do all of these things and more.\n\nBefore you install itself, you’re going to need some OS-specific dependencies. These dependencies are mostly development utilities written in C and are required because installs Python by building from source. For a more detailed breakdown and explanation of the build dependencies, you can check out the official docs. In this tutorial, you’ll see the most common ways to install these dependencies. Note: did not originally support Windows. However, there appears to be some basic support with the pyenv-win project that recently became active. If you use Windows, feel free to check it out. builds Python from source, which means you’ll need build dependencies to actually use . The build dependencies vary by platform. If you are on Ubuntu/Debian and want to install the build dependencies, you could use the following: This uses Apt to install all the build dependencies. Let this run, and you’ll be ready to go for Debian systems. If you use Fedora/CentOS/RHEL, you could use to install your build dependencies: This command will install all the build dependencies for Python using . macOS users can use the following command: This command relies on Homebrew and installs the few dependencies for macOS users. Tip: When running Mojave or higher (10.14+) you will also need to install the additional SDK headers: Thanks to Rodrigo Viera for the update. If you’re instead using openSUSE then you would run the following: Once again, this command installs all the Python build dependencies for your system. Finally, for Alpine users, you can use this: This command uses as the package manager and will install all build dependencies for Python on Alpine. After you’ve installed the build dependencies, you’re ready to install itself. I recommend using the pyenv-installer project: This will install along with a few plugins that are useful:\n• : Plugin to verify that and build dependencies are installed Note: The above command is the same as downloading the pyenv-installer script and running it locally. So if you’d like to see exactly what you’re running, you can view the file yourself. Alternatively, if you really don’t want to run a script, you can checkout the manual installation instructions. At the end of the run, you should see something like this: WARNING: seems you still have not added 'pyenv' to the load path. the following to ~/.bashrc: The output will be based on your shell. But you should follow the instructions to add to your path and to initialize / auto completion. Once you’ve done this, you need to reload your shell: # Or just restart your terminal That’s it. You now have and four useful plugins installed.\n\nNow that you have installed, installing Python is the next step. You have many versions of Python to choose from. If you wanted to see all the available CPython 3.6 through 3.8, you can do this: The above shows all the Python versions that knows about that match the regular expression. In this case, that is all available CPython versions 3.6 through 3.8. Likewise, if you wanted to see all the Jython versions, you could do this: Again, you can see all the Jython versions that has to offer. If you want to see all the versions, you can do the following: Once you find the version you want, you can install it with a single command: Having Problems? The documentation has great installation notes as well as a useful FAQ along with common build problems. This will take a while because is building Python from source, but once it’s done, you’ll have Python 3.7.2 available on your local machine. If you don’t want to see all the output, just remove the flag. Even development versions of CPython can be installed: Pro Tip: If you’ve been using for a while and don’t see the version you’re looking for, you may need to run to update the tool and make sure you have access to the latest versions. For the rest of the tutorial, the examples assume you’ve installed and , but you’re free to substitute these values for the Python versions you actually installed. Also note that the system Python version in the examples is . As mentioned before, works by building Python from source. Each version that you have installed is located nicely in your root directory: All of your versions will be located here. This is handy because removing these versions is trivial: Of course also provides a command to uninstall a particular Python version: Using Your New Python Now that you’ve installed a couple of different Python versions, let’s see some basics on how to use them. First, check what versions of Python you have available: The indicates that the Python version is active currently. You’ll also notice that this is set by a file in your root directory. This means that, by default, you are still using your system Python: If you try to confirm this using , you’ll see this: This might be surprising, but this is how works. inserts itself into your and from your OS’s perspective is the executable that is getting called. If you want to see the actual path, you can run the following: If, for example, you wanted to use version 2.7.15, then you can use the command: Pro Tip: A great way to get peace of mind that the version of Python you just installed is working properly is to run the built-in test suite: This will kick off lots of internal Python tests that will verify your installation. You can just kick back and watch the tests pass. If you ever want to go back to the system version of Python as the default, you can run this: You can now switch between different versions of Python with ease. This is just the beginning. If you have many versions that you want to switch between, typing these commands consistently is tedious. This section goes over the basics, but a better workflow is described in working with multiple environments.\n\noffers many commands. You can see a complete list of all available commands with this: This outputs all command names. Each command has a flag that will give you more detailed information. For example, if you wanted to see more information on the command you could run the following: The help message describes what the command is used for and any options you can use in conjunction with the command. In the following sections, you’ll find a quick, high-level overview of the most used commands. You’ve already seen the command above. This command can be used to install a specific version of Python. For example, if you wanted to install you would use this: The output shows us downloading and installing Python. Some of the common flags you may want to use are the following: Lists all available Python versions for installation The command displays all currently installed Python versions: This output shows not only that , , , and your Python are installed, but also shows you that the Python is active. If you only care about the current active version, you can use the following command: This command is similar to but only shows you the current active Python version. The command is helpful for determining the full path to a system executable. Because works by using shims, this command allows you to see the full path to the executable is running. For example, if you wanted to see where is installed, you could run this: The output displays the full system path for . This can be helpful when you’ve installed command-line applications. The command sets the global Python version. This can be overridden with other commands, but is useful for ensuring you use a particular Python version by default. If you wanted to use by default, then you could run this: This command sets the to . For more information, see the section on specifying your Python version. The command is often used to set an application-specific Python version. You could use it to set the version to : This command creates a file in your current directory. If you have active in your environment, this file will automatically activate this version for you. The command is used to set a shell-specific Python version. For example, if you wanted to test out the version of Python, you can do this: This command activates the version specified by setting the environment variable. This command overwrites any applications or global settings you may have. If you want to deactivate the version, you can use the flag.\n\nOne of the more confusing parts of is how exactly the command gets resolved and what commands can be used to modify it. As mentioned in the commands, there are 3 ways to modify which version of you’re using. So how do all these commands interact with one another? The resolution order looks a little something like this: This pyramid is meant to be read from top to bottom. The first of these options that can find is the option it will use. Let’s see a quick example: Here, your Python is being used as denoted by the . To exercise the next most global setting, you use : You can see that now wants to use as our Python version. It even indicates the location of the file it found. That file does indeed exist, and you can list its contents: Here again, indicates how it would resolve our command. This time it comes from . Note that the searching for is recursive: Even though there isn’t a in , the version is still set to because exists in a parent directory. Finally, you can set the Python version with : All this did is set the environment variable: If you’re feeling overwhelmed by the options, the section on working with multiple environments goes over an opinionated process for managing these files, mostly using .\n\nVirtual environments are a big part of managing Python installations and applications. If you haven’t heard of virtual environments before, you can check out Python Virtual Environments: A Primer. Virtual environments and are a match made in heaven. has a wonderful plugin called that makes working with multiple Python version and multiple virtual environments a breeze. If you’re wondering what the difference is between , , and tools like or , then don’t worry. You’re not alone. Here’s what you need to know:\n• pyenv-virtualenv manages virtual environments for across varying versions of Python. If you’re a die-hard or user, don’t worry: plays nicely with either. In fact, you can keep the same workflow you’ve had if you’d prefer, though I think makes for a nicer experience when you’re switching between multiple environments that require different Python versions. The good news is that since you used the script to install , you already have installed and ready to go. Technically, the is optional, but you should consider always specifying it so that you’re certain of what Python version you’re using. The is just a name for you to help keep your environments separate. A good practice is to name your environments the same name as your project. For example, if you were working on and wanted to develop against Python 3.6.8, you would run this: The output includes messages that show a couple of extra Python packages getting installed, namely , , and . This is strictly for convenience and just sets up a more full featured environment for each of your virtual environments. Now that you’ve created your virtual environment, using it is the next step. Normally, you should activate your environments by running the following: You’ve seen the command before, but this time, instead of specifying a Python version, you specify an environment. This creates a file in your current working directory and because you ran in your environment, the environment will automatically be activated. You can verify this by running the following: You can see a new version has been created called and the executable is pointing to that version. If you look at any executable this environment provides, you will see the same thing. Take, for example, : If you did not configure to run in your shell, you can manually activate/deactivate your Python versions with this: The above is what is doing when it enters or exits a directory with a file in it.\n\nAs described in the example above, uses experimental features in 3.8. Suppose you wanted to ensure that your code still works on Python 3.6. If you try running , you’ll get this: project2/ python3.6 -V The `python3.6' command exists in these Python versions: informs you that, while Python 3.6 is not available in the current active environment, it is available in other environments. gives you a way to activate multiple environments at once using a familiar command: This indicates to that you would like to use the virtual environment as the first option. So if a command, for example , can be resolved in both environments, it will pick before . Let’s see what happens if you run this: Here, attempts to find the command, and because it finds it in an environment that is active, it allows the command to execute. This is extremely useful for tools like tox that require multiple versions of Python to be available on your in order to execute. Pro Tip: If you’re using tox and , you should checkout the tox-pyenv package. Suppose that in the above example, you’ve found a compatibility problem with your library and would like to do some local testing. The testing requires that you install all the dependencies. You should follow the steps to create a new environment: Once you’re satisfied with your local testing, you can easily switch back to your default environment:\n\nBonus: Displaying Your Environment Name in Your Command Prompt If you’re like me and constantly switching between various virtual environments and Python versions, it’s easy to get confused about which version is currently active. I use oh-my-zsh and the agnoster theme, which by default makes my prompt look like this: At a glance, I don’t know which Python version is active. To figure it out, I would have to run or . To help reduce my time spent on figuring out my active Python environment, I add the virtual environment I’m using to my prompt: My Python version in this case is and is displayed immediately at the beginning of the prompt. This allows me to quickly see what version of Python I’m using right away. If you’d like to use this too, you can use my agnoster-pyenv theme. Test your knowledge with our interactive “Managing Multiple Python Versions With pyenv” quiz. You’ll receive a score upon completion to help you track your learning progress: In this quiz, you'll test your understanding of how to use pyenv to manage multiple versions of Python. Pyenv allows you to try out new Python features without disrupting your development environment, and quickly switch between different Python versions."
    },
    {
        "link": "https://pip.pypa.io/en/stable/installation",
        "document": "Usually, pip is automatically installed if you are:\n• None using Python that has not been modified by a redistributor to remove\n\nIf your Python environment does not have pip installed, there are 2 mechanisms to install pip supported directly by pip’s maintainers: Python comes with an module , which can install pip in a Python environment. More details about how works and how it can be used, is available in the standard library documentation. This is a Python script that uses some bootstrapping logic to install pip.\n• None Open a terminal/command prompt, to the folder containing the file and run: More details about this script can be found in pypa/get-pip’s README. The zip application is currently experimental. We test that pip runs correctly in this form, but it is possible that there could be issues in some situations. We will accept bug reports in such cases, but for now the zip application should not be used in production environments. In addition to installing pip in your environment, pip is available as a standalone zip application. This can be downloaded from https://bootstrap.pypa.io/pip/pip.pyz. There are also zip applications for specific pip versions, named . The zip application can be run using any supported version of Python: then the currently active Python interpreter will be used. then the currently active Python interpreter will be used. then the currently active Python interpreter will be used. You may need to configure your system to recognise the extension before this will work.\n\nDepending on how you installed Python, there might be other mechanisms available to you for installing pip such as using Linux package managers. These mechanisms are provided by redistributors of pip, who may have modified pip to change its behaviour. This has been a frequent source of user confusion, since it causes a mismatch between documented behaviour in this documentation and how pip works after those modifications. If you face issues when using Python and pip installed using these mechanisms, it is recommended to request for support from the relevant provider (eg: Linux distro community, cloud provider support channels, etc)."
    },
    {
        "link": "https://packaging.python.org/guides/installing-using-pip-and-virtual-environments",
        "document": "Install packages in a virtual environment using pip and venv¶\n\nThis guide discusses how to create and activate a virtual environment using the standard library’s virtual environment tool venv and install packages. The guide covers how to:\n• None Install packages into a virtual environment using the command\n\nThis guide has the prerequisite that you are using an official Python version obtained from <https://www.python.org/downloads/>. If you are using your operating system’s package manager to install Python, please ensure that Python is installed before proceeding with these steps.\n\nvenv (for Python 3) allows you to manage separate package installations for different projects. It creates a “virtual” isolated Python installation. When you switch projects, you can create a new virtual environment which is isolated from other virtual environments. You benefit from the virtual environment since packages can be installed confidently and will not interfere with another project’s environment. It is recommended to use a virtual environment when working with third party packages. To create a virtual environment, go to your project’s directory and run the following command. This will create a new virtual environment in a local folder named : The second argument is the location to create the virtual environment. Generally, you can just create this in your project and call it . will create a virtual Python installation in the folder. You should exclude your virtual environment directory from your version control system using or similar. Before you can start installing or using packages in your virtual environment you’ll need to it. Activating a virtual environment will put the virtual environment-specific and executables into your shell’s . To confirm the virtual environment is activated, check the location of your Python interpreter: While the virtual environment is active, the above command will output a filepath that includes the directory, by ending with the following: While a virtual environment is activated, pip will install packages into that specific environment. This enables you to import and use packages in your Python application. If you want to switch projects or leave your virtual environment, the environment: Closing your shell will deactivate the virtual environment. If you open a new shell window and want to use the virtual environment, reactivate it. If you want to reactivate an existing virtual environment, follow the same instructions about activating a virtual environment. There’s no need to create a new virtual environment.\n\npip is the reference Python package manager. It’s used to install and update packages into a virtual environment. The Python installers for macOS include pip. On Linux, you may have to install an additional package such as . You can make sure that pip is up-to-date by running: Afterwards, you should have the latest version of pip installed in your user site: The Python installers for Windows include pip. You can make sure that pip is up-to-date by running: Afterwards, you should have the latest version of pip:\n\nWhen your virtual environment is activated, you can install packages. Use the command to install packages. For example,let’s install the Requests library from the Python Package Index (PyPI): pip should download requests and all of its dependencies and install them: Collecting requests Using cached requests-2.18.4-py2.py3-none-any.whl Collecting chardet<3.1.0,>=3.0.2 (from requests) Using cached chardet-3.0.4-py2.py3-none-any.whl Collecting urllib3<1.23,>=1.21.1 (from requests) Using cached urllib3-1.22-py2.py3-none-any.whl Collecting certifi>=2017.4.17 (from requests) Using cached certifi-2017.7.27.1-py2.py3-none-any.whl Collecting idna<2.7,>=2.5 (from requests) Using cached idna-2.6-py2.py3-none-any.whl Installing collected packages: chardet, urllib3, certifi, idna, requests Successfully installed certifi-2017.7.27.1 chardet-3.0.4 idna-2.6 requests-2.18.4 urllib3-1.22 pip allows you to specify which version of a package to install using version specifiers. For example, to install a specific version of : To install the latest release of requests: To install pre-release versions of packages, use the flag: Some packages have optional extras. You can tell pip to install these by specifying the extra in brackets: pip can install a package directly from its source code. For example, to install the source code in the directory: Additionally, pip can install packages from source in development mode, meaning that changes to the source directory will immediately affect the installed package without needing to re-install: pip can install packages directly from their version control system. For example, you can install directly from a git repository: For more information on supported version control systems and syntax, see pip’s documentation on VCS Support. If you have a local copy of a Distribution Package’s archive (a zip, wheel, or tar file) you can install it directly with pip: If you have a directory containing archives of multiple packages, you can tell pip to look for packages there and not to use the Python Package Index (PyPI) at all: This is useful if you are installing packages on a system with limited connectivity or if you want to strictly control the origin of distribution packages. If you want to download packages from a different index than the Python Package Index (PyPI), you can use the flag: If you want to allow packages from both the Python Package Index (PyPI) and a separate index, you can use the flag instead:\n\nPip can export a list of all installed packages and their versions using the command: Which will output a list of package specifiers such as: The command is useful for creating Requirements Files that can re-create the exact versions of all packages installed in an environment."
    },
    {
        "link": "https://packaging.python.org/tutorials/installing-packages",
        "document": "This section covers the basics of how to install Python packages.\n\nIt’s important to note that the term “package” in this context is being used to describe a bundle of software to be installed (i.e. as a synonym for a distribution). It does not refer to the kind of package that you import in your Python source code (i.e. a container of modules). It is common in the Python community to refer to a distribution using the term “package”. Using the term “distribution” is often not preferred, because it can easily be confused with a Linux distribution, or another larger software distribution like Python itself.\n\nThis section describes the steps to follow before installing other Python packages. Ensure you can run Python from the command line¶ Before you go any further, make sure you have Python and that the expected version is available from your command line. You can check this by running: You should get some output like . If you do not have Python, please install the latest 3.x version from python.org or refer to the Installing Python section of the Hitchhiker’s Guide to Python. If you’re a newcomer and you get an error like this: File , line , in : name 'python3' is not defined It’s because this command and other suggested commands in this tutorial are intended to be run in a shell (also called a terminal or console). See the Python for Beginners getting started tutorial for an introduction to using your operating system’s shell and interacting with Python. If you’re using an enhanced shell like IPython or the Jupyter notebook, you can run system commands like those in this tutorial by prefacing them with a character: It’s recommended to write rather than plain in order to ensure that commands are run in the Python installation matching the currently running notebook (which may not be the same Python installation that the command refers to). Due to the way most Linux distributions are handling the Python 3 migration, Linux users using the system Python without creating a virtual environment first should replace the command in this tutorial with and the command with . Do not run any of the commands in this tutorial with : if you get a permissions error, come back to the section on creating virtual environments, set one up, and then continue with the tutorial as written. Ensure you can run pip from the command line¶ Additionally, you’ll need to make sure you have pip available. You can check this by running: If you installed Python from source, with an installer from python.org, or via Homebrew you should already have pip. If you’re on Linux and installed using your OS package manager, you may have to install pip separately, see Installing pip/setuptools/wheel with Linux Package Managers. If isn’t already installed, then first try to bootstrap it from the standard library: If that still doesn’t allow you to run :\n• None Run . This will install or upgrade pip. Additionally, it will install Setuptools and wheel if they’re not installed already. Be cautious if you’re using a Python install that’s managed by your operating system or another package manager. get-pip.py does not coordinate with those tools, and may leave your system in an inconsistent state. You can use to install in which is designed for locally-installed software. See section below for details, but here’s the basic venv command to use on a typical Linux system: This will create a new virtual environment in the subdirectory, and configure the current shell to use it as the default environment.\n\nPython “Virtual Environments” allow Python packages to be installed in an isolated location for a particular application, rather than being installed globally. If you are looking to safely install global command line tools, see Installing stand alone command line tools. Imagine you have an application that needs version 1 of LibFoo, but another application requires version 2. How can you use both these applications? If you install everything into /usr/lib/python3.6/site-packages (or whatever your platform’s standard location is), it’s easy to end up in a situation where you unintentionally upgrade an application that shouldn’t be upgraded. Or more generally, what if you want to install an application and leave it be? If an application works, any change in its libraries or the versions of those libraries can break the application. Also, what if you can’t install packages into the global site-packages directory? For instance, on a shared host. In all these cases, virtual environments can help you. They have their own installation directories and they don’t share libraries with other virtual environments. Currently, there are two common tools for creating Python virtual environments:\n• None venv is available by default in Python 3.3 and later, and installs pip into created virtual environments in Python 3.4 and later (Python versions prior to 3.12 also installed Setuptools).\n• None virtualenv needs to be installed separately, but supports Python 2.7+ and Python 3.3+, and pip, Setuptools and wheel are always installed into created virtual environments by default (regardless of Python version). The basic usage is like so: For more information, see the venv docs or the virtualenv docs. The use of source under Unix shells ensures that the virtual environment’s variables are set within the current shell, and not in a subprocess (which then disappears, having no useful effect). In both of the above cases, Windows users should not use the source command, but should rather run the activate script directly from the command shell like so: Managing multiple virtual environments directly can become tedious, so the dependency management tutorial introduces a higher level tool, Pipenv, that automatically manages a separate virtual environment for each project and application that you work on.\n\nThe most common usage of pip is to install from the Python Package Index using a requirement specifier. Generally speaking, a requirement specifier is composed of a project name followed by an optional version specifier. A full description of the supported specifiers can be found in the Version specifier specification. Below are some examples. To install the latest version of “SomeProject”: To install greater than or equal to one version and less than another: To install a version that’s compatible with a certain version: In this case, this means to install any version “==1.4.*” version that’s also “>=1.4.2”.\n\npip can install from either Source Distributions (sdist) or Wheels, but if both are present on PyPI, pip will prefer a compatible wheel. You can override pip`s default behavior by e.g. using its –no-binary option. Wheels are a pre-built distribution format that provides faster installation compared to Source Distributions (sdist), especially when a project contains compiled extensions. If pip does not find a wheel to install, it will locally build a wheel and cache it for future installs, instead of rebuilding the source distribution in the future.\n\nTo install packages that are isolated to the current user, use the flag: For more information see the User Installs section from the pip docs. Note that the flag has no effect when inside a virtual environment - all installation commands will affect the virtual environment. If defines any command-line scripts or console entry points, will cause them to be installed inside the user base’s binary directory, which may or may not already be present in your shell’s . (Starting in version 10, pip displays a warning when installing any scripts to a directory outside .) If the scripts are not available in your shell after installation, you’ll need to add the directory to your :\n• None On Linux and macOS you can find the user base binary directory by running and adding to the end. For example, this will typically print (with expanded to the absolute path to your home directory) so you’ll need to add to your . You can set your permanently by modifying ~/.profile.\n• None On Windows you can find the user base binary directory by running and replacing with . For example, this could return so you would need to set your to include . You can set your user permanently in the Control Panel. You may need to log out for the changes to take effect."
    },
    {
        "link": "https://pip.pypa.io/en/stable/user_guide",
        "document": "pip supports installing from PyPI, version control, local projects, and directly from distribution files. The most common scenario is to install from PyPI using Requirement Specifiers For more information and examples, see the pip install reference. This is now covered in Authentication. This is now covered in Authentication. This is now covered in Authentication.\n\n“Requirements files” are files containing a list of items to be installed using pip install like so: Details on the format of the files are here: Requirements File Format. Logically, a Requirements file is just a list of pip install arguments placed in a file. Note that you should not rely on the items in the file being installed by pip in any particular order. Requirements files can also be served via a URL, e.g. http://example.com/requirements.txt besides as local files, so that they can be stored and served in a centralized place. In practice, there are 4 common uses of Requirements files:\n• None Requirements files are used to hold the result from pip freeze for the purpose of achieving Repeatable Installs. In this case, your requirement file contains a pinned version of everything that was installed when was run.\n• None Requirements files are used to force pip to properly resolve dependencies. pip 20.2 and earlier doesn’t have true dependency resolution, but instead simply uses the first specification it finds for a project. E.g. if requires and requires , and if is resolved first, pip will only use , and could easily end up installing a version of that conflicts with the needs of . To solve this problem, you can place (i.e. the correct specification) into your requirements file directly along with the other top level requirements. Like so:\n• None Requirements files are used to force pip to install an alternate version of a sub-dependency. For example, suppose in your requirements file requires , but the latest version (v1.3) has a bug, you can force pip to accept earlier versions like so:\n• None Requirements files are used to override a dependency with a local patch that lives in version control. For example, suppose a dependency from PyPI has a bug, and you can’t wait for an upstream fix. You could clone/copy the src, make the fix, and place it in VCS with the tag . You’d reference it in your requirements file with a line like so: If was previously a top-level requirement in your requirements file, then replace that line with the new line. If is a sub-dependency, then add the new line. It’s important to be clear that pip determines package dependencies using install_requires metadata, not by discovering files embedded in projects.\n• None “setup.py vs requirements.txt” (an article by Donald Stufft)\n\nConstraints files are requirements files that only control which version of a requirement is installed, not whether it is installed or not. Their syntax and contents is a subset of Requirements Files, with several kinds of syntax not allowed: constraints must have a name, they cannot be editable, and they cannot specify extras. In terms of semantics, there is one key difference: Including a package in a constraints file does not trigger installation of the package. Use a constraints file like so: Constraints files are used for exactly the same reason as requirements files when you don’t know exactly what things you want to install. For instance, say that the “helloworld” package doesn’t work in your environment, so you have a local patched version. Some things you install depend on “helloworld”, and some don’t. One way to ensure that the patched version is used consistently is to manually audit the dependencies of everything you install, and if “helloworld” is present, write a requirements file to use when installing that thing. Constraints files offer a better way: write a single constraints file for your organisation and use that everywhere. If the thing being installed requires “helloworld” to be installed, your fixed version specified in your constraints file will be used. Constraints file support was added in pip 7.1. In Changes to the pip dependency resolver in 20.3 (2020) we did a fairly comprehensive overhaul, removing several undocumented and unsupported quirks from the previous implementation, and stripped constraints files down to being purely a way to specify global (version) limits for packages. Same as requirements files, constraints files can also be served via a URL, e.g. http://example.com/constraints.txt, so that your organization can store and serve them in a centralized place.\n\n“Wheel” is a built, archive format that can greatly speed installation compared to building and installing from source archives. For more information, see the specification. pip prefers Wheels where they are available. To disable this, use the --no-binary flag for pip install. If no satisfactory wheels are found, pip will default to finding source archives. To include optional dependencies provided in the metadata in the wheel, you must add quotes around the install target name: In the future, the syntax may become deprecated. It is recommended to use standard syntax wherever possible. For the cases where wheels are not available, pip offers pip wheel as a convenience, to build wheels for all your requirements and dependencies. pip wheel requires the wheel package to be installed, which provides the “bdist_wheel” setuptools extension that it uses. To build wheels for your requirements and all their dependencies to a local directory: And then to install those requirements just using your local directory of wheels (and not from PyPI):\n\nWith Python 2.6 came the “user scheme” for installation, which means that all Python distributions support an alternative install location that is specific to a user. The default location for each OS is explained in the python documentation for the site.USER_BASE variable. This mode of installation can be turned on by specifying the --user option to . Moreover, the “user scheme” can be customized by setting the environment variable, which updates the value of . To install “SomePackage” into an environment with customized to ‘/myappenv’, do the following:\n• None When globally installed packages are on the python path, and they conflict with the installation requirements, they are ignored, and not uninstalled.\n• None When globally installed packages are on the python path, and they satisfy the installation requirements, pip does nothing, and reports that requirement is satisfied (similar to how global packages can satisfy requirements when installing packages in a virtualenv).\n• None pip will not perform a install in a virtualenv (i.e. the default kind of virtualenv), due to the user site not being on the python path. The installation would be pointless.\n• None In a virtualenv, pip will not install a package that conflicts with a package in the virtualenv site-packages. The --user installation would lack sys.path precedence and be pointless. To make the rules clearer, here are some examples: From within a virtualenv (i.e. the default kind): python -m pip install --user SomePackage Can not perform a '--user' install. User site-packages are not visible in this virtualenv. Can not perform a '--user' install. User site-packages are not visible in this virtualenv. From within a virtualenv where is already installed in the virtualenv: python -m pip install --user .4 Will not install to the user site because it will lack sys.path precedence Will not install to the user site because it will lack sys.path precedence From within a real python, where is not installed globally: From within a real python, where is installed globally, but is not the latest version: python -m pip install --user SomePackage Requirement already satisfied (use --upgrade to upgrade) python -m pip install --user --upgrade SomePackage Requirement already satisfied (use --upgrade to upgrade) From within a real python, where is installed globally, and is the latest version: python -m pip install --user SomePackage Requirement already satisfied (use --upgrade to upgrade) python -m pip install --user --upgrade SomePackage force the install python -m pip install --user --ignore-installed SomePackage Requirement already satisfied (use --upgrade to upgrade) force the install This is now covered in Repeatable Installs. This is now covered in Dependency Resolution.\n\nUsing pip from your program¶ As noted previously, pip is a command line program. While it is implemented in Python, and so is available from your Python code via , you must not use pip’s internal APIs in this way. There are a number of reasons for this:\n• None The pip code assumes that it is in sole control of the global state of the program. pip manages things like the logging system configuration, or the values of the standard IO streams, without considering the possibility that user code might be affected.\n• None pip’s code is not thread safe. If you were to run pip in a thread, there is no guarantee that either your code or pip’s would work as you expect.\n• None pip assumes that once it has finished its work, the process will terminate. It doesn’t need to handle the possibility that other code will continue to run after that point, so (for example) calling pip twice in the same process is likely to have issues. This does not mean that the pip developers are opposed in principle to the idea that pip could be used as a library - it’s just that this isn’t how it was written, and it would be a lot of work to redesign the internals for use as a library, handling all of the above issues, and designing a usable, robust and stable API that we could guarantee would remain available across multiple releases of pip. And we simply don’t currently have the resources to even consider such a task. What this means in practice is that everything inside of pip is considered an implementation detail. Even the fact that the import name is is subject to change without notice. While we do try not to break things as much as possible, all the internal APIs can change at any time, for any reason. It also means that we generally won’t fix issues that are a result of using pip in an unsupported way. It should also be noted that installing packages into in a running Python process is something that should only be done with care. The import system caches certain data, and installing new packages while a program is running may not always behave as expected. In practice, there is rarely an issue, but it is something to be aware of. Having said all of the above, it is worth covering the options available if you decide that you do want to run pip from within your program. The most reliable approach, and the one that is fully supported, is to run pip in a subprocess. This is easily done using the standard module: If you want to process the output further, use one of the other APIs in the module. We are using freeze here which outputs installed packages in requirements format.: To programmatically monitor download progress use the option. This will print lines to stdout in the format , where and are integers and the unit is bytes. If the real total is unknown then is set to . Be aware that the specific formatting of pip’s outputs are not guaranteed to be the same in future versions. If you don’t want to use pip’s command line functionality, but are rather trying to implement code that works with Python packages, their metadata, or PyPI, then you should consider other, supported, packages that offer this type of ability. Some examples that you could consider include:\n• None - Utilities to work with standard package metadata (versions, requirements, etc.)\n• None (specifically ) - Functions for querying what packages the user has installed on their system.\n• None - Packaging and distribution utilities (including functions for interacting with PyPI)."
    },
    {
        "link": "https://docs.python.org/3/using/windows.html",
        "document": "This document aims to give an overview of Windows-specific behaviour you should know about when using Python on Microsoft Windows.\n\nUnlike most Unix systems and services, Windows does not include a system supported installation of Python. To make Python available, the CPython team has compiled Windows installers with every release for many years. These installers are primarily intended to add a per-user installation of Python, with the core interpreter and library being used by a single user. The installer is also able to install for all users of a single machine, and a separate ZIP file is available for application-local distributions.\n\nAs specified in PEP 11, a Python release only supports a Windows platform while Microsoft considers the platform under extended support. This means that Python 3.13 supports Windows 8.1 and newer. If you require Windows 7 support, please install Python 3.8.\n\nThere are a number of different installers available for Windows, each with certain benefits and downsides.\n\nThe full installer contains all components and is the best option for developers using Python for any kind of project.\n\nThe Microsoft Store package is a simple installation of Python that is suitable for running scripts and packages, and using IDLE or other development environments. It requires Windows 10 and above, but can be safely installed without corrupting other programs. It also provides many convenient commands for launching Python and its tools.\n\nThe nuget.org packages are lightweight installations intended for continuous integration systems. It can be used to build Python packages or run scripts, but is not updateable and has no user interface tools.\n\nThe embeddable package is a minimal package of Python suitable for embedding into a larger application.\n\nFour Python 3.13 installers are available for download - two each for the 32-bit and 64-bit versions of the interpreter. The web installer is a small initial download, and it will automatically download the required components as necessary. The offline installer includes the components necessary for a default installation and only requires an internet connection for optional features. See Installing Without Downloading for other ways to avoid downloading during installation. After starting the installer, one of two options may be selected:\n• None You will not need to be an administrator (unless a system update for the C Runtime Library is required or you install the Python Launcher for Windows for all users)\n• None Python will be installed into your user directory\n• None The Python Launcher for Windows will be installed according to the option at the bottom of the first page\n• None The standard library, test suite, launcher and pip will be installed\n• None If selected, the install directory will be added to your\n• None Shortcuts will only be visible for the current user Selecting “Customize installation” will allow you to select the features to install, the installation location and other options or post-install actions. To install debugging symbols or binaries, you will need to use this option. To perform an all-users installation, you should select “Customize installation”. In this case:\n• None You may be required to provide administrative credentials or approval\n• None Python will be installed into the Program Files directory\n• None The Python Launcher for Windows will be installed into the Windows directory\n• None Optional features may be selected during installation\n• None The standard library can be pre-compiled to bytecode\n• None If selected, the install directory will be added to the system\n• None Shortcuts are available for all users Windows historically has limited path lengths to 260 characters. This meant that paths longer than this would not resolve and errors would result. In the latest versions of Windows, this limitation can be expanded to approximately 32,000 characters. Your administrator will need to activate the “Enable Win32 long paths” group policy, or set to in the registry key . This allows the function, the module and most other path functionality to accept and return paths longer than 260 characters. After changing the above option, no further configuration is required. Changed in version 3.6: Support for long paths was enabled in Python. All of the options available in the installer UI can also be specified from the command line, allowing scripted installers to replicate an installation on many machines without user interaction. These options may also be set without suppressing the UI in order to change some of the defaults. The following options (found by executing the installer with ) can be passed into the installer: to install/uninstall without displaying any UI All other options are passed as , where the value is usually to disable a feature, to enable a feature, or a path. The full list of available options is shown below. The default custom install directory displayed in the UI Create file associations if the launcher is also installed. Prepend install and Scripts directories to and add to Append install and Scripts directories to and add to Create shortcuts for the interpreter, documentation and IDLE if installed. Install developer headers and libraries. Omitting this may lead to an unusable installation. Install and related files. Omitting this may lead to an unusable installation. Installs the launcher for all users. Also requires to be set to 1 Install standard library and extension modules. Omitting this may lead to an unusable installation. Only installs the launcher. This will override most other options. A custom message to display when the simplified install UI is used. For example, to silently install a default, system-wide Python installation, you could use the following command (from an elevated command prompt): To allow users to easily install a personal copy of Python without the test suite, you could provide a shortcut with the following command. This will display a simplified initial page and disallow customization: python-3.9.0.exe InstallAllUsers=0 Include_launcher=0 Include_test=0 SimpleInstall=1 SimpleInstallDescription=\"Just for me, no test suite.\" The options listed above can also be provided in a file named alongside the executable. This file specifies a list of options and values. When a value is provided as an attribute, it will be converted to a number if possible. Values provided as element text are always left as strings. This example file sets the same options as the previous example: Just for me, no test suite As some features of Python are not included in the initial installer download, selecting those features may require an internet connection. To avoid this need, all possible components may be downloaded on-demand to create a complete layout that will no longer require an internet connection regardless of the selected features. Note that this download may be bigger than required, but where a large number of installations are going to be performed it is very useful to have a locally cached copy. Execute the following command from Command Prompt to download all possible required files. Remember to substitute for the actual name of your installer, and to create layouts in their own directories to avoid collisions between files with the same name. You may also specify the option to hide the progress display. Once Python has been installed, you can add or remove features through the Programs and Features tool that is part of Windows. Select the Python entry and choose “Uninstall/Change” to open the installer in maintenance mode. “Modify” allows you to add or remove features by modifying the checkboxes - unchanged checkboxes will not install or remove anything. Some options cannot be changed in this mode, such as the install directory; to modify these, you will need to remove and then reinstall Python completely. “Repair” will verify all the files that should be installed using the current settings and replace any that have been removed or modified. “Uninstall” will remove Python entirely, with the exception of the Python Launcher for Windows, which has its own entry in Programs and Features. Everything described in this section is considered experimental, and should be expected to change in future releases. To install pre-built binaries with free-threading enabled (see PEP 703), you should select “Customize installation”. The second page of options includes the “Download free-threaded binaries” checkbox. Selecting this option will download and install additional binaries to the same location as the main Python install. The main executable is called , and other binaries either receive a suffix or a full ABI suffix. Python source files and bundled third-party dependencies are shared with the main install. The free-threaded version is registered as a regular Python install with the tag (with a or suffix as normal for those platforms). This allows tools to discover it, and for the Python Launcher for Windows to support . Note that the launcher will interpret (or a shebang) as “the latest 3.x install”, which will prefer the free-threaded binaries over the regular ones, while will not. If you use the short style of option, you may prefer to not install the free-threaded binaries at this time. To specify the install option at the command line, use . See Installing Without Downloading for instructions on pre-emptively downloading the additional binaries for offline install. The options to include debug symbols and binaries also apply to the free-threaded builds. Free-threaded binaries are also available on nuget.org.\n\nThe Microsoft Store package is an easily installable Python interpreter that is intended mainly for interactive use, for example, by students. To install the package, ensure you have the latest Windows 10 updates and search the Microsoft Store app for “Python 3.13”. Ensure that the app you select is published by the Python Software Foundation, and install it. Python will always be available for free on the Microsoft Store. If you are asked to pay for it, you have not selected the correct package. After installation, Python may be launched by finding it in Start. Alternatively, it will be available from any Command Prompt or PowerShell session by typing . Further, pip and IDLE may be used by typing or . IDLE can also be found in Start. All three commands are also available with version number suffixes, for example, as and as well as (where is the specific version you want to launch, such as 3.13). Open “Manage App Execution Aliases” through Start to select which version of Python is associated with each command. It is recommended to make sure that and are consistent with whichever version of is selected. Virtual environments can be created with and activated and used as normal. If you have installed another version of Python and added it to your variable, it will be available as rather than the one from the Microsoft Store. To access the new installation, use or . The launcher will detect this Python installation, but will prefer installations from the traditional installer. To remove Python, open Settings and use Apps and Features, or else find Python in Start and right-click to select Uninstall. Uninstalling will remove all packages you installed directly into this Python installation, but will not remove any virtual environments Because of restrictions on Microsoft Store apps, Python scripts may not have full write access to shared locations such as and the registry. Instead, it will write to a private copy. If your scripts must modify the shared locations, you will need to install the full installer. At runtime, Python will use a private copy of well-known Windows folders and the registry. For example, if the environment variable is , then when writing to will write to . When reading files, Windows will return the file from the private folder, or if that does not exist, the real Windows directory. For example reading returns the contents of plus the contents of . You can find the real path of any existing file using : When writing to the Windows Registry, the following behaviors exist:\n• None Reading from is allowed and results are merged with the file in the package.\n• None Writing to is not allowed if the corresponding key/value exists, i.e. modifying existing keys.\n• None Writing to is allowed as long as a corresponding key/value does not exist in the package and the user has the correct access permissions. For more detail on the technical basis for these limitations, please consult Microsoft’s documentation on packaged full-trust apps, currently available at docs.microsoft.com/en-us/windows/msix/desktop/desktop-to-uwp-behind-the-scenes\n\nThe nuget.org package is a reduced size Python environment intended for use on continuous integration and build systems that do not have a system-wide install of Python. While nuget is “the package manager for .NET”, it also works perfectly fine for packages containing build-time tools. Visit nuget.org for the most up-to-date information on using nuget. What follows is a summary that is sufficient for Python developers. The command line tool may be downloaded directly from , for example, using curl or PowerShell. With the tool, the latest version of Python for 64-bit or 32-bit machines is installed using: To select a particular version, add a . The output directory may be changed from , and the package will be installed into a subdirectory. By default, the subdirectory is named the same as the package, and without the option this name will include the specific version installed. Inside the subdirectory is a directory that contains the Python installation: In general, nuget packages are not upgradeable, and newer versions should be installed side-by-side and referenced using the full path. Alternatively, delete the package directory manually and install it again. Many CI systems will do this automatically if they do not preserve files between builds. Alongside the directory is a directory. This contains a MSBuild properties file that can be used in a C++ project to reference the Python install. Including the settings will automatically use the headers and import libraries in your build. The package information pages on nuget.org are www.nuget.org/packages/python for the 64-bit version, www.nuget.org/packages/pythonx86 for the 32-bit version, and www.nuget.org/packages/pythonarm64 for the ARM64 version Everything described in this section is considered experimental, and should be expected to change in future releases. Packages containing free-threaded binaries are named python-freethreaded for the 64-bit version, pythonx86-freethreaded for the 32-bit version, and pythonarm64-freethreaded for the ARM64 version. These packages contain both the and entry points, both of which run free threaded.\n\nThe embedded distribution is a ZIP file containing a minimal Python environment. It is intended for acting as part of another application, rather than being directly accessed by end-users. When extracted, the embedded distribution is (almost) fully isolated from the user’s system, including environment variables, system registry settings, and installed packages. The standard library is included as pre-compiled and optimized files in a ZIP, and , , and are all provided. Tcl/tk (including all dependents, such as Idle), pip and the Python documentation are not included. The embedded distribution does not include the Microsoft C Runtime and it is the responsibility of the application installer to provide this. The runtime may have already been installed on a user’s system previously or automatically via Windows Update, and can be detected by finding in the system directory. Third-party packages should be installed by the application installer alongside the embedded distribution. Using pip to manage dependencies as for a regular Python installation is not supported with this distribution, though with some care it may be possible to include and use pip for automatic updates. In general, third-party packages should be treated as part of the application (“vendoring”) so that the developer can ensure compatibility with newer versions before providing updates to users. The two recommended use cases for this distribution are described below. An application written in Python does not necessarily require users to be aware of that fact. The embedded distribution may be used in this case to include a private version of Python in an install package. Depending on how transparent it should be (or conversely, how professional it should appear), there are two options. Using a specialized executable as a launcher requires some coding, but provides the most transparent experience for users. With a customized launcher, there are no obvious indications that the program is running on Python: icons can be customized, company and version information can be specified, and file associations behave properly. In most cases, a custom launcher should simply be able to call with a hard-coded command line. The simpler approach is to provide a batch file or generated shortcut that directly calls the or with the required command-line arguments. In this case, the application will appear to be Python and not its actual name, and users may have trouble distinguishing it from other running Python processes or file associations. With the latter approach, packages should be installed as directories alongside the Python executable to ensure they are available on the path. With the specialized launcher, packages can be located in other locations as there is an opportunity to specify the search path before launching the application. Applications written in native code often require some form of scripting language, and the embedded Python distribution can be used for this purpose. In general, the majority of the application is in native code, and some part will either invoke or directly use . For either case, extracting the embedded distribution to a subdirectory of the application installation is sufficient to provide a loadable Python interpreter. As with the application use, packages can be installed to any location as there is an opportunity to specify search paths before initializing the interpreter. Otherwise, there is no fundamental differences between using the embedded distribution and a regular installation.\n\nTo run Python conveniently from a command prompt, you might consider changing some default environment variables in Windows. While the installer provides an option to configure the PATH and PATHEXT variables for you, this is only reliable for a single, system-wide installation. If you regularly use multiple versions of Python, consider using the Python Launcher for Windows. Windows allows environment variables to be configured permanently at both the User level and the System level, or temporarily in a command prompt. To temporarily set environment variables, open Command Prompt and use the set command: These changes will apply to any further commands executed in that console, and will be inherited by any applications started from the console. Including the variable name within percent signs will expand to the existing value, allowing you to add your new value at either the start or the end. Modifying by adding the directory containing python.exe to the start is a common way to ensure the correct version of Python is launched. To permanently modify the default environment variables, click Start and search for ‘edit environment variables’, or open System properties, Advanced system settings and click the Environment Variables button. In this dialog, you can add or modify User and System variables. To change System variables, you need non-restricted access to your machine (i.e. Administrator rights). Windows will concatenate User variables after System variables, which may cause unexpected results when modifying . The variable is used by all versions of Python, so you should not permanently configure it unless the listed paths only include code that is compatible with all of your installed Python versions. Besides using the automatically created start menu entry for the Python interpreter, you might want to start Python in the command prompt. The installer has an option to set that up for you. On the first page of the installer, an option labelled “Add Python to PATH” may be selected to have the installer add the install location into the . The location of the folder is also added. This allows you to type python to run the interpreter, and pip for the package installer. Thus, you can also execute your scripts with command line options, see Command line documentation. If you don’t enable this option at install time, you can always re-run the installer, select Modify, and enable it. Alternatively, you can manually modify the using the directions in Excursus: Setting environment variables. You need to set your environment variable to include the directory of your Python installation, delimited by a semicolon from other entries. An example variable could look like this (assuming the first two entries already existed):\n\nThe Python launcher for Windows is a utility which aids in locating and executing of different Python versions. It allows scripts (or the command-line) to indicate a preference for a specific Python version, and will locate and execute that version. Unlike the variable, the launcher will correctly select the most appropriate version of Python. It will prefer per-user installations over system-wide ones, and orders by language version rather than using the most recently installed version. The launcher was originally specified in PEP 397. System-wide installations of Python 3.3 and later will put the launcher on your . The launcher is compatible with all available versions of Python, so it does not matter which version is installed. To check that the launcher is available, execute the following command in Command Prompt: You should find that the latest version of Python you have installed is started - it can be exited as normal, and any additional command-line arguments specified will be sent directly to Python. If you have multiple versions of Python installed (e.g., 3.7 and 3.13) you will have noticed that Python 3.13 was started - to launch Python 3.7, try the command: If you want the latest version of Python 2 you have installed, try the command: If you see the following error, you do not have the launcher installed: 'py' is not recognized as an internal or external command, operable program or batch file. displays the currently installed version(s) of Python. The argument is the short form of the argument, which allows selecting a specific Python runtime, including those that may have come from somewhere other than python.org. Any runtime registered by following PEP 514 will be discoverable. The command lists all available runtimes using the format. When using the argument, specifying the Company will limit selection to runtimes from that provider, while specifying only the Tag will select from all providers. Note that omitting the slash implies a tag: The short form of the argument ( ) only ever selects from core Python releases, and not other distributions. However, the longer form ( ) will select from any. The Company is matched on the full string, case-insensitive. The Tag is matched on either the full string, or a prefix, provided the next character is a dot or a hyphen. This allows to match , but not . Tags are sorted using numerical ordering ( is newer than ), but are compared using text ( does not match ). If the launcher is run with no explicit Python version specification, and a virtual environment (created with the standard library module or the external tool) active, the launcher will run the virtual environment’s interpreter rather than the global one. To run the global interpreter, either deactivate the virtual environment, or explicitly specify the global Python version. Let’s create a test Python script - create a file called with the following contents From the directory in which hello.py lives, execute the command: You should notice the version number of your latest Python 2.x installation is printed. Now try changing the first line to be: Re-executing the command should now print the latest Python 3.x information. As with the above command-line examples, you can specify a more explicit version qualifier. Assuming you have Python 3.7 installed, try changing the first line to and you should find the 3.7 version information printed. Note that unlike interactive use, a bare “python” will use the latest version of Python 2.x that you have installed. This is for backward compatibility and for compatibility with Unix, where the command typically refers to Python 2. The launcher should have been associated with Python files (i.e. , , files) when it was installed. This means that when you double-click on one of these files from Windows explorer the launcher will be used, and therefore you can use the same facilities described above to have the script specify the version which should be used. The key benefit of this is that a single launcher can support multiple Python versions at the same time depending on the contents of the first line. If the first line of a script file starts with , it is known as a “shebang” line. Linux and other Unix like operating systems have native support for such lines and they are commonly used on such systems to indicate how a script should be executed. This launcher allows the same facilities to be used with Python scripts on Windows and the examples above demonstrate their use. To allow shebang lines in Python scripts to be portable between Unix and Windows, this launcher supports a number of ‘virtual’ commands to specify which interpreter to use. The supported virtual commands are: For example, if the first line of your script starts with The default Python or an active virtual environment will be located and used. As many Python scripts written to work on Unix will already have this line, you should find these scripts can be used by the launcher without modification. If you are writing a new script on Windows which you hope will be useful on Unix, you should use one of the shebang lines starting with . Any of the above virtual commands can be suffixed with an explicit version (either just the major version, or the major and minor version). Furthermore the 32-bit version can be requested by adding “-32” after the minor version. I.e. will request usage of the 32-bit Python 3.7. If a virtual environment is active, the version will be ignored and the environment will be used. Added in version 3.7: Beginning with python launcher 3.7 it is possible to request 64-bit version by the “-64” suffix. Furthermore it is possible to specify a major and architecture without minor (i.e. ). Changed in version 3.11: The “-64” suffix is deprecated, and now implies “any architecture that is not provably i386/32-bit”. To request a specific environment, use the new argument with the complete tag. Changed in version 3.13: Virtual commands referencing now prefer an active virtual environment rather than searching . This handles cases where the shebang specifies but is not present in the active environment. The form of shebang line has one further special property. Before looking for installed Python interpreters, this form will search the executable for a Python executable matching the name provided as the first argument. This corresponds to the behaviour of the Unix program, which performs a search. If an executable matching the first argument after the command cannot be found, but the argument starts with , it will be handled as described for the other virtual commands. The environment variable may be set (to any value) to skip this search of . Shebang lines that do not match any of these patterns are looked up in the section of the launcher’s .INI file. This may be used to handle certain commands in a way that makes sense for your system. The name of the command must be a single argument (no spaces in the shebang executable), and the value substituted is the full path to the executable (additional arguments specified in the .INI will be quoted as part of the filename). Any commands not found in the .INI file are treated as Windows executable paths that are absolute or relative to the directory containing the script file. This is a convenience for Windows-only scripts, such as those generated by an installer, since the behavior is not compatible with Unix-style shells. These paths may be quoted, and may include multiple arguments, after which the path to the script and any additional arguments will be appended. The shebang lines can also specify additional options to be passed to the Python interpreter. For example, if you have a shebang line: Then Python will be started with the option Two .ini files will be searched by the launcher - in the current user’s application data directory ( or ) and in the same directory as the launcher. The same .ini files are used for both the ‘console’ version of the launcher (i.e. py.exe) and for the ‘windows’ version (i.e. pyw.exe). Customization specified in the “application directory” will have precedence over the one next to the executable, so a user, who may not have write access to the .ini file next to the launcher, can override commands in that global .ini file. In some cases, a version qualifier can be included in a command to dictate which version of Python will be used by the command. A version qualifier starts with a major version number and can optionally be followed by a period (‘.’) and a minor version specifier. Furthermore it is possible to specify if a 32 or 64 bit implementation shall be requested by adding “-32” or “-64”. For example, a shebang line of has no version qualifier, while has a version qualifier which specifies only a major version. If no version qualifiers are found in a command, the environment variable can be set to specify the default version qualifier. If it is not set, the default is “3”. The variable can specify any value that may be passed on the command line, such as “3”, “3.7”, “3.7-32” or “3.7-64”. (Note that the “-64” option is only available with the launcher included with Python 3.7 or newer.) If no minor version qualifiers are found, the environment variable (where is the current major version qualifier as determined above) can be set to specify the full version. If no such option is found, the launcher will enumerate the installed Python versions and use the latest minor release found for the major version, which is likely, although not guaranteed, to be the most recently installed version in that family. On 64-bit Windows with both 32-bit and 64-bit implementations of the same (major.minor) Python version installed, the 64-bit version will always be preferred. This will be true for both 32-bit and 64-bit implementations of the launcher - a 32-bit launcher will prefer to execute a 64-bit Python installation of the specified version if available. This is so the behavior of the launcher can be predicted knowing only what versions are installed on the PC and without regard to the order in which they were installed (i.e., without knowing whether a 32 or 64-bit version of Python and corresponding launcher was installed last). As noted above, an optional “-32” or “-64” suffix can be used on a version specifier to change this behaviour.\n• None If no relevant options are set, the commands and will use the latest Python 2.x version installed and the command will use the latest Python 3.x installed.\n• None The command will not consult any options at all as the versions are fully specified.\n• None If , the commands and will both use the latest installed Python 3 version.\n• None If , the command will use the 32-bit implementation of 3.7 whereas the command will use the latest installed Python (PY_PYTHON was not considered at all as a major version was specified.)\n• None If and , the commands and will both use specifically 3.7 In addition to environment variables, the same settings can be configured in the .INI file used by the launcher. The section in the INI file is called and the key name will be the same as the environment variables without the leading prefix (and note that the key names in the INI file are case insensitive.) The contents of an environment variable will override things specified in the INI file.\n• None Setting is equivalent to the INI file containing:\n• None Setting and is equivalent to the INI file containing: If an environment variable is set (to any value), the launcher will print diagnostic information to stderr (i.e. to the console). While this information manages to be simultaneously verbose and terse, it should allow you to see what versions of Python were located, why a particular version was chosen and the exact command-line used to execute the target Python. It is primarily intended for testing and debugging. If an environment variable is set (to any value), the launcher will output the command it would have run, but will not actually launch Python. This may be useful for tools that want to use the launcher to detect and then launch Python directly. Note that the command written to standard output is always encoded using UTF-8, and may not render correctly in the console. If an environment variable is set (to any value), and the requested Python version is not installed but is available on the Microsoft Store, the launcher will attempt to install it. This may require user interaction to complete, and you may need to run the command again. An additional variable causes the launcher to always try to install Python, even if it is detected. This is mainly intended for testing (and should be used with ). The following exit codes may be returned by the Python launcher. Unfortunately, there is no way to distinguish these from the exit code of Python itself. The names of codes are as used in the sources, and are only for reference. There is no way to access or resolve them apart from reading this page. Entries are listed in alphabetical order of names. A was found but is corrupt. An install was started, but the command will need to be re-run after it completes. Unable to obtain command line from the operating system. A was required but not found.\n\nThese notes supplement the description at The initialization of the sys.path module search path with detailed Windows notes. When no file is found, this is how is populated on Windows:\n• None An empty entry is added at the start, which corresponds to the current directory.\n• None If the environment variable exists, as described in Environment variables, its entries are added next. Note that on Windows, paths in this variable must be separated by semicolons, to distinguish them from the colon used in drive identifiers ( etc.).\n• None Additional “application paths” can be added in the registry as subkeys of under both the and hives. Subkeys which have semicolon-delimited path strings as their default value will cause each path to be added to . (Note that all known installers only use HKLM, so HKCU is typically empty.)\n• None If the environment variable is set, it is assumed as “Python Home”. Otherwise, the path of the main Python executable is used to locate a “landmark file” (either or ) to deduce the “Python Home”. If a Python home is found, the relevant sub-directories added to ( , , etc) are based on that folder. Otherwise, the core Python path is constructed from the PythonPath stored in the registry.\n• None If the Python Home cannot be located, no is specified in the environment, and no registry entries can be found, a default path with relative entries is used (e.g. , etc). If a file is found alongside the main executable or in the directory one level above the executable, the following variations apply:\n• None If is an absolute path and is not set, this path is used instead of the path to the main executable when deducing the home location. The end result of all this is:\n• None When running , or any other .exe in the main Python directory (either an installed version, or directly from the PCbuild directory), the core path is deduced, and the core paths in the registry are ignored. Other “application paths” in the registry are always read.\n• None When Python is hosted in another .exe (different directory, embedded via COM, etc), the “Python Home” will not be deduced, so the core path from the registry is used. Other “application paths” in the registry are always read.\n• None If Python can’t find its home and there are no registry value (frozen .exe, some very strange installation setup) you get a path with some default, but relative, paths. For those who want to bundle Python into their application or distribution, the following advice will prevent conflicts with other installations:\n• None Include a file alongside your executable containing the directories to include. This will ignore paths listed in the registry and environment variables, and also ignore unless is listed.\n• None If you are loading or in your own executable, explicitly set before .\n• None Clear and/or overwrite and set before launching from your application.\n• None If you cannot use the previous suggestions (for example, you are a distribution that allows people to run directly), ensure that the landmark file ( ) exists in your install directory. (Note that it will not be detected inside a ZIP file, but a correctly named ZIP file will be detected instead.) These will ensure that the files in a system-wide installation will not take precedence over the copy of the standard library bundled with your application. Otherwise, your users may experience problems using your application. Note that the first suggestion is the best, as the others may still be susceptible to non-standard paths in the registry and user site-packages. Changed in version 3.6: Add file support and removes option from . Changed in version 3.6: Add as a potential landmark when directly adjacent to the executable. Deprecated since version 3.6: Modules specified in the registry under (not ) may be imported by . This finder is enabled on Windows in 3.6.0 and earlier, but may need to be explicitly added to in the future."
    }
]