[
    {
        "link": "https://stackhawk.com/blog/node-js-sql-injection-guide-examples-and-prevention",
        "document": "Node.js is a fantastic runtime platform for developing accessible and uncomplicated applications and services, offering all the flexibility and benefits of working with JavaScript. The fact that its source is both open and supported by Microsoft, Google, and IBM provides this decade-old technology a lot of credibility. Yet it is not invulnerable to attacks like SQL injection.\n\nOf course, no platform is perfect. Moreover, vulnerabilities like these are mainly introduced into systems by poor development practices. Which is why developers must nowadays be aware of their impact and mitigate them appropriately. For that purpose, this article will serve as an introduction to SQL injection attacks for beginners and a refresher for more seasoned developers.\n\nWe will briefly examine what SQL injection is and what a SQL injection attack looks like. We'll also discuss measures to prevent them. If you have never worked on Node.js or JavaScript, I recommend taking some time to familiarize yourself with them. Nevertheless, the concepts of SQL injection are pretty consistent across platforms and .\n\nFirst, let's briefly explain what SQL injection is.\n\nSQL injection is an attack that takes advantage of poor database integration infrastructure and lackluster user input validation. Malicious SQL instructions injected directly into the system's SQL database through user-facing input fields can take over a system. The main goal of a SQL injection attack is to manipulate the data in the database, force the system to present its data, or both.\n\nGiven that these attacks target the system database and, when successful, can provide access to the database, the potential impact is evident. One could be excused for believing that these attacks are very complex and are used only rarely. However, most SQL injection attacks are not particularly sophisticated or rare. In fact, the opposite is true.\n\nLet's look at a simple SQL injection attack that could target any system that allows user input.\n\nImagine you have code in your model layer or database integration layer where you retrieve user information by formatting the following SQL query command:\n\nquery = 'SELECT * FROM Users WHERE Email = \"' + USERNAME + '\" AND Pass = \"' + PASSWORD + '\";'\n\nThis simple query command would typically search through the users table and retrieve the user who intends to log in. However, a hacker could take advantage of the lack of validation from user inputs by inputting values that the developer did not foresee a valid user would use.\n\nFor example, let's say you input something like the following:\n\nThe system would then return all users in the table.\n\nAs you can see, there is little complexity or intricacy in this attack. It lives and dies on simple input validation. However, this doesn't mean that SQL injection attacks can't be complex or be part of a more powerful, more sophisticated attack.\n\nIf you want to read more about SQL injection, you can read where we go into more details about it.\n\nWhat SQL Injection Attacks Look Like in Node.js\n\nHow can you spot a SQL injection vulnerability in your Node.js code?\n\nIt's not hard when you know how it works, and the database layer is where the most glaring problems usually are.\n\nTake this code, for example:\n\nThis will process a post request to the records endpoint and find user records matching the IDs provided.\n\nNow can you spot the issues with this implementation?\n\nAs we saw in the previous section, allowing unescaped and unsanitized input into the query command must be avoided at all costs.\n\nBesides the \"\"=\"\" attacks that we explored already, a few more forms of injection attacks are widespread. Hackers can use them to successfully target a vulnerable system if they have enough knowledge of the database structure after some trial and error.\n• None\n• None SELECT * FROM Users WHERE UserId = 105 OR 1=1;\n• None\n• None SELECT * FROM health_records WHERE date = '22/04/1999'; -- ' AND id = 33\n\nIf you want to learn more and see examples of these attacks, you can find some .\n\nNow that you have a basic understanding of how SQL injection attacks take advantage of our systems, let's look at how we can prevent them or mitigate their impact.\n\nFirst, we need to address the user input validation implemented in our user-facing front-end code. This validation would be our first layer of defense against bad actors and serve as a responsive interaction mechanism for users struggling with interface intuitiveness.\n\nMake sure that the values provided by the user are scoped and sanitized for each field accordingly. That means, for example, that if an input field is intended to receive emails, it does not allow the user to submit the form if an invalid email address—or no value at all—is set.\n\nA simple example would look like this:\n\nOf course, this approach can be expanded with input masks and responsive form styling to tell the user that the value provided is not valid and to inform the user what is expected.\n\nSecond, input validation can be implemented at the control level, where most of the calculations are done. This strategy could be as simple as revalidating and, when appropriate, sanitizing the user input before it reaches the model layer. Additionally, adding a third-party library like \"node-mysql\" that implements escaping automatically also helps.\n\nOnce the issues at the top level are addressed, we can then secure the database layer. To do that, all we need to do is implement what are known as query placeholders or name placeholders. These placeholders, indicated here with the ? symbol, tell the interfacing layer to automatically escape the input passed to it before it is inserted into the query.\n\nIf we expand on the previous example, we can address the issue with a simple change to the code.\n\nIt's a subtle change, but it has a significant impact on the security of our code.\n\nWhile using query parameters is a best practice to avoid SQL injection attacks, it is not fool-proof. Malicious inputs sent to your application can take advantage of the flexibility in how some Node libraries handle type conversions of query parameters.\n\nFor example, take a look at this code example written for the express framework that handles login authentication. This example comes from the article Finding an unseen SQL Injection by bypassing escape functions in mysqljs/mysql\n\nThis code seems secure. However, a request with the following payload would allow a hacker to gain access to the application without a password:\n\nIn this example, the attacker is passing in a value that gets evaluated as an Object instead of a String value, and results in the following SQL query:\n\nSELECT * FROM accounts WHERE username = 'admin' AND password = `password` = 1\n\nThe part evaluates to TRUE and is a 1=1 attack.\n\nTo protect yourself from this type of attack, it's best to check that the variables you are passing to query parameters are of the data type that you expect. The following code snippet adds some type checking to ensure both values are strings, and will prevent the 1=1 vulnerability:\n\nValidating that your query parameters are of the correct data type as well as doing input validation gives you the best protection against SQL injection.\n\nWe've explored the risks that involve SQL injection attacks and the various ways to counter them, and here's a recap of what you should do:\n• None Implement input validation and field masking at the view level.\n• None Ensure that your model layer properly uses placeholders.\n• None Avoid insecure packages that have access to the database.\n• None Enforce security policies and best practices with your team.\n\nIn the end, complying with proper SQL injection prevention practices is relatively straightforward. Depending on the size and complexity of the codebase, however, your mileage might vary. Nevertheless, the time investment that this protection requires will pay dividends for years to come.\n\nThis post was written by Juan Reyes. is an engineer by profession and a dreamer by heart who crossed the seas to reach Japan following the promise of opportunity and challenge. While trying to find himself and build a meaningful life in the east, Juan borrows wisdom from his experiences as an entrepreneur, artist, hustler, father figure, husband, and friend to start writing about passion, meaning, self-development, leadership, relationships, and mental health. His many years of struggle and self-discovery have inspired him and drive to embark on a journey for wisdom."
    },
    {
        "link": "https://planetscale.com/blog/how-to-prevent-sql-injection-attacks-in-node-js",
        "document": "How to Prevent SQL Injection Attacks in Node.js\n\nAlthough the tooling around databases has come a long way, it is still your responsibility to protect them against attacks. In this article, you’ll learn to prevent SQL injection attacks in Node.js using the mysql2 npm package.\n\nA SQL injection attack happens when a user injects malicious bits of SQL into your database queries. Most commonly, this happens when allowing a user to pass input to a database query without validation which can alter the original intended query. By injecting their own SQL, the user can cause harm by:\n\nAs you can probably imagine, these types of attacks can have negative impacts on your applications and your business. In fact, you’ve probably heard of some major companies being involved in data breaches in the past couple of years. This can lead to loss of customers, revenue, application uptime, and more.\n\nYou now have a general understanding of what SQL injection attacks are, but I think it would be good to see a few specific examples.\n\nLet’s explore a developer related-scenario where, hypothetically, you build an application that stores code repositories. Just like GitHub, these user-created repositories can be either public or private. Furthermore, a user has the ability to search public repositories by tag. For simplicity, let’s assume that each repository only has one tag.\n\nIn your application logic, you would use the user’s search term to generate the SQL query. In your Node.js code, you might be tempted to use ES6 template literal strings to interpolate that value directly to your query string like so:\n\nFor a search of \"javascript\", your SQL query string might look like this:\n\nIn this case, you are attempting to select all public repositories that have “javascript” as their tag. Assuming reasonable user input, this works fine, but what if the user were to search for something like this . Now, things start to become dangerous.\n\nThe is the SQL code for a comment. This means that it would then shortcut the rest of the query. So, the unvalidated query would look like this.\n\nSince the part after the \"--\" would be ignored, the query that gets executed looks more like this.\n\nAs you can see, this removed the additional clause in the query which previously prevented private repositories from being included. You can imagine this being a significant problem for intellectual property.\n\nOne other type of SQL injection attack to be aware of is one that can add a secondary statement to the query. Let’s stay with the same example, but say the user searches for . Then, the query would become:\n\nIn this example, the original query is terminated with the but then followed by a second query that would drop the entire table. NO GOOD!\n\nFor notes on a few other examples of SQL injection attacks, check the W3Schools SQL Injection page.\n\nFor a quick reference, let’s take a look at how to set up the client in Node.js. You’ll first want to install the package:\n\nOnce you have this package installed, you can initialize the client.\n\nFrom there, you can make queries like so:\n\nIf you’re working with Express.js, you could then define an endpoint that accepts user input as , queries the database, and returns the repositories in JSON format.\n\nThere are a few common ways to prevent SQL injection attacks:\n• Use placeholders instead of variable interpolation\n\nDon’t allow multiple statements if you can avoid it\n\nConveniently, number 1 is handled by the client (and many other database clients). It prevents multiple statements from being executed by default. So, even if the user submits an input that attempts to terminate a query and run a second one, the second one won’t run. This is the default configuration, but you can override that if you choose.\n\nTo emphasize the need for more levels of protection, refer to the example above where injecting a comment (ex. ) into the SQL allowed the user to read from private repositories. Since that was done using only one statement, setting still wouldn’t be enough.\n\nTherefore, you should never accept raw input from a user and input it directly into your query string. Instead, you should use placeholders ( ) (or parametrized queries) which would look like this (notice the as the placeholder):\n\nBy using placeholders, the malicious SQL will be escaped and treated as a raw string, not as actual SQL code. The end result query would look like this:\n\nThanks to using placeholders, the malicious SQL is not run and instead, is treated as a search query as intended.\n\nIn addition to using placeholders, you can add logic in your applications to prevent invalid user input. Let’s stick with the example of querying public repositories by tag. For demo purposes, you can assume that you should not have a tag that includes special characters or numbers. In other words, tags should only use capital and lowercase letters (A-Z, a-z).\n\nThis means you can add logic to your application to validate that user input matches the correct formatting (no numbers and no special characters). To do this, you can create a regex pattern to match the user input. If it doesn’t match, return an error.\n\nNow the code doesn’t even get to the SQL part unless a valid input is passed. You can apply this method with any sort of validation that is relevant to your data. For example, if you allow the user to query by an property which should be a number, you can throw an error if the input isn’t a valid number.\n\nOne last option you have is to use allowlisting, a specific type of input validation. Allowlisting is useful if you know every possible valid user input. From there, you can easily reject anything else.\n\nFor example, let’s say for your repository tags, there are only three valid tags: “javascript”, “html”, and “css”. If that’s the case, then you can check whether or not the user input is \"allowlisted\" by comparing it against known valid inputs.\n\nYes, this example is a bit simplified with just three valid tags, but this works at scale as well. A more realistic scenario might be that you store all known tags in their own table in your database. Then, to validate the user input, you can check against all the tag records in your database.\n\nHopefully, this helped give you a good overview of what SQL injection attacks are and how to prevent them. They can be detrimental to your application and business, so it’s important to plan ahead when accepting user input for your database queries to prevent any negative side effects."
    },
    {
        "link": "https://stackoverflow.com/questions/15778572/preventing-sql-injection-in-node-js",
        "document": "Is it possible to prevent SQL injections in Node.js (preferably with a module) in the same way that PHP had Prepared Statements that protected against them.\n\nIf so, how? If not, what are some examples that might bypass the code I've provided (see below).\n\nI'm making a web application with a back-end stack consisting of Node.js + MySql using the node-mysql module. From a usability perspective, the module is great, but it has not yet implemented something akin to PHP's Prepared Statements (though I'm aware it is on the todo).\n\nFrom my understanding, PHP's implementation of prepared statements, among other things, helped greatly in the prevention of SQL injections. I'm worried, though, that my node.js app may be open to similar attacks, even with the string escaping provided by default (as in the code snippet below).\n\nnode-mysql seems to be the most popular mysql connector for node.js, so I was wondering what other people might be doing (if anything) to account for this issue - or if it is even an issue with node.js to begin with (not sure how this wouldn't be, since user/client-side input is involved).\n\nShould I switch to node-mysql-native for the time being, since it does provide prepared statements? I'm hesitant to do this, because it does not seem to be as active as node-mysql (though that may just mean that it is complete).\n\nHere is a snippet of user registration code, which uses the sanitizer module, along with node-mysql's prepared statement-like syntax (which, as I mentioned above, does character escaping), to prevent cross site scripting and sql injections, respectively:"
    },
    {
        "link": "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html",
        "document": "This cheat sheet will help you prevent SQL injection flaws in your applications. It will define what SQL injection is, explain where those flaws occur, and provide four options for defending against SQL injection attacks. SQL Injection attacks are common because:\n• SQL Injection vulnerabilities are very common, and\n• The application's database is a frequent target for attackers because it typically contains interesting/critical data.\n\nAttackers can use SQL injection on an application if it has dynamic database queries that use string concatenation and user supplied input. To avoid SQL injection flaws, developers need to:\n• Prevent malicious SQL input from being included in executed queries.\n\nThere are simple techniques for preventing SQL injection vulnerabilities and they can be used with practically any kind of programming language and any type of database. While XML databases can have similar problems (e.g., XPath and XQuery injection), these techniques can be used to protect them as well.\n\nA common SQL injection flaw in Java is below. Because its unvalidated \"customerName\" parameter is simply appended to the query, an attacker can enter SQL code into that query and the application would take the attacker's code and execute it on the database.\n• Option 1: Use of Prepared Statements (with Parameterized Queries)\n\nWhen developers are taught how to write database queries, they should be told to use prepared statements with variable binding (aka parameterized queries). Prepared statements are simple to write and easier to understand than dynamic queries, and parameterized queries force the developer to define all SQL code first and pass in each parameter to the query later.\n\nIf database queries use this coding style, the database will always distinguish between code and data, regardless of what user input is supplied. Also, prepared statements ensure that an attacker cannot change the intent of a query, even if SQL commands are inserted by an attacker.\n\nIn the safe Java example below, if an attacker were to enter the userID as , the parameterized query would look for a username that literally matches the entire string . Thus, the database would be protected against injections of malicious SQL code.\n\nThe following code example uses a , Java's implementation of a parameterized query, to execute the same database query.\n\nIn .NET, the creation and execution of the query doesn't change. Just pass the parameters to the query using the call as shown below.\n\nWhile we have shown examples in Java and .NET, practically all other languages (including Cold Fusion and Classic ASP) support parameterized query interfaces. Even SQL abstraction layers, like the Hibernate Query Language (HQL) with the same type of injection problems (called HQL Injection) support parameterized queries as well:\n\nIf you need examples of prepared queries/parameterized languages, including Ruby, PHP, Cold Fusion, Perl, and Rust, see the Query Parameterization Cheat Sheet or this site.\n\nGenerally, developers like prepared statements because all the SQL code stays within the application, which makes applications relatively database independent.\n\nThough stored procedures are not always safe from SQL injection, developers can use certain standard stored procedure programming constructs. This approach has the same effect as using parameterized queries, as long as the stored procedures are implemented safely (which is the norm for most stored procedure languages).\n\nIf stored procedures are needed, the safest approach to using them requires the developer to build SQL statements with parameters that are automatically parameterized, unless the developer does something largely out of the norm. The difference between prepared statements and stored procedures is that the SQL code for a stored procedure is defined and stored in the database itself, then called from the application. Since prepared statements and safe stored procedures are equally effective in preventing SQL injection, your organization should choose the approach that makes the most sense for you.\n\nOccasionally, stored procedures can increase risk when a system is attacked. For example, on MS SQL Server, you have three main default roles: , and . Before stored procedures came into use, DBAs would give or rights to the webservice's user, depending on the requirements.\n\nHowever, stored procedures require execute rights, a role not available by default. In some setups where user management has been centralized, but is limited to those 3 roles, web apps would have to run as so stored procedures could work. Naturally, that means that if a server is breached, the attacker has full rights to the database, where previously, they might only have had read-access.\n\nThe following code example uses Java's implementation of the stored procedure interface ( ) to execute the same database query. The stored procedure has to be predefined in the database and use the same functionality as the query above.\n\nThe following code example uses a , .NET's implementation of the stored procedure interface, to execute the same database query. The stored procedure must be predefined in the database and use the same functionality as the query defined above.\n\nIf you are faced with parts of SQL queries that can't use bind variables, such as table names, column names, or sort order indicators (ASC or DESC), input validation or query redesign is the most appropriate defense. When table or column names are needed, ideally those values come from the code and not from user parameters.\n\nWARNING: Using user parameter values to target table or column names is a symptom of poor design and a full rewrite should be considered if time allows. If that is not possible, developers should map the parameter values to the legal/expected table or column names to make sure unvalidated user input doesn't end up in the query.\n\nIn the example below, since is identified as one of the legal and expected values for a table name in this query, it can be directly appended to the SQL query. Keep in mind that generic table validation functions can lead to data loss if table names are used in queries where they are not expected.\n\nWhen we say a stored procedure is \"implemented safely,\" that means it does not include any unsafe dynamic SQL generation. Developers do not usually generate dynamic SQL inside stored procedures. However, it can be done, but should be avoided.\n\nIf it can't be avoided, the stored procedure must use input validation or proper escaping, as described in this article, to make sure that all user supplied input to the stored procedure can't be used to inject SQL code into the dynamically generated query. Auditors should always look for uses of , or within SQL Server stored procedures. Similar audit guidelines are necessary for similar functions for other vendors.\n\nFor something simple like a sort order, it is best if the user supplied input is converted to a boolean, and then that boolean is used to select the safe value to append to the query. This is a very standard need in dynamic query creation.\n\nAny time user input can be converted to a non-String, like a date, numeric, boolean, enumerated type, etc. before it is appended to a query, or used to select a value to append to the query, this ensures it is safe to do so.\n\nInput validation is also recommended as a secondary defense in ALL cases, even when using bind variables as discussed earlier in this article. More techniques on how to implement strong input validation is described in the Input Validation Cheat Sheet.\n\nIn this approach, the developer will escape all user input before putting it in a query. It is very database specific in its implementation. This methodology is frail compared to other defenses, and we CANNOT guarantee that this option will prevent all SQL injections in all situations.\n\nIf an application is built from scratch or requires low risk tolerance, it should be built or re-written using parameterized queries, stored procedures, or some kind of Object Relational Mapper (ORM) that builds your queries for you.\n\nBeyond adopting one of the four primary defenses, we also recommend adopting all of these additional defenses to provide defense in depth. These additional defenses are:\n\nTo minimize the potential damage of a successful SQL injection attack, you should minimize the privileges assigned to every database account in your environment. Start from the ground up to determine what access rights your application accounts require, rather than trying to figure out what access rights you need to take away.\n\nMake sure that accounts that only need read access are only granted read access to the tables they need access to. DO NOT ASSIGN DBA OR ADMIN TYPE ACCESS TO YOUR APPLICATION ACCOUNTS. We understand that this is easy, and everything just \"works\" when you do it this way, but it is very dangerous.\n\nSQL injection is not the only threat to your database data. Attackers can simply change the parameter values from one of the legal values they are presented with, to a value that is unauthorized for them, but the application itself might be authorized to access. As such, minimizing the privileges granted to your application will reduce the likelihood of such unauthorized access attempts, even when an attacker is not trying to use SQL injection as part of their exploit.\n\nWhile you are at it, you should minimize the privileges of the operating system account that the DBMS runs under. Don't run your DBMS as root or system! Most DBMSs run out of the box with a very powerful system account. For example, MySQL runs as system on Windows by default! Change the DBMS's OS account to something more appropriate, with restricted privileges.\n\nDetails Of Least Privilege When Developing¶\n\nIf an account only needs access to portions of a table, consider creating a view that limits access to that portion of the data and assigning the account access to the view instead of the underlying table. Rarely, if ever, grant create or delete access to database accounts.\n\nIf you adopt a policy where you use stored procedures everywhere, and don't allow application accounts to directly execute their own queries, then restrict those accounts to only be able to execute the stored procedures they need. Don't grant them any rights directly to the tables in the database.\n\nThe designers of web applications should avoid using the same owner/admin account in the web applications to connect to the database. Different DB users should be used for different web applications.\n\nIn general, each separate web application that requires access to the database should have a designated database user account that the application will use to connect to the DB. That way, the designer of the application can have good granularity in the access control, thus reducing the privileges as much as possible. Each DB user will then have select access to only what it needs, and write-access as needed.\n\nAs an example, a login page requires read access to the username and password fields of a table, but no write access of any form (no insert, update, or delete). However, the sign-up page certainly requires insert privilege to that table; this restriction can only be enforced if these web apps use different DB users to connect to the database.\n\nYou can use SQL views to further increase the granularity of access by limiting the read access to specific fields of a table or joins of tables. It could have additional benefits.\n\nFor example, if the system is required (perhaps due to some specific legal requirements) to store the passwords of the users, instead of salted-hashed passwords, the designer could use views to compensate for this limitation. They could revoke all access to the table (from all DB users except the owner/admin) and create a view that outputs the hash of the password field and not the field itself.\n\nAny SQL injection attack that succeeds in stealing DB information will be restricted to stealing the hash of the passwords (could even be a keyed hash), since no DB user for any of the web applications has access to the table itself.\n\nIn addition to being a primary defense when nothing else is possible (e.g., when a bind variable isn't legal), input validation can also be a secondary defense used to detect unauthorized input before it is passed to the SQL query. For more information please see the Input Validation Cheat Sheet. Proceed with caution here. Validated data is not necessarily safe to insert into SQL queries via string building.\n\nThe following articles describe how to exploit different kinds of SQL injection vulnerabilities on various platforms (that this article was created to help you avoid):\n• OWASP Developers Guide article on how to avoid SQL injection vulnerabilities\n• OWASP Cheat Sheet that provides numerous language specific examples of parameterized queries using both Prepared Statements and Stored Procedures\n• The Bobby Tables site (inspired by the XKCD webcomic) has numerous examples in different languages of parameterized Prepared Statements and Stored Procedures\n\nHow to Review Code for SQL Injection Vulnerabilities:\n• OWASP Code Review Guide article on how to Review Code for SQL Injection Vulnerabilities\n\nHow to Test for SQL Injection Vulnerabilities:\n• OWASP Testing Guide article on how to Test for SQL Injection Vulnerabilities"
    },
    {
        "link": "https://stackoverflow.com/questions/3913837/best-way-to-prevent-sql-injection-using-javascript-or-c",
        "document": "The lack of security of Javascript validation has got nothing to do with the fact that Javascript might be turned off.\n\nThat Javascript might be turned off means that an honest mistake may do something wrong, or result in a default server message rather than a helpful one. While they could accidentally trigger a security issue (I have actually done this as a user, the worse bit is my input was valid, but one of the people whose names I was entering had a in it, more on that below). This affects honest but imperfect users, not crackers.\n\nA cracker should be able to replay an AJAX request with different values in around 30seconds, including time spent making stupid threats on social media sites in another window. It's not technically difficult. That's why Javascript validation has no security value, and is solely to make the validation for honest mistakes more user-friendly (by having a more immediate response, and being able to direct focus to the incorrect field).\n\nFurther, this is generally not a matter of validation, but of encoding. Some people try to \"fix\" SQL injection attacks by banning the sequences that can cause them, which most often means banning apostrophe characters. Then they put this logic onto fields that might reasonably contain apostrophes. In particular, never do this with name fields; people really don't like being told that their name is \"wrong\" and at worse it can feel like racism or cultural insensitivity, since you will find them a lot in e.g. French or Irish names but not so often in English or German names (yes I know English names of Norman origin often having them, but I have also heard people with apostrophes in their names ranting about the stupid racist website that won't let them input their name correctly, which is probably the worse time to bring up the Normans as a correction).\n\nValidate for the obviously wrong in Javascript as a means to improve UI.\n\nValidate for the obviously wrong on the server as both a means to improve UI and a means to catch attacks.\n\nPass your data to other layers in the correct manner. In terms of SQL this would mean encoding string delimiters (again, is the most common case, but some other delimiters are possible with some databases), for which the best means of doing so is through a library that does so for you. In the case of C# this would mean using with ADO.NET rather than building SQL yourself (there are other advantages to this too)."
    },
    {
        "link": "https://expressjs.com/en/resources/middleware/body-parser.html",
        "document": "Parse incoming request bodies in a middleware before your handlers, available under the property.\n\nNote As ’s shape is based on user-controlled input, all properties and values in this object are untrusted and should be validated before trusting. For example, may fail in multiple ways, for example the property may not be there or may not be a string, and may not be a function and instead a string or other user input.\n\nLearn about the anatomy of an HTTP transaction in Node.js.\n\nThis does not handle multipart bodies, due to their complex and typically large nature. For multipart bodies, you may be interested in the following modules:\n\nThis module provides the following parsers:\n\nOther body parsers you might be interested in:\n\nThe object exposes various factories to create middlewares. All middlewares will populate the property with the parsed body when the request header matches the option.\n\nThe various errors returned by this module are described in the errors section.\n\nReturns middleware that only parses and only looks at requests where the header matches the option. This parser accepts any Unicode encoding of the body and supports automatic inflation of , (brotli) and encodings.\n\nA new object containing the parsed data is populated on the object after the middleware (i.e. ).\n\nThe function takes an optional object that may contain any of the following keys:\n\nWhen set to , then deflated (compressed) bodies will be inflated; when , deflated bodies are rejected. Defaults to .\n\nControls the maximum request body size. If this is a number, then the value specifies the number of bytes; if it is a string, the value is passed to the bytes library for parsing. Defaults to .\n\nThe option is passed directly to as the second argument. You can find more information on this argument in the MDN documentation about JSON.parse.\n\nWhen set to , will only accept arrays and objects; when will accept anything accepts. Defaults to .\n\nThe option is used to determine what media type the middleware will parse. This option can be a string, array of strings, or a function. If not a function, option is passed directly to the type-is library and this can be an extension name (like ), a mime type (like ), or a mime type with a wildcard (like or ). If a function, the option is called as and the request is parsed if it returns a truthy value. Defaults to .\n\nThe option, if supplied, is called as , where is a of the raw request body and is the encoding of the request. The parsing can be aborted by throwing an error.\n\nReturns middleware that parses all bodies as a and only looks at requests where the header matches the option. This parser supports automatic inflation of , (brotli) and encodings.\n\nA new object containing the parsed data is populated on the object after the middleware (i.e. ). This will be a object of the body.\n\nThe function takes an optional object that may contain any of the following keys:\n\nWhen set to , then deflated (compressed) bodies will be inflated; when , deflated bodies are rejected. Defaults to .\n\nControls the maximum request body size. If this is a number, then the value specifies the number of bytes; if it is a string, the value is passed to the bytes library for parsing. Defaults to .\n\nThe option is used to determine what media type the middleware will parse. This option can be a string, array of strings, or a function. If not a function, option is passed directly to the type-is library and this can be an extension name (like ), a mime type (like ), or a mime type with a wildcard (like or ). If a function, the option is called as and the request is parsed if it returns a truthy value. Defaults to .\n\nThe option, if supplied, is called as , where is a of the raw request body and is the encoding of the request. The parsing can be aborted by throwing an error.\n\nReturns middleware that parses all bodies as a string and only looks at requests where the header matches the option. This parser supports automatic inflation of , (brotli) and encodings.\n\nA new string containing the parsed data is populated on the object after the middleware (i.e. ). This will be a string of the body.\n\nThe function takes an optional object that may contain any of the following keys:\n\nSpecify the default character set for the text content if the charset is not specified in the header of the request. Defaults to .\n\nWhen set to , then deflated (compressed) bodies will be inflated; when , deflated bodies are rejected. Defaults to .\n\nControls the maximum request body size. If this is a number, then the value specifies the number of bytes; if it is a string, the value is passed to the bytes library for parsing. Defaults to .\n\nThe option is used to determine what media type the middleware will parse. This option can be a string, array of strings, or a function. If not a function, option is passed directly to the type-is library and this can be an extension name (like ), a mime type (like ), or a mime type with a wildcard (like or ). If a function, the option is called as and the request is parsed if it returns a truthy value. Defaults to .\n\nThe option, if supplied, is called as , where is a of the raw request body and is the encoding of the request. The parsing can be aborted by throwing an error.\n\nReturns middleware that only parses bodies and only looks at requests where the header matches the option. This parser accepts only UTF-8 encoding of the body and supports automatic inflation of , (brotli) and encodings.\n\nA new object containing the parsed data is populated on the object after the middleware (i.e. ). This object will contain key-value pairs, where the value can be a string or array (when is ), or any type (when is ).\n\nThe function takes an optional object that may contain any of the following keys:\n\nThe “extended” syntax allows for rich objects and arrays to be encoded into the URL-encoded format, allowing for a JSON-like experience with URL-encoded. For more information, please see the qs library.\n\nWhen set to , then deflated (compressed) bodies will be inflated; when , deflated bodies are rejected. Defaults to .\n\nControls the maximum request body size. If this is a number, then the value specifies the number of bytes; if it is a string, the value is passed to the bytes library for parsing. Defaults to .\n\nThe option controls the maximum number of parameters that are allowed in the URL-encoded data. If a request contains more parameters than this value, a 413 will be returned to the client. Defaults to .\n\nThe option is used to determine what media type the middleware will parse. This option can be a string, array of strings, or a function. If not a function, option is passed directly to the type-is library and this can be an extension name (like ), a mime type (like ), or a mime type with a wildcard (like ). If a function, the option is called as and the request is parsed if it returns a truthy value. Defaults to .\n\nThe option, if supplied, is called as , where is a of the raw request body and is the encoding of the request. The parsing can be aborted by throwing an error.\n\nThe default charset to parse as, if not specified in content-type. Must be either or . Defaults to .\n\nWhether to let the value of the parameter take precedence as the charset selector. It requires the form to contain a parameter named with a value of . Defaults to .\n\nWhether to decode numeric entities such as when parsing an iso-8859-1 form. Defaults to .\n\nThe option is used to configure the maximum depth of the library when is . This allows you to limit the amount of keys that are parsed and can be useful to prevent certain types of abuse. Defaults to . It is recommended to keep this value as low as possible.\n\nThe middlewares provided by this module create errors using the module. The errors will typically have a / property that contains the suggested HTTP response code, an property to determine if the property should be displayed to the client, a property to determine the type of error without matching against the , and a property containing the read body, if available.\n\nThe following are the common errors created, though any error can come through for various reasons.\n\nThis error will occur when the request had a header that contained an encoding but the “inflation” option was set to . The property is set to , the property is set to , and the property will be set to the encoding that is unsupported.\n\nThis error will occur when the request contained an entity that could not be parsed by the middleware. The property is set to , the property is set to , and the property is set to the entity value that failed parsing.\n\nThis error will occur when the request contained an entity that could not be failed verification by the defined option. The property is set to , the property is set to , and the property is set to the entity value that failed verification.\n\nThis error will occur when the request is aborted by the client before reading the body has finished. The property will be set to the number of bytes received before the request was aborted and the property is set to the number of expected bytes. The property is set to and property is set to .\n\nThis error will occur when the request body’s size is larger than the “limit” option. The property will be set to the byte limit and the property will be set to the request body’s length. The property is set to and the property is set to .\n\nThis error will occur when the request’s length did not match the length from the header. This typically occurs when the request is malformed, typically when the header was calculated based on characters instead of bytes. The property is set to and the property is set to .\n\nstream encoding should not be set\n\nThis error will occur when something called the method prior to this middleware. This module operates directly on bytes only and you cannot call when using this module. The property is set to and the property is set to .\n\nThis error will occur when the request is no longer readable when this middleware attempts to read it. This typically means something other than a middleware from this module read the request body already and the middleware was also configured to read the same request. The property is set to and the property is set to .\n\nThis error will occur when the content of the request exceeds the configured for the parser. The property is set to and the property is set to .\n\nThis error will occur when the request had a charset parameter in the header, but the module does not support it OR the parser does not support it. The charset is contained in the message as well as in the property. The property is set to , the property is set to , and the property is set to the charset that is unsupported.\n\nThis error will occur when the request had a header that contained an unsupported encoding. The encoding is contained in the message as well as in the property. The property is set to , the property is set to , and the property is set to the encoding that is unsupported.\n\nThis error occurs when using with the property set to and the input exceeds the configured option. The property is set to . It is recommended to review the option and evaluate if it requires a higher value. When the option is set to (default value), the error will not be thrown.\n\nThis example demonstrates adding a generic JSON and URL-encoded parser as a top-level middleware, which will parse the bodies of all incoming requests. This is the simplest setup.\n\nThis example demonstrates adding body parsers specifically to the routes that need them. In general, this is the most recommended way to use body-parser with Express.\n\nAll the parsers accept a option which allows you to change the that the middleware will parse."
    },
    {
        "link": "https://github.com/expressjs/body-parser",
        "document": "Parse incoming request bodies in a middleware before your handlers, available under the property.\n\nNote As 's shape is based on user-controlled input, all properties and values in this object are untrusted and should be validated before trusting. For example, may fail in multiple ways, for example the property may not be there or may not be a string, and may not be a function and instead a string or other user input.\n\nLearn about the anatomy of an HTTP transaction in Node.js.\n\nThis does not handle multipart bodies, due to their complex and typically large nature. For multipart bodies, you may be interested in the following modules:\n\nThis module provides the following parsers:\n\nOther body parsers you might be interested in:\n\nThe object exposes various factories to create middlewares. All middlewares will populate the property with the parsed body when the request header matches the option.\n\nThe various errors returned by this module are described in the errors section.\n\nReturns middleware that only parses and only looks at requests where the header matches the option. This parser accepts any Unicode encoding of the body and supports automatic inflation of , (brotli) and encodings.\n\nA new object containing the parsed data is populated on the object after the middleware (i.e. ).\n\nThe function takes an optional object that may contain any of the following keys:\n\nWhen set to , then deflated (compressed) bodies will be inflated; when , deflated bodies are rejected. Defaults to .\n\nControls the maximum request body size. If this is a number, then the value specifies the number of bytes; if it is a string, the value is passed to the bytes library for parsing. Defaults to .\n\nThe option is passed directly to as the second argument. You can find more information on this argument in the MDN documentation about JSON.parse.\n\nWhen set to , will only accept arrays and objects; when will accept anything accepts. Defaults to .\n\nThe option is used to determine what media type the middleware will parse. This option can be a string, array of strings, or a function. If not a function, option is passed directly to the type-is library and this can be an extension name (like ), a mime type (like ), or a mime type with a wildcard (like or ). If a function, the option is called as and the request is parsed if it returns a truthy value. Defaults to .\n\nThe option, if supplied, is called as , where is a of the raw request body and is the encoding of the request. The parsing can be aborted by throwing an error.\n\nReturns middleware that parses all bodies as a and only looks at requests where the header matches the option. This parser supports automatic inflation of , (brotli) and encodings.\n\nA new object containing the parsed data is populated on the object after the middleware (i.e. ). This will be a object of the body.\n\nThe function takes an optional object that may contain any of the following keys:\n\nWhen set to , then deflated (compressed) bodies will be inflated; when , deflated bodies are rejected. Defaults to .\n\nControls the maximum request body size. If this is a number, then the value specifies the number of bytes; if it is a string, the value is passed to the bytes library for parsing. Defaults to .\n\nThe option is used to determine what media type the middleware will parse. This option can be a string, array of strings, or a function. If not a function, option is passed directly to the type-is library and this can be an extension name (like ), a mime type (like ), or a mime type with a wildcard (like or ). If a function, the option is called as and the request is parsed if it returns a truthy value. Defaults to .\n\nThe option, if supplied, is called as , where is a of the raw request body and is the encoding of the request. The parsing can be aborted by throwing an error.\n\nReturns middleware that parses all bodies as a string and only looks at requests where the header matches the option. This parser supports automatic inflation of , (brotli) and encodings.\n\nA new string containing the parsed data is populated on the object after the middleware (i.e. ). This will be a string of the body.\n\nThe function takes an optional object that may contain any of the following keys:\n\nSpecify the default character set for the text content if the charset is not specified in the header of the request. Defaults to .\n\nWhen set to , then deflated (compressed) bodies will be inflated; when , deflated bodies are rejected. Defaults to .\n\nControls the maximum request body size. If this is a number, then the value specifies the number of bytes; if it is a string, the value is passed to the bytes library for parsing. Defaults to .\n\nThe option is used to determine what media type the middleware will parse. This option can be a string, array of strings, or a function. If not a function, option is passed directly to the type-is library and this can be an extension name (like ), a mime type (like ), or a mime type with a wildcard (like or ). If a function, the option is called as and the request is parsed if it returns a truthy value. Defaults to .\n\nThe option, if supplied, is called as , where is a of the raw request body and is the encoding of the request. The parsing can be aborted by throwing an error.\n\nReturns middleware that only parses bodies and only looks at requests where the header matches the option. This parser accepts only UTF-8 encoding of the body and supports automatic inflation of , (brotli) and encodings.\n\nA new object containing the parsed data is populated on the object after the middleware (i.e. ). This object will contain key-value pairs, where the value can be a string or array (when is ), or any type (when is ).\n\nThe function takes an optional object that may contain any of the following keys:\n\nThe \"extended\" syntax allows for rich objects and arrays to be encoded into the URL-encoded format, allowing for a JSON-like experience with URL-encoded. For more information, please see the qs library.\n\nWhen set to , then deflated (compressed) bodies will be inflated; when , deflated bodies are rejected. Defaults to .\n\nControls the maximum request body size. If this is a number, then the value specifies the number of bytes; if it is a string, the value is passed to the bytes library for parsing. Defaults to .\n\nThe option controls the maximum number of parameters that are allowed in the URL-encoded data. If a request contains more parameters than this value, a 413 will be returned to the client. Defaults to .\n\nThe option is used to determine what media type the middleware will parse. This option can be a string, array of strings, or a function. If not a function, option is passed directly to the type-is library and this can be an extension name (like ), a mime type (like ), or a mime type with a wildcard (like ). If a function, the option is called as and the request is parsed if it returns a truthy value. Defaults to .\n\nThe option, if supplied, is called as , where is a of the raw request body and is the encoding of the request. The parsing can be aborted by throwing an error.\n\nThe default charset to parse as, if not specified in content-type. Must be either or . Defaults to .\n\nWhether to let the value of the parameter take precedence as the charset selector. It requires the form to contain a parameter named with a value of . Defaults to .\n\nWhether to decode numeric entities such as when parsing an iso-8859-1 form. Defaults to .\n\nThe option is used to configure the maximum depth of the library when is . This allows you to limit the amount of keys that are parsed and can be useful to prevent certain types of abuse. Defaults to . It is recommended to keep this value as low as possible.\n\nThe middlewares provided by this module create errors using the module. The errors will typically have a / property that contains the suggested HTTP response code, an property to determine if the property should be displayed to the client, a property to determine the type of error without matching against the , and a property containing the read body, if available.\n\nThe following are the common errors created, though any error can come through for various reasons.\n\nThis error will occur when the request had a header that contained an encoding but the \"inflation\" option was set to . The property is set to , the property is set to , and the property will be set to the encoding that is unsupported.\n\nThis error will occur when the request contained an entity that could not be parsed by the middleware. The property is set to , the property is set to , and the property is set to the entity value that failed parsing.\n\nThis error will occur when the request contained an entity that could not be failed verification by the defined option. The property is set to , the property is set to , and the property is set to the entity value that failed verification.\n\nThis error will occur when the request is aborted by the client before reading the body has finished. The property will be set to the number of bytes received before the request was aborted and the property is set to the number of expected bytes. The property is set to and property is set to .\n\nThis error will occur when the request body's size is larger than the \"limit\" option. The property will be set to the byte limit and the property will be set to the request body's length. The property is set to and the property is set to .\n\nThis error will occur when the request's length did not match the length from the header. This typically occurs when the request is malformed, typically when the header was calculated based on characters instead of bytes. The property is set to and the property is set to .\n\nThis error will occur when something called the method prior to this middleware. This module operates directly on bytes only and you cannot call when using this module. The property is set to and the property is set to .\n\nThis error will occur when the request is no longer readable when this middleware attempts to read it. This typically means something other than a middleware from this module read the request body already and the middleware was also configured to read the same request. The property is set to and the property is set to .\n\nThis error will occur when the content of the request exceeds the configured for the parser. The property is set to and the property is set to .\n\nThis error will occur when the request had a charset parameter in the header, but the module does not support it OR the parser does not support it. The charset is contained in the message as well as in the property. The property is set to , the property is set to , and the property is set to the charset that is unsupported.\n\nThis error will occur when the request had a header that contained an unsupported encoding. The encoding is contained in the message as well as in the property. The property is set to , the property is set to , and the property is set to the encoding that is unsupported.\n\nThis error occurs when using with the property set to and the input exceeds the configured option. The property is set to . It is recommended to review the option and evaluate if it requires a higher value. When the option is set to (default value), the error will not be thrown.\n\nThis example demonstrates adding a generic JSON and URL-encoded parser as a top-level middleware, which will parse the bodies of all incoming requests. This is the simplest setup.\n\nThis example demonstrates adding body parsers specifically to the routes that need them. In general, this is the most recommended way to use body-parser with Express.\n\nAll the parsers accept a option which allows you to change the that the middleware will parse."
    },
    {
        "link": "https://expressjs.com/en/api.html",
        "document": "Creates an Express application. The function is a top-level function exported by the module.\n\nThe object conventionally denotes the Express application. Create it by calling the top-level function exported by the Express module:\n\nThe object has methods for\n• Routing HTTP requests; see for example, app.METHOD and app.param.\n\nIt also has settings (properties) that affect how the application behaves; for more information, see Application settings.\n\nAdd callback triggers to route parameters, where is the name of the parameter or an array of them, and is the callback function. The parameters of the callback function are the request object, the response object, the next middleware, the value of the parameter and the name of the parameter, in that order. If is an array, the trigger is registered for each parameter declared in it, in the order in which they are declared. Furthermore, for each declared parameter except the last one, a call to inside the callback will call the callback for the next declared parameter. For the last parameter, a call to will call the next middleware in place for the route currently being processed, just like it would if were just a string. For example, when is present in a route path, you may map user loading logic to automatically provide to the route, or perform validations on the parameter input. // try to get the user details from the User model and attach it to the request object Param callback functions are local to the router on which they are defined. They are not inherited by mounted apps or routers, nor are they triggered for route parameters inherited from parent routers. Hence, param callbacks defined on will be triggered only by route parameters defined on routes. All param callbacks will be called before any handler of any route in which the param occurs, and they will each be called only once in a request-response cycle, even if the parameter is matched in multiple routes, as shown in the following examples. On , the following is printed: CALLED ONLY ONCE although this matches and this matches too On , the following is printed: CALLED ONLY ONCE with 42 CALLED ONLY ONCE with 3 although this matches and this matches too The following section describes , which is deprecated as of v4.11.0. The behavior of the method can be altered entirely by passing only a function to . This function is a custom implementation of how should behave - it accepts two parameters and must return a middleware. The first parameter of this function is the name of the URL parameter that should be captured, the second parameter can be any JavaScript object which might be used for returning the middleware implementation. The middleware returned by the function decides the behavior of what happens when a URL parameter is captured. In this example, the signature is modified to . Instead of accepting a name and a callback, will now accept a name and a number. In this example, the signature remains the same, but instead of a middleware callback, a custom data type checking function has been defined to validate the data type of the user id. The ‘ ’ character can’t be used to capture a character in your capturing regexp. For example you can’t use to capture , use or instead (as in . // captures '1-a_6' and '543-az(ser\"-sder' but not '5-a s'\n\nThe object represents the HTTP request and has properties for the request query string, parameters, body, HTTP headers, and so on. In this documentation and by convention, the object is always referred to as (and the HTTP response is ) but its actual name is determined by the parameters to the callback function in which you’re working.\n\nBut you could just as well have:\n\nThe object is an enhanced version of Node’s own request object and supports all built-in fields and methods.\n\nThe object represents the HTTP response that an Express app sends when it gets an HTTP request.\n\nIn this documentation and by convention, the object is always referred to as (and the HTTP request is ) but its actual name is determined by the parameters to the callback function in which you’re working.\n\nBut you could just as well have:\n\nThe object is an enhanced version of Node’s own response object and supports all built-in fields and methods."
    },
    {
        "link": "https://expressjs.com.cn/resources/middleware/body-parser.html",
        "document": ""
    },
    {
        "link": "https://expressjs.com/en/resources/middleware.html",
        "document": "The Express middleware modules listed here are maintained by the Expressjs team.\n\nThese are some additional popular middleware modules.\n\nThis information refers to third-party sites, products, or modules that are not maintained by the Expressjs team. Listing here does not constitute an endorsement or recommendation from the Expressjs project team."
    }
]