[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Scripting/JSON",
        "document": "JavaScript Object Notation (JSON) is a standard text-based format for representing structured data based on JavaScript object syntax. It is commonly used for transmitting data in web applications (e.g., sending some data from the server to the client, so it can be displayed on a web page, or vice versa). You'll come across it quite often, so in this article, we give you all you need to work with JSON using JavaScript, including parsing JSON so you can access data within it, and creating JSON. An understanding of HTML and the fundamentals of CSS, familiarity with JavaScript basics as covered in previous lessons.\n• What JSON is — a very commonly used data format based on JavaScript object syntax.\n• That JSON can also contain arrays.\n• Retrieve JSON as a JavaScript object using mechanisms available in Web APIs (for example, in the Fetch API).\n• Converting between objects and text using and .\n\nNo, really, what is JSON? JSON is a text-based data format following JavaScript object syntax. It represents structured data as a string, which is useful when you want to transmit data across a network. Even though it closely resembles JavaScript object literal syntax, it can be used independently from JavaScript. Many programming environments feature the ability to read (parse) and generate JSON. In JavaScript, the methods for parsing and generating JSON are provided by the object. Note: Converting a string to a native object is called deserialization, while converting a native object to a string so it can be transmitted across the network is called serialization. A JSON string can be stored in its own file, which is basically just a text file with an extension of , and a MIME type of .\n\nAs described above, JSON is a string whose format very much resembles JavaScript object literal format. The following is a valid JSON string representing an object. Note how it is also a valid JavaScript object literal — just with some more syntax restrictions. { \"squadName\": \"Super hero squad\", \"homeTown\": \"Metro City\", \"formed\": 2016, \"secretBase\": \"Super tower\", \"active\": true, \"members\": [ { \"name\": \"Molecule Man\", \"age\": 29, \"secretIdentity\": \"Dan Jukes\", \"powers\": [\"Radiation resistance\", \"Turning tiny\", \"Radiation blast\"] }, { \"name\": \"Madame Uppercut\", \"age\": 39, \"secretIdentity\": \"Jane Wilson\", \"powers\": [ \"Million tonne punch\", \"Damage resistance\", \"Superhuman reflexes\" ] }, { \"name\": \"Eternal Flame\", \"age\": 1000000, \"secretIdentity\": \"Unknown\", \"powers\": [ \"Immortality\", \"Heat Immunity\", \"Inferno\", \"Teleportation\", \"Interdimensional travel\" ] } ] } If you load this JSON in your JavaScript program as a string, you can parse it into a normal object and then access the data inside it using the same dot/bracket notation we looked at in the JavaScript object basics article. For example:\n• First, we have the variable name — .\n• Inside that, we want to access the property, so we use .\n• contains an array populated by objects. We want to access the second object inside the array, so we use .\n• Inside this object, we want to access the property, so we use .\n• Inside the property is an array containing the selected hero's superpowers. We want the third one, so we use . The key takeaway is that there's really nothing special about working with JSON; after you've parsed it into a JavaScript object, you work with it just like you would with an object declared using the same object literal syntax. Note: We've made the JSON seen above available inside a variable in our JSONTest.html example (see the source code). Try loading this up and then accessing data inside the variable via your browser's JavaScript console.\n\nAbove we mentioned that JSON text basically looks like a JavaScript object inside a string. We can also convert arrays to/from JSON. The below example is perfectly valid JSON: You have to access array items (in its parsed version) by starting with an array index, for example . The JSON can also contain a single primitive. For example, , , or are all valid JSON.\n\nTo begin with, make local copies of our heroes.html and style.css files. The latter contains some simple CSS to style our page, while the former contains some very simple body HTML, plus a element to contain the JavaScript code we will be writing in this exercise: We have made our JSON data available on our GitHub, at https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json. We are going to load the JSON into our script, and use some nifty DOM manipulation to display it, like this:\n\nThe top-level function looks like this: To obtain the JSON, we use an API called Fetch. This API allows us to make network requests to retrieve resources from a server via JavaScript (e.g. images, text, JSON, even HTML snippets), meaning that we can update small sections of content without having to reload the entire page. In our function, the first four lines use the Fetch API to fetch the JSON from the server:\n• we declare the variable to store the GitHub URL\n• we use the URL to initialize a new object.\n• we make the network request using the function, and this returns a object\n• we retrieve the response as JSON using the function of the object. Note: The API is asynchronous. You can learn about asynchronous functions in detail in our Asynchronous JavaScript module, but for now, we'll just say that we need to add the keyword before the name of the function that uses the fetch API, and add the keyword before the calls to any asynchronous functions. After all that, the variable will contain the JavaScript object based on the JSON. We are then passing that object to two function calls — the first one fills the with the correct data, while the second one creates an information card for each hero on the team, and inserts it into the .\n\nNow that we've retrieved the JSON data and converted it into a JavaScript object, let's make use of it by writing the two functions we referenced above. First of all, add the following function definition below the previous code: Here we first create an h1 element with , set its to equal the property of the object, then append it to the header using . We then do a very similar operation with a paragraph: create it, set its text content and append it to the header. The only difference is that its text is set to a template literal containing both the and properties of the object.\n\nNext, add the following function at the bottom of the code, which creates and displays the superhero cards: function populateHeroes(obj) { const section = document.querySelector(\"section\"); const heroes = obj.members; for (const hero of heroes) { const myArticle = document.createElement(\"article\"); const myH2 = document.createElement(\"h2\"); const myPara1 = document.createElement(\"p\"); const myPara2 = document.createElement(\"p\"); const myPara3 = document.createElement(\"p\"); const myList = document.createElement(\"ul\"); myH2.textContent = hero.name; myPara1.textContent = `Secret identity: ${hero.secretIdentity}`; myPara2.textContent = `Age: ${hero.age}`; myPara3.textContent = \"Superpowers:\"; const superPowers = hero.powers; for (const power of superPowers) { const listItem = document.createElement(\"li\"); listItem.textContent = power; myList.appendChild(listItem); } myArticle.appendChild(myH2); myArticle.appendChild(myPara1); myArticle.appendChild(myPara2); myArticle.appendChild(myPara3); myArticle.appendChild(myList); section.appendChild(myArticle); } } To start with, we store the property of the JavaScript object in a new variable. This array contains multiple objects that contain the information for each hero. Next, we use a for...of loop to loop through each object in the array. For each one, we:\n• Create several new elements: an , an , three s, and a .\n• Set the to contain the current hero's .\n• Fill the three paragraphs with their , , and a line saying \"Superpowers:\" to introduce the information in the list.\n• Store the property in another new constant called — this contains an array that lists the current hero's superpowers.\n• Use another loop to loop through the current hero's superpowers — for each one we create an element, put the superpower inside it, then put the inside the element ( ) using .\n• The very last thing we do is to append the , s, and inside the ( ), then append the inside the . The order in which things are appended is important, as this is the order they will be displayed inside the HTML. Note: If you are having trouble getting the example to work, try referring to our heroes-finished.html source code (see it running live also.) Note: If you are having trouble following the dot/bracket notation we are using to access the JavaScript object, it can help to have the superheroes.json file open in another tab or your text editor, and refer to it as you look at our JavaScript. You should also refer back to our JavaScript object basics article for more information on dot and bracket notation.\n\nThe above example was simple in terms of accessing the JavaScript object, because we converted the network response directly into a JavaScript object using . But sometimes we aren't so lucky — sometimes we receive a raw JSON string, and we need to convert it to an object ourselves. And when we want to send a JavaScript object across the network, we need to convert it to JSON (a string) before sending it. Luckily, these two problems are so common in web development that a built-in JSON object is available in browsers, which contains the following two methods:\n• : Accepts a JSON string as a parameter, and returns the corresponding JavaScript object.\n• : Accepts an object as a parameter, and returns the equivalent JSON string. You can see the first one in action in our heroes-finished-json-parse.html example (see the source code) — this does exactly the same thing as the example we built up earlier, except that:\n• we retrieve the response as text rather than JSON, by calling the method of the response\n• we then use to convert the text to a JavaScript object. The key snippet of code is here: As you might guess, works the opposite way. Try entering the following lines into your browser's JavaScript console one by one to see it in action: let myObj = { name: \"Chris\", age: 38 }; myObj; let myString = JSON.stringify(myObj); myString; Here we're creating a JavaScript object, then checking what it contains, then converting it to a JSON string using — saving the return value in a new variable — then checking it again."
    },
    {
        "link": "https://medium.com/@AlexanderObregon/best-practices-for-json-formatting-and-code-readability-f5e769e3d051",
        "document": "JSON (JavaScript Object Notation) is a lightweight data interchange format that is easy for humans to read and write, and easy for machines to parse and generate. Making sure your JSON code is well-formatted and readable can make a significant difference when it comes to debugging and maintaining your applications. In this article we’ll look at some best practices for JSON formatting and code readability.\n\nIndentation is crucial for code readability. It helps developers easily identify the structure and hierarchy of the JSON data. A common practice is to use two or four spaces for each level of indentation.\n\nKeep Keys and Values on the Same Line\n\nWhen defining a key-value pair in JSON, keep both the key and value on the same line to maintain readability. This makes it easier to scan the JSON code and quickly understand its structure.\n\nAdopting a consistent naming convention for keys in your JSON data is essential. Common conventions include camelCase, snake_case, or kebab-case. Choose one that best fits your project and stick to it throughout.\n\nOrganizing keys in a specific order, such as alphabetically or logically, can greatly improve readability. Logical ordering refers to grouping related keys together, such as placing all address-related keys in one section.\n\nUtilize JSON linters and formatters to automatically enforce consistent formatting and identify syntax errors. Popular tools include JSONLint, Prettier, and Visual Studio Code’s built-in JSON formatter.\n\nProper JSON formatting and code readability are essential to maintain and debug your applications efficiently. By adhering to these best practices, you’ll create more readable JSON code, making it easier for you and your team to work with. Remember to use indentation, keep keys and values on the same line, adopt consistent naming conventions, organize keys, and utilize linters and formatters for a more efficient workflow."
    },
    {
        "link": "https://jsonlint.com/mastering-json-format",
        "document": "Mastering JSON Format: Advantages, Best Practices and Comparison with Other Data Formats\n\nJSON, standing for JavaScript Object Notation, is already a big player in today's era of data interchange. I'll delve into what makes JSON so standout. It's a text-based, language-independent format that allows for the easy and structured exchange of information. Boasting simplicity and being exceptionally lightweight, JSON is king when it comes to data transfer across your favorite web applications.\n\nOne undeniable charm of JSON is its compatibility. It's like that friend we all need — flexible and gets along with everyone. Whether you're coding in Python, JavaScript, or C++, JSON functions seamlessly across these and many more languages. Importantly, its plain text nature makes it readable to both humans and machines.\n\nThe beauty of JSON lies in its structure. Information is stored in a \"key: value\" pair format, which in essence is like a collection of Lego blocks. These 'blocks' or data objects can be assembled in various ways to form meaningful data structures.\n\nAn example of a simple JSON object could be:\n\nThis structure makes JSON adaptable and extendable. You can add, modify, and delete key-value pairs without disrupting the system, offering unparalleled flexibility in data storage.\n\nIn addition to supporting these object structures, JSON also supports arrays (ordered sequence of values), which further simplifies complex data representation. For instance, if you wanted to add job details for John Doe, it’d look something like this:\n\nLeveraging the power of arrays and objects, JSON can efficiently store virtually any data structure. Indeed, it is the backbone that drives today's internet, actively shaping the ways we store, retrieve, and process data.\n\nLooking into the wonderful world of JSON, it's clear there are a multitude of benefits when using this format. Let's dive deeper into why JSON makes such a significant impact in data interchange.\n\nFirstly, simplicity and readability play a key role in JSON's popularity. The structure is easy-to-follow, mimicking a simple key-value pair that anyone, coder or not, can grasp. It's this simplicity that helps developers quickly read, write or edit the data - a feature that doesn't go unnoticed in the fast-paced world of technology.\n\nJSON also shines in its compatibility with various programming languages. Languages such as JavaScript, Python, Ruby and many others natively support JSON. What does this mean? Simply put, JSON can readily integrate with these languages without any need for additional libraries. Now that's efficient.\n\nAnother winning feature of JSON is its support for arrays and objects. This ability to handle complex data through a recognized syntax makes JSON superior in data representation to many other formats. Whether you're dealing with multi-level arrays or nested objects, JSON has you covered.\n\nOne more advantage of JSON to highlight is its lightweight nature. JSON's format, without the need for end tags or closing tags, leads to reduced data redundancy and less data overall. This means faster data transmission and smoother execution – an essential requirement in today's digital age.\n\nIn this internet era, JSON's importance in shaping how data is stored, retrieved, and processed is undeniable. From simple inventory lists to intricate game data, JSON delivers with reliability and flexibility.\n\nAs we delve further into the nitty-gritty of JSON, it's paramount we draw comparisons between JSON and other data formats. Two main competitors of JSON that come to mind are XML and CSV. Understanding where JSON stands in relation to these will help define its unique value more accurately.\n\nXML, just like JSON, is human-readable and used widely for data exchange. But where JSON really shines is in its simplicity. Rather than the verbose and complex syntax of XML that can quickly clutter your screen, JSON stays minimal and clean, something I absolutely appreciate. JSON's format is also more condense which leads to quicker data transmissions.\n\nWell, then we have CSV. While it's true that CSV files are typically smaller, they lack the depth of JSON. In a CSV, it's challenging to represent hierarchical or multi-dimensional data. JSON, on the other hand, as we discussed earlier, has robust support for arrays and objects. It's like comparing a black-and-white photo to a 3D movie; the depth that JSON provides far outshines a mere CSV's capabilities.\n\nLet's not forget one of JSON's formidable advantages - compatibility with various programming languages. XML requires parsers to be readable in different programming languages, and CSV files often need custom parsing solutions, both of which can be cumbersome for developers. With JSON, that isn't necessary - it's supported natively in many programming languages, easing integration and reducing development time.\n\nBut before we lean too far into JSON's corner, it's worth mentioning that there are scenarios where other formats may be more suitable. Binary formats like Protobuf or Avro might provide better performance for massive or complex datasets. The world of data formats isn't black and white - there are shades of grey that give room for all, each with its own use cases.\n\nMoving forward, we'll dissect how JSON is leveraged in web development, and its role in shaping APIs. By highlighting its advantages and pointing out certain usage pitfalls, this deep dive into JSON seeks to arm you with the knowledge to efficiently utilize JSON in your own projects.\n\nUnderstanding the syntax is fundamental to appreciating JSON's beauty. It's this simplicity and readability that make JSON a desirable format. JSON structures data in name-value pairs, much like a JavaScript object. Yet, it's not limited to a particular set of programming languages. Its universal syntax is what allowed me to integrate it in various environments easily.\n\nThe first thing to look at is data types that JSON supports. It can handle simple data types like strings, numbers, and Booleans – true or false. At the same time, it embraces compound types such as arrays and other JSON objects. Being adept with these data types can make the information representation more effective.\n\nLet's take a look at a JSON object:\n\nIn this JSON object, you can see different types of data. The name is a string, the age a number, isVaccinated a Boolean, and familyNames an array of strings.\n\nWhen it comes to arrays, they are enclosed in square brackets. Each value is separated by a comma. Here's an example of a JSON array:\n\nThis array represents a list of people, each person being a JSON object itself.\n\nNext, we'll discuss how the JSON format shapes the landscape of web development, and how it’s used in creating user-friendly and feature-rich APIs. For developers seeking to use JSON in their projects, gaining a good grasp of the format and its syntax will be time well spent.\n\nParsing JSON data is a crucial skill in web development, making it an area that I must delve into due to its immense importance. It's necessary to understand that the process varies depending on the programming language you're using. In this regard, let's look at parsing JSON data using two popular languages, JavaScript and Python.\n\nParsing in JavaScript is straightforward. JavaScript natively supports JSON through the JSON object. To parse JSON using JavaScript, developers use the JSON.parse() method, converting the JSON data into a JavaScript object.\n\nIn this JavaScript example, we are converting a JSON string into a JavaScript object using the JSON.parse method. The alert function then displays the name value, \"John\".\n\nParsing in Python, on the other hand, requires the python 'json' library. Developers invoke the json.loads() method to parse JSON data.\n\nIn our Python example, after importing the json module, we invoke the json.loads() function to parse the JSON data into a python dictionary. The print function then outputs the name value, which is \"John\".\n\nTake note that converting JSON data into another data structure (for instance, a Python dictionary or JavaScript object) is called deserialization. It's an essential part of using JSON format in web development, allowing you to process the data as per your needs. As you work with JSON, remember to keep the syntax rules in mind to ensure data integrity. The ease with which JSON integrates into your coding process is what makes it a front runner in data interchange formats.\n\nMoving onward, let's delve into a crucial element associated with JSON - that's right, we're talking about JSON schema validation. This integral feature of JSON ensures code standardization, guarantees the integrity of data, and promotes a smooth coding process.\n\nSo what is JSON schema validation? Essentially, it's a powerful tool that validates your JSON data and checks if it adheres to the predefined specifications. And yes, it does all of this before you import that data into your JavaScript or Python environments, saving you from potential headaches.\n\nHere's how it works. When you're transferring data between applications using JSON, the data structure should be predictable and standardized. JSON schema validation, as its name suggests, is like a blueprint or a model for your data. It outlines what your data should look like - what elements it should contain, what data types those elements should be, whether certain fields are required or optional, and even the acceptable range of values for certain elements.\n\nApplying JSON schema validation can significantly improve your overall coding experience. It enables you to catch and address inconsistencies and errors early on, reducing debugging efforts. It helps maintain consistent data structures across multiple applications, which really comes in handy for large-scale projects involving various teams.\n\nTake a look at this simple example of JSON schema:\n\nIn this example, the schema defines an object that needs to have two properties, and . should be a string, whereas should be an integer and cannot be a negative value.\n\nNow that we've understood the concept of JSON schema validation, we'll be moving onto another exciting topic- creating custom JSON schemas. This will require another deep dive and you'll need your concentration caps on for this one. So, let's proceed...\n\nBest Practices for Using JSON\n\nJSON format is intuitive and offers a lot of flexibility, but to get the most out of it, it's crucial to follow certain best practices. These practices streamline the coding process, aid readability and optimize data interchange.\n\nFirst, always keep the JSON structure clean and organized. JSON data is represented in name-value pairs, meaning proper structuring ensures data integrity. It's easy to fall prey to messy code when dealing with complex data, so I emphasize consistency and neatness.\n\nSecondly, utilize JSON schema validation to its fullest extent. As explained before, JSON schema validation ensures code standardization and aids in catching inconsistencies early. A well-implemented validation process helps maintain the robustness of data interchange.\n\nIn addition, when dealing with large strings of data, it's better to use arrays rather than multiple name-value pairs. Data arrays in JSON are simple to understand and can hold data more efficiently than multiple name-value pairs.\n\nWhen creating custom JSON schemas for complex data, remember to keep things as simple as possible. Simplicity is the key to meaningful data representation in JSON.\n\nBelow, I've compiled a basic guide to JSON best practices:\n• Maintain clean, organized structure: Do this by using consistent name-value pairs and avoid nesting data unnecessarily.\n• Use arrays for large strings of data: Arrays are easier to manage and are intuitive for other developers.\n\nThese practices don't just apply to JSON -- they're a solid foundation for any data interchange format. The true power of these principles shines through when they're used consistently throughout a project. Get into this habit, and you'll see a marked improvement in your coding efficiency. While working with JSON, you'll soon discover other practices that can boost your experience - shaping and tailoring these guidelines to your workflow is equally important.\n\nIn the next section, we'll delve into comparing JSON with other data interchange formats - looking at where JSON stands out and where it might not be the best option. That's for another discussion though, so let's place the bookmark here.\n\nSo we've seen how JSON's simplicity and readability make it a powerful tool for data interchange. Its schema validation feature is a game changer, ensuring code standardization and catching errors early. I've shared some best practices for using JSON, like maintaining a clean structure, using arrays for large data strings, and keeping schemas simple. Remember, these aren't exclusive to JSON and can be applied to other data interchange formats too. In the next section, we'll dive into how JSON stacks up against other data formats. Stay tuned!"
    },
    {
        "link": "https://w3schools.com/js/js_json.asp",
        "document": "JSON is a format for storing and transporting data.\n\nJSON is often used when data is sent from a server to a web page.\n• JSON is \"self-describing\" and easy to understand\n\n* The JSON syntax is derived from JavaScript object notation syntax, but the JSON format is text only. Code for reading and generating JSON data can be written in any programming language.\n\nThis JSON syntax defines an employees object: an array of 3 employee records (objects):\n\nThe JSON format is syntactically identical to the code for creating JavaScript objects.\n\nBecause of this similarity, a JavaScript program can easily convert JSON data into native JavaScript objects.\n\nJSON Data - A Name and a Value\n\nJSON data is written as name/value pairs, just like JavaScript object properties.\n\nA name/value pair consists of a field name (in double quotes), followed by a colon, followed by a value:\n\nJust like in JavaScript, objects can contain multiple name/value pairs:\n\nJust like in JavaScript, an array can contain objects:\n\nIn the example above, the object \"employees\" is an array. It contains three objects.\n\nEach object is a record of a person (with a first name and a last name).\n\nA common use of JSON is to read data from a web server, and display the data in a web page.\n\nFor simplicity, this can be demonstrated using a string as input.\n\nThen, use the JavaScript built-in function to convert the string into a JavaScript object:\n\nFinally, use the new JavaScript object in your page:\n\nYou can read more about JSON in our JSON tutorial."
    },
    {
        "link": "https://medium.com/@stheodorejohn/mastering-json-in-javascript-best-practices-and-real-world-scenarios-b001cb79bb20",
        "document": "🔍Unlock the power of JSON with best practices and practical examples!\n\nMastering JSON in JavaScript — Best Practices and Real-World Scenarios\n\nJSON (JavaScript Object Notation) stands out as a universal favorite for data representation. In this comprehensive guide, we will explore best practices for working with JSON in JavaScript. We’ll dive deep into what JSON is, why it’s crucial, real-world scenarios where it’s employed, various implementation techniques, and offer in-depth explanations. Additionally, we’ll discuss important considerations for practical usage to ensure your JSON-related tasks are executed flawlessly.\n\nJSON, short for JavaScript Object Notation, is a lightweight data interchange format. It’s easy for humans to read and write, and it’s easy for machines to parse and generate. JSON is often used to transmit data between a server and a web application as an alternative to XML."
    },
    {
        "link": "https://stackoverflow.com/questions/2351040/is-it-possible-to-construct-complex-queries-against-nosql-db",
        "document": "In my opinion, you can do this in a document data store, such as MongoDB, but not easily in a key-value data store such as Cassandra. If you were to do it in a key-value data store, the composite key would have to identify all the queried data elements (columns). In other words, one instance would have to have all the query columns. This is possible. In a vanilla key-value store, there is one data element (column) per key but you can do it to support many. A key value store permits this because the value is just a string value and can contain what you want. I recommend multiple data elements (columns) per key but you would have to program for this. If instead you have the columns in different column instances, it would be very slow to search through the data vertically, even though the columns are ordered. The sample in your question has only one table. If you have multiple tables in relational, in key-value stores you would have to create a new column family to store the joined data and you would still have to have multiple data elements per key. However, it would have to be pre-loaded horizontally in one instance in one family by an ETL-like process. In other words, join the data before it is loaded into the key value store, and design the Cassandra data store to store the already-combined data in a column with multiple values. Or use data mining. I believe \"big data analytics\" are currently addressing this problem in key-value stores. Another example, less sophisticated than yours, is how in key-value stores can you produce a simple report of sales revenue and volume by customer by product by week?"
    },
    {
        "link": "https://mongodb.com/resources/basics/databases/nosql-explained",
        "document": "To see a more detailed version of this data modeling example, read Mapping Terms and Concepts From SQL to MongoDB.\n\nThere are a variety of differences between relational database management systems and non-relational databases. One of the key differences is the way data is modeled in the database. Some key differences of each feature is listed below:\n\nNoSQL: Data models vary based on the type of NoSQL database used — for example, key-value, document, graph, and wide-column — making the model suitable for semi-structured and unstructured data.\n\nRDBMS: RDBMS uses a tabular data structure, with data represented as a set of rows and columns, making the model suitable for structured data.\n\nNoSQL: It provides a flexible schema where each set of documents/row-column/key-value pairs can contain different types of data. It’s easier to change schema, if required, due to the flexibility.\n\nRDBMS: This is a fixed schema where every row should contain the same predefined column types. It is difficult to change the schema once data is stored.\n\nNoSQL: It varies based on the type of NoSQL database used. For example, MongoDB has MQL, and Neo4J uses Cypher.\n\nNoSQL: NoSQL is designed for vertical and horizontal scaling.\n\nRDBMS: RDBMS is designed for vertical scaling. However, it can extend limited capabilities for horizontal scaling.\n\nNoSQL: Relationships can be nested, explicit, or implicit.\n\nRDBMS: Relationships are defined through foreign keys and accessed using joins.\n\nNoSQL: Transactions are either ACID- or BASE-compliant.\n\nNoSQL: NoSQL is suitable for real-time processing, big data analytics, and distributed environments.\n\nRDBMS: RDBMS is suitable for read-heavy and transaction workloads.\n\nNoSQL: This offers eventual consistency, in most cases.\n\nNoSQL: One of the main reasons to introduce NoSQL was for distributed computing, and NoSQL databases support distributed data storage, vertical and horizontal scaling through sharding, replication, and clustering.\n\nRDBMS: RDBMS supports distributed computing through clustering and replication. However, it’s less scalable and flexible as it’s not traditionally designed to support distributed architecture.\n\nNoSQL: NoSQL has built-in fault tolerance and high availability due to data replication.\n\nRDBMS: RDBMS uses replication, backup, and recovery mechanisms. However, as they are designed for these, additional measures like disaster recovery mechanisms may need to be implemented during application development.\n\nNoSQL: It’s done through sharding and replication.\n\nLearn more about data partitioning here.\n\nNoSQL: NoSQL stores the data in a variety of ways — for example, as JSON documents, wide-column stores, or key-value pairs. It provides abstraction through the ODM (object-data mapping) frameworks to work with NoSQL data in an object-oriented manner.\n\nRDBMS: RDBMS relies more on data-to-object mapping so that there is seamless integration between the database columns and the object-oriented application code.\n\nTo learn more about the differences between relational databases and NoSQL databases, read NoSQL vs SQL Databases.\n\nNoSQL database systems are used in nearly every industry, for real-time analytics, content management, IoT applications, recommendation systems, fraud detection, product catalog management, and much more. Use cases range from the highly critical (e.g., storing financial data and healthcare records) to the more fun and frivolous (e.g., storing IoT readings from a smart kitty litter box).\n\nWhen should NoSQL be used?\n\nWhen deciding which database to use, decision-makers typically find one or more of the following factors that lead them to select a NoSQL database:\n\nSee When to Use NoSQL Databases and Exploring NoSQL Database Examples for more detailed information on the reasons listed above.\n\nOver the years, many misconceptions about NoSQL databases have spread throughout the developer community. In this section, we'll discuss two of the most common misconceptions.\n\nMisconception: relationship data is best suited for relational databases\n\nA common misconception is that NoSQL databases or non-relational databases don't store relationship data well. NoSQL databases can store relationship data — they just store it differently than relational databases do.\n\nIn fact, when compared with relational databases, many find modeling relationship data in NoSQL databases to be easier than in relational databases because related data doesn't have to be split between tables. NoSQL data models allow related data to be nested within a single data structure.\n\nAnother common misconception is that NoSQL databases don't support ACID transactions. Some NoSQL databases, like MongoDB, do, in fact, support ACID transactions.\n\nNote that the way data is modeled in NoSQL databases can eliminate the need for multi-record transactions in many use cases. Consider the earlier example where we stored information about a user and their hobbies in both a relational model and a document store. To ensure information about a user and their hobbies was updated together in a relational database, we'd need to use a transaction to update records in two tables. To do the same in a document store, we could update a single document — no multi-record transaction required.\n\nTo learn more about common misconceptions, read Everything You Know About MongoDB is Wrong.\n\nYou could start with MongoDB, the world's most popular NoSQL database, according to DB-Engines. The easiest way to get started with MongoDB is MongoDB Atlas. Atlas is MongoDB's fully managed database as a service. Atlas has a forever-free tier, which you can use to play around. Check out the MongoDB Atlas tutorial to get started.\n\nYou can continue to interact with your data by using the Atlas Data Explorer to insert new documents, edit existing documents, and delete documents.\n\nWhen you are ready to try more advanced queries that aggregate your data, create an aggregation pipeline. The aggregation framework is an incredibly powerful tool for analyzing your data. To learn more, take the free MongoDB University Course M121 The MongoDB Aggregation Framework.\n\nWhen you want to visualize your data, check out MongoDB Charts. Charts allow you to create dashboards that are filled with visualizations of your data.\n\nNoSQL databases provide a variety of benefits, including flexible data models, horizontal scaling, lightning-fast queries, and ease of use for developers. NoSQL databases come in a variety of types, including document stores, key-values databases, wide-column stores, graph databases, and multi-model databases.\n\nMongoDB is the world's most popular NoSQL database. Learn more about MongoDB Atlas, and give the free tier a try.\n\nExcited to learn more now that you have your own Atlas account? Head over to MongoDB University where you can get free online training from MongoDB engineers and earn a MongoDB certification. The Quickstarts are another great place to begin; they will get you up and running quickly with your favorite programming language."
    },
    {
        "link": "https://stackoverflow.com/questions/5092030/most-efficient-method-for-persisting-complex-types-with-variable-schemas-in-sql",
        "document": "I am creating an SQL table that will provide the back-end storage mechanism for complex-typed objects. I am trying to determine how to accomplish this with the best performance. I need to be able to query on each individual simple type value of the complex type (e.g. the String value of a City in an Address complex type).\n\nI was originally thinking that I could store the complex type values in one record as an XML, but now I am concerned about the search performance of this design. I need to be able to create variable schemas on the fly without changing anything about the database access layer.\n\nWhere I'm at now\n\nRight now I am thinking to create the following tables.\n\nfrom these tables, when performing queries I would do a series of self-joins on the value table. When I want to get the entire object by the DocumentId, I would have a generic script for creating a view mimics a denormalized datatable of the complex-type.\n\nWhat I want to know\n\nI believe there are better ways to accomplish what I am trying to, but I am a little too ignorant about the relative performance benefits of different SQL techniques. Specifically I don't know the performance cost of:\n\nI would appreciate any information or resources about these performance issues in sql as well as a recommendation for how to approach this general issue in a more efficient way.\n\nHere's an example of what I am currently planning on doing.\n\nI have a C# class Address which looks like\n\nAn instance is constructed from\n\nits XML value would be look like.\n\nUsing the db-schema from above I would have a single record in the Schemas table with an XSD definition of the address xml schema. This instance would have a uniqueidentifier (PK of the Documents table) which is assigned to the SchemaId of the Address record in the Schemas table. There would then be five records in the Values table to represent this Address.\n\nThey would look like:\n\nMy objective is to obtain the resources I need in order to give my application a data access layer that is fully searchable and has a data-schema generated from the application layer that does not require direct database configuration (i.e. creating a new SQL table) in order to add a new aggregate root to the domain model.\n\nI am open to the possibility of using .NET compatible technologies other than SQL, but I will require that any such suggestions be adequately substantiated in order to be considered."
    },
    {
        "link": "https://altexsoft.com/blog/nosql-databases",
        "document": ""
    },
    {
        "link": "https://quora.com/Is-there-an-example-of-a-complex-NoSQL-ndb-data-model",
        "document": "Something went wrong. Wait a moment and try again."
    }
]