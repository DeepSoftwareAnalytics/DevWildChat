[
    {
        "link": "https://controlplane.com/community-blog/post/an-in-depth-guide-to-deploying-node-js-apps",
        "document": "In the world of application development, Node.js is one of the most popular and widely used tools available today. Its robust JavaScript runtime environment enables developers to easily create fast and efficient server-side applications.\n\nWith its scalability, flexibility, and performance capabilities, it’s no wonder why so many companies are turning to Node.js for their web development needs.\n\nThis in-depth guide will explore how to deploy your Node.js apps quickly and efficiently using best practices. By the end of this guide, you should have all the knowledge you need to get started on deploying your very own Node app!\n\nNode.js is an open-source, cross-platform JavaScript runtime environment enabling developers to easily create server-side applications. It’s based on Google Chrome’s V8 JavaScript engine and allows developers to build scalable network applications quickly and efficiently.\n\nNode.js utilizes an event-driven architecture and a nonblocking I/O model, which makes it lightweight and efficient, perfect for data-intensive real-time applications that run across distributed devices.\n\nDeployment is the process of transferring a software application from its development environment to production, usually within a hosted environment such as a web server or cloud computing platform. It includes testing, installing updates, and configuring any necessary settings required for launching the application.\n\nDeploying an application requires comprehensive knowledge of hosting platforms and corresponding software configurations to ensure that it works properly in the designated live environment.\n\nDepending on their size and complexity, apps can be deployed using different methods, including manual deployments, continuous integration tools, or automated deployment scripts.\n\nWhat Are the Different Ways to Deploy Node.js Apps on the Cloud?\n\nThere are several ways to deploy Node.js applications on the cloud, each with its own benefits and drawbacks.\n• Process manager: The first option is to use PM2, an open-source production process manager explicitly designed for Node.js applications. PM2 allows developers to quickly and easily monitor and manage their applications in real time while supporting configurations such as multiple instances, hot reloading (restarting processes after changes), logging management, and more. This makes PM2 a powerful tool for quickly launching and deploying Node apps on the cloud without manually configuring or maintaining them over time.\n• Containerization with Docker: Another way to deploy Node apps on the cloud is by using Docker containers. Docker is a popular containerization platform that enables developers to package their applications into self-contained environments called containers, which developers can easily deploy on any platform. By using Docker containers, developers can ensure that their application runs exactly how they expect it to, regardless of where it’s being deployed, while providing scalability options if needed.\n• Serverless platforms: A third option for deploying Node apps on the cloud is using serverless cloud platforms such as AWS Lambda or Azure Functions. These platforms provide developers with an easy way to quickly spin up and run Node applications without worrying about managing servers or setting up complicated infrastructure. In addition, these services provide scalability options for efficiently handling high volumes of traffic or large datasets.\n• Platform as a service: Developers may also opt for platform as a service (PaaS) platforms such as Heroku and Railway. With these platforms, developers don’t have to worry about managing infrastructure. Some common features of such platforms include autoscaling, logging, etc.\n\nThis post will focus on deploying Node apps using PM2 and Docker.\n\nBefore we get started, it’s essential to have the setup ready, which includes the following:\n\nFor the sake of this tutorial, you can use a sample Node.js todo application. First, create a folder on the VM and initialize npm.\n\nOnce done, let’s create the main application. Create an index.js and paste the code from the GitHub Gist. Also, install all required packages using the following command:\n\nAfter installing the Node.js packages, start the Node.js app using node index.js to test the application.\n\nNow, it’s time to get started with the deployment. First, install PM2 using this command:\n\nNow, start the application using the following command.\n\nTo test if the application is working, we can use the cURL command.\n\nThe output should be [“Buy Egg”]. If your output is this, you’re good to go.\n\nWe used the cURL command to test the application locally, as we haven’t enabled public access to our application. To do that, open ports 80 and 443 from your cloud provider and enable ports 80 and 443 from the firewall.\n\nNow, it’s time to use NGINX (as Reverse Proxy) to enable internet traffic to access our application. First, install NGINX using the following command:\n\nAfter that, let’s update the NGINX config and restart the NGINX server to get started. Feel free to use your favorite text editor to make changes to the config file.\n\nIn the config file, you’ll find a server block (something like server {…}) and a default location block inside the server block. Remove the location / block and the following block.\n\nReplace the port in the proxy_pass with the port your node application is running on. You can also add the following line in the server block (just above the location block) to map your custom domain with the public IP of your VM.\n\nIt’s crucial to test the NGINX config after updating the config file. Use the following command to test the NGINX config.\n\nNote: If the status failed, you might have missed something when editing the server file.\n\nNow, restart NGINX using this command:\n\nIf your application is up and running, it’s time to test public access.\n\nVisit your cloud provider to copy the public IP address of the VM and open it using a web browser (you can use Postman or cURL). If you get 404: Page not found, you don’t have to worry, as we don’t have any controller for the / route.\n\nThe output should be [“Buy Eggs”]. You can also test the /add endpoint to add an item using the following command:\n\nWe can also add an SSL certificate to our application to make it more secure and trusted. We’ll use Certbot’s Standalone mode to get a certificate from Let’s Encrypt.\n\nFirst, let’s install Certbot to get started. The Certbot document suggests using Snap to install Certbot.\n\nWe’ve first removed Certbot to ensure there are no old packages installed using other package managers.\n\nThen, we simply install Certbot and use the ln command to use the Certbot command.\n\nAt last, we use the Certbot command (–nginx flag) to install the certificate. Ensure that you’ve added server_name in the server block and a record in your DNS records with the public IP of your machine before proceeding.\n\nWe can also run our Node.js application using Docker rather than PM2. To do that, let’s first install Docker on the VM.\n\nFirst, stop the existing application running on port 3000 using PM2.\n\nWe can either use Dockerfile or the docker-compose.yml file to run the application. We can also use both of them together, but the application doesn’t have any integrations such as Redis, Mongo, etc., so let’s just use Dockerfile to get started.\n\nCreate a Dockerfile and add the following code:\n\nNow, it’s time to build and run the application in detached mode.\n\nAs we’re running the same on the same port, we don’t have to make any changes in the NGINX config. If you’ve changed the port, ensure that you’ve updated proxy_pass in the config file.\n\nIn conclusion, deploying Node.js applications in production can be a daunting task if not done properly. By following the steps outlined in this post and leveraging tools such as PM2 and Docker containers, developers can rest assured that their apps are running optimally on Linux virtual machines with minimal effort required for maintenance or scaling purposes.\n\nFor even greater ease and flexibility, consider trying Control Plane’s hybrid platform, which combines the computing power of major cloud providers and provides a global environment for building and scaling your backend services.\n\nSign up now and experience worry-free Node.js app deployment!”\n\nThis post was written by Keshav Malik, a highly skilled and enthusiastic Security Engineer. Keshav has a passion for automation, hacking, and exploring different tools and technologies. With a love for finding innovative solutions to complex problems, Keshav is constantly seeking new opportunities to grow and improve as a professional. He is dedicated to staying ahead of the curve and is always on the lookout for the latest and greatest tools and technologies."
    },
    {
        "link": "https://stackoverflow.com/questions/60689222/how-to-deploy-node-js-on-public-domain",
        "document": "I have been putting myself together a personal brand website for a class of mine and built it with node, html, and css. It works all fine and dandy on my local host and even my raspberry pi, but I just bought a domain on google domains and want to go public with it. I have been trying tutorials and resources for a couple hours now and I very lost. Can anyone link me and resources, or walk me through what I have to do to get my local host code running on a public domain. Thank you."
    },
    {
        "link": "https://stackoverflow.com/questions/5489956/how-could-others-on-a-local-network-access-my-nodejs-app-while-its-running-on",
        "document": "I have a pretty straight-forward question. I made a web game with NodeJS, and I can successfully play it by myself with multiple browser windows open side-by-side; however, I'd like to know if it's possible for other local machines to be able to access and play the game with me too. I naively tried using this url: and it won't work."
    },
    {
        "link": "https://quora.com/How-can-I-deploy-a-website-using-node-js-I-have-bought-a-domain-name-from-GoDaddy-and-have-linked-my-node-application-with-mongoDB-atlas-I-want-to-deploy-my-node-application-to-the-domain-name-I-bought-from-GoDaddy",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://medium.com/@Anatolii_Zhadan/how-to-deploy-a-node-js-app-with-a-domain-2a443fbf6a71",
        "document": "The server settings depend on the load your site will be under and the complexity of the project. Since I will be deploying a simple site, I chose the most minimal settings.\n\nOnce our server is up and running, we can start connecting to it.\n\nCopy the IPv4 or IPv6 address, then open a terminal and enter the following command:\n\nAfter this, it will ask you to enter the password that you set when creating the VPS:\n\nWhen you successfully log in, you will see something similar to this:\n\nFrom there, we have two ways to transfer our project folder. If you have it in a zip file on your local computer, you can use these commands to transfer the zip file with your project to the server.\n\nHowever, I suggest that you use GitHub.\n\nLogin to GitHub and use “git clone” to put your project in the global directory. For example, I will use my Node.js project called “qr_code_hunt_challenge”.\n\nThen, we need to install packages. Use the following commands on our VPS:\n\nAfter this, go to the git repository using this link and choose the version of Node.js you need. In my case, I will use the latest LTS version. Press the copy button next to the commands and insert them in our VPS:\n\nIf you encounter any errors:\n\nNow, we need to make some changes in the firewall settings:\n\nsudo ufw allow 'OpenSSH'\n\nsudo ufw allow 'Nginx HTTP'\n\nsudo ufw enable \n\n#after all this commands you need to write\n\nsudo ufw status\n\n#and you will get something like this\n\nStatus: active\n\n\n\nTo Action From\n\n-- ------ ----\n\nOpenSSH ALLOW Anywhere \n\nNginx HTTP ALLOW Anywhere \n\nOpenSSH (v6) ALLOW Anywhere (v6) \n\nNginx HTTP (v6) ALLOW Anywhere (v6)"
    },
    {
        "link": "https://blog.logrocket.com/how-to-run-node-js-server-nginx",
        "document": "Editor’s note: This article was last updated by Alexander Godwin on 13 March 2024 to include advanced Nginx configuration options such as SSL termination and load balancing, as well as to answer commonly asked questions like Why use Nginx with Node.js? and How does a reverse proxy server work?\n\nNode.js is a vital tool for almost all kinds of microservice-based development and delivery. It’s also the leading tool for creating server applications in JavaScript, offering the functionality of both a web server and an application server.\n\nBut Node.js has some shortcomings and vulnerabilities that can cause performance issues and even crashes. For example, Node-based web applications are prone to slow code execution and crashes due to IO-bound operations or rapid traffic growth. They also sometimes struggle with serving static content such as images and JavaScript files and load balancing across multiple servers.\n\nFortunately, you can cache static content, reverse proxy and load balance among multiple application servers, and manage port contention between clients using Nginx. This makes Nginx an excellent tool for increasing Node.js performance.\n\nIn this tutorial, we’ll show you how to reverse proxy a Node.js application with Nginx. We’ll build a simple Node.js application that will run on port 3000 and use Nginx as a reverse proxy server for the Node.js application. The application will be addressed using a domain name:\n\nTo follow along, you should have:\n• An understanding of how the web, web servers, and web browsers communicate\n• An Ubuntu virtual machine from a public cloud provider, open to ports 22, 80, and 3000\n\nWhat are servers and web servers?\n\nA server is a computer that communicates with other computers to serve them with the information requested by these computers. These computers, also called clients, connect to a server through either a local area network (LAN) or a wide area network (WAN). A server sends and collects information across a network within multiple locations.\n\nA web server is a server on the internet that uses the Hypertext Transfer Protocol (HTTP) to receive requests from a client, such as a browser. It then returns an HTTP response, which can be an HTML webpage or data in JSON format, as used in API calls.\n\nWeb servers, essential for data exchange, use HTTP for client-server communication. They consist of both hardware and software, crucial in web development. The software interprets URLs and manages user access to hosted files.\n\nAccording to its documentation, Nginx (pronounced “engine X”) is an HTTP and reverse proxy server, a mail proxy server, and a generic TCP/UDP proxy server, originally written by Igor Sysoev.\n\nNginx is used for a variety of tasks that contribute to improving Node performance:\n• Reverse proxy server: As traffic to your app increases, the best approach to improve performance is to use Nginx as a reverse proxy server in front of the Node.js server to load balance traffic across the servers. This is the core use case of Nginx in Node.js applications\n• Stateless load balancing: This improves performance while reducing load on backend services by sending off client requests to be fulfilled by any server with access to the requested file\n• Cache static contents: Serving static content in a Node.js application and using Nginx as a reverse proxy server doubles the application performance to a maximum of 1,600 requests per second\n• Implement SSL/TLS and HTTP/2: Given the recent shift from using SSL/TLS to secure user interactions in Node.js applications, Nginx also supports HTTP/2 connections\n• Performance tracking: You can keep real-time tabs on the overall performance of your Node.js application using the stats provided on Nginx’s live dashboards\n• Scalability: Depending on what assets you’re serving, you can take advantage of the full‑featured HTTP, TCP, and UDP load balancing in Nginx to scale up your Node.js application\n\nNginx currently supports seven scripting languages: Go, Node.js, Perl, PHP, Python, Ruby, and Java Servlet Containers (the last is an experimental module). It enables you to run applications written in different languages on the same server.\n\nNow, let’s set up our Node.js application.\n\nFor this simple Node.js application, we’ll build a Node.js server with the HTTP module provided by Node.js. Let’s start by creating a folder and initializing the project on the terminal:\n\nThe above code will create the folder and change the directory into the folder. We then initialize a Node.js application with npm, using the flag to set as the default answer to all the questions.\n\nThe next step is to create the file that contains the source code for our application. Open it up with any IDE or text editor of your choice:\n\nNow it’s time to build and start the server. Let’s define two extra subdomains as a means to test that our application is fully functional:\n\nWe created a server with a Node.js HTTP module that we imported using the function in the above code. Within our server, we’ll render two different responses, depending on our current route. The two routes are and .\n\nOn the subdomain, we’ll render a plain text, while on the , we’ll render a JSON object. The above application will be accessed on the Public IPv4 address of your virtual machine — e.g., on port .\n\nNow that the Node server application is ready, let’s install Nginx and configure it.\n\nWe’ll install Nginx using the default package manager for a Debian-based operating system, which is called apt. Nginx is also available for almost all operating systems under their default repositories.\n\nBefore installing Nginx, make sure you’ve installed the prerequisites for Ubuntu OS. Next, we’ll configure Nginx based on the unique needs of our project, then we’ll be ready to implement it.\n\nFor Nginx to route to the Node.js application listening on port 3000, we’ll need to first unlink the default configuration of Nginx and then create a new configuration to be used by our Node.js application.\n\nTo unlink the default Nginx configuration, you can use the following command:\n\nThe Nginx configuration is kept in the directory. To create a new configuration, let’s navigate to this directory and create a configuration file pointing to the server block of our Node.js application:\n\nAfter changing the directory to , the second command will create an Nginx configuration file named .\n\nPaste in the following configuration:\n\nThe above configuration has Nginx listening on port 80 on . The is your Uniform Resource Identifier (URI) with the following properties:\n• : Sets the host header to be that of the Nginx server\n• : Instructs Nginx to proxy all requests matching the location pattern to an upstream (backend) server\n• : Converts the proxied connection to type because WebSockets only communicate on upgraded connections\n• : Ensures the connection header value is\n\nSave the changes and exit the file by clicking the key. Then, type the command and hit the or key.\n\nFor the next step, let’s enable the above file by creating a symbolic link from it to the directory, which Nginx reads from during startup:\n\nThe server block is now enabled and configured to return responses to requests based on the port and path.\n\nNow it’s time to start both our Node.js application and the Nginx service to trigger the recent changes. But first, let’s check the status of Nginx to confirm that the configuration is working properly:\n\nThe output upon running the above command would look like this:\n\nThe above output confirms that our configuration was successful. Next, restart Nginx to enable your changes:\n\nWith Nginx running again, let’s allow full access through the Nginx firewall:\n\nNext, navigate to the directory of the Node.js application:\n\nStart your Node.js server application using the following command:\n\nOpen your browser and access the Node.js application using :\n\nNow we can navigate to the address on the browser and access the endpoint of our application:\n\nTo further test if every other path we defined is working, let’s try the last path, :\n\nNode.js has become popular for creating online applications that are fast and scalable. However, it is essential to optimize the web server infrastructure to take advantage of its possibilities. This section will explore how to optimize the scalability and security of Node.js apps by covering advanced Nginx configuration options including SSL termination, load balancing, and more.\n\nIt is essential to secure communication between clients and the Node.js server, and SSL/TLS encryption is a key component in making this happen. Nginx performs well when it comes to SSL termination.\n\nBy terminating HTTPS traffic from clients, Nginx relieves the computational burden of SSL/TLS encryption on your upstream web and application servers:\n• Sets up Nginx to listen on port 443 for SSL connections\n• Specifies the SSL certificate and key paths for SSL termination\n• Uses the directive to forward incoming requests to the backend Node.js servers\n\nAs Node.js applications develop in size to accommodate an increasing number of users, it becomes important to allocate incoming traffic among several backend servers to guarantee efficiency and dependability.\n\nNginx provides a variety of algorithms to help with load balancing. These algorithms determine how loads are distributed among the available servers:\n• The directive defines a group of backend Node.js servers for load balancing\n• Nginx distributes incoming requests among the specified servers using a default round-robin algorithm\n• The directive forwards requests to the backend servers within the upstream group\n\nThe efficiency and scalability of Node.js applications can be improved by optimizing static assets and dynamic content for caching.\n\nBy storing content depending on the URL patterns, response headers, and other criteria, Nginx makes it easier for Node.js servers to serve content dynamically. This frees up resources for logic related to applications. To respond to client requests without requiring a proxy request for the same content each time, Nginx uses disk caching to store responses in response to queries:\n\nNginx offers strong security capabilities that shield Node.js applications from attacks and vulnerabilities in addition to enhancing scalability.\n\nBecause Nginx has a large number of security modules, it offers features like rate limiting, access control, and request filtering to prevent attacks like SQL injection, DDoS, and cross-site scripting:\n\nWhy use Nginx with Node.js?\n• Load balancing: Load balancing becomes important as server load increases. Using some algorithms, Nginx can spread the server traffic across multiple servers as specified in the file\n• Reverse proxy: Nginx acts as a middleman between the server and our Node.js server. As a reverse proxy, Nginx intercepts client requests to the servers, performs checks on the headers or body of the client requests if needed, and then forwards the request to the servers. It’s also responsible for passing responses back to client devices\n• Content caching: Nginx can be used for caching responses to requests and serving that response whenever those routes are called\n• Gzip compression: Nginx allows for the compression of static content, reducing the size of the responses that are sent to the client\n\nThe reverse proxy acts as an intermediary between client devices (e.g., web browsers) and backend servers (e.g., application servers or web servers), and instead of forwarding client requests directly to the backend servers, it intercepts these requests and forwards them on behalf of the client. Here’s how a reverse proxy server works:\n• Client sends request: A request to access a specific internet resource is sent by a client device, such as a web browser. Typically, this request contains the URL, the request type, and any other important headers\n• Request reaches reverse proxy: When a reverse proxy is in use, it intercepts any request to the server\n• Reverse proxy assesses request: The reverse proxy reviews the request after it has been received. The request handling is decided by the reverse proxy based on established rules or configurations\n• Forwarding request to backend: After evaluating the request, the reverse proxy forwards it to the appropriate server. This backend server could be selected based on various factors, such as load balancing algorithms, request routing rules, or server health checks\n• Backend server processes request: The server receives the forwarded request from the reverse proxy and processes it accordingly\n• Response sent back to reverse proxy: Once the backend server has processed the request, it generates an appropriate response\n• Reverse proxy receives response: The reverse proxy intercepts the response from the server\n• Response sent back to client: Finally, the reverse proxy forwards the response received from the backend server to the original client device that initiated the request\n\nWhat is the difference between a forward proxy and a reverse proxy?\n\nThe primary difference between a forward proxy and a reverse proxy lies in their roles, deployment, and the direction of traffic they handle.\n\nA forward proxy manages client devices’ outgoing traffic to the internet. It receives a client’s request to access a resource online and passes it to the desired location on the client’s behalf.\n\nOn the other hand, a reverse proxy responds to incoming traffic going from clients to backend servers. Upon receiving a request from a client seeking access to a resource hosted on backend servers, the reverse proxy relays the request to the relevant backend server on the client’s behalf.\n\nForward proxies are usually installed on the client’s device or within the client’s network. By serving as a bridge between client devices and the internet, it offers services like anonymization, content screening, and caching.\n\nMeanwhile, a reverse proxy is usually set up in front of web, application, or API servers. With functions like load balancing, SSL termination, and security protection, it serves as a gateway between clients and backend servers.\n\nForward proxies can be used to uphold rules, filter content, and improve users’ security and privacy when they browse the internet. Meanwhile, use cases of reverse proxy include routing incoming client requests to backend servers, SSL termination, caching, and load balancing.\n\nHow to configure SSL with Nginx for a Node.js application?\n\nConfiguring SSL with Nginx for a Node.js application involves several steps to ensure secure communication between clients and the server. Below is a series of steps to configure SSL with Nginx.\n\nFirst, obtain SSL/TLS certificates from a trusted Certificate Authority (CA) like or generate self-signed certificates for testing purposes. You need two files: a containing the server’s public key and a containing the server’s private key.\n\nThen, open your Nginx configuration file (commonly located at or ). Add or modify a server block to enable SSL. Here’s a basic example:\n\nWithin the server block, you can configure additional SSL parameters for security and performance. Some common directives include:\n\nOptionally, you may want to redirect HTTP traffic to HTTPS to ensure all communication is encrypted:\n\nThen, verify your Nginx configuration using . If the configuration is valid, reload Nginx to apply the changes: (or equivalent command, based on your system).\n\nAfter configuring Nginx, ensure your Node.js application is running on the specified port.\n\nFinally, use a web browser to access your application via HTTPS (e.g., https://example.com). Verify that the connection is secure and that SSL/TLS encryption is properly configured.\n\nWhat are the best practices for monitoring and maintaining Nginx as a reverse proxy?\n\nAs a reverse proxy, Nginx requires constant monitoring and upkeep to guarantee the dependability, efficiency, and security of your web infrastructure.\n• Monitor server health: Monitoring server health is an important aspect of building better servers. Using monitoring tools such as Prometheus, Grafana, or the built-in Nginx status module, we can monitor the health of our server\n• Set up logging: We can configure Nginx to log access logs and error logs to track incoming requests, response codes, and errors. This way we can tell what went wrong with our system and also what aspects we can improve\n• Regularly update Nginx: Keep up with Nginx’s most recent releases and security fixes to make sure your reverse proxy is shielded from known vulnerabilities\n\nIn this tutorial, we learned how to set up Nginx as a Node.js server for backend applications. We built a simple Node.js application using Node.js and Nginx. Then, we configured Nginx to listen for port 3000 and served the contents we had predefined within our Node.js application on the browser.\n\nNgnix is a great tool for web application delivery, providing performance and scalability at both the ADC (Application Delivery Controller) and web server layers."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/nginx-reverse-proxy-node-angular",
        "document": "A reverse proxy is a server that retrieves resources for clients from one or more upstream servers. It typically places itself behind a firewall in a private network and forwards clients request to these upstream servers. A reverse proxy greatly improves security, performance, and reliability of any web application. Many modern web applications written in NodeJS or Angular can run with their own standalone server but they lack a number of advanced features like load balancing, security, and acceleration that most of these applications demands. NGINX with its advanced features can act as a reverse proxy while serving the request for a NodeJS or an Angular application.\n\nIn this tutorial, we will explore how NGINX can be used as a reverse proxy server for a Node or an Angular application. Below diagram gives you an overview of how reverse proxy server works and process client requests and send the response.\n• You have already installed NGINX by following our tutorial from here.\n• The NGINX server can be accessed from public domain.\n• The Node or Angular application will be running in a separate system (upstream server) in a private network and can be reached from NGINX server. Although it is very much possible to do the setups in a single system.\n• The tutorial makes use of variables like and . Replace them with your own values at appropriate places.\n\nAssuming you have already installed NGINX in your environment, Let us create an example NodeJS application that will be accessed through NGINX reverse proxy. To start with, set up a node environment in a system residing in your private network.\n\nBefore proceeding with installing NodeJS and latest version of npm(node package manager), check if it is already installed or not:\n\nIf the above commands return the version of NodeJS and NPM then skip the following installation step and proceed with creating the example NodeJS application. To install NodeJS and NPM, use the following commands:\n\nOnce installed, check the version of NodeJS and NPM again.\n\nOnce NodeJS environment is ready, create an example application using ExpressJS. Therefore, create a folder for node application and install ExpressJS.\n\nNow using your favorite text editor, create and add the following content into it.\n\nRun the node application using following command:\n\nMake a curl query to the port number 3000 to confirm that the application is running on localhost.\n\nAt this point, NodeJS application will be running in the upstream server. In the last step, we will configure NGINX to act as a reverse proxy for the above node application. For the time being, let us proceed with creating an angular application, the steps for which are given below:\n\nAngular is another JavaScript framework for developing web applications using typescript. In general, an angular application is accessed through the standalone server that is shipped along with it. But due to a few disadvantages of using this standalone server in a production environment, a reverse proxy is placed in front of an angular application to serve it better.\n\nSince Angular is a JavaScript framework, it requires to have Nodejs with version > 8.9 installed in the system. Therefore before proceeding with installing angular CLI, quickly setup node environment by issuing following command in the terminal.\n\nNow proceed with installing Angular CLI that helps us to create projects, generate application and library code for any angular application.\n\nThe setup needed for Angular environment is now complete. In the next step, we will create an angular application.\n\nCreate an Angular application using following angular CLI command:\n\nChange to the newly created angular directory and run the web application by specifying the host name and port number:\n\nMake a curl query to the port number 3000 to confirm that the angular application is running on localhost.\n\nAt this point, the angular application will be running in your upstream server. In the next step, we will configure NGINX to act as a reverse proxy for the above angular application.\n\nNavigate to the NGINX virtual host configuration directory and create a server block that will act as a reverse proxy. Remember the system where you have installed NGINX earlier can be reached via the Internet i.e. a public IP is attached to the system.\n\nThe proxy_pass directive in the above configuration makes the server block a reverse proxy. All traffic destined to the domain and those matches with root location block (/) will be forwarded to where the node or angular application is running.\n\nNGINX Reverse Proxy for Both NodeJS and Angular App?\n\nThe above server block will act as a reverse proxy for either node or angular application. To serve both node and angular application at the same time using NGINX reverse proxy, just run them in two different port number if you intended to use the same system for both of them. It is also very much possible to use two separate upstream servers for running node and angular application. Further, you also need to create another NGINX server block with a matching values for and directive. Recommended Read: Understanding NGINX Configuration File. Check for any syntactical error in the above server block and enable the same. Finally, reload NGINX to apply new settings.\n\nNow point your favorite web browser to , you will be greeted with a welcome message from the Node or Angular application.\n\nThat’s all for configuring an NGINX reverse proxy for NodeJS or Angular application. You can now proceed with adding a free SSL certificate like Let’s Encrypt to secure your application!"
    },
    {
        "link": "https://stackoverflow.com/questions/75820301/how-to-configure-nginx-reverse-proxy-to-nodejs-app",
        "document": "I am new to nginx and I am following tutorials to set up nodejs app with nginx reverse proxy but nothing seems to be working. I have a very simple configuration and I’m not sure what the problem is can anybody let me know? I am just trying to get the standard welcome to nginx page to be served at my_domain/ and then proxy to my node app at my_domain/api but the node app doesn’t seem to be working. When I navigate to my_domain/ I get the standard welcome to nginx page, but when I go to my_domain/api I get \"cannot GET /api\""
    },
    {
        "link": "https://medium.com/@techWithAditya/rev-up-your-node-js-2b03aff0d25b",
        "document": "Node.js is a popular runtime environment for developing web applications due to its lightweight, fast, and scalable nature. However, as your app grows in size and traffic, you may experience performance issues that affect user experience. One way to mitigate these issues is to use a reverse proxy like NGINX.\n\nNGINX is a high-performance web server that can act as a reverse proxy and load balancer. It can handle multiple domains and route incoming requests to the appropriate backend servers, in this case, your Node.js app.\n\nWith NGINX reverse proxy, you can offload some of the responsibilities of your Node.js app, such as serving static files and SSL termination, freeing up resources for handling app-specific tasks. NGINX also provides caching, compression, and security features that can improve your app’s overall performance and security.\n\nIn this guide, I’ll show you how to set up NGINX reverse proxy on multiple domains to improve the performance of your Node.js app.\n\nSo, what exactly is NGINX reverse proxy? Simply put, it’s a way to manage incoming traffic to your web application. Instead of directly communicating with your application, clients send their requests to NGINX, which then forwards them to your app. This setup allows you to manage the flow of traffic and perform optimizations that can improve your app’s performance.\n\nNGINX reverse proxy can also act as a load balancer, distributing incoming requests across multiple backend servers, ensuring that each server receives a manageable amount of traffic. Additionally, it can handle SSL termination, offloading this resource-intensive task from your application.\n\nBut that’s not all. NGINX reverse proxy also provides caching, compression, and security features that can further improve your app’s performance and security. By caching frequently requested content, NGINX can reduce the load on your application, resulting in faster response times. It can also compress content to reduce the amount of data transferred, reducing the load on the network.\n\nBefore we dive into the setup process, make sure you have the following:\n• A domain name for your app (e.g., example.com) and subdomains (e.g., api.example.com)\n\nIf you’re ready to boost your web app’s performance and scalability, it’s time to install NGINX, the world’s most popular web server. NGINX is fast, lightweight, and highly scalable, making it an ideal choice for serving static content, handling SSL termination, and acting as a reverse proxy or load balancer.\n\nBefore installing NGINX, it’s important to update your package list to ensure that you have the latest versions of all the required packages. Run the following command to update the package list:\n\nOnce your package list is updated, you can install NGINX using the following command:\n\nThis will install NGINX along with its dependencies.\n\nAfter installation, start the NGINX service using the following command:\n\nYou can check the status of the NGINX service using the following command:\n\nThis should return an output indicating that the service is active and running.\n\nFinally, you’ll want to configure your firewall to allow incoming traffic to NGINX. If you’re using the default UFW firewall on Ubuntu, you can enable HTTP and HTTPS traffic using the following commands:\n\nThese commands will allow incoming traffic on port 80 (HTTP) and 443 (HTTPS).\n\nCongratulations! You’ve successfully installed NGINX on your Ubuntu 20.04 server. Now you’re ready to take advantage of its powerful features to supercharge your web app.\n\nThe next step is to configure NGINX to act as a reverse proxy for your Node.js app. To do this, you need to create a new configuration file for your app by running the following command:\n\nReplace “example.com” with your domain name.\n\nIn the configuration file, add the following code:\n\nThis configuration sets NGINX to listen on port 80 and handle requests for the domain names “example.com” and “www.example.com\". The block defines the proxy rules for your app. In this case, we're using to forward incoming requests to , which is where your Node.js app is running. The other proxy headers are added to ensure proper communication between NGINX and your app.\n\nThe next step is to enable the NGINX configuration you just created. You can do this by creating a symbolic link to the directory:\n\nThis will create a symbolic link from your configuration file to the directory.\n\nBefore restarting NGINX, it’s a good idea to test your configuration to make sure there are no syntax errors. You can do this by running the following command:\n\nThis command will check the NGINX configuration for syntax errors. If there are no errors, you’ll see the following output:\n\nOnce you’ve verified that your configuration is correct, you can restart NGINX to apply the changes by running the following command:\n\nIf you have subdomains that need to be routed to different backend servers, you can add them to the NGINX configuration by creating a new configuration file for each subdomain. For example, to add a subdomain called “api.example.com”, create a new configuration file:\n\nIn this file, add the following code:\n\nThis configuration is similar to the one for the main domain, but it routes requests to a different port (in this case, port 4000). \n\nOnce you’ve created the configuration file, enable it by creating a symbolic link:\n\nRestart NGINX to apply the changes:\n\nIf you’re running a high-traffic Node.js app, distributing incoming requests across multiple backend servers can help you handle more requests, reduce response times, and improve overall performance and reliability. NGINX can act as a powerful load balancer that can help you achieve these goals.\n\nHere’s a step-by-step guide to configuring load balancing with NGINX for your Node.js app:\n\nSimilar to configuring NGINX as a reverse proxy, you’ll need to set up your Node.js app as an upstream server. This can be done by adding the following lines to your Node.js app’s configuration file, replacing the IP address and port with those of your Node.js servers:\n\nThis configuration creates an upstream server named “nodes” that points to two Node.js servers running on IP addresses 192.0.2.10 and 192.0.2.11, both running on port 3000.\n\nNext, you’ll need to configure NGINX as a load balancer by adding the following configuration block to your NGINX server block:\n\nThis configuration block defines an upstream server named “nodes” that points to two Node.js servers running on IP addresses 192.0.2.10 and 192.0.2.11, both running on port 3000. The server block listens on port 80 and responds to requests for the domain. The location block proxies all requests to the upstream server, which will distribute incoming requests to both backend servers.\n\nFinally, you’ll want to test your configuration to ensure that NGINX is properly configured as a load balancer for your Node.js app. You can do this by running the following command:\n\nThis will test your NGINX configuration and report any errors. If no errors are reported, you can reload your NGINX configuration using the following command:\n\nRunning a Node.js app with multiple domains can be a complex task, but with NGINX, it’s easier than you might think. In this guide, we’ll explain how to configure NGINX to handle multiple domains and subdomains for your Node.js app.\n\nThe first step is to create separate configuration files for each of your domains. You can create a new file for each domain in the /etc/nginx/sites-available directory, with a filename that matches your domain name. For example, if your domain name is example.com, create a new file named example.com.conf.\n\nHere’s an example configuration file for a Node.js app running on example.com:\n\nThis configuration file sets up a server block that listens on port 80 for requests to example.com. The location block proxies incoming requests to a Node.js app running on localhost:3000.\n\nNext, you’ll need to enable your configuration files by creating a symbolic link from the /etc/nginx/sites-available directory to the /etc/nginx/sites-enabled directory. You can do this using the following command:\n\nReplace example.com.conf with the filename of your configuration file.\n\nOnce you’ve created and enabled your configuration files, you’ll need to test your configuration to ensure that NGINX is properly configured for multiple domains. You can do this by running the following command:\n\nThis will test your NGINX configuration and report any errors. If no errors are reported, you can reload your NGINX configuration using the following command:\n\nIn this guide, I showed you how to use NGINX reverse proxy to improve the performance of your Node.js app on multiple domains. By configuring NGINX to act as a reverse proxy and load balancer, you can distribute incoming requests to multiple backend servers and improve the overall performance and reliability of your app. With these steps, you can easily set up NGINX reverse proxy on your own server and enhance the performance of your Node.js app.\n\nIf you found this article helpful and informative, please like it and follow for more such articles. I would love to hear your comments and experiences related to proxies , feel free to share them below to discuss further."
    },
    {
        "link": "https://stackoverflow.com/questions/60139257/running-nginx-to-serve-files-and-act-as-a-reverse-proxy-for-node-app-on-same-dom",
        "document": "I am currently trying to run Nginx as a reverse proxy for a small Node application and serve up files for the core of a site.\n\nThis appeared to work at first glance, but what I have found over time is that I am being served 502 errors constantly on the Node app route. This applies to both the app itself, as well as static assets included in the app.\n\nI've tried using various different variations of the above config, but nothing I can find seems to fix the issue. I had read of issues with SELinux, but this is currently not on the server in question.\n\nHas anyone encountered similar issues, or knows what it is that I've done wrong?"
    }
]