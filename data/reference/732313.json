[
    {
        "link": "https://hub.spigotmc.org/javadocs/spigot/index.html?overview-summary.html",
        "document": "The documentation is for developing plugins and is split into the respective packages for each subject matter. This documentation does not cover running a server, contributing code back to the project, or setting up a workspace. Working knowledge of the Java language is a prerequisite for developing plugins.\n\nFor basic plugin development, see the . It covers the basic requirements of a plugin jar.\n\nFor handling events and triggered code, see the .\n\nNote: While the Bukkit API makes every effort to ensure stability, this is not guaranteed, especially across major versions. In particular the following is a (incomplete) list of things that are not API.\n• Implementing interfaces or extending classes. The Bukkit API is designed to only be implemented by server software. Unless a class/interface is obviously designed for extension (eg ), or explicitly marked as such, it should not be implemented or extended by plugins. Although this can sometimes work, it is not guaranteed to do so and resulting bugs will be disregarded.\n• Constructing inbuilt events. Although backwards compatibility is attempted where possible, it is sometimes not possible to add new fields to events without breaking existing constructors. To ensure that the API continues to evolve, event constructors are therefore not plugin API.\n• Implementation classes. Concrete implementation classes packaged with Bukkit (eg those beginning with Simple) are not API. You should access them via their interfaces instead.\n• The \"enumness\" of enums which implement . Such enums are liable to conversion to regular classes and therefore usages deriving from their status as an enum (including, but not limited to, use in switch statements and classes such as ) should be avoided."
    },
    {
        "link": "https://hub.spigotmc.org/javadocs/spigot",
        "document": "The documentation is for developing plugins and is split into the respective packages for each subject matter. This documentation does not cover running a server, contributing code back to the project, or setting up a workspace. Working knowledge of the Java language is a prerequisite for developing plugins.\n\nFor basic plugin development, see the . It covers the basic requirements of a plugin jar.\n\nFor handling events and triggered code, see the .\n\nNote: While the Bukkit API makes every effort to ensure stability, this is not guaranteed, especially across major versions. In particular the following is a (incomplete) list of things that are not API.\n• Implementing interfaces or extending classes. The Bukkit API is designed to only be implemented by server software. Unless a class/interface is obviously designed for extension (eg ), or explicitly marked as such, it should not be implemented or extended by plugins. Although this can sometimes work, it is not guaranteed to do so and resulting bugs will be disregarded.\n• Constructing inbuilt events. Although backwards compatibility is attempted where possible, it is sometimes not possible to add new fields to events without breaking existing constructors. To ensure that the API continues to evolve, event constructors are therefore not plugin API.\n• Implementation classes. Concrete implementation classes packaged with Bukkit (eg those beginning with Simple) are not API. You should access them via their interfaces instead.\n• The \"enumness\" of enums which implement . Such enums are liable to conversion to regular classes and therefore usages deriving from their status as an enum (including, but not limited to, use in switch statements and classes such as ) should be avoided."
    },
    {
        "link": "https://helpch.at/docs/1.20",
        "document": "The documentation is for developing plugins and is split into the respective packages for each subject matter. This documentation does not cover running a server, contributing code back to the project, or setting up a workspace. Working knowledge of the Java language is a prerequisite for developing plugins.\n\nFor basic plugin development, see the . It covers the basic requirements of a plugin jar.\n\nFor handling events and triggered code, see the .\n\nNote: While the Bukkit API makes every effort to ensure stability, this is not guaranteed, especially across major versions. In particular the following is a (incomplete) list of things that are not API.\n• Implementing interfaces. The Bukkit API is designed to only be implemented by server software. Unless a class/interface is obviously designed for extension (eg ), or explicitly marked as such, it should not be implemented by plugins. Although this can sometimes work, it is not guaranteed to do so and resulting bugs will be disregarded.\n• Constructing inbuilt events. Although backwards compatibility is attempted where possible, it is sometimes not possible to add new fields to events without breaking existing constructors. To ensure that the API continues to evolve, event constructors are therefore not plugin API.\n• Implementation classes. Concrete implementation classes packaged with Bukkit (eg those beginning with Simple) are not API. You should access them via their interfaces instead."
    },
    {
        "link": "https://bukkit.org/threads/where-can-i-find-the-bukkit-api-documentation.348177",
        "document": ""
    },
    {
        "link": "https://helpch.at/docs/1.16.5",
        "document": "The documentation is for developing plugins and is split into the respective packages for each subject matter. This documentation does not cover running a server, contributing code back to the project, or setting up a workspace. Working knowledge of the Java language is a prerequisite for developing plugins.\n\nFor basic plugin development, see the . It covers the basic requirements of a plugin jar.\n\nFor handling events and triggered code, see the .\n\nNote: While the Bukkit API makes every effort to ensure stability, this is not guaranteed, especially across major versions. In particular the following is a (incomplete) list of things that are not API.\n• Implementing interfaces. The Bukkit API is designed to only be implemented by server software. Unless a class/interface is obviously designed for extension (eg ), or explicitly marked as such, it should not be implemented by plugins. Although this can sometimes work, it is not guaranteed to do so and resulting bugs will be disregarded.\n• Constructing inbuilt events. Although backwards compatibility is attempted where possible, it is sometimes not possible to add new fields to events without breaking existing constructors. To ensure that the API continues to evolve, event constructors are therefore not plugin API.\n• Implementation classes. Concrete implementation classes packaged with Bukkit (eg those beginning with Simple) are not API. You should access them via their interfaces instead."
    },
    {
        "link": "https://bukkit.org/threads/tutorial-metadata-what-it-is-and-how-to-use-it.276338",
        "document": "\n• None * To put some context into it, I use metadata in relation to zombies in my King\n• None * of the Hill plugin. This has saved me lots of time and code from using NMS /\n• None * Reflection where it was unnecessary.\n• None * This static method will spawn a zombie on the player and add metadata.\n• None * Note: Adding metadata does not make the zombie stop attacking the player,\n• None * you will need to listen for that in an EntityTargetEvent.\n• None * this is your main class. Replace \"MainClass\" with the class\n• None * this is the player we want to make the owner of the zombie.\n• None * the metadata tag that we will use to get the zombie anywhere else in\n• None * There are two types of metadata: LazyMetadataValues, and\n• None * FixedMetadataValues which extend lazy ones. We will be working with\n• None * A FixedMetadataValue is, well, fixed. It is unchanging and therefore\n• None * You will need to call a new FixedMetadataValue, which requires a\n• None * plugin argument and an arbitrary string. This string does not matter\n• None * and you can name it whatever you want. I recommend that your plugin\n• None * directly points your main class but Plugin, and JavaPlugin variable\n• None * Metadata is useless unless we can check if the zombie has metadata to\n• None * @return the player, or null if none was found online.\n• None * Remember how we set metadata. We had a string argument, and a\n• None * metadata value. If the zombie has a metadata cache with this\n• None * string value, we have a match.\n• None * So right away with a few lines of code we are able to retrieve a\n• None * player who the zombie belongs to.\n• None * Maybe we want to remove the player as a zombie owner. We can do that\n• None * because the Metadata API allows us to remove metadata with just one line\n• None * the zombie who has the metadata to be removed.\n• None * the player whose name is the metadata.\n• None * we need a plugin argument to remove metadata.\n• None * based on this string argument, so we don't accidentally avoid all\n• None * metadata tags from other plugins or even elsewhere in this\n• None * plugin. (Yes! The plot thickens: You can have multiple metadata\n• None * We also need the plugin argument from which we set metadata."
    },
    {
        "link": "https://spigotmc.org/threads/tutorial-obtaining-actual-item-names.35088",
        "document": ""
    },
    {
        "link": "https://bukkit.org/threads/how-would-i-check-the-metadata-of-a-item.240291",
        "document": "[16:49:30 ERROR]: Could not pass event PlayerInteractEvent to VoidGuns v1.7.5\n\n org.bukkit.event.EventException\n\n at org.bukkit.plugin.java.JavaPluginLoader$1.execute(JavaPluginLoader.java:320) ~[craft.jar:git-Bukkit-1.7.2-R0.2-50-gdce2b35-b\n\n 3019jnks]\n\n at org.bukkit.plugin.RegisteredListener.callEvent(RegisteredListener.java:62) ~[craft.jar:git-Bukkit-1.7.2-R0.2-50-gdce2b35-b30\n\n 19jnks]\n\n at org.bukkit.plugin.SimplePluginManager.fireEvent(SimplePluginManager.java:486) [craft.jar:git-Bukkit-1.7.2-R0.2-50-gdce2b35-b\n\n 3019jnks]\n\n at org.bukkit.plugin.SimplePluginManager.callEvent(SimplePluginManager.java:471) [craft.jar:git-Bukkit-1.7.2-R0.2-50-gdce2b35-b\n\n 3019jnks]\n\n at org.bukkit.craftbukkit.v1_7_R1.event.CraftEventFactory.callPlayerInteractEvent(CraftEventFactory.java:195) [craft.jar:git-Bu\n\n kkit-1.7.2-R0.2-50-gdce2b35-b3019jnks]\n\n at org.bukkit.craftbukkit.v1_7_R1.event.CraftEventFactory.callPlayerInteractEvent(CraftEventFactory.java:165) [craft.jar:git-Bu\n\n kkit-1.7.2-R0.2-50-gdce2b35-b3019jnks]\n\n at net.minecraft.server.v1_7_R1.PlayerConnection.a(PlayerConnection.java:604) [craft.jar:git-Bukkit-1.7.2-R0.2-50-gdce2b35-b301\n\n 9jnks]\n\n at net.minecraft.server.v1_7_R1.PacketPlayInBlockPlace.a(SourceFile:60) [craft.jar:git-Bukkit-1.7.2-R0.2-50-gdce2b35-b3019jnks]\n\n \n\n at net.minecraft.server.v1_7_R1.PacketPlayInBlockPlace.handle(SourceFile:9) [craft.jar:git-Bukkit-1.7.2-R0.2-50-gdce2b35-b3019j\n\n nks]\n\n at net.minecraft.server.v1_7_R1.NetworkManager.a(NetworkManager.java:146) [craft.jar:git-Bukkit-1.7.2-R0.2-50-gdce2b35-b3019jnk\n\n s]\n\n at net.minecraft.server.v1_7_R1.ServerConnection.c(SourceFile:134) [craft.jar:git-Bukkit-1.7.2-R0.2-50-gdce2b35-b3019jnks]\n\n at net.minecraft.server.v1_7_R1.MinecraftServer.u(MinecraftServer.java:655) [craft.jar:git-Bukkit-1.7.2-R0.2-50-gdce2b35-b3019j\n\n nks]\n\n at net.minecraft.server.v1_7_R1.DedicatedServer.u(DedicatedServer.java:250) [craft.jar:git-Bukkit-1.7.2-R0.2-50-gdce2b35-b3019j\n\n nks]\n\n at net.minecraft.server.v1_7_R1.MinecraftServer.t(MinecraftServer.java:545) [craft.jar:git-Bukkit-1.7.2-R0.2-50-gdce2b35-b3019j\n\n nks]\n\n at net.minecraft.server.v1_7_R1.MinecraftServer.run(MinecraftServer.java:457) [craft.jar:git-Bukkit-1.7.2-R0.2-50-gdce2b35-b301\n\n 9jnks]\n\n at net.minecraft.server.v1_7_R1.ThreadServerApplication.run(SourceFile:617) [craft.jar:git-Bukkit-1.7.2-R0.2-50-gdce2b35-b3019j\n\n nks]\n\n Caused by: java.lang.NullPointerException\n\n at com.voidGuns.main.ShootingListiner.RightClick(ShootingListiner.java:34) ~[?:?]\n\n at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:1.7.0_40]\n\n at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) ~[?:1.7.0_40]\n\n at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) ~[?:1.7.0_40]\n\n at java.lang.reflect.Method.invoke(Unknown Source) ~[?:1.7.0_40]\n\n at org.bukkit.plugin.java.JavaPluginLoader$1.execute(JavaPluginLoader.java:318) ~[craft.jar:git-Bukkit-1.7.2-R0.2-50-gdce2b35-b\n\n 3019jnks]\n\n ... 15 more"
    },
    {
        "link": "https://spigotmc.org/threads/set-metadata-on-a-itemstack.493039",
        "document": ""
    },
    {
        "link": "https://bukkit.org/threads/tutorial-attaching-metadata-to-itemstacks.221480",
        "document": "\n• None imd. \"values can also be numbers\" ,\n• None list. // Impossible: you can only add objects of 1 type to a list (it's the way how Bukkit handles it)\n• None imd. \"values can also be lists\" , list\n• None compound. , // Used the same way as ItemMetaData because it extends TagCompound\n• None imd. \"values can also be compounds\" , compound\n• None // Do something with the item stack..."
    }
]