[
    {
        "link": "https://forum.multitheftauto.com/topic/121619-lua-for-absolute-beginners",
        "document": "This tutorial can also be viewed on GitHub\n\nThis tutorial aims to teach the Lua scripting language to those with 0 previous experience with programming / scripting.\n\n This guide will start with explaining some Lua concepts, and will later on move to explaining MTA:SA specific concepts.\n\nThis part of the tutorial discusses Lua itself. No MTA-specific concepts will be discussed here.\n\nThe Lua scripting language is a language which is interpreted by a \"Lua interpreter\". MTA:SA's resources use such an interpreter to run Lua code. For the beginning of this tutorial you can use the online Lua interpreter available on https://www.Lua.org/demo.html. Any code in the Lua part of the tutorial can be run on this website.\n\nLua is written in \"plain text\". This means it exists of regular characters like any other text you are writing. To edit Lua files you will require a text editor. You use Notepad, but there are many far better alternatives. My personal favourite is Visual Studio Code, but there are many other good options, to name a few: Atom, sublime text, notepad++\n\n Lua files are usually saved with the file extension\n\nThe first concept we're going to discuss is variables. Variables allow you to store a value in your code.\n\n For example:\n\nwill output the value of the variable. We will get into what exactly is later in the tutorial.\n\nVariables can have any name you want, as long as you follow some specific rules.\n• variable names must start with a letter (lower or upper case), or an underscore (_)\n• variable names may contain letters (lower and upper case), numbers and underscores.\n\nThe convention in Lua is to name your variables in \"camelCase\". This means if a variable exists of multiple words you start every word with a capital letter, except for the first one.\n\nSo far we've seen variables used to store numeric values, but there are many different types of data Lua can handle. These are:\n• string\n\n A piece of text, a string is surrounded by or . For example or 'Hello world'\n• boolean\n\n A boolean is a data type that has only 2 options, and .\n• nil\n\n is a value indicating nothing. It's the absence of a value. (Not the be confused with 0)\n• table\n\n Tables will be discussed later in the tutorial\n• userdata\n\n Userdata will be discussed later in the tutorial\n• function\n\n Functions will be discussed later in the tutorial\n• thread\n\n Threads are out of scope for this tutorial and won't be discussed\n\nSo we can use these different data types, and store them in variables:\n\nOperators are symbols in Lua which can be used to do \"things\" with variables. Here's a list of operators and an example for each:\n\nSubtracts a value from another value\n\nDivides a value by another value\n\nThis is the \"modulo\" operator. This will divide a value by another, and return the leftover.\n\nThe result of this is\n\nThe operator will return if both variables are \"truthy\". Otherwise it returns \n\n (A \"truthy\" value is anything except for and )\n\nThe operator will return if one of the variables are \"truthy\". Otherwise it returns\n\nThe (equals) operator will return if both of the variables are the same. Otherwise it returns\n\nThe (does not equal) operator will return if both variables are not the same. Otherwise it returns\n\nThe (greater than) operator will return if the first value is greater than the second value. Otherwise it returns\n\nThe (greater than or equals) operator will return if the first value is greater than, or equal to, the second value. Otherwise it returns\n\nThe (less than) operator will return if the first value is less than the second value. Otherwise it returns\n\nThe (less than or equals) operator will return if the first value is less than, or equal to, the second value. Otherwise it returns\n\nThe (string concatanation) operator allows you to add two strings together.\n\nAn statement allows your code to decide to do something, or not. Depending on a value. Often times statements are used in combination with some of the above operators.\n\nAn if statement is written as :\n\nAny code between and will only be executed when the expression is true. You might also have noticed that the code between the and is moved over a bit to the right. This is called \"indentation\". Whenever we open a new scope (scopes will be discussed later in the tutorial) we move our code to the right. This is usually done by either a or several spaces . Many code editors will convert a to spaces.\n\nWithin an statement, you can also add an block. The code in such a block will be executed when the code in the block is not executed.\n\nIf you want to do multiple statements, you can use an :\n\nThe difference between the first example and the second is that if is higher than 10 in the first example both lines \"X is higher than 10\" and \"X is higher than 5\" will be output. Whilst in the second example only \"X is higher than 10\" will be output.\n\nAnd if statement must always start with an , can contain multiple s, and may only have one .\n\nFunctions allow you to write less code, by reusing pieces of code.\n\nThe syntax to create a function is\n\nIn order to execute code in the function, you \"call\" the function. You do this by writing the function name followed by .\n\nFunctions also allow you to send a variable to the function, for it to do something with. This is what's called a function parameter. Function parameters are defined in the brackets after the function name.\n\nYou may notice that this looks a lot like the we have been using. This is because is a built-in Lua function.\n\nA function not only can execute code, it can also give something back to where it was called. This is called a . In order to return something from a function you use the keyword.\n\nJust like in an statement, all code within a function is indented.\n\nNow let's combine everything we have learnt so far:\n\nWe quickly encountered scopes before, and said we indent our code whenever we enter a new scope. But scopes allow you to do more than that. Most importantly, \"local\" variables.\n\nA local variable is only available in the scope it was defined in (or scopes that were created from within that scope)\n\nYou can create a new scope using a block ( s and statements also have their own scope).\n\n(For) loops are ways in scripting / programming to have code executed multiple times, without having to write the same thing multiple times.\n\n An example of such a loop:\n\nThe first part : defines a variable called . Which start at . This will be incremented by 1, until it reaches . The code within the loop then can use this variable.\n\nYou can also increment with a different number than (including negative numbers) using this construct.\n\nThis code sample will start with at 20, and keep adding (thus subtracting ), until it reaches\n\nTables are a datatype in Lua which allows for lists of things.\n\n Here's an example:\n\nTables consist of key/value pairs. In the example above the key , has the value , has the value , and has the value .\n\n You can get the value in a table, by putting the key in between square brackets . Like in .\n\nYou can choose to not include the keys in a table. Doing so will automatically add numbers as keys, starting at 1. So the above example would be the exact same as the first example.\n\nTable keys and values can be of any data type, including other tables. This allows you to create (very) complex table structures.\n\nWhen using a string as the key in a table, you can leave out the square brackets and the quotes. This goes for both when defining the table, and for indexing it (getting a value from it). For example\n\nA table's values can be modified / set after creating the table as well.\n\nWhen using tables you will often want to add something to the \"end\" of a table. This is most common when you are using tables with numeric keys.\n\n In order to do this you can use a to get the amount of items currently in the table.\n\nThis will store the value on the key , because is 3.\n\nIterators are a mechanism that allow you to make a loop, which goes over a set of values. Writing your own iterators won't be discussed in this tutorial. But there are two functions which are often used to create an iterator to iterate over a table. These are and .\n\nThe difference between and is the order in which the key/value pairs are iterated over, and which of the key/value pairs are iterated over.\n\n Where will always use numeric keys, starting at , and going up by every time, until there is no entry in the table. This also means it won't iterate over anything key that is not numeric.\n\nA loop will iterate over any value in a table, but the order is not guaranteed. Meaning that between different runs of the script the order could be different.\n\nCallbacks are when you pass a function as an argument to another function. To have the function you passed be called later on. This is used often within MTA.\n\nAn example of a Lua function which uses a callback is . will sort a tables values, by default these values are sorted numerically. But you can use a callback to change this behaviour.\n\nIn the first call to ( ) you can see the function is passed as second argument to the function. Note that we don't write here (notice the brackets difference) because that would call the function, and pass its return value to .\n\nwill then call this function when it compares two different values, this function should return or depending on whether its second argument ( in this case) is larger than it's first argument ( ), in the context of sorting.\n\nIt is also possible to use an \"anonymous function\" when passing a callback to a function.\n\nThis part of the tutorial discusses MTA specific constructs. Code in this part of the tutorial won't run in the online Lua interpreter. You will need to set up a (local) server for this.\n\nBy default when installing MTA:SA a server is installed as well. This server is located in the directory of your MTA directory. This is usually at . This directory contains an file, running this file will start a server.\n\nScripts on a server are grouped by resources, a single resource can consist of multiple script files and other assets such as images, sounds, fonts, mods and more.\n\nResources are placed in your folder in your server folder. A resource is always in its own directory. A resource must always have a single file. This file tells the server (among others) what script files to load. A typical meta.xml file looks like this:\n\nYou will need an entry for every .Lua file you want to have executed on the server.\n\nYou can start a resource by typing in the server console (the window that opened when you started ). The resource name is the name of the directory your is in. (This may not have spaces).\n\n Starting a resource will start running the Lua scripts, if you've changed your scripts you will need to restart the resource for the changes to take effect. ( ).\n\nLua code can be executed in one of two places. The server, or the client.\n\n Server sided scripts are executed on the actual machine that is running the process.\n\n Client sided scripts are executed on the computer of every player that connects to your server.\n\nServer sided and client sided scripts have a distinct difference in responsibility and possibility. Some functions for example are only available on the client, whilst others are available only on the server (and many on both).\n\nNote: Some of these functions which are available both server sided and client sided are different on server and client\n\nIn plain Lua there's not much you can do to affect a game engine like MTA:SA. This is why MTA:SA offers a (large) list of functions available for you to use in your scripts which interact with the actual GTA world.\n\n You can find a list of all of these, what they do and how to use them on the MTA wiki.\n\nAn example of such a function is createObject(). This function will create a physical object in the game. The wiki page contains information on how to use it (what arguments it expects, and in what order). And often shows an example of how to use it.\n\nAt the start of this tutorial we quickly mentioned data types. These are data types configurable by the implementation of Lua. In this case, MTA.\n\n MTA uses userdata to represent \"elements\". Many things in MTA are elements, like objects, markers, peds, players, user interfaces, vehicles, etc.\n\n On the MTA wiki you will notice many functions either return elements, or require an element as arguments.\n\n A list of different types of elements can be found on the MTA wiki.\n\nElements also have a hierarchical structure to them. Elements can have a \"parent\", and multiple \"children\". This will result in a tree of elements, the element at the top of this tree (and thus the grandparent of all elements) is called the root element.\n\nOften times in MTA you want certain things to happen when a player enters a command. This is done using command handlers, command handlers use a callback, which we previously discussed.\n\n The wiki contains a page for the addCommandHandler() function. For this example we will be using the server side version.\n\nThis example also uses the outputChatBox() function, this will output a piece of text to the chat.(in this case, only for the player who executed the command)\n\nThe callback function passed to will be called every time a player uses the command ingame.\n\nBesides having your script do things when a user executes a command you likely want the game to respond to many different types of things that happen in the game. Like players taking damage, coming close to something, etc.\n\n These things are called events. Whenever an event is triggered you can run a piece of Lua code. You do this using event handlers. Event handlers are created using the addEventHandler().\n\nThe first argument to the function is the string name of the event. These can be found on the MTA wiki as well.\n\nAn event is always triggered for a specific element, for example is triggered on the player that was wasted (killed).\n\n You can attach an event handler to a single element to only have your callback function be called when the event is triggered on that specific element. But you could also use the root element here and your function will be called for every element the event is triggered on.\n\nThe getRootElement() function used in this example returns the root element discussed earlier.\n\n You can also see is used in this code snippet, we'll talk about that some more in the next section.\n\nMTA has some predifined global variables for you to use in your script.\n\n A list of them can be found on the wiki.\n\nHere's a couple notable ones and what they're used for\n• The root element, same as the return value of )\n• The element an event handler was called on. An event's wiki page always describes what the event source will be for the event.\n• The player element for the player whose client the script is running on. (Thus only available client sided)\n• Will be discussed in the next section\n\nAs stated earlier in this tutorial scripts can run either on the server, or one of the connected clients. However often times you would want to trigger something on the server from a client, or the other way around.\n\nAn example of this would be when the user clicks the login button on a GUI (Graphical user interface) the server should try to log that person in, and send him back whether or not this was successful.\n\nThis can be done using events. MTA allows you to create and trigger your own events, and these events can be triggered from server to client (and the other way around). You can do this using the addEvent() function.\n\n Once an event has been added (and marked as remotely triggerable by passing as second argument to ) you can call it from server/client. You do this using [triggerClientEvent()]https://wiki.multitheftauto.com/wiki/TriggerClientEvent() and triggerServerEvent() respectively.\n\nThis example will trigger the event from the client sided script. And passes the and arguments to the event.\n\n The server then handles this event in the function, which in our case just outputs something to the chatbox.\n\nIn this example you can see the previously mentioned global variable.\n\n This variable is set to the player element corresponding to the client the event was triggered from. (And is thus only usable when used in an event handler which has been triggered from a client).\n\nWith this information you should be able to start scripting, and making things in MTA! If you didn't understand it all in one go, or you have any more questions there is no shame in that!\n\n You can find myself and many others willing to help you with your scripting questions in the #scripting channel on the MTA discord.\n\n Another good source for programming / scripting related questions is stack overflow."
    },
    {
        "link": "https://wiki.multitheftauto.com/wiki/Scripting_Introduction",
        "document": "Resources are a key part of MTA. A resource is essentially a folder or zip file that contains a collection of files, plus a \"meta\" file that describes to the server how the resource should be loaded and what files it does contain. A resource can be seen as being partly equivalent to a program running in an operating system - it can be started and stopped, and multiple resources can run at once.\n\nEverything that has to do with scripting happens in resources, what a resource does defines if it is a gamemode, a map, or anything else. MTA comes with resources that you can optionally use in your gamemodes, such as map limits to keep playings within a playing area or death-pickups to create weapon pickups.\n\nWe will first learn how to make a basic script that lets the player walk around in the city, step by step.\n\nWhere are all the scripts?\n\nLet's take a look at the script's file structure. Go to your MTA Server folder, and follow the path below:\n\nYou will see a lot of .zip files, which are the packaged sample scripts shipped with MTA. Each file is a \"resource\", and they will all be unzipped and loaded by the server when it starts. To create your own resource, simply make a folder with your preferred name. We'll use \"myserver\" for this tutorial.\n\nNow you should be under this directory:\n\nIn order to let the server know what's in the resource, a meta.xml file must be created to list the resource's content. It must be located in the resource's root directory, which is the \"myserver\" folder in our case. So create a text file and name it \"meta.xml\", and open it with notepad.\n\nEnter the following codes in the meta.xml file:\n\nIn the <info /> tag, there's a \"type\" field which indicates that the resource is a gamemode instead of a regular include or a map, which will be explained later. A gamemode is what you need to make a stand-alone server.\n\nThe <script /> tag indicates the script files contained in the resource, which we will create next.\n\nNote that in the <script /> tag above, the .lua file is not under another directory. Therefore we'll create the file in the same folder as meta.xml. Now you can copy and paste the following code into script.lua:\n\nThe script will spawn you at the coordinate (x, y, z) specified above when you join the game. Note that the fadeCamera function must be used or the screen will be black. Also, in releases after DP2, you need to set the camera target (otherwise all the players will see is the blue sky).\n\nThe source variable indicates who triggered the event. Since a player has joined when the code is triggered, you use this variable to look which has joined. So it'll spawn that player instead of everyone or a random person.\n\nIf we have a closer look on addEventHandler, you can see 3 things: 'onPlayerJoin', which indicates when it's triggered. getRootElement(), which shows by what/who it can be triggered. (getRootElement() is everything/everyone) And joinHandler, which indicates the function that has to be triggered after the event is triggered. Other details will be explained later in another example, now let's just run the server and try it out!\n\nTo get the server started, simply run the executable under the server/ directory. A list of server stats will be shown first; note the port number, which you'll need when joining the game. Then the server loads all the resources under the mods/deathmatch/resources/ directory, and then \"ready to accept connections!\"\n\nBefore you connect to the server, you must run the gamemode. Type \"start myserver\" and press Enter. The server will start the gamemode you just created, and will also show any errors and warnings from this point on. Now you can start the MTA client, and \"Quick Connect\" using the IP address of your server and the port number you saw earlier. If all goes well, after a few seconds your character will be walking on the streets of Los Santos.\n\nNext, we'll add a command to your script that players can use to spawn a vehicle beside their position. You may skip it and check out more advanced scripting with the Map Manager, which continues this tutorial. Another branch from this tutorial is Introduction to Scripting GUI, you may follow it to see how the Graphical User Interface in MTA is drawn and scripted.\n\nLet's go back to the content of the script.lua file. As mentioned above, we want to provide a command to create a vehicle beside your current position in the game. Firstly we need to create a function we want to call and a command handler that creates the command the player will be able to enter in the console.\n\nNote: Function names are clickable in code examples on the wiki and linked to the functions' documentation.\n\nThe first argument of addCommandHandler is the name of the command the player will be able to enter, the second argument is the function this will call, in this case createVehicleForPlayer.\n\nIf you have already experienced in scripting, you will know that you call a function like this:\n\nIf we have a closer look on the lower example above, we can see argument1 is thePlayer and argument2 the commandName. thePlayer is simply the one who typed the command, so whatever you call it, the variable will contain the player who activated the command. commandName is simply the command they typed. So if they typed \"/greet\", this argument will contain \"greet\". Argument 3 is something extra the player typed, you'll learn it a little bit further in the tutorial. Never forget that the first 2 arguments are standard arguments, but you can name them to anything you want.\n\nWe called the addCommandHandler function this way already and since createVehicleForPlayer is a function too, it can be called that way as well. But we are using a command handler for that, which calls it in a similar manner, internally.\n\nFor example someone types \"createvehicle 468\" in-game in the console to spawn a Sanchez, the command handler calls the createVehicleForPlayer function, as if we would have this line of code in the script:\n\nAs we can see, it provides several parameters: the player who called the command, the command he entered, and whatever text he had after that, in this case, \"468\" as vehicle id for the Sanchez. The first two parameters are the same with all command handlers, which you can read on the addEventHandler page. For this fact, you always have to define at least those two parameters to use any after that (for example to process text that was entered after the command, like in our example the vehicle model id).\n\nNote: You have to add the command handler AFTER you defined the handler function, else it can't find it. The order of execution matters.\n\nIn order to fill the function we created, we need to think about what we have to do:\n• Get the players position, so we know where to spawn the vehicle (we want it to appear right beside the player)\n• Calculate the position we want to spawn the vehicle at (we don't want it to appear in the player)\n• Check if it has been spawned successfully, or output a message\n\nIn order to achieve our goals, we have to use several functions. To find the function we need to use, we should visit the Server Functions List. First, we need a function to get the player's position. Since players are Elements, we first jump to the Element functions where we find the getElementPosition function. By clicking on the function name in the list, you get to the function description. There we can see the syntax, what it returns, and usually an example. The syntax shows us what arguments we can or have to submit.\n\nFor getElementPosition, the syntax is:\n\nThe three float in front of the function name is the return type. In this case, it means the function returns three floating-point numbers. (x, y, and z) Within the parentheses, you can see what arguments you have to submit. In this case, only the element whose position you want to get, which is the player in our example.\n\nNext, we want to ensure that the vehicle won't spawn directly in the player, so we add a few units to the x variable, which will make it spawn east from the player.\n\nNow we need another function, one to spawn a vehicle. We once again search for it on the Server Functions List, this time - since we are talking about vehicles - in the Vehicle functions section, where we will choose createVehicle. In this function's syntax, we only have one return type (which is more common), a vehicle element that points to the vehicle we just created. Also, we see that some arguments are enclosed within [ ] which means that those are optional.\n\nWe already have all arguments we need for createVehicle in our function: The position we just calculated in the x,y,z variables and the model id that we provided through the command (\"createvehicle 468\") and can access in the function as vehicleModel variable.\n\nOf course, this code can be improved in many ways, but at least we want to add a check whether the vehicle was created successfully or not. As we can read on the createVehicle page under Returns, the function returns false when it was unable to create the vehicle. Thus, we check the value of the createVehicle variable.\n\nNow we have our complete script:\n\nAs you can see, we introduced another function with outputChatBox. By now, you should be able to explore the function's documentation page yourself. For more advanced scripting, please check out the Map Manager.\n\nWhat you need to know\n\nYou already read some things about resources, command handlers, and finding functions in the documentation in the first paragraph, but there is much more to learn. This section will give you a rather short overview over some of these things while linking to related pages if possible.\n\nYou may have already noticed these or similar terms (Server/Client) somewhere on this wiki, mostly in conjunction with functions. MTA not only supports scripts that run on the server and provide commands (like the one we wrote above) or other features but also scripts that run on the MTA client the players use to connect to the server. The reason for this is, that some features MTA provides have to be clientside (like a GUI - Graphical User Interface), others should be because they work better and still, others are better off to be serverside or just don't work clientside.\n\nMost scripts you will make (gamemodes, maps) will probably be serverside, like the one we wrote in the first section. If you run into something that can't be solved serverside, you will probably have to make it clientside. For a clientside script, for example, you would create an ordinary script file (for example called client.lua) and specify it in the meta.xml, like this:\n\nThe type attribute defaults to 'server', so you only need to specify it for client-side scripts. When you do this, the clientside script will be downloaded to the player's computer once he connects to the server. Read more about Client side scripts.\n\nThe previous section showed briefly how to add clientside scripts to the resource, but there is also much more possible. As mentioned at the very top of this page, resources can be pretty much everything. Their purpose is defined by what they do. Let's have some theoretical resources, by looking at the files it contains, the meta.xml and what they might do:\n• The commands.lua provides some admin commands, like banning a player, muting or something else that can be used to admin the server\n• The client.lua provides a GUI to be able to perform the mentioned actions easily\n\nThis example might be running all the time (maybe even auto-started when the server starts) as it's useful during the whole gaming experience and also won't interfere with the gameplay, unless an admin decides to take some action of course.\n• The counterstrike.lua contains similar to the following features:\n• Let players choose their team and spawn them\n• Provide them with weapons, targets, and instructions (maybe read from a Map, see below)\n• Define the game's rules, e.g. when does the round end, what happens when a player dies\n• .. and maybe some more\n• The buymenu.lua is a clientside script and creates a menu to buy weapons\n\nThis example can be called a gamemode, since it not only interferes with the gameplay but actually defines the rules of it. The type attribute indicates that this example works with the Map manager, yet another resource that was written by the QA Team to manage gamemodes and map loading. It is highly recommended that you base your gamemodes on the techniques it provides.\n\nThis also means that the gamemode probably won't run without a map. Gamemodes should always be as generic as possible. An example of a map is stated in the next example.\n• The airport.map in an XML file that provides information about the map to the gamemode, these may include:\n• Where the players should spawn, with what weapons, what teams there are\n• What the targets are\n• The airport.lua might contain map-specific features, that may include:\n• Opening some door/make something explode when something specific happens\n• Create or move some custom objects, or manipulate objects that are created through the .map file\n• .. anything else map-specific you can think of\n\nAs you can see, the type attribute changed to 'map', telling the Map manager that this resource is a map, while the gamemodes attribute tells it for which gamemodes this map is valid, in this case, the gamemode from the above example. What may come as a surprise is that there is also a script in the Map resource. Of course, this is not necessarily needed in a map but opens a wide range of possibilities for map makers to create their own world within the rules of the gamemode they create it for.\n\nThe airport.map file might look similiar to this:\n\nWhen a gamemode is started with a map, the map resources are automatically started by the map-manager and the information it contains can be read by the gamemode resource. When the map changes, the current map resource is stopped and the next map resource is started. For a more in-depth explanation and examples of how map resources are utilized in the main script, please visit the Writing Gamemodes page.\n\nEvents are the way MTA tells scripts about things that happen. For example, when a player dies, the onPlayerWasted event is triggered. In order to perform any actions when a player dies, you have to prepare yourself similar to adding a command handler, as shown in the first chapter.\n\nThis example will output a message with the name of the player who died:\n\nInstead of showing what arguments are needed, the documentation page for Events shows what parameters are passed to the handler function, similar to the way a command handler does, just that it is different from event to event. Another important point is the source variable, that exists in handler functions. It doesn't have to be added to the parameter list of the function, but it still exists. It has a different value from event to event, for player events (as in the example above) it is the player element. As another example, you can take a look at the basic spawning player script in the first section to get an idea of how source is used.\n\nWhere to go from here\n\nYou should now be familiar with the most basic aspects of MTA scripting and also a bit with the documentation. The Main Page provides you with links to more information, Tutorials, and References that allow a deeper look into the topics you desire to learn about."
    },
    {
        "link": "https://github.com/multitheftauto/mtasa-blue",
        "document": "Multi Theft Auto (MTA) is a software project that adds network play functionality to Rockstar North's Grand Theft Auto game series, in which this functionality is not originally found. It is a unique modification that incorporates an extendable network play element into a proprietary commercial single-player PC game.\n\nNote If you're a fork developer, please read this note carefully. We have changed the default build type back to CUSTOM in . If you're developing without the anti-cheat in mind, say in the Debug configuration, this doesn't affect you at all. Now, if you plan to test your custom client with anti-cheat enabled, you should change your build type to . If you want to publish a release of your custom client, you must switch to a fork support hardened release of . Please read our Forks_Full_AC wiki page for more information.\n\nMulti Theft Auto is based on code injection and hooking techniques whereby the game is manipulated without altering any original files supplied with the game. The software functions as a game engine that installs itself as an extension of the original game, adding core functionality such as networking and GUI rendering while exposing the original game's engine functionality through a scripting language.\n\nOriginally founded back in early 2003 as an experimental piece of C/C++ software, Multi Theft Auto has since grown into an advanced multiplayer platform for gamers and third-party developers. Our software provides a minimal sandbox style gameplay that can be extended through the Lua scripting language in many ways, allowing servers to run custom created game modes with custom content for up to hundreds of online players.\n\nFormerly a closed-source project, we have migrated to open-source to encourage other developers to contribute as well as showing insight into our project's source code and design for educational reasons.\n\nMulti Theft Auto is built upon the \"Blue\" concept that implements a game engine framework. Since the class design of our game framework is based upon Grand Theft Auto's design, we are able to insert our code into the original game. The game is then heavily extended by providing new game functionality (including tweaks and crash fixes) as well as a completely new graphical interface, networking and scripting component.\n\nBy default, Multi Theft Auto provides the minimal sandbox style gameplay of Grand Theft Auto. The gameplay can be heavily extended through the use of the Lua scripting language that has been embedded in the client and server software. Both the server hosting the game, as well as the client playing the game are capable of running and synchronizing Lua scripts. These scripts are layered on top of Multi Theft Auto's game framework that consists of many classes and functions so that the game can be adjusted in virtually any possible way.\n\nAll gameplay content such as Lua scripts, images, sounds, custom models or textures is grouped into a \"resource\". This resource is nothing more than an archive (containing the content) and a metadata file describing the content and any extra information (such as dependencies on other resources).\n\nUsing a framework based on resources has a number of advantages. It allows content to be easily transferred to clients and servers. Another advantage is that we can provide a way to import and export scripting functionality in a resource. For example, different resources can import (often basic) functionality from one or more common resources. These will then be automatically downloaded and started. Another feature worth mentioning is that server administrators can control the access to specific resources by assigning a number of different user rights to them.\n\nOur project's code repository can be found on the multitheftauto/mtasa-blue Git repository at GitHub. We are always looking for new developers, so if you're interested, here are some useful links:\n\nVisit the wiki article \"Compiling MTASA\" for additional information and error troubleshooting.\n\nYou can build the MTA:SA server on GNU/Linux distributions only for x86, x86_64, armhf and arm64 CPU architectures. ARM architectures are currently in experimental phase, which means they're unstable, untested and may crash randomly. Beware that we only officially support building from x86_64 and that includes cross-compiling for x86, arm and arm64.\n\nPlease always read the Dockerfiles for up-to-date build dependencies. Note: ncftp is not required for building the MTA:SA server.\n\nNote: This script always deletes and directories and does a clean build.\n\nIf build architecture is not provided, then it's taken from the environment variable (defaults to: x64).\n\nIf build configuration is not provided, then it's taken from the environment variable (defaults to: release).\n\nIf you are trying to cross-compile to another architecture, then set , , , environment variables accordingly (see Dockerfile.arm64 for an example).\n\nIf you don't want to build the release configuration for the x86_64 architecture, you can instead pick another build configuration from: .\n\nIf you have problems resolving the required dependencies or want maximum compatibility, you can use our dockerized build environment that ships all needed dependencies. We also use this environment to build the official binaries.\n\nThese examples assume that your current directory is the mtasa-blue checkout directory. You should also know that is the code directory required by our Docker images inside the container. If the current directory is not a valid git repository, it instead create a (shallow) clone of the mtasa-blue repository. After compiling, you will find the resulting binaries in . To build the unoptimised debug build, add to the docker run arguments.\n\nUnless otherwise specified, all source code hosted on this repository is licensed under the GPLv3 license. See the LICENSE file for more details.\n\nGrand Theft Auto and all related trademarks are © Rockstar North 1997–2024."
    },
    {
        "link": "https://github.com/multitheftauto/mtasa-blue/blob/master/README.md",
        "document": "Multi Theft Auto (MTA) is a software project that adds network play functionality to Rockstar North's Grand Theft Auto game series, in which this functionality is not originally found. It is a unique modification that incorporates an extendable network play element into a proprietary commercial single-player PC game.\n\nNote If you're a fork developer, please read this note carefully. We have changed the default build type back to CUSTOM in . If you're developing without the anti-cheat in mind, say in the Debug configuration, this doesn't affect you at all. Now, if you plan to test your custom client with anti-cheat enabled, you should change your build type to . If you want to publish a release of your custom client, you must switch to a fork support hardened release of . Please read our Forks_Full_AC wiki page for more information.\n\nMulti Theft Auto is based on code injection and hooking techniques whereby the game is manipulated without altering any original files supplied with the game. The software functions as a game engine that installs itself as an extension of the original game, adding core functionality such as networking and GUI rendering while exposing the original game's engine functionality through a scripting language.\n\nOriginally founded back in early 2003 as an experimental piece of C/C++ software, Multi Theft Auto has since grown into an advanced multiplayer platform for gamers and third-party developers. Our software provides a minimal sandbox style gameplay that can be extended through the Lua scripting language in many ways, allowing servers to run custom created game modes with custom content for up to hundreds of online players.\n\nFormerly a closed-source project, we have migrated to open-source to encourage other developers to contribute as well as showing insight into our project's source code and design for educational reasons.\n\nMulti Theft Auto is built upon the \"Blue\" concept that implements a game engine framework. Since the class design of our game framework is based upon Grand Theft Auto's design, we are able to insert our code into the original game. The game is then heavily extended by providing new game functionality (including tweaks and crash fixes) as well as a completely new graphical interface, networking and scripting component.\n\nBy default, Multi Theft Auto provides the minimal sandbox style gameplay of Grand Theft Auto. The gameplay can be heavily extended through the use of the Lua scripting language that has been embedded in the client and server software. Both the server hosting the game, as well as the client playing the game are capable of running and synchronizing Lua scripts. These scripts are layered on top of Multi Theft Auto's game framework that consists of many classes and functions so that the game can be adjusted in virtually any possible way.\n\nAll gameplay content such as Lua scripts, images, sounds, custom models or textures is grouped into a \"resource\". This resource is nothing more than an archive (containing the content) and a metadata file describing the content and any extra information (such as dependencies on other resources).\n\nUsing a framework based on resources has a number of advantages. It allows content to be easily transferred to clients and servers. Another advantage is that we can provide a way to import and export scripting functionality in a resource. For example, different resources can import (often basic) functionality from one or more common resources. These will then be automatically downloaded and started. Another feature worth mentioning is that server administrators can control the access to specific resources by assigning a number of different user rights to them.\n\nOur project's code repository can be found on the multitheftauto/mtasa-blue Git repository at GitHub. We are always looking for new developers, so if you're interested, here are some useful links:\n\nVisit the wiki article \"Compiling MTASA\" for additional information and error troubleshooting.\n\nYou can build the MTA:SA server on GNU/Linux distributions only for x86, x86_64, armhf and arm64 CPU architectures. ARM architectures are currently in experimental phase, which means they're unstable, untested and may crash randomly. Beware that we only officially support building from x86_64 and that includes cross-compiling for x86, arm and arm64.\n\nPlease always read the Dockerfiles for up-to-date build dependencies. Note: ncftp is not required for building the MTA:SA server.\n\nNote: This script always deletes and directories and does a clean build.\n\nIf build architecture is not provided, then it's taken from the environment variable (defaults to: x64).\n\nIf build configuration is not provided, then it's taken from the environment variable (defaults to: release).\n\nIf you are trying to cross-compile to another architecture, then set , , , environment variables accordingly (see Dockerfile.arm64 for an example).\n\nIf you don't want to build the release configuration for the x86_64 architecture, you can instead pick another build configuration from: .\n\nIf you have problems resolving the required dependencies or want maximum compatibility, you can use our dockerized build environment that ships all needed dependencies. We also use this environment to build the official binaries.\n\nThese examples assume that your current directory is the mtasa-blue checkout directory. You should also know that is the code directory required by our Docker images inside the container. If the current directory is not a valid git repository, it instead create a (shallow) clone of the mtasa-blue repository. After compiling, you will find the resulting binaries in . To build the unoptimised debug build, add to the docker run arguments.\n\nUnless otherwise specified, all source code hosted on this repository is licensed under the GPLv3 license. See the LICENSE file for more details.\n\nGrand Theft Auto and all related trademarks are © Rockstar North 1997–2024."
    },
    {
        "link": "https://en.wikipedia.org/wiki/Multi_Theft_Auto",
        "document": "Multi Theft Auto (MTA) is a multiplayer modification for the Microsoft Windows version of Rockstar North games Grand Theft Auto III, Grand Theft Auto: Vice City and Grand Theft Auto: San Andreas that adds online multiplayer functionality. For Grand Theft Auto: San Andreas, the mod also serves as a derivative engine to Rockstar's interpretation of RenderWare.\n\nThe release of Grand Theft Auto III, a critically acclaimed sandbox-style action-adventure computer and video game developed by DMA Design (now Rockstar North) represented the first 3D title in the Grand Theft Auto (GTA) series. Despite its success, it was the first Grand Theft Auto game to ship without the network multiplayer gameplay features that were present in earlier titles, which allowed players to connect through a computer network and play the game with others.[3]\n\nThe first version of Multi Theft Auto, dubbed Grand Theft Auto III: Alternative Multiplayer, attempted to fill in this gap by extending an already existing cheating tool with functionality that allowed the game to be played with a very crude form of two-player racing over a computer network purely as a proof of concept,[3] similar to how the now-defunct XBAND service worked by manipulating game memory in order to add online multiplayer functionality. Newer versions of Multi Theft Auto with increasingly better gameplay and other improvements were released based on the same concept of game manipulation, by a small team of developers.\n\nWith the introduction of successor Grand Theft Auto: Vice City, it became clear that this computer game title also lacked any form of network gameplay. The Multi Theft Auto software was subsequently extended to include support for this title, and eventually shifted its entire focus towards this title and the concept of a new software framework dubbed Blue.[4] As the original concept (of game manipulation by memory) was prone to various problems with performance and stability that often resulted in application crashes, this new framework was created as a successor and laid the foundation of all future Multi Theft Auto software.[5]\n\nThe latest Multi Theft Auto version is based on code injection and hooking techniques whereby the game is manipulated without altering any original files supplied with the game.[6] The software functions as a game engine that installs itself as an extension of the original game, adding core functionality such as networking and GUI rendering while exposing the original game's engine functionality through a scripting language.\n\nThe Multi Theft Auto: San Andreas project was revised and relaunched as an open-source project, leaving all prior versions behind. The source code was licensed under the GPLv3 license and made available on GitHub.\n\nMulti Theft Auto's latest release is for the game Grand Theft Auto: San Andreas and is built upon a now open source game engine that has been in development for several years and is the only project that is still actively maintained. The engine provides users with all the necessary tools they need to create their own game modes and maps by exposing a large part of the original game functionality through a Lua scripting machine.\n\nThe initial version of the software was dubbed \"Race\" and unveiled on Sunday 22 January 2006, when the first playable content was released. This version featured a networked vehicle racing game mode and a map editor that allowed users to create custom environments and races. The advanced nature of the engine's early incarnation allowed the developers to develop a sophisticated integrated WYSIWYG editor for adding gameplay elements such as checkpoints, spawn points, power-ups and various objects ranging from ramps to exploding barrels.[7]\n\nThe successor release, dubbed \"Deathmatch\", was designed to improve upon \"Race\" by providing minimal sandbox style gameplay that could be extended by users and developers. The production on this release started shortly after the initial release, but stagnated due to what is seen as a lack of focus by the development team. As many new features were being introduced, the continuous introduction of these features delayed a stable and final version of the modification.[8] Instead, several on-line facilities were introduced during the development phase to allow visitors to track the development process of the software as changes were made to the code repository, illustrating any notable updates to the progress of the modification.\n\nThe first \"Deathmatch\" successor was introduced as a fully playable version on 2 January 2008 and tagged as \"Developer Preview\" to promote the third-party development of custom gameplay content and utilities.[9] This version was followed by a second \"Developer Preview\" that introduced several new features and fixes and was subsequently followed by a period of major code restructuring that led to the open-source relaunch on Friday, 21 November 2008 under the GPLv3 License.\n\nOn Saturday, 22 August, Multi Theft Auto: San Andreas v1.0 was officially distributed as the first open source release.[5] This release abandoned the now obsolete \"Deathmatch\" tag in the product name to emphasize on the versatility of the software. Gameplay functionality is solely provided by the scripting language, so users can choose or develop their own combination of scripts and other contents to customize and host their own type of game.\n\nThe initial \"Deathmatch\" version and its underlying engine presented a series of relevant changes to the functionality of the modification as well as the introduction of an online community content delivery system. Through the use of this website, registered users (such as players, server administrators or developers) can accumulate in-game statistics whilst playing on servers or share custom created content with other users.\n\nThird party content is made possible through the addition of the Lua scripting language in both the server hosting the game (e.g. providing functionality for a specific game mode), as well as the client playing the game (e.g. providing a graphical front end or user-specific local content to the game mode). Different scripts can then be run in parallel on either of these, communicating to each other through the use of events.\n\nThe custom created content is grouped into \"resources\" that are hosted server-side. This is a package-based system that packs all script files, custom content (e.g. images, 3D models, textures and collision files) and metadata files inside a single archive or directory. Specific content can then be marked to be uploaded to every connected player, to enable client-side execution of Lua code. This system allows for package dependency and inheritance of functions between different packages, easy management and distribution.[10]\n• Multi Theft Auto uses a modular platform to separate several facilities such as the GUI, network, game and scripting code and loads these into the game instead of injecting code into its memory process. This improves stability, speed and allows a better file management.\n• Uses the freeware CEGUI system, replacing the original Grand Theft Auto GUI, allowing Multi Theft Auto to draw its own widgets for any in-game user interaction such as the server-browser and allows scripting from any third-party resource.\n• A versatile set of scripting functions. By building upon Grand Theft Auto's own class-based design, implementing this into the client and server and synchronizing between these two, a third-party developer can control almost any aspect of every player's game by means of the Lua scripting language: native elements such as animations, explosions, particles, skins, weapons, vehicles, objects and players, as well as new elements such as custom 3D models are controllable.\n\nDeathmatch, roleplay and race gameplay options are available. Some gameplay elements include checkpoints, spawn points, power-ups, weapons and various objects ranging from ramps to exploding barrels. Many online servers contain custom game modes which use the scripting engine supplied with Multi Theft Auto. As example a few game modes in MTA:SA like Freeroam, where players can roam free in San Andreas all across the map, or competitive game-modes like Race, Destruction/Demolition Derby, Team Deathmatch, and Fallout, where players spawn their characters in the air, on a platform of glass plates, which will suddenly fall down after indicating it, where the players have to jump from a falling piece to an intact one, and the last surviving player wins. The principle of Fallout is similar to Hay, where players have to climb and be on top of a haystack first. The last modes also indicates how many game modes and scripts are possible to create on the MTA scripting engine, with endless possibilities and variation.\n\nThere are many genres of specific game servers and communities, like real-life role-playing, classic RPGs, and gaming communities that serve a wide variation of different gamemodes, sometimes all together in one server. Today the average amount of game servers the San Andreas version of Multi Theft Auto (MTA:SA) contains, is 3000 to 4000 servers, with over 600,000 players monthly, spread over the servers. The most popular game servers have a constant average of 200 to 1000 online players in-game.[11]\n\nThe Multi Theft Auto project has also been the subject in multiple articles in different media.[12][13][14][15][16][17] The most prominent being a coverage on G4 TV,[18] an exclusive release for Fileplanet with coverage on its frontpage,[19] and features in published magazines such as PC Gamer[20] and Total PC Gaming.[21]"
    },
    {
        "link": "https://wiki.multitheftauto.com/wiki/OnClientMarkerHit",
        "document": "This event is triggered when a player enters a marker created using createMarker.\n• hitPlayer: the player that hit the marker.\n• matchingDimension: true if the player is in the same dimension as the hit marker.\n\nThe source of this event is the marker that got hit by the player.\n\nThis code will output a message to the chatbox whenever any player walks into any marker."
    },
    {
        "link": "https://wiki.multitheftauto.com/wiki/Client_Scripting_Functions",
        "document": "Contributors: Did you create a page but it's not on this list? Confused? Read: Adding Pages to Categories and Templates Did you create a page but it's not on this list? Confused?\n\nThis page lists all the client-side scripting functions that have been implemented and are available as native functions from the Deathmatch mod. To request a function, create an issue in our GitHub repository.\n\nFor more functions, check the useful functions page."
    },
    {
        "link": "https://github.com/MrPoper/Useful-World-Lua/blob/master/FUNCTION.lua",
        "document": ""
    }
]