[
    {
        "link": "https://w3schools.com/python/ref_func_range.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://docs.python.org/2/library/functions.html",
        "document": "The Python interpreter has a number of functions built into it that are always available. They are listed here in alphabetical order.\n\nIn addition, there are other four built-in functions that are no longer considered essential: , , , and . They are documented in the Non-essential Built-in Functions section."
    },
    {
        "link": "https://docs.python.org/3/library/functions.html",
        "document": "The Python interpreter has a number of functions and types built into it that are always available. They are listed here in alphabetical order.\n\nOpen file and return a corresponding file object. If the file cannot be opened, an is raised. See Reading and Writing Files for more examples of how to use this function. file is a path-like object giving the pathname (absolute or relative to the current working directory) of the file to be opened or an integer file descriptor of the file to be wrapped. (If a file descriptor is given, it is closed when the returned I/O object is closed unless closefd is set to .) mode is an optional string that specifies the mode in which the file is opened. It defaults to which means open for reading in text mode. Other common values are for writing (truncating the file if it already exists), for exclusive creation, and for appending (which on some Unix systems, means that all writes append to the end of the file regardless of the current seek position). In text mode, if encoding is not specified the encoding used is platform-dependent: is called to get the current locale encoding. (For reading and writing raw bytes use binary mode and leave encoding unspecified.) The available modes are: open for writing, truncating the file first open for exclusive creation, failing if the file already exists open for writing, appending to the end of file if it exists The default mode is (open for reading text, a synonym of ). Modes and open and truncate the file. Modes and open the file with no truncation. As mentioned in the Overview, Python distinguishes between binary and text I/O. Files opened in binary mode (including in the mode argument) return contents as objects without any decoding. In text mode (the default, or when is included in the mode argument), the contents of the file are returned as , the bytes having been first decoded using a platform-dependent encoding or using the specified encoding if given. Python doesn’t depend on the underlying operating system’s notion of text files; all the processing is done by Python itself, and is therefore platform-independent. buffering is an optional integer used to set the buffering policy. Pass 0 to switch buffering off (only allowed in binary mode), 1 to select line buffering (only usable when writing in text mode), and an integer > 1 to indicate the size in bytes of a fixed-size chunk buffer. Note that specifying a buffer size this way applies for binary buffered I/O, but (i.e., files opened with ) would have another buffering. To disable buffering in , consider using the flag for . When no buffering argument is given, the default buffering policy works as follows:\n• None Binary files are buffered in fixed-size chunks; the size of the buffer is chosen using a heuristic trying to determine the underlying device’s “block size” and falling back on . On many systems, the buffer will typically be 4096 or 8192 bytes long.\n• None “Interactive” text files (files for which returns ) use line buffering. Other text files use the policy described above for binary files. encoding is the name of the encoding used to decode or encode the file. This should only be used in text mode. The default encoding is platform dependent (whatever returns), but any text encoding supported by Python can be used. See the module for the list of supported encodings. errors is an optional string that specifies how encoding and decoding errors are to be handled—this cannot be used in binary mode. A variety of standard error handlers are available (listed under Error Handlers), though any error handling name that has been registered with is also valid. The standard names include:\n• None to raise a exception if there is an encoding error. The default value of has the same effect.\n• None ignores errors. Note that ignoring encoding errors can lead to data loss.\n• None causes a replacement marker (such as ) to be inserted where there is malformed data.\n• None will represent any incorrect bytes as low surrogate code units ranging from U+DC80 to U+DCFF. These surrogate code units will then be turned back into the same bytes when the error handler is used when writing data. This is useful for processing files in an unknown encoding.\n• None is only supported when writing to a file. Characters not supported by the encoding are replaced with the appropriate XML character reference .\n• None (also only supported when writing) replaces unsupported characters with escape sequences. newline determines how to parse newline characters from the stream. It can be , , , , and . It works as follows:\n• None When reading input from the stream, if newline is , universal newlines mode is enabled. Lines in the input can end in , , or , and these are translated into before being returned to the caller. If it is , universal newlines mode is enabled, but line endings are returned to the caller untranslated. If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated.\n• None When writing output to the stream, if newline is , any characters written are translated to the system default line separator, . If newline is or , no translation takes place. If newline is any of the other legal values, any characters written are translated to the given string. If closefd is and a file descriptor rather than a filename was given, the underlying file descriptor will be kept open when the file is closed. If a filename is given closefd must be (the default); otherwise, an error will be raised. A custom opener can be used by passing a callable as opener. The underlying file descriptor for the file object is then obtained by calling opener with (file, flags). opener must return an open file descriptor (passing as opener results in functionality similar to passing ). The following example uses the dir_fd parameter of the function to open a file relative to a given directory: 'This will be written to somedir/spamspam.txt' The type of file object returned by the function depends on the mode. When is used to open a file in a text mode ( , , , , etc.), it returns a subclass of (specifically ). When used to open a file in a binary mode with buffering, the returned class is a subclass of . The exact class varies: in read binary mode, it returns an ; in write binary and append binary modes, it returns an , and in read/write mode, it returns an . When buffering is disabled, the raw stream, a subclass of , , is returned. See also the file handling modules, such as , (where is declared), , , , and . The and arguments may have been modified or inferred from the original call.\n• None used to be raised, it is now an alias of .\n• None is now raised if the file opened in exclusive creation mode ( ) already exists.\n• None The file is now non-inheritable.\n• None If the system call is interrupted and the signal handler does not raise an exception, the function now retries the system call instead of raising an exception (see PEP 475 for the rationale).\n• None On Windows, opening a console buffer may return a subclass of other than . Changed in version 3.11: The mode has been removed.\n\nReturn a proxy object that delegates method calls to a parent or sibling class of type. This is useful for accessing inherited methods that have been overridden in a class. The object_or_type determines the method resolution order to be searched. The search starts from the class right after the type. For example, if of object_or_type is and the value of type is , then searches . The attribute of the class corresponding to object_or_type lists the method resolution search order used by both and . The attribute is dynamic and can change whenever the inheritance hierarchy is updated. If the second argument is omitted, the super object returned is unbound. If the second argument is an object, must be true. If the second argument is a type, must be true (this is useful for classmethods). When called directly within an ordinary method of a class, both arguments may be omitted (“zero-argument ”). In this case, type will be the enclosing class, and obj will be the first argument of the immediately enclosing function (typically ). (This means that zero-argument will not work as expected within nested functions, including generator expressions, which implicitly create nested functions.) There are two typical use cases for super. In a class hierarchy with single inheritance, super can be used to refer to parent classes without naming them explicitly, thus making the code more maintainable. This use closely parallels the use of super in other programming languages. The second use case is to support cooperative multiple inheritance in a dynamic execution environment. This use case is unique to Python and is not found in statically compiled languages or languages that only support single inheritance. This makes it possible to implement “diamond diagrams” where multiple base classes implement the same method. Good design dictates that such implementations have the same calling signature in every case (because the order of calls is determined at runtime, because that order adapts to changes in the class hierarchy, and because that order can include sibling classes that are unknown prior to runtime). For both use cases, a typical superclass call looks like this: # This does the same thing as: In addition to method lookups, also works for attribute lookups. One possible use case for this is calling descriptors in a parent or sibling class. Note that is implemented as part of the binding process for explicit dotted attribute lookups such as . It does so by implementing its own method for searching classes in a predictable order that supports cooperative multiple inheritance. Accordingly, is undefined for implicit lookups using statements or operators such as . Also note that, aside from the zero argument form, is not limited to use inside methods. The two argument form specifies the arguments exactly and makes the appropriate references. The zero argument form only works inside a class definition, as the compiler fills in the necessary details to correctly retrieve the class being defined, as well as accessing the current instance for ordinary methods. For practical suggestions on how to design cooperative classes using , see guide to using super()."
    },
    {
        "link": "https://geeksforgeeks.org/python-range-function",
        "document": "The Python range() function returns a sequence of numbers, in a given range. The most common use of it is to iterate sequences on a sequence of numbers using Python loops.\n\nIn the given example, we are printing the number from 0 to 4.\n\nWhat is the use of the range function in Python\n\nIn simple terms, range() allows the user to generate a series of numbers within a given range. Depending on how many arguments the user is passing to the function, the user can decide where that series of numbers will begin and end, as well as how big the difference will be between one number and the next. Python range() function takes can be initialized in 3 ways.\n\nWhen the user call range() with one argument, the user will get a series of numbers that starts at 0 and includes every whole number up to, but not including, the number that the user has provided as the stop.\n\nIn this example, we are printing the number from 0 to 5. We are using the range function in which we are passing the stopping of the loop.\n\nWhen the user call range() with two arguments, the user gets to decide not only where the series of numbers stops but also where it starts, so the user doesn’t have to start at 0 all the time. Users can use range() to generate a series of numbers from X to Y using range(X, Y).\n\nIn this example, we are printing the number from 5 to 19. We are using the range function in which we are passing the starting and stopping points of the loop.\n\nWhen the user call range() with three arguments, the user can choose not only where the series of numbers will start and stop, but also how big the difference will be between one number and the next. If the user doesn’t provide a step, then range() will automatically behave as if the step is 1. In this example, we are printing even numbers between 0 and 10, so we choose our starting point from 0(start = 0) and stop the series at 10(stop = 10). For printing an even number the difference between one number and the next must be 2 (step = 2) after providing a step we get the following output (0, 2, 4, 8).\n\nIn this example, we are printing the number from 0 to 9 with the jump of 2. We are using the range function in which we are passing the starting and stopping points with the jump of the iterator.\n\nIf a user wants to increment, then the user needs steps to be a positive number.\n\nIf a user wants to decrement, then the user needs steps to be a negative number.\n\nPython range() function doesn’t support float numbers. i.e. user cannot use floating-point or non-integer numbers in any of its arguments. Users can use only integer numbers.\n\nConcatenation of two range() functions using itertools chain() method\n\nThe result from two range() functions can be concatenated by using the chain() method of itertools module. The chain() method is used to print all the values in iterable targets one after another mentioned in its arguments.\n\nAccessing range() with an Index Value\n\nA sequence of numbers is returned by the range() function as its object that can be accessed by its index value. Both positive and negative indexing is supported by its object.\n\nIn this example, we are creating a list and we are printing list elements with the range() in Python.\n\nSome Important points to remember about the Python range() function\n• None The range() function only works with integers, i.e. whole numbers.\n• None All arguments must be integers. Users can not pass a string or float number or any other type in a start stop, step\n• None All three arguments can be positive or negative.\n• step value must not be zero. If a step is zero, python raises a ValueError exception.\n• None Users can access items in a range() by index, just as users do with a list.\n\nWhat Does the\n\nHow to Create a Sequence of Numbers with\n\nWhat Are the Parameters of the\n\nHow to Use a Negative Step in the\n\nHow to Generate a List Using"
    },
    {
        "link": "https://docs.python.org/3/tutorial/controlflow.html",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/convert-string-to-integer-in-python",
        "document": "In Python, converting a string to an integer is important for performing mathematical operations, processing user input and efficiently handling data. This article will explore different ways to perform this conversion, including error handling and other method to validate input string during conversion.\n\nThe simplest way to convert a string to an integer in Python is by using the int() function. This function attempts to parse the entire string as a base-10 integer.\n\nExplanation: The int() function takes the string s and converts it into an integer.\n• None If the string contains non-numeric characters or is empty, int() ValueError\n• int() leading trailing whitespaces int() function trims whitespaces and converts the core numeric part to an integer.\n\nThe int() function also supports other number bases, such as binary (base-2) or hexadecimal (base-16). To specify the base during conversion, we have to provide the base in the second argument of int().\n\nUsing try and except\n\nIf the input string contains non-numeric characters, int() will raise a ValueError. To handle this gracefully, we use a try-except block.\n• s ValueError is raised and we print an error message instead.\n\nUse str.isdigit() to check if a string is entirely numeric before converting. This method make sure that the input only contains digits.\n\nExplanation: s.isdigit() returns True if s contains only digits, this allow us safe conversion to an integer.\n\nWhat happens if the string contains non-numeric characters?\n\nCan int() handle strings with leading or trailing spaces?\n\nHow can I convert a string representing a number in a different base (like binary or hexadecimal)?\n\nIs there a way to check if a string can be converted to an integer before using int()?\n\nCan I convert a floating-point string to an integer?"
    },
    {
        "link": "https://stackoverflow.com/questions/8075877/converting-string-to-int-using-try-except-in-python",
        "document": "Firstly, / are not functions, but statements.\n\nTo convert a string (or any other type that can be converted) to an integer in Python, simply call the built-in function. will a if it fails and you should catch this specifically:"
    },
    {
        "link": "https://datacamp.com/tutorial/how-to-convert-a-string-into-an-integer-in-python",
        "document": "Master the basics of data analysis with Python in just four hours. This online course will introduce the Python interface and explore popular packages."
    },
    {
        "link": "https://realpython.com/convert-python-string-to-int",
        "document": "Integers are whole numbers. In other words, they have no fractional component. Two data types you can use to store an integer in Python are and . These types offer flexibility for working with integers in different circumstances. In this tutorial, you’ll learn how you can convert a Python string to an . You’ll also learn how to convert an to a string.\n\nBy the end of this tutorial, you’ll understand:\n• How to store integers using and\n• How to convert a Python string to an\n• How to convert a Python to a string\n\nAn integer can be stored using different types. Two possible Python data types for representing an integer are: For example, you can represent an integer using a string literal: Here, Python understands you to mean that you want to store the integer as a string. You can do the same with the integer data type: It’s important to consider what you specifically mean by and in the examples above. As a human who has used the decimal number system for your whole life, it may be obvious that you mean the number one hundred and ten. However, there are several other number systems, such as binary and hexadecimal, which use different bases to represent an integer. For example, you can represent the number one hundred and ten in binary and hexadecimal as 1101110 and 6e respectively. You can also represent your integers with other number systems in Python using the and data types: Notice that and use prefixes to identify the number system. All integer prefixes are in the form , in which you replace with a character that refers to the number system: Technical Detail: The prefix is not required in either an integer or string representation when it can be inferred. assumes the literal integer to be decimal: The string representation of an integer is more flexible because a string holds arbitrary text data: Each of these strings represent the same integer. Now that you have some foundational knowledge about how to represent integers using and , you’ll learn how to convert a Python string to an .\n\nIf you have a decimal integer represented as a string and you want to convert the Python string to an , then you just pass the string to , which returns a decimal integer: By default, assumes that the string argument represents a decimal integer. If, however, you pass a hexadecimal string to , then you’ll see a : The error message says that the string is not a valid decimal integer. It’s important to recognize the difference between two types of failed results of passing a string to :\n• Syntax Error: A will occur when doesn’t know how to parse the string using the provided base (10 by default).\n• Logical Error: does know how to parse the string, but not the way you expected. Here’s an example of a logical error: # Using the default base of 10, instead of 2 In this example, you meant for the result to be 210, which is the decimal representation of the binary string. Unfortunately, because you didn’t specify that behavior, assumed that the string was a decimal integer. One good safeguard for this behavior is to always define your string representations using explicit bases: Here, you get a because doesn’t know how to parse the binary string as a decimal integer. When you pass a string to , you can specify the number system that you’re using to represent the integer. The way to specify the number system is to use : Now, understands you are passing a hexadecimal string and expecting a decimal integer. Technical Detail: The argument that you pass to is not limited to 2, 8, 10, and 16: Great! Now that you’re comfortable with the ins and outs of converting a Python string to an , you’ll learn how to do the inverse operation.\n\nIn Python, you can convert a Python to a string using : By default, behaves like in that it results in a decimal representation: In this example, is smart enough to interpret the binary literal and convert it to a decimal string. If you want a string to represent an integer in another number system, then you use a formatted string, such as an f-string (in Python 3.6+), and an option that specifies the base: is a flexible way to represent an integer in a variety of different number systems.\n\nCongratulations! You’ve learned so much about integers and how to represent and convert them between Python string and data types. In this tutorial, you learned:\n• How to use and to store integers\n• How to specify an explicit number system for an integer representation\n• How to convert a Python string to an\n• How to convert a Python to a string Now that you know so much about and , you can learn more about representing numerical types using , , , and !"
    },
    {
        "link": "https://freecodecamp.org/news/python-convert-string-to-int-how-to-cast-a-string-in-python",
        "document": "When you're programming, you'll often need to switch between data types.\n\nThe ability to convert one data type to another gives you great flexibility when working with information.\n\nThere are different built-in ways to convert, or cast, types in the Python programming language.\n\nIn this article, you'll learn how to convert a string to an integer.\n\nData types are used for specifying, representing, and categorizing the different kinds of data that exist and are used in computer programs.\n\nAlso, different operations are available with different types of data – one operation available in one data type is often not available in another.\n\nOne example of a data type is strings.\n\nStrings are sequences of characters that are used for conveying textual information.\n\nThey are enclosed in single or double quotation marks, like so:\n\nInts, or integers, are whole numbers.\n\nThey are used to represent numerical data, and you can do any mathematical operation (such as addition, subtraction, multiplication, and division) when working with integers.\n\nIntegers are not enclosed in single or double quotation marks.\n\nSometimes when you're storing data, or when you receive input from a user in one type, you'll need to manipulate and perform different kinds of operations on that data.\n\nSince each data type can be manipulated in different ways, this often means that you'll need to convert it.\n\nConverting one data type to another is also called type casting or type conversion. Many languages offer built-in cast operators to do just that – to explicitly convert one type to another.\n\nHow to convert a string to an integer in Python\n\nTo convert, or cast, a string to an integer in Python, you use the built-in function.\n\nThe function takes in as a parameter the initial string you want to convert, and returns the integer equivalent of the value you passed.\n\nThe general syntax looks something like this: .\n\nLet's take the following example, where there is the string version of a number:\n\nTo convert the string version of the number to the integer equivalent, you use the function, like so:\n\nA practical example of converting a string to an int\n\nSay you want to calculate the age of a user. You do this by receiving input from them. That input will always be in string format.\n\nSo, even if they type in a number, that number will be of .\n\nIf you want to then perform mathematical operations on that input, such as subtracting that input from another number, you will get an error because you can't carry out mathematical operations on strings.\n\nCheck out the example below to see this in action:\n\nThe error mentions that subtraction can't be performed between an int and a string.\n\nYou can check the data type of the input by using the method:\n\nThe way around this and to avoid errors is to convert the user input to an integer and store it inside a new variable:\n\nAnd there you have it - you now know how to convert strings to integers in Python!\n\nIf you want to learn more about the Python programming language, freeCodeCamp has a Python Certification to get you started.\n\nYou'll start with the fundamentals and progress to more advance topics like data structures and relational databases. In the end, you'll build five projects to practice what you learned.\n\nThanks for reading and happy coding!"
    }
]