[
    {
        "link": "https://docs.unity3d.com/Manual/class-Quaternion.html",
        "document": "Unity uses the QuaternionUnity’s standard way of representing rotations as data. When writing code that deals with rotations, you should usually use the Quaternion class and its methods. More info\n\nSee in Glossary class to store the three dimensional orientation of GameObjectsThe fundamental object in Unity scenes, which can represent characters, props, scenery, cameras, waypoints, and more. A GameObject’s functionality is defined by the Components attached to it. More info\n\nSee in Glossary, as well as using them to describe a relative rotation from one orientation to another.\n\nThis page provides an overview of the Quaternion class and its common uses when scripting with it. For an exhaustive reference of every member of the Quaternion class, see the Quaternion script reference.\n\nIt’s important to understand the difference between Euler angles (the X, Y, & Z values that you see in the inspector for the rotation of a GameObject), and the underlying Quaternion value which Unity uses to store the actual rotation of GameObjects. For the basics of this topic, read Rotation and Orientation in Unity.\n\nWhen dealing with handling rotations in your scriptsA piece of code that allows you to create your own Components, trigger game events, modify Component properties over time and respond to user input in any way you like. More info\n\nSee in Glossary, you should use the Quaternion class and its functions to create and modify rotational values. There are some situations where it is valid to use Euler angles, but you should bear in mind: - You should use the Quaternion Class functions that deal with Euler angles - Retrieving, modifying, and re-applying Euler values from a rotation can cause unintentional side-effects (see below)\n\nUnity’s Quaternion class has a number of functions which allow you to create and manipulate rotations without needing to use Euler angles at all, and these are the ones you should use in most typical cases. Each of these links to the Script Reference with code samples:\n\nThe Transform class also provides methods which allow you to work with the Quaternion rotations:\n\nIn some cases it’s more desirable to use Euler angles in your scripts. When doing so, it’s important to note that you must keep your angles in variables, and only use them to apply them as Euler angles to your rotation, which should still ultimately be stored as a Quaternion. While it’s possible to retrieve Euler angles from a quaternion, if you retrieve, modify and re-apply, problems are likely to arise.\n\nYou can read more detail about exactly how these problems can arise in the eulerAngles script reference page.\n\nHere are some examples of mistakes commonly made using a hypothetical example of trying to rotate a GameObject around the X axis at 10 degrees per second. This is what you should avoid:\n\nAnd here is an example of using Euler angles in script correctly:"
    },
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/Manual/class-Quaternion.html",
        "document": "Unity uses the QuaternionUnity’s standard way of representing rotations as data. When writing code that deals with rotations, you should usually use the Quaternion class and its methods. More info\n\nSee in Glossary class to store the three dimensional orientation of GameObjectsThe fundamental object in Unity scenes, which can represent characters, props, scenery, cameras, waypoints, and more. A GameObject’s functionality is defined by the Components attached to it. More info\n\nSee in Glossary, as well as using them to describe a relative rotation from one orientation to another.\n\nThis page provides an overview of the Quaternion class and its common uses when scripting with it. For an exhaustive reference of every member of the Quaternion class, see the Quaternion script reference.\n\nIt’s important to understand the difference between Euler angles (the X, Y, & Z values that you see in the inspector for the rotation of a GameObject), and the underlying Quaternion value which Unity uses to store the actual rotation of GameObjects. For the basics of this topic, read Rotation and Orientation in Unity.\n\nWhen dealing with handling rotations in your scriptsA piece of code that allows you to create your own Components, trigger game events, modify Component properties over time and respond to user input in any way you like. More info\n\nSee in Glossary, you should use the Quaternion class and its functions to create and modify rotational values. There are some situations where it is valid to use Euler angles, but you should bear in mind: - You should use the Quaternion Class functions that deal with Euler angles - Retrieving, modifying, and re-applying Euler values from a rotation can cause unintentional side-effects (see below)\n\nUnity’s Quaternion class has a number of functions which allow you to create and manipulate rotations without needing to use Euler angles at all, and these are the ones you should use in most typical cases. Each of these links to the Script Reference with code samples:\n\nThe Transform class also provides methods which allow you to work with the Quaternion rotations:\n\nIn some cases it’s more desirable to use Euler angles in your scripts. When doing so, it’s important to note that you must keep your angles in variables, and only use them to apply them as Euler angles to your rotation, which should still ultimately be stored as a Quaternion. While it’s possible to retrieve Euler angles from a quaternion, if you retrieve, modify and re-apply, problems are likely to arise.\n\nYou can read more detail about exactly how these problems can arise in the eulerAngles script reference page.\n\nHere are some examples of mistakes commonly made using a hypothetical example of trying to rotate a GameObject around the X axis at 10 degrees per second. This is what you should avoid:\n\nAnd here is an example of using Euler angles in script correctly:"
    },
    {
        "link": "https://docs.unity.cn/ru/2019.4/Manual/QuaternionAndEulerRotationsInUnity.html",
        "document": ""
    },
    {
        "link": "https://discussions.unity.com/t/quaternion-operator-docs-misleading-for-edge-cases/807509",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/Unity3D/comments/1c5hpql/how_do_i_use_quaternions_in_c",
        "document": "I know the gist of how they work but if i am trying to prevent an object from rotating beyond a point what *would* my w be? how does W actually practically effect the rotation of the object? here is my code. thanks in advanced!!\n\ni am new to C# and unity so some help would be much appreciated."
    },
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Transform.html",
        "document": "Suggest a change Thank you for helping us improve the quality of Unity Documentation. Although we cannot accept all submissions, we do read each suggested change from our users and will make updates where applicable. Close For some reason your suggested change could not be submitted. Please <a>try again</a> in a few minutes. And thank you for taking the time to help us improve the quality of Unity Documentation. Close Switch to Manual\n\nEvery object in a Scene has a Transform. It's used to store and manipulate the position, rotation and scale of the object. Every Transform can have a parent, which allows you to apply position, rotation and scale hierarchically. This is the hierarchy seen in the Hierarchy pane. They also support enumerators so you can loop through children using:"
    },
    {
        "link": "https://docs.unity3d.com/Manual/class-Transform.html",
        "document": "The Transform stores a GameObjectThe fundamental object in Unity scenes, which can represent characters, props, scenery, cameras, waypoints, and more. A GameObject’s functionality is defined by the Components attached to it. More info\n\nSee in Glossary’s Position, Rotation, Scale and parenting state. A GameObject always has a Transform component attached: you can’t remove a Transform or create a GameObject without a Transform component.\n\nThe Transform component determines the Position, Rotation, and Scale of each GameObject in the sceneA Scene contains the environments and menus of your game. Think of each unique Scene file as a unique level. In each Scene, you place your environments, obstacles, and decorations, essentially designing and building your game in pieces. More info\n\nSee in Glossary. Every GameObject has a Transform.\n\nTip: You can change the colors of the Transform axes (and other UI elements) (Menu: Unity > Preferences and then select the Colors & keys panel).\n\nUnity measures the Position, Rotation and Scale values of a Transform relative to the Transform’s parent. If the Transform has no parent, Unity measures the properties in world space.\n\nIn 2D space, you can manipulate Transforms on the x-axis or the y-axis only. In 3D space, you can manipulate Transforms on the x-axis, y-axis, and z-axis. In Unity, these axes are represented by the colors red, green, and blue respectively.\n\nThere are three primary ways you can edit a Transform’s properties:\n• In the Scene view \n\n An interactive view into the world you are creating. You use the Scene View to select and position scenery, characters, cameras, lights, and all other types of Game Object. More info .\n• In your C# scripts.\n\nIn the Scene view, you can use the Move, Rotate and Scale tools to modify Transforms. These tools are located in the upper left-hand corner of the Unity Editor.\n\nYou can use the Transform tools on any GameObject in a scene. When you select a GameObject, the tool GizmoA graphic overlay associated with a GameObject in a Scene, and displayed in the Scene View. Built-in scene tools such as the move tool are Gizmos, and you can create custom Gizmos using textures or scripting. Some Gizmos are only drawn when the GameObject is selected, while other Gizmos are drawn by the Editor regardless of which GameObjects are selected. More info\n\nSee in Glossary appears within it. The appearance of the Gizmo depends on which tool you select.\n\nWhen you click and drag on one of the three Gizmo axes, the axis’s color changes to yellow. While you drag the mouse, the GameObject moves, rotates, or scales along the selected axis. When you release the mouse button, the axis remains selected\n\nWhile moving the GameObject, you can lock movement to a particular plane (that is, change two of the axes and keep the third unchanged). To activate the lock for each plane, select the three small coloured squares around the center of the Move Gizmo. The colors correspond to the axis that locks when you select the square (for example, select the blue square to lock the z-axis).\n\nIn the InspectorA Unity window that displays information about the currently selected GameObject, asset or project settings, allowing you to inspect and edit the values. More info\n\nSee in Glossary window, you can use the Transform component to edit the Transform properties of a selected GameObject. There are two ways to edit the Transform property values in the component:\n• Enter values into the property value fields manually. This is useful for very specific adjustments.\n• Click a value field and drag up or down to increase or decrease the value. This is useful for less specific adjustments.\n\nUse the API to edit the Transform of a GameObject through script.\n\nIn Unity, you can group GameObjects into parent-child hierarchies:\n• A parent GameObject has other GameObjects connected to it that take on its Transform properties.\n• A child GameObject is connected to another GameObject, and takes on that GameObject’s Transform properties.\n\nIn the Hierarchy window, child GameObjects appear directly underneath parent GameObjects and are indented in the list. You can select the fold-out icon to hide or reveal a parent GameObject’s child GameObjects.\n\nA child GameObject moves, rotates, and scales exactly as its parent does. Child GameObjects can also have child GameObjects of their own. A GameObject can have multiple child GameObjects, but only one parent GameObject.\n\nThese multiple levels of parent-child relationships between GameObjects form a Transform hierarchy. The GameObject at the top of a hierarchy (that is, the only GameObject in the hierarchy that doesn’t have a parent) is known as the root GameObject.\n\nTo create a parent GameObject, drag any GameObject in the Hierarchy window onto another. This creates a parent-child relationship between the two GameObjects.\n\nYou can group GameObjects into parent-child hierarchies.\n\nThe Transform values for any child GameObject are displayed relative to the parent GameObject’s Transform values. These values are called local coordinates. For scene construction, it is usually sufficient to work with local coordinates for child GameObjects. In gameplay, it is often useful to find their global coordinates or their exact position in world space. The scripting API for the Transform component has separate properties for local and global Position, Rotation and Scale, and lets you convert between local and global coordinates.\n\nTip: When you parent Transforms, it is useful to set the parent’s location to <0,0,0> before you add the child Transform. This means that the local coordinates for the child Transform will be the same as the global coordinates, which makes it easier to ensure the child Transform is in the right position.\n\nThe Scale of the Transform determines the difference between the size of a meshThe main graphics primitive of Unity. Meshes make up a large part of your 3D worlds. Unity supports triangulated or Quadrangulated polygon meshes. Nurbs, Nurms, Subdiv surfaces must be converted to polygons. More info\n\nSee in Glossary in your modeling application and the size of that mesh in Unity. The mesh’s size in Unity (and therefore the Transform’s Scale) is important, especially during physics simulation. By default, the physics engineA system that simulates aspects of physical systems so that objects can accelerate correctly and be affected by collisions, gravity and other forces. More info\n\nSee in Glossary assumes that one unit in world space corresponds to one meter. If a GameObject is very large, it can appear to fall in “slow motion”; the simulation is correct because you are watching a very large GameObject fall a great distance.\n\nThree factors affect the Scale of your GameObject:\n• The size of your mesh in your 3D modeling application.\n• The Mesh Scale Factor setting in the GameObject’s Import Settings.\n• The Scale values of your Transform Component.\n\nDon’t adjust the Scale of your GameObject in the Transform component. If you create your models at real-life scale, you won’t have to change your Transform’s Scale. You can also adjust the scale at which your mesh is imported because some optimizations occur based on the import size. Do this in the Import settings for your individual mesh. Instantiating a GameObject that has an adjusted Scale value can decrease performance.\n\nNote: Changing the Scale affects the position of child Transforms. For example, scaling the parent Transform to (0,0,0) positions all child Transforms at (0,0,0) relative to the parent Transform.\n\nNon-uniform scaling is when the Scale in a Transform has different values for x, y, and z; for example (2, 4, 2). In contrast, uniform scaling has the same value for x, y, and z; for example (3, 3, 3). Non-uniform scaling can be useful in a few specific cases but it behaves differently to uniform scaling:\n• Some components don’t fully support non-uniform scaling. For example, some components have a circular or spherical element defined by a Radius property, such as Sphere Collider \n\n An invisible shape that is used to handle physical collisions for an object. A collider doesn’t need to be exactly the same shape as the object’s mesh - a rough approximation is often more efficient and indistinguishable in gameplay. More info , Capsule Collider \n\n A capsule-shaped collider component that handles collisions for GameObjects like barrels and character limbs. More info , Light and Audio Source \n\n A component which plays back an Audio Clip in the scene to an audio listener or through an audio mixer. More info . This means the circular shape remains circular under non-uniform scaling instead of elliptical.\n• If a child GameObject has a non-uniformly scaled parent GameObject and is rotated relative to that parent GameObject, it might appear skewed or “sheared”. There are components that support simple non-uniform scaling but that don’t work correctly when skewed like this. For example, a skewed Box Collider \n\n A cube-shaped collider component that handles collisions for GameObjects like dice and ice cubes. More info does not match the shape of the rendered mesh accurately.\n• A child GameObject of a non-uniformly scaled parent GameObject does not have its scale automatically updated when it rotates. As a result, the child GameObject’s shape might appear to change abruptly when you eventually update the scale, for example, if the child GameObject is detached from the parent GameObject."
    },
    {
        "link": "https://docs.unity.cn/560/Documentation/Manual/Transforms.html",
        "document": "The Transform is used to store a GameObject’s position, rotation, scale and parenting state and is thus very important. A GameObject will always have a Transform component attached - it is not possible to remove a Transform or to create a GameObject without one.\n\nTransforms are manipulated in 3D space in the X, Y, and Z axes or in 2D space in just X and Y. In Unity, these axes are represented by the colors red, green, and blue respectively.\n\nA Transform can be edited in the Scene View or by changing its properties in the Inspector. In the scene, you can modify Transforms using the Move, Rotate and Scale tools. These tools are located in the upper left-hand corner of the Unity Editor.\n\nThe tools can be used on any object in the scene. When you click on an object, you will see the tool gizmo appear within it. The appearance of the gizmo depends on which tool is selected.\n\nWhen you click and drag on one of the three gizmo axes, you will notice that its color changes to yellow. As you drag the mouse, you will see the object translate, rotate, or scale along the selected axis. When you release the mouse button, the axis remains selected. If you subsequently drag with the middle mouse button, the axis last selected will be used regardless of the mouse position.\n\nThere is also an additional option in Translate mode to lock movement to a particular plane (ie, allow dragging in two of the axes while keeping the third unchanged). The three small coloured squares around the center of the Translate gizmo activate the lock for each plane; the colors correspond to the axis that will be locked when the square is clicked (eg, blue locks the Z axis).\n\nParenting is one of the most important concepts to understand when using Unity. When a GameObject is a Parent of another GameObject, the Child GameObject will move, rotate, and scale exactly as its Parent does. You can think of parenting as being like the relationship between your arms and your body; whenever your body moves, your arms also move along with it. Child objects can also have children of their own and so on. So your hands could be regarded as “children” of your arms and then each hand has several fingers, etc. Any object can have multiple children, but only one parent. These multiple levels of parent-child relationships form a Transform hierarchy. The object at the very top of a hierarchy (ie, the only object in the hierarchy that doesn’t have a parent) is known as the root.\n\nYou can create a Parent by dragging any GameObject in the Hierarchy View onto another. This will create a Parent-Child relationship between the two GameObjects.\n\nNote that the Transform values in the Inspector for any child GameObject are displayed relative to the Parent’s Transform values. These values are referred to as local coordinates. Returning to the analogy of body and arms, the position of your body may move as you walk but your arms will still be attached at the same relative position. For scene construction, it is usually sufficient to work with local coordinates for child objects but in gameplay it is often useful to find their exact position in world space or global coordinates. The scripting API for the Transform component has separate properties for local and global position, rotation and scale and also allows you to convert any point between local and global coordinates.\n\nNon-uniform scaling is when the Scale in a Transform has different values for x, y, and z; for example (2, 4, 2). In contrast, uniform scaling has the same value for x, y, and z; for example (3, 3, 3). Non-uniform scaling can be useful in a few specific cases but it introduces a few oddities that don’t occur with uniform scaling:-\n• Certain components do not fully support non-uniform scaling. For example, some components have a circular or spherical element defined by a radius property, among them Sphere Collider, Capsule Collider, Light and Audio Source. In cases like this the circular shape will not become elliptical under non-uniform scaling as you would expect and will simply remain circular.\n• When a child object has a non-uniformly scaled parent and is rotated relative to that parent, it may appear skewed or “sheared”. There are components that support simple non-uniform scaling but don’t work correctly when skewed like this. For example, a skewed Box Collider will not match the shape of the rendered mesh accurately.\n• For performance reasons, a child object of a non-uniformly scaled parent will not have its scale automatically updated when it rotates. As a result, the child’s shape may appear to change abruptly when the scale eventually is updated, say if the child object is detached from the parent.\n\nThe scale of the Transform determines the difference between the size of a mesh in your modeling application and the size of that mesh in Unity. The mesh’s size in Unity (and therefore the Transform’s scale) is very important, especially during physics simulation. By default, the physics engine assumes that one unit in world space corresponds to one metre. If an object is very large, it can appear to fall in “slow motion”; the simulation is actually correct since effectively, you are watching a very large object falling a great distance.\n\nThere are three factors that can affect the scale of your object:\n• The size of your mesh in your 3D modeling application.\n• The Mesh Scale Factor setting in the object’s Import Settings.\n• The Scale values of your Transform Component.\n\nIdeally, you should not adjust the Scale of your object in the Transform Component. The best option is to create your models at real-life scale so you won’t have to change your Transform’s scale. The next best option is to adjust the scale at which your mesh is imported in the Import Settings for your individual mesh. Certain optimizations occur based on the import size, and instantiating an object that has an adjusted scale value can decrease performance. For more information, see the section about optimizing scale on the Rigidbody component reference page.\n• When parenting Transforms, it is useful to set the parent’s location to <0,0,0> before adding the child. This means that the local coordinates for the child will be the same as global coordinates making it easier to be sure you have the child in the right position.\n• Particle Systems are not affected by the Transform’s Scale. In order to scale a Particle System, you need to modify the properties in the System’s Particle Emitter, Animator and Renderer.\n• If you are using Rigidbodies for physics simulation then be sure to read about the Scale property on the Rigidbody component reference page.\n• You can change the colors of the Transform axes (and other UI elements) from the preferences (Menu: Unity > Preferences and then select the Colors & keys panel).\n• Changing the Scale affects the position of child transforms. For example scaling the parent to (0,0,0) will position all children at (0,0,0) relative to the parent."
    },
    {
        "link": "https://discussions.unity.com/t/how-to-read-transform-position-from-transform-without-high-performance-impact/803549",
        "document": ""
    },
    {
        "link": "https://discussions.unity.com/t/how-do-you-get-the-x-y-and-z-position-of-a-game-object/845139",
        "document": ""
    }
]