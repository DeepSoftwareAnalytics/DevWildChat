[
    {
        "link": "https://forums.unrealengine.com/t/how-to-serialize-additional-data-with-an-asset/611423",
        "document": "I’m attempting to serialize some additional data with an asset. I assumed I’d be able to override and read/write to the archive, but I hit an error at the end of when I do this. I’ve been searching around, but I can’t find any documentation on custom serialization. The few places I can find in the engine that override seem to do the same thing I’m doing. Can someone point me in the right direction?\n\nYour usage looks correct, but you must already have one of these objects serialized in a package. The editor tries to load the asset, but crashes because it was saved WITHOUT the additional data, and now you try to load it WITH the additional data. If you look into UE4 source code, you can see in various places they handle this with versioning, like :\n\nI’m making a brand new asset. There are no preexisting assets of this type. I’ve been deleting them and recreating them for each test, just to minimize variables. The error is actually because more data is deserialized than expected. By exactly the amount that I’m adding. Are there rules about adding serialized data if there are already serialized properties? It seems like the UObject::Serialize implementation is recording how much it serializes to an ExportMap and checking against that later. That doesn’t seem to include the size from any data I add, whether it’s before calling the super implementation or after.\n\nTurns out that overriding the FRecord overload is what causes the error. Here’s a complete example that will raise a fatal error after creating, saving, and reloading a new data asset. #pragma once #include \"Engine/DataAsset.h\" #include \"StubEntityDefinition.generated.h\" UCLASS() class UEntityDefinition : public UDataAsset { GENERATED_BODY() public: UPROPERTY(EditAnywhere) int Value; virtual void Serialize(FArchive& Ar) override { Super::Serialize(Ar); int32 Foo = 32; Ar << Foo; } // If this is enabled it causes a fatal error when appending additional data in the Serialize // overload above virtual void Serialize(FStructuredArchive::FRecord Record) override { Super::Serialize(Record); } };"
    },
    {
        "link": "https://dev.epicgames.com/documentation/en-us/unreal-engine/unreal-object-handling-in-unreal-engine",
        "document": "Marking classes, properties, and functions with the appropriate macros turns them into , , and . This gives Unreal Engine access to them, which allows for a number of under-the-hood handling features to be implemented.\n\nare automatically zeroed on initialization, before the constructor is called. This happens for the whole class, and native members alike. Members can subsequently be initialized with custom values in the class constructor.\n\nWhen an or is destroyed or otherwise removed from play, all references to it that are visible to the reflection system ( pointers and pointers stored in Unreal Engine container classes such as ) are automatically nulled. This is beneficial in that it prevents dangling pointers from persisting and causing trouble down the road, but it also means that and pointers can become null if some other piece of code destroys them. The ultimate advantage of this is that null-checking is more reliable, as it detects both standard-case null pointers and cases where a non-null pointer would have been pointing at deleted memory.\n\nIt is important to realize that this feature applies only to or references marked with or stored in an Unreal Engine container class. An Object reference stored in a raw pointer will be unknown to the Unreal Engine, and will not be automatically nulled, nor will it prevent garbage collection. Note this does not mean that all variables must be . If you want an Object pointer that is not a , consider using . This is a \"weak\" pointer, meaning it will not prevent garbage collection, but it can be queried for validity before being accessed and will be set to null if the Object it points to is destroyed.\n\nAnother case where a referenced UObject UProperty will be automatically null'ed is when using 'Force Delete' on an asset in the editor. As a result, all code operating on UObjects which are assets must handle these pointers becoming null.\n\nWhen a is serialized, all values are automatically written or read unless explicitly marked as \"transient\" or unchanged from the post-constructor default value. For example, you could place an instance in a level, set its Health to 500, save it and successfully reload it without writing a single line of code beyond the definition.\n\nWhen UProperties are added or removed, loading pre-existing content is handled seamlessly. New properties get default values copied from the new CDO. Removed properties are silently ignored.\n\nIf custom behavior is required, the function can be overridden. This can be useful to detect data errors, check version numbers, or perform automatic conversions or updates if the data format has changed.\n\nWhen the Class Default Object (or CDO) of a has changed, the engine will try to apply those changes to all instances of the class when they are loaded. For a given Object instance, if the updated variable's value matches the value in the old CDO, it will be updated to the value it holds in the new CDO. If the variable has any other value, the assumption is that the value was set intentionally, and those changes will be preserved.\n\nAs an example, let us say you saved a level with several of your Objects placed in it, and you had set the default Health value in the constructor to 100. Let us also assume you set the health for Enemy_3 to 500, because they are particularly tough. Now imagine you changed your mind and increased the default value of Health to 150. When you next load your level, Unreal will realize you have changed the CDO and will update all instances of with the old default Health value (100) to have a Health value of 150. Enemy_3's Health will remain at 500 because it wasn't using the old default value.\n\nand are understood by the Editor, and the Editor can expose these values automatically for editing without the need to write special code. This can optionally include integration into the Blueprint visual scripting system. There are many options to control the accessibility and exposure of variables and functions.\n\nBecause are part of the Unreal Engine's reflection system, they always know what they are, and type-related decisions and casts can be made at runtime.\n\nIn native code, every class has a custom typedef set to its parent class, which allows easy control of overriding behavior. As an example:\n\nAs you can see, calling will result in the MegaBoss saying \"Powering up! Time to fight!\".\n\nAlso, you can safely cast an Object from a base class to a more derived class using the templated Cast function, or query if an Object is of a particular class using . A quick example follows:\n\nHere we have used to attempt to cast the to an . If the Object in question is not actually an (or a child class thereof), the cast will return a null pointer and we can react appropriately. In the code above, the function will only be called against the MegaBoss.\n\nUnreal implements a garbage collection scheme whereby that are no longer referenced or have been explicitly flagged for destruction will be cleaned up at regular intervals. The engine builds a reference graph to determine which are still in use and which ones are orphaned. At the root of this graph is a set of designated as the \"root set\". Any can be added to the root set. When garbage collection occurs, the engine can track all referenced by searching the tree of known references, starting from the root set. Any unreferenced , meaning those which are not found in the tree search, will be assumed to be unneeded, and will be removed.\n\nOne practical implication here is that you typically need to maintain a reference to any Object you wish to keep alive, whether it's a simple Object pointer or an Unreal Engine container class that contains Object pointer types, such as . Actors and their Components are frequently an exception to this, since the Actors are usually referenced by an Object that links back to the root set, such as the Level to which they belong, and the Actor's Components are referenced by the Actor itself. Actors can be explicitly marked for destruction by calling their function, which is the standard way to remove an Actor from an in-progress game. Components can be destroyed explicitly with the function, but they are usually destroyed when their owning Actor is removed from the game.\n\nGarbage collection in Unreal Engine 4 is fast and efficient, and has a number of built-in features designed to minimize overhead, such as multithreaded reachability analysis to identify orphaned Objects, and unhashing code optimized to remove Actors from containers as quickly as possible. There are other features that can be adjusted to gain more precise control over how and when garbage collection is performed, most of which are found in Project Settings under Engine - Garbage Collection. The following settings are commonly used to tune garbage collector performance for a project:\n\nThe system includes a robust set of functionality to facilitate network communication and multiplayer games.\n\ncan be tagged to tell the Engine to replicate their data during network play. A common model here is that a variable gets changed on the server, and the Engine then detects this change and sends it reliably to all clients. Clients can optionally receive a callback function when the variable changes from replication.\n\ncan also be tagged to execute on a remote machine. A \"server\" function, for example, when called on a client machine, will cause the function to execute on the server machine for the server's version of the Actor. A \"client\" function, on the other hand, can be called from the server and will run on the owning client's version of that Actor."
    },
    {
        "link": "https://forums.unrealengine.com/t/how-do-you-serialize-and-deserialize-a-uobject-to-from-an-farchive-file/563740",
        "document": "Please consider the following code: On the line marked 1 it creates a file with the following content: but on the line marked 2 I get the error: LogSerialization: Error: Invalid boolean encountered while reading archive myarchive.bin - stream is most likely corrupted What am I doing wrong? Do FArchive files need to have some sort of preamble written to them?\n\nIt looks like the error is coming from PossiblySerializeObjectGuid. The call chain is as follows: So it’s trying to deserialize the bool bEnterWhenWriting, but gets a value of 10 (which is not 0 or 1) so it fails. I guess when the object was written it didn’t serialize bEnterWhenWriting for some reason?\n\nThanks @Sedal45, that’s certainly interesting and I’ll take a look at UGameplayStatics and USaveGame - but I’d really like to understand how to use the Core serialization library (ie Engine/Source/Runtime/Core/Public/Serialization) directly and how it works. I’ve found that if I wrap the FArchive in a FObjectAndNameAsStringProxyArchive then it works as expected and the UObject is serialized and deserializes correctly with this different format: As you can see each UPROPERTYs is seralized as name, type and value with run-length encoded strings. (I’m not sure what the “None” is on the end.) But looking at the code for FObjectAndNameAsStringProxyArchive I’m not sure I get why it works, whereas using FArchive (FFileReader / FFileWriter) directly doesn’t. It’s functions don’t seem to be called. I’ve walked through the working loading call (MyObject2->Serialize through FObjectAndNameAsStringProxyArchive ) in the debugger and I can’t quite figure out where the fields are actually read into the object.\n\nOk, so I’ve figured it out… Here is the story: UObject::Serialize calls operator<<(FArchive, FName) to serialize property names, and uses FName “None” as a “null-terminator” to indicate the end of the property list. That’s why in the correctly serialized file above “None” appears at the end of the property list to indicate it’s end. The property list is followed by an optional GUID which, when empty, is a 32-bit bool all zeros. That’s why there is 4 bytes of zeros after the None property in the corretly serialized version, to indicate no object GUID is present. The reason that it doesn’t work with FArchive is that the default implementation of operator<<(FArchive, FName) is a no-op: consequently, when Saving, FArchive is told the property names and goes “yep got it”, and then places nothing in the file for the property names. And now the fun part: Then later when Loading from FArchive, UObject::Serialize goes to load the first property and asks to deserialize the FName of the first property, passing in a default-constructed FName which is also the value of “None” (0). FArchive doesn’t touch the FName and returns (again, its a no-op - same operator<< function shown above). UObject::Serialize then takes this to mean it has read FName None from the archive indicating the end of the property list. Thinking it has successfully read the (seemingly empty) property list, UObject::Serialize then goes onto read the optional GUID bool (with the file position at the start of the file), and it gets something other than 0 or 1. (It gets 10 which is the value of the first four bytes of the file little-endian: 0x0A) and then croaks with “Invalid boolean encountered while reading archive” in the Guid reading code. The solution is the use FNameAsStringProxyArchive which is basically a tiny wrapper around FArchive that implements operator<<(FName) Rather than a no-op it writes it out a string: FArchive& FNameAsStringProxyArchive::operator<<( class FName& N ) { if (IsLoading()) { FString LoadedString; InnerArchive << LoadedString; N = FName(*LoadedString); } else { FString SavedString(N.ToString()); InnerArchive << SavedString; } return *this; } I consider it a bug that UObject::Serialize is interpretting the default no-op implementation of FArchive::operator<<(FName) returning None indicating the end-of-the-property list and continuing on. They should be distinct paths, and it should provoke a proper error message. How to assign FArchive and FMemoryReader to a file properly?"
    },
    {
        "link": "https://forums.unrealengine.com/t/serializing-uobjects/441753",
        "document": "Is there any nice way to serialize an uobject? I just want to store all the uproperties and eventually deserialize them into a new uobject.\n\n I don’t care about networking if that matters.\n\nI tried playing with FBitWriter but it doesn’t seem to work for me, all i get is an array of 0s or in the best case an array of 0 with a 0x1 at the beginning :s"
    },
    {
        "link": "https://dev.epicgames.com/documentation/en-us/unreal-engine/objects-in-unreal-engine",
        "document": "The UCLASS macro gives the a reference to a that describes its Unreal-based type. Each maintains one Object called the Class Default Object(CDO). The CDO is essentially a default 'template' Object, generated by the class constructor and unmodified thereafter.\n\nBoth the UCLASS and the CDO can be retrieved for a given Object instance, although they should generally be considered read-only. The UCLASS for an Object instance can be accessed at any time using the function.\n\nA contains a set of properties and functions that define the class. These are normal C++ functions and variables available to standard C++ code, but tagged with Unreal Engine-specific metadata that controls how they behave within the Object system. For more details about the tagging syntax, refer to the Programming Reference.\n\nUObjects can have member variables (known as properties) or functions of any type. However, for the Unreal Engine to recognize and manipulate those variables or functions, they must be marked with special macros and must conform to certain type standards. For details on those standards, refer to the Properties and UFunctions reference pages.\n\nUObjects do not support constructor arguments. All C++ UObjects are initialized on engine startup, and the engine calls their default constructor. If there is no default constructor, your UObject will not compile.\n\nUObject constructors should be lightweight and only used to set up default values and subobjects, no other functionality should be called at construction time. For Actors and Actor Components, initialization functionality should be put into the method instead.\n\nUObjects should only be constructed using NewObject at runtime, or CreateDefaultSubobject for constructors.\n\nIt is not required or even appropriate to use this system in all cases, but there are many benefits to doing so, including:\n\nTo harness the functionality provided by UObject-derived types, a preprocessing step needs to be run on the header files for these types to collate the information it needs. This preprocessing step is performed by the UnrealHeaderTool, or UHT for short. UObject-derived types have a certain structure that needs to be adhered to.\n\nWhile a UObject's implementation in a source (.cpp) file is just like any other C++ class, its definition in a header (.h) file must adhere to a certain basic structure in order to work properly with Unreal Engine. Using the editor's New C++ Class command is the easiest way to set up a correctly-formatted header file. A basic header file for a UObject-derived class might look like this, assuming the UObject derivative is called UMyObject and the project in which it was created is called MyProject:\n\nThe Unreal-specific parts of this are as follows:\n\nThis line is expected to be the the last directive in the file. If this header file needs to know about other classes, they can be forward declared anywhere in the file, or included above .\n\nThe macro makes visible to Unreal Engine. The macro supports a variety of Class Specifiers that determine which features are turned on or off for the class.\n\nSpecifying is necessary if MyProject wishes to expose the UMyObject class to other modules. This is most useful for modules or plugins that will be included by game projects and which deliberately expose classes to provide portable, self-contained functionality across multiple projects.\n\nThe macro takes no arguments, but sets up the class to support the infrastructure required by the engine. It is required for all and .\n\nTicking refers to how Objects are updated in Unreal Engine. All Actors have the ability to be ticked each frame, providing you a way to perform any update calculations or actions that are necessary.\n\nActors and ActorComponents have their Tick functions called automatically when registered to do so, however, do not possess any built-in update ability. When it is necessary for your project, this can be added by inheriting from the class using the inherits class specifier. They can then implement the function, which will be called each frame by the engine.\n\nObject destruction is handled automatically by the garbage collection system when an Object is no longer referenced. This means that no pointers, engine containers, , or class instances should have any strong references to them.\n\nWhen the garbage collector runs, unreferenced Objects found are removed from memory. In addition, the function can be called directly on an Object. This function sets all pointers to the Object to and removes the Object from global searches. The Object is fully deleted on the next garbage collection pass.\n• has been replaced with . This new function is now only for tracking stale objects, If then objects marked as will be automatically nulled and destroyed by Garbage Collector.\n• Strong references keep UObjects alive. If you don't want these references to keep the UObject alive, then those references should convert to using weak pointers, or be a normal pointer that is manually cleared by a programmer (if performance is critical.) You can replace Strong pointers with weak pointers and dereference them once during a gameplay operation as garbage collection only runs between frames.\n• is for checking if it's null or garbage, but most usages of IsValid can be replaced with proper programming conventions like clearing pointers to Actors when they have their event called.\n• If is disabled, will flag to the owner of the object that it wants the object destroyed, but the object itself will not get garbage collected until all references to it are released.\n• In the case of Actors, even if the Actor had called on them, and they were removed from the level, then it will not be Garbage Collected until all references to it are released.\n• The Main difference for licensees is that using the function to force expensive objects to garbage collect will no longer work.\n• Existing checks for nullptr should be replaced with calls if you're not clearing them manually, since pointers will no longer get automatically cleared by the garbage collector through ."
    },
    {
        "link": "https://forums.unrealengine.com/t/what-does-fmemorywriter-and-fmemoryreader-do/331189",
        "document": "FMemoryReader and FMemoryWriter can wrap a byte array (TArray<uint8>) to give it an FArchive compatible interface. We use it to serialize and de-serialize UObjects, UStructs and basic core types from/to byte buffers. The usage is very simple: given an existing byte array you create a memory reader or writer object, passing the array into their constructors: TArray<uint8> Buffer; int64 Value = 42; FMemoryReader Reader(Buffer); Reader << Value; // De-serialize an int64 from the buffer into a variable FMemoryWriter Writer(Buffer); Writer << Value; // Serialize an int64 variable into the buffer. Both the reader and the writer constructors have an optional flag to determine whether the buffer is intended to be persistent, i.e. written to disk, for example. If this flag is true, they will automatically make sure that the correct byte ordering is used on the corresponding platform. This allows you to de-/serialize the same multi-byte value on platforms with different Endianness.\n\nThank You So MUCH !\n\n but i still have one more problem :\n\n i’m using something like this for serialize my actors : everything work correctly but about 2 min after saving actor my editor stop working and crashes\n\nin this example its using an actor and Actor Record but in the my codes i’m using an array of Actors and an array of records like this: void AMyTestActor::SaveTheGame(TArray<FActorRecord>& Records, TArray<AActor*> Actors) { int32 leng = Actors.Num(); for (int32 i = 0; i < leng; i++) { Records.Emplace(); FMemoryWriter MemoryWriter(Records[i].ActorData, false); // use a wrapper archive that converts FNames and UObject*'s to strings that can be read back in FMySaveGameArchive Ar(MemoryWriter, false); // serialize the object Actors[i]->Serialize(Ar); } } this function implement in blueprint and also gets the array of Actors in blueprint\n\nI know this post is quite old but it appears to be a common garbage collection error.\n\n Your pointers aren’t all initialized in your struct it seems. Create an initialize method in FActorRecord and set If you never assign a value to a pointer, when garbage collection hits that value, things will EXPLODE. So, always initialize pointers in structs. I’ve spent many an hour when I started C++ trying to find what was causing crashes, and I sometimes still forget to assign a value to them. should do the trick also, if you don’t have a default value for the pointer variable."
    },
    {
        "link": "https://forums.unrealengine.com/t/what-is-the-best-way-to-handle-saving-loading-an-array-of-objects/281775",
        "document": "After over a year in maintenance mode, the official Unreal Engine Wiki is now permanently offline. These resources now live on a new community-run Unreal Engine Community Wiki — ue4community.wiki! You will be able to find content from the official..."
    },
    {
        "link": "https://tomlooman.com/unreal-engine-cpp-save-system",
        "document": "For your game, you’ll eventually need to write some kind of save system. To store player information, unlocks, achievements, etc. In some cases, you will need to save the world state such as looted chests, unlocked doors, dropped player items, etc.\n\nIn this tutorial (UE4 & UE5 Compatible) we will go through the setup of your very own C++ SaveGame system. Different types of games will have their own save systems needs. Use this article and code as a starting point for whatever game you’re building. You’ll need to be fairly familiar with Unreal Engine C++ to build this system.\n\nWe’ll be creating a save system similar to Dark Souls with a bonfire interaction that saves the world state. We will be saving a few actors and some player information. The bonfire itself is a thematic interaction, with the real interesting bits being the actual world state that we save/load. Such as the moved item locations, previously opened treasure chests, and obtained credits (aka “Souls”).\n\nThis project was created for Stanford University Computer Science classes (CS193U) that I taught in late 2020. It is the reference project used in my Unreal Engine C++ online course!\n\nFirst, let’s briefly talk about the system design so you have a better understanding of intent once we get into the code.\n\nUnreal has a built-in SaveGame UObject that we inherit from and add variables to be written to disk. Another powerful feature is the Serialize() function available in every UObject/Actor to convert our variables to a binary array and back into variables again. To decide which variables to store, Unreal uses a ‘SaveGame’ UPROPERTY specifier. The resulting binary array per Actor can be added to the SaveGame object just before writing to disk.\n\nLoading the game will basically do the inverse operations. We load the SaveGame UObject from disk, all the variables get restored in this SaveGame object. We then pass all these variables back into the Objects/Actors they originated from such as Player position, Credits earned, and individual Actor’s state (matched by the Actor’s Name in our example) such as whether a treasure chest was looted in our previous session.\n\nTo identify which Actors we wish to save state for we use an Interface. We also use this interface to allow Actors to respond to a game load (OnActorLoaded) so he may run some actor-specific code to properly restore animation state etc. In the Action Roguelike project I re-used my GameplayInterface, but I would recommend you make a fresh interface specifically for marking objects/actors as savable (eg. SavableObjectInterface)\n\nIn order to save the world state, we must decide which variables to store for each Actor and what misc. info we need to be saved to disk such as earned Credits by each player. Credits aren’t really part of the world state and belong to the PlayerState class instead. Even though PlayerState exists in the world and is in fact an Actor, we handle them separately so we can properly restore it based on which Player it belonged to previously. One reason to handle this manually is so we can store a unique ID for each player to know who the stats belong to when a player re-joins the server at a later time.\n\nFor Actor variables we store its Name, Transform (Location, Rotation, Scale) and an array of byte data which will contain all variables marked with ‘SaveGame’ in their UPROPERTY.\n\nTo convert variables into a binary array we need an FMemoryWriter and FObjectAndNameAsStringProxyArchive which is derived from FArchive (Unreal’s data container for all sorts of serialized data including your game content).\n\nWe filter by Interface to avoid calling Serialize on potentially thousands of static Actors in the world we don’t wish to save. Storing the Actor’s name will be used later to identify which Actor to deserialize (load) the data for. You could come up with your own solution such as an FGuid (mostly useful for runtime spawned Actors that might not have a consistent Name)\n\nThe rest of the code is pretty straightforward (and explained in the comments) thanks to the built-in systems.\n\nNow it’s time to prepare our Actors to be serialized…\n\nBelow is the TreasureChest code taken directly from the project. Note the ISGameplayInterface inheritance and ‘SaveGame‘ marked on the bLidOpened variable. That will be the only variable saved to disk. By default, we store the FTransform of the Actor as well. So we can push the treasure chest around the map (Simulate Physics is enabled) and on the next Play, the Location and Rotation will be restored along with the lid state.\n\nFinally we have the OnActorLoaded_Implementation() function to implement. This can be useful to handle load-specific logic. In the example below we simply call the existing functions that update the state of the Lid to be opened/closed.\n\nKeep in mind however that often you can rely on BeginPlay() as your ‘OnActorLoaded’ replacement. So long as you load the saved data into each Actor BEFORE BeginPlay() has been triggered. This is why we handle the loading logic very early in the process inside our GameMode class (more on that in ‘Loading Game State’ below)\n\nThat takes care of the Actor states, all that’s left is to iterate PlayerState instances and let them store data as well. While PlayerState is derived from Actor and could in theory be saved during the iteration of all world actors, it’s useful to do it separately so we can match them to Player ID’s (eg. Steam user ID) instead of a constantly changing Actor name that we did not decide/control for this type of runtime spawned Actor.\n\nIn my example I chose to fetch all data from PlayerState just before saving the game. We do so by calling SavePlayerState(USSaveGame* SaveObject); This lets us pass in whatever data is relevant into the SaveGame object, such as the PlayerId and Transform of the Pawn (if the player is currently alive)\n\nMake sure you call these on all PlayerStates before saving to disk. It’s important to note that GetUniqueId is only relevant/consistent if you have an Online Subsystem loaded such as Steam or EOS.\n\nTo retrieve the Player Data we do the opposite and have to manually assign the player’s transform once the pawn has spawned and is ready to do so. You could override the player spawn logic in gamemode more seamlessly to use the saved transform instead. For the example, I stuck with a more simple approach of handling this during HandleStartingNewPlayer.\n\nUnlike loading Actor data which is handled on initial level load, for player states we want to load them in one-by-one as players join the server that might have previously played with us. We can do so during HandleStartingNewPlayer in the GameMode class.\n\nAs you can see it’s even split up into two pieces. The main data is loaded and assigned as soon as possible to make sure it’s ready for our UI (which is created during “BeginPlayingState” in our specific implementation inside of PlayerController) and wait for the Pawn to be spawned before we handle the location/rotation.\n\nThis is where you could probably implement it so that during the creation of the Pawn you use the loaded data instead of looking for a PlayerStart (as if the default Unreal behavior) I chose to keep things simple.\n\nThe function below looks for the Player id and uses fall-back while in PIE assuming we have no online subsystem loaded then. This function is used by Loading the player state above.\n\nIdeally, you can load your world state once while loading your persistent level. This way you can easily load in the level data and then deserialize any Actor Data from disk BEFORE BeginPlay() is called on anything. Your use-case might be more complex with streaming in/out additional levels on the fly that contain a savable world state. That’s a bit out of the scope for now, especially as my own games thankfully don’t require such functionality. I recommend checking out Steve’s library as he does handle such complex cases.\n\nTo restore our world state we do somewhat of the opposite as before. We load from disk, iterate all actors, and finally use an FMemoryReader to convert each Actor’s binary data back into “Unreal” Variables. Somewhat confusingly we still use Serialize() on the Actor, but because we pass in an FMemoryReader instead of an FMemoryWriter the function can be used to pass saved variables back into the Actors.\n\nTo load a specific Save file that might have been selected in a previous level (such as your main menu) you can easily pass data between levels using GameMode URLs. These URLs are the ‘Options’ parameter and you probably used them already for things like “?listen” when hosting a multiplayer session.\n\nNow while loading a level you should pass in ?savegame=MySaveFile in the options. “savegame” as an option is made up, you can type whatever as your option, just be sure to parse that same ‘option’ in C++.\n\nIn the code example prior I showed loading the data during InitGame() which happens pretty early during the loading phase. That means that we have our level data available and yet not called BeginPlay() yet on anything. That lets us deserialize variables and use BeginPlay() as a way to react as if those saved variables are their blueprint originals.\n\nThis could be useful to initialize with the relevant saved data or skipping entire blocks of code in BeginPlay by saving a specific bool such as bHasSpawnedLoot (make sure you mark this with SaveGame) to not accidentally re-run this logic if it has already done so in the previous session and should do so only once.\n\nIn the previous sections we set up the entire save/load system. Now to finish it off, I’ll break down how to make a simple bonfire-style interaction. I’m skipping all the steps specific to interacting with the Actor itself, you can view the source code for more details.\n\nNow to create the actual Bonfire in Blueprint it’s super simple and fast to do because we did most of the hard work already. Here are the basic steps required including the Blueprint Node below.\n• New Actor Blueprint with a mesh and particle system (the fire)\n• Disable ‘Auto Activate’ on the particle system, we’ll only turn it on after interacting with it once (and storing this as bool in the Actor for later loads)\n• Add the Interface (GameplayInterface in our case) to mark it for the save system.\n• Add a bool bFireActive and mark it as SaveGame (find it in the variable details, you will need to open up the Advanced options – see below for image)\n• Setup the graph like below – we interact with the fire (Event Interact) which updates bFireActive and then saves the game. We then update the particle state.\n\nOnce interacted with once, the bFireActive is now saved into the bonfire and on the next game load the particle system will activate through OnActorLoaded (our own interface function) You can do the same through BeginPlay() as we’ll have loaded our Actor data before that is called as mentioned earlier in this post.\n\nAs you can see there isn’t a lot of complexity involved in this basic SaveGame system. And even setting up savable variables in Blueprint is quite easy once the boilerplate has been implemented. There is a lot more to consider and required for your own complete system that covers all cases and will depend on your game mechanics. Perhaps you’ll need to save the state of the ActorComponents too, or UObjects that hold info about abilities and/or attributes. I’ll briefly discuss these in the next paragraph, but all are outside of the scope of this tutorial.\n\nOf course, this system is just a starting point for your own fully-featured save system. There are some things to consider when building your own system that I encountered so far including respawning Actors that were spawned during the previous session instead of loaded from a Map/level file.\n\nYou also should track which Actors got destroyed in the previous session. For this, you can make assumptions based on the SaveGame data. When there is no SavedActorData in your SaveGame but your Actor (loaded from level) does have a savable interface, you should be able to immediately call Destroy on it.\n\nYou might want to consider placing all this logic in a Game Subsystem which more neatly splits your save/loading logic out from the GameMode class.\n\nFor the demo project, we only assume a single persistent level and don’t save any LevelName with the Actor or have a specific Array of Actors per (Streaming)Level. That would likely be something you need depending on your game’s design.\n\nIt’s a great idea to include a version number in your save file as a sort of header. This way you can find out incompatible (old) SaveGames and even handle conversions from old to new save versions when possible (eg. when a data format has changed but can be converted with some code) Epic’s ActionRPG Example (May be deprecated as of UE5) has an implementation of this.\n\nThat’s all for the basics of your SaveGame system! This can be molded in all directions to fit your needs, and there is certainly a lot that can be added. I recommend checking out the additional resources below for more information on the subject.\n\nAlso, don’t forget to sign-up for my newsletter below for any new content I post! And follow me on Twitter!\n• My Unreal C++ Course handles Saving & Loading in more detail\n• Saving and Loading your game (Docs BP / C++)"
    },
    {
        "link": "https://stackoverflow.com/questions/78702792/is-there-an-unreal-c-function-to-parse-a-byte-array-to-an-fstring-with-specifi",
        "document": "I am working on an Unreal Engine 5 project where I need to parse binary files. These files contain text encoded in Shift-JIS, as opposed to UTF-8 encoding. My goal is to convert a byte array from this binary file into an FString, but specifically interpreted using Shift-JIS encoding.\n\nI've been searching around the web for a potential solution, but haven't seemed to find anything that addresses this specific issue. Ideally, I am looking for a function or method in Unreal C++ that can decode the byte array using Shift-JIS encoding, and convert it to an FString. Does Unreal have built-in support for this kind of conversion? Or if not, are there any third-party libraries or custom solutions I could use otherwise to achieve this functionality?\n\nIf it helps anything, I am very flexible on how the function could work, so long as I have a correct FString representation of the string in the end, too. I have no specific requirements other than achieving the conversion."
    },
    {
        "link": "https://wizardcell.com/unreal/multiplayer-tips-and-tricks",
        "document": "As you keep practicing online multiplayer in Unreal Engine, you might have already wondered what are the best practices to tackle a specific issue, or even ranted about your code not behaving the way you desired. In this post I try to consolidate all the tips and tricks I’ve gathered while revamping my humble networking experience.\n\nBy no means these are rules that you will be judged for if you choose not to comply with. However, they proved useful over the course of my experience with networking code in Unreal Engine.\n\n1. Get to Know the Game Framework Objects Online-wise\n\nRegardless of networking, understanding Unreal’s Gameplay Framework, will not only make your code well-structured, but also keep you from reinventing the wheel, which will save you precious time down the line.\n\nNow multiplayer-wise, game framework Objects, and more specifically Actors, can behave differently over the network. While one Actor will always be relevant to all clients, another will always be relevant only to its owning client, while another not relevant to clients at all. These don’t mean much for single-player fanatics, but it should mean a lot for their multiplayer counterparts. It’s not just relevancy, but other replication settings may vary. In fact, relevancy and most other replication settings don’t mean anything if the Actor in question isn’t set to replicate. The following table sheds some light on some of those most notable replication settings variances on a bunch of different types of replicable Actors:\n\nNow let’s understand what these settings mean:\n• : If true, this Actor is only relevant to its owning client. If this flag is changed during play, all non-owner channels (those belonging to simulated proxies) would need to be explicitly closed.\n• : Always relevant for all clients (overrides ).\n• : How often (per second) this Actor will be considered for replication, used to determine .\n• : Priority for this Actor when checking for replication in a low bandwidth or saturated situation, higher priority means it is more likely to replicate.\n\nI highly suggest you read further about the Detailed Actor Replication Flow.\n\nI keep seeing peeps using the following static functions in online multiplayer:\n\nAnd their corresponding native versions:\n\nThese functions will do you more harm than good, unless you know what you’re doing (which, in most cases, sadly ends up not being the case) or that you’re doing local multiplayer (split-screen) only, then you’re good to go.\n\nI won’t really dwell on the why any long, but for example calling or the corresponding native will end up returning different results based on the context, usually being:\n\nThe difference in behavior based on context is not a clear matter for beginners. In addition to that, there is almost no need to get that Actor by index, as indices won’t be consistent across different clients and servers. Also, the order for the PlayerController iterator is not consistent across map transfer so we don’t want to use that index. 99% of the time people pass in index 0 and want the primary local PlayerController, while sometimes in a listen-server environment for example, the client connects fast enough (through seamless travel) that it ends up as index 0 on the listen-server, so you end up with an undesired PlayerController, while expecting the listen-server’s PlayerController. Instead, using will safely retrieve you the desired primary local PlayerController. Sadly, it’s not exposed to Blueprint, but you can keep reading below for the exposed nodes.\n\nThat’s why I highly suggest you refrain from using these functions as there are always other ways to retrieve the Actor in question.\n\nDepending on the context (from which class you are trying to retrieve the Actor in question) the alt functions/properties will vary, but here are the most handy:\n\nAnd their corresponding native versions:\n\n3. Be Aware that Blueprint-only Multiplayer is Limited\n\nMost people that start doing Unreal Engine in general, will start coding in Blueprint. Without a shadow of doubt this also applies to those starting with multiplayer. While Blueprint-only multiplayer is fine, and can be sufficient to your simple needs at first, you will quickly come to realize that it’s limited. Let’s discover robust tools that Blueprint lacks:\n• Replication Graph: While it will most probably be replaced with Iris, it’s still worth to know that you won’t be able to utilize it in place of the old regular relevancy system if you’re a Blueprint-only project. It won’t reduce the number of replicated Actors, but will result in the server having to evaluate less Actors per data channel, so indeed it’s an improved relevancy mechanism that aims to optimize server cpu usage, as well as network bandwidth usage.\n• Custom Network Serialization for Types: Basically in C++ you are able to customize the way specific types are serialized over the network. Usually, to do so we simply wrap such types in a Struct, and implement internally. Effectively speaking, this also helps in achieving atomic replication.\n• Fast TArray Replication - FTR: It’s a sophisticated Unreal built-in container that are usually preferred over the regular TArray for replicating large TArrays of Structs. It aims to lower down the server cpu time needed to check elements for replication every time the array gets dirtied. You also get a very handy replication callbacks on clients per element that gets added, removed, or even changed.\n• Essential Virtual Methods: It’s a matter of time to realize how limiting this C++ only feature can be. Here are the most notable virtual functions that you want to override almost in any real world project:\n• : This lets you set your own criteria to whether an Actor is relevant for a specific network connection.\n• : Great place to do extra Pawn initialization that both server and client need to do.\n• : Replication callback to when our PlayerState has replicated. In Blueprint you will have to do very dirty workarounds and hacks.\n• Proper Replication Callbacks: Basically the way functions behave in Blueprint is somehow different than the way they do in C++, and that’s basically by design. In Blueprint they are usually called locally every time the variable is set, with no respect to where that was done (server vs. client) and that’s definitely not a replication callback. However, their C++ counterparts are real replication callbacks that will fire only on client and only when set on server. This article is the most inclusive source that explains most of their nuances. In addition, C++ has a function overload that has pre-replication value as an argument, which can be very handy: .\n• Fine Grain Control Over Replication Conditions: By default, both in C++ and Blueprint, a property set to the same old value on the server, won’t trigger the replication callback on clients (Blueprint will still trigger it on server, because as stated earlier above, it’s by design). However, if we wanted to change that behavior, and make it so that the replication callback always triggers on clients even if the newly set value was unchanged, we can do the following:\n• Struct Property Replication Exclusion: C++ Structs have the ability to exclude some of their members from replication, while their Blueprint counterparts don’t. Here’s how you do it:\n• Replicate Subobjects that are not ActorComponents: UObjects are preferred than Actors/ActorComponents to replicate, for the simple reason that they are more lighter-weight. In C++ there are at least two ways to make these kind of Objects support replication, however in Blueprints there are none.\n\nAnd the list goes on…\n\nYou should be aware that Unreal’s source code is available and should be in the palm of your hand. It should be your number one of reliable info about anything Unreal Engine related.\n\nIt’s meant to help you:\n• Better understand why and where things went wrong.\n• Ask better and smarter questions.\n\nFor functions that activate on both server and client, there are a couple of handy methods for filtering their execution:\n\nFor every Actor in the World, usually either the server or a client will have authority over that Actor.\n\nFor every Actor that exists on the server, the server has authority over that Actor - including all replicated Actors, and pre-placed (not specifically replicated) Actors. As a result, when function is run on a client, and the target is an Actor that was replicated to them, it will return . You can also use the convenience macro in Blueprint as a quick means to branch for different server and client behavior in replicated Actors:\n\nFor every Actor that exists only on client, only that client will have authority over that Actor - including mainly cosmetic (zero effect to gameplay) Actors.\n\nThis method makes use of Network Roles:\n\nThis method makes use of Network Modes:\n\nBy calling and , you can reliably decide what NetMode the Actor has, by chaining back to its owning World and the instance of the game that has it, which can have any of the previous network modes.\n\nWhile most of the times you could opt for either one to get the same results, this is how I use them:\n• NetMode: I use this method in the earlier life points of an Actor, so any point before is called, as the network roles have not been setup properly yet.\n• NetRole: I use this method at any point in time after (inclusive) is called. In theory, this method is faster than the previous, and thus should be preferred when possible.\n\nIn short, NetMode is more reliable, while NetRole is faster.\n\nFiltering execution based on whether it is relevant to the owning client is another useful method of execution filtering for functions/events that activate on both owning and non-owning clients.\n\nHere are the most remarkable scenarios where you want to utilize this type of filtering:\n\nThe filtering will vary based on the context, but here are the most handy methods you will want to use:\n\nNote: Not all of them are exposed to Blueprint, but the ones you will use most of the time are.\n\nWarning: Avoid using these functions during spawning, and most notably during , as it is possible for a Pawn not to have a Controller assigned during construction.\n\nA very common scenario in which you see this method of execution filtering being used, is if you want to add a 3D interaction widget upon overlapping with an Actor. You don’t want other players that have your simulated Pawn to see the interaction widget!\n\nNote: works, since Pawn is always the instigator of its own. See for reference.\n\n7. Refrain from Using Delay to Account for Replication Time\n\nYou should have already been in a situation where you are trying to retrieve a specific replicated property, usually being an Actor, and unluckily getting a null value. After some digging you figured that the property didn’t have enough time to replicate to be valid. The amount of time it takes for a property to replicate to clients in Unreal Engine can be affected by several factors, including RTT (also referred to as ping), the complexity of the Object being replicated, the number of replicated properties, and the replication settings being used. At which point, you falsely realize that you should delay your retrieval, which also seemingly stinks.\n\nThe most common real life example I’ve seen for this delay behavior, is before accessing PlayerState client-side, which is known to be a replicated property in a couple of game framework Actor classes. This is due to the fact that PlayerState has a low NetUpdateFrequency by default, which in simple words mean that potentially it will take the PlayerState Actor more time to replicate than its game framework counterparts. This situation leads a lot of novice developers to use the Delay node (or its native function, but it mostly comes from Blueprint-only developers), which is not a real clean fix, as you can never reliably predict how much time it’s going to take replication.\n\nThe real clean fix is to “listen” to when PlayerState replicates as a whole, or when one of its specific properties does, from various different places based on the various specific needs:\n• : This gets called automatically on client-only (server excluded) as any other OnRep function does, and each time a Pawn is assigned a new PlayerState, and that by default happens when the Pawn is possessed by a PlayerController that owns the PlayerState in question. Note that usually you can’t count on this call, especially when you want to listen to a specific property that can keep changing and thus replicating throughout the game. However, it can prove useful at the life start of the Pawn. Note that a Pawn can get destroyed and spawned multiple times on the various client instances due to relevancy for example, and in which this replication callback will be called. All properties set before the previous circumstances occurred, should have potentially replicated by the time this function is called (with the exception of unmapped properties, i.e. properties that are assigned NetworkGUIDs and those usually being UObjects* and FNames that are not hardcoded in ).\n• : This is usually less used than the previous, however it’s good to know that it’s similar in use, as it gets called at the life start of the PlayerController, or after a persistent PlayerController finishes seamless traveling.\n• client-side: This is usually used by Blueprint-only fanatics, as they have no access to the previous two methods which are C++ only. Filtering for client execution path means that we are looking for the replicated client version of the PlayerState.\n• Busy-wait polling: Checking if PlayerState is valid on , or rather using the node, and then checking validity is an easy yet dirty fix. This is traditionally useful while prototyping in Blueprint.\n• : This is the preferred mostly used method, as it helps you track when each and every property gets replicated, after it potentially changes.\n\nUsually peeps want for example UI to listen to when these replication callbacks take place, so UI can be updated accordingly. At that point, they should bind to a delegate where needed, and call it in either one of the functions above. In C++ they are called Delegates while in Blueprint they are called Event Dispatchers, with the Blueprint version being a specific of the various C++ candidates.\n\n8. Know when is it Safe to Call RPCs\n\nI often see peeps use RPCs (Remote Procedure Calls - also called replicated functions) and wondering why they are not called (more accurately processed/executed) in the desired FunctionCallspace. RPCs that are called on one instance of the game, could end up being:\n• Absorbed: Not executed at all.\n• Executed remotely: Executed on remote instance/s of the game.\n• Executed locally: Executed on the local instance of the game where it was called.\n\nRPCs that are not called safely, will end up either being absorbed, executed locally and becoming meaningless, or even lost.\n\nThis issue applies to Server RPCs called on/from an Actor that is not owned by a NetConnection (i.e. not owned by a player/client), such that they will not be processed and you would see the following very similar warning either in the window or inside one of the log files inside :\n\nThis happens in one of the two cases below, where in the former the Actor in question is not owned by client and is neither meant to be, while in the latter it’s meant to be so, but the timing of the RPC call happens before the Actor is owned properly by client.\n\nNote: The native function that returns an Actor’s NetConnection is , and is overridden in and .\n\nThe only Actor which has NetConnection by default is PlayerController. Any other Actors that are owned by the PlayerController, either directly or indirectly, will have NetConnection too, with those usually being: Pawn, PlayerState. As a result, it’s usually safe to fire Server/Client RPCs from the former three Actors (we’ll see that’s not always the case due to timing).\n\nWhile in theory one could own every Actor they want to Server/Client RPC from, that is a very bad approach, for a couple of reasons:\n• Different clients won’t be able to interact with the same Actor simultaneously, considering an Actor can have only one owner at a time.\n• You could end up in owning too many Actors, which results in too many unnecessary hard references.\n• It’s counter-intuitive to polymorphism which is perfect for this situation.\n\nA very common example to the situation above, is if the client wants to interact with an Actor. In such case here’s the basic procedure the client should go by:\n\n8.1.2 Bad Timing: Actor has no NetConnection yet\n\nWhile this issue seems similar to the previous in shape, it’s in fact different in essence. This one goes over Actors that are supposed to have NetConnection, such as: PlayerController/PlayerState/Pawn, where the RPC still gets dropped/absorbed. The reason is that the RPC call happens at a time where the Actor in question hasn’t been owned yet by a NetConnection.\n\nOften times I see the following unfortunate code in a custom Blueprint Character class:\n\nNote: The code above is for demonstration purposes only and you should almost never need to RPC on an event ( in our case) that fires on both server and client. Filtering client-server execution paths, would save us calling the meaningless, unnecessary RPC.\n\nWhile the Server RPC could potentially execute fine on the server, due to the fact that the owning PlayerController (which has NetConnection) is created before the Pawn, so usually it replicates first. However, that’s not always the case given that these two Actors could have different net stats, such as update frequency and priority, or even due to packet loss.\n\nNote: Don’t let functions like fool you into thinking that it means that the Actor is guaranteed capable of firing meaningful RPCs, because it is not. In the situation above, the PlayerController has net owner, but has no NetConnection. Therefore, this function indicates that the Actor is potentially capable of firing meaningful RPCs. However, the one that does guarantee you that is the previously mentioned , after it returns a non-null value.\n\nAnother common, yet unfortunate absorbed Client RPC that is seen in a custom Blueprint PlayerState class:\n\nNote: The code above is for demonstration purposes only and you should almost never need to RPC on an event ( in our case) that fires on both server and client. Filtering client-server execution paths, would save us calling the meaningless, unnecessary RPC.\n\nAlthough the PlayerState is owned by a PlayerController at this point, the latter still has no owning Player (another way of saying NetConnection as it is a subclass of Player), and that is because takes place before gets the chance to, in which it’s guaranteed a Player has been associated with a PlayerController, enabling it to call RPCs without them being absorbed.\n\nAnother important factor to decide if it’s safe to call any type of RPC at a specific point in time, is to logically decide if that point in time is safe or not.\n\nFor example, is the first place it is safe to call replicated functions on PlayerController.\n\nOften times I see the following bad code in a custom Blueprint Character class:\n\nNote: The code above is for demonstration purposes only and you should almost never need to RPC on an event ( in our case) that fires on both server and client. Filtering client-server execution paths, would save us calling the meaningless, unnecessary RPC.\n\nWith the following string printed to the , running a dedicated server that has one connected client:\n\nYou could tell it’s not what we expected, since it should have said “Client:” instead of “Server:”. Meaning, the Client RPC, which we call on the server and expect to execute on client, is executing locally on server. Reason for that, is at the time executes, there is no such guarantee that the Pawn/Character has an owning connection (not that it’s even owned yet, which you can verify by printing the value of function ), which by the table of RPC invoked from the server means that it runs on server, making it totally undesirable and meaningless.\n\nWe can alleviate the issue with this bad hotfix:\n\nWith the following desired string printed to the , running a dedicated server that has one connected client:\n\nHowever here’s the more proper fix:\n\nReason we use event, is that it executes on the server when we are guaranteed to have been possessed by a Controller, which automatically calls function for us, letting the Controller own the Pawn, so it chains back to a NetConnection and is able to fire Client RPCs.\n\nWith all that being said, it’s not a good practice to call unnecessary RPCs to force an execution path on the other end (owning-client execution path in our example), when there’s a native event that is already implemented for us that executes on that end. In our case there are and BIEs (Blueprint Implementable Events), or their native caller versions and which occur on possession, and are called on both server and owning client.\n\nLet’s look at the following common problematic scenario that could occur in a custom GameState class for example:\n\nNote: The code above is for demonstration purposes only and you should almost never need to RPC on an event ( in our case) that fires on both server and client. Filtering client-server execution paths, would save us calling the meaningless, unnecessary RPC.\n\nWith the following string printed to the running a dedicated server that has a connecting client:\n\nAs you might have expected, the client hasn’t been welcomed, as it was not there in the first place when the Multicast RPC took place. Notice that the RPC was lost even though it is was marked , and that’s because of the lossy nature of RPCs in general, as they simply don’t count for a pending NetConnection.\n\nThere are multiple options you can consider but I will route you to the native method that you could override and utilize:\n\nStarting in UE 5.1, a new more intuitive and flexible way of replicating subobjects was added. One of the methods that was added is the following:\n\nAs its name and the documentation suggest, this handy function is called when the ActorComponent is ready to start replicating properties, and call RPCs through its owner’s ActorChannel. It’s also stated that this function is called before is called, and also when the owning Actor is ready for replication, which gets us to the conclusion:\n\nThe conclusion isn’t quite true as of now, as it involves the new Iris replication system, which isn’t enabled (although compiled) by default, let alone that it’s still in experimental state.\n\nIn the past tip we’ve already come across a couple of unnecessary RPCs, but the term was never established. Unnecessary RPC is an RPC that is in fact not needed, and could have been saved. For example, server-only logic does not necessarily have to be contained in a Server RPC if you can guarantee that a non-replicated function will only execute on the server.\n\nUnnecessary RPCs in fact stem from the -sad yet true- fact of not being knowledgeable enough with the game framework multiplayer-wise.\n• Iterating upon a past example, here’s how a client could be notified locally of possession in Blueprint, without the need to use any needless RPCs:\n\nWe filter by mainly cause we care about the owning client, which by nature exists at the local Controller level.\n\nNote: For the listen-server player, the local controller exists on server, and for other client players, it exists on client.\n\nOne of the bad habits I keep seeing is the use of meaningless RPCs. With that I mean RPCs that don’t serve their true purpose, desirably executing on the other remote end, but instead they execute only locally, like in the following circumstances:\n• Client RPC invoked from the server on a server-owned/unowned Actor.\n\nIt gets tricky and kinda hard to debug when you do a meaningless RPC without you knowing about it. We’ve already seen such example, which can occur due to bad timing of the RPC call.\n\nI’m not very strict on this one, but overriding RPCs is grounds for being shot. In my humble opinion, keeping networking code abstracted from game-specific code helps with an essential daily coding habit: Debugging.\n\nThe simple other reason is consistency. You should keep in mind that you override in the child class, and not , and in case you want to call a parent class implementation, then you call , and not or you’ll get into an infinite loop:\n\nYou might have understood the chain of calls by yourself now, but the way RPCs work, internally calls as you could see in the chain of calls above. Anywhere you want to call the RPC, you always call the regular version without the for the RPC to be meaningful, otherwise the RPC gets called locally.\n\nLastly, you can’t override RPCs in Blueprint by adding or to the RPC macro, as UHT (Unreal Header Tool) will prohibit you, not to mention that you can’t add those tags to a virtual function.\n\n11.1 Override RPCs The Right Way\n\nHere’s how you should “override” RPCs in C++:\n\nAny replicated event, can either be Reliable or Unreliable. By default, RPCs are unreliable.\n\nReliable events are guaranteed to reach their destination (assuming ownership rules are followed) in the order they were sent and as long as they are in the same translation unit (being handled by the same ActorChannel), as they will be resent until they are acknowledged. However, they introduce more bandwidth, and potentially latency, to meet this guarantee. Try to avoid sending reliable events too often, like on tick for example, since the engine’s internal buffer of reliable events may overflow, and as a result the associated player will be disconnected!\n\nUse Reliable RPCs for events that should not be missed, with those usually being player input that doesn’t happen on tick, and gameplay critical events that are better be late than missed, that could potentially affect the state of the game.\n\nWarning: Never use a Reliable RPC on tick. Also, be cautious when binding Reliable RPCs to player input. Players can repeatedly press buttons very rapidly, and that will overflow the queue for Reliable RPCs. You should use some way of limiting how often players can activate these.\n\nUnreliable events work as their name implies - they may not reach their destination, or reach it with gaps in the RPC calls (even though they will still be processed in order), in case of packet loss on the network, or if the engine determines there is a lot of higher-priority traffic it needs to send, meaning they won’t be resent if they’re lost. As a result, unreliable events use less bandwidth than reliable events, and they can be called safely more often.\n\nUse Unreliable if the RPC is being called very often, such as on tick, or if you are calling a cosmetic event that isn’t critical to gameplay, such as spawning visual and sound effects.\n\nReplicated properties and RPCs, are two quite powerful tools, that almost every Unreal multiplayer game inevitably takes advantage of.\n\nThis is a super important rule, that diverges into three golden subrules of multiplayer, of which you should live by:\n• Use Multicast/Client RPCs for replicating transient (not stateful) or cosmetic in nature events.\n• Use Server RPCs to make the client communicate with the server (basically it’s the only way), and validate the passed data if needed.\n\nGood to note, that the golden rule above is not set in stone, and there are always exceptions:\n• Sometimes the use of RPCs would be quite good even for stateful replication, where for example the maximum bunch size (65535B=64KB) is exceeded, at which point chunking the data into reliable RPCs, while avoiding overflowing the reliable buffer size ( that defaults to 256, which is the maximum number of reliable unacked packets plus the current outgoing bunches at any given time) could prove to be a useful pattern, although this must be done with extreme caution, or otherwise clients will start getting disconnected! Here’s to an astounding article that goes more in depth on how this can be done.\n• Some other times, and by the same previous analogy, you can use property replication even for transient/lossy events. Here’s to a spectacular article that demonstrates that.\n\nOften times peeps compare replicated properties with RPCs based on performance, to consider which one to use. This comparison stems basically from the fact that they don’t really understand that they are different tools serving quite different purposes, making the comparison out of place for the most part.\n\nGenerally speaking, RPCs end up invoking a lot more virtual function calls and lookups than property replication, and these need to happen every time an RPC is invoked. Further, these calls will happen in the frame right where the RPC is called as opposed to batched at the end of the frame (like with property replication), so it’s more likely that you’ll have cache misses for one off RPCs.\n\nReplicated properties actually use more memory, since server and clients store shadow states about every property to know when changes occur.\n\nAll properties and RPCs incur a minimum 2-byte property header to identify which property/RPC it is. Properties embedded in Structs and Subobjects will have larger headers. This is usually not something significant enough to change the design of the code however, apart from in very extreme circumstances.\n\nFor a more in depth comparison, check this article.\n\nAt this point you should have already understood that your only way to pass data from client to server in Unreal, is via Server RPC.\n\nIt’s not uncommon to see peeps pass data indifferently from client to server, trusting the client without validating its data. Hence why we end up with the following scenarios in many games:\n\nAnd the list just grows…\n\nWhat you ought to be doing instead is to use a technique most games nowadays use, that follows the principle of “trust and verify”, in which we trust the client about the data it passes to the server (for responsiveness), and then we validate it on the server. Validation on the server can be done with the help of:\n• RPC validation function: Usually it does nothing but return true. The reason for this, is you don’t want to kick a player simply because there was a client-server disagreement, as such can happen frequently in any real world networked game scenario.\n\nHere to a funny vulnerability story Shooter Game has, that spread to many games.\n\nIt’s important to understand what is guaranteed and what isn’t when it comes to property and RPC replication and what steps should be taken to account for this in your game code. This tip builds upon Epic’s article.\n\nProperty replication is guaranteed to be reliable. This means that the property of the client version of the Actor will eventually reflect the value on the server, but the client will not necessarily receive notification of every individual change that happens to a property on the server. The is because the Actor does not necessarily replicate every frame and packets may be dropped, meaning that every update made on the server won’t necessarily be received by the client.\n\nIf you need frequent changes to be received by the client, you may want to increase the NetUpdateFrequency of the Actor to ensure it replicates each frame. However, even a high update frequency doesn’t guarantee that every change will be received, as packet loss can result in a change being dropped. How you handle this will depend on the specifics of your game, but in many cases, smoothing between received values can help mitigate issues with updates not being received.\n\nReliable RPCs sent are almost always guaranteed to be received and processed, as they will be resent until they are acknowledged. If they never reach their target clients, which rarely happens (massive packet loss for several seconds), then the affected clients are kicked. On the other hand, Unreliable RPCs won’t be resent if they’re lost, and neither will be the instigator for disconnecting the client.\n\nHowever, RPCs don’t count for clients that haven’t joined yet, meaning they won’t get resent to a client if the client wasn’t there when the RPC was initially sent. That’s why at the end of the day property replication is considered more reliable over a wider spectrum of scenarios, with the most famous being syncing game state data for late-joiners, also referred to as JIP (join in progress) clients.\n\nAs we mentioned before, each Actor has its own , which dictates how often it will be considered for replication.\n\nOnce an Actor is considered for replication on a frame, all trivial properties (anciently referred to as POD types) that should replicate will be sent at once, and the client should receive and apply these changes within a single frame. On the other hand, as you would expect, unmapped properties (un-hardcoded FNames and UObject*) are excluded from such guarantee. They are called unmapped because their NetworkGUID, which is a globally unique identifier for network related use, that gets serialized alongside the Object to be replicated, has not been mapped to it just yet, such that the Object has the value of null, but once the Object replicates (loads on client), and the NetworkGUID gets resolved into it, then they will become mapped properties. To be able to know when a NetworkGUID gets resolved into a replicated Object, we use replication callback functions known as OnReps:\n\nNote: The intention above is anything that derives from UObject, so the same applies for the common use of AActor*.\n\nPractically speaking, it takes less time to replicate a POD than to replicate an Object. When spawning a replicated Actor (not placed in map) on the server, all its replicated POD properties, as long as they are set in the same frame the Actor is spawned in (i.e. no longer than getting called), are guaranteed to have been replicated to the client by the time is called client-side for example. The reason for this, is that on client, of replicated Actors that are spawned from replication (not loaded from map) will always be called after is called:\n\nNote: If World hasn’t begun play on client by the time is called, then the replicated GameState is what dispatches . Placed in map Actors won’t have called for them, and will have dispatched from the replicated GameState as well.\n\nHowever, again Names that are not hardcoded in and pointers to other Objects (especially dynamic ones - spawned at runtime) are not guaranteed to be valid at such point, and should ideally rely upon replication callbacks to determine when they replicate.\n\nFor changes made to multiple properties across multiple frames, generally these changes should be received in the order that they were made. However, unideal network conditions can result in these changes being dropped and resent, so they may be received later. For example:\n\nThe server has three replicated booleans that are changed over three net updates respectively. The server’s states look like this for the three properties:\n\n0,0,0 → 1,0,0 (the first property’s change is sent) → 1,1,0 (the second property’s change is sent) → 1,1,1 (the third property’s change is sent).\n\nAfter the third change is sent, the server detects the second change was lost, so it is resent. The client receives the first change, but because the second change is dropped and resent, the third change is received before the second. The client’s states look will like this: 0,0,0 → 1,0,0 → 1,0,1 → 1,1,1.\n\nAgain, the guarantee that the state on the client will eventually reflect the state on the server is upheld, but until then, the client’s properties can be in a state (1,0,1) that never existed on the server. This is because Objects or even Structs don’t replicate atomically (all at once), meaning only properties that changed from the shadow state of the Actor (used to compare if the property is different and therefore needs to be replicated) will be sent. I don’t believe Objects can support atomic replication natively, but Structs definitely can.\n\nWhile we’re at it, it’s good to mention that dynamically (at runtime) attaching an ActorComponent to a replicated just spawned Actor server-side, is guaranteed to arrive in the same initial packet the Actor is sent so long as you do it in the same frame you spawn it (no longer than getting called).\n\nAt this point you should understand that the term frame is so important in this context, for the simple reason that Actors and the properties they entail are potentially gathered for replication at the end of every frame.\n\nGameState is guaranteed to be valid when any Actor on client calls .\n\nLet’s look at the following code to understand how such a guarantee is legit:\n\nNow if your’e familiar with the traditional game flow, and have read the code above, you’ll understand that first of all is called on the server, calling , which calls , which in return sets (that is marked for replication) to , and also calls , which calls on all Actors available on the server at this point. When the previously set boolean replicates, its replication callback gets automatically called, which calls , that calls on all Actors available on client at that point. replicating simply means that the GameState that entails it replicated as well. This guarantees us having a valid GameState by the time is called for any Actor existing on client at this point. Any Actors that may exist at a later point on client, will have their called either from:\n• : These are dynamic Actors spawned implicitly from replication on client, usually at a point later than the initial phase of the game, or having a lower than the one the GameState has (PlayerState for example).\n• : These are Actors spawned explicitly (not from replication) on client, usually at a point later than the initial phase of the game.\n\nIn order for to get called in both scenarios, the World must have on client, which must have already happened at this point, and which guarantees us a valid GameState on client.\n\nWith all that being said, this leads us to our exceptional guarantee:\n\nThere is no guarantee made regarding the order in which properties will be received or the order in which will be called. Any order is considered an implementation detail that should not be relied upon. If the order of an Actor’s property replication is important to your game, you may need to implement to track which properties have been updated on a frame. After the replicated values have been received and their called, you can handle the changes in the function. You may also need to save certain received values in their respective until they’re ready to be used.\n\nIt’s also important to know that the ordering of replication between Actors is not guaranteed. If two Actors have properties changed on the same frame, they may not be replicated or received on the same frame for a number of factors, such as differing update frequencies, relevancy/priority differences, or packet loss. If you have one Actor that is dependent on another for replication, such as an inventory Actor depending on a player Character, using to track state and determine when an Actor is available, is again a useful strategy for handling these kinds of situations. The Replication Graph also provides support for building and handling these dependencies as well.\n\nAny reliable RPCs sent are guaranteed to be received and processed in the order they were sent, as they will be resent until they are acknowledged. However, regardless of reliability, order is still not guaranteed between different Actors, and there is no guarantee that RPCs called on the same frame will arrive on the same frame.\n\nIn an ideal world, with optimal network conditions, unreliable RPCs are not any different, however once packet loss comes into the picture, gaps start to arise in the unreliable bunches, as they won’t be resent if they’re lost.\n\nAtomic replication of an object means replicating all properties within that object in the same packet, regardless of whether they changed or not, every time an object replicates. By default, Objects and Structs don’t replicate atomically, meaning only what changes gets sent, so they delta net-serialize.\n\nNote: Objects or Structs will atomically replicate (send all at once) all properties that are changed in the same frame as was mentioned before, however they don’t replicate atomically per se, so watch out for the context in which “atomically” is said!\n\nAtomic replication is crucial in situations where the client must never end up in a situation that never existed server-side potentially leading to an unexpected behavior. Such situations happen when you replicate multiple properties that relate to each other, and that you change them over multiple different frames, so some changes in between won’t get sent right away to the client because of packet loss, leading to a state client-side that never existed server-side, causing unexpected bad behaviors.\n\nTo solve this matter, we pack such properties that we need them to replicate “always together” in a Struct, and then we implement function for it (which we could also use to compress its properties values smaller as forms of bandwidth/CPU optimization), by serializing these properties in the archive, such that they can be always deserialized on client back into the state in which they were serialized on server. Here can be found a practical example. Note however that some of these properties you pack together, can potentially not be valid by the time you receive your packet (if they were references to an Object for example) as it was said previously.\n\nWarning: Using atomic replication out of place, can be of a burden on bandwidth, considering all properties are always sent for replication.\n\nWhile native Structs like FLinearColor doesn’t implement function, others do implement it, such that you can take as an example: FVector (you will find as TVector though), FRepMovement, and FHitResult.\n\nSometimes you might want to go a step further and ensure that a whole Object replicates atomically for reasons. The reason I had to do this at work recently was that I needed all properties of an Object to be valid all at the same time for an atomic operation (an operation that is done once, and needs all these properties to be valid when it gets executed). Again, this is not something you want to do regularly, but only when necessary.\n\nIn my case the Object defines customization settings for the Character. The code I ended up writing roughly looks like this:\n\nWith all that being said, you should be really careful to when you do something similar. In my case, I needed to do this only when a client joins a game session, and under certain conditions that I can’t disclose, such that it doesn’t happen frequently for it to consume much bandwidth. It’s good to note that this method of custom network serialization has some limitations, but it goes out of the article’s scope. Lastly, unless you got the reasons, you should always consider something else, but in my case this was a solid consideration that thankfully my lead guided me to.\n\nWhen running the Server-Client model, the GameMode will only exist on the server. Here are the wrong habits that involve this Actor:\n• Trying to retrieve it on client and getting null. Instead, you only retrieve it on the server.\n• Filtering client-server execution paths, when it has only one execution server path, making the filtering meaningless.\n• Calling RPCs on it, which will end up being meaningless, such that they will run locally on the server, considering GameMode is not a replicated Actor, and in fact exist only on the server.\n\nCurrently, almost all sources of Unreal Engine multiplayer knowledge will tell you the following info about Multicast RPCs:\n\nAnyone who reads this piece of info will be attracted by the myth that Multicast RPCs that are called on a replicated Actor on the server, will be executed on all of its instances (its server instance, and all its instances on clients), with no respect to relevancy for example, and that is totally wrong.\n\nThis, along with that they are not aware of the golden rule of multiplayer will lead them to use this type of RPCs out of place.\n\nThe correct piece of info though is:\n\nYou have to be aware that Multicast RPCs won’t account for either of the following:\n• Join-in-progress clients: Late joiners won’t have the Actor in question spawned in the first place for the RPC to get executed on it.\n• Clients the Actor isn’t relevant for: Imagine a game scenario where two players, A and B, are far away from one another, such that the distance between them is bigger than net cull distance (square root of ). Calling a Multicast RPC on A’s Pawn server-side, will execute the RPC on the A’s Pawn on the server, and on client where A’s Pawn is locally controlled (has a of ). However, the RPC won’t get executed on A’s Pawn on the instance where B’s Pawn is locally controlled (A’s Pawn won’t be locally controlled and will have a of ).\n• Replay recording/scrubbing: This can be used to implement Killcam for example.\n\nTo handle these scenarios, you will need to do stateful replication.\n\nOne of the very common problems that beginners face in multiplayer is: “How do you replicate the assignment/change of a SkeletalMesh to other clients?”\n\nClearly neither the SkeletalMeshComponent (inherits from SkinnedMeshComponent) nor its SkeletalMesh replicate:\n\nWhat beginners often do to solve this problem is one of the following ultimately failing tries:\n• Replicate the SkeletalMeshComponent: Which won’t do anything good, considering the internal isn’t replicated. This will also potentially break the CharacterMovementComponent networking.\n• Multicast the change: This is clearly bad because it is not stateful, and will break in many scenarios.\n\nWhat you should do instead is replicate the “action” or the “state” that drives the change. That can as simple as a replicated boolean variable that is tied to a replication callback , that assigns the to your Character. Instead of the boolean, you could have even replicated a pointer variable that points to the asset itself:\n\nHere you can find a similar problem that demonstrates the misuse of Multicast RPC, that then solves the problem properly like we did here above.\n\nRecently I was faced with the following issue at work:\n\nFor you to be able to know when a property replicates in a clean optimal way, you should have that property marked as , which isn’t always the case for native properties already provided to you by the engine, and in my case that was:\n\nThat variable was being set to when we initiate spectating, however we wanted to be able to “listen” to when it replicates so we could do something in response. Some of you might wonder why I didn’t simply use the native function , and the reason is that we want to avoid calling , which will make the PlayerController unpossess the Pawn and create a situation where it can no longer execute gameplay abilities, which can break one of our exclusive game features.\n\nAt this point I was suggested by my smart lead to do the following trick:\n\nTo explain, is a native function I used as a form of a “global replication callback”, along with implementing a gate inside, so we decide if the potentially new value received is really new, so we broadcast the proper delegate in response. As you can tell, it’s way more convoluted than if there was a replication callback that we could utilize out of the box, but it works nicely.\n\n21. Know when Objects are Network Referenceable\n\nPeeps usually tend to think that in order to be able to reference an Object over the network, it must be replicated, and that’s not entirely correct. This is because they are not aware that a stably named Object is a thing, which we will go over shortly.\n\nGenerally, Object references are handled automatically in Unreal’s multiplayer framework. What this means is, if you have an Object property that is replicated, the reference to that Object will be sent over the network as a special ID that is assigned by the server. This special ID is a NetworkGUID. The server is in charge of assigning this ID, and then notifying all connected clients of this assignment.\n\nHere’s how you replicate an Object reference:\n\nIn this case, property will be a replicated reference to the Object that this property refers to.\n\nFor an Object to be legally referenced over the network, it must be supported for networking. To check for this, you can call . This is generally considered a low level function, so it’s not common to need to check this in game code.\n\nIn general, these are the Objects that are network referenceable:\n• Any replicated Object: These can be Actors, or Subobjects (ActorComponents and UObjects).\n• Any stably named Object: These are generally non-replicated Actors, or Subobjects.\n\nStably named Objects are simply Objects that exist on both server and client, and have the exact same name. Initially they are referred to over the network by their name, until it’s replaced by the assigned NetworkGUID.\n\nActors are stably named if they were:\n• Act like loaded directly from packages\n• These are dynamically spawned Actors that fool the engine into thinking they are net startup Actors placed in maps (assigned static NetworkGUIDs so they are not destroyed on clients when they are not relevant to them). That’s done by setting and to , and them being deterministically named (same name on server and client).\n• Marked to be addressable by name (via )\n• These are dynamically deferred spawned Actors, that are marked to be net addressable before is called, and are deterministically named (same name on server and client).\n\nNote: Epic is quite strict on being called before is called. However, from my own experience, it can be called at any point in time.\n\nActorComponents are stably named if they were:\n• Default Subobjects\n• Created in C++ constructor, so they part of the CDO - Class Default Object.\n• Loaded directly from packages\n• Added to Actors placed in maps.\n• Marked to be addressable by name (via )\n• Automatically (done by native code)\n• Added via SCS - SimpleConstructionScript (created from a template defined in the section of the Blueprint. They are not part of the CDO, but of the SCS).\n• TimelineComponents (are behind the scenes added via UCS - UserConstructionScript).\n• Manually marked to be addressable by name (done by you)\n• Deterministically named (same name on server and client). These are generally dynamically spawned, but could be for example a SplineMeshComponent added via UCS.\n\nAll other UObjects (non-Actors and non-ActorComponents) are stably named if they were:\n• Default Subobjects\n• Created in C++ constructor, so they part of the CDO.\n• Deterministically named (same name on server and client), with returning . These are generally dynamically spawned.\n\nNote: Whether Objects were replicated or stably named, ultimately they will be referred to by their NetworkGUID, however when stably named, their name will be sent only once, and then replaced by NetworkGUID.\n\nBeware: Marking a replicated Actor to be addressable by name before it’s actually replicated, won’t make it replicate, and it will only exist on the server!\n\n23. Be Aware of Objects Prerequisites to Run RPCs\n\nI’ve decided to put this into a tip, because I’ve seen too many misinformation out there, both official and non-official.\n\nActors are potentially able to run RPCs if there were replicated.\n\nActorComponents are potentially able to run RPCs if there were:\n• Created from replication (spawned server-side and replicated), and their owning/outer Actor is replicated.\n• Stably named (Loaded/Spawned on both ends (server/client) with the same name relative to their owning.outer Actor), and their owning/outer Actor is replicated.\n• Neither replicated, nor stably named, and the RPC is a reliable Multicast/Client. This will however, spawn an ActorComponent on client, and link it with its server version by the NetworkGUID assigned, however the engine doesn’t seem to quite like it and you will end up crashing (I have to yet find a way not to crash).\n\nAll other UObjects (non-Actors or non-ActorComponents) are potentially able to run RPCs if they had the relevant code, their Actor replicated, and they were:\n• Created from replication (spawned server-side and replicated), and their Actor replicated.\n• Fully stably named (Loaded/Spawned on both ends (server/client) with the same full path name, so both their name and their Object name are the same - see for reference), and their owning Actor replicated. I found that you can bypass stably naming the if it was replicated, and then simply override to return .\n• Neither replicated, nor stably named, and the RPC is a reliable Multicast/Client. This will however, spawn a UObject on client, and link it with its server version by the NetworkGUID assigned, however the engine doesn’t seem to quite like it and you will end up crashing (I have to yet find a way not to crash).\n\nWhen it comes to naming your different type of RPCs, a very good practice and also a convention, is to prepend the name of your RPC function based on its type:\n\nThis is very useful to determine at a glance what machines this function will be potentially executed on during a multiplayer session.\n\n25. Know why RPCs have No Return Values\n\nRPCs are one way calls, that’s why they simply have no return values.\n\nIf you want to simulate a return value, you will have to ping-pong your RPCs. Meaning that an RPC gets sent one way, pulls some data, passes it as an RPC parameter to another RPC that is sent back the other way around.\n\nLevel Blueprints aren’t Actors that you use often in single-player, and so neither in multiplayer. However they’re great for one-off prototypes, and getting familiar with the Blueprints system, but they are specific to the level that they’re used in. This does mean that Level Blueprints can be great places to set up functionality specific to the level, or Actors in it. Some examples would be kicking off a cinematic when a certain trigger is touched, or opening a particular door after you kill all the enemies.\n\nLet’s look at the following piece of code that I see from time to time in the Level Blueprint:\n\nAnd in return an error is generated that goes along these lines:\n\nThis is a code that can take many forms but has one big caveat: Timings are not working to your side when it comes to the Level Blueprint!\n\nPlayerController can potentially get spawned after the LevelScriptActor (another way of saying Level Blueprint, as it’s its native parent class), meaning that it’s not there by the time is called, resulting in the error we’ve seen above, and with the being the possessed Pawn in case one exists.\n\nIn addition, keep in mind that this code also uses the ominous !\n\n27. Be Aware of Placed in Map Actors’ Subtleties\n\nPlaced-in-map (static) replicated Actors will quite surprise you in how different they can operate in a networked game from runtime-spawned (dynamic) replicated Actors:\n• They don’t get destroyed when net culled, meaning that when a placed in map Actor goes out of the relevancy range for a connection, it doesn’t get destroyed for that connection.\n• They don’t get called on them.\n• They are loaded from the map rather than spawned from replication.\n• Their replication callbacks, also known as functions, are not necessarily called before , like it’s guaranteed for POD types in dynamic replicated Actors, and will even usually have them called after is called."
    }
]