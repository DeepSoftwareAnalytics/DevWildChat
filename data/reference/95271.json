[
    {
        "link": "https://selenium-python.readthedocs.io/api.html",
        "document": "This chapter covers all the interfaces of Selenium WebDriver.\n\nThe API definitions in this chapter show the absolute location of classes. However, the recommended import style is as given below:\n\nThen, you can access the classes like this:\n\nThe special keys class ( ) can be imported like this:\n\nThe exception classes can be imported like this (Replace the with the actual class name given below):\n\nConventions used in the API\n\nSome attributes are callable (or methods) and others are non-callable (properties). All the callable attributes are ending with round brackets.\n\nHere is an example for property:\n\nHere is an example of a method:\n\nExceptions that may happen in all the webdriver code. The Element Click command could not be completed because the element receiving the events is obscuring the element that was requested to be clicked. Thrown when an element is present in the DOM but interactions with that element will hit another element due to paint order. Thrown when trying to select an unselectable element. Thrown when an element is present on the DOM, but it is not visible, and so is not able to be interacted with. Most commonly encountered when trying to click or read text of an element that is hidden from view. Thrown when activating an IME engine has failed. Thrown when IME support is not available. This exception is thrown for every IME-related method call if IME support is not available on the machine. Navigation caused the user agent to hit a certificate warning, which is usually the result of an expired or invalid TLS certificate. The arguments passed to a command are either invalid or malformed. Thrown when attempting to add a cookie under a different domain than the current URL. The coordinates provided to an interaction’s operation are invalid. Thrown when a command could not be completed because the element is in an invalid state. This can be caused by attempting to clear an element that isn’t both editable and resettable. Thrown when the selector which is used to find an element does not return a WebElement. Currently this only happens when the selector is an xpath expression and it is either syntactically invalid (i.e. it is not a xpath expression) or the expression does not select WebElements (e.g. “count(//input)”). Occurs if the given session id is not in the list of active sessions, meaning the session either does not exist or that it’s not active. Thrown when frame or window target to be switched doesn’t exist. An error occurred while executing JavaScript supplied by the user. Thrown when the target provided to the move() method is invalid, i.e. out of document. Thrown when switching to no presented alert. This can be caused by calling an operation on the Alert() class when an alert is not yet on the screen. Thrown when the attribute of element could not be found. You may want to check if the attribute exists in the particular browser you are testing against. Some browsers may have different property names for the same property. (IE8’s .innerText vs. Firefox .textContent) No cookie matching the given path name was found amongst the associated cookies of the current browsing context’s active document. Raised when driver is not specified and cannot be located. Thrown when element could not be found. If you encounter this exception, you may want to check the following:\n• None Check your selector used in your find_by…\n• None Element may not yet be on the screen at the time of the find operation, (webpage is still loading) see selenium.webdriver.support.wait.WebDriverWait() for how to write a wait wrapper to wait for an element to appear. Thrown when frame target to be switched doesn’t exist. Thrown when trying to access the shadow root of an element when it does not have a shadow root attached. Thrown when window target to be switched doesn’t exist. To find the current set of active window handles, you can get a list of the active window handles in the following way: A new session could not be created. Thrown when a reference to an element is now “stale”. Stale means the element no longer appears on the DOM of the page. Possible causes of StaleElementReferenceException include, but not limited to:\n• None You are no longer on the same page, or the page may have refreshed since the element was located.\n• None The element may have been removed and re-added to the screen, since it was located. Such as an element being relocated. This can happen typically with a javascript framework when values are updated and the node is rebuilt.\n• None Element may have been inside an iframe or another context which was refreshed. Thrown when a command does not complete in enough time. Thrown when an unexpected alert has appeared. Usually raised when an unexpected modal is blocking the webdriver from executing commands. Thrown when a support class did not get an expected web element. The requested command matched a known URL but did not match any methods for that URL.\n\nABC’s allow custom implementations of Webdriver to be registered so that isinstance type checks will succeed. Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://www.selenium.dev/documentation/legacy/json_wire_protocol/.\n• None session_id - String ID of the browser session started and controlled by this WebDriver.\n• None capabilities - Dictionary of effective capabilities of this browser session as returned by the remote server. See https://www.selenium.dev/documentation/legacy/desired_capabilities/ Create a new driver that will issue commands using the wire protocol.\n• None command_executor - Either a string representing URL of the remote server or a custom\n• None keep_alive - Whether to configure remote_connection.RemoteConnection to use\n• None file_detector - Pass custom file detector object during instantiation. If None, then default LocalFileDetector() will be used. Adds a virtual authenticator with the given options. Goes one step backward in the browser history. Creates a web element with the specified . Delete all cookies in the scope of the session. Deletes a single cookie with the given name. Downloads a file with the specified file name to the target directory. file_name: The name of the file to download. target_directory: The path to the directory to save the downloaded file. Sends a command to be executed by a command.CommandExecutor.\n• None driver_command: The name of the command to execute as a string.\n• None params: A dictionary of named parameters to send with the command.\n• None *args: Any applicable arguments for your JavaScript.\n• None *args: Any applicable arguments for your JavaScript. Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards.\n• None file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager.\n• None args - Optional arguments that get passed to the file detector class during\n• None kwargs - Keyword arguments, passed the same way as args. Find an element given a By strategy and locator. Find elements given a By strategy and locator. Goes one step forward in the browser history. Get a single cookie by name. Returns the cookie if found, None if not. Returns a set of dictionaries, corresponding to cookies visible in the current session. Returns the list of credentials owned by the authenticator. Retrieves the downloadable files as a map of file names and their corresponding URLs. Gets the log for a given log type.\n• None log_type: type of log that which will be returned Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename.\n• None filename: The full path you wish to save your screenshot to. This should end with a extension. Gets the screenshot of the current window as a binary data. Gets the x,y position of the current window. Gets the x, y coordinates of the window as well as height and width of the current window. Gets the width and height of the current window. Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout.\n• None time_to_wait: Amount of time to wait (in seconds) Maximizes the current window that webdriver is using. Store common javascript scripts to be executed later by a unique hashable ID. The driver makes a best effort to return a PDF based on the provided parameters. Quits the driver and closes every associated window. Removes all credentials from the authenticator. The authenticator is no longer valid after removal, so no methods may be called. Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename.\n• None filename: The full path you wish to save your screenshot to. This should end with a extension. Set the amount of time to wait for a page load to complete before throwing an error.\n• None time_to_wait: The amount of time to wait Set the amount of time that the script should wait during an execute_async_script call before throwing an error.\n• None time_to_wait: The amount of time to wait (in seconds) Sets whether the authenticator will simulate success or fail on user verification. verified: True if the authenticator will pass user verification, False otherwise. Sets the x,y position of the current window. (window.moveTo)\n• None x: the x-coordinate in pixels to set the window position\n• None y: the y-coordinate in pixels to set the window position Sets the x, y coordinates of the window as well as height and width of the current window. This method is only supported for W3C compatible browsers; other browsers should use and . Sets the width and height of the current window. (window.resizeTo)\n• None width: the width in pixels to set the window to\n• None height: the height in pixels to set the window to This method may be overridden to define custom startup behavior. Creates a new session with the desired capabilities.\n• None capabilities - a capabilities dict to start the session with. This method may be overridden to define custom shutdown behavior. Returns the drivers current capabilities being used. Gets the URL of the current page. Returns the handle of the current window. Gets a list of the available log types. This only works with w3c compliant browsers. Returns the name of the underlying browser for this instance. Gets the current orientation of the device. Gets the source of the current page.\n• None SwitchTo: an object containing all options to switch focus into Get all the timeouts that have been set on the current session. Returns the title of the current page. Returns the id of the virtual authenticator. Returns the handles of all windows within the current session.\n\nABC’s will allow custom types to be registered as a WebElement to pass type checks. Generally, all interesting operations that interact with a document will be performed through this interface. All method calls will do a freshness check to ensure that the element reference is still valid. This essentially determines whether the element is still attached to the DOM. If this test fails, then an is thrown, and all future calls to this instance will fail. Find an element given a By strategy and locator. Find elements given a By strategy and locator. Gets the given attribute or property of the element. This method will first try to return the value of a property with the given name. If a property with that name doesn’t exist, it returns the value of the attribute with the same name. If there’s no attribute with that name, is returned. Values which are considered truthy, that is equals “true” or “false”, are returned as booleans. All other non- values are returned as strings. For attributes or properties which do not exist, is returned. To obtain the exact value of the attribute or property, use or methods respectively.\n• None name - Name of the attribute/property to retrieve. # Check if the \"active\" CSS class is applied to an element. Gets the given attribute of the element. Unlike , this method only returns attributes declared in the element’s HTML markup.\n• None name - Name of the attribute to retrieve. Gets the given property of the element.\n• None name - Name of the property to retrieve. Whether the element is visible to a user. Returns whether the element is enabled. Returns whether the element is selected. Can be used to check if a checkbox or radio button is selected. Saves a screenshot of the current element to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename.\n• None filename: The full path you wish to save your screenshot to. This should end with a extension.\n• None value - A string for typing, or setting form fields. For setting file inputs, this could be a local file path. Use this to send simple key events or to fill out form fields: This can also be used to set file inputs. # Generally it's better to wrap the file path in one of the methods # in os.path to return the actual path to support cross OS testing. The value of a CSS property. Returns the ARIA Level of the current webelement. Returns the ARIA role of the current web element. This is mainly for internal use. Simple use cases such as checking if 2 webelements refer to the same element, can be done using : The location of the element in the renderable canvas. THIS PROPERTY MAY CHANGE WITHOUT WARNING. Use this to discover where on the screen an element is so that we can click it. This method should cause the element to be scrolled into view. Returns the top lefthand corner location on the screen, or zero coordinates if the element is not visible. Internal reference to the WebDriver instance this element was found from. A dictionary with the size and location of the element. Gets the screenshot of the current element as a base64 encoded string. Gets the screenshot of the current element as a binary data. Returns a shadow root of the element if there is one or an error. Only works from Chromium 96, Firefox 96, and Safari 16.4 onwards.\n• None NoSuchShadowRoot - if no shadow root was attached to element\n\nAn expectation for checking if an alert is currently present and switching to it. An expectation that all of multiple expected conditions is true. Equivalent to a logical ‘AND’. Returns: When any ExpectedCondition is not met: False. When all ExpectedConditions are met: A List with each ExpectedCondition’s return value. An expectation that any of multiple expected conditions is true. Equivalent to a logical ‘OR’. Returns results of the first matching condition, or False if none do. An expectation for checking if the given attribute is included in the specified element. An expectation to locate an element and check if the selection state specified is in that state. locator is a tuple of (by, path) is_selected is a boolean An expectation for the element to be located is selected. locator is a tuple of (by, path) An expectation for checking if the given element is selected. An Expectation for checking an element is visible and enabled such that you can click it. element is either a locator (text) or an WebElement An expectation for checking the selection is selected. An expectation for checking whether the given frame is available to switch to. If the frame is available it switches the given driver to the specified frame. An Expectation for checking that an element is either invisible or not present on the DOM. element is either a locator (text) or an WebElement An Expectation for checking that an element is either invisible or not present on the DOM. locator used to find the element An expectation that a new window will be opened and have the number of windows handles increase. An expectation that none of 1 or multiple expected conditions is true. An expectation for the number of windows to be a certain value. An expectation for checking that there is at least one element present on a web page. locator is used to find the element returns the list of WebElements once they are located An expectation for checking that an element is present on the DOM of a page. This does not necessarily mean that the element is visible. locator - used to find the element returns the WebElement once it is located Wait until an element is no longer attached to the DOM. element is the element to wait for. returns False if the element is still attached to the DOM, true otherwise. An expectation for checking if the given text is present in the specified element. An expectation for checking if the given text is present in the element’s attribute. An expectation for checking if the given text is present in the element’s value. An expectation for checking that the title contains a case-sensitive substring. title is the fragment of title expected returns True when the title matches, False otherwise An expectation for checking the title of a page. title is the expected title, which must be an exact match returns True if the title matches, false otherwise. An expectation for checking the current url. url is the expected url, which must not be an exact match returns True if the url is different, false otherwise. An expectation for checking that the current url contains a case- sensitive substring. url is the fragment of url expected, returns True when the url matches, False otherwise An expectation for checking the current url. pattern is the expected pattern. This finds the first occurrence of pattern in the current url and as such does not require an exact full match. An expectation for checking the current url. url is the expected url, which must be an exact match returns True if the url matches, false otherwise. An expectation for checking that an element, known to be present on the DOM of a page, is visible. Visibility means that the element is not only displayed but also has a height and width that is greater than 0. element is the WebElement returns the (same) WebElement once it is visible An expectation for checking that all elements are present on the DOM of a page and visible. Visibility means that the elements are not only displayed but also has a height and width that is greater than 0. locator - used to find the elements returns the list of WebElements once they are located and visible An expectation for checking that there is at least one element visible on a web page. locator is used to find the element returns the list of WebElements once they are located An expectation for checking that an element is present on the DOM of a page and visible. Visibility means that the element is not only displayed but also has a height and width that is greater than 0. locator - used to find the element returns the WebElement once it is located and visible"
    },
    {
        "link": "https://selenium.dev/selenium/docs/api/py/webdriver_chrome/selenium.webdriver.chrome.webdriver.html",
        "document": "Controls the ChromeDriver and allows you to drive the browser.\n\nCreates a new instance of the chrome driver. Starts the service and then creates new instance of chrome driver.\n\nNavigate the browser to the specified URL in the current window or tab. The method does not return until the page is fully loaded (i.e. the onload event has fired).\n• None The URL to be opened by the browser."
    },
    {
        "link": "https://selenium.dev/documentation/webdriver/drivers/options",
        "document": "These capabilities are shared by all browsers.\n\nIn Selenium 3, capabilities were defined in a session by using Desired Capabilities classes. As of Selenium 4, you must use the browser options classes. For remote driver sessions, a browser options instance is required as it determines which browser will be used.\n\nThese options are described in the w3c specification for Capabilities.\n\nEach browser has custom options that may be defined in addition to the ones defined in the specification.\n\nBrowser name is set by default when using an Options class instance.\n\nThis capability is optional, this is used to set the available browser version at remote end. In recent versions of Selenium, if the version is not found on the system, it will be automatically downloaded by Selenium Manager\n\nThree types of page load strategies are available.\n\nThe page load strategy queries the document.readyState as described in the table below:\n\nThe property of a document describes the loading state of the current document.\n\nWhen navigating to a new page via URL, by default, WebDriver will hold off on completing a navigation method (e.g., driver.navigate().get()) until the document ready state is complete. This does not necessarily mean that the page has finished loading, especially for sites like Single Page Applications that use JavaScript to dynamically load content after the Ready State returns complete. Note also that this behavior does not apply to navigation that is a result of clicking an element or submitting a form.\n\nIf a page takes a long time to load as a result of downloading assets (e.g., images, css, js) that aren’t important to the automation, you can change from the default parameter of to or to speed up the session. This value applies to the entire session, so make sure that your waiting strategy is sufficient to minimize flakiness.\n\nWebDriver waits until the load event fire is returned.\n\nWebDriver only waits until the initial page is downloaded.\n\nThis identifies the operating system at the remote-end, fetching the returns the OS name.\n\nIn cloud-based providers, setting sets the OS at the remote-end.\n\nThis capability checks whether an expired (or) invalid is used while navigating during a session.\n\nIf the capability is set to , an insecure certificate error will be returned as navigation encounters any domain certificate problems. If set to , invalid certificate will be trusted by the browser.\n\nAll self-signed certificates will be trusted by this capability by default. Once set, capability will have an effect for the entire session.\n\nA WebDriver is imposed with a certain interval, during which the user can control the behaviour of executing scripts or retrieving information from the browser.\n\nEach session timeout is configured with combination of different as described below:\n\nSpecifies when to interrupt an executing script in a current browsing context. The default timeout 30,000 is imposed when a new session is created by WebDriver.\n\nSpecifies the time interval in which web page needs to be loaded in a current browsing context. The default timeout 300,000 is imposed when a new session is created by WebDriver. If page load limits a given/default time frame, the script will be stopped by TimeoutException.\n\nThis specifies the time to wait for the implicit element location strategy when locating elements. The default timeout 0 is imposed when a new session is created by WebDriver.\n\nSpecifies the state of current session’s . Defaults to dismiss and notify state\n\nThis defines what action must take when a user prompt encounters at the remote-end. This is defined by capability and has the following states:\n\nIndicates whether the remote end supports all of the resizing and repositioning commands.\n\nThis new capability indicates if strict interactability checks should be applied to input type=file elements. As strict interactability checks are off by default, there is a change in behaviour when using Element Send Keys with hidden file upload controls.\n\nA proxy server acts as an intermediary for requests between a client and a server. In simple terms, the traffic flows through the proxy server on its way to the address you requested and back.\n\nA proxy server for automation scripts with Selenium could be helpful for:\n• Access the required website under complex network topologies or strict corporate restrictions/policies.\n\nIf you are in a corporate environment, and a browser fails to connect to a URL, this is most likely because the environment needs a proxy to be accessed.\n\nSelenium WebDriver provides a way to proxy settings:"
    },
    {
        "link": "https://selenium-python.readthedocs.io/getting-started.html",
        "document": "If you have installed Selenium Python bindings, you can start using it from Python like this. The above script can be saved into a file (eg:- ), then it can be run like this: The which you are running should have the module installed.\n\nThe module provides all the WebDriver implementations. Currently supported WebDriver implementations are Firefox, Chrome, IE and Remote. The class provide keys in the keyboard like RETURN, F1, ALT etc. The class is used to locate elements within a document. Next, the instance of Firefox WebDriver is created. The method will navigate to a page given by the URL. WebDriver will wait until the page has fully loaded (that is, the “onload” event has fired) before returning control to your test or script. Be aware that if your page uses a lot of AJAX on load then WebDriver may not know when it has completely loaded: The next line is an assertion to confirm that title has the word “Python” in it: WebDriver offers a number of ways to find elements using the method. For example, the input text element can be located by its attribute using the method and using By.NAME as its first parameter. A detailed explanation of finding elements is available in the Locating Elements chapter: Next, we are sending keys, this is similar to entering keys using your keyboard. Special keys can be sent using the class imported from . To be safe, we’ll first clear any pre-populated text in the input field (e.g. “Search”) so it doesn’t affect our search results: After submission of the page, you should get the result if there is any. To ensure that some results are found, make an assertion: Finally, the browser window is closed. You can also call the method instead of . The method will exit the browser whereas will close one tab, but if just one tab was open, by default most browsers will exit entirely.:\n\nSelenium is mostly used for writing test cases. The package itself doesn’t provide a testing tool/framework. You can write test cases using Python’s unittest module. Alternatively, you may consider pytest for writing tests. In this chapter, we use as the framework of choice. Here is the modified example which uses the unittest module. This is a test for the search functionality: You can run the above test case from a shell like this: The above result shows that the test has been successfully completed. Note: To run the above test in IPython or Jupyter, you should pass a couple of arguments to the function as shown below:\n\nInitially, all the basic modules required are imported. The unittest module is a built-in Python module based on Java’s JUnit. This module provides the framework for organizing the test cases. The module provides all the WebDriver implementations. Currently supported WebDriver implementations are: Firefox, Chrome, IE and Remote. The class provides keys in the keyboard like RETURN, F1, ALT etc. The class is used to locate elements within a document. The test case class is inherited from . Inheriting from the class is the way to tell module that this is a test case: The method is part of initialization. This method will get called before every test function which you are going to write in this test case class. Here you are creating an instance of a Firefox WebDriver. This is the test case method. The test case method should always start with characters . The first line inside this method creates a local reference to the driver object created in method. The method will navigate to a page given by the URL. WebDriver will wait until the page has fully loaded (that is, the “onload” event has fired) before returning control to your test or script. Be aware that if your page uses a lot of AJAX on load then WebDriver may not know when it has completely loaded: The next line is an assertion to confirm that title has the word “Python” in it: WebDriver offers a number of ways to find elements using the method. For example, the input text element can be located by its attribute using the method. Detailed explanation of finding elements is available in the Locating Elements chapter: Next, we are sending keys, this is similar to entering keys using your keyboard. Special keys can be sent using the class imported from : After submission of the page, you should get the result as per search if there is any. To ensure that some results are found, make an assertion: The method will get called after every test method. This is a place to do all cleanup actions. In the current method, the browser window is closed. You can also call the method instead of . The method will exit the entire browser, whereas will close a tab, but if it is the only tab opened, by default most browsers will exit entirely.: Final lines are some boiler plate code to run the test suite:"
    },
    {
        "link": "https://developer.chrome.com/docs/chromedriver/get-started",
        "document": "Save and categorize content based on your preferences.\n\nStay organized with collections Save and categorize content based on your preferences.\n\nThis page documents how to start using ChromeDriver for testing your website on desktop (Windows/Mac/Linux). You can also read Getting Started with Android or Getting Started with ChromeOS.\n\nChromeDriver is a separate executable that Selenium WebDriver uses to control Chrome. It is maintained by the Chromium team with help from WebDriver contributors. If you are unfamiliar with Selenium WebDriver, you should check out the Selenium site.\n\nFollow these steps to setup your tests for running with ChromeDriver:\n• Ensure Chromium and Google Chrome are installed in a recognized location.\n• ChromeDriver expects you to have Chrome installed in the default location for your platform. You can force ChromeDriver to use a custom location by setting a special capability.\n• Download the ChromeDriver binary for your platform.\n\nAny of these steps should work:\n• Include the ChromeDriver location in your PATH environment variable\n• (Python only) Include the path to ChromeDriver when instantiating . See the following samples.\n\n// Optional. If not specified, WebDriver searches the PATH for chromedriver. // Let the user actually see something! // Let the user actually see something!\n\n# Optional argument, if not specified will search path. # Let the user actually see something! # Let the user actually see something!\n\nThe ChromeDriver class starts the ChromeDriver server process at creation and terminates it when quit is called. This can waste a significant amount of time for large test suites where a ChromeDriver instance is created per test. There are two options to remedy this, ChromeDriverService and starting ChromeDriver separately.\n\nUse the ChromeDriverService. This is available for most languages and lets you start or stop the ChromeDriver server yourself. Here's a Java example, with JUnit 4:\n\nStart the ChromeDriver server separately before running your tests, and connect to it using the Remote WebDriver."
    },
    {
        "link": "https://stackoverflow.com/questions/64613878/how-do-i-use-multiple-browser-instances-at-the-same-time-in-selenium-python",
        "document": "I have a code that opens three same windows of website, and I need to do the same actions on them at the same time, is it possible? If yes, how can I make it? Btw, I am new to selenium, and programming at all, so sorry for a dumb question :d Thanks for any help.\n\nUpd. I've tried using something like this, and now actions are being made only at one window, what should I do?"
    },
    {
        "link": "https://browserstack.com/guide/python-selenium-to-run-web-automation-test",
        "document": "New features are regularly added to web applications to boost user engagement. To ensure these updates work as intended and that the user interface remains functional, automated testing is crucial. Selenium is a widely-used tool for this type of automation testing.\n\nSelenium is an open-source automation testing tool that supports various scripting languages such as C#, Java, Perl, Ruby, JavaScript, and others. The choice of scripting language can be made based on the specific requirements of the application being tested.\n\nPython is one of the most popular choices when it comes to scripting with 51% of the developers using it, as suggested by the StackOverflow 2024 annual survey.\n\nWhy do Developers prefer Python for writing Selenium Test Scripts?\n\nDevelopers prefer Python for writing Selenium test scripts because of its simplicity, readability, and ease of use. Python’s clear and concise syntax allows for faster script development and easier maintenance, which is crucial in testing scenarios.\n\nAdditionally, Python has a rich set of libraries and frameworks that complement Selenium, making it easier to handle complex tasks such as data manipulation, reporting, and integration with other tools.\n\nPython’s extensive community support and documentation also provide valuable resources for troubleshooting and improving test scripts. These factors make Python a popular choice for Selenium automation.\n\nGetting started with Selenium using Python involves setting up an environment where you can write and run automated test scripts for web applications.\n\nSelenium, combined with Python, offers a powerful and easy-to-learn toolset for automating browser interactions. Python’s simple syntax makes it ideal for quickly writing clear and maintainable test scripts.\n\nTo begin, you’ll need to install the Selenium WebDriver, set up a compatible browser, and learn the basics of locating web elements, interacting with them, and running test cases. This combination is perfect for testing dynamic and responsive web applications efficiently.\n\nSelenium Python Example: How to run your first Test?\n\nTo run Selenium Python Tests here are the steps to follow:\n\nFirst, you’ll need to import the WebDriver and Keys classes from Selenium. These classes help you interact with a web browser and emulate keyboard actions.\n• webdriver: Allows you to control the browser.\n\nTo interact with a browser, you’ll need to create an instance of WebDriver. In this example, we use Chrome:\n\nMake sure chromedriver is in the same directory as your Python script. This command opens a new Chrome browser window.\n\nUse the .get() method to navigate to a website. This method waits for the page to load completely:\n\nThis will open Python’s official website in the browser.\n\nOnce the page is loaded, you can retrieve and print the page title to verify you’re on the right page:\n\nYou should see:\n\nTo perform a search, locate the search bar element, enter a query, and submit it. Here’s how to find the search bar by its name attribute and interact with it:\n• send_keys(“getting started with python”): Types the query into the search bar.\n\nAfter submitting the search query, you can check the updated URL to confirm the search results page:\n\nYou should see a URL similar to:\n\nFinally, close the browser session to end the test:\n\nHere is the complete script for your first Selenium test in Python. Save this code in a file named selenium_test.py and run it using python selenium_test.py:\n\nSelenium allows you to perform a variety of actions on web elements. You have already touched upon entering input, here’s how to interact with buttons, and dropdowns:\n\nAssuming you want to click a button with the ID “submit-button” after entering the input in the search bar :\n\nIf you need to click a link by its text:\n• find_element_by_id(“submit-button”): Finds the button with the ID “submit-button”.\n\nThough dropdowns are not present on this site, they are quite common for web application testing\n\nFor dropdown menus, Selenium provides the Select class to handle options within <select> elements.\n\nExample: Selecting an Option from a Dropdown\n\nAssuming you have a dropdown menu with the ID “dropdown-menu”:\n• select_by_visible_text(“Option 1”): Selects an option by its visible text.\n• select_by_value(“option1”): Selects an option by its value attribute.\n• select_by_index(0): Selects an option by its index in the dropdown.\n\nThe HTML Document Object Model (DOM) represents the structure of a web page as a tree of objects. Selenium allows you to interact with these elements using various locator strategies.\n\nIn our first test script, we have already used some of the methods used to navigate DOM elements. This section will be a slightly more detailed view into how you can use different methods to locate and interact with elements on the Python.org website.\n\nTo click the “Downloads” link, you can use the .find_element_by_link_text() method, but here’s how to use other locators to achieve the same, example by using find_element_by_xpath:\n\nlocates the “Downloads” link based on its visible text.\n\nTo access the main header text, you can use different locators to find the header element.\n• Class Name: “introduction” is used to find the header element based on its class.\n\nExample: Filling Out and Submitting the Search Form\n\nTo interact with the search form, you can use the .find_element_by_name() method to locate the input field.\n• Name Attribute: find_element_by_name(“q”) locates the search input field by its name attribute.\n\nWhen working with multiple browser windows or tabs, or dealing with iframes (frames), you may need to switch contexts to interact with different elements.\n• window_handles: Retrieves a list of window handles. Switch to a specific window using switch_to.window().\n\nExample: Switching to an iFrame\n\nTo switch to and interact with elements within an iframe:\n\nDynamic content can load at different times, so using waits helps ensure elements are present before interacting with them.\n• implicitly_wait(): Sets a default wait time for finding elements. If an element is not immediately found, WebDriver will wait up to the specified time.\n• WebDriverWait(driver, 10): Creates an instance of WebDriverWait, specifying a maximum wait time of 10 seconds.\n• wait.until(EC.presence_of_element_located((By.NAME, “q”))): Pauses the script until the search bar element is found by its name attribute. If the element is not found within 10 seconds, a TimeoutException will be raised.\n\nTo ensure that the application behaves as expected, you can use assertions and validations.\n• Assertions: Used to check if the conditions are met. For example, checking if the title or text of elements matches expected values.\n• assert: Verifies conditions and will raise an AssertionError if the condition is not true.\n\nWeb applications often use JavaScript alerts, confirmation dialogs, or prompts to interact with users. Selenium provides ways to handle these pop-ups effectively.\n\nJavaScript alerts are simple pop-up messages that require user interaction to dismiss. Selenium allows you to interact with these alerts using the switch_to.alert() method.\n• switch_to.alert: Switches the context to the alert. Once switched, you can interact with the alert.\n• alert.accept(): Accepts the alert, which is equivalent to clicking “OK” on the alert.\n\nProperly closing the browser session is crucial for releasing resources and ensuring that your automation script runs cleanly.\n• driver.quit(): Closes all browser windows and ends the WebDriver session. This is the preferred method for cleanup as it ensures the browser process is terminated and resources are freed.\n• driver.close(): Closes the current window. If it’s the only window open, it will end the session. Use driver.quit() for complete cleanup.\n\nIntegrating Selenium tests with a testing framework provides structured test cases, reporting, and additional functionality such as setup and teardown methods.\n\nunittest is a built-in Python testing framework that provides a structured approach to writing and running tests, including test case management, fixtures, and test discovery. Integrating Selenium with unittest allows for organized test cases, setup and teardown methods, and detailed test reports, making it easier to manage and maintain automated tests.\n• unittest.TestCase: Defines a test case class. Each method within the class represents a test case.\n• setUpClass(): Initializes resources needed for the tests. Runs once before any test methods are executed.\n• tearDownClass(): Cleans up resources. Runs once after all test methods have completed.\n• unittest.main(): Runs the tests and provides output in the console.\n\npytest is a powerful and flexible Python testing framework that simplifies writing tests with its rich feature set, including fixtures, parameterized tests, and detailed assertions. Integrating Selenium with pytest enhances test organization, facilitates advanced setup/teardown functionality, and generates comprehensive test reports, improving test reliability and clarity.\n• pytest.fixture(): Defines a fixture that sets up and tears down resources. The scope=”module” ensures the fixture is run once per module.\n• yield: Provides the driver instance to the test function and performs cleanup after the test completes.\n• assert: Checks that the condition is met. pytest will report the assertion failure if the\n• How to install GeckoDriver for Selenium Python?\n• How to perform Web Scraping using Selenium and Python\n• How to Create and Use Action Class in Selenium Python\n• How to download a file using Selenium and Python\n• How to Press Enter without Element in Selenium Python?\n• Get Current URL in Selenium using Python: Tutorial\n\nBest Practices using Selenium WebDriver with Python\n\nHere are five best practices for using Selenium WebDriver with Python:\n• Use Explicit Waits: Prefer explicit waits over implicit waits to handle dynamic content. Explicit waits ensure that your script interacts with elements only when they are ready, reducing the chances of encountering timing issues.\n• Organize Tests with Frameworks: Integrate Selenium tests with testing frameworks like unittest or pytest to structure your test cases, manage setup and teardown, and generate detailed test reports.\n• Use Page Object Model (POM): Implement the Page Object Model to separate test logic from page-specific code. This design pattern promotes code reusability, maintainability, and easier updates.\n• Handle Exceptions Carefully: Implement error handling and logging to manage unexpected situations, such as element not found or timeout errors. This helps in debugging and provides insights into test failures.\n• Optimize Browser Performance: Run tests in headless mode or use browser profiles to speed up test execution and reduce resource consumption. Also, ensure that browser drivers are up-to-date for compatibility and performance improvements.\n\nRunning Selenium Python tests on BrowserStack’s Real Device Cloud offers numerous advantages that significantly enhance testing efficiency and effectiveness.\n\nBrowserStack provides access to a wide range of real devices and browsers, ensuring that tests reflect real-world scenarios and uncover device-specific issues. The platform supports scalable parallel execution, allowing multiple tests to run simultaneously across various configurations, which accelerates the development cycle.\n\nCross-platform testing on BrowserStack ensures consistent application performance across different environments. Additionally, it offers real-time debugging features such as live logs, screenshots, and video recordings, which aid in quick troubleshooting.\n\nSeamless integration with CI/CD pipelines further automates the testing process, enabling tests to run on every code change and providing immediate feedback on application quality. Overall, BrowserStack Automate enables comprehensive, efficient, and reliable testing, fostering continuous development and deployment."
    },
    {
        "link": "https://stackoverflow.com/questions/78272090/how-can-i-handle-multiple-browser-instance-in-selenium-webdriver",
        "document": "I wrote a code to open 4 Browser instance at a time but i need to select each browser instance separately. for example if there are 4 Browser instance with 4 different profiles.1st Browser 1 (Profile 1) opens after 10 seconds Browser 2 (profile 2) opens and so on. After Profile 4 Opens i can see Profile 4 windows on screen but i need to switch to profile 1 browser instance (view on screen) and do some task then go to profile 2-- 3---4.\n\nIs there anyway to do this?"
    },
    {
        "link": "https://lambdatest.com/blog/handling-multiple-windows-in-selenium-python",
        "document": "Automating testing is a crucial step in the development pipeline of a software product. In an agile development environment, where there is continuous development, deployment, and maintenance of software products, automation testing ensures that the end software products delivered are error-free.\n\nIn the world of automation, Selenium is one of the most widely used open-source automation testing frameworks to execute automated web browser tests on websites. Selenium can run automated tests on various browsers (e.g., Chrome, Firefox, Edge, etc.). The test automation scripts can be devised using popular frameworks offered by languages like C#, Java, JavaScript, Python, and more.\n\nThe automated test cases you perform using Selenium might lead you to instances where it is necessary to handle multiple windows while working with a web application. This situation may arise as a result of clicking a button on the website that opens up a URL to a new tab or a new window. For example, the job search platform Glassdoor opens a new window when you click the buttons to sign in using your Google account or Facebook account.\n\nClick on the “Continue with Facebook” button to sign in.\n\nA Facebook webpage window will pop up to prompt you to sign in.\n\nAs a result, the user might need to access the open browser window to move forward.\n\nAs a QA tester, running a test case might require you to complete some operations in a newly opened browser window or tab before going back to the original window or tab to finish the rest of the tasks.\n\nIn this blog on how to handle multiple windows in Selenium Python, we will discuss the basics of browser windows and how to handle multiple windows in Selenium Python. By the end of the blog, you will be able to handle multiple windows when they arise when executing test cases. If you’re looking to improve your Selenium interview skills, check out our curated list of Selenium interview questions and answers.\n\nWhat is a Browser Window in Selenium?\n\nThe browser window, often called the main or parent window, represents the homepage or the currently open web page a user sees when opening a browser. When a Selenium automation script runs, it typically starts with the parent window. Initiating a Selenium WebDriver session involves opening a window that is initially controlled by the WebDriver.\n\nTo have a view of what a parent window looks like, here is a window of the LambdaTest Selenium Playground website.\n\nSelenium WebDriver always keeps the context of the parent window when navigating to a defined URL that opens a new window. The child window will be within the context of the parent window. This enables navigating back and forth between the windows once you are done with the operations you were handling in the newly opened child window.\n\nThis was all about the browser window in Selenium. In the next section of this blog on how to handle multiple windows in Selenium Python, we will learn more about child windows in Selenium.\n\nWhat is a Child Window in Selenium?\n\nWhen we click on a button or URL link in the parent window, and the action opens another window(s) within the main window, the new window(s) is called a child window. The new window(s) or tab(s) opened are called children of the parent window and have unique window handles.\n\nTo demonstrate the handling of child windows, let’s use the LambdaTest Selenium Playground we mentioned earlier:\n• Click on the Windows Popup Modal link in the main window.\n• Click on the buttons in the Single Window Popup Modal to open a single child window. Click on the buttons in the Single Window Popup to open the Child Window\n• Click on the Multiple Window Popup buttons to open multiple child browser windows. The first button opens two child windows, while the “Follow All” button opens three child windows.\n\nThe current page you are on is the main window, while the windows (Facebook, Twitter, and LambdaTest web pages) open by clicking the buttons are the child windows.\n\nIt is possible to open a single window or multiple child windows from a single main window. It is also important to note that a child window may or may not contain a URL link.\n\nWhile conducting a test case on the above scenario manually, it is simple to examine the behavior of the child windows because of their visibility in the context of the parent window. However, this is not the case when using Selenium to automate the test case because we need to change the WebDriver’s context from the parent window to the child window to perform actions on it.\n\nWhat is a Window Handle in Selenium Python?\n\nSince we have discussed the concept of windows in Selenium in the above section of this blog on how to handle multiple windows in Selenium Python, let us move on to learning how to control multiple windows.\n\nMultiple windows are brought up by scenarios in which a web application navigates to or opens multiple browser windows. Selenium provides the option to handle multiple windows with window handles.\n\nThe Selenium WebDriver does not distinguish between windows and tabs. It handles both using window handles. Whenever a window is opened, it contains a distinct ID that returns a string value, making it unique and persisting for the entire session.\n\nUsing the Window Popup Modal Demo page from the LambdaTest Selenium Playground website, we can see the IDs of the main browser window and the child window, as shown below.\n\nHow to handle multiple windows in Selenium Python?\n\nWe can handle the occurrence of child windows or tabs when running test cases using Selenium Python. When a parent window opens a child window, the WebDriver only controls one window at a time in the running session.\n\nThe WebDriver controls the main window, and any actions in a test script will be executed in the currently active window.\n\nThe Selenium Python WebDriver provides the following methods to handle multiple windows.\n\nThis method collects the unique window handle ID of the browser window that is currently active.\n\nThis method returns the IDs of all the windows that have been opened by the WebDriver in the current session. It stores the window IDs to be used for switching windows.\n\nThis method switches the WebDriver’s focus from the currently open browser window to the intended browser window. The targeted window’s id is passed as the argument to shift the WebDriver’s control to the new window.\n\n\n\n Now, let’s deep dive into it with a practical demonstration on how to handle multiple windows in Selenium Python.\n\nDemonstration: How to handle multiple windows in Selenium Python?\n\nNow that we have looked at the different methods available in Selenium Python to handle multiple windows, this section on how to handle multiple windows in Selenium Python looks at how to execute these Selenium tests on a cloud Selenium Grid.\n\nThe best approach to fully utilizing Python automation testing and achieving the intended results quickly is to use a cloud-based Selenium Grid. We can automate multiple window handling in Selenium Python using a cloud-based Selenium Grid platform like LambdaTest.\n\nLambdaTest enables you to perform automated cross browser testing at scale using a Selenium IDE cloud. The platform offers an online browser farm of 3000+ real web browsers running on various operating systems to ensure that enterprises develop more high-quality software applications faster.\n\nYou can also Subscribe to the LambdaTest YouTube Channel and stay updated with the latest tutorials around automated browser testing, Selenium testing, Cypress E2E testing, CI/CD, and more.\n\nTo get started writing tests for Python web automation, we need to have Python and Selenium installed on the client machine. If you are unfamiliar with Selenium using Python, you can check out this detailed blog on getting started with Selenium Python.\n\nThere are many different Python testing frameworks available for Selenium testing, including PyUnit (unittest), pytest, Behave, Robot, Lettuce, Nose2, and Testify. You can learn more about these Selenium Python testing frameworks in detail in this blog post on the best Python testing frameworks.\n\nIn this blog on how to handle multiple windows in Selenium Python, however, we will use the pytest testing framework. Pytest is an open-source Python web automation framework mainly used for unit testing and is scalable by supporting automation tests for functions, APIs, and unit tests.\n\nThis detailed Selenium pytest tutorial can teach you more about how to configure and begin using the pytest Framework to perform automated tests in Selenium Python.\n\nWe use VS Code(Visual Studio ) IDE to write and run the Selenium Python automation scripts for our test case project. Apart from VS Code, there are other IDEs available such as Atom, PyCharm, and Sublime Text that can be used to write the test scripts as well.\n\nThe package manager we use is PIP, the default package manager for Python. It comes preinstalled when you install Python (version 3.4 and above). Pip allows you to install and manage additional packages that aren’t included in the Python standard library. These packages are built specially to be used for different development frameworks, utilities, and modules.\n\nThe test case project’s demonstration will be run on a Windows operating system. In addition, steps on how to set up the project on a macOS have also been included.\n• To use Pip to manage our project’s dependencies, let us first look at the version currently available in the command-line terminals\n• Create a directory that will hold the test project.\n• Move into the project folder you have just created.\n• Create a virtual environment (venv) that will hold the specific dependencies used by the test project. The creation of a venv is crucial because we do not want to combine the global dependencies provided by Python with the particular libraries we need to run the project’s test cases. We install the virtual environment library on Windows to help create the venv using the following command.\n• Run the below-mentioned command on the terminal to activate the virtual environment.\n• Activate the virtual environment so we can install the required libraries to run our test project.\n• We install the following library dependencies in our test project’s venv to run the Selenium Python tests:\n\nThe autopep8 library enforces the PEP 8 style manual on the Python code to ensure it is in the correct format, while flake8 is a library that tests the Python code for errors that are against the PEP 8 style guide.\n\nThe pytest-xdist plugin is an extension of pytest that introduces a new test execution mode that enables us to perform parallel Selenium Python tests.\n• To install the dependencies described above, write the command below in the terminal as follows.\n• Create a “requirements.txt” file that contains all the installed project dependencies in the root folder.\n\nLet’s create a folder called “seltests” in the project’s root directory to house the test scripts.\n\nBefore running the tests, please set the environment variables LT_USERNAME & LT_ACCESS_KEY from the terminal. The account details are available on the LambdaTest Profile page.\n\n\n\n In the next sections of this blog on how to handle multiple windows in Selenium Python, we will look into the following use cases while handling windows in Selenium Python:\n• Switching back to a parent window from a child window in Selenium Python\n\nLet us look at how to implement window handling on a single child window in the following test case scenario.\n• In the new webpage, click on the “Follow on Twitter” button to open a child window.\n• Print the window handle id of the child window.\n\nTo run the test scripts, type the following command in the terminal.\n\nOnce the test is executed, the output in the terminal will display the GUIDS of the parent and child windows, as shown below.\n\nAfter the test execution is completed, you can view the results and logs in the Build section of the LambdaTest Automation Dashboard.\n\nYou can view a test recording and logs of the tests executed.\n\nNow, let us go through the code we have written in detail.\n\nStep 1: Here, we import the important Selenium Python libraries that will enable us to perform our test. These include pytest, WebDriver, By, BrowserOptions, WebDriverWait, and expected_conditions.\n\nWe import pytest, as it is Selenium Python’s primary unit testing tool. The imported Selenium WebDriver is a web framework that automates cross browser tests.\n\nThe By query is used to locate specific web elements using the find_element() method. The explicit wait time implements the WebDriverWait class combined with the expected_conditions class to define the wait for a certain condition to be executed before proceeding to the next part of the code.\n\nLastly, the Options class customizes the specified browser driver sessions. For this instance, we are using the ChromeOptions classes.\n\nStep 2: We generate options using the LambdaTest Automation Capabilities Generator according to the browser we use to run the automated tests. We create an instance of the Options class, set the conditions, and pass it to the driver constructor.\n\nStep 3: We set the username and accesskey provided in the LambdaTest Profile page to a remote_url variable that connects us to the Remote Selenium Grid (@hub.lambdatest.com/wd/hub). We then use the remote_url and options to instantiate the corresponding web browser (Chrome).\n\nStep 4: We open the LambdaTest Playground website, then maximize the browser window to locate the web element with the link to the Window Popup Demo Page.\n\nRight-click the “Windows Popup Modal” link and click inspect to open the browser inspect tool. The web element is located using its href tag.\n\nWe use the driver. current_window_handle method to obtain the parent window’s unique id and store it as a string.\n\nStep 5: We then locate the web element with the button “Follow on Twitter” using its title and click on it to open a child window.\n\nWe store the window handles of the opened windows in a variable called all_guid.\n\nStep 6: We then switch to the child window using the driver.switch_to.window(guid) method. The code iterates through the stored window handles, and if it comes across the parent window handle, it skips over it and switches to the child window. Then the child window’s ID is printed.\n\nThe driver.close() method closes the currently active child window and will quit the driver session if the child window is the only active window.\n\nWe then close the browser session using the driverquit() method in Selenium.\n\nIn the above section of this blog on how to handle multiple windows in Selenium Python, we have looked at how to handle a single child window in Selenium using Python. Let us go through how to implement window handling of multiple child windows in the scenarios below.\n• In the new webpage, click on the “Follow Twitter & Facebook” button to open the child windows.\n• Switch to each open child window using the page titles.\n• Print the page title of each of the child windows.\n\nWe execute the test scripts in the terminal using the following command.\n\nThe test runs successfully in the terminal and displays the following output, as shown below.\n\nWe can view the test script’s results in the LambdaTest Builds section.\n\nThe test’s logs and recordings are also displayed.\n\nThe code written for implementing multiple child window handling in Selenium using Python is similar to that written for handling a single child window. Nonetheless, the difference comes when iterating through the window handles, as we show the distinction between the child windows based on their respective page titles.\n\nIn the “Window Popup Modal” page, we locate the “Follow Twitter & Facebook” button using its ID in the inspect tool. We click the button, which will then open up two child windows.\n\nThe window handles of the currently open windows are stored in a variable called all_guid, and the total number of open windows is captured in the variable num_of_handles.\n\nThe code iterates through all the window handles stored, identifies the child window handles, and switches to the child windows. The code checks the page title of the child window and prints it. The child windows are then closed using the driver.close() method.\n\nThe driver session is then finally closed using the quit() method.\n\nSwitching back to a parent window from a child window in Selenium Python\n\nLet us look at a scenario where we want to switch back to the parent window from the child window after we have completed some operations. This means we must change the WebDriver’s control to the main window.\n\nWe will implement the scenario discussed in the above section of this blog on how to handle multiple windows in Selenium Python to demonstrate switching back to the parent window.\n\nWe run the test script in the terminal using the following command.\n\nThe test script will execute successfully in the terminal and display the following output.\n\nWe can view the test results in the LambdaTest Builds dashboard.\n\nIn the test script, after navigating through the child windows and performing the operations we specified in the scenario before, the open child windows are closed. We then switch back to the parent window using the switch_to.window(parent_guid) method with the parent_guid variable as the method’s argument. We then print the parent window’s handle.\n\nThe driver session is finally closed using the driver.quit() method.\n\nIf you are a Python programmer looking to take your career to the next level, you can go with the Selenium Python 101 certification from LambdaTest.\n\nIn this Selenium Python tutorial, we have covered in detail what windows are and how to handle multiple windows when they occur in testing using Selenium Python. We have looked at the two types of windows—the parent window and the child window. We have written test scripts that implement window handling for a single child window and multiple child windows. We have also looked at how to switch back to the parent window after completing operations on the child windows.Also, the visual testing tool Selenium can help you to find elusive bugs in the webpage.\n\nI hope this blog on how to handle multiple windows in Selenium Python will help you while performing test automation."
    },
    {
        "link": "https://groups.google.com/g/chromedriver-users/c/mGHarEzvaAg",
        "document": "Either email addresses are anonymous for this group or you need the view member email addresses permission to view the original message\n\nYou do not have permission to delete messages in this group\n\nMy company uses Selenium for automated testing and currently, our tests take 3-4 hours to run. Chrome is the fastest browser, but even so, it takes hours.\n\nWe are trying to run multiple instances of Chrome on the SAME machine so we can divide the tests into groups to run simultaneously. For example:\n\n150 tests total\n\nStart chrome1 running first 50\n\nStart chrome2 running next 50\n\nStart chrome3 running last 50\n\nAll browsers running at the same time.\n\nI create two instances of ChromeDriver. Each ChromeDriver starts a single instance of Chrome in a UNIQUE profile. The first Chrome window starts up and begins running tests just fine.\n\nThe second window appears but does nothing. Examination of verbose logging shows the second window is unable to connect to the DevTools of the second browser.\n\nI know running multiple instances simultaneously was possible in prior versions of Chrome (I believe 29 was the last one that people had luck with.) Due to IT constraints, it will be difficult to run multiple VMs on a machine and using Selenium Grid.\n\nWe MUST run multiple instances on a single machine but nothing we've tried has worked.\n\nIs this even still possible? If not, is there any way to get Chrome 29 offline installer so we can run the previous version and see if that works?"
    }
]