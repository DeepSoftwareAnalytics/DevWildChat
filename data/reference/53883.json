[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.io.path?view=net-9.0",
        "document": "The following example demonstrates some of the main members of the class.\n\nA path is a string that provides the location of a file or directory. A path does not necessarily point to a location on disk; for example, a path might map to a location in memory or on a device. The exact format of a path is determined by the current platform. For example, on some systems, a path can start with a drive or volume letter, while this element is not present in other systems. On some systems, file paths can contain extensions, which indicate the type of information stored in the file. The format of a file name extension is platform-dependent; for example, some systems limit extensions to three characters (such as FAT16 commonly used on smaller flash storage and older versions of ISO 9660 used on optical media), and others do not. The current platform also determines the set of characters used to separate the elements of a path, and the set of characters that cannot be used when specifying paths. Because of these differences, the fields of the class as well as the exact behavior of some members of the class are platform-dependent.\n\nA path can contain absolute or relative location information. Absolute paths fully specify a location: the file or directory can be uniquely identified regardless of the current location. Relative paths specify a partial location: the current location is used as the starting point when locating a file specified with a relative path. To determine the current directory, call Directory.GetCurrentDirectory.\n\n.NET Core 1.1 and later versions and .NET Framework 4.6.2 and later versions also support access to file system objects that are device names, such as \"\\\\?\\C:\\\".\n\nFor more information on file path formats on Windows, see File path formats on Windows systems.\n\nMost members of the class do not interact with the file system and do not verify the existence of the file specified by a path string. class members that modify a path string, such as ChangeExtension, have no effect on names of files in the file system.\n\nSome members do validate the contents of a specified path string, and throw an ArgumentException if the string contains characters that are not valid in path strings, as defined in the characters returned from the GetInvalidPathChars method. For example, on Windows-based desktop platforms, invalid path characters might include quote (\"), less than (<), greater than (>), pipe (|), backspace (\\b), null (\\0), and Unicode characters 16 through 18 and 20 through 25. This validation behavior varies between .NET versions:\n• None On .NET Framework and .NET Core versions older than 2.1: All members that take a path as an argument throw an ArgumentException if they detect invalid path characters.\n• None On .NET Core 2.1 and later versions: GetFullPath is the only member that throws an ArgumentException if the string contains invalid path characters.\n\nThe members of the class enable you to quickly and easily perform common operations such as determining whether a file name extension is part of a path, and combining two strings into one path name.\n\nAll members of the class are static and can therefore be called without having an instance of a path.\n\nIn members that accept a path, the path can refer to a file or just a directory. The specified path can also refer to a relative path or a Universal Naming Convention (UNC) path for a server and share name. For example, all the following are acceptable paths:\n• None \"c:\\\\MyDir\\\\MyFile.txt\" in C#, or \"c:\\MyDir\\MyFile.txt\" in Visual Basic.\n• None \"c:\\\\MyDir\" in C#, or \"c:\\MyDir\" in Visual Basic.\n• None \"MyDir\\\\MySubdir\" in C#, or \"MyDir\\MySubDir\" in Visual Basic.\n• None \"\\\\\\\\MyServer\\\\MyShare\" in C#, or \"\\\\MyServer\\MyShare\" in Visual Basic.\n\nBecause all these operations are performed on strings, it is impossible to verify that the results are valid in all scenarios. For example, the GetExtension method parses a string that you pass to it and returns the extension from that string. However, this does not mean that a file with that extension exists on the disk.\n\nFor a list of common I/O tasks, see Common I/O Tasks.\n• How to: Read Text from a File\n• How to: Write Text to a File\n• How to: Read and Write to a Newly Created Data File"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/io/file-path-formats",
        "document": "Members of many of the types in the System.IO namespace include a parameter that lets you specify an absolute or relative path to a file system resource. This path is then passed to Windows file system APIs. This topic discusses the formats for file paths that you can use on Windows systems.\n\nA standard DOS path can consist of three components:\n• A volume or drive letter followed by the volume separator ( ).\n• A directory name. The directory separator character separates subdirectories within the nested directory hierarchy.\n• An optional filename. The directory separator character separates the file path and the filename.\n\nIf all three components are present, the path is absolute. If no volume or drive letter is specified and the directory name begins with the directory separator character, the path is relative from the root of the current drive. Otherwise, the path is relative to the current directory. The following table shows some possible directory and file paths.\n\nYou can determine whether a file path is fully qualified (that is, if the path is independent of the current directory and does not change when the current directory changes) by calling the Path.IsPathFullyQualified method. Note that such a path can include relative directory segments ( and ) and still be fully qualified if the resolved path always points to the same location.\n\nThe following example illustrates the difference between absolute and relative paths. It assumes that the directory exists, and that you haven't set any current directory for from the command prompt before running the example.\n\nUniversal naming convention (UNC) paths, which are used to access network resources, have the following format:\n• A server or host name, which is prefaced by . The server name can be a NetBIOS machine name or an IP/FQDN address (IPv4 as well as v6 are supported).\n• A share name, which is separated from the host name by . Together, the server and share name make up the volume.\n• A directory name. The directory separator character separates subdirectories within the nested directory hierarchy.\n• An optional filename. The directory separator character separates the file path and the filename.\n\nThe following are some examples of UNC paths:\n\nUNC paths must always be fully qualified. They can include relative directory segments ( and ), but these must be part of a fully qualified path. You can use relative paths only by mapping a UNC path to a drive letter.\n\nThe Windows operating system has a unified object model that points to all resources, including files. These object paths are accessible from the console window and are exposed to the Win32 layer through a special folder of symbolic links that legacy DOS and UNC paths are mapped to. This special folder is accessed via the DOS device path syntax, which is one of:\n\nIn addition to identifying a drive by its drive letter, you can identify a volume by using its volume GUID. This takes the form:\n\nThe DOS device path consists of the following components:\n• None The device path specifier ( or ), which identifies the path as a DOS device path. The is supported in all versions of .NET Core and .NET 5+ and in .NET Framework starting with version 4.6.2.\n• None A symbolic link to the \"real\" device object (C: in the case of a drive name, or Volume{b75e2c83-0000-0000-0000-602f00000000} in the case of a volume GUID). The first segment of the DOS device path after the device path specifier identifies the volume or drive. (For example, and .) There is a specific link for UNCs that is called, not surprisingly, . For example: For device UNCs, the server/share portion forms the volume. For example, in , the server/share portion is . This is significant when calling a method such as Path.GetFullPath(String, String) with relative directory segments; it is never possible to navigate past the volume.\n\nDOS device paths are fully qualified by definition and cannot begin with a relative directory segment ( or ). Current directories never enter into their usage.\n\nExample: Ways to refer to the same file\n\nThe following example illustrates some of the ways in which you can refer to a file when using the APIs in the System.IO namespace. The example instantiates a FileInfo object and uses its Name and Length properties to display the filename and the length of the file.\n\nAlmost all paths passed to Windows APIs are normalized. During normalization, Windows performs the following steps:\n• Evaluates relative directory components ( for the current directory and for the parent directory).\n\nThis normalization happens implicitly, but you can do it explicitly by calling the Path.GetFullPath method, which wraps a call to the GetFullPathName() function. You can also call the Windows GetFullPathName() function directly using P/Invoke.\n\nThe first step in path normalization is identifying the type of path. Paths fall into one of a few categories:\n• They are device paths; that is, they begin with two separators and a question mark or period ( or ).\n• They are UNC paths; that is, they begin with two separators without a question mark or period.\n• They are fully qualified DOS paths; that is, they begin with a drive letter, a volume separator, and a component separator ( ).\n• They are relative to the root of the current drive; that is, they begin with a single component separator ( ).\n• They are relative to the current directory of a specified drive; that is, they begin with a drive letter, a volume separator, and no component separator ( ).\n• They are relative to the current directory; that is, they begin with anything else ( ).\n\nThe type of the path determines whether or not a current directory is applied in some way. It also determines what the \"root\" of the path is.\n\nIf the path is a legacy DOS device such as , , or , it is converted into a device path by prepending and returned.\n\nPrior to Windows 11, a path that begins with a legacy device name is always interpreted as a legacy device by the Path.GetFullPath(String) method. For example, the DOS device path for is , and the DOS device path for is . Because this no longer applies with Windows 11, specify the full path to the legacy DOS device, such as .\n\nIf a path isn't fully qualified, Windows applies the current directory to it. UNCs and device paths do not have the current directory applied. Neither does a full drive with separator .\n\nIf the path starts with a single component separator, the drive from the current directory is applied. For example, if the file path is and the current directory is , normalization produces .\n\nIf the path starts with a drive letter, volume separator, and no component separator, the last current directory set from the command shell for the specified drive is applied. If the last current directory was not set, the drive alone is applied. For example, if the file path is , the current directory is , and the last current directory on drive D: was , the result is . These \"drive relative\" paths are a common source of program and script logic errors. Assuming that a path beginning with a letter and a colon isn't relative is obviously not correct.\n\nIf the path starts with something other than a separator, the current drive and current directory are applied. For example, if the path is and the current directory is , the result is .\n\nAll forward slashes ( ) are converted into the standard Windows separator, the back slash ( ). If they are present, a series of slashes that follow the first two slashes are collapsed into a single slash.\n\nAs the path is processed, any components or segments that are composed of a single or a double period ( or ) are evaluated:\n• None For a single period, the current segment is removed, since it refers to the current directory.\n• None For a double period, the current segment and the parent segment are removed, since the double period refers to the parent directory. Parent directories are only removed if they aren't past the root of the path. The root of the path depends on the type of path. It is the drive ( ) for DOS paths, the server/share for UNCs ( ), and the device path prefix for device paths ( or ).\n\nAlong with the runs of separators and relative segments removed earlier, some additional characters are removed during normalization:\n• None If a segment ends in a single period, that period is removed. (A segment of a single or double period is normalized in the previous step. A segment of three or more periods is not normalized and is actually a valid file/directory name.)\n• None If the path doesn't end in a separator, all trailing periods and spaces (U+0020) are removed. If the last segment is simply a single or double period, it falls under the relative components rule above. This rule means that you can create a directory name with a trailing space by adding a trailing separator after the space. You should never create a directory or filename with a trailing space. Trailing spaces can make it difficult or impossible to access a directory, and applications commonly fail when attempting to handle directories or files whose names include trailing spaces.\n\nNormally, any path passed to a Windows API is (effectively) passed to the GetFullPathName function and normalized. There is one important exception: a device path that begins with a question mark instead of a period. Unless the path starts exactly with (note the use of the canonical backslash), it is normalized.\n\nWhy would you want to skip normalization? There are three major reasons:\n• None To get access to paths that are normally unavailable but are legal. A file or directory called , for example, is impossible to access in any other way.\n• None To improve performance by skipping normalization if you've already normalized.\n• None On .NET Framework only, to skip the check for path length to allow for paths that are greater than 259 characters. Most APIs allow this, with some exceptions.\n\nSkipping normalization and max path checks is the only difference between the two device path syntaxes; they are otherwise identical. Be careful with skipping normalization, since you can easily create paths that are difficult for \"normal\" applications to deal with.\n\nPaths that start with are still normalized if you explicitly pass them to the GetFullPathName function.\n\nYou can pass paths of more than characters to GetFullPathName without . It supports arbitrary length paths up to the maximum string size that Windows can handle.\n\nA peculiarity of the Windows file system that non-Windows users and developers find confusing is that path and directory names are case-insensitive. That is, directory and file names reflect the casing of the strings used when they are created. For example, the method call\n\ncreates a directory named TeStDiReCtOrY. If you rename a directory or file to change its case, the directory or file name reflects the case of the string used when you rename it. For example, the following code renames a file named test.txt to Test.txt:\n\nHowever, directory and file name comparisons are case-insensitive. If you search for a file named \"test.txt\", .NET file system APIs ignore case in the comparison. \"Test.txt\", \"TEST.TXT\", \"test.TXT\", and any other combination of uppercase and lowercase letters will match \"test.txt\"."
    },
    {
        "link": "https://stackoverflow.com/questions/13175868/how-to-get-full-file-path-from-file-name",
        "document": "Prepend this dirpath to the filename to get the complete path.\n\nAs @Dan Puzey indicated in the comments, it would be better to use Path.Combine"
    },
    {
        "link": "https://geeksforgeeks.org/how-to-extract-filename-from-a-given-path-in-c-sharp",
        "document": "How to Extract filename from a given path in C#\n\nWhile developing an application that can be desktop or web in C#, such kind of requirement to extract the filename from a given path (where the path can be taken while selecting a file using File Open dialog box or any other sources) can arise. A path may contain the drive name, directory name(s) and the filename. To extract filename from the file, we use “GetFileName()” method of “Path” class. This method is used to get the file name and extension of the specified path string. The returned value is null if the file path is null.\n\nSyntax: public static string GetFileName (string path);\n\n Here, path is the string from which we have to obtain the file name and extension. Return Value: This method will return the characters after the last directory separator character in path. If the last character of the path is a directory or volume separator character, this method returns Empty. If the path is null, this method returns null.\n\nException: This method will give ArgumentException if the path contains one or more of the invalid characters defined in GetInvalidPathChars()."
    },
    {
        "link": "https://stackoverflow.com/questions/1048129/what-is-the-best-way-to-combine-a-path-and-a-filename-in-c-net",
        "document": "What is the best way to combine a path with a filename?\n\nThat is, given and , I want .\n\nGiven and , I want either an error or (so I cannot use directly). Similarly for and , I want an error or (not ).\n\nI realize, I could check that the filename does not contain '\\' or '/', but is that enough? If not, what is the correct check?"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.io.path.getfilenamewithoutextension?view=net-9.0",
        "document": "The string returned by GetFileName(ReadOnlySpan<Char>), minus the last period (.) and all characters following it.\n\nThe following example demonstrates a use of the method.\n\nThis method does not verify that the path or file name exists.\n\nFor a list of common I/O tasks, see Common I/O Tasks.\n• How to: Read Text from a File\n• How to: Write Text to a File"
    },
    {
        "link": "https://stackoverflow.com/questions/68813665/use-path-getfilenamewithoutextension-method-in-c-sharp-to-get-the-file-name-but",
        "document": "I just wonder why would you want such behavior. On windows slashes are treated as separator between directory and subdirectory (or file).\n\nSo, basically you are not able to create such file name.\n\nAnd since slashes are treated as described, it is very natural that method implementation just checks what's after last slash and extracts just filename.\n\nIf you are interested on how the method is implemented take a look at source code"
    },
    {
        "link": "https://stackoverflow.com/questions/1886866/how-to-find-the-extension-of-a-file-in-c",
        "document": "In my web application (asp.net,c#) I am uploading video file in a page but I want to upload only flv videos. How can I restrict when I upload other extension videos?\n\nYou may simply read the stream of a file First 5/6 indexes will tell you the file type. In case of FLV its 70, 76, 86, 1, 5. if equals then its FLV. First two/three letters will tell you the file type.\n\n In case of FLV its \"FLV......\"\n\nAt the server you can check the MIME type, lookup flv mime type here or on google. You should be checking that the mime type is If you were using a FileUpload in C# for instance, you could do\n\nIn addition, if you have a , you can simply do: and it'll hold the extension of the file (note: it will include the , so a result of the above could be: , and so on....\n\nThe above method works fine with the Firefox and IE: I am able to view all types of files like zip,txt,xls,xlsx,doc,docx,jpg,png. But when I try to find the extension of file from Google Chrome, I fail.\n\nFound an alternate solution over at DotNetPerls that I liked better because it doesn't require you to specify a path. Here's an example where I populated an array with the help of a custom method // This custom method takes a path // and adds all files and folder names to the 'files' array string[] files = Utilities.FileList(\"C:\\\", \"\"); // Then for each array item... foreach (string f in files) { // Here is the important line I used to ommit .DLL files: if (!f.EndsWith(\".dll\", StringComparison.Ordinal)) // then populated a listBox with the array contents myListBox.Items.Add(f); }\n\nYou will not be able to restrict the file type that the user uploads at the client side[*]. You'll only be able to do this at the server side. If a user uploads an incorrect file you will only be able to recognise that once the file is uploaded uploaded. There is no reliable and safe way to stop a user uploading whatever file format they want. [*] yes, you can do all kinds of clever stuff to detect the file extension before starting the upload, but don't rely on it. Someone will get around it and upload whatever they like sooner or later.\n\nwill get you the file name Im also sharing a test code if someone needs to test and ge the extention or name. Forming a text file with name test.txt and checking its extention in xUnit. [Fact] public void WrongFileExtention_returnError() { //Arrange string expectedExtention = \".csv\"; var content = \"Country,Quantity\n\nUnited Kingdom,1\"; var fileName = \"test.csv\"; var stream = new MemoryStream(); var writer = new StreamWriter(stream); writer.Write(content); writer.Flush(); stream.Position = 0; //Act IFormFile file = new FormFile(stream, 0, stream.Length, \"\", fileName); //Assert Assert.Equal(expectedExtention, Path.GetExtension(file.FileName)); } Return true as the expected and the filename extention is name."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.io.path.getextension?view=net-9.0",
        "document": "The extension of the specified path (including the period \".\"), or , or Empty. If is , GetExtension(String) returns . If does not have extension information, GetExtension(String) returns Empty.\n\n.NET Framework and .NET Core versions older than 2.1: contains one or more of the invalid characters defined in GetInvalidPathChars().\n\nThe following example demonstrates using the method on a Windows-based desktop platform.\n\nThis method obtains the extension of by searching for a period (.), starting with the last character in and continuing toward the first character. If a period is found before a DirectorySeparatorChar or AltDirectorySeparatorChar character, the returned string contains the period and the characters after it; otherwise, String.Empty is returned.\n\nFor a list of common I/O tasks, see Common I/O Tasks.\n• How to: Read Text from a File\n• How to: Write Text to a File"
    },
    {
        "link": "https://developer.bennysutton.com/blog/1850-c-remove-extension-from-filename",
        "document": "You can remove the extension from a filename in C# using several methods. Here are a couple of common approaches:\n\nYou can use the Path.GetFileNameWithoutExtension method from the System.IO namespace to get the filename without the extension.\n\nYou can also achieve this using string manipulation, extracting the substring before the last dot (.) occurrence.\n\nBoth methods will give you the filename without the extension. Choose the one that best suits your needs and coding style."
    }
]