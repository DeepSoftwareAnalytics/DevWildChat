[
    {
        "link": "https://edw.is/using-lua-with-cpp",
        "document": "\n• How to implement action sequences and cutscenes in Lua\n• Making and storing references to game objects (entities) in C++ and Lua\n\nI’ve written many articles about using Lua with C++ on my old blog many years ago. I also worked on a fork of LuaJIT professionally and described my experiences here - this experience made me learn a lot about LuaJIT and how vanilla Lua works (and how it can be used in production for servers with a very high QPS).\n\nThis is not a tutorial or step-by-step guide. It’s a road map for learning Lua and my advice for how to integrate it with C/C++ code.\n• It’s simple. The simplest language I know. It doesn’t have many “gotchas”. Writing the code in it feels like writing pseudocode/prototyping.\n• It’s easy to integrate Lua scripts into C/C++ projects. You just compile a bunch of C files, link with the library and you’re ready to go - you don’t need to rewrite half of your program/game or make your build script 10 times more difficult.\n• It’s stable. New versions come out once in a while, but you can comfortably stay on Lua 5.2 not loose much. Many 3rd party Lua libraries usually work with Lua 5.2/5.3/5.4.\n• It’s fast. You’re unlikely to run into performance issues, unless you’re making a AA/AAA game or a complex simulation program.\n• Even if you do, with LuaJIT you’ll be able to achieve C/C++ level performance.\n• Lua doesn’t impose one style of writing code on you. You can do procedural, functional, OO programming.\n• You can even create small domain specific languages thanks to Lua’s syntax sugar.\n• You don’t need to compile Lua code, which means that you can change parts of your program/game logic without recompiling and even without reloading your program.\n• If you’re writing a game and want to make it possible for people to create mods, many of your players are likely to know Lua thanks to such games as Minecraft, Factorio, Garry’s Mod, World of Warcraft, Roblox and many others.\n• The same can be said about making your program expandable with plugins. E.g. NeoVim, which uses Lua scripts for user script code.\n• Sandboxing is easy. You choose what Lua code can and can’t do. You can easily create a Lua state which won’t have any functions from the standard library (I/O, coroutines, tables etc.)\n• You don’t need a specialized IDE or tools to write Lua comfortably. If you need a debugger, I recommend checking out ZenoBrane Studio.\n\nTo learn Lua, read “Programming in Lua” by Roberto Ierusalimschy.\n\nYou can find Lua’s reference manual here.\n\nThat’s basically all you’ll ever need to know about Lua.\n\nDownload the official Lua source code here: https://www.lua.org/download.html.\n\nLua is written in ANSI C, so it can compile almost everywhere. It has a GNU Make build, so building it is easy.\n\nIntegrating it with CMake is somewhat trickier. I’ve used LuaDist’s CMake build scripts for Lua for many years, but LuaDist authors have stopped supporting newer Lua versions. It’s a good starting point for making your own CMake build for Lua, though (or if you use older versions of Lua, they work well).\n\nSee a simple example of how to build Lua with CMake and use it with sol2 here.\n• LuaJIT if you need maximum performance.\n\nWhich binding to use?\n\nIf you only want to call some C/C++ functions from Lua (or some small Lua functions from C/C++) - use Lua C API. It’s minimalistic, but requires a lot of boilerplate and manual error-checking.\n\nYou can learn about how to use Lua C API here (or in the latest version of “Programming in Lua”) - the online version is written for Lua 5.1 and some things have changed since 5.1, but most concepts have stayed the same.\n\nThe reference manual for Lua 5.4’s C API is here: https://www.lua.org/manual/5.4/manual.html#4\n\nOption B. sol2 (C++ only, requires a compiler which supports C++17)\n\nsol2 is a fantastic library which I’ve used for many years. It can do everything you’d ever want from Lua and even more. The docs are fantastic too.\n• The fastest and the most feature-complete Lua/C++ binding library.\n• Easy to start using, the interface is user friendly and feels similar to C++ standard library.\n• Can do a lot of “automagic” and save you from writing tons of boilerplate code, which you need to do if you use other bindings or Lua C API.\n• It uses heavy meta-programming to get things done.\n• This can result in slow compilation times, unreadable error messages and some interfaces are not that friendly (e.g. it’s hard to know if what you’re passing to Lua will be copied or passed by a reference).\n• Not safe by default, you need to use versions of functions/objects to not crash constantly.\n\nEnrique García Cota has a lot of great articles about Lua: http://kiki.to/\n\nHe has also implemented a number of incredible little libraries which I’ve used in my projects:\n\nMany other great libraries can be found via LuaRocks: https://luarocks.org/\n\nYou might also find Moonscript interesting. itch.io was written with it and it compiles to vanilla Lua. It’s neat.\n\nWhere to see Lua in practice?\n• Check out this engine for making Zelda-likes for inspiration of how to write game code in Lua: https://www.solarus-games.org/.\n• Minetest (a Minecraft-like game) has a great API and a lot of docs.\n• I also found Don’t Starve Lua scripts/code inspiring (purchase the game, go to game dir, they’re in plain text!).\n\nAnd finally, see what LÖVE and PICO-8 do. They’re mostly written in C/C++ and only expose a bunch of Lua functions/tables to the user.\n\nYou can write entire games in Lua without ever touching C/C++. Isn’t it great?\n• Most of the time, you only need one Lua state ( in Lua C API and in sol2) for everything.\n• Think of Lua scripts as functions - you can call them with or and they can return variables.\n• Don’t put too much code into one script - it’s easy to separate everything into smaller scripts.\n• After your basic game engine is implemented, start with writing new code in Lua. Then, see if you really need to move this code (or parts of it) to C++.\n• If you think that your game became “slow” because of Lua code, profile first before rewriting it in C++. Gut feeling is usually wrong.\n• Your life will be easier if you have a small C/C++ API. The less data is shared between C++ and Lua, the better.\n• What to write in C++: collision detection, path finding, physics, renderer and other things that are performance critical.\n• What to write in Lua: gameplay logic, FSMs, cutscenes, etc. - basically everything else that doesn’t interact with low-level OS APIs much.\n\nAnd now, for more detailed advice…\n\n1. Avoid creating C++ objects in Lua if they’re not PODs (simple structs)\n\nDealing with C++ objects in Lua is much harder than dealing with “native” types.\n\n2. Avoid passing Lua tables to C++ functions and returning tables from C++ functions\n\nIt’s much easier to test if something is non-nil or has a specific type/fields in Lua than in C++. So it’s better to do it on Lua side, unless you make a C++ API which has to accept tables for ease-of-use - then you don’t have much choice (but you can still wrap them into Lua functions and call C++ function internally).\n\n3. If you’re calling functions too often, maybe it’s time to reconsider your API design\n\nFor example (C++ functions have “cpp” postfix):\n\nAsk yourself: do all these functions need to be in C++? Can they be rewritten in Lua, perhaps? This will make your life easier, because you would be able to write less “binding” code and be able to stay “inside” Lua code as much as possible.\n\n4. Avoid calling Lua from C++ too often\n\nThis code is OK (calling C++ from Lua is cheap):\n\nThis code is not that good (calling Lua from C++ is slow):\n\nProfile first. If you notice that your C++ function has a huge overhead because of Lua calls, consider using this pattern:\n\nIf you don’t use “local” to define/init a variable, it becomes a global by default. It stays global and doesn’t get collected by a GC until it has been set to .\n\nKeep your global state to a minimum and variable scope as small as possible. Don’t forget that you can do this:\n\nNow, when you load/execute this script, you will only get one function as the result:\n\nAll the internal script state will be hidden and non-modifable and won’t overwrite any global state in your current Lua state, which is great.\n\nSimilarly to the previous advice, when defining classes (e.g. via middleclass library), don’t do it like this:\n\nDo it like this instead:\n\nand then, when you want to create an instance of this class, you do this:\n\nWhy do it like this? Because it makes it much easier to track dependencies between various script files and makes them load each other when they’re needed. If you used classes as “globals” (which I’ve seen in many tutorials and real code), you might have a script like this:\n\nSuppose that you didn’t execute first (which defines a global ). Then, executing would resullt in an error: is nil. This makes dependencies between files hard to track and require you to manually execute before you can execute .\n\nHowever, in the example where is returned as a local variable, you won’t need to do this - if you just load the , it would execute when you call (it would only do this if another script didn’t call it, otherwise it would return a “cached” variable).\n\n7. Don’t rely on “external” scripts too much in initialization/“base” code\n\nFor example, suppose that you have C++ code like this:\n\nYour engine will crash on startup if is not found when your game starts (or contains errors). Of course, you can check for this file’s existence and handle errors appropriately (e.g. by displaying a message box/writing to a log), but if your is not meant to be modified externally, maybe you can do it like this?\n\nMuch better! Now you don’t need to ship this “init.lua” with your binary and life becomes easier.\n\nWriting code like this will become better with new directive in future C/C++ versions, e.g.:\n\n8. Be careful when storing references to Lua objects on the C++ side (e.g. via sol::object)\n\nOverusing them makes code harder to understand because now you need to make sure that the object you’re are pointing to doesn’t change unexpectedly.\n\nAnd be especially careful when using coroutines. If you create a local object inside the coroutine and store the reference to it in C++. In short, if your coroutine gets GC’ed and you hold the reference to this local variable as a on the C++ side, it won’t prevent the variable from getting GC’ed by Lua and your program crashing because of that.\n\nSee the explanation on how to do concurrency in Lua in sol2 here (especially about and ).\n\nBasically, you need to tell Lua explicitly that something you’ve created in the coroutine needs to outlive this coroutine (and this is done with ).\n\nYou can easily print table contents with it:\n\nFor example, I’d recommend to avoid SDL/glfw/SFML bindings and writing them manually for the stuff you need. The problem with 3rd party bindings is that they usually tend to get unmaintained or only support a specific version of the library. With your own bindings, you can control what version you use and how the exposed API looks in Lua.\n\nAnd you can do even better, you can hide library details and not expose them to Lua at all which will make switching between lower-level frameworks much easier, for example:\n\nIf you want to use a C library and you’re using LuaJIT, you don’t even need to create a binding for it at all. You can call it with LuaJIT’s FFI, see the tutorial here."
    },
    {
        "link": "https://reddit.com/r/gamedev/comments/1wckxw/how_do_you_integrate_lua_in_your_games_c",
        "document": "I authored my own set of lua bindings here and it's developed enough that I feel willing to show a bigger audience and also ask how you all integrate Lua in your games.\n\nSpecifically, what features have you used a lot or deem critical. Do you handle the bulk of your logic in Lua or just configuration? Something in between?\n\nWhat interface do you use or do you use the raw API? Anything you wish existing interfaces had that don't currently exist?\n\nThis would help me drum up some ideas on how to proceed. I've been integrating Lua into my own engine but I thought it wouldn't hurt to ping others and see how they go about it."
    },
    {
        "link": "https://github.com/0xc0dec/solo",
        "document": "\"I have no idea how to write game engines\"-style game engine. A playground for my gamedev experiments.\n• Loading of several popular mesh and texture formats, also TTF fonts.\n• Same API for both Lua and C++.\n• Install dependencies:\n• Python2 (Python3 might work, but not tested). Needed for building some engine dependencies.\n• (or other generator depending on the OS/IDE).\n• where is the demo number"
    },
    {
        "link": "https://reddit.com/r/gamedev/comments/q8j8g/c_engine_lua_scripting_help",
        "document": "Just wondering if someone could please explain to me how to use Lua for scripting a game whilst writing the engine in C++ (I'm using SDL). Or are there any better alternatives to Lua?"
    },
    {
        "link": "https://stackoverflow.com/questions/7434267/scripting-languages-and-game-dev-programming",
        "document": "Okay, so I've been getting into 2D game developing/programming , and many games I've seen use some sort of scripting language too. So I'm wondering - What's the purpose of using scripts in games? I know there's not simple one reason answer, and I've been trying to consider all the possibilities. Here's what I 'think' I know so far: 1) Scripts allow for changing the game without having to re-compile. 2) Scripts are easier for non-programmers to use. 3) Scripts allow me to separate the engine from the game itself allowing me to make other games with the same components quicker? That's about all I'm aware of. My next question is, if I'm going to be Dev/programming a game alone - do I really need to use scripts? Or could I prototype the game using something like python or ruby, to allow for rapid testing, then rewrite the code in C++ saving time and compiler bugs, etc? Another thing I'm wondering, Am I better off using Ruby or Python since I'm most experienced with those? Or should I use Lua, Perl or something else if it better fits what I aim to achieve? Speaking on that matter, what really should I use scripts for? should I use them to position and model game menu UI's, write/read save-files, load map levels, hold arrays or structures of game terminology such as \"New Game\" or \"Quit,\" all of the above, none of the above? If I make use of scripts, won't that allow game mechanics to be edited by the end user? Or is there a way to package the scripts into one compressed file that the engine can read? What should I use scripting in my game for? And why? Do I need use scripting languages if I'm working alone or with programmers as opposed to Devs? What scripting language 'should' I use if I were to be making platformers, RPGs, or what-have-you?"
    },
    {
        "link": "https://wiki.libsdl.org/SDL3/APIByCategory",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/cpp_questions/comments/qvj89c/how_to_use_game_states_in_sdl",
        "document": "Create your account and connect with a world of communities.\n\nBy continuing, you agree to our\n\nand acknowledge that you understand the"
    },
    {
        "link": "https://stackoverflow.com/questions/61406043/event-handling-using-sdl-and-c-for-my-hobby-game-engine",
        "document": "If you want end-users to write the functions for handling the events, I would suggest relying on callbacks. The idea is that the end-user will dictate what event handler to call for each event type, whereas the game engine will dictate when to call the corresponding event handler.\n\nThe user is provided with a struct of callbacks so that user code can define custom event handlers and configure these callbacks to refer to these custom functions. Then, the loop for event processing of the game engine calls those functions via the callbacks set up by the user.\n\nYou could define different function types for different events:\n\nThat is, the handler for quitting takes no arguments, whereas those for a key going up and down takes an argument that represents the corresponding key.\n\nThen, you provide the client with a struct, , that contains pointers to the event handlers and the end-user is supposed to populate:\n\nFinally, the game engine's loop for processing the events call those functions through the callbacks that were set up by the user:\n\nNote that the game engine could also initialize the struct with default event handlers. The end-user would be able to override that default behavior by modifying the members of ."
    },
    {
        "link": "https://studyplan.dev/sdl2/sdl2-user-events",
        "document": "Previously, we’ve seen how SDL implements an event queue, which we can interact with using functions like . As standard, SDL will push events onto this queue to report actions like the user moving their mouse ( ) or requesting the application close ( ).\n\nHowever, we can also use SDL’s event system to manage custom events, that are specific to the game we’re making. For example, if we were making a first-person shooter, we could use this system to report when player fires their weapon or reloads.\n\nIn this lesson, we'll learn how to register and use custom events to create these game-specific behaviors.\n\nWe'll also look at how to organise our code around a custom event system, and see practical examples of how custom events can be used to manage game state and handle complex user interactions.\n\nAn can be created like any other object:\n\nIts most useful constructor allows us to specify the type. Below, we create an event with a type of . This is equivalent to what SDL creates internally when the player attempts to close the window from the menu bar, for example:\n\nTo add our event to SDL’s event queue, we pass a pointer to it to . It will then be available to our main application loop, like any other event:\n\nIn real use cases, we’re going to be pushing events from some other part of our application. For example, our UI might be rendering an exit button somewhere, and it is some function in that class that will be creating and pushing the event:\n\nThe previous example may seem suspicious, as we’re providing a pointer to a local variable. ’s memory location will be freed as soon as ends, so it would seem possible that the event we receive in our main loop will be a dangling pointer.\n\nHowever, this is not the case. Behind the scenes, copies the relevant data from the we provide into the event queue, so we do not need to worry about our local copy of the event expiring before it is processed in our main loop\n\nLet’s see how we can now use SDL’s event system to handle custom events, whose type is specific to our program.\n\nFor example, our game might have a settings menu, and we’d like to use SDL’s event queue to report when the user requests to open that settings menu.\n\nThe first step of this process is to register our custom type with SDL. To do this, we call , passing an integer representing how many event types we want to register. In most cases, this will be :\n\nThis function will return a value that we can use as the property when we create an . SDL event types are 32 bit unsigned integers and, behind the scenes, ensures that the integer it returns is unique.\n\nThat is, it does not conflict with any event types that SDL uses internally (such as ) and it does not conflict with the type returned by any previous call to\n\nLet’s save the value returned by our call, and use it to create an event:\n\nAs before, in real use cases, events will typically not be dispatched from our file - rather, they’ll be dispatched from some object deeper within our game, such as a button on the UI.\n\nHowever, with custom event types, this adds a little complexity. The files that push the custom event type and the files that use it all need access to the representing it’s type - the variable in the previous example.\n\nTo accommodate this, we can move our event registrations to a header file, and it where needed. It may also be helpful to put these variables in a namespace, with a name like :\n\nJust like the built in events can contain additional data (such as the and values of a ), so too can our custom events. Any event with a type returned from is considered a user event.\n\nWe can access the user event data from the property of the . This will be a struct with a type of :\n\nAn struct has three members that we can attach data to:\n\nThe two void pointers tend to be the most useful. A void pointer can point to any type of data, so we can store anything we might need in the and members.\n\nNote, however, that we must ensure that the objects that these pointers point to remain alive long enough so anything that receives our event can make use of them.\n\nBelow, we attach a pointer to an and a to our event. Both variables are global, so they remain alive even after our call ends:\n\nTo meaningfully use a void pointer, we first need to statically cast it to the correct type:\n\nVoid pointers are considered somewhat unsafe by modern standards, as the compiler is unable to verify that we’re casting to the correct type.\n\nIf we update our code with the mistaken belief that is an , we don’t get any compiler error. Instead, our program simply has unexpected behavior at run time:\n\nWe introduce modern, safer alternatives to in our advanced course, such as and . However, in this case, we’re forced to use void pointers, so we just have to be cautious.\n\nOne obvious strategy that can be helpful here is to ensure that the types pointed at by and are consistent for any given event type. For example, we don’t want events to sometimes have pointing at an , and sometimes pointing at a .\n\nEvery component that pushes events onto the queue should by attaching the same type of data to the event.\n\nWe’re not restricted to storing simple primitive types in the or pointers. We can store pointers to any data type, including custom data types created specifically to support the respective event type, if needed.\n\nA common pattern is for the event to include a pointer to the object that created it. This is particularly useful when we have multiple instances of some class that can push events. Code that handles those events will often need to know which specific instance the event came from.\n\nWe can do this using the pointer:\n\nThis allows any function that receives the event to access the public methods of the object that sent it, which can be helpful for determing how it needs to react:\n\nIn this lesson, we explored how to create and manage custom events in SDL2. We learned how to create and push events onto SDL's event queue using . We then delved into creating custom event types using and how to handle these events in our main loop.\n\nThe lesson also covered how to attach additional data to user events using the struct, including the common pattern of storing a pointer to the object that created the event."
    },
    {
        "link": "https://geeksforgeeks.org/sdl-library-in-c-c-with-examples",
        "document": "SDL is Simple DirectMedia Layer.It is a cross-platform development library designed to provide low level access to audio, keyboard, mouse, joystick, and graphics hardware via OpenGL and Direct3D.It can be used to make animations and video games.\n• It basically provides a set of APIs to interact with various devices like graphics hardware, audio, keyboard, mouse, etc.\n• It is written in C programming language and works with C++ and various other languages like c# and python.\n\nInstallation on Linux ( For OS which uses the apt package manager eg : Ubuntu ):\n• We need to make a Makefile.So open a text editor of your choice and start writing the code below.\n\nThat will create a empty window on your screen. \n\nOutput: \n\n\n\nWe will write a simple program to explain rendering and I/O handling:\n\nThat will render a image on the window which can be controlled via your keyboard up, down, left, right. \n\nOutput:"
    }
]