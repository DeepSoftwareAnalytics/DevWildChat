[
    {
        "link": "https://sandordargo.com/blog/2024/09/04/structs-and-constructors",
        "document": "Today, we are going to talk about when and why structs should have constructors if they should have them at all. We are also going to see once again that generic best practices and best practices to reduce binary size do not always go hand in hand.\n\nI had some time to dedicate to cleaning up code. I remembered that recently I saw some structs like this:\n\nI didn’t like this code. Even though the struct didn’t have any constructors, even though not all the members were set, with the help of designated initializers it’s so easy to get rid of the initialize then modify anti-pattern Connor Hoekstra talked about a couple of years ago at the Italian C++ conference.\n\nAs a result, you get code that still tells you what is initialized, code which is more efficient without making it less readable and in addition you don’t have to think about why the object is created before its members are set.\n\nNext, I checked some code where I did see some non-default constructors, probably because people wanted to avoid to previous pattern.\n\nI didn’t like this pattern either, because the members are public and we could initialize them directly. It’s true that it was not enough to simply remove the constructors, we had to modify the syntax. We could either use designated initializers which come along with aggregate initialization with its braces or if we didn’t need the member names in the initializer expressions, we could use simply braces.\n\nSo this shows that if you still haven’t upgraded to C++20, you can still use aggregate initialization without having to initialize all the members. If we provide members in the initializer list, the first member (counting from the top) will be initialized.\n\nSo unless the constructors are not initializing the first members of the struct (but they skip some in between), they didn’t make much sense from the beginning assuming that the code was not written to a standard earlier than C++11.\n\nThen I continued looking for similar code and I found this.\n\nOh, a macro. There is even a corresponding implementation file, with other macro and constructor definitions.\n\nThat’s clearly not how most like to see their structs which should be simple. So I immediately started removing the fluff but I didn’t merge the changes. I didn’t even post a code review. Can you guess why?\n\nBinary size was significantly impacted. Removing all the user-declared special member functions gave a few extra KBs for widely used classes. The reason is essentially inlining. With defaulted special member functions, each compilation unit where is used, gets a copy of the special member functions’ code. In other words, they are inlined. With the used-provided versions, they are not inlined, but you get simple function calls.\n\nI must say that if we didn’t care so much about binary sizes, I’d still go ahead and remove the macro and the constructors from . There would be only one constructor to keep in a certain format and that’s the one taking the blob. I’d probably turn it into a static builder function or a free function as it was suggested by Jonathan Boccara on FluentC++.\n\nIn my opinion, a barely needs a constructor. With the combination of aggregate initialization, designated initializers and the right order of members, you can easily get rid of constructors in a . In those rare cases, when you’d still need them you can replace it with a free function keeping your as simple as possible.\n\nAt the same time, it’s worth noting that sometimes a has constructors and special member functions to limit binary sizes. By moving special member functions to implementation files, we can limit inlining and thus decrease binary sizes.\n\nIf you liked this article, please\n• hit on the like button,"
    },
    {
        "link": "https://softwareengineering.stackexchange.com/questions/262463/should-we-add-constructors-to-structs",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://stackoverflow.com/questions/62611176/best-practice-for-struct-layout-in-c-c",
        "document": "My question here is, are there scenarios where layout L2 has downsides when compared to L1 or any other layout ?\n\nSometimes you need to have members in a different order. Reasons for this may include:\n• The structure is part of a communications protocol and has to be sent byte-by-byte across a network or other communication device. In this case, the layout of the structure may be dictated by the protocol, and you will have to match it exactly (including padding or lack thereof).\n• The structure is part of a family of structures that share initial sequences of members, so those members must be placed first. This is sometimes done to allow structures to be handled in a “generic” way by operating on those initial members only.\n• The structure includes a buffer whose length will vary (by being allocated dynamically according to needs that arise during program execution). Such a buffer is implemented with a flexible array member, which must be the last member in the structure.\n\nAlso, there may be incidental effects of how members are ordered. For example, if member happens to be used much more frequently than other members of the structure, putting it at the front might allow the compiler to access it with simpler address arithmetic, since its offset from the beginning of the structure will be zero. This is rarely a consideration in programming, but I mention it for completeness.\n\nAside such considerations, you are generally free to order members as you desire.\n\nNo. As an example, an eight-byte might have an alignment require of one, two, four, or eight bytes.\n\nThis is not true for members that are aggregates (arrays, structures, and unions). Consider that a member is 13 bytes in size but only requires alignment of one byte. To minimize padding, order members in order of decreasing alignment requirement, not decreasing size."
    },
    {
        "link": "https://reddit.com/r/cpp/comments/1h6gc5f/opiniones_about_constructors_in_structs",
        "document": "What are you guys' opinions on using constructors inside of structs? I personally don't really see a point in using then since I usually use structs so I can group simple data types for a bigger class, so if I need to initialize any struct type I do it in the bigger class.\n\nHowever I'm not that good or experienced of a programmer, since I'm already on Y2 CS, so what are you guys' opinions?"
    },
    {
        "link": "https://quora.com/What-are-some-best-practices-for-struct-members-in-C-C",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://stackoverflow.com/questions/15106102/how-to-use-c-stdostream-with-printf-like-formatting",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/5193173/getting-cout-output-to-a-stdstring",
        "document": ""
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/text/string-and-i-o-formatting-modern-cpp?view=msvc-170",
        "document": "C++ <iostream> classes, functions, and operators support formatted string I/O. For example, the following code shows how to set to format an integer to output in hexadecimal. First, it saves the current state to reset it afterwards, because once format state is passed to , it stays that way until changed. It doesn't just apply to the one line of code.\n\nThis approach is type-safe and extensible, but it's also complex and verbose.\n\nAs an alternative, you can use from the Boost C++ libraries, even though it's nonstandard. You can download any Boost library from the Boost website.\n\nSome advantages of are:\n• None Safe: Type-safe, and throws an exception for errors, for example, the specification of too few or too many items.\n• None Extensible: Works for any type that can be streamed.\n\nAlthough is built on C++ <iostream> facilities, which are safe and extensible, they aren't performance-optimized. When you require performance optimization, consider C printf and sprintf, which are fast and easy to use. However, they aren't extensible or safe from vulnerabilities. (Safe versions exist, but they incur a slight performance penalty. For more information, see printf_s, _printf_s_l, wprintf_s, _wprintf_s_l and sprintf_s, _sprintf_s_l, swprintf_s, _swprintf_s_l).\n\nThe following code demonstrates some of the Boost formatting features.\n\nWelcome back to C++\n\n C++ Language Reference\n\n C++ Standard Library\n\n <iostream>\n\n <limits>\n\n <iomanip>"
    },
    {
        "link": "https://websites.umich.edu/~eecs381/handouts/formatting.pdf",
        "document": ""
    },
    {
        "link": "https://en.cppreference.com/w/cpp/io/cout",
        "document": "The global objects and control output to a stream buffer of implementation-defined type (derived from std::streambuf), associated with the standard C output stream stdout.\n\nThese objects are guaranteed to be initialized during or before the first time an object of type std::ios_base::Init is constructed and are available for use in the constructors and destructors of static objects with ordered initialization (as long as is included before the object is defined).\n\nUnless std::ios_base::sync_with_stdio(false) has been issued, it is safe to concurrently access these objects from multiple threads for both formatted and unformatted output.\n\nBy specification of std::cin, std::cin.tie() returns &std::cout. This means that any input operation on executes std::cout.flush() (via std::basic_istream::sentry's constructor). Similarly, std::wcin.tie() returns &std::wcout.\n\nBy specification of std::cerr, std::cerr.tie() returns &std::cout. This means that any output operation on executes std::cout.flush() (via std::basic_ostream::sentry's constructor). Similarly, std::wcerr.tie() returns &std::wcout. (since C++11)\n\nThe 'c' in the name refers to \"character\" (stroustrup.com FAQ); means \"character output\" and means \"wide character output\".\n\nBecause dynamic initialization of templated variables are unordered, it is not guaranteed that has been initialized to a usable state before the initialization of such variables begins, unless an object of type std::ios_base::Init has been constructed."
    },
    {
        "link": "https://stackoverflow.com/questions/7657910/arrays-initialization-body-as-function-parameter-c-array-is-it-possible",
        "document": "I am searching for some help in next situation:\n\n I have some class and some method in it, syntax is like this:\n\nSo I want to call this method like\n\nIs it possible in any language? Any (C++, C, obj-c, obj-c++) implementation is welcome! I know that this initialization block is a body of array, like\n\nBut interface will look great, I think, if there will be no temp variables before function calls (as we don't need to know the type of parameter in class-client). So, is there any chance to make this?"
    },
    {
        "link": "https://tutorialspoint.com/cplusplus/cpp_passing_arrays_to_functions.htm",
        "document": "C++ does not allow to pass an entire array as an argument to a function. However, You can pass a pointer to an array by specifying the array's name without an index.\n\nIf you want to pass a single-dimension array as an argument in a function, you would have to declare function formal parameter in one of following three ways and all three declaration methods produce similar results because each tells the compiler that an integer pointer is going to be received.\n\nFormal parameters as a pointer as follows −\n\nFormal parameters as a sized array as follows −\n\nFormal parameters as an unsized array as follows −\n\nNow, consider the following function, which will take an array as an argument along with another argument and based on the passed arguments, it will return average of the numbers passed through the array as follows −\n\nNow, let us call the above function as follows −\n\nWhen the above code is compiled together and executed, it produces the following result −\n\nAs you can see, the length of the array doesn't matter as far as the function is concerned because C++ performs no bounds checking for the formal parameters."
    },
    {
        "link": "https://labex.io/tutorials/cpp-how-to-pass-arrays-as-function-parameters-420860",
        "document": "What is an Array?\n\nAn array in C++ is a fundamental data structure that stores multiple elements of the same type in contiguous memory locations. It provides a way to organize and access multiple values efficiently under a single variable name.\n\nIn C++, you can declare an array using the following syntax:\n\nThere are multiple ways to initialize arrays in C++:\n\nArray elements are accessed using their index, which starts from 0:\n• Always initialize arrays before use\n• Consider using or for more safety\n\nBy understanding these array basics, you're ready to explore more advanced array techniques in LabEx's C++ programming environment."
    },
    {
        "link": "https://w3schools.com/cpp/cpp_function_array.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://stackoverflow.com/questions/31537349/initialiser-list-passed-as-function-parameter-for-array",
        "document": "The answers so far haven't addressed the main problem with the question: In the signature\n\nis not an array, but a pointer to a . This is despite the fact that the declaration of makes it look like an array. This is even pointed out by the error message:\n\nSo, in the same way you are not allowed to do this:\n\nYou can't call With the signature above.\n\nI suggest you take some time to read up on C-style arrays and how they are not first-class citizens in C++.\n\nFrom the answer you posted to your own question, it seems that you are looking for a function that works for fixed-size arrays. But don't pass it by value! I recommend using the following declaration:"
    }
]