[
    {
        "link": "https://docs.python.org/3.10/library/typing.html",
        "document": "This module provides runtime support for type hints. The most fundamental support consists of the types , , , , and . For a full specification, please see PEP 484. For a simplified introduction to type hints, see PEP 483.\n\nThe function below takes and returns a string and is annotated as follows:\n\nIn the function , the argument is expected to be of type and the return type . Subtypes are accepted as arguments.\n\nNew features are frequently added to the module. The typing_extensions package provides backports of these new features to older versions of Python.\n\nUse the helper to create distinct types: The static type checker will treat the new type as if it were a subclass of the original type. This is useful in helping catch logical errors: # fails type checking; an int is not a UserId You may still perform all operations on a variable of type , but the result will always be of type . This lets you pass in a wherever an might be expected, but will prevent you from accidentally creating a in an invalid way: # 'output' is of type 'int', not 'UserId' Note that these checks are enforced only by the static type checker. At runtime, the statement will make a callable that immediately returns whatever parameter you pass it. That means the expression does not create a new class or introduce much overhead beyond that of a regular function call. More precisely, the expression is always true at runtime. It is invalid to create a subtype of : # Fails at runtime and does not pass type checking However, it is possible to create a based on a ‘derived’ : and typechecking for will work as expected. See PEP 484 for more details. Recall that the use of a type alias declares two types to be equivalent to one another. Doing will make the static type checker treat as being exactly equivalent to in all cases. This is useful when you want to simplify complex type signatures. In contrast, declares one type to be a subtype of another. Doing will make the static type checker treat as a subclass of , which means a value of type cannot be used in places where a value of type is expected. This is useful when you want to prevent logic errors with minimal runtime cost. Changed in version 3.10: is now a class rather than a function. There is some additional runtime cost when calling over a regular function. However, this cost will be reduced in 3.11.0.\n\nA user-defined class can be defined as a generic class. as a base class defines that the class takes a single type parameter . This also makes valid as a type within the class body. The base class defines so that is valid as a type: A generic type can have any number of type variables. All varieties of are permissible as parameters for a generic type: Each type variable argument to must be distinct. This is thus invalid: You can use multiple inheritance with : When inheriting from generic classes, some type variables could be fixed: In this case has a single parameter, . Using a generic class without specifying type parameters assumes for each position. In the following example, is not generic but implicitly inherits from : # Return type here is same as Iterable[str] | int Changed in version 3.7: no longer has a custom metaclass. User-defined generics for parameter expressions are also supported via parameter specification variables in the form . The behavior is consistent with type variables’ described above as parameter specification variables are treated by the typing module as a specialized type variable. The one exception to this is that a list of types can be used to substitute a : Furthermore, a generic with only one parameter specification variable will accept parameter lists in the forms and also for aesthetic reasons. Internally, the latter is converted to the former, so the following are equivalent: Do note that generics with may not have correct after substitution in some cases because they are intended primarily for static type checking. Changed in version 3.10: can now be parameterized over parameter expressions. See and PEP 612 for more details. A user-defined generic class can have ABCs as base classes without a metaclass conflict. Generic metaclasses are not supported. The outcome of parameterizing generics is cached, and most types in the typing module are hashable and comparable for equality.\n\nA special kind of type is . A static type checker will treat every type as being compatible with and as being compatible with every type. This means that it is possible to perform any operation or method call on a value of type and assign it to any variable: # Passes type checking; 'item' could be any type, # and that type might have a 'bar' method Notice that no type checking is performed when assigning a value of type to a more precise type. For example, the static type checker did not report an error when assigning to even though was declared to be of type and receives an value at runtime! Furthermore, all functions without a return type or parameter types will implicitly default to using : # A static type checker will treat the above # as having the same signature as: This behavior allows to be used as an escape hatch when you need to mix dynamically and statically typed code. Contrast the behavior of with the behavior of . Similar to , every type is a subtype of . However, unlike , the reverse is not true: is not a subtype of every other type. That means when the type of a value is , a type checker will reject almost all operations on it, and assigning it to a variable (or using it as a return value) of a more specialized type is a type error. For example: # Fails type checking; an object does not have a 'magic' method. # Passes type checking, since ints and strs are subclasses of object # Passes type checking, since Any is compatible with all types Use to indicate that a value could be any type in a typesafe manner. Use to indicate that a value is dynamically typed."
    },
    {
        "link": "https://docs.python.org/3/library/typing.html",
        "document": "This module provides runtime support for type hints.\n\nConsider the function below:\n\nThe function takes an argument expected to be an instance of , as indicated by the type hint . The function is expected to return an instance of , as indicated by the hint.\n\nWhile type hints can be simple classes like or , they can also be more complex. The module provides a vocabulary of more advanced type hints.\n\nNew features are frequently added to the module. The typing_extensions package provides backports of these new features to older versions of Python.\n\nUse the helper to create distinct types: The static type checker will treat the new type as if it were a subclass of the original type. This is useful in helping catch logical errors: # fails type checking; an int is not a UserId You may still perform all operations on a variable of type , but the result will always be of type . This lets you pass in a wherever an might be expected, but will prevent you from accidentally creating a in an invalid way: # 'output' is of type 'int', not 'UserId' Note that these checks are enforced only by the static type checker. At runtime, the statement will make a callable that immediately returns whatever parameter you pass it. That means the expression does not create a new class or introduce much overhead beyond that of a regular function call. More precisely, the expression is always true at runtime. It is invalid to create a subtype of : # Fails at runtime and does not pass type checking However, it is possible to create a based on a ‘derived’ : and typechecking for will work as expected. See PEP 484 for more details. Recall that the use of a type alias declares two types to be equivalent to one another. Doing will make the static type checker treat as being exactly equivalent to in all cases. This is useful when you want to simplify complex type signatures. In contrast, declares one type to be a subtype of another. Doing will make the static type checker treat as a subclass of , which means a value of type cannot be used in places where a value of type is expected. This is useful when you want to prevent logic errors with minimal runtime cost. Changed in version 3.10: is now a class rather than a function. As a result, there is some additional runtime cost when calling over a regular function. Changed in version 3.11: The performance of calling has been restored to its level in Python 3.9.\n\nFor most containers in Python, the typing system assumes that all elements in the container will be of the same type. For example: # Type checker will infer that all elements in ``x`` are meant to be ints # Type checker will infer that all keys in ``z`` are meant to be strings, # and that all values in ``z`` are meant to be either strings or ints only accepts one type argument, so a type checker would emit an error on the assignment above. Similarly, only accepts two type arguments: the first indicates the type of the keys, and the second indicates the type of the values. Unlike most other Python containers, however, it is common in idiomatic Python code for tuples to have elements which are not all of the same type. For this reason, tuples are special-cased in Python’s typing system. accepts any number of type arguments: # OK: ``x`` is assigned to a tuple of length 1 where the sole element is an int # OK: ``y`` is assigned to a tuple of length 2; # element 1 is an int, element 2 is a str # Error: the type annotation indicates a tuple of length 1, # but ``z`` has been assigned to a tuple of length 3 To denote a tuple which could be of any length, and in which all elements are of the same type , use . To denote an empty tuple, use . Using plain as an annotation is equivalent to using : # These reassignments are OK: ``tuple[int, ...]`` indicates x can be of any length # This reassignment is an error: all elements in ``x`` must be ints # ``y`` can only ever be assigned to an empty tuple # These reassignments are OK: plain ``tuple`` is equivalent to ``tuple[Any, ...]``\n\nA user-defined class can be defined as a generic class. This syntax indicates that the class is parameterised around a single type variable . This also makes valid as a type within the class body. Generic classes implicitly inherit from . For compatibility with Python 3.11 and lower, it is also possible to inherit explicitly from to indicate a generic class: Generic classes have methods, meaning they can be parameterised at runtime (e.g. below): A generic type can have any number of type variables. All varieties of are permissible as parameters for a generic type: Each type variable argument to must be distinct. This is thus invalid: Generic classes can also inherit from other classes: When inheriting from generic classes, some type parameters could be fixed: In this case has a single parameter, . Using a generic class without specifying type parameters assumes for each position. In the following example, is not generic but implicitly inherits from : # Return type here is same as Iterable[str] | int For backward compatibility, generic type aliases can also be created through a simple assignment: Changed in version 3.7: no longer has a custom metaclass. Changed in version 3.12: Syntactic support for generics and type aliases is new in version 3.12. Previously, generic classes had to explicitly inherit from or contain a type variable in one of their bases. User-defined generics for parameter expressions are also supported via parameter specification variables in the form . The behavior is consistent with type variables’ described above as parameter specification variables are treated by the typing module as a specialized type variable. The one exception to this is that a list of types can be used to substitute a : Classes generic over a can also be created using explicit inheritance from . In this case, is not used: Another difference between and is that a generic with only one parameter specification variable will accept parameter lists in the forms and also for aesthetic reasons. Internally, the latter is converted to the former, so the following are equivalent: Note that generics with may not have correct after substitution in some cases because they are intended primarily for static type checking. Changed in version 3.10: can now be parameterized over parameter expressions. See and PEP 612 for more details. A user-defined generic class can have ABCs as base classes without a metaclass conflict. Generic metaclasses are not supported. The outcome of parameterizing generics is cached, and most types in the typing module are hashable and comparable for equality.\n\nA special kind of type is . A static type checker will treat every type as being compatible with and as being compatible with every type. This means that it is possible to perform any operation or method call on a value of type and assign it to any variable: # Passes type checking; 'item' could be any type, # and that type might have a 'bar' method Notice that no type checking is performed when assigning a value of type to a more precise type. For example, the static type checker did not report an error when assigning to even though was declared to be of type and receives an value at runtime! Furthermore, all functions without a return type or parameter types will implicitly default to using : # A static type checker will treat the above # as having the same signature as: This behavior allows to be used as an escape hatch when you need to mix dynamically and statically typed code. Contrast the behavior of with the behavior of . Similar to , every type is a subtype of . However, unlike , the reverse is not true: is not a subtype of every other type. That means when the type of a value is , a type checker will reject almost all operations on it, and assigning it to a variable (or using it as a return value) of a more specialized type is a type error. For example: # Fails type checking; an object does not have a 'magic' method. # Passes type checking, since ints and strs are subclasses of object # Passes type checking, since Any is compatible with all types Use to indicate that a value could be any type in a typesafe manner. Use to indicate that a value is dynamically typed."
    },
    {
        "link": "https://docs.python.org/tr/3.10/library/typing.html",
        "document": ""
    },
    {
        "link": "https://mypy.readthedocs.io/en/latest/cheat_sheet_py3.html",
        "document": "This document is a quick cheat sheet showing how to use type annotations for various common types in Python.\n\nTechnically many of the type annotations shown below are redundant, since mypy can usually infer the type of a variable from its value. See Type inference and type annotations for more details. # This is how you declare the type of a variable # You don't need to initialize a variable to annotate it # Ok (no value at runtime until assigned) # Doing so can be useful in conditional branches\n\n# For most types, just use the name of the type in the annotation # Note that mypy can usually infer the type of a variable from its value, # so technically these annotations are redundant # For collections on Python 3.9+, the type of the collection item is in brackets # For mappings, we need the types of both keys and values # For tuples of fixed size, we specify the types of all the elements # For tuples of variable size, we use one type and ellipsis # On Python 3.8 and earlier, the name of the collection type is # capitalized, and the type is imported from the 'typing' module # On Python 3.10+, use the | operator when something could be one of a few types # Use X | None for a value that could be None on Python 3.10+ # Use Optional[X] on 3.9 and earlier; Optional[X] is the same as 'X | None' # Mypy understands x won't be None here because of the if-statement # If you know a value can never be None due to some logic that mypy doesn't\n\n# This is how you annotate a function definition # And here's how you specify multiple arguments # If a function does not return a value, use None as the return type # Default value for an argument goes after the type annotation # Note that arguments without a type are dynamically typed (treated as Any) # and that functions without any annotations are not checked # This is how you annotate a callable (function) value # A generator function that yields ints is secretly just a function that # returns an iterator of ints, so that's how we annotate it # You can of course split a function annotation over multiple lines # Positional-only arguments can also be marked by using a name starting with # error: Too many positional arguments for \"quux\" # This says each positional arg and each keyword arg is a \"str\"\n\n# The \"__init__\" method doesn't return anything, so it gets return # type \"None\" just like any other method that doesn't return anything # mypy will infer the correct types for these instance variables # based on the types of the parameters. # For instance methods, omit type for \"self\" # User-defined classes are valid as types in annotations # Functions that accept BankAccount also accept any subclass of BankAccount! # You can optionally declare instance variables in the class body # You can use the ClassVar annotation to declare a class variable # If you want dynamic attributes on your class, have it # This will allow assignment to any A.x, if x is the same type as \"value\" # (use \"value: Any\" to allow arbitrary types) # This will allow access to any A.x, if x is compatible with the return type\n\nWhen you’re puzzled or when things are complicated¶ # To find out what type mypy infers for an expression anywhere in # your program, wrap it in reveal_type(). Mypy will print an error # message with the type; remove it again before running the code. # If you initialize a variable with an empty container or \"None\" # you may have to help mypy a bit by providing an explicit type annotation # Use Any if you don't know the type of something or it's too # Mypy will let you do anything with x! # Use a \"type: ignore\" comment to suppress errors on a given line, # when your code confuses mypy or runs into an outright bug in mypy. # Good practice is to add a comment explaining the issue. # type: ignore # confusing_function won't return None here because ... # \"cast\" is a helper function that lets you override the inferred # type of an expression. It's only for mypy -- there's no runtime check. # Passes fine despite being a lie (no runtime check) # Still prints [4] ... the object is not changed or casted at runtime # Use \"TYPE_CHECKING\" if you want to have code that mypy can see but will not # be executed at runtime (or to have code that mypy can't see) # mypy is unaware of this In some cases type annotations can cause issues at runtime, see Annotation issues at runtime for dealing with this. See Silencing type errors for details on how to silence errors.\n\nIn typical Python code, many functions that can take a list or a dict as an argument only need their argument to be somehow “list-like” or “dict-like”. A specific meaning of “list-like” or “dict-like” (or something-else-like) is called a “duck type”, and several duck types that are common in idiomatic Python are standardized. # or 'from typing import ...' (required in Python 3.8) # Use Iterable for generic iterables (anything usable in \"for\"), # and Sequence where a sequence (supporting \"len\" and \"__getitem__\") is # Mapping describes a dict-like object (with \"__getitem__\") that we won't # mutate, and MutableMapping one (with \"__setitem__\") that we might # mypy will complain about this line... # ...but mypy is OK with this. # Use IO[str] or IO[bytes] for functions that should accept or return # objects that come from an open() call (note that IO does not # distinguish between reading, writing or other modes) You can even make your own duck types using Protocols and structural subtyping."
    },
    {
        "link": "https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html",
        "document": "This document is a quick cheat sheet showing how to use type annotations for various common types in Python.\n\nTechnically many of the type annotations shown below are redundant, since mypy can usually infer the type of a variable from its value. See Type inference and type annotations for more details. # This is how you declare the type of a variable # You don't need to initialize a variable to annotate it # Ok (no value at runtime until assigned) # Doing so can be useful in conditional branches\n\n# For most types, just use the name of the type in the annotation # Note that mypy can usually infer the type of a variable from its value, # so technically these annotations are redundant # For collections on Python 3.9+, the type of the collection item is in brackets # For mappings, we need the types of both keys and values # For tuples of fixed size, we specify the types of all the elements # For tuples of variable size, we use one type and ellipsis # On Python 3.8 and earlier, the name of the collection type is # capitalized, and the type is imported from the 'typing' module # On Python 3.10+, use the | operator when something could be one of a few types # Use X | None for a value that could be None on Python 3.10+ # Use Optional[X] on 3.9 and earlier; Optional[X] is the same as 'X | None' # Mypy understands x won't be None here because of the if-statement # If you know a value can never be None due to some logic that mypy doesn't\n\n# This is how you annotate a function definition # And here's how you specify multiple arguments # If a function does not return a value, use None as the return type # Default value for an argument goes after the type annotation # Note that arguments without a type are dynamically typed (treated as Any) # and that functions without any annotations are not checked # This is how you annotate a callable (function) value # A generator function that yields ints is secretly just a function that # returns an iterator of ints, so that's how we annotate it # You can of course split a function annotation over multiple lines # Positional-only arguments can also be marked by using a name starting with # error: Too many positional arguments for \"quux\" # This says each positional arg and each keyword arg is a \"str\"\n\n# The \"__init__\" method doesn't return anything, so it gets return # type \"None\" just like any other method that doesn't return anything # mypy will infer the correct types for these instance variables # based on the types of the parameters. # For instance methods, omit type for \"self\" # User-defined classes are valid as types in annotations # Functions that accept BankAccount also accept any subclass of BankAccount! # You can optionally declare instance variables in the class body # You can use the ClassVar annotation to declare a class variable # If you want dynamic attributes on your class, have it # This will allow assignment to any A.x, if x is the same type as \"value\" # (use \"value: Any\" to allow arbitrary types) # This will allow access to any A.x, if x is compatible with the return type\n\nWhen you’re puzzled or when things are complicated¶ # To find out what type mypy infers for an expression anywhere in # your program, wrap it in reveal_type(). Mypy will print an error # message with the type; remove it again before running the code. # If you initialize a variable with an empty container or \"None\" # you may have to help mypy a bit by providing an explicit type annotation # Use Any if you don't know the type of something or it's too # Mypy will let you do anything with x! # Use a \"type: ignore\" comment to suppress errors on a given line, # when your code confuses mypy or runs into an outright bug in mypy. # Good practice is to add a comment explaining the issue. # type: ignore # confusing_function won't return None here because ... # \"cast\" is a helper function that lets you override the inferred # type of an expression. It's only for mypy -- there's no runtime check. # Passes fine despite being a lie (no runtime check) # Still prints [4] ... the object is not changed or casted at runtime # Use \"TYPE_CHECKING\" if you want to have code that mypy can see but will not # be executed at runtime (or to have code that mypy can't see) # mypy is unaware of this In some cases type annotations can cause issues at runtime, see Annotation issues at runtime for dealing with this. See Silencing type errors for details on how to silence errors.\n\nIn typical Python code, many functions that can take a list or a dict as an argument only need their argument to be somehow “list-like” or “dict-like”. A specific meaning of “list-like” or “dict-like” (or something-else-like) is called a “duck type”, and several duck types that are common in idiomatic Python are standardized. # or 'from typing import ...' (required in Python 3.8) # Use Iterable for generic iterables (anything usable in \"for\"), # and Sequence where a sequence (supporting \"len\" and \"__getitem__\") is # Mapping describes a dict-like object (with \"__getitem__\") that we won't # mutate, and MutableMapping one (with \"__setitem__\") that we might # mypy will complain about this line... # ...but mypy is OK with this. # Use IO[str] or IO[bytes] for functions that should accept or return # objects that come from an open() call (note that IO does not # distinguish between reading, writing or other modes) You can even make your own duck types using Protocols and structural subtyping."
    },
    {
        "link": "https://stackoverflow.com/questions/31487696/most-efficient-palindrome-program-for-python",
        "document": "You can do this very simply by just checking if the string that you input is equal to itself reversed (that's what a palindrome is).\n\nreverses the string because the tells how many steps to go by and negative will go through the string in reverse.\n\nIf you will need to check if integers are palindromes, you can do:"
    },
    {
        "link": "https://stackoverflow.com/questions/8769890/performance-of-various-methods-to-test-for-a-palindrome-python",
        "document": "Today, I was fooling around with a couple of programming puzzles. Faced with the task of testing a string to see whether or not it is a palindrome, I conceived of several ways to accomplish this. The basics of these three methods are depicted below (most neatifying and testing code is omitted).\n\nMethod 1 takes advantage of the fact that characters in a string can be indexed like elements of a list. We can imagine this method thusly: you start with your fingers under the first and last letters of a word; with each iteration, you first check whether the letters above your fingers are the same; if they are different, the word is not a palindrome; if they are the same, you move each of your fingers 1 letter toward the center of the word and repeat.\n\nThe bulk of computation with this method would be the condition testing, index slicing, and comparisons. There is also a counter variable which is a constant part of a calculation for the index slicing.\n\nMethod 2 also employs the indexing of characters in a string. The first and last characters are compared, then discarded, and these steps are repeated until a palindrome is guaranteed (or disproven).\n\nCosts would be similar to Method 1, with some differences: the addition of conversion from str -> list, popping elements from a list, and minus a counter variable.\n\nMethod 3 reverses the given string, and then compares it to the original. There are various ways to reverse a string ( , etc.), but I've only shown one such possibility: converting the string to a list, and then concatenating each element of that list to the BEGINNING of a new string.\n\nWith different methods for reversing a string, there may be different operations, and thus costs, involved. For my chosen method here, we have the cost of slicing each and every element from a list and concatenating it with a str variable.\n\nWhich of these methods would be the fastest executing and why? Also, is there any way to improve the efficiency of these methods? (On a tangent, how do you test the execution speed of modules in Python?)"
    },
    {
        "link": "https://pickl.ai/blog/palindromes-in-python",
        "document": "Are There Any Performance Considerations When Checking for Large Strings?\n\nPalindromes can be found in various forms\n\nSummary: This guide explores multiple methods for checking palindrome program in Python, including reverse comparison, iterative approaches using loops, and recursive techniques. Each method is illustrated with clear examples, allowing programmers to choose the best approach based on their needs. Mastering these techniques enhances coding skills and opens up practical applications.\n\nPalindromes are fascinating sequences that read the same forwards and backwards. In programming, especially in Python, understanding how to identify and manipulate palindrome can enhance your coding skills and problem-solving abilities.\n\nThis guide aims to provide a comprehensive overview of palindrome program in Python, covering various methods to check for palindromic strings and numbers, along with practical examples.\n• Palindromes read the same forwards and backwards, applicable in strings and numbers.\n• Multiple methods exist in Python for checking palindromes, each with unique advantages.\n• Reverse comparison is the simplest and most intuitive method for palindrome checks.\n• Recursive methods offer elegant solutions but may be less efficient for large inputs.\n• Understanding palindromes enhances problem-solving skills and has practical applications in programming.\n\nA palindrome is a sequence of characters, which can be a word, phrase, number, or other symbols, that reads the same forwards and backwards. For example, words like “madam” and “racecar” are palindromes because they maintain the same sequence when reversed.\n\nThe term “palindrome” originates from the Greek words palin meaning “again” and dromos meaning “way” or “direction,” reflecting its reversible nature.\n\nPalindromes can be found in various forms\n\nPalindromes are fascinating sequences that can be found in various forms, each exhibiting the characteristic of reading the same forwards and backwards. Here are the main types of palindromes:\n\nThese are single words that remain unchanged when reversed. Examples include:\n\nWord palindromes are often used in puzzles and word games, showcasing the playful nature of language.\n\nPhrase palindromes consist of multiple words and ignore spaces, punctuation, and capitalization. They maintain their palindromic nature when these elements are disregarded. Examples include:\n\nThese phrases often require careful consideration to identify, making them popular in literary contexts and recreational linguistics.\n\nThese are numbers that read the same forwards and backwards. Examples include:\n\nNumerical palindromes are commonly used in mathematics and number theory, where they may have special properties or significance.\n\nCertain dates can also be palindromic, depending on the format used. For example:\n\nDate palindromes often capture attention for their uniqueness and can be celebrated in various contexts, such as anniversaries or special events.\n\nThese involve entire sentences that read the same forwards and backwards when ignoring spaces and punctuation. Examples include:\n• “Evil is a name of a foeman, as I live.”\n\nSentence palindromes can be more complex and require creativity to construct, often leading to humorous or thought-provoking phrases.\n\nIn programming and computer science, character palindromes refer to sequences of characters (including letters, digits, or symbols) that maintain their order when reversed. This concept is often applied in algorithms for string manipulation.\n\nPalindromes have been used in literature and poetry for centuries and are also present in mathematics and computer science. They serve various purposes, from creating wordplay to being used in algorithms for data validation.\n\nMastering palindromes is essential for several reasons, particularly in fields such as genetics, mathematics, and programming. Here are some key points highlighting the importance of understanding palindromes:\n\nPalindromic sequences in DNA are crucial for various biological processes, including DNA replication, gene expression, and recombination. They help stabilize single-stranded DNA during replication and play a role in the regulation of genes through methylation, impacting how genes are expressed and function in organisms.\n\nIn evolutionary biology, palindromes facilitate local recombination on chromosomes that do not typically undergo recombination. This allows for intrachromosomal gene conversion, which can eliminate harmful mutations and enhance adaptive evolution by increasing the potential for beneficial mutations to be fixed in a population.\n\nIn mathematics and competitive exams like the GMAT, palindromes present unique problem-solving challenges. Understanding how to identify and construct palindromic numbers enhances logical reasoning and analytical skills, which are vital for success in quantitative reasoning sections.\n\nPalindromes have been revered across various cultures for their perceived mystical properties. In ancient Chinese and Hindu beliefs, palindromic numbers symbolized balance and harmony, serving as reminders of duality within life.\n\nPalindromes also find their place in literature and poetry. Mastering the art of creating palindromic phrases can enhance creative writing skills, allowing writers to explore unique structures and themes in their work.\n\nPalindromes are not merely linguistic curiosities; they have a variety of practical applications across different fields. Here are some key areas where palindromes play a significant role:\n\nPalindromes can be used to validate user inputs in software applications. By checking if an input is a palindrome, developers can ensure that the data adheres to specific criteria, which is particularly useful in forms where symmetrical data is required.\n\nIn game design, palindromes can enhance the gameplay experience by introducing puzzles and challenges that involve identifying or creating palindromic sequences. This adds an engaging layer of complexity, making games more interesting and interactive for players.\n\nCertain encryption algorithms utilize palindromic structures due to their symmetrical nature. Understanding these patterns can aid in developing secure cryptographic methods, which are essential for protecting sensitive information.\n\nPalindromes are valuable in text analysis for identifying patterns within strings. This application is relevant in linguistic studies and natural language processing, where recognizing language patterns can provide insights into phonetics, morphology, and syntax.\n\nIn the field of bioinformatics, palindromic sequences are crucial for DNA analysis. They are involved in processes such as gene regulation and DNA repair mechanisms. For instance, certain enzymes target palindromic sequences for cutting DNA strands, which is vital for genetic engineering and molecular biology.\n\nResearch has shown that palindromic properties can be leveraged in compression algorithms for biological sequences. By recognizing palindromic structures, these algorithms can efficiently encode genetic information, reducing storage requirements while maintaining data integrity.\n\nPalindromes often appear in recreational mathematics, where enthusiasts seek out numbers with special properties, such as palindromic primes. This exploration fosters mathematical creativity and problem-solving skills among learners.\n\nIn bioinformatics, finding palindromic substrings is essential for predicting secondary structures in RNA folding. These structures play a crucial role in various biological functions and understanding them can lead to advancements in genetic research.\n\nMastering palindrome program in Python equips you with essential programming skills that are applicable across various domains. By exploring different methods to identify palindromic strings and numbers, you enhance your problem-solving toolkit.\n\nThe versatility of Python allows for multiple approaches, each with its own advantages depending on context and requirements.\n\nHow Do I Create a Palindrome Function in Python?\n\nYou can create a palindrome function using various methods such as reverse comparison, loops (for or while), recursion, or built-in functions like reversed(). Each method has its strengths depending on your needs.\n\nYes! To check for palindromic phrases, normalise by removing spaces and punctuation before applying any palindrome-checking logic to ensure accurate results.\n\nAre There Any Performance Considerations When Checking for Large Strings?\n\nYes, performance can vary based on the method used. For large strings, using while loops or recursion may be more efficient than creating multiple copies of strings through slicing or joining operations."
    },
    {
        "link": "https://beapython.dev/2020/05/09/python-palindrome-detection-f-strings-ternary-operators-and-fast-fail-optimizations",
        "document": "The other day I was scrolling through a learning Python Facebook group that I contribute in to help people and ran across a seemingly simple post where someone was asking why he was getting a highlight error in his IDE. The original poster also wanted to know if this was the correct way to write this. The code is as below.\n\nWhile this code is correct for basic cases of a palindrome such as “bob” it definitely has some room for improvement.\n• Have spaces around your operators such as ‘if s1 == a’\n• Very inefficient way to reverse a string\n• Input should give a prompt to the user what the program does\n• Using a if else block for a simple logic check isn’t Pythonic\n• “it’s” instead of “its”, but that is just a grammar thing and the poster probably isn’t a native English speaker which is fine\n\nSure for a simple toy application from a beginner this is fine code. But to get in the habit of preparing for a career as a developer it is good to establish good coding practices earlier. This helps you write more maintainable code in the future when you are working harder problems or for your job where the code needs to be maintained for a longer time and may be worked on by multiple developers.\n\nAh, much simpler! To achieve this we utilize the splicing notation, F strings which are fast formatted strings, and a ternary operator to simplify our logic check, and reduce line usage to be able to visually process longer code in one screen.\n\nAlthough this code is cleaner, it still only detects basic palindromes like “bob” and “racecar”. If we input “Race car” it would say it’s not a palindrome even though generally spacing, casing, and special characters are ignored for the sake of cool palindromes. Before we fix for that let’s talk a little more about F Strings and Ternary operators.\n\nF strings or “fast formatted strings” are a feature introduced in Python3.6 and later that allow you to create complex strings in a easy to read way. Also the python magic it uses for interpolation can be bench-marked and proven faster than using basic string concatenation or python 2.7’s string formatting. I’ll give examples of this all below.\n\nYou can see the f string is much easier to read and follow than the str interpolation and also runs slightly quicker if you need to output a lot of formatted text in your program.\n\nA ternary operator is a way to do single line logic checks for simple conditions such as printing output in f strings, initializing a variable, or logic forking.\n\nNow that we have a deeper understanding of F Strings and Ternary operators my suggested code should make more sense. But as I stated earlier it doesn’t work for “Race car”. When working with user input your code should make assumptions about what the user is inputting and you should format that input to meet the expectations of your code. For example maybe your program expects integers for ‘guess the number’ type programs and the input is a string.\n\nFor our palindrome program we should clean the user input to make everything lower case and to remove special characters and spaces.\n\nThe code above is now functional for phrases such as “A man, a plan, a canal: Panama”. However you can see there are multiple operations in our algorithm which are O(n) in Big Oh notation which is an important concept in computer science. It is a way to make assumptions about an algorithms efficiency as the number of inputs increases drastically and the program scales.\n\nBig O breakdown of the above algorithm\n\nIf you’re familiar with big O notation for estimating complexities please feel free to skip. In the above example our input is a string, and our algorithm is dependent on the number of characters in our string. If our string has 7 letters as in the case of “Racecar”, to reverse our string we need to run a few operations on 7 inputs to move an iterator and concatenate the reversed string, this ends up being noted as O(n) or for every input n we do something n number of times.\n\n\n\nTo format things to lower case again we do another algorithm on 7 inputs to check if it’s upper case and change it to lower in our string array for an index of our loop.\n\nThe above algorithm ends up being 5 o(n) , for “Racecar” input there is roughly 35 set of operations we do. And while 35 is much bigger than an input of 7 it is still a linear increase and from the sake of a computer processor it’s not much different so the overall complexity is o(n).\n\nThis becomes more obvious when you look into exponential functions that run in o(n^2) where 7 inputs created 49 operations and 10 inputs generates 100 operations. These are the kind of algorithms that really slow down growing systems. Increasing the multiplier of a o(n^2) algorithm does not have as much impact on the runtime as adding another input (N).\n\nWhat if I told you that you could clean the input and run your comparison all in a single iteration of the input string by using left and right points to divide our steps. Also doing this will dramatically increase the speed of the algorithm on large input strings. Ultimately, it will end up turning this from an O(n) algorithm into an O(log n) algorithm or logarithmic time.\n\nTo analyze the above optimizations I wrote this code:\n\nAs you can see in the benchmark output reversing your own string is extremely less efficient than using [::-1]. The main optimization in our two pointer algorithm is the ability to break the loop early when we see two different characters in our palindrome check. This demonstrates the efficiency of writing your business logic in a way you can fail fast and do operations in your input in a way to do them as needed and verify as soon as possible."
    },
    {
        "link": "https://plainenglish.io/blog/the-best-and-worst-way-of-solving-the-palindrome-question",
        "document": "I have had a few technical interviews lately asking questions that are variations or actually include the palindrome question. This is why I thought it would be relevant to shed some light on how I learned to solve this interview question in the hopes that someone could benefit from how to solve it by reading how I did it.\n\nAs far as I know there are 4 ways of solving this question, but when I refer to the best or worst way I am referring to best and worst big-O notation in both time and space complexity. I should also note that I will be solving this problem in JavaScript.\n\nA typical string manipulation question, the palindrome question states that if given a string that is not empty, to write a function that will determine if the word or words is spelled the same forwards and backwards.\n\nThe final output to determine this could be true or false as anything in JavaScript has a truthy or falsy value anyways. This doesn’t necessarily mean that you have to return the boolean true or false each time however. In other words if you are trying to test an if condition in a function by saying that it needs to return some kind of specific answer, but the input given as an argument would not make it possible to return that answer, then it would return false if tested in a JavaScript console.\n\nApproach Summary: The worst way would be to create a new string and go through each letter backwards from the original string to put every letter in reverse and then compare the two strings.\n\nHow to solve: We’ll start by defining the function’s name which it is determining if a string is a palindrome so it is named relevantly. Our input would be the string every time the function is called.\n\nNext we’ll set a variable for our eventual reversed string:\n\nNow to go through the string itself to concatenate the reversed string we will make a for loop, but it will start from the last letter of the string (let i = string.length -1), then it will keep going until it reaches the first letter of the input (i>=0), and i which represents each index, will decrease every time it runs (i --).\n\nNow to put what goes inside the loop I am using the += operator to concatenate every letter into my empty string which will represent my first string backwards. String[i] represents each letter and it is important to remember that reversedString += string[i] is the same as reversedString = reversedString + string[i].\n\nThis next line will be written to return a truthy value where the original string is the same as the reversed string.\n\nAltogether it looks like the following:\n\nWhere this solution fails to be the best would be the fact that it has a big-O notation of O(n^2) for time complexity, not the best on the charts, and O(n) on the space complexity side, pretty good. However this compared to the second solution, clearly shows the other solution having a better time and space complexity, which I will get into soon. The important takeaway to see here is this solution has a bad of a time complexity mainly because the program has to create a brand new string which takes longer.\n\nBest way — Using the pointer system to compare the furthest left and right side\n\nApproach Summary: On the other hand, the best way to solve this problem would be to define a left and right pointer and compare the letter that each is pointing to. Then using a while loop, while the right pointer is on the right and while the left pointer is on the left, if at any point in time the letters the pointers are pointing to are not the same then return false. Otherwise, return true.\n\nHow to solve: To begin solving this, it starts off the same way as the last to set up a function where we choose an appropriate name and the input is still the string given.\n\nThis time however we are going to set two variables to represent the left and right pointers. The left pointer will represent the first index of the string which starts at 0. To compliment the left, we have a right pointer set equal to the string’s length -1 which represents the furthest number on the right, or last index.\n\nNow using the while loop we will say that we want to run the following logic while the left pointer is on the left side compared to the right pointer.\n\nOur logic will contain an if condition that says that if the left letter is not the same as the right letter the first time the loop goes through, then return false. Which means that if our string was “abcbz” and if “a” was not the same as “z” then it would return false at this point.\n\nLet’s say our string was “abcba” though. The letter “a” and letter “a” on the both ends are the same so it would pass the return false line area and go to the next line which will increment or decrement depending on what it is. If it is a left pointer it will move more to the right and vice versa so that the pointers can compare both sides of the string.\n\nNow once the pointers are at the same point in the middle, the program will break out of the while loop and will run into the return true statement because that would indicate it never made the if condition true where both sides aren’t the same. This would mean it is a palindrome.\n\nFinal results for this solution look like this:\n\nAt the end of it all, we are left with a time complexity of O(n) and a space complexity of O(1). Why does this approach have better time and space complexity? This is because it doesn’t have to create a new string, all the program has to do is use some simple pointers working with the same size of an input and ultimately return true or false which takes less time than the first solution.\n\nThe palindrome question does a great job testing developer’s basic understanding of how to manipulate a string. It is a problem simple enough to solve to have a clearer chance to understand the reasons behind the big-O notations given to each which developers can use in more complicated problems down the road. I hope that this shorter blog was simple enough to help you understand how to solve this question by ultimately breaking down the parts of each solution and give some insight into how big-O notations are given. Until next time!"
    },
    {
        "link": "https://geeksforgeeks.org/backtracking-algorithm-in-python",
        "document": "Backtracking is a problem-solving algorithmic technique that involves finding a solution incrementally by trying different options and undoing them if they lead to a dead end. The backtracking algorithm is a recursive algorithm that is used to solve problems by making a series of choices, and if a choice leads to a dead end, it backtracks to the last valid choice made and tries a different path. It is often used to solve problems such as the N-Queens puzzle, Sudoku, and the Knight's Tour.\n\nA backtracking algorithm works by recursively exploring all possible solutions to a problem. It starts by choosing an initial solution, and then it explores all possible extensions of that solution. If an extension leads to a solution, the algorithm returns that solution. If an extension does not lead to a solution, the algorithm backtracks to the previous solution and tries a different extension.\n\nThe following is a general outline of how a backtracking algorithm works:\n• None Explore all possible extensions of the current\n• None If an extension leads to a solution, return\n• None If an extension does not lead to a solution, backtrack previous solution and try a different extension.\n• None Repeat steps 2-4 until all possible solutions have been explored.\n\nIt is commonly used in situations where you need to explore multiple possibilities to solve a problem, like searching for a path in a maze or solving puzzles like Sudoku. When a dead end is reached, the algorithm backtracks to the previous decision point and explores a different path until a solution is found or all possibilities have been exhausted.\n\nImplement the Backtracking algorithm to solve the N-Queens problem in Python.\n• None Start placing queens on the chessboard, one column\n• queen in a column, check if it is safe to place the queen in that position.\n• None If the queen can be placed safely, proceed to the next column recursively\n• None If no safe position is found, backtrack previous column and try the next position\n• None Repeat the process until all queens are placed on the chessboard or all possibilities are explored.\n\nBelow is the implementation of the above idea:"
    },
    {
        "link": "https://geeksforgeeks.org/backtracking-algorithms",
        "document": "Backtracking algorithms are like problem-solving strategies that help explore different options to find the best solution. They work by trying out different paths and if one doesn't work, they backtrack and try another until they find the right one. It's like solving a puzzle by testing different pieces until they fit together perfectly.\n• None Check if a given string is sum-string\n• None Count all possible paths between two vertices\n• None Find all distinct subsets of a given set\n• None Find if there is a path of more than k length from a source\n• None Print all paths from a given source to a destination\n• None Print all possible strings that can be made by placing spaces\n• None Find paths from corner cell to middle cell in maze\n• None Find Maximum number possible by doing at-most K swaps\n• None Rat in a Maze with multiple steps or jump allowed\n• None Partition of a set into K subsets with equal sum\n• None Longest Possible Route in a Matrix with Hurdles\n\nBacktracking is a problem-solving algorithmic technique that involves finding a solution incrementally by trying different options and undoing them if they lead to a dead end.\n\nIt is commonly used in situations where you need to explore multiple possibilities to solve a problem, like searching for a path in a maze or solving puzzles like Sudoku. When a dead end is reached, the algorithm backtracks to the previous decision point and explores a different path until a solution is found or all possibilities have been exhausted.\n\nA backtracking algorithm works by recursively exploring all possible solutions to a problem. It starts by choosing an initial solution, and then it explores all possible extensions of that solution. If an extension leads to a solution, the algorithm returns that solution. If an extension does not lead to a solution, the algorithm backtracks to the previous solution and tries a different extension.\n\nThe following is a general outline of how a backtracking algorithm works:\n• None Explore all possible extensions of the current solution.\n• None If an extension leads to a solution, return that solution.\n• None If an extension does not lead to a solution, backtrack to the previous solution and try a different extension.\n• None Repeat steps 2-4 until all possible solutions have been explored.\n\nExample: Finding the shortest path through a maze\n\nInput: A maze represented as a 2D array, where 0 represents an open space and 1 represents a wall.\n• None For each of the four possible directions (up, down, left, right), try moving in that direction.\n• None If moving in that direction leads to the ending point, return the path taken.\n• None If moving in that direction does not lead to the ending point, backtrack to the previous position and try a different direction.\n• None Repeat steps 2-4 until the ending point is reached or all possible paths have been explored.\n\nWhen to Use a Backtracking Algorithm?\n\nBacktracking algorithms are best used to solve problems that have the following characteristics:\n• None There are multiple possible solutions to the problem.\n• None The problem can be broken down into smaller subproblems.\n• None The subproblems can be solved independently.\n\nBacktracking algorithms are used in a wide variety of applications, including:\n• None Combinatorial problems, such as generating permutations, combinations, or subsets."
    },
    {
        "link": "https://stackoverflow.com/questions/60908042/backtracking-in-a-recursive-maze-python",
        "document": "I'm coding a maze solving algorithm and I'm having trouble with the backtracking once you hit a \"wall\"\n\nSo far I have that my code checks some basic recursive cases such as if I've reached the end or if I have checked all points. I've also made it so that there's a list that keeps track of the solution \"path\" and adds and removes points accordingly. So every time it adds a point, it checks if its valid and checks the point, above, to the left, to the right, and below etc. If none are valid then this statement is executed\n\nthis removes the point and backtracks and checks the following conditions at the beginning of the function.\n\nHowever when I execute the last line, it just removes all the points in my path and i get an indexing error.\n\nAny advice on how I can backtrack once I hit a dead end?"
    },
    {
        "link": "https://inventwithpython.com/recursion/chapter3.html",
        "document": "If you take a computer science course, the unit on recursion is sure to cover some of the classic algorithms presented in this chapter. Coding interviews (which, for lack of suitable ways to evaluate candidates, often crib notes from freshman computer science curricula) can touch upon them too. This chapter covers six classic problems in recursion, along with their solutions.\n\nWe begin with three simple algorithms: summing the numbers in an array, reversing a text string, and detecting whether a string is a palindrome. Then we explore an algorithm for solving the Tower of Hanoi puzzle, implement the flood fill drawing algorithm, and tackle the absurdly recursive Ackermann function.\n\nIn the process, you’ll learn about the head-tail technique for splitting up the data in the recursive function arguments. We’ll also ask ourselves three questions when trying to come up with recursive solutions: What is the base case? What argument is passed to the recursive function call? And how do the arguments passed to the recursive function calls become closer to the base case? As you gain more experience, answering these questions should come more naturally.\n\nOur first example is simple: given a list (in Python) or an array (in JavaScript) of integers, return the total sum of all the integers. For example, a call such as should return .\n\nThis is easy to solve with a loop, but solving it with recursion requires more thought. After reading Chapter 2, you might also notice that this algorithm doesn’t map well enough to recursion’s capabilities to justify recursion’s added complexity. Still, summing numbers in an array (or some other calculation based on processing data in a linear data structure) is a common enough recursion problem in coding interviews that it deserves our attention.\n\nTo solve this problem, let’s examine the head-tail technique for implementing recursive functions. This technique splits the recursive function’s array argument into two parts: the head (the first element of the array) and the tail (a new array including everything after the first element). We define the recursive function to find the sum of the array argument’s integers by adding the head to the sum of the tail array. To find out the sum of the tail array, we recursively pass it as the array argument to .\n\nBecause the tail array is one element smaller than the original array argument, we’ll eventually end up calling the recursive function and passing it an empty array. An empty array argument is trivial to sum and doesn’t require more recursive calls; it is merely . From these facts, our answers to the three questions are as follows:\n• None What is the base case? An empty array, which has the sum of .\n• None What argument is passed to the recursive function call? The tail of the original number array, which has one less number than the original array argument.\n• None How does this argument become closer to the base case? The array argument shrinks by one element for each recursive call until it becomes a zero-length, or empty, array.\n\nHere is sumHeadTail.py, a Python program to sum a list of numbers:\n\nAnd here is the equivalent JavaScript program, sumHeadTail.html:\n\nThe output of these programs is shown here:\n\nWhen called with an empty array argument, the base case of our function simply returns ❶. In the recursive case, we form the head ❷ and the tail ❸ from the original argument. Keep in mind that the data type of is an array of numbers, just like the argument. But the data type of is just a single number value, and not an array with one number value. The return value of the function is also a single number value and not an array of numbers; this is why we can add and together in the recursive case ❹.\n\nEach recursive call passes a smaller and smaller array to , bringing it closer to the base case of an empty array. For example, Figure 3-1 shows the state of the call stack for .\n\nIn this figure, each card in the stack represents a function call. At the top of each card is the function name with the argument it was passed when called. Beneath that are the local variables: the parameter, and the and local variables created during the call. At the bottom of the card is the expression that the function call returns. When a new recursive function is made, a new card is pushed to the stack. When the function call returns, the top card is popped from the stack.\n\nWe can use the function as a template for applying the head-tail technique to other recursive functions. For example, you can change the function from one that sums an array of numbers to a function that concatenates an array of strings together. The base case would return an empty string for an empty array argument, while the recursive case would return the head string joined with the return value of the recursive call that is passed the tail.\n\nRecall from Chapter 2 that recursion is especially suited for problems that involve a tree-like structure and backtracking. An array, string, or other linear data structure can be considered a tree-like structure, albeit a tree that has only one branch at each node, as in Figure 3-2.\n\nThe key “tell” that our recursive function is unnecessary is that it never does any backtracking over the data it processes. It makes a single pass over each element in the array from beginning to end, which is something a basic loop can accomplish. Additionally, the Python recursive summation function is about 100 times slower than a straightforward iterative algorithm. Even if performance weren’t an issue, the recursive function would cause a stack overflow if passed a list with tens of thousands of numbers to sum. Recursion is an advanced technique, but it isn’t always the best approach.\n\nIn Chapter 5, we’ll examine a recursive summation function that uses a divide-and-conquer strategy, and in Chapter 8 we’ll examine one that uses tail call optimization. These alternate recursive approaches work around some of the problems in the summation function in this chapter.\n\nLike summing the numbers in an array, reversing a string is another frequently cited recursive algorithm even though the iterative solution is straightforward. Because a string is essentially an array of single characters, we’ll employ the head and tail approach for our function just as we did for the summation algorithm.\n\nLet’s start with the smallest strings possible. A blank string and a single-character string are already the reverse of themselves. These naturally form our base cases: if the string argument is a string such as or , our function should simply return the string argument.\n\nFor larger strings, let’s try splitting the string into a head (just the first character) and tail (all characters after the first). For a two-character string like , is the head and is the tail. To reverse the string, we need to place the head behind the tail: .\n\nDoes this algorithm hold for longer strings? To reverse a string like , we would break it into the head and the tail . But placing the head behind the tail alone doesn’t reverse the string; it gives us . What we actually want to do is put the head behind the reverse of the tail. In other words, would reverse to , and then adding the head to the end of that would produce the reversed string, .\n\nHow can we reverse the tail? Well, we can recursively call and pass it the tail. Forget about the implementation of our function for a moment and focus on its input and output: takes one string argument and returns a string with the argument’s characters reversed.\n\nThinking about how to implement a recursive function like can be difficult because it involves a chicken-and-egg problem. In order to write ’s recursive case, we need to call a function that reverses a string—that is, . As long as we have a solid understanding of what our recursive function’s arguments and return value will be, we can use the leap-of-faith technique to get around this chicken-and-egg problem by writing our recursive case assuming the function call returns the correct value even though we haven’t finished writing it yet.\n\nTaking a leap of faith in recursion is not a magical technique that guarantees your code works bug free. It is merely a perspective to hold to break past the mental programmer’s block you can have when thinking about how to implement your recursive function. The leap of faith requires you to have a firm understanding of your recursive function’s arguments and return value.\n\nNote that the leap-of-faith technique only helps you write the recursive case. You must pass to the recursive call an argument that is closer to the base case. You can’t simply pass the same argument that the recursive function received, like this:\n\nTo continue our example, when we pass the tail to , the head is and the tail is in that function call. We already know that the reverse of a single-character string like is simply ; that’s our base case. So this second call to will reverse to , which is precisely what the previous call to needs. Figure 3-3 shows the state of the call stack during all the recursive calls to .\n\nLet’s ask our three recursive algorithm questions about the function:\n• None What is the base case? A zero- or one-character string.\n• None What argument is passed to the recursive function call? The tail of the original string argument, which has one less character than the original string argument.\n• None How does this argument become closer to the base case? The array argument shrinks by one element for each recursive call until it becomes a one- or zero-length array.\n\nHere is reverseString.py, a Python program to reverse a string:\n\nAnd here is the equivalent JavaScript code in reverseString.html:\n\nHere is the output of these programs:\n\nOur recursive function returns the string that is the reverse of the argument, . Let’s consider the simplest strings to reverse: the empty string and a single-character string would “reverse” to themselves. These are the two base cases with which we’ll start (though we combine them with an or Boolean operator ❶). For the recursive case, we form from the first character in ❷, and from every character after the first ❸. The recursive case then returns the reverse of followed by the character ❹.\n\nA palindrome is a word or phrase that is spelled the same when written forward and backward. Level, race car, taco cat, and a man, a plan, a canal . . . Panama are all examples of palindromes. If you would like to detect whether a string is a palindrome, you can write a recursive function.\n\nThe base case is a zero- or one-character string, which by its nature is always the same, whether forward or backward. We’ll use an approach similar to the head-tail technique, except that we’ll split the string argument into head, middle, and last strings instead. If the head and last characters are the same and the middle characters also form a palindrome, the string is a palindrome. The recursion comes from passing the middle string to .\n\nLet’s ask the three recursive algorithm questions about the function:\n• None What is the base case? A zero- or one-character string, which returns because it is always a palindrome.\n• None What argument is passed to the recursive function call? The middle characters of the string argument.\n• None How does this argument become closer to the base case? The string argument shrinks by two characters for each recursive call until it becomes a zero- or one-character string.\n\nHere is palindrome.py, a Python program to detect palindromes:\n\nHere is the equivalent JavaScript code in palindrome.html:\n\nHere is the output of these programs:\n\nThe base case returns because a zero- or one-character string is always a palindrome. Otherwise, the string argument is broken into three pieces: the first character ❶, the last character ❸, and the middle characters between them ❷.\n\nThe statement in the recursive case ❹ makes use of Boolean short-circuiting, a feature of almost every programming language. In an expression joined with the or Boolean operators, if the left-side expression is , it doesn’t matter if the right-side expression is or because the entire expression will be . Boolean short-circuiting is an optimization that skips the evaluation of the right-side expression of an operator if the left side is . So, in the expression , if is , the recursive call to is skipped. This means that as soon as the head and last strings don’t match, the recursion stops and simply returns .\n\nThis recursive algorithm is still sequential, like the summation and reverse-string functions in the previous sections, except that instead of going from the start of the data to the end, it goes from both ends of the data toward the middle. The iterative version of this algorithm that uses a simple loop is more straightforward. We cover the recursive version in this book because it’s a common coding interview problem.\n\nThe Tower of Hanoi is a puzzle involving a tower of stacked disks. The puzzle begins with the largest disk on the bottom, and the disk sizes decrease going up. Each disk has a hole in its center so that the disks can be stacked on top of one another on a pole. Figure 3-4 shows a wooden Tower of Hanoi puzzle.\n\nTo solve the puzzle, the player must move the stack of disks from one pole to another while following three rules:\n• The player can move only one disk at a time.\n• The player can move disks only to and from the top of a tower.\n• The player can never place a larger disk on top of a smaller disk.\n\nPython’s built-in module has a Tower of Hanoi demonstration that you can see by running on Windows or on macOS/Linux, and then selecting minimum_hanoi from the Examples menu. Tower of Hanoi animations are readily found through an internet search as well.\n\nThe recursive algorithm for solving the Tower of Hanoi puzzle is not intuitive. Let’s start with the smallest case: a Tower of Hanoi with one disk. The solution is trivial: move the disk to another pole and you’re finished. Solving for two disks is slightly more complicated: move the smaller disk to one pole (we’ll call it the temporary pole) and the larger disk to the other pole (we’ll call it the end pole), and then finally move the smaller disk from the temporary pole to the end pole. Both disks are now on the end pole in the correct order.\n\nOnce you solve the three-disk tower, you’ll notice that a pattern emerges. To solve a tower of n disks from the start pole to the end pole, you must do the following:\n• Solve the n – 1 disks puzzle by moving those disks from the start pole to the temporary pole.\n• Move the nth disk from the start pole to the end pole.\n• Solve the n – 1 disks puzzle by moving those disks from the temporary pole to the end pole.\n\nLike the Fibonacci algorithm, the recursive case for the Tower of Hanoi algorithm makes two recursive calls instead of just one. If we draw a tree diagram of the operations for solving a four-disk Tower of Hanoi, it looks like Figure 3-5. Solving the four-disk puzzle requires the same steps as solving the three-disk puzzle, as well as moving the fourth disk and performing the steps of solving the three-disk puzzle again. Likewise, solving the three-disk puzzle requires the same steps as the two-disk puzzle plus moving the third disk, and so on. Solving the one-disk puzzle is the trivial base case: it involves only moving the disk.\n\nThe tree-like structure in Figure 3-5 hints that a recursive approach is ideal for solving the Tower of Hanoi puzzle. In this tree, the execution moves from top to bottom and from left to right.\n\nWhile a three-disk or four-disk Tower of Hanoi is easy for a human to solve, increasing numbers of disks require an exponentially increasing number of operations to complete. For n disks, it takes a minimum of 2^n – 1 moves to solve. This means a 30-disk tower requires over a billion moves to complete!\n\nLet’s ask ourselves the three questions for creating a recursive solution:\n• None What is the base case? Solving a tower of one disk.\n• None What argument is passed to the recursive function call? Solving a tower of size one less than the current size.\n• None How does this argument become closer to the base case? The size of the tower to solve decreases by one disk for each recursive call until it is a one-disk tower.\n\nThe following towerOfHanoiSolver.py program solves the Tower of Hanoi puzzle and displays a visualization of each step:\n\nThis towerOfHanoiSolver.html program contains the equivalent JavaScript code:\n\nWhen you run this code, the output shows each move of the disks until the entire tower has moved from Tower A to Tower B:\n\nThe Python version has an interactive mode too, where you can solve the puzzle yourself. Uncomment the lines of code at the end of towerOfHanoiSolver.py to play the interactive version.\n\nYou can start by running the program with the smaller cases by setting the constant ❶ at the top of the program to or . In our program, a list of integers in Python and an array of integers in JavaScript represent a pole. The integer represents a disk, with larger integers representing larger disks. The integer at the start of the list or array is at the bottom of the pole, and the integer at the end is at the pole’s top. For example, represents the starting pole with six disks with the largest on the bottom, while represents a pole with no disks. The variable contains three of these lists ❷.\n\nThe base case merely moves the smallest disk from the start pole to the end pole ❸. The recursive case for a tower of n disks carries out three steps: solving the n – 1 case ❹, moving the nth disk ❺, and then solving the n – 1 case again ❻.\n\nGraphics programs commonly use the flood fill algorithm to fill an arbitrarily shaped area of the same color with another color. Figure 3-6 shows one such shape at the top left. The subsequent panels show three different sections of the shape flood-filled with a gray color. The flood fill begins on a white pixel and spreads until it meets a non-white pixel, filling the enclosed space.\n\nThe flood fill algorithm is recursive: it begins by changing a single pixel to a new color. The recursive function is then called on any neighbors of the pixel with its same old color. It then moves on to the neighbors of the neighbors, and so on, converting each pixel to the new color until the enclosed space is filled in.\n\nThe base case is a pixel whose color is the edge of the image or is not the old color. Since reaching the base case is the only way to stop the “spread” of recursive calls for every pixel in the image, this algorithm has the emergent behavior of changing all the contiguous pixels from the old color to the new color.\n\nLet’s ask the three recursive algorithm questions about our function:\n• None What is the base case? When the x- and y-coordinates are for a pixel that is not the old color, or are at the edge of the image.\n• None What arguments are passed to the recursive function call? The x- and y-coordinates of the four neighboring pixels of the current pixel are the arguments to four recursive calls.\n• None How do these arguments become closer to the base case? The neighboring pixels run up to a different color than the old color or the edge of the image. Either way, eventually the algorithm runs out of pixels to check.\n\nInstead of an image for our sample program, we’ll use a list of single-character strings to form a 2D grid of text characters to represent an “image.” Each string represents a “pixel,” and the specific character represents the “color.” The floodfill.py Python program implements the flood fill algorithm, the image data, and a function to print the image on the screen:\n\nThe floodfill.html program contains the equivalent JavaScript code:\n\nWhen you run this code, the program fills the interior of the shape drawn by the characters ❶ starting at coordinates 3, 3. It replaces all the period characters ( ) with characters. The following output shows the before and after images:\n\nIf you want to see every step of the flood fill algorithm as it fills in the new character, uncomment the line in the function and run the program again.\n\nThe image is represented by a 2D array of string characters. We can pass this data structure, an coordinate and a coordinate, and a new character to the function. The function notes the character currently at the and coordinates and saves it to the variable ❷.\n\nIf the current characters at coordinates and in are not the same as , this is our base case, and the function simply returns. Otherwise, the function continues on to its four recursive cases: passing the x- and y-coordinates of the bottom ❸, top ❹, right ❺, and left ❻ neighbors of the current coordinates. After these four potential recursive calls are made, the end of the function is an implicit base case, made explicit in our program with a statement ❼.\n\nThe flood fill algorithm doesn’t have to be recursive. For large images, a recursive function could cause stack overflows. If we were to implement flood fill with a loop and a stack instead, the stack would begin with the x- and y-coordinates of the starting pixel. The code in the loop would pop the coordinates off the top of the stack, and if that coordinate’s pixel matches , it would push the coordinates of the four neighboring pixels. When the stack is empty because the base case is no longer pushing neighbors to the stack, the loop is finished.\n\nHowever, the flood fill algorithm doesn’t necessarily have to use a stack. The pushing and popping of a first-in, last-out stack is effective for backtracking behavior, but the order that the pixels are processed in the flood fill algorithm can be arbitrary. This means we could equally effectively use a set data structure that removes elements randomly. You can find these iterative flood fill algorithms implemented in floodFillIterative.py and floodFillIterative.html in the downloadable resources at https://nostarch.com/recursive-book-recursion.\n\nThe Ackermann function is named after its discoverer, Wilhelm Ackermann. A student of mathematician David Hilbert (whose Hilbert curve fractal we discuss in Chapter 9), Ackermann published his function in 1928. Mathematicians Rózsa Péter and Raphael Robinson later developed the version of the function featured in this section.\n\nWhile the Ackermann function has some application in advanced mathematics, it is mostly known for being an example of a highly recursive function. Even slight increases to its two integer arguments cause a large increase in the number of recursive calls it makes.\n\nThe Ackermann function takes two arguments, and , and has a base case of returning when is . There are two recursive cases: when is , the function returns , and when is greater than , the function returns . These cases likely aren’t meaningful to you, but suffice it to say, the number of recursive calls the Ackermann function makes grows quickly. Calling results in three recursive function calls. Calling results in 43 recursive function calls. Calling results in 42,437 recursive function calls. And calling results in . . . well, actually I don’t know how many recursive function calls, because it would take several times the age of the universe to calculate.\n\nLet’s answer the three questions we ask when constructing recursive algorithms:\n• None What is the base case? When is .\n• None What arguments are passed to the recursive function call? Either or is passed for the next parameter; and , , or the return value of is passed for the next parameter.\n• None How do these arguments become closer to the base case? The argument is always either decreasing or staying the same size, so it will eventually reach .\n\nHere is an ackermann.py Python program:\n\nAnd here is the equivalent ackermann.html JavaScript program:\n\nWhen you run this code, the output’s indentation (set by the argument) tells you how deep on the call stack the given recursive function call is:\n\nYou can also try , but anything with larger arguments will probably take far too long to calculate. To speed up the calculation, try commenting out all and calls except the ones that print the final return value of .\n\nRemember, even a recursive algorithm like the Ackermann function can be implemented as an iterative function. The iterative Ackermann algorithms are implemented in ackermannIterative.py and ackermannIterative.html in the downloadable resources at https://nostarch.com/recursive-book-recursion.\n\nThis chapter covered some classic recursive algorithms. For each, we asked the three important questions you should always ask when designing your own recursive functions: What is the base case? What arguments are passed to the recursive function call? How do these arguments become closer to the base case? If they don’t, your function will continue to recurse until it causes a stack overflow.\n\nThe summation, string reversing, and palindrome detection recursive functions could have easily been implemented with a simple loop. The key giveaway is that they all make a single pass through the data given to them with no backtracking. As explained in Chapter 2, recursive algorithms are especially suited to problems that involve a tree-like structure and require backtracking.\n\nThe tree-like structures for solving the Tower of Hanoi puzzle suggest that it involves backtracking, as the program execution runs from top to bottom, left to right, in the tree. This makes it a prime candidate for recursion, especially since the solution requires two recursive calls of smaller towers.\n\nThe flood fill algorithm is directly applicable to graphics and drawing programs, as well as other algorithms to detect the shape of contiguous areas. If you’ve used the paint-bucket tool in a graphics program, you’ve likely used a version of the flood fill algorithm.\n\nThe Ackermann function is an excellent example of how quickly a recursive function can grow as its inputs increase. While it doesn’t have many practical applications in day-to-day programming, no discussion about recursion would be complete without it. But as recursive as it is, like all recursive functions it can be implemented iteratively with a loop and a stack.\n\nWikipedia has more information on the Tower of Hanoi problem at https://en.wikipedia.org/wiki/Tower_of_Hanoi, and the Computerphile video “Recursion ‘Super Power’ (in Python)” covers solving the Tower of Hanoi in Python at https://youtu.be/8lhxIOAfDss. The 3Blue1Brown two-part video series, “Binary, Hanoi, and Sierpiński,” goes into even more detail by exploring the relationships among the Tower of Hanoi, binary numbers, and the Sierpiński Triangle fractal starting at https://youtu.be/2SUvWfNJSsM.\n\nWikipedia has an animation of the flood fill algorithm working on a small image at https://en.wikipedia.org/wiki/Flood_fill.\n\nThe Computerphile video “The Most Difficult Program to Compute?” discusses the Ackermann function at https://youtu.be/i7sm9dzFtEI. If you’d like to learn more about the Ackermann function’s place in computability theory, the Hackers in Cambridge channel has a five-part video series on primitive recursive and partial recursive functions at https://youtu.be/yaDQrOUK-KY. The series requires a lot of mathematical thinking on the part of the viewer, but you don’t need a lot of prior mathematical knowledge.\n\nTest your comprehension by answering the following questions:\n• What is the head of an array or string?\n• What is the tail of an array or string?\n• What are the three questions this chapter presents for each recursive algorithm?\n• What is the leap of faith in recursion?\n• What do you need to understand about the recursive function you are writing before you can take a leap of faith?\n• How does a linear data structure such as an array or string resemble a tree-like structure?\n• Does the recursive function involve any backtracking over the data it works on?\n• In the flood fill program, try changing the variable’s strings to create a C shape that is not fully enclosed. What happens when you attempt to flood-fill the image from the middle of the C?\n• Answer the three questions about recursive solutions for each of the recursive algorithms presented in this chapter:\n• What is the base case?\n• What argument is passed to the recursive function call?\n• How does this argument become closer to the base case? Then re-create the recursive algorithms from this chapter without looking at the original code.\n\nFor practice, write a function for each of the following tasks:\n• Using the head-tail technique, create a recursive function that is passed an array of strings and returns these strings concatenated together into a single string. For example, should return .\n• Using the head-tail technique, create a recursive function that is passed an array of integers and returns the total multiplied product of them. This code will be almost identical to the function in this chapter. However, note that the base case of an array with just one integer returns the integer, and the base case of an empty array returns .\n• Using the flood fill algorithm, count the number of “rooms,” or enclosed spaces, in a 2D grid. You can do this by creating nested loops that call the flood fill function on each character in the grid if it is a period, in order to change the periods into hash characters. For example, the following data would result in the program finding six places in the grid with periods, meaning there are five rooms (and the space outside all the rooms)."
    },
    {
        "link": "https://realpython.com/python-thinking-recursively",
        "document": "Problems (in life and also in computer science) can often seem big and scary. But if we keep chipping away at them, more often than not we can break them down into smaller chunks trivial enough to solve. This is the essence of thinking recursively, and my aim in this article is to provide you, my dear reader, with the conceptual tools necessary to approach problems from this recursive point of view.\n\nTogether, we’ll learn how to work with recursion in our Python programs by mastering concepts such as recursive functions and recursive data structures. We’ll also talk about maintaining state during recursion and avoiding recomputation by caching results. This is going to be a lot of fun. Onwards and upwards!\n\nI realize that as fellow Pythonistas we are all consenting adults here, but children seem to grok the beauty of recursion better. So let’s not be adults here for a moment and talk about how we can use recursion to help Santa Claus. Have you ever wondered how Christmas presents are delivered? I sure have, and I believe Santa Claus has a list of houses he loops through. He goes to a house, drops off the presents, eats the cookies and milk, and moves on to the next house on the list. Since this algorithm for delivering presents is based on an explicit loop construction, it is called an iterative algorithm. The algorithm for iterative present delivery implemented in Python: But I feel for Santa. At his age, he shouldn’t have to deliver all the presents by himself. I propose an algorithm with which he can divide the work of delivering presents among his elves:\n• Appoint an elf and give all the work to him\n• Assign titles and responsibilities to the elves based on the number of houses for which they are responsible:\n• He is a manager and can appoint two elves and divide his work among them\n• He is a worker and has to deliver the presents to the house assigned to him This is the typical structure of a recursive algorithm. If the current problem represents a simple case, solve it. If not, divide it into subproblems and apply the same strategy to them. The algorithm for recursive present delivery implemented in Python: # Each function call represents an elf doing his work # Divides his work among two elves\n\nNow that we have some intuition about recursion, let’s introduce the formal definition of a recursive function. A recursive function is a function defined in terms of itself via self-referential expressions. This means that the function will continue to call itself and repeat its behavior until some condition is met to return a result. All recursive functions share a common structure made up of two parts: base case and recursive case. To demonstrate this structure, let’s write a recursive function for calculating :\n• Decompose the original problem into simpler instances of the same problem. This is the recursive case:\n• As the large problem is broken down into successively less complex ones, those subproblems must eventually become so simple that they can be solved without further subdivision. This is the base case: Here, is our base case, and it equals . Behind the scenes, each recursive call adds a stack frame (containing its execution context) to the call stack until we reach the base case. Then, the stack begins to unwind as each call returns its results:\n\nWhen dealing with recursive functions, keep in mind that each recursive call has its own execution context, so to maintain state during recursion you have to either:\n• Thread the state through each recursive call so that the current state is part of the current call’s execution context\n• Keep the state in global scope A demonstration should make things clearer. Let’s calculate using recursion. The state that we have to maintain is (current number we are adding, accumulated sum till now). Here’s how you do that by threading it through each recursive call (i.e. passing the updated current state to each recursive call as arguments): # Thread the state through the recursive call Here’s how you maintain the state by keeping it in global scope: I prefer threading the state through each recursive call because I find global mutable state to be evil, but that’s a discussion for a later time.\n\nA data structure is recursive if it can be deﬁned in terms of a smaller version of itself. A list is an example of a recursive data structure. Let me demonstrate. Assume that you have only an empty list at your disposal, and the only operation you can perform on it is this: # Return a new list that is the result of # adding element to the head (i.e. front) of input_list Using the empty list and the operation, you can generate any list. For example, let’s generate :\n• Starting with an empty list, you can generate any list by recursively applying the function, and thus the list data structure can be defined recursively as:\n• Recursion can also be seen as self-referential function composition. We apply a function to an argument, then pass that result on as an argument to a second application of the same function, and so on. Repeatedly composing with itself is the same as calling itself repeatedly. List is not the only recursive data structure. Other examples include set, tree, dictionary, etc. Recursive data structures and recursive functions go together like bread and butter. The recursive function’s structure can often be modeled after the definition of the recursive data structure it takes as an input. Let me demonstrate this by calculating the sum of all the elements of a list recursively: # Decompose the original problem into simpler instances of the same problem # by making use of the fact that the input is a recursive data structure # and can be deﬁned in terms of a smaller version of itself\n\nThe Fibonacci numbers were originally deﬁned by the Italian mathematician Fibonacci in the thirteenth century to model the growth of rabbit populations. Fibonacci surmised that the number of pairs of rabbits born in a given year is equal to the number of pairs of rabbits born in each of the two previous years, starting from one pair of rabbits in the ﬁrst year. To count the number of rabbits born in the nth year, he deﬁned the recurrence relation: Naively following the recursive deﬁnition of the nth Fibonacci number was rather inefficient. As you can see from the output above, we are unnecessarily recomputing values. Let’s try to improve by caching the results of each Fibonacci computation F : is a decorator that caches the results. Thus, we avoid recomputation by explicitly checking for the value before trying to compute it. One thing to keep in mind about is that since it uses a dictionary to cache results, the positional and keyword arguments (which serve as keys in that dictionary) to the function must be hashable.\n\nPython doesn’t have support for tail-call elimination. As a result, you can cause a stack overflow if you end up using more stack frames than the default call stack depth: Keep this limitation in mind if you have a program that requires deep recursion. Also, Python’s mutable data structures don’t support structural sharing, so treating them like immutable data structures is going to negatively affect your space and GC (garbage collection) efficiency because you are going to end up unnecessarily copying a lot of mutable objects. For example, I have used this pattern to decompose lists and recurse over them: I did that to simplify things for the sake of clarity. Keep in mind that tail is being created by copying. Recursively doing that over large lists can negatively affect your space and GC efficiency."
    }
]