[
    {
        "link": "https://geeksforgeeks.org/python-mapping-key-values-to-dictionary",
        "document": "We are given two list and we need to map key to values of another list so that it becomes dictionary. For example, we are given two list k = [‘a’, ‘b’, ‘c’] and v = [1, 2, 3] we need to map the keys of list k to the values of list v so that the resultant output should be {‘a’: 1, ‘b’: 2, ‘c’: 3}.\n\nfunction pairs elements from two lists allowing us to create a dictionary using where each key gets mapped to its corresponding value.\n• None zip(k, v) function pairs elements from lists k and v into tuples, and dict() converts these tuples into key-value pairs in dictionary d.\n• None Resulting dictionary d is {‘a’: 1, ‘b’: 2, ‘c’: 3}, where each key from k is mapped to its corresponding value in v.\n\nDictionary comprehension iterates through the indices of key list and maps each key to its corresponding value from value list.\n• None This dictionary comprehension iterates over indices of the list and assigns each key from to its corresponding value from\n• None It ensures that mapping is created efficiently without requiring external functions making it a straightforward approach when both lists have same length.\n\ncreates a dictionary where all keys in are mapped to the same single value , not individual values from list. It is useful when assigning a default value to multiple keys.\n• None creates a dictionary where each key from the list is assigned the same value\n• None This method is useful when initializing multiple keys with a common default value efficiently.\n\nzip(k, v) function pairs corresponding elements from the key and value lists, which map() processes into key-value tuples dict() function then converts these tuples into a dictionary effectively mapping keys to values.\n• None () function pairs each key in k with its corresponding value in v using a lambda function.\n• None dict() function then converts the mapped pairs into a dictionary."
    },
    {
        "link": "https://stackoverflow.com/questions/53765443/how-to-convert-a-mapping-of-ranges-into-a-dictionary",
        "document": "I know how to make basic dictionaries, however, I am not sure whether it would look something like this:\n\nHow can this be converted into a dictionary?\n\nThe short answer is that you should not convert this to a dictionary. This is best suited as a function, and it appears you are just missing your function definition, as I see you are using in your code. Dictionaries are constructed from key-value pairs, and since your conditions involve evaluations, a dictionary is not appropriate. See the function implementation below:\n\nWithout a dict, you could solve the problem like this: import numpy as np GRADES = np.array( [[96.5 , 92.5 , 89.5 , 86.5 , 82.5 , 79.5 , 76.5 , 72.5 , 69.5 , 68.5 , 64.5 ], [ 5.83, 5.5 , 5.16, 4.83, 4.5 , 4.16, 3.83, 3.5 , 3.16, 2.83, 2.5 ]]) def get_grade(grade): try: return GRADES[1][grade > [GRADES[0]][0] except: return 0 This is preferable over a dictionary because builtin dictionaries make a guarantee of orderedness (i.e., that they will iterate in the order that keys/values were inserted) only for >= Python 3.6. Being able to run code over more Python versions is preferable to depending on a specific version detail.\n\nYou can use a dictionary for holding the grading information, but it does not really provide any benefit as you can not use the fast dictionary lookup with those ranges. Instead, I'd suggest using a sorted list of pairs and then using to binary-search the matching score in O(logn). Unzipping the to and is optional here, but IMHO it's a bit cleaner that way. If you don't unzip, you will have to pass a tuple to , e.g.\n\nDicts are especially useful if you want to store key-value pairs and want to be able to retrieve an arbitrary entry really fast. As the other answers show, you only need to go through the sequence of elements and use the value of the first one that matches. So the most straight forward (and probably most efficient) strategy is to use a sequence data type. Here's how that looks like in code: pairs = ( (96.5, 5.83), (92.5, 5.5), (89.5, 5.16), (86.5, 4.83), (82.5, 4.5), (79.5, 4.16), (76.5, 3.83), (72.5, 3.5), (69.5, 3.16), (68.5, 2.83), (64.5, 2.5), ) def get_grade(g): for grade, value in pairs: if g >= grade: return value return 0 Dicts are great, but if you don't need their powers, use something simpler.\n\nAnother option is to use range-key-dict: You can install this Python package with . You would also need to examine the source code for the complexity, since this won't maintain O(1) hashing like regular dictionaries. It might be easier and efficient to just use regular if statements.\n\nIf you can use a 3rd party library, you can use Pandas via . This will be especially efficient if you have a large number of input grades to categorise. import pandas as pd grade_checker = {96.5: 5.83, ..., 64.5: 2.5} keys, values = zip(*sorted(grade_checker.items())) keys += (float('inf'),) # need to add upper boundary for pd.cut input grade = 65.5 res = pd.cut([grade], keys, labels=values).astype(float)[0] # 2.5 See related: How to map numeric data into categories / bins in Pandas dataframe\n\nIf you are using Python before 3.6, you can use (including Python 2.7), otherwise objects are natively insertion-sorted (see here for more)! With that, you can simply iterate over your and return the first range match. # python 3.6+ grade_table = { 96.5: 5.83, ... 64.5: 2.5, } # pre-3.6 from collections import OrderedDict grade_table = OrderedDict(( # this is a tuple of tuples (96.5, 5.83), ... (64.5, 2.5), )) def fn(student_grade): for grade, value in grade_table.iteritems(): if student_grade >= grade: return value return 0 # default Note if you expect your table to change, it probably makes sense to test if your dict is in descending order or always accept an iterable of iterables and then sort 'em (I use a tuple of tuples above, but anything of the same form should work and be easy to sort) Otherwise it will return incorrect results.\n\nI'm not a maths person but thought that interpolation might, maybe, work for this? from numpy import interp ak = [k for k in gc.keys()] av = [v for v in gc.values()] # np.interp needs values from lowest to highest ak.reverse() av.reverse() interp(79, ak, av) >>> 4.105 interp(96, ak, av) >>> 5.78875 interp(64, ak, av) >>> 2.5 You'd need to pad-up to 100 and pad-down because it is interpolation so your data points of interest need to be within sample'able scope."
    },
    {
        "link": "https://stackoverflow.com/questions/71769232/more-elegant-way-to-create-a-python-dictionary-from-a-map-object-and-list",
        "document": "The end result is a dictionary with a keyed on the strings from someList and a value of the object returned from getDatafromFile. The following code I wrote accomplishes this but it seems there should be an easier way with less lines of code.\n\nfrom this point forward is there a more elegant way to do this with less lines of code? Some sort of comprehension, perhaps. I thought about returning the string value and dataframe object back from the function, but it seems asinine to return back a parameter."
    },
    {
        "link": "https://docs.python.org/3/tutorial/datastructures.html",
        "document": "This chapter describes some things you’ve learned about already in more detail, and adds some new things as well.\n\nThe list data type has some more methods. Here are all of the methods of list objects: Add an item to the end of the list. Similar to . Extend the list by appending all the items from the iterable. Similar to . Insert an item at a given position. The first argument is the index of the element before which to insert, so inserts at the front of the list, and is equivalent to . Remove the first item from the list whose value is equal to x. It raises a if there is no such item. Remove the item at the given position in the list, and return it. If no index is specified, removes and returns the last item in the list. It raises an if the list is empty or the index is outside the list range. Remove all items from the list. Similar to . Return zero-based index in the list of the first item whose value is equal to x. Raises a if there is no such item. The optional arguments start and end are interpreted as in the slice notation and are used to limit the search to a particular subsequence of the list. The returned index is computed relative to the beginning of the full sequence rather than the start argument. Return the number of times x appears in the list. Sort the items of the list in place (the arguments can be used for sort customization, see for their explanation). Reverse the elements of the list in place. Return a shallow copy of the list. Similar to . An example that uses most of the list methods: You might have noticed that methods like , or that only modify the list have no return value printed – they return the default . This is a design principle for all mutable data structures in Python. Another thing you might notice is that not all data can be sorted or compared. For instance, doesn’t sort because integers can’t be compared to strings and can’t be compared to other types. Also, there are some types that don’t have a defined ordering relation. For example, isn’t a valid comparison. The list methods make it very easy to use a list as a stack, where the last element added is the first element retrieved (“last-in, first-out”). To add an item to the top of the stack, use . To retrieve an item from the top of the stack, use without an explicit index. For example: It is also possible to use a list as a queue, where the first element added is the first element retrieved (“first-in, first-out”); however, lists are not efficient for this purpose. While appends and pops from the end of list are fast, doing inserts or pops from the beginning of a list is slow (because all of the other elements have to be shifted by one). To implement a queue, use which was designed to have fast appends and pops from both ends. For example: # The first to arrive now leaves # The second to arrive now leaves List comprehensions provide a concise way to create lists. Common applications are to make new lists where each element is the result of some operations applied to each member of another sequence or iterable, or to create a subsequence of those elements that satisfy a certain condition. For example, assume we want to create a list of squares, like: Note that this creates (or overwrites) a variable named that still exists after the loop completes. We can calculate the list of squares without any side effects using: which is more concise and readable. A list comprehension consists of brackets containing an expression followed by a clause, then zero or more or clauses. The result will be a new list resulting from evaluating the expression in the context of the and clauses which follow it. For example, this listcomp combines the elements of two lists if they are not equal: Note how the order of the and statements is the same in both these snippets. If the expression is a tuple (e.g. the in the previous example), it must be parenthesized. # create a new list with the values doubled # apply a function to all the elements # the tuple must be parenthesized, otherwise an error is raised File , line : did you forget parentheses around the comprehension target? # flatten a list using a listcomp with two 'for' List comprehensions can contain complex expressions and nested functions: The initial expression in a list comprehension can be any arbitrary expression, including another list comprehension. Consider the following example of a 3x4 matrix implemented as a list of 3 lists of length 4: The following list comprehension will transpose rows and columns: As we saw in the previous section, the inner list comprehension is evaluated in the context of the that follows it, so this example is equivalent to: which, in turn, is the same as: # the following 3 lines implement the nested listcomp In the real world, you should prefer built-in functions to complex flow statements. The function would do a great job for this use case: See Unpacking Argument Lists for details on the asterisk in this line.\n\nWe saw that lists and strings have many common properties, such as indexing and slicing operations. They are two examples of sequence data types (see Sequence Types — list, tuple, range). Since Python is an evolving language, other sequence data types may be added. There is also another standard sequence data type: the tuple. A tuple consists of a number of values separated by commas, for instance: File , line , in : # but they can contain mutable objects: As you see, on output tuples are always enclosed in parentheses, so that nested tuples are interpreted correctly; they may be input with or without surrounding parentheses, although often parentheses are necessary anyway (if the tuple is part of a larger expression). It is not possible to assign to the individual items of a tuple, however it is possible to create tuples which contain mutable objects, such as lists. Though tuples may seem similar to lists, they are often used in different situations and for different purposes. Tuples are immutable, and usually contain a heterogeneous sequence of elements that are accessed via unpacking (see later in this section) or indexing (or even by attribute in the case of ). Lists are mutable, and their elements are usually homogeneous and are accessed by iterating over the list. A special problem is the construction of tuples containing 0 or 1 items: the syntax has some extra quirks to accommodate these. Empty tuples are constructed by an empty pair of parentheses; a tuple with one item is constructed by following a value with a comma (it is not sufficient to enclose a single value in parentheses). Ugly, but effective. For example: The statement is an example of tuple packing: the values , and are packed together in a tuple. The reverse operation is also possible: This is called, appropriately enough, sequence unpacking and works for any sequence on the right-hand side. Sequence unpacking requires that there are as many variables on the left side of the equals sign as there are elements in the sequence. Note that multiple assignment is really just a combination of tuple packing and sequence unpacking.\n\nPython also includes a data type for sets. A set is an unordered collection with no duplicate elements. Basic uses include membership testing and eliminating duplicate entries. Set objects also support mathematical operations like union, intersection, difference, and symmetric difference. Curly braces or the function can be used to create sets. Note: to create an empty set you have to use , not ; the latter creates an empty dictionary, a data structure that we discuss in the next section. Here is a brief demonstration: # show that duplicates have been removed # Demonstrate set operations on unique letters from two words # letters in a but not in b # letters in a or b or both # letters in both a and b # letters in a or b but not both Similarly to list comprehensions, set comprehensions are also supported:\n\nAnother useful data type built into Python is the dictionary (see Mapping Types — dict). Dictionaries are sometimes found in other languages as “associative memories” or “associative arrays”. Unlike sequences, which are indexed by a range of numbers, dictionaries are indexed by keys, which can be any immutable type; strings and numbers can always be keys. Tuples can be used as keys if they contain only strings, numbers, or tuples; if a tuple contains any mutable object either directly or indirectly, it cannot be used as a key. You can’t use lists as keys, since lists can be modified in place using index assignments, slice assignments, or methods like and . It is best to think of a dictionary as a set of key: value pairs, with the requirement that the keys are unique (within one dictionary). A pair of braces creates an empty dictionary: . Placing a comma-separated list of key:value pairs within the braces adds initial key:value pairs to the dictionary; this is also the way dictionaries are written on output. The main operations on a dictionary are storing a value with some key and extracting the value given the key. It is also possible to delete a key:value pair with . If you store using a key that is already in use, the old value associated with that key is forgotten. It is an error to extract a value using a non-existent key. Performing on a dictionary returns a list of all the keys used in the dictionary, in insertion order (if you want it sorted, just use instead). To check whether a single key is in the dictionary, use the keyword. Here is a small example using a dictionary: The constructor builds dictionaries directly from sequences of key-value pairs: In addition, dict comprehensions can be used to create dictionaries from arbitrary key and value expressions: When the keys are simple strings, it is sometimes easier to specify pairs using keyword arguments:\n\nWhen looping through dictionaries, the key and corresponding value can be retrieved at the same time using the method. When looping through a sequence, the position index and corresponding value can be retrieved at the same time using the function. To loop over two or more sequences at the same time, the entries can be paired with the function. What is your name? It is lancelot. What is your quest? It is the holy grail. What is your favorite color? It is blue. To loop over a sequence in reverse, first specify the sequence in a forward direction and then call the function. To loop over a sequence in sorted order, use the function which returns a new sorted list while leaving the source unaltered. Using on a sequence eliminates duplicate elements. The use of in combination with over a sequence is an idiomatic way to loop over unique elements of the sequence in sorted order. It is sometimes tempting to change a list while you are looping over it; however, it is often simpler and safer to create a new list instead.\n\nThe conditions used in and statements can contain any operators, not just comparisons. The comparison operators and are membership tests that determine whether a value is in (or not in) a container. The operators and compare whether two objects are really the same object. All comparison operators have the same priority, which is lower than that of all numerical operators. Comparisons can be chained. For example, tests whether is less than and moreover equals . Comparisons may be combined using the Boolean operators and , and the outcome of a comparison (or of any other Boolean expression) may be negated with . These have lower priorities than comparison operators; between them, has the highest priority and the lowest, so that A and not B or C is equivalent to (A and (not B)) or C . As always, parentheses can be used to express the desired composition. The Boolean operators and are so-called short-circuit operators: their arguments are evaluated from left to right, and evaluation stops as soon as the outcome is determined. For example, if and are true but is false, A and B and C does not evaluate the expression . When used as a general value and not as a Boolean, the return value of a short-circuit operator is the last evaluated argument. It is possible to assign the result of a comparison or other Boolean expression to a variable. For example, Note that in Python, unlike C, assignment inside expressions must be done explicitly with the walrus operator . This avoids a common class of problems encountered in C programs: typing in an expression when was intended.\n\nSequence objects typically may be compared to other objects with the same sequence type. The comparison uses lexicographical ordering: first the first two items are compared, and if they differ this determines the outcome of the comparison; if they are equal, the next two items are compared, and so on, until either sequence is exhausted. If two items to be compared are themselves sequences of the same type, the lexicographical comparison is carried out recursively. If all items of two sequences compare equal, the sequences are considered equal. If one sequence is an initial sub-sequence of the other, the shorter sequence is the smaller (lesser) one. Lexicographical ordering for strings uses the Unicode code point number to order individual characters. Some examples of comparisons between sequences of the same type: Note that comparing objects of different types with or is legal provided that the objects have appropriate comparison methods. For example, mixed numeric types are compared according to their numeric value, so 0 equals 0.0, etc. Otherwise, rather than providing an arbitrary ordering, the interpreter will raise a exception."
    },
    {
        "link": "https://docs.python.org/3/library/collections.html",
        "document": "This module implements specialized container datatypes providing alternatives to Python’s general purpose built-in containers, , , , and .\n\nA class is provided for quickly linking a number of mappings so they can be treated as a single unit. It is often much faster than creating a new dictionary and running multiple calls. The class can be used to simulate nested scopes and is useful in templating. A groups multiple dicts or other mappings together to create a single, updateable view. If no maps are specified, a single empty dictionary is provided so that a new chain always has at least one mapping. The underlying mappings are stored in a list. That list is public and can be accessed or updated using the maps attribute. There is no other state. Lookups search the underlying mappings successively until a key is found. In contrast, writes, updates, and deletions only operate on the first mapping. A incorporates the underlying mappings by reference. So, if one of the underlying mappings gets updated, those changes will be reflected in . All of the usual dictionary methods are supported. In addition, there is a maps attribute, a method for creating new subcontexts, and a property for accessing all but the first mapping: A user updateable list of mappings. The list is ordered from first-searched to last-searched. It is the only stored state and can be modified to change which mappings are searched. The list should always contain at least one mapping. Returns a new containing a new map followed by all of the maps in the current instance. If is specified, it becomes the new map at the front of the list of mappings; if not specified, an empty dict is used, so that a call to is equivalent to: . If any keyword arguments are specified, they update passed map or new empty dict. This method is used for creating subcontexts that can be updated without altering values in any of the parent mappings. Changed in version 3.4: The optional parameter was added. Property returning a new containing all of the maps in the current instance except the first one. This is useful for skipping the first map in the search. Use cases are similar to those for the keyword used in nested scopes. The use cases also parallel those for the built-in function. A reference to is equivalent to: . Note, the iteration order of a is determined by scanning the mappings last to first: This gives the same ordering as a series of calls starting with the last mapping: Changed in version 3.9: Added support for and operators, specified in PEP 584.\n• None The MultiContext class in the Enthought CodeTools package has options to support writing to any mapping in the chain.\n• None Django’s Context class for templating is a read-only chain of mappings. It also features pushing and popping of contexts similar to the method and the property.\n• None The Nested Contexts recipe has options to control whether writes and other mutations apply only to the first mapping or to any mapping in the chain. This section shows various approaches to working with chained maps. Example of letting user specified command-line arguments take precedence over environment variables which in turn take precedence over default values: Example patterns for using the class to simulate nested contexts: # Child of c, independent from d # Get first key in the chain of contexts The class only makes updates (writes and deletions) to the first mapping in the chain while lookups will search the full chain. However, if deep writes and deletions are desired, it is easy to make a subclass that updates keys found deeper in the chain: 'Variant of ChainMap that allows direct updates to inner scopes' # update an existing key two levels down # new keys get added to the topmost dict # remove an existing key one level down\n\nA counter tool is provided to support convenient and rapid tallies. For example: # Find the ten most common words in Hamlet [('the', 1143), ('and', 966), ('to', 762), ('of', 669), ('i', 631), ('you', 554), ('a', 546), ('my', 514), ('hamlet', 471), ('in', 451)] A is a subclass for counting hashable objects. It is a collection where elements are stored as dictionary keys and their counts are stored as dictionary values. Counts are allowed to be any integer value including zero or negative counts. The class is similar to bags or multisets in other languages. Elements are counted from an iterable or initialized from another mapping (or counter): # a new counter from an iterable Counter objects have a dictionary interface except that they return a zero count for missing items instead of raising a : # count of a missing element is zero Setting a count to zero does not remove an element from a counter. Use to remove it entirely: Changed in version 3.7: As a subclass, inherited the capability to remember insertion order. Math operations on Counter objects also preserve order. Results are ordered according to when an element is first encountered in the left operand and then by the order encountered in the right operand. Counter objects support additional methods beyond those available for all dictionaries: Return an iterator over elements repeating each as many times as its count. Elements are returned in the order first encountered. If an element’s count is less than one, will ignore it. Return a list of the n most common elements and their counts from the most common to the least. If n is omitted or , returns all elements in the counter. Elements with equal counts are ordered in the order first encountered: Elements are subtracted from an iterable or from another mapping (or counter). Like but subtracts counts instead of replacing them. Both inputs and outputs may be zero or negative. Compute the sum of the counts. The usual dictionary methods are available for objects except for two which work differently for counters. This class method is not implemented for objects. Elements are counted from an iterable or added-in from another mapping (or counter). Like but adds counts instead of replacing them. Also, the iterable is expected to be a sequence of elements, not a sequence of pairs. Counters support rich comparison operators for equality, subset, and superset relationships: , , , , , . All of those tests treat missing elements as having zero counts so that returns true. Changed in version 3.10: In equality tests, missing elements are treated as having zero counts. Formerly, and were considered distinct. Several mathematical operations are provided for combining objects to produce multisets (counters that have counts greater than zero). Addition and subtraction combine counters by adding or subtracting the counts of corresponding elements. Intersection and union return the minimum and maximum of corresponding counts. Equality and inclusion compare corresponding counts. Each operation can accept inputs with signed counts, but the output will exclude results with counts of zero or less. Unary addition and subtraction are shortcuts for adding an empty counter or subtracting from an empty counter. Added in version 3.3: Added support for unary plus, unary minus, and in-place multiset operations. Counters were primarily designed to work with positive integers to represent running counts; however, care was taken to not unnecessarily preclude use cases needing other types or negative values. To help with those use cases, this section documents the minimum range and type restrictions.\n• None The class itself is a dictionary subclass with no restrictions on its keys and values. The values are intended to be numbers representing counts, but you could store anything in the value field.\n• None The method requires only that the values be orderable.\n• None For in-place operations such as , the value type need only support addition and subtraction. So fractions, floats, and decimals would work and negative values are supported. The same is also true for and which allow negative and zero values for both inputs and outputs.\n• None The multiset methods are designed only for use cases with positive values. The inputs may be negative or zero, but only outputs with positive values are created. There are no type restrictions, but the value type needs to support addition, subtraction, and comparison.\n• None The method requires integer counts. It ignores zero and negative counts.\n• None For mathematical operations on multisets and their use cases, see Knuth, Donald. The Art of Computer Programming Volume II, Section 4.6.3, Exercise 19.\n• None To enumerate all distinct multisets of a given size over a given set of elements, see :\n\nReturns a new deque object initialized left-to-right (using ) with data from iterable. If iterable is not specified, the new deque is empty. Deques are a generalization of stacks and queues (the name is pronounced “deck” and is short for “double-ended queue”). Deques support thread-safe, memory efficient appends and pops from either side of the deque with approximately the same O(1) performance in either direction. Though objects support similar operations, they are optimized for fast fixed-length operations and incur O(n) memory movement costs for and operations which change both the size and position of the underlying data representation. If maxlen is not specified or is , deques may grow to an arbitrary length. Otherwise, the deque is bounded to the specified maximum length. Once a bounded length deque is full, when new items are added, a corresponding number of items are discarded from the opposite end. Bounded length deques provide functionality similar to the filter in Unix. They are also useful for tracking transactions and other pools of data where only the most recent activity is of interest. Add x to the right side of the deque. Add x to the left side of the deque. Remove all elements from the deque leaving it with length 0. Count the number of deque elements equal to x. Extend the right side of the deque by appending elements from the iterable argument. Extend the left side of the deque by appending elements from iterable. Note, the series of left appends results in reversing the order of elements in the iterable argument. Return the position of x in the deque (at or after index start and before index stop). Returns the first match or raises if not found. Insert x into the deque at position i. If the insertion would cause a bounded deque to grow beyond maxlen, an is raised. Remove and return an element from the right side of the deque. If no elements are present, raises an . Remove and return an element from the left side of the deque. If no elements are present, raises an . Remove the first occurrence of value. If not found, raises a . Reverse the elements of the deque in-place and then return . Rotate the deque n steps to the right. If n is negative, rotate to the left. When the deque is not empty, rotating one step to the right is equivalent to , and rotating one step to the left is equivalent to . Maximum size of a deque or if unbounded. In addition to the above, deques support iteration, pickling, , , , , membership testing with the operator, and subscript references such as to access the first element. Indexed access is O(1) at both ends but slows to O(n) in the middle. For fast random access, use lists instead. # make a new deque with three items # add a new entry to the right side # add a new entry to the left side # show the representation of the deque # list the contents of the deque # list the contents of a deque in reverse # cannot pop from an empty deque : This section shows various approaches to working with deques. Bounded length deques provide functionality similar to the filter in Unix: 'Return the last n lines of a file' Another approach to using deques is to maintain a sequence of recently added elements by appending to the right and popping to the left: A round-robin scheduler can be implemented with input iterators stored in a . Values are yielded from the active iterator in position zero. If that iterator is exhausted, it can be removed with ; otherwise, it can be cycled back to the end with the method: The method provides a way to implement slicing and deletion. For example, a pure Python implementation of relies on the method to position elements to be popped: To implement slicing, use a similar approach applying to bring a target element to the left side of the deque. Remove old entries with , add new entries with , and then reverse the rotation. With minor variations on that approach, it is easy to implement Forth style stack manipulations such as , , , , , , and .\n\nReturn a new dictionary-like object. is a subclass of the built-in class. It overrides one method and adds one writable instance variable. The remaining functionality is the same as for the class and is not documented here. The first argument provides the initial value for the attribute; it defaults to . All remaining arguments are treated the same as if they were passed to the constructor, including keyword arguments. objects support the following method in addition to the standard operations: If the attribute is , this raises a exception with the key as argument. If is not , it is called without arguments to provide a default value for the given key, this value is inserted in the dictionary for the key, and returned. If calling raises an exception this exception is propagated unchanged. This method is called by the method of the class when the requested key is not found; whatever it returns or raises is then returned or raised by . Note that is not called for any operations besides . This means that will, like normal dictionaries, return as a default rather than using . This attribute is used by the method; it is initialized from the first argument to the constructor, if present, or to , if absent. Changed in version 3.9: Added merge ( ) and update ( ) operators, specified in PEP 584. Using as the , it is easy to group a sequence of key-value pairs into a dictionary of lists: When each key is encountered for the first time, it is not already in the mapping; so an entry is automatically created using the function which returns an empty . The operation then attaches the value to the new list. When keys are encountered again, the look-up proceeds normally (returning the list for that key) and the operation adds another value to the list. This technique is simpler and faster than an equivalent technique using : Setting the to makes the useful for counting (like a bag or multiset in other languages): When a letter is first encountered, it is missing from the mapping, so the function calls to supply a default count of zero. The increment operation then builds up the count for each letter. The function which always returns zero is just a special case of constant functions. A faster and more flexible way to create constant functions is to use a lambda function which can supply any constant value (not just zero): Setting the to makes the useful for building a dictionary of sets:\n\nNamed tuples assign meaning to each position in a tuple and allow for more readable, self-documenting code. They can be used wherever regular tuples are used, and they add the ability to access fields by name instead of position index. Returns a new tuple subclass named typename. The new subclass is used to create tuple-like objects that have fields accessible by attribute lookup as well as being indexable and iterable. Instances of the subclass also have a helpful docstring (with typename and field_names) and a helpful method which lists the tuple contents in a format. The field_names are a sequence of strings such as . Alternatively, field_names can be a single string with each fieldname separated by whitespace and/or commas, for example or . Any valid Python identifier may be used for a fieldname except for names starting with an underscore. Valid identifiers consist of letters, digits, and underscores but do not start with a digit or underscore and cannot be a such as class, for, return, global, pass, or raise. If rename is true, invalid fieldnames are automatically replaced with positional names. For example, is converted to , eliminating the keyword and the duplicate fieldname . defaults can be or an iterable of default values. Since fields with a default value must come after any fields without a default, the defaults are applied to the rightmost parameters. For example, if the fieldnames are and the defaults are , then will be a required argument, will default to , and will default to . If module is defined, the attribute of the named tuple is set to that value. Named tuple instances do not have per-instance dictionaries, so they are lightweight and require no more memory than regular tuples. To support pickling, the named tuple class should be assigned to a variable that matches typename. Changed in version 3.6: The verbose and rename parameters became keyword-only arguments. Changed in version 3.7: Removed the verbose parameter and the attribute. Changed in version 3.7: Added the defaults parameter and the attribute. # fields also accessible by name Named tuples are especially useful for assigning field names to result tuples returned by the or modules: In addition to the methods inherited from tuples, named tuples support three additional methods and two attributes. To prevent conflicts with field names, the method and attribute names start with an underscore. Class method that makes a new instance from an existing sequence or iterable. Return a new which maps field names to their corresponding values: Changed in version 3.1: Returns an instead of a regular . Changed in version 3.8: Returns a regular instead of an . As of Python 3.7, regular dicts are guaranteed to be ordered. If the extra features of are required, the suggested remediation is to cast the result to the desired type: . Return a new instance of the named tuple replacing specified fields with new values: Named tuples are also supported by generic function . Changed in version 3.13: Raise instead of for invalid keyword arguments. Tuple of strings listing the field names. Useful for introspection and for creating new named tuple types from existing named tuples. To retrieve a field whose name is stored in a string, use the function: To convert a dictionary to a named tuple, use the double-star-operator (as described in Unpacking Argument Lists): Since a named tuple is a regular Python class, it is easy to add or change functionality with a subclass. Here is how to add a calculated field and a fixed-width print format: The subclass shown above sets to an empty tuple. This helps keep memory requirements low by preventing the creation of instance dictionaries. Subclassing is not useful for adding new, stored fields. Instead, simply create a new named tuple type from the attribute: Docstrings can be customized by making direct assignments to the fields: 'List of authors sorted by last name'\n• None See for a way to add type hints for named tuples. It also provides an elegant notation using the keyword:\n• None See for a mutable namespace based on an underlying dictionary instead of a tuple.\n• None The module provides a decorator and functions for automatically adding generated special methods to user-defined classes.\n\nOrdered dictionaries are just like regular dictionaries but have some extra capabilities relating to ordering operations. They have become less important now that the built-in class gained the ability to remember insertion order (this new behavior became guaranteed in Python 3.7). Some differences from still remain:\n• None The regular was designed to be very good at mapping operations. Tracking insertion order was secondary.\n• None The was designed to be good at reordering operations. Space efficiency, iteration speed, and the performance of update operations were secondary.\n• None The algorithm can handle frequent reordering operations better than . As shown in the recipes below, this makes it suitable for implementing various kinds of LRU caches.\n• None The equality operation for checks for matching order. A regular can emulate the order sensitive equality test with p == q and all(k1 == k2 for k1, k2 in zip(p, q)) .\n• None The method of has a different signature. It accepts an optional argument to specify which item is popped. A regular can emulate OrderedDict’s with which is guaranteed to pop the rightmost (last) item. A regular can emulate OrderedDict’s with which will return and remove the leftmost (first) item if it exists.\n• None has a method to efficiently reposition an element to an endpoint. A regular can emulate OrderedDict’s with which will move the key and its associated value to the rightmost (last) position. A regular does not have an efficient equivalent for OrderedDict’s which moves the key and its associated value to the leftmost (first) position. Return an instance of a subclass that has methods specialized for rearranging dictionary order. The method for ordered dictionaries returns and removes a (key, value) pair. The pairs are returned in order if last is true or order if false. Move an existing key to either end of an ordered dictionary. The item is moved to the right end if last is true (the default) or to the beginning if last is false. Raises if the key does not exist: In addition to the usual mapping methods, ordered dictionaries also support reverse iteration using . Equality tests between objects are order-sensitive and are roughly equivalent to . Equality tests between objects and other objects are order-insensitive like regular dictionaries. This allows objects to be substituted anywhere a regular dictionary is used. Changed in version 3.5: The items, keys, and values views of now support reverse iteration using . Changed in version 3.6: With the acceptance of PEP 468, order is retained for keyword arguments passed to the constructor and its method. Changed in version 3.9: Added merge ( ) and update ( ) operators, specified in PEP 584. It is straightforward to create an ordered dictionary variant that remembers the order the keys were last inserted. If a new entry overwrites an existing entry, the original insertion position is changed and moved to the end: 'Store items in the order the keys were last added' An would also be useful for implementing variants of : \"LRU Cache that invalidates and refreshes old entries.\" it has been requested multiple times. To avoid flushing the LRU cache with one-time requests, we don't cache until a request has been made more than once.\n\nThis class acts as a wrapper around list objects. It is a useful base class for your own list-like classes which can inherit from them and override existing methods or add new ones. In this way, one can add new behaviors to lists. The need for this class has been partially supplanted by the ability to subclass directly from ; however, this class can be easier to work with because the underlying list is accessible as an attribute. Class that simulates a list. The instance’s contents are kept in a regular list, which is accessible via the attribute of instances. The instance’s contents are initially set to a copy of list, defaulting to the empty list . list can be any iterable, for example a real Python list or a object. In addition to supporting the methods and operations of mutable sequences, instances provide the following attribute: A real object used to store the contents of the class. Subclassing requirements: Subclasses of are expected to offer a constructor which can be called with either no arguments or one argument. List operations which return a new sequence attempt to create an instance of the actual implementation class. To do so, it assumes that the constructor can be called with a single parameter, which is a sequence object used as a data source. If a derived class does not wish to comply with this requirement, all of the special methods supported by this class will need to be overridden; please consult the sources for information about the methods which need to be provided in that case."
    },
    {
        "link": "https://datacamp.com/tutorial/python-dictionary-comprehension",
        "document": "Master the basics of data analysis with Python in just four hours. This online course will introduce the Python interface and explore popular packages."
    },
    {
        "link": "https://stackoverflow.com/questions/1747817/create-a-dictionary-with-comprehension",
        "document": "You're looking for the phrase \"dict comprehension\" - it's actually:\n\nAssuming is an iterable of two-tuples - you're so close. Let's create some \"blahs\" like that:\n\nNow the syntax here is the mapping part. What makes this a comprehension instead of a comprehension (which is what your pseudo-code approximates) is the colon, like below:\n\nAnd we see that it worked, and should retain insertion order as-of Python 3.7:\n\nIn Python 2 and up to 3.6, order was not guaranteed:\n\nAll comprehensions feature a mapping component and a filtering component that you can provide with arbitrary expressions.\n\nSo you can add a filter part to the end:\n\nHere we are just testing for if the last character is divisible by 2 to filter out data before mapping the keys and values."
    },
    {
        "link": "https://geeksforgeeks.org/python-dictionary-comprehension",
        "document": "Like List Comprehension, Python allows dictionary comprehensions. We can create dictionaries using simple expressions. A dictionary comprehension takes the form {key: value for (key, value) in iterable}\n\nHere we have two lists named keys and value and we are iterating over them with the help of zip() function.\n\nHere we are using the fromkeys() method that returns a dictionary with specific keys and values.\n\nWe can use Dictionary comprehensions with if and else statements and with other expressions too. This example below maps the numbers to their cubes that are divisible by 4.\n\nHere we are trying to create a nested dictionary with the help of dictionary comprehension.\n\nWhat is Dictionary Comprehension in Python?\n\nHow to Create Dictionaries Using Comprehension in Python?\n\nWhat Are Benefits of Using Dictionary Comprehension in Python?\n\nHow to Implement Complex Dictionary Comprehensions in Python?\n\nDictionary comprehensions can include conditional logic to filter elements or modify the key-value pairs based on certain conditions. # Creating a dictionary with even numbers and their squares \n\n even_squares = {x: x**2 for x in range(10) if x % 2 == 0} \n\n # Creating a dictionary with pairs of numbers and their products \n\n products = {(x, y): x * y for x in range(1, 4) for y in range(1, 4)} \n\n\n\n\n\nHow Do Dictionary Comprehensions Enhance Code Readability in Python?"
    },
    {
        "link": "https://geeksforgeeks.org/create-a-dictionary-with-list-comprehension-in-python",
        "document": "The task of creating a dictionary with list comprehension in Python involves iterating through a sequence and generating key-value pairs in a concise manner. For example, given two lists, keys = [“name”, “age”, “city”] and values = [“Alice”, 25, “New York”], we can pair corresponding elements using list comprehension and convert them into a dictionary, resulting in {‘name’: ‘Alice’, ‘age’: 25, ‘city’: ‘New York’}.\n\nzip() pairs elements from two lists and is commonly used to create dictionaries efficiently. By wrapping zip() inside a list comprehension and converting it into a dictionary using dict(), we can merge two lists into key-value pairs. It ensures that elements are mapped correctly without extra iterations.\n\nExplanation: zip(keys, values) pairs elements into tuples like [(‘name’, ‘Alice’), (‘age’, 25), (‘city’, ‘New York’)]. Then, list comprehension generates a list of key-value pairs, which dict() converts into a dictionary, storing it in d.\n\nDictionary can be created by passing a list of tuples to the dict(). Using list comprehension, we first generate a list of tuples, where each tuple consists of a key-value pair. This method is useful when keys and values are derived through computations, such as squaring numbers or mapping values dynamically.\n\nExplanation: List comprehension generates a list of tuples, where each tuple consists of a number x (from 1 to 5) as the first element and its square (x**2) as the second. Then, this list of tuples is converted into a dictionary using dict().\n\nenumerate() assigns an index to each element in an iterable, making it useful for generating dictionaries with numeric keys. By applying list comprehension, we can create a list of (index, value) pairs and convert it into a dictionary. It ensures a structured and ordered mapping of elements.\n\nExplanation: List comprehension iterates over enumerate(a), assigning an index to each element in a, creating tuples (idx, val). These tuples are then passed to dict(), converting them into a dictionary where indexes are keys and list elements are values."
    },
    {
        "link": "https://realpython.com/python-dictionary-comprehension",
        "document": "Dictionary comprehensions are a concise and quick way to create, transform, and filter dictionaries in Python. They can significantly enhance your code’s conciseness and readability compared to using regular loops to process your dictionaries.\n\nUnderstanding dictionary comprehensions is crucial for you as a Python developer because they’re a Pythonic tool for dictionary manipulation and can be a valuable addition to your programming toolkit.\n\nIn this tutorial, you’ll learn how to:\n• Decide when to use dictionary comprehensions\n\nTo get the most out of this tutorial, you should be familiar with basic Python concepts, such as loops, iterables, and dictionaries, as well as list comprehensions.\n\nIn Python programming, you’ll often need to create, populate, and transform dictionaries. To do this, you can use dictionary literals, the constructor, and loops. In the following sections, you’ll take a quick look at how to use these tools. You’ll also learn about dictionary comprehensions, which are a powerful way to manipulate dictionaries in Python. To create new dictionaries, you can use literals. A dictionary literal is a series of key-value pairs enclosed in curly braces. The syntax of a dictionary literal is shown below: The keys must be hashable objects and are commonly strings. The values can be any Python object, including other dictionaries. Here’s a quick example of a dictionary: In this example, you create dictionary key-value pairs that describe things people often like. The keys and values of your dictionary are string objects. You can add new pairs to the dictionary using the syntax. Note: To learn more about dictionaries, check out the Dictionaries in Python tutorial. You can also create new dictionaries using the constructor: In this example, you create a new dictionary using with keyword arguments. In this case, the keys are strings and the values are floating-point numbers. It’s important to note that the constructor is only suitable for those cases where the dictionary keys can be strings that are valid Python identifiers. Sometimes, you need to start with an empty dictionary and populate it with key-value pairs dynamically. To do this, you can use a loop. For example, say that you want to create a dictionary in which keys are integer numbers and values are powers of . Here’s how you can do this with a loop: In this example, you create an empty dictionary using an empty pair of curly braces. Then, you run a loop over a range of integer numbers from to . Inside the loop, you populate the dictionary with the integer numbers as keys and powers of two as values. The loop in this example is readable and clear. However, you can also use dictionary comprehension to create and populate a dictionary like the one shown above. Dictionary comprehensions allow you to build dictionaries with a one-line loop. If you’re familiar with list comprehensions, then you’ll quickly grasp dictionary comprehensions. Both constructs have similar syntax. The main difference is that dictionary comprehensions use curly braces instead of square brackets. Additionally, the comprehension expression must include a key and a value separated by a colon. A dictionary comprehension returns a new dictionary. To build this dictionary, you compute the key-value pairs from the items of an input iterable. Note that the syntax includes an optional conditional at the end, which you can use to filter existing dictionaries.\n• Enclosing brackets: Curly braces ( ) are used for dictionary comprehensions.\n• The comprehension expression: An expression that provides a value in each iteration. In dictionary comprehension, the expression must provide the key and its corresponding value, . Both elements can be expressions.\n• The current : This is the current item or value in the iterable.\n• The : This can be any Python iterable object, including a list, tuple, set, generator, or similar. The following code shows how you can build the dictionary using a comprehension: In this example, is the comprehension expression, is the current member, and is the iterable. Here’s a diagram that illustrates the process of converting your loop from the previous section into the equivalent dictionary comprehension: As you can see, with a couple of movements and the addition of the enclosing curly braces, your comprehension is complete. Comprehensions can also have more than one clause. When they do, the leftmost iterates over the outer collection, the next from left to right iterates over the first nesting level, and so on. To illustrate, say that you have a list of lists. Each nested list contains numbers. You want to create a dictionary that maps numbers to their square values. You can use a comprehension with two clauses as shown below: In this example, the first loop iterates over the rows of your matrix. The second loop iterates over the number of each row. As a result, you get a dictionary that maps numbers to their square values. Even though this syntax works, it can make your comprehensions difficult to read and understand. It’s important to note that in this example, instead of having 16 key-value pairs, you end up with only nine. This is because dictionary keys are unique. When the key is duplicated, the new value overrides the previous one. In this example, this behavior doesn’t cause issues because the values will always be the square of their corresponding keys.\n\nWith dictionary comprehensions, you can create new dictionaries, transform existing ones, and even filter key-value pairs. In the following sections, you’ll learn how to use dictionary comprehension to approach all these use cases. To kick things off, you’ll start by learning how to create new dictionaries from existing iterables. Sometimes, you have an iterable of data and want to create a dictionary by using the data items to generate the keys and values, while also applying some transformation to the original data. For a quick example, say that you have a list of fruits and want to create a dictionary where the keys are the fruit names displayed in uppercase, and the values represent the number of letters in each name: In this example, you apply transformations to generate the keys and values. In real-world programming, you may often need to apply transformations to generate the values or the keys. Consider the following example that creates a dictionary with lowercase letters as keys and their Unicode code points as values: In this example, you generate the dictionary’s values by running a transformation on the provided items. You use the data items directly to provide the keys. Sometimes, you have two data sequences and want to map each item in the first sequence to the corresponding item in the second. In this case, you can use the following code: In this example, you use the built-in function to create pairs of items. This function takes two or more iterables as arguments and yields tuples of items by getting one item from each iterable. In practice, when you need to create a dictionary from two sequences without applying any transformation on the data items, you can use the following code instead of a comprehension: This way of creating a dictionary from two sequences is pretty Pythonic and straightforward. You don’t need a comprehension. However, if you need to transform the data somehow, then you’d benefit from using a comprehension. For example, say that you have a third list containing the prices of each computer part. You want to create a dictionary that holds the parts as keys and their costs as values. In this situation, you can’t use the trick above. You need to use a comprehension: In this example, using combined with doesn’t provide a suitable solution for building the dictionary because you need to compute the values. This is when a comprehension comes in handy, as it allows you to handle the calculation of values. You can also use comprehensions to transform the keys or values of existing dictionaries. A typical example is when you need to swap keys and values. For example, say that you have a dictionary containing computer parts that map to part codes, and you want an opposite configuration. In this situation, you can use a dictionary comprehension to swap the keys and values: In this comprehension, you use the method on the dictionary to access the key-value pairs. Then, you have two loop variables, one for the keys and one for the values. In the comprehension expression, you swap the keys and values. Note: It’s important to note that in order for you to swap the keys and values of a dictionary, you need to have values that are hashable objects. Also, the values must be unique, or you’ll end up losing part of the data corresponding to the duplicate values. You can get the same result using the following code that combines and with the and dictionary methods: In this example, you use a combination of function and method calls instead of a comprehension. The result is the same as with a comprehension. Note: To learn more about dictionary iteration, check out the How to Iterate Through a Dictionary in Python tutorial. As another example, say that you have a dictionary of fruits and their prices, and you need to decrease the prices by 5%. You can do this with a comprehension: In this example, you transform the values of the original dictionary. Now, you have a new dictionary with prices that are 5% lower. You can apply the transformation to just the keys, or both the values and the keys, depending on what you need. Dictionary comprehensions also allow you to use a conditional at the end of their syntax. This conditional will enable you to create dictionaries by filtering existing data. You can use the conditional syntax with both keys and values. Here’s an example that filters a dictionary of numbers by their values to create a dictionary of even numbers: The conditional at the end of the comprehension filters odd numbers from the original dictionary. As a result, you get a dictionary of even numbers. To learn how to filter a dictionary by keys, say that you have a dictionary that maps postal codes to towns, and you need to filter the dictionary to get the towns in a range of postal codes: In this example, the condition checks whether the current postal code is between 1100 and 1300. This condition filters the original dictionary, generating a new one with the towns in the target range of codes.\n\nDeciding When to Use Dictionary Comprehensions When deciding whether to use a dictionary comprehension instead of regular loops or a combination of function calls, you should consider the following factors:\n• Conciseness: Dictionary comprehensions reduce the amount of code compared to equivalent loops.\n• Readability: Dictionary comprehensions can make your code more explicit and readable. In practice, you can use dictionary comprehensions when you need to do some of the following operations:\n• Merge iterables into a dictionary while transforming keys, values, or both So far, you’ve learned how to do all these operations using dictionary comprehensions. Still, you may find other good use cases for dictionary comprehensions during your Python coding experience. Finally, there are situations when you want to avoid dictionary comprehensions. For example, when you want to process a large dataset to produce key-value pairs. Using dictionary comprehension in this situation will create a large dictionary and store it in memory, which will result in high memory consumption. To make your code memory-efficient, you may use a generator expression that yields tuples of the form instead: In this example, you use a generator expression to build an iterator that yields tuples of two values. The first value is a number, and the second is its square value. Note: You don’t get direct look-up with a generator. If you rely on looking up the values by their key, then a generator expression is a clumsy replacement for a dictionary comprehension. The resulting iterator yields tuples on demand, meaning that you’ll only use memory to store one tuple at a time. You don’t need to store a dictionary of a million key-value pairs in your computer’s memory, and avoiding this will make your code more efficient. Instead, you can use the built-in function to traverse the resulting iterator, or you can use a loop.\n\nYou should avoid a few bad practices when working with dictionary comprehensions in your Python code. Some of the most common include the following:\n• Writing nested comprehensions with several clauses or several conditionals\n• Running costly transformations while building the keys and values\n• Trying to access comprehension variables from the outside Sometimes, you may end up with a dictionary comprehension where the comprehension expression is too complicated. For example, you may want to apply transformations conditionally and think of something like the following: In this comprehension, you apply a price discount to a list of selected fruits. To do this, you use a conditional expression as the comprehension expression. You may find it challenging to read this comprehension and decipher what it does. When a complicated expression makes your code difficult to read, you may benefit from using a regular loop instead to make your code more readable. Nested comprehensions with several clauses or conditionals can make your code less readable. So, in general, you should avoid them and use more readable constructs like a regular loop. Trying to use the variables that you define in a comprehension outside of the comprehension itself isn’t possible: : name 'value' is not defined The variable is only visible within the comprehension. If you try to use it outside the comprehension, then you get a . Sometimes, when working with dictionary comprehensions, you may need to run costly data transformations to generate keys, values, or both. In those situations, you need to be aware that building the final dictionary in memory may take considerable time. A possible workaround is to use a generator that produces the key-value pairs on demand."
    }
]