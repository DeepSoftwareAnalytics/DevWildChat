[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify",
        "document": "The value to convert to a JSON string. A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of to be included in the output. If is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including values, are completely ignored. If is anything other than a function or an array (e.g. or not provided), all string-keyed properties of the object are included in the resulting JSON string. A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes. If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than is treated as if it were ). Values less than 1 indicate that no space should be used. If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array. If is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is or not provided — no white space is used.\n\nconverts a value to the JSON notation that the value represents. Values are stringified in the following manner:\n• , , , and (obtainable via ) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. objects (obtainable via ) are treated as plain objects.\n• Attempting to serialize values will throw. However, if the BigInt has a method (through monkey patching: ), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user.\n• , , and values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to (when found in an array). can return when passing in \"pure\" values like or .\n• The numbers and , as well as the value , are all considered . (But unlike the values in the previous point, they would never be omitted.)\n• Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and (inclusive) are serialized; other properties are ignored.\n• The special raw JSON object created with is serialized as the raw JSON text it contains (by accessing its property).\n• \n• All -keyed properties will be completely ignored, even when using the parameter.\n• If the value has a method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the method when called will be serialized. calls with one parameter, the , which has the same semantic as the parameter of the function:\n• if this object is a property value, the property name\n• if it is in an array, the index in the array, as a string\n• if was directly called on this object, an empty string All objects implement the method, which returns a string (the same as calling ). Thus, they will be serialized as strings. Similarly, objects implement , which returns the same as .\n• Only enumerable own properties are visited. This means , , etc. will become . You can use the parameter to serialize them to something more useful. Properties are visited using the same algorithm as , which has a well-defined order and is stable across implementations. For example, on the same object will always produce the same string, and would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable).\n\nThe parameter can be either a function or an array. As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored. As a function, it takes two parameters: the and the being stringified. The object in which the key was found is provided as the 's context. The function is called for the initial object being stringified as well, in which case the is an empty string ( ). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as . The current property value will be replaced with the 's return value for stringification. This means:\n• If you return a number, string, boolean, or , that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.)\n• If you return a , , or , the property is not included in the output.\n• If you return any other object, the object is recursively stringified, calling the function on each property. Note: When parsing JSON generated with functions, you would likely want to use the parameter to perform the reverse operation. Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become instead of omitted). Using the function allows you to control the order of the array elements by returning a different array.\n\nfunction replacer(key, value) { // Filtering out properties if (typeof value === \"string\") { return undefined; } return value; } const foo = { foundation: \"Mozilla\", model: \"box\", week: 45, transport: \"car\", month: 7, }; JSON.stringify(foo, replacer); // '{\"week\":45,\"month\":7}' If you wish the to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key). function makeReplacer() { let isInitial = true; return (key, value) => { if (isInitial) { isInitial = false; return value; } if (key === \"\") { // Omit all properties with name \"\" (except the initial object) return undefined; } return value; }; } const replacer = makeReplacer(); console.log(JSON.stringify({ \"\": 1, b: 2 }, replacer)); // \"{\"b\":2}\"\n\nSince the JSON format doesn't support object references (although an IETF draft exists), a will be thrown if one attempts to encode an object with circular references. To serialize circular references, you can use a library that supports them (e.g. cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values. If you are using to deep-copy an object, you may instead want to use , which supports circular references. JavaScript engine APIs for binary serialization, such as , also support circular references.\n\nIn a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of : // Creating an example of JSON const session = { screens: [], state: true, }; session.screens.push({ name: \"screenA\", width: 450, height: 250 }); session.screens.push({ name: \"screenB\", width: 650, height: 350 }); session.screens.push({ name: \"screenC\", width: 750, height: 120 }); session.screens.push({ name: \"screenD\", width: 250, height: 60 }); session.screens.push({ name: \"screenE\", width: 390, height: 120 }); session.screens.push({ name: \"screenF\", width: 1240, height: 650 }); // Converting the JSON string with JSON.stringify() // then saving with localStorage in the name of session localStorage.setItem(\"session\", JSON.stringify(session)); // Example of how to transform the String generated through // JSON.stringify() and saved in localStorage in JSON object again const restoredSession = JSON.parse(localStorage.getItem(\"session\")); // Now restoredSession variable contains the object that was saved // in localStorage console.log(restoredSession);"
    },
    {
        "link": "https://w3schools.com/jsref/jsref_stringify.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://w3schools.com/js/js_json_stringify.asp",
        "document": "A common use of JSON is to exchange data to/from a web server. When sending data to a web server, the data has to be a string. You can convert any JavaScript datatype into a string with .\n\nImagine we have this object in JavaScript:\n\nUse the JavaScript function to convert it into a string.\n\nis now a string, and ready to be sent to a server:\n\nYou will learn how to send JSON to a server in the next chapters.\n\nIt is also possible to stringify JavaScript arrays:\n\nImagine we have this array in JavaScript:\n\nUse the JavaScript function to convert it into a string.\n\nis now a string, and ready to be sent to a server:\n\nYou will learn how to send a JSON string to a server in the next chapters.\n\nWhen storing data, the data has to be a certain format, and regardless of where you choose to store it, text is always one of the legal formats.\n\nJSON makes it possible to store JavaScript objects as text.\n\nJSON.stringify() can not only convert objects and arrays into JSON strings, it can convert any JavaScript value into a string.\n\nIn JSON, date objects are not allowed. The function will convert any Date objects into strings.\n\nYou can convert the string back into a date object at the receiver.\n\nIn JSON, functions are not allowed as object values.\n\nThe function will remove any functions from a JavaScript object, both the key and the value:\n\nThis can be omitted if you convert your functions into strings before running the function.\n\nIf you send functions using JSON, the functions will lose their scope, and the receiver would have to use eval() to convert them back into functions."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Scripting/JSON",
        "document": "JavaScript Object Notation (JSON) is a standard text-based format for representing structured data based on JavaScript object syntax. It is commonly used for transmitting data in web applications (e.g., sending some data from the server to the client, so it can be displayed on a web page, or vice versa). You'll come across it quite often, so in this article, we give you all you need to work with JSON using JavaScript, including parsing JSON so you can access data within it, and creating JSON. An understanding of HTML and the fundamentals of CSS, familiarity with JavaScript basics as covered in previous lessons.\n• What JSON is — a very commonly used data format based on JavaScript object syntax.\n• That JSON can also contain arrays.\n• Retrieve JSON as a JavaScript object using mechanisms available in Web APIs (for example, in the Fetch API).\n• Converting between objects and text using and .\n\nNo, really, what is JSON? JSON is a text-based data format following JavaScript object syntax. It represents structured data as a string, which is useful when you want to transmit data across a network. Even though it closely resembles JavaScript object literal syntax, it can be used independently from JavaScript. Many programming environments feature the ability to read (parse) and generate JSON. In JavaScript, the methods for parsing and generating JSON are provided by the object. Note: Converting a string to a native object is called deserialization, while converting a native object to a string so it can be transmitted across the network is called serialization. A JSON string can be stored in its own file, which is basically just a text file with an extension of , and a MIME type of .\n\nAs described above, JSON is a string whose format very much resembles JavaScript object literal format. The following is a valid JSON string representing an object. Note how it is also a valid JavaScript object literal — just with some more syntax restrictions. { \"squadName\": \"Super hero squad\", \"homeTown\": \"Metro City\", \"formed\": 2016, \"secretBase\": \"Super tower\", \"active\": true, \"members\": [ { \"name\": \"Molecule Man\", \"age\": 29, \"secretIdentity\": \"Dan Jukes\", \"powers\": [\"Radiation resistance\", \"Turning tiny\", \"Radiation blast\"] }, { \"name\": \"Madame Uppercut\", \"age\": 39, \"secretIdentity\": \"Jane Wilson\", \"powers\": [ \"Million tonne punch\", \"Damage resistance\", \"Superhuman reflexes\" ] }, { \"name\": \"Eternal Flame\", \"age\": 1000000, \"secretIdentity\": \"Unknown\", \"powers\": [ \"Immortality\", \"Heat Immunity\", \"Inferno\", \"Teleportation\", \"Interdimensional travel\" ] } ] } If you load this JSON in your JavaScript program as a string, you can parse it into a normal object and then access the data inside it using the same dot/bracket notation we looked at in the JavaScript object basics article. For example:\n• First, we have the variable name — .\n• Inside that, we want to access the property, so we use .\n• contains an array populated by objects. We want to access the second object inside the array, so we use .\n• Inside this object, we want to access the property, so we use .\n• Inside the property is an array containing the selected hero's superpowers. We want the third one, so we use . The key takeaway is that there's really nothing special about working with JSON; after you've parsed it into a JavaScript object, you work with it just like you would with an object declared using the same object literal syntax. Note: We've made the JSON seen above available inside a variable in our JSONTest.html example (see the source code). Try loading this up and then accessing data inside the variable via your browser's JavaScript console.\n\nAbove we mentioned that JSON text basically looks like a JavaScript object inside a string. We can also convert arrays to/from JSON. The below example is perfectly valid JSON: You have to access array items (in its parsed version) by starting with an array index, for example . The JSON can also contain a single primitive. For example, , , or are all valid JSON.\n\nTo begin with, make local copies of our heroes.html and style.css files. The latter contains some simple CSS to style our page, while the former contains some very simple body HTML, plus a element to contain the JavaScript code we will be writing in this exercise: We have made our JSON data available on our GitHub, at https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json. We are going to load the JSON into our script, and use some nifty DOM manipulation to display it, like this:\n\nThe top-level function looks like this: To obtain the JSON, we use an API called Fetch. This API allows us to make network requests to retrieve resources from a server via JavaScript (e.g. images, text, JSON, even HTML snippets), meaning that we can update small sections of content without having to reload the entire page. In our function, the first four lines use the Fetch API to fetch the JSON from the server:\n• we declare the variable to store the GitHub URL\n• we use the URL to initialize a new object.\n• we make the network request using the function, and this returns a object\n• we retrieve the response as JSON using the function of the object. Note: The API is asynchronous. You can learn about asynchronous functions in detail in our Asynchronous JavaScript module, but for now, we'll just say that we need to add the keyword before the name of the function that uses the fetch API, and add the keyword before the calls to any asynchronous functions. After all that, the variable will contain the JavaScript object based on the JSON. We are then passing that object to two function calls — the first one fills the with the correct data, while the second one creates an information card for each hero on the team, and inserts it into the .\n\nNow that we've retrieved the JSON data and converted it into a JavaScript object, let's make use of it by writing the two functions we referenced above. First of all, add the following function definition below the previous code: Here we first create an h1 element with , set its to equal the property of the object, then append it to the header using . We then do a very similar operation with a paragraph: create it, set its text content and append it to the header. The only difference is that its text is set to a template literal containing both the and properties of the object.\n\nNext, add the following function at the bottom of the code, which creates and displays the superhero cards: function populateHeroes(obj) { const section = document.querySelector(\"section\"); const heroes = obj.members; for (const hero of heroes) { const myArticle = document.createElement(\"article\"); const myH2 = document.createElement(\"h2\"); const myPara1 = document.createElement(\"p\"); const myPara2 = document.createElement(\"p\"); const myPara3 = document.createElement(\"p\"); const myList = document.createElement(\"ul\"); myH2.textContent = hero.name; myPara1.textContent = `Secret identity: ${hero.secretIdentity}`; myPara2.textContent = `Age: ${hero.age}`; myPara3.textContent = \"Superpowers:\"; const superPowers = hero.powers; for (const power of superPowers) { const listItem = document.createElement(\"li\"); listItem.textContent = power; myList.appendChild(listItem); } myArticle.appendChild(myH2); myArticle.appendChild(myPara1); myArticle.appendChild(myPara2); myArticle.appendChild(myPara3); myArticle.appendChild(myList); section.appendChild(myArticle); } } To start with, we store the property of the JavaScript object in a new variable. This array contains multiple objects that contain the information for each hero. Next, we use a for...of loop to loop through each object in the array. For each one, we:\n• Create several new elements: an , an , three s, and a .\n• Set the to contain the current hero's .\n• Fill the three paragraphs with their , , and a line saying \"Superpowers:\" to introduce the information in the list.\n• Store the property in another new constant called — this contains an array that lists the current hero's superpowers.\n• Use another loop to loop through the current hero's superpowers — for each one we create an element, put the superpower inside it, then put the inside the element ( ) using .\n• The very last thing we do is to append the , s, and inside the ( ), then append the inside the . The order in which things are appended is important, as this is the order they will be displayed inside the HTML. Note: If you are having trouble getting the example to work, try referring to our heroes-finished.html source code (see it running live also.) Note: If you are having trouble following the dot/bracket notation we are using to access the JavaScript object, it can help to have the superheroes.json file open in another tab or your text editor, and refer to it as you look at our JavaScript. You should also refer back to our JavaScript object basics article for more information on dot and bracket notation.\n\nThe above example was simple in terms of accessing the JavaScript object, because we converted the network response directly into a JavaScript object using . But sometimes we aren't so lucky — sometimes we receive a raw JSON string, and we need to convert it to an object ourselves. And when we want to send a JavaScript object across the network, we need to convert it to JSON (a string) before sending it. Luckily, these two problems are so common in web development that a built-in JSON object is available in browsers, which contains the following two methods:\n• : Accepts a JSON string as a parameter, and returns the corresponding JavaScript object.\n• : Accepts an object as a parameter, and returns the equivalent JSON string. You can see the first one in action in our heroes-finished-json-parse.html example (see the source code) — this does exactly the same thing as the example we built up earlier, except that:\n• we retrieve the response as text rather than JSON, by calling the method of the response\n• we then use to convert the text to a JavaScript object. The key snippet of code is here: As you might guess, works the opposite way. Try entering the following lines into your browser's JavaScript console one by one to see it in action: let myObj = { name: \"Chris\", age: 38 }; myObj; let myString = JSON.stringify(myObj); myString; Here we're creating a JavaScript object, then checking what it contains, then converting it to a JSON string using — saving the return value in a new variable — then checking it again."
    },
    {
        "link": "https://geeksforgeeks.org/javascript-json-stringify-method",
        "document": "The method in JavaScript is used to convert JavaScript objects into a JSON string. This method takes a JavaScript object as input and returns a JSON-formatted string representing that object.\n• value: It is the value that is to be converted into a JSON string.\n• replacer: It is an optional parameter. This parameter value can be an altering function or an array used as a selected filter for the stringify. If the value is empty or null then all properties of an object are included in a string.\n• space: It is also an optional parameter. This argument is used to control spacing in the final string generated using the JSON.stringify() function. It can be a number or a string if it is a number then the specified number of spaces are indented to the final string and if it is a string then that string is (up to 10 characters) used for indentation.\n\nReturn Value: Returns a string for a given value.\n\nThe code demonstrates how to convert a JavaScript object into a JSON string using . The resulting JSON string represents the properties of the object in a serialized format.\n\nExample 2: Deep Copying JavaScript Object with JSON.stringify() and JSON.parse()\n\nThe code creates an object with nested properties. converts to a JSON string, then parses it back to an object . Modifying doesn’t affect , illustrating deep copying.\n\nThe code converts the array into a JSON string using . The resulting string is logged along with its type. This demonstrates how JSON.stringify() converts JavaScript data types into JSON strings.\n\nWe have a complete list of Javascript JSON methods, to check those please go through Javascript JSON Complete Reference article."
    },
    {
        "link": "https://stackoverflow.com/questions/10434599/get-the-data-received-in-a-flask-request",
        "document": "The answer to this question led me to ask Get raw POST body in Python Flask regardless of Content-Type header next, which is about getting the raw data rather than the parsed data.\n\nI want to be able to get the data sent to my Flask app. I've tried accessing request.data but it is an empty string. How do you access request data?\n\nThe docs describe the attributes available on the object ( ) during a request. In most common cases will be empty because it's used as a fallback: Contains the incoming request data as string in case it came with a mimetype Flask does not handle.\n• : the key/value pairs in the URL query string\n• : the key/value pairs in the body, from a HTML post form, or JavaScript request that isn't JSON encoded\n• : the files in the body, which Flask keeps separate from . HTML forms must use or files will not be uploaded.\n• : parsed JSON data. The request must have the content type, or use to ignore the content type. All of these are instances (except for ). You can access values using:\n• : use indexing if you know the key exists\n• : use if the key might not exist\n• : use if the key is sent multiple times and you want a list of values. only returns the first value.\n\nUse to get posted JSON data. Use to get data when submitting a form with the POST method. Use to get data passed in the query string of the URL, like when submitting a form with the GET method. etc. are dict-like, use the method to get a value with a default if it wasn't passed.\n\nIf the body is recognized as form data, it will be in . If it's JSON, it will be in . Otherwise the raw data will be in . If you're not sure how data will be submitted, you can use an chain to get the first one with data. def get_request_data(): return ( request.args or request.form or request.get_json(force=True, silent=True) or request.data ) contains args parsed from the query string, regardless of what was in the body, so you would remove that from if both it and a body should data at the same time.\n\nTo get form data, try this, The request object allows us to get access to the data that come from a request. it can also help us access other information about a request. Hope that helps. :) from flask import Flask, request app = Flask(__name__) @app.get('/') def index(): json_data = request.get_json() #this will get the json data and return a dictionary containing the data sent form_data = request.form #this will get the form data return a dictionary of the data submitted in a form #such can be accessed in the following way username = json_data.get('username') email = form_data.get('email') # this will be value from the email input ....\n\nI went through all the answers above, however, I noticed no one really talked about when you receive data from Client-side (when your client side is of different origin e.g. react app) to Server-side then you also need to handle pre-flight request in Flask to allow Cross-Origin access otherwise CORS error is thrown. After you handle that, then usual process is to use method on object. Following is the code that works for me: @app.route(\"/read_row_to_customer_sheet\", methods=[\"POST\", \"OPTIONS\"]) def read_row_to_customer_sheet(): if request.method == \"OPTIONS\": response = make_response() response.headers.add(\"Access-Control-Allow-Origin\", \"*\") response.headers.add('Access-Control-Allow-Headers', \"*\") response.headers.add(\"Content-Type\", \"application/json\") return response elif request.method == 'POST': form = request.get_json() print(form) # your custom logic goes here response = make_response() response.headers.add(\"Access-Control-Allow-Origin\", \"*\") return response Also make sure you put in elif block not at the beginning of function. Otherwise you will encounter the CORS error at client-side and possibly 415 error at server side because when you receive the pre-flight OPTIONS request the function will try to decode it as json because you placed the at the beginning, therefore, following control-flow is wrong: ### WRONG Route Function @app.route(\"/read_row_to_customer_sheet\", methods=[\"POST\", \"OPTIONS\"]) def read_row_to_customer_sheet(): form = request.get_json() if request.method == \"OPTIONS\": response = make_response() response.headers.add(\"Access-Control-Allow-Origin\", \"*\") response.headers.add('Access-Control-Allow-Headers', \"*\") response.headers.add(\"Content-Type\", \"application/json\") return response elif request.method == 'POST': print(form) # your custom logic goes here response = make_response() response.headers.add(\"Access-Control-Allow-Origin\", \"*\") return response"
    },
    {
        "link": "https://stackoverflow.com/questions/72397196/how-to-access-form-data-of-a-post-request-with-flask",
        "document": "I hope you can help me. The fact is that I want to implement the transfer of values ​​from the sliders to the image processing function.\n\nI also have an image processing function that runs when the page loads.\n\nFor example in the filtering method(cv2.bilateralFilter) we have parameters that will need to be changed by the sliders (in this case, it is 11,50,100), but at the same time, this method must have default values ​​so that the image is still processed when the page loads. How can I that?I will be grateful for the answer"
    },
    {
        "link": "https://digitalocean.com/community/tutorials/processing-incoming-request-data-in-flask",
        "document": "Web applications frequently require processing incoming request data from users. This payload can be in the shape of query strings, form data, and JSON objects. Flask, like any other web framework, allows you to access the request data.\n\nIn this tutorial, you will build a Flask application with three routes that accept either query strings, form data, or JSON objects.\n\nTo complete this tutorial, you will need:\n• This project will require Python installed in a local environment.\n• This project will use Pipenv, a production-ready tool that aims to bring the best of all packaging worlds to the Python world. It harnesses Pipfile, pip, and virtualenv into one single command.\n• Downloading and installing a tool like Postman will be required for testing API endpoints.\n\nThis tutorial was verified with Pipenv v2020.11.15, Python v3.9.0, and Flask v1.1.2.\n\nTo demonstrate the different ways of using requests, you will need to create a Flask app. Even though the example app uses a simplified structure for the view functions and routes, what you learn in this tutorial can be applied to any method of organizing your views like class-based views, blueprints, or an extension like Flask-Via.\n\nFirst, you will need to create a project directory. Open your terminal and run the following command:\n\nThen, navigate to the new directory:\n\nNext, install Flask. Open your terminal and run the following command:\n\nThe command will create a virtualenv for this project, a Pipfile, install , and a Pipfile.lock.\n\nTo activate the project’s virtualenv, run the following command:\n\nTo access the incoming data in Flask, you have to use the object. The object holds all incoming data from the request, which includes the mimetype, referrer, IP address, raw data, HTTP method, and headers, among other things.\n\nAlthough all the information the object holds can be useful, for the purposes of this article, you will focus on the data that is normally directly supplied by the caller of the endpoint.\n\nTo gain access to the request object in Flask, you will need to import it from the Flask library:\n\nYou then have the ability to use it in any of your view functions.\n\nUse your code editor to create an file. Import and the object. And also establish routes for , , and :\n\nNext, open your terminal and start the app with the following command:\n\nThe app will start on port 5000, so you can view each route in your browser with the following links:\n\nThe code establishes three routes and visiting each route will display the messages of , , and respectively.\n\nURL arguments that you add to a query string are a common way to pass data to a web app. While browsing the web, you will have likely encountered a query string before.\n\nThe query string begins after the question mark ( ) character:\n\nAnd has key-value pairs separated by an ampersand ( ) character:\n\nFor each pair, the key is followed by an equals sign ( ) character and then the value.\n\nQuery strings are useful for passing data that does not require the user to take action. You could generate a query string somewhere in your app and append it to a URL so when a user makes a request, the data is automatically passed for them. A query string can also be generated by forms that have GET as the method.\n\nLet’s add a query string to the route. In this hypothetical example, you will provide the name of a programming language that will be displayed on the screen. Create a key of and a value of :\n\nIf you run the app and navigate to that URL, you will see that it still displays a message of .\n\nYou will need to program the part that handles the query arguments. This code will read in the key by using either or .\n\nBy calling , the application will continue to run if the key doesn’t exist in the URL. In that case, the result of the method will be .\n\nBy calling , the app will return a 400 error if the key doesn’t exist in the URL.\n\nWhen dealing with query strings, it is recommended to use to prevent the app from failing.\n\nLet’s read the key and display it as output.\n\nModify the route in with the following code:\n\nThen, run the app and navigate to the URL:\n\nThe browser should display the following message:\n\nThe argument from the URL gets assigned to the variable and then gets returned to the browser.\n\nTo add more query string parameters, you can append ampersands and the new key-value pairs to the end of the URL. Create a key of and a value of :\n\nAnd if you want more, continue adding ampersands and key-value pairs. Create a key of and a value of :\n\nTo gain access to those values, you will still use either or . Let’s use both to demonstrate what happens when there is a missing key. Modify the route to assign the value of the results to variables and then display them:\n\nThen, run the app and navigate to the URL:\n\nThe browser should display the following message:\n\nRemove the key from the URL:\n\nThe browser should display the following message with when a value is not provided for :\n\nRemove the key from the URL:\n\nThe browser should encounter an error because it is expecting a value for :\n\nNow you understand handling query strings. Let’s continue to the next type of incoming data.\n\nForm data comes from a form that has been sent as a POST request to a route. So instead of seeing the data in the URL (except for cases when the form is submitted with a GET request), the form data will be passed to the app behind the scenes. Even though you cannot easily see the form data that gets passed, your app can still read it.\n\nTo demonstrate this, modify the route in to accept both GET and POST requests and returns a form:\n\nThen, run the app and navigate to the URL:\n\nThe browser should display a form with two input fields - one for and one for - and a submit button.\n\nThe most important thing to know about this form is that it performs a POST request to the same route that generated the form. The keys that will be read in the app all come from the attributes on our form inputs. In this case, and are the names of the inputs, so you will have access to those in the app.\n\nInside the view function, you will need to check if the request method is GET or POST. If it is a GET request, you can display the form. Otherwise, if it is a POST request, then you will want to process the incoming data.\n\nModify the route in with the following code:\n\nThen, run the app and navigate to the URL:\n\nFill out the field with value of and the field with the value of . Then, press Submit.\n\nThe browser should display the following message:\n\nNow you understand handling form data. Let’s continue to the next type of incoming data.\n\nJSON data is normally constructed by a process that calls the route.\n\nAn example JSON object looks like this:\n\nThis structure can allow for much more complicated data to be passed as opposed to query strings and form data. In the example, you see nested JSON objects and an array of items. Flask can handle this format of data.\n\nModify the route in to accept POST requests and ignore other requests like GET:\n\nUnlike the web browser used for query strings and form data, for the purposes of this article, to send a JSON object, you will use Postman to send custom requests to URLs.\n\nIn Postman, add the URL and change the type to POST. On the body tab, change to raw and select JSON from the drop-down.\n\nThese settings are required so Postman can send JSON data properly, and so your Flask app will understand that it is receiving JSON:\n\nNext, copy the earlier JSON example into the text input.\n\nSend the request, and you should get as the response. That is fairly anti-climatic but is to be expected because the code for handling the JSON data response has yet to be written.\n\nTo read the data, you must understand how Flask translates JSON data into Python data structures:\n• Anything that is an object gets converted to a Python dict. in JSON corresponds to , which returns a value in Python.\n• An array in JSON gets converted to a list in Python. Since the syntax is the same, here’s an example list:\n• The values inside of quotes in the JSON object become strings in Python.\n• Boolean and become and in Python.\n• Finally, numbers without quotes around them become numbers in Python.\n\nNow let’s work on the code to read the incoming JSON data.\n\nFirst, let’s assign everything from the JSON object into a variable using .\n\nconverts the JSON object into Python data. Let’s assign the incoming request data to variables and return them by making the following changes to the route:\n\nNote how you access elements that aren’t at the top level. is used because you are entering a nested object. And is used to access the 0th index in the examples array.\n\nIf the JSON object sent with the request doesn’t have a key that is accessed in your view function, then the request will fail. If you don’t want it to fail when a key doesn’t exist, you’ll have to check if the key exists before trying to access it.\n\nRun the app and submit the example JSON request using Postman. In the response, you will get the following output:\n\nIn this article, you built a Flask application with three routes that accept either query strings, form data, or JSON objects.\n\nAlso, recall that all approaches had to address the recurring consideration for gracefully failing when a key is missing.\n\nIf you’d like to learn more about Flask, check out our Flask topic page for exercises and programming projects."
    },
    {
        "link": "https://reddit.com/r/flask/comments/1gxxe4x/retrieving_form_data",
        "document": "This is all there is written about request.form in the flask docs,\n\n\"*property form: ImmutableMultiDict[str, str]* The form parameters. By default an is returned from this function. This can be changed by setting to a different type. This might be necessary if the order of the form data is important.\n\nPlease keep in mind that file uploads will not end up here, but instead in the attribute.\"\n\nHow am i supposed to know that i have to use `request.form['username']` where 'username' is the the name attribute of the input element from the html, to get the data? also they do mention it in the quickstart a bit but still leaves out the part what that 'username' part is.\n\nI am a complete nub on this stuff, but i started to give docs more reads these days to actually understand and know what is going.\n\nI genuinely want to know how do you guys figure out these kind of stuff when the docs just assumes you know what you are doing as if you were not looking through docs to not learn?"
    },
    {
        "link": "https://flask.palletsprojects.com/en/stable/api",
        "document": "This part of the documentation covers all the interfaces of Flask. For parts where Flask depends on external libraries, we document the most important right here and provide links to the canonical documentation.\n\nThe Click command group for registering CLI commands for this object. The commands are available from the command once the application has been discovered and blueprints have been registered. Used by to determine the cache value for a given file path if it wasn’t passed. By default, this returns from the configuration of . This defaults to , which tells the browser to use conditional requests instead of a timed cache, which is usually preferable. Note this is a duplicate of the same method in the Flask class. Changed in version 2.0: The default configuration is instead of 12 hours. The view function used to serve files from . A route is automatically registered for this view at if is set. Note this is a duplicate of the same method in the Flask class. Open a resource file relative to for reading. The blueprint-relative equivalent of the app’s method.\n• None resource (str) – Path to the resource relative to .\n• None mode (str) – Open the file in this mode. Only reading is supported, valid values are (or ) and .\n• None encoding (str | None) – Open the file with this encoding when opening in text mode. This is ignored when opening in binary mode. Register a template filter, available in any template rendered by the application. Works like the decorator. Equivalent to .\n• None name (str | None) – the optional name of the filter, otherwise the function name will be used. Register a template global, available in any template rendered by the application. Works like the decorator. Equivalent to .\n• None name (str | None) – the optional name of the global, otherwise the function name will be used. Register a template test, available in any template rendered by the application. Works like the decorator. Equivalent to .\n• None name (str | None) – the optional name of the test, otherwise the function name will be used. Register a URL rule with the blueprint. See for full documentation. The URL rule is prefixed with the blueprint’s URL prefix. The endpoint name, used with , is prefixed with the blueprint’s name. Like , but after every request, not only those handled by the blueprint. Equivalent to . Register a function to run after each request to this object. The function is called with the response object, and must return a response object. This allows the functions to modify or replace the response before it is sent. If a function raises an exception, any remaining functions will not be called. Therefore, this should not be used for actions that must execute, such as to close resources. Use for that. This is available on both app and blueprint objects. When used on an app, this executes after every request. When used on a blueprint, this executes after every request that the blueprint handles. To register with a blueprint and execute after every request, use . Like , but for templates rendered by every view, not only by the blueprint. Equivalent to . Like , but for every request, not only those handled by the blueprint. Equivalent to . Register a template filter, available in any template rendered by the application. Equivalent to . name (str | None) – the optional name of the filter, otherwise the function name will be used. Register a template global, available in any template rendered by the application. Equivalent to . name (str | None) – the optional name of the global, otherwise the function name will be used. Register a template test, available in any template rendered by the application. Equivalent to . name (str | None) – the optional name of the test, otherwise the function name will be used. Like , but for every request, not only those handled by the blueprint. Equivalent to . Like , but for every request, not only those handled by the blueprint. Equivalent to . Like , but before every request, not only those handled by the blueprint. Equivalent to . Register a function to run before each request. For example, this can be used to open a database connection, or to load the logged in user from the session. The function will be called without any arguments. If it returns a non- value, the value is handled as if it was the return value from the view, and further request handling is stopped. This is available on both app and blueprint objects. When used on an app, this executes before every request. When used on a blueprint, this executes before every request that the blueprint handles. To register with a blueprint and execute before every request, use . Registers a template context processor function. These functions run before rendering a template. The keys of the returned dict are added as variables available in the template. This is available on both app and blueprint objects. When used on an app, this is called for every rendered template. When used on a blueprint, this is called for templates rendered from the blueprint’s views. To register with a blueprint and affect every template, use . Decorate a view function to register it for the given endpoint. Used if a rule is added without a with . endpoint (str) – The endpoint name to associate with the view function. Register a function to handle errors by code or exception class. A decorator that is used to register a function given an error code. Example: 'This page does not exist' You can also register handlers for arbitrary exceptions: This is available on both app and blueprint objects. When used on an app, this can handle errors from every request. When used on a blueprint, this can handle errors from requests that the blueprint handles. To register with a blueprint and affect every request, use . Added in version 0.7: Use instead of modifying directly, for application wide error handlers. Added in version 0.7: One can now additionally also register custom exception types that do not necessarily have to be a subclass of the class. code_or_exception (type[Exception] | int) – the code as integer for the handler, or an arbitrary exception The Jinja loader for this object’s templates. By default this is a class to if it is set. Creates an instance of object that is later passed to the register callback functions. Subclasses can override this to return a subclass of the setup state. Registers a function that is called when the blueprint is registered on the application. This function is called with the state as argument as returned by the method. Works like but wraps the function in another function that will ensure the function is only called once. If the blueprint is registered a second time on the application, the function passed is not called. Called by to register all views and callbacks registered on the blueprint with the application. Creates a and calls each callback with it.\n• None app (App) – The application this blueprint is being registered with. Changed in version 2.1: Registering the same blueprint with the same name multiple times is an error. Changed in version 2.0.1: Nested blueprints are registered with their dotted name. This allows different blueprints with the same name to be nested at different locations. Changed in version 2.0.1: The option can be used to change the (pre-dotted) name the blueprint is registered with. This allows the same blueprint to be registered multiple times with unique names for . Register a on this blueprint. Keyword arguments passed to this method will override the defaults set on the blueprint. Changed in version 2.0.1: The option can be used to change the (pre-dotted) name the blueprint is registered with. This allows the same blueprint to be registered multiple times with unique names for . Alternative error attach function to the decorator that is more straightforward to use for non decorator usage. Decorate a view function to register it with the given URL rule and options. Calls , which has more details about the implementation. The endpoint name for the route defaults to the name of the view function if the parameter isn’t passed. The parameter defaults to . and are added automatically.\n• None options (Any) – Extra options passed to the object. The absolute path to the configured static folder. if no static folder is set. The URL prefix that the static route will be accessible from. If it was not configured during init, it is derived from . Like , but after every request, not only those handled by the blueprint. Equivalent to . Register a function to be called when the request context is popped. Typically this happens at the end of each request, but contexts may be pushed manually as well during testing. When the block exits (or is called), the teardown functions are called just before the request context is made inactive. When a teardown function was called because of an unhandled exception it will be passed an error object. If an is registered, it will handle the exception and the teardown will not receive it. Teardown functions must avoid raising exceptions. If they execute code that might fail they must surround that code with a / block and log any errors. The return values of teardown functions are ignored. This is available on both app and blueprint objects. When used on an app, this executes after every request. When used on a blueprint, this executes after every request that the blueprint handles. To register with a blueprint and execute after every request, use . Callback function for URL defaults for all view functions of the application. It’s called with the endpoint and values and should update the values passed in place. This is available on both app and blueprint objects. When used on an app, this is called for every request. When used on a blueprint, this is called for requests that the blueprint handles. To register with a blueprint and affect every request, use . Register a URL value preprocessor function for all view functions in the application. These functions will be called before the functions. The function can modify the values captured from the matched url before they are passed to the view. For example, this can be used to pop a common language code value and place it in rather than pass it to every view. The function is passed the endpoint name and values dict. The return value is ignored. This is available on both app and blueprint objects. When used on an app, this is called for every request. When used on a blueprint, this is called for requests that the blueprint handles. To register with a blueprint and affect every request, use . The name of the package or module that this object belongs to. Do not change this once it is set by the constructor. The path to the templates folder, relative to , to add to the template loader. if templates should not be added. Absolute path to the package on the filesystem. Used to look up resources contained in the package. To register a view function, use the decorator. This data structure is internal. It should not be modified directly and its format may change at any time. A data structure of registered error handlers, in the format . The key is the name of a blueprint the handlers are active for, or for all requests. The key is the HTTP status code for , or for other exceptions. The innermost dictionary maps exception classes to handler functions. To register an error handler, use the decorator. This data structure is internal. It should not be modified directly and its format may change at any time. A data structure of functions to call at the beginning of each request, in the format . The key is the name of a blueprint the functions are active for, or for all requests. To register a function, use the decorator. This data structure is internal. It should not be modified directly and its format may change at any time. A data structure of functions to call at the end of each request, in the format . The key is the name of a blueprint the functions are active for, or for all requests. To register a function, use the decorator. This data structure is internal. It should not be modified directly and its format may change at any time. A data structure of functions to call at the end of each request even if an exception is raised, in the format . The key is the name of a blueprint the functions are active for, or for all requests. To register a function, use the decorator. This data structure is internal. It should not be modified directly and its format may change at any time. A data structure of functions to call to pass extra context values when rendering templates, in the format . The key is the name of a blueprint the functions are active for, or for all requests. To register a function, use the decorator. This data structure is internal. It should not be modified directly and its format may change at any time. A data structure of functions to call to modify the keyword arguments passed to the view function, in the format . The key is the name of a blueprint the functions are active for, or for all requests. To register a function, use the decorator. This data structure is internal. It should not be modified directly and its format may change at any time. A data structure of functions to call to modify the keyword arguments when generating URLs, in the format . The key is the name of a blueprint the functions are active for, or for all requests. To register a function, use the decorator. This data structure is internal. It should not be modified directly and its format may change at any time.\n\nThe request object used by default in Flask. Remembers the matched endpoint and view arguments. It is what ends up as . If you want to replace the request object used you can subclass this and set to your subclass. The request object is a subclass and provides all of the attributes Werkzeug defines plus a few Flask specific ones. The internal URL rule that matched the request. This can be useful to inspect which methods are allowed for the URL from a before/after handler ( ) etc. Though if the request’s method was invalid for the URL rule, the valid list is available in instead (an attribute of the Werkzeug exception ) because the request was never internally bound. A dict of view arguments that matched the request. If an exception happened when matching, this will be . If matching the URL failed, this is the exception that will be raised / was raised as part of the request handling. This is usually a exception or something similar. The maximum number of bytes that will be read during this request. If this limit is exceeded, a 413 error is raised. If it is set to , no limit is enforced at the Flask application level. However, if it is and the request has no header and the WSGI server does not indicate that it terminates the stream, then no data is read to avoid an infinite stream. Each request defaults to the config, which defaults to . It can be set on a specific to apply the limit to that specific view. This should be set appropriately based on an application’s or view’s specific needs. Changed in version 3.1: This can be set per-request. Changed in version 0.6: This is configurable through Flask config. The maximum size in bytes any non-file form field may be in a body. If this limit is exceeded, a 413 error is raised. If it is set to , no limit is enforced at the Flask application level. Each request defaults to the config, which defaults to . It can be set on a specific to apply the limit to that specific view. This should be set appropriately based on an application’s or view’s specific needs. Changed in version 3.1: This is configurable through Flask config. The maximum number of fields that may be present in a body. If this limit is exceeded, a 413 error is raised. If it is set to , no limit is enforced at the Flask application level. Each request defaults to the config, which defaults to . It can be set on a specific to apply the limit to that specific view. This should be set appropriately based on an application’s or view’s specific needs. Changed in version 3.1: This is configurable through Flask config. The endpoint that matched the request URL. This will be if matching failed or has not been performed yet. This in combination with can be used to reconstruct the same URL or a modified URL. The registered name of the current blueprint. This will be if the endpoint is not part of a blueprint, or if URL matching failed or has not been performed yet. This does not necessarily match the name the blueprint was created with. It may have been nested, or registered with a different name. The registered names of the current blueprint upwards through parent blueprints. This will be an empty list if there is no current blueprint, or if URL matching failed. If this method returns a value, it is used as the return value for . The default implementation raises . e (ValueError | None) – If parsing failed, this is the exception. It will be if the content type wasn’t . Changed in version 2.3: Raise a 415 error instead of 400. List of charsets this client supports as object. List of encodings this client accepts. Encodings in a HTTP term are compression encodings such as gzip. For charsets have a look at . List of languages this client accepts as object. List of mimetypes this client supports as object. Sent with a preflight request to indicate which headers will be sent with the cross origin request. Set on the response to indicate which headers are allowed. Sent with a preflight request to indicate which method will be used for the cross origin request. Set on the response to indicate which methods are allowed. If a forwarded header exists this is a list of all ip addresses from the client ip to the last proxy server. Decorate a function as responder that accepts the request as the last argument. This works like the decorator but the function is passed the request object as the last argument and the request object will be closed automatically: As of Werkzeug 0.14 HTTP exceptions are automatically caught and converted to responses instead of failing. The parsed URL parameters (the part in the URL after the question mark). By default an is returned from this function. This can be changed by setting to a different type. This might be necessary if the order of the form data is important. The header parsed into an object. if the header is not present. Changed in version 2.3: is no longer a . The attribute was added for auth schemes that use a token instead of parameters. Like but without the query string. Closes associated resources of this request object. This closes all file handles explicitly. You can also use the request object in a with statement which will automatically close it. The Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field. The Content-Length entity-header field indicates the size of the entity-body in bytes or, in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET. The Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body. (Note: a MIC is good for detecting accidental modification of the entity-body in transit, but is not proof against malicious attacks.) The Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET. A with the contents of all cookies transmitted with the request. The raw data read from . Will be empty if the request represents form data. To get the raw data even if it represents form data, use . The Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822. Changed in version 2.0: The datetime object is timezone-aware. object containing all uploaded files. Each key in is the name from the . Each value in is a Werkzeug object. It basically behaves like a standard file object you know from Python, with the difference that it also has a function that can store the file on the filesystem. Note that will only contain data if the request method was POST, PUT or PATCH and the that posted to the request had . It will be empty otherwise. See the / documentation for more details about the used data structure. The form parameters. By default an is returned from this function. This can be changed by setting to a different type. This might be necessary if the order of the form data is important. Please keep in mind that file uploads will not end up here, but instead in the attribute. Changed in version 0.9: Previous to Werkzeug 0.9 this would only contain form data for POST and PUT requests. Create a new request object based on the values provided. If environ is given missing values are filled from there. This method is useful for small scripts when you need to simulate a request from an URL. Do not use this method for unittesting, there is a full featured client object ( ) that allows to create multipart requests, support for cookies etc. This accepts the same options as the . Changed in version 0.5: This method now accepts the same arguments as . Because of this the parameter is now called . This reads the buffered incoming data from the client into one bytes object. By default this is cached but that behavior can be changed by setting to . Usually it’s a bad idea to call this method without checking the content length first as a client could send dozens of megabytes or more to cause memory problems on the server. Note that if the form data was already parsed this method will not return anything as form data parsing does not cache the data like this method does. To implicitly invoke form data parsing function set to . When this is done the return value of this method will be an empty string if the form parser handles the data. This generally is not necessary as if the whole data is cached (which is the default) the form parser will used the cached data to parse the form data. Please be generally aware of checking the content length first in any case before calling this method to avoid exhausting server memory. If is set to the return value will be a decoded string. If the mimetype does not indicate JSON (application/json, see ), or parsing fails, is called and its return value is used as the return value. By default this raises a 415 Unsupported Media Type resp.\n• None force (bool) – Ignore the mimetype and always try to parse JSON.\n• None silent (bool) – Silence mimetype and parsing errors, and return instead.\n• None cache (bool) – Store the parsed JSON to return for subsequent calls. Changed in version 2.3: Raise a 415 error instead of 400. Changed in version 2.1: Raise a 400 error if the content type is incorrect. The host name the request was made to, including the port if it’s non-standard. Validated with . The request URL scheme and host only. An object containing all the etags in the header. Changed in version 2.0: The datetime object is timezone-aware. An object containing all the etags in the header. Changed in version 2.0: The datetime object is timezone-aware. The raw WSGI input stream, without any safety checks. This is dangerous to use. It does not guard against infinite streams or reading past or . Check if the mimetype indicates JSON data, either application/json or application/*+json. boolean that is if the application is served by a WSGI server that spawns multiple processes. boolean that is if the application is served by a multithreaded WSGI server. boolean that is if the application will be executed only once in a process lifetime. This is the case for CGI for example, but it’s not guaranteed that the execution only happens one time. if the request was made with a secure protocol (HTTPS or WSS). The parsed JSON data if indicates JSON (application/json, see ). If the request content type is not , this will raise a 415 Unsupported Media Type error. Changed in version 2.3: Raise a 415 error instead of 400. Changed in version 2.1: Raise a 400 error if the content type is incorrect. Creates the form data parser. Instantiates the with some parameters. The Max-Forwards request-header field provides a mechanism with the TRACE and OPTIONS methods to limit the number of proxies or gateways that can forward the request to the next inbound server. Like , but without parameters (eg, without charset, type etc.) and always lowercase. For example if the content type is the mimetype would be . The mimetype parameters as dict. For example if the content type is the params would be . The host that the request originated from. Set on the response to indicate which origins are allowed. The Pragma general-header field is used to include implementation-specific directives that might apply to any recipient along the request/response chain. All pragma directives specify optional behavior from the viewpoint of the protocol; however, some systems MAY require that behavior be consistent with the directives. The Referer[sic] request-header field allows the client to specify, for the server’s benefit, the address (URI) of the resource from which the Request-URI was obtained (the “referrer”, although the header field is misspelled). If the server supports user authentication, and the script is protected, this attribute contains the username the user has authenticated as. The request URL scheme, host, and root path. This is the root that the application is accessed from. The WSGI input stream, with safety checks. This stream can only be consumed once. Use to get the full data as bytes or text. The attribute will contain the full bytes only if they do not represent form data. The attribute will contain the parsed form data in that case. Unlike , this stream guards against infinite streams or reading past or . If is set, it can be enforced on streams if is set. Otherwise, an empty stream is returned. If the limit is reached before the underlying stream is exhausted (such as a file that is too large, or an infinite stream), the remaining contents of the stream cannot be read safely. Depending on how the server handles this, clients may show a “connection reset” failure instead of seeing the 413 response. Changed in version 2.3: Check preemptively and while reading. Changed in version 0.9: The stream is always set (but may be consumed) even if form parsing was accessed first. Valid host names when handling requests. By default all hosts are trusted, which means that whatever the client says the host is will be accepted. Because and headers can be set to any value by a malicious client, it is recommended to either set this property or implement similar validation in the proxy (if the application is being run behind one). The full request URL with the scheme, host, root path, path, and query string. Alias for . The URL with scheme, host, and root path. For example, . The user agent. Use to get the header value. Set to a subclass of to provide parsing for the other properties or other extended data. Changed in version 2.1: The built-in parser was removed. Set to a subclass to parse data from the string. For GET requests, only are present, not . Changed in version 2.0: For GET requests, only are present, not . if the request method carries content. By default this is true if a is sent. The WSGI environment containing HTTP headers and information from the WSGI server. Set when creating the request object. If , reading from the request body will cause a . Useful to prevent modifying the stream from middleware. The method the request was made with, such as . The URL scheme of the protocol the request used, such as or . The address of the server. , for unix sockets, or if not known. The prefix that the application is mounted under, without a trailing slash. comes after this. The path part of the URL after . This is the path used for routing within the application. The part of the URL after the “?”. This is the raw value, use for the parsed values. The headers received with the request. The address of the client sending the request. To access incoming request data, you can use the global object. Flask parses incoming request data for you and gives you access to it through that global object. Internally Flask makes sure that you always get the correct data for the active thread if you are in a multithreaded environment. This is a proxy. See Notes On Proxies for more information. The request object is an instance of a .\n\nThe response object that is used by default in Flask. Works like the response object from Werkzeug but is set to have an HTML mimetype by default. Quite often you don’t have to create this object yourself because will take care of that for you. If you want to replace the response object used you can subclass this and set to your subclass. Changed in version 1.0: JSON support is added to the response, like the request. This is useful when testing to get the test client response data as JSON. the default mimetype if none is provided. The header. Even though the name would indicate that multiple values are supported, it must be one string token only. The values and are common. Whether credentials can be shared by the browser to JavaScript code. As part of the preflight request it indicates whether credentials can be used on the cross origin request. Which headers can be sent with the cross origin request. Which methods can be used for the cross origin request. The origin or ‘*’ for any origin that may make cross origin requests. Which headers can be shared by the browser to JavaScript code. The maximum age in seconds the access control settings can be cached for. Add an etag for the current response if there is none yet. Changed in version 2.0: SHA-1 is used to generate the value. MD5 may not be available in some environments. The Age response-header field conveys the sender’s estimate of the amount of time since the response (or its revalidation) was generated at the origin server. The Allow entity-header field lists the set of methods supported by the resource identified by the Request-URI. The purpose of this field is strictly to inform the recipient of valid methods associated with the resource. An Allow header field MUST be present in a 405 (Method Not Allowed) response. Should this response object automatically set the content-length header if possible? This is true by default. The Cache-Control general-header field is used to specify directives that MUST be obeyed by all caching mechanisms along the request/response chain. Returns the content length if available or otherwise. Adds a function to the internal list of functions that should be called as part of closing down the response. Since 0.7 this function also returns the function that was passed so that this can be used as a decorator. Close the wrapped response if possible. You can also use the object in a with statement which will automatically close it. Added in version 0.9: Can now be used in a with statement. The Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field. The Content-Language entity-header field describes the natural language(s) of the intended audience for the enclosed entity. Note that this might not be equivalent to all the languages used within the entity-body. The Content-Length entity-header field indicates the size of the entity-body, in decimal number of OCTETs, sent to the recipient or, in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET. The Content-Location entity-header field MAY be used to supply the resource location for the entity enclosed in the message when that entity is accessible from a location separate from the requested resource’s URI. The Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body. (Note: a MIC is good for detecting accidental modification of the entity-body in transit, but is not proof against malicious attacks.) The header as a object. Available even if the header is not set. The header as a object. Available even if the header is not set. The Content-Security-Policy header adds an additional layer of security to help detect and mitigate certain types of attacks. The header as a object. Available even if the header is not set. The Content-Security-Policy-Report-Only header adds a csp policy that is not enforced but is reported thereby helping detect certain types of attacks. The Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET. Prevents a document from loading any cross-origin resources that do not explicitly grant the document permission. Values must be a member of the enum. Allows control over sharing of browsing context group with cross-origin documents. Values must be a member of the enum. The Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822. Changed in version 2.0: The datetime object is timezone-aware. the default status if none is provided.\n• None key (str) – the key (name) of the cookie to be deleted.\n• None path (str | None) – if the cookie that should be deleted was limited to a path, the path has to be defined here.\n• None domain (str | None) – if the cookie that should be deleted was limited to a domain, that domain has to be defined here.\n• None secure (bool) – If , the cookie will only be available via HTTPS.\n• None samesite (str | None) – Limit the scope of the cookie to only be attached to requests that are “same-site”.\n• None partitioned (bool) – If , the cookie will be partitioned. The Expires entity-header field gives the date/time after which the response is considered stale. A stale cache entry may not normally be returned by a cache. Changed in version 2.0: The datetime object is timezone-aware. Enforce that the WSGI response is a response object of the current type. Werkzeug will use the internally in many situations like the exceptions. If you call on an exception you will get back a regular object, even if you are using a custom subclass. This method can enforce a given response type, and it will also convert arbitrary WSGI callables into response objects if an environ is provided: # convert a Werkzeug response object into an instance of the This is especially useful if you want to post-process responses in the main dispatcher and use functionality provided by your subclass. Keep in mind that this will modify response objects in place if possible! Make the response object ready to be pickled. Does the following:\n• None Buffer the response into a list, ignoring and .\n• None Generate an header if one is not already set. Changed in version 2.0: An header is always added. Changed in version 0.6: The header is set. Create a new response object from an application output. This works best if you pass it an application that returns a generator all the time. Sometimes applications may use the callable returned by the function. This tries to resolve such edge cases automatically. But if you don’t get the expected output you should set to which enforces buffering.\n• None environ (WSGIEnvironment) – the WSGI environment to execute against. Returns the application iterator for the given environ. Depending on the request method and the current status code the return value might be an empty response rather than the one from the response. If the request method is or the status code is in a range where the HTTP specification requires an empty response, an empty iterable is returned. environ (WSGIEnvironment) – the WSGI environment of the request. The string representation of the response body. Whenever you call this property the response iterable is encoded and flattened. This can lead to unwanted behavior if you stream big data. This behavior can be disabled by setting to . If is set to the return value will be a decoded string. Return a tuple in the form . If there is no ETag the return value is . Parse as JSON. Useful during testing. If the mimetype does not indicate JSON (application/json, see ), this returns . Unlike , the result is not cached.\n• None force (bool) – Ignore the mimetype and always try to parse JSON. This is automatically called right before the response is started and returns headers modified for the given environment. It returns a copy of the headers from the response with some modifications applied if necessary. For example the location header (if present) is joined with the root URL of the environment. Also the content length is automatically set to zero here for certain status codes. Changed in version 0.6: Previously that function was called and modified the response object in place. Also since 0.6, IRIs in location and content-location headers are handled properly. Also starting with 0.6, Werkzeug will attempt to set the content length if it is able to figure it out on its own. This is the case if all the strings in the response iterable are already encoded and the iterable is buffered. environ (WSGIEnvironment) – the WSGI environment of the request. Returns the final WSGI response as tuple. The first item in the tuple is the application iterator, the second the status and the third the list of headers. The response returned is created specially for the given environment. For example if the request method in the WSGI environment is the response will be empty and only the headers and status code will be present. environ (WSGIEnvironment) – the WSGI environment of the request. if set to accessing properties on the response object will not try to consume the response iterator and convert it into a list. Added in version 0.6.2: That attribute was previously called . (Notice the typo). If you did use this feature, you have to adapt your code to the name change. Check if the mimetype indicates JSON data, either application/json or application/*+json. If the iterator is buffered, this property will be . A response object will consider an iterator to be buffered if the response attribute is a list or tuple. If the response is streamed (the response is not an iterable with a length information) this property is . In this case streamed means that there is no information about the number of iterations. This is usually if a generator is passed to the response object. This is useful for checking before applying some sort of post filtering that should not take place for streamed responses. Iter the response encoded with the encoding of the response. If the response object is invoked as WSGI application the return value of this method is used as application iterator unless was activated. The parsed JSON data if indicates JSON (application/json, see ). The Last-Modified entity-header field indicates the date and time at which the origin server believes the variant was last modified. Changed in version 2.0: The datetime object is timezone-aware. The Location response-header field is used to redirect the recipient to a location other than the Request-URI for completion of the request or identification of a new resource. Make the response conditional to the request. This method works best if an etag was defined for the response already. The method can be used to do that. If called without etag just the date header is set. This does nothing if the request method in the request or environ is anything but GET or HEAD. For optimal performance when handling range requests, it’s recommended that your response data object implements , and methods as described by . Objects returned by automatically implement those methods. It does not remove the body of the response because that’s something the function does for us automatically. Returns self so that you can do but modifies the object in-place.\n• None request_or_environ (WSGIEnvironment | Request) – a request object or WSGI environment to be used to make the response conditional against.\n• None accept_ranges (bool | str) – This parameter dictates the value of header. If (default), the header is not set. If , it will be set to . If it’s a string, it will use this value.\n• None complete_length (int | None) – Will be used only in valid Range Requests. It will set complete length value and compute real value. This parameter is mandatory for successful Range Requests completion. if header could not be parsed or satisfied. Changed in version 2.0: Range processing is skipped if length is 0 instead of raising a 416 Range Not Satisfiable error. Converts the response iterator in a list. By default this happens automatically if required. If is disabled, this method is not automatically called and some properties might raise exceptions. This also encodes all the items. The mimetype (content type without charset etc.) The mimetype parameters as dict. For example if the content type is the params would be . The Retry-After response-header field can be used with a 503 (Service Unavailable) response to indicate how long the service is expected to be unavailable to the requesting client. Time in seconds until expiration or date. Changed in version 2.0: The datetime object is timezone-aware. A warning is raised if the size of the cookie header exceeds , but the header will still be set.\n• None key (str) – the key (name) of the cookie to be set.\n• None value (str) – the value of the cookie.\n• None max_age (timedelta | int | None) – should be a number of seconds, or (default) if the cookie should last only as long as the client’s browser session.\n• None expires (str | datetime | int | float | None) – should be a object or UNIX timestamp.\n• None path (str | None) – limits the cookie to a given path, per default it will span the whole domain.\n• None domain (str | None) – if you want to set a cross-domain cookie. For example, will set a cookie that is readable by the domain , etc. Otherwise, a cookie will only be readable by the domain that set it.\n• None secure (bool) – If , the cookie will only be available via HTTPS.\n• None samesite (str | None) – Limit the scope of the cookie to only be attached to requests that are “same-site”.\n• None partitioned (bool) – If , the cookie will be partitioned. Changed in version 3.1: The parameter was added. Sets a new string as response. The value must be a string or bytes. If a string is set it’s encoded to the charset of the response (utf-8 by default). Set the etag, and override the old one if there was one. The Vary field value indicates the set of request-header fields that fully determines, while the response is fresh, whether a cache is permitted to use the response to reply to a subsequent request without revalidation. The header parsed into a object. Modifying the object will modify the header value. This header is not set by default. To set this header, assign an instance of to this attribute. Multiple values for this header can be sent to give the client multiple options. Assign a list to set multiple headers. However, modifying the items in the list will not automatically update the header values, and accessing this attribute will only ever return the first value. To unset this header, assign or use . Changed in version 2.3: This attribute can be assigned to to set the header. A list can be assigned to set multiple header values. Use to unset the header. Changed in version 2.3: is no longer a . The attribute was added for auth challenges that use a token instead of parameters. The response body to send as the WSGI iterable. A list of strings or bytes represents a fixed-length response, any other iterable is a streaming response. Strings are encoded to bytes as UTF-8. Do not set to a plain string or bytes, that will cause sending the response to be very inefficient as it will iterate one byte at a time. Pass the response body directly through as the WSGI iterable. This can be used when the body is a binary file or other iterator of bytes, to skip some unnecessary checks. Use instead of setting this manually. If a redirect header is a relative URL, make it an absolute URL, including scheme and domain. Changed in version 2.1: This is disabled by default, so responses will send relative redirects.\n\nGenerally there are three ways to define rules for the routing system:\n• None You can use the decorator.\n• None You can use the function.\n• None You can directly access the underlying Werkzeug routing system which is exposed as . Variable parts in the route can be specified with angular brackets ( ). By default a variable part in the URL accepts any string without a slash however a different converter can be specified as well by using . Variable parts are passed to the view function as keyword arguments. The following converters are available: accepts any text without a slash (the default) like but for floating point values like the default but also accepts slashes matches one of the items provided Custom converters can be defined using . An important detail to keep in mind is how Flask deals with trailing slashes. The idea is to keep each URL unique so the following rules apply:\n• None If a rule ends with a slash and is requested without a slash by the user, the user is automatically redirected to the same page with a trailing slash attached.\n• None If a rule does not end with a trailing slash and the user requests the page with a trailing slash, a 404 not found is raised. This is consistent with how web servers deal with static files. This also makes it possible to use relative link targets safely. You can also define multiple rules for the same function. They have to be unique however. Defaults can also be specified. Here for example is a definition for a URL that accepts an optional page: This specifies that will be the URL for page one and will be the URL for page . If a URL contains a default value, it will be redirected to its simpler form with a 301 redirect. In the above example, will be redirected to . If your route handles and requests, make sure the default route only handles , as redirects can’t preserve form data. Here are the parameters that and accept. The only difference is that with the route parameter the view function is defined with the decorator instead of the parameter. the endpoint for the registered URL rule. Flask itself assumes that the name of the view function is the name of the endpoint if not explicitly stated. the function to call when serving a request to the provided endpoint. If this is not provided one can specify the function later by storing it in the dictionary with the endpoint as key. A dictionary with defaults for this rule. See the example above for how defaults work. specifies the rule for the subdomain in case subdomain matching is in use. If not specified the default subdomain is assumed. the options to be forwarded to the underlying object. A change to Werkzeug is handling of method options. methods is a list of methods this rule should be limited to ( , etc.). By default a rule just listens for (and implicitly ). Starting with Flask 0.6, is implicitly added and handled by the standard request handling. They have to be specified as keyword arguments."
    }
]