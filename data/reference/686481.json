[
    {
        "link": "https://en.cppreference.com/w/cpp/container/map",
        "document": "is a sorted associative container that contains key-value pairs with unique keys. Keys are sorted by using the comparison function . Search, removal, and insertion operations have logarithmic complexity. Maps are usually implemented as Red–black trees.\n\nIterators of iterate in ascending order of keys, where ascending is defined by the comparison that was used for construction. That is, given\n• and , dereferenceable iterators to , with .\n\nm.value_comp()(*it_l, *it_r) == true (least to greatest if using the default comparison).\n\nEverywhere the standard library uses the Compare requirements, uniqueness is determined by using the equivalence relation. In imprecise terms, two objects a and b are considered equivalent (not unique) if neither compares less than the other: !comp(a, b) && !comp(b, a).\n\nmeets the requirements of Container, AllocatorAwareContainer, AssociativeContainer and ReversibleContainer.\n\nAll member functions of are constexpr: it is possible to create and use objects in the evaluation of a constant expression. However, objects generally cannot be constexpr, because any dynamically allocated storage must be released in the same evaluation of constant expression.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://geeksforgeeks.org/map-associative-containers-the-c-standard-template-library-stl",
        "document": "In C++, maps are associative containers that store data in the form of key value pairs sorted on the basis of keys. No two mapped values can have the same keys. By default, it stores data in ascending order of the keys, but this can be changes as per requirement.\n\nExplanation: In the above program, we created a map m of integer keys and string values. We inserted three key-value pairs into the map: {1, “Geeks”}, {2, “For”}, and {3, “Geeks”}. The map automatically sorts the keys in ascending order.\n\nThe map container is defined as std::map class template inside the <map> header file.\n• comp: Custom comparator function that defines how to compare two keys for sorting. It is optional and if not provided, sorts data in increasing order of the keys.\n\nWe can declare and initialize a map in different ways as shown in the below example:\n\nExample: In the above program,\n• map<int, string> m1 is an empty map with no elements.\n• map<int, string> m2 = {{1, “Geeks”}, {2, “For”}, {3, “Geeks”}} initialized to three key-value pairs using initializer list.\n\nTo see more ways to declare and initialize map, refer to this article – Different Ways to Initialize a Map\n\nBasic operations on map containers are shown below:\n\nElements can be inserted into a map using either [] operator or insert() method. If the element with the given key already exists, the insert() method skips the insertion but [] operator updates the associated value to the new value.\n\nWe cannot specify any particular position to insert element as map automatically sort the data according to the order. To know more ways to insert elements in a map, refer this article – Different Ways to Insert Elements in a Map\n\nMap elements can be accessed by using the corresponding key inside operator []. If the key exists, it will return the associated value but if the key doesn’t exist, it will create a new element with the given key and the default value. To avoid this, we can also use at() method for accessing elements with any modification.\n\nTo know more methods to access values in a map, refer to the article – Different Ways to Access a Value in a Map\n\nThe key of an already present elements cannot be modified in the map. But the associated value can be changed by first accessing the element and then using assignment operator to change the value.\n\nExplanation: In this program, expression m[0] = “Tweaks” updates the value associated with the key 0. Similarly, expression m.at(1) = “By” updates the value of the key 1.\n\nTo see more methods to update values in a map, refer to the article – Different Ways to Update Value of a Pair in Map\n\nMap provides fast element search by key using the find() member function. This function returns iterator the element if found, otherwise returns end() iterator.\n\nTo know more methods to search element in map, refer to this article – Check if Map Contains a Specific Key\n\nMaps can be easily traversed by using either range based for loop or using begin() and end() iterator with traditional loops.\n\nTo see more methods to traverse a map, refer to the article – Different Ways to Traverse a Map\n\nMap elements can be deleted from a map using erase() method by passing the key or an iterator.\n\nTo know more ways to delete elements in a map, refer this article – Different Ways to Delete Elements from Map\n\nThe below table lists the time complexity of the above operations on map:\n\nFollowing are some other commonly used operations on a map in C++:\n\nIn C++, map is an associative container that provides the built-in implementation of Red-Black Tree. It stores the elements in some sorted order on the basis of keys. Due do RB Trees, insertion, deletion, and search operations takes logarithmic O(log n) time.\n\nHere’s the list of all member functions of std::map:\n\nInsert elements with a particular key in the map container. Returns an iterator of pairs. The pair refers to the bounds of a range that includes all the elements in the container which have a key equivalent to k. Used to erase elements from the map. Returns an iterator pointing to the first element of the map. Returns an iterator pointing to the first element of the map. Returns a reverse iterator pointing to the element preceding the first element of the map Returns a reverse iterator pointing to the last element of the map. Returns an iterator to the element with key-value in the map if found, else returns the iterator to end. crbegin() returns a constant reverse iterator referring to the last element in the map container. crend() returns a constant reverse iterator pointing to the theoretical element before the first element in the map. cbegin() returns a constant iterator referring to the first element in the map container. cend() returns a constant iterator pointing to the element that is beyond the last element. Inserts the key with value in the map container. Returns the maximum number of elements a map can hold. Find the first element in the map that is just greater than the given key. Find the first element in the map that is equal to or greater than the given key. Inserts the key and its element in the map container with a given hint. Returns the object that determines how the elements in the map are ordered (‘<‘ by default). Returns the object that determines how the elements in the map are ordered (‘<‘ by default). Returns the number of elements in the map. Returns whether the map is empty. Removes all the elements from the map. at() function is used to the element associated with the key k. swap() function is used to exchange the contents of two maps but the maps must be of the same type, although sizes may differ."
    },
    {
        "link": "https://fluentcpp.com/2018/12/11/overview-of-std-map-insertion-emplacement-methods-in-cpp17",
        "document": "Today’s guest post is written by @walletfox, one of the hitchhikers in the C++ galaxy, trying to navigate its dark corners by writing articles, creating Mostly Harmless cheat sheets and observing the following rules: “Don’t panic! Always carry a cheat sheet next to the towel. So long and thanks for all the fish.”.\n\nInterested in writing on Fluent C++ too? Submit your post!\n\nTL;DR Go ahead and try out the C++17 emplacement / insertion methods. They offer a tangible improvement in terms of expressiveness and code safety.\n\nHere are examples of code using them.\n\nC++17 introduced two new insertion / emplacement methods for , namely and .\n\nAt first sight, this might seem like a cause for concern. Why new insertion methods? Don’t we have already plenty of them?\n\nNevertheless, by studying the problem closer we might come to the conclusion that the introduction of the new methods and makes a convincing case and that they bring us closer to more expressive and safer code.\n\nTo understand how we ended up with this pool of insertion / emplacement methods, we are going to use a simple . Later on, we are going to look at a more complex scenario with where is a with two member variables ( , ).\n\nFor logging purposes I have provided all the special member functions for the . In production, we should apply The Rule of Zero (C++ Core Guidelines, C.20: If you can avoid defining default operations, do) and let the compiler generate the special member functions for us.\n\nUnless stated otherwise, the code was compiled with gcc 9.0.0. and clang 8.0.0, -O2 (HEAD at the time of writing).\n\nBefore we can discuss how exactly the new C++17 methods and bring improvement, we are going to travel back to pre-C++11 times when all we had was and .\n\nThe selling point of was its simplicity of use, which unlike didn’t need to use or other verbose constructs to pass around function arguments.\n\nConvenience aside, what is more important, differs from in how it handles a situation when an element with the given key already exists in the map. While simply overwrites the corresponding value, doesn’t.\n\nAnother important difference lies in the requirements on the , namely, requires a , which means that if we explicitly or implicitly disable the default constructor of the , the code won’t compile. Notice that, unlike , calls different special member functions, i.e. the call to the default constructor is followed by the call to copy/move assignment operator.\n\nLast but not least, these methods differ in the return information they provide. With , we have no way of finding out whether the insertion actually took place, unless we perform a prior lookup. On the other hand, returns a that provides us with this information.\n\nMost recently, this has been simplified thanks to structured bindings introduced in C++17.\n\nFurther down the road, we got C++11 which introduced move semantics, and both and , i.e. the original insertion methods, benefited from this in terms of performance. In addition, C++11 introduced emplace() which has the same functionality as but additionally, enables in-place construction.\n\nIn-place construction is a technique that bypasses construction and destruction of temporaries by constructing the objects directly in the map. A notable attraction of () is that we can do away either with or the extra pair of that needed to be used with . Emplacement is accomplished via perfect forwarding and variadic templates.\n\nThe jury is still out on whether () should be generally preferred to . The potential performance gain is dependent on the types involved and specific library implementations. While Scott Meyers is in favor of (Effective Modern C++, Item 42, what a coincidence!), other C++ experts/guidelines are in favor of , most notably Bjarne Stroustrup and Abseil Common Libraries. The reason for that is code safety.\n\nClang-tidy uses a mixed approach with a general preference for emplacement with the exception of and where emplacement could lead to memory leaks:\n\nLet’s get back to our example and study the effect of different insertion/emplacement constructs. Though this will provide us with some observations, keep in mind that this is a specific example. The types and specific libraries involved are likely to cause differences and it would be counterproductive to make general conclusions. If in doubt, measure.\n\nNow that we have listed some common alternatives, notice that scenario (1) resulted in a copy constructor call with both compilers. This is because of copy-list-initialization.\n\nIf performance is of concern, we can disable this alternative by marking the multi-argument constructor of explicit. This code will then fail to compile:\n\nIt appears that omitting with in case (5) helped us dispense with one move construction, but we can do even better—this is demonstrated in case (7) where we passed and as arguments to resulting in a single constructor and destructor call, completely avoiding intermediate copies and moves!\n\nThe verbosity of emplacement with piecewise construct is off-putting, therefore you might appreciate C++17’s which will do away with the gobbledegook. This is going to be demonstrated in the next section.\n\nFor reasons of completeness, I am also listing scenarios where we move from L-values. As you can see, contrary to the previous example, we don’t get the same benefit with and as before.\n\nC++17: try_emplace() and insert_or_assign() as a solution to double lookup\n\nNow we have enough background to understand the rationale behind the introduction of the new methods. and differ in their respective functionalities, but they do have something in common—they are both a solution to a redundant search that had to be performed in pre-C++17 days to provide safety or additional information.\n\nis a safer successor of or . In line with and , doesn’t modify values for already inserted elements. However, on top of that, it prevents stealing from original arguments that happens both with and in case of a failed insertion.\n\nThis is demonstrated in the snippet below. An element with key 1 is already in the map, as a result p1 won’t be inserted. That doesn’t prevent from plundering the pointer p:\n\nIn the pre C++17 days this issue could have been only solved with a prior lookup, with .\n\nThis lookup is no longer necessary. makes sure that the argument remains untouched in case it wasn’t inserted:\n\nAlthough this is the primary purpose of , there are some other important advantages. As already mentioned in the previous section, simplifies the original that had to use pair’s piecewise constructor:\n\nand dispenses with its verbosity in the following way:\n\nAt first sight, using in this way might seem rather user unfriendly due to the nonexistent boundary between the key and the value. However, if used in this way, solves another issue of , namely that objects were created even though they weren’t actually used.\n\nSpecifically, the map below already contains the key with value , thus a object doesn’t need to be generated, because doesn’t modify values for already existing keys.\n\nNonetheless, we shouldn’t blindly replace all occurrences of with without adjusting the argument list first. The that uses ’s constructor below generates a redundant object just like its counterparts:\n\nis a “smarter” successor of . Just like it modifies values if supplied with a key that is already present in the map. However, unlike , doesn’t require default constructibility of the . On top of that, it returns a . The is when insertion took place and false in case of assignment.\n\nAgain, this information was unavailable for without a prior lookup with the help of as demonstrated below. The map already contains an element with the key , thus this won’t be an insertion but an update.\n\nThe code contains a lot of boilerplate that can result both in errors and performance inefficiencies only for the sole purpose of insert or update identification. Luckily, with we can skip all of it and simply write:\n\nAt present, it is difficult to conclude whether the new C++17 methods express clearly their intent and functionality. If you have a look at the original proposal, is being referred to as , while is being referred to as .\n\nAt the moment it might seem confusing but with more frequent use we are bound to get it right and hopefully, we will be able to link the new names to the correct functionalities.\n• , and don’t overwrite values for existing keys. On the other hand, and overwrite them.\n• may be susceptible to memory leaks if allocation fails.\n• doesn’t steal from original arguments if insertion fails. This is in contrast to and .\n• doesn’t generate redundant objects in case insertion didn’t take place. This is in contrast to .\n• offers a simplified piecewise construction. On the other hand, has to use , .\n• doesn’t require default constructibility. On the other hand, does.\n• returns information on whether insertion or assignment took place. This is in contrast to .\n\nThe author is grateful to Jonathan Boccara for hosting, formatting and editing the post and Ricardo Nabinger Sanchez for proofreading.\n\nYou will also like\n• Which One Is Better: Map of Vectors, or Multimap?\n• 3 Simple C++17 Features That Will Make Your Code Simpler\n• “auto to stick” and Changing Your Style\n• Inserting several elements into an STL container efficiently\n• Searching when you have access to an STL container\n\nDon't want to miss out ? Share this post!"
    },
    {
        "link": "https://stackoverflow.com/questions/24702235/c-stdmap-holding-any-type-of-value",
        "document": "Blindy's answer is very good (+1), but just to complete the answer: there is another way to do it with no library, by using dynamic inheritance:\n• it's familiar to any C++ coder\n• it don't force you to use Boost (in some contexts you are not allowed to);\n• you have to allocate the objects on the heap/free store and use reference semantic instead of value semantic to manipulate them;\n• public inheritance exposed that way might lead to over-use of dynamic inheritance and a lot of long-term issues related to your types really being too inter-dependent;\n• a vector of pointers is problematic if it have to own the objects, as you have to manage destruction;\n\nSo use boost::any or boost::variant as default if you can, and consider this option only otherwise.\n\nTo fix that last cons point you could use smart pointers:\n\nHowever there is still a potentially more problematic point:\n\nIt forces you to create the objects using new/delete (or make_unique/shared). This mean that the actual objects are created in the free store (the heap) at any location provided by the allocator (mostly the default one). Therefore, going though the list of objects very often is not as fast as it could be because of cache misses.\n\nIf you are concerned with performance of looping through this list very often as fast as possible (ignore the following if not), then you'd better use either boost::variant (if you already know all the concrete types you will use) OR use some kind of type-erased polymorphic container.\n\nThe idea is that the container would manage arrays of objects of the same type, but that still expose the same interface. That interface can be either a concept (using duck-typing techniques) or a dynamic interface (a base class like in my first example). The advantage is that the container will keep same-type objects in separate vectors, so going through them is fast. Only going from one type to another is not.\n\nHere is an example (the images are from there): http://bannalia.blogspot.fr/2014/05/fast-polymorphic-collections.html\n\nHowever, this technique loose it's interest if you need to keep the order in which the objects are inserted.\n\nIn any way, there are several solutions possible, which depends a lot on your needs. If you have not enough experience with your case, I suggest using either the simple solution I first explained in my example or boost::any/variant.\n\nAs a complement to this answer, I want to point very good blog articles which summarize all C++ type-erasure techniques you could use, with comments and pros/cons:"
    },
    {
        "link": "https://medium.com/@chittaranjansethi/a-comprehensive-guide-to-std-map-in-c-with-code-examples-f5cd576669f1",
        "document": "In the world of programming, efficient data storage and retrieval are crucial for many applications. One powerful tool in C++ that helps achieve this is the std::map container. std::map is a part of the Standard Template Library (STL) and provides an associative array that stores key-value pairs. In this blog, we will explore the features of std::map and provide a code example to demonstrate its usage.\n\nstd::map is implemented as a binary search tree, which ensures that the elements are always sorted based on their keys. This sorted structure allows for efficient searching, insertion, and deletion of elements, making std::map a popular choice when fast key-based operations are required.\n• Ordered Storage: As mentioned earlier, std::map arranges its elements based on their keys. This ordering enables easy traversal of the elements in either ascending or descending order.\n• Unique Keys: Each key in a std::map is unique. This property ensures that you cannot have multiple elements with the same key. If an attempt is made to insert a duplicate key, the insertion operation will fail.\n• Associative Lookup: std::map allows for efficient associative lookup. Given a key, you can quickly find the corresponding value associated with it. This feature is particularly useful in scenarios where you need to perform frequent searches based on specific keys.\n• Dynamic Size: std::map can dynamically grow and shrink as elements are inserted or removed. It takes care of memory management, making it convenient to work with varying data sizes.\n• Efficient Operations: std::map provides efficient operations like insertion, deletion, and searching, with a time complexity of O (log n).\n\nLet’s dive into a simple code example to demonstrate the usage of std::map:\n\nIn this example, we create a std::map called to store student names with corresponding integer keys. We insert three key-value pairs using the function. We then access and update elements using the keys. The ‌function is used to check if a particular key exists. We iterate over the map using a range-based for loop and print the values. Finally, we remove an element using and check the size of the map using the function.\n\nIn this example, we create a std::map named with the key as a string and the value as an integer. We then insert three key-value pairs into the map using the subscript operator ( ). The keys are the names of the students, and the values represent their marks.\n\nWe access the value associated with the key “Bob” using the subscript operator, and modify the value associated with the key “Charlie” using the same operator. We also demonstrate how to check if a key exists in the map using the function.\n\nFinally, we iterate over the map using a range-based for loop and print all the key-value pairs.\n\nstd::map is a versatile container in C++ that simplifies data storage and retrieval based on keys. Its ordered storage, associative lookup, and dynamic size make it a powerful tool for various applications. With its well-defined functionality and ease of use, std::map is worth considering whenever you need efficient key-based operations in your C++ programs."
    },
    {
        "link": "https://geeksforgeeks.org/file-handling-c-classes",
        "document": "File handling is used to store data permanently in a computer. Using file handling we can store our data in secondary memory (Hard disk).\n\nHow to achieve the File Handling\n\nFor achieving file handling we need to follow the following steps:-\n\n STEP 1-Naming a file\n\n STEP 2-Opening a file\n\n STEP 3-Writing data into the file\n\n STEP 4-Reading data from the file\n\n STEP 5-Closing a file.\n\nWe give input to the executing program and the execution program gives back the output. The sequence of bytes given as input to the executing program and the sequence of bytes that comes as output from the executing program are called stream. In other words, streams are nothing but the flow of data in a sequence.\n\nThe input and output operation between the executing program and the devices like keyboard and monitor are known as “console I/O operation”. The input and output operation between the executing program and files are known as “disk I/O operation”.\n\nThe I/O system of C++ contains a set of classes which define the file handling methods. These include ifstream, ofstream and fstream classes. These classes are derived from fstream and from the corresponding iostream class. These classes, designed to manage the disk files, are declared in fstream and therefore we must include this file in any program that uses files. File handling is essential for data storage and retrieval in applications.\n• None This class is the base class for other classes in this class hierarchy.\n• None This class contains the necessary facilities that are used by all the other derived classes for input and output operations.\n• None This class is derived from the class ‘ios’.\n• None The extraction operator(>>) is overloaded in this class to handle input streams from files to the program execution.\n• None This class declares input functions such as get(), getline() and read().\n• None This class is derived from the class ‘ios’.\n• None The insertion operator(<<) is overloaded in this class to handle output streams to files from the program execution.\n• None This class declares output functions such as put() and write().\n• None This class contains a pointer which points to the buffer which is used to manage the input and output streams.\n• None This class provides operations common to the file streams. Serves as a base for fstream, ifstream and ofstream class.\n• None This class contains open() and close() function.\n• None It contains open() function with default input mode.\n• None Inherits the functions get(), getline(), read(), seekg() and tellg() functions from the istream.\n• None It contains open() function with default output mode.\n• None Inherits the functions put(), write(), seekp() and tellp() functions from the ostream.\n• None This class provides support for simultaneous input and output operations.\n• None Inherits all the functions from istream and ostream classes through iostream.\n• None Its purpose is to set the file buffers to read and write.\n• None We can also use file buffer member function to determine the length of the file. \n\n\n\nIn C++, files are mainly dealt by using three classes fstream, ifstream, ofstream available in fstream headerfile. \n\nofstream: Stream class to write on files \n\nifstream: Stream class to read from files \n\nfstream: Stream class to both read and write from/to files.\n\nNow the first step to open the particular file for read or write operation. We can open file by \n\n1. passing file name in constructor at the time of object creation \n\n2. using the open method\n\nBoth ios::app and ios::ate take us to the end of the file when it is opened. The difference between the two modes is that ios :: app allow us to add data to the end of the file only, while ios :: ate mode permits us add data or to modify the existing data anywhere in the file.\n\nProblem Statement : To read and write a File in C++. \n\nExamples:\n\nBelow is the implementation by using ifstream & ofstream classes.\n\nBelow is the implementation by using fstream class."
    },
    {
        "link": "https://stackoverflow.com/questions/46701540/preferred-c-i-o-stream-method-fstream-or-ifstream-ofstream-or-something-else",
        "document": "I have created a roster program that accepts user input to create/write/delete information into and out of a specified text file. My issue now becomes wanting to create a lasting text file that isn't overwritten every time I re-run the program and am not sure if using fstream or a combination of of/ifstream is better practice, or if there is maybe a third option I missed when checking the reference docs.\n\nRight now I am simply using: which works, until I kill and re-run the program to which my text file is now wiped clean."
    },
    {
        "link": "https://cplusplus.com/doc/tutorial/files",
        "document": "std; main () { ofstream myfile ( ); (myfile.is_open()) { myfile << ; myfile << \"This is another line.\n\n\" ; myfile.close(); } cout << ; 0; }\n\n[file example.txt] This is a line. This is another line."
    },
    {
        "link": "https://stackoverflow.com/questions/71336125/best-practice-when-dealing-with-c-iostreams",
        "document": "I'm writing a command-line utility for some text processing. I need a helper function (or two) that does the following:\n• If the filename is , return standard input/output;\n• Otherwise, create and open a file, check for error, and return it.\n\nAnd here comes my question: what is the best practice to design/implement such a function? What should it look like?\n\nIt works, and it's safe to later on (in case one doesn't forget to), but then I would lose access to the stream methods such as .\n\nSo I figure, the modern C++ way would be to use smart pointers with streams. At first, I tried\n\nThis works for but not for , because you can't delete . So I have to supply a custom deleter (that does nothing) for the case. But suddenly, it fails to compile, because apparently, when supplied a custom deleter, the becomes a different type.\n\nEventually, after many tweaks and searches on StackOverflow, this is the best I can come up with:\n\nIt is type-safe and memory-safe (or at least I believe so; do correct me if I'm wrong), but this looks kind of ugly and boilerplate, and above all, it is such a headache to just get it to compile.\n\nAm I doing it wrong and missing something here? There's gotta be a better way."
    },
    {
        "link": "https://reddit.com/r/cpp_questions/comments/f9s2sf/file_handling_in_c",
        "document": "I am a beginner and I stumbled upon two different ways of handling files in cpp.\n\nFirst one is by using ifstream, ofstream or fsteam. And the other one is using FILE *. My question is what is the difference between those two. I have seen type File documentation which says FILE is an \"Object containing information to control a stream \". However I don't clearly understand how does it work."
    }
]