[
    {
        "link": "https://geeksforgeeks.org/stringbuilder-class-in-java-with-examples",
        "document": "In Java, StringBuilder class is a part of the package that provides a mutable sequence of characters. Unlike , which creates a new object for every modification, StringBuilder allows in-place changes, making it memory-efficient and faster for large or frequent string manipulations.\n• None in Java creates an immutable sequence of characters, whereas StringBuilder creates a mutable sequence of characters, offering an alternative.\n• None Functionality of StringBuilder is similar to the StringBuffer class, as both provide mutable sequences of characters.\n• None StringBuilder is designed as a drop-in replacement for StringBuffer in scenarios where StringBuffer is used by a single thread.\n• None StringBuilder is faster than StringBuffer in most implementations.\n• None StringBuilder is not thread-safe and should not be used in multi-threaded environments. If thread safety is required, it is recommended to use StringBuffer instead.\n• None StringBuilder is high in performance but lacks thread-safety compared to StringBuffer.\n\nExample: Here, you can see all Type of methods which included , , , , , etc. in StringBuilder class.\n• None The code demonstrates the usage of multiple StringBuilder methods , , , , ,\n• “GeeksforGeeks” is used the operations to make the examples."
    },
    {
        "link": "https://stackoverflow.com/questions/19279586/best-way-to-modify-an-existing-string-stringbuilder-or-convert-to-char-array-an",
        "document": "As written, the code in your second example will create just two arrays: one when you call , and another when you call ( stores data in a char[] array). The element manipulations you are performing should not trigger any object allocations. There are no copies being made of the array when you read or write an element.\n\nIf you are going to be doing any sort of manipulation, the recommended practice is to use a . If you are writing very performance-sensitive code, and your transformation does not alter the length of the string, then it might be worthwhile to manipulate the array directly. But since you are learning Java as a new language, I am going to guess that you are not working in high frequency trading or any other environment where latency is critical. Therefore, you are probably better off using a .\n\nIf you are performing any transformations that might yield a string of a different length than the original, you should almost certainly use a ; it will resize its internal buffer as necessary.\n\nOn a related note, if you are doing simple string concatenation (e.g, ), the compiler will actually transform those operations into a chain of calls, so you are free to use whichever you find more aesthetically pleasing. I personally prefer the operator. However, if you are building up a string across multiple statements, you should create a single .\n\nHere, we have a single, long expression involving many concatenations. You don't need to worry about hand-optimizing this, because the compiler will use a single and just call on it repeatedly.\n\nHere, you'll end up with two being created under the covers, but unless this is an extremely hot code path in a latency-critical application, it's really not worth fretting about. Given similar code, but with many more separate concatenations, it might be worth optimizing. Same goes if you know the strings might be very large. But don't just guess--measure! Demonstrate that there's a performance problem before you try to fix it. (Note: this is just a general rule for \"micro optimizations\"; there's rarely a downside to explicitly using a . But don't assume it will make a measurable difference: if you're concerned about it, you should actually measure.)\n\nHere, we're performing a separate concatenation operation on each loop iteration, which means a new will be allocated on each pass. In this case, it's probably worth using a single since you may not know how large the collection will be. I would consider this an exception to the \"prove there's a performance problem before optimizing rule\": if the operation has the potential to explode in complexity based on input, err on the side of caution."
    },
    {
        "link": "https://stackoverflow.com/questions/31382825/pass-by-value-stringbuilder-vs-string",
        "document": "I do not understand why System.out.println(name) outputs Sam without being affected by the method's concat function, while System.out.println(names) outputs Sam4 as a result of the method's append method. Why is StringBuilder affected and not String? Normally, calling methods on a reference to an object affects the caller, so I do not understand why the String result remains unchanged. Thanks in advance\n\nThis question already has answers here :\n\nBecause when you call , inside speak when you do it creates a new object because s are immutable. When you change the original string it creates a new object,I agree that you are returning it but you are not catching it. So essentially what you are doing is : name(new) = name(original) + '4'; // but you should notice that both the names are different objects. Of course now I think there is no need to explain why it's working with unless if you don't know that is mutable.\n\nOkay, what is method doing? creates new object, which is equal to , concatenated with . Then you return the reference to this new value with So, the original variable, passed within method is not modified, but the method returns modified value. In the method you actually modify variable without modifying the reference (the class is mutable, so variable if this type can be modified). Then we can see another question arising: why returns value, where it can seem redundant. The answer to this question lies in the description of \"builder\" pattern, for which it is the usual way of implementing modification methods. See wikipedia on Builder pattern.\n\nWhen you invoke it computes the new value, but discards it. the result will be the one you expect. With the , the object you pass is mutable: so changes the state of the current object (it also returns a reference to the same object, which is just a convenience to allow you to write code like etc.). So in the case of the , the object you are referencing when you call the method has actually changed, hence you see the changes.\n\nIn your method , the method returns a new String, the original object it was called on is unchanged (strings are immutable). As documented: If the length of the argument string is , then this object is returned. Otherwise, a object is returned that represents a character sequence that is the concatenation of the character sequence represented by this object and the character sequence represented by the argument string. Calling is the equivalent of . In your method the method modifies the content of the . As documented: The principal operations on a are the and methods, which are overloaded so as to accept data of any type. Each effectively converts a given datum to a string and then appends or inserts the characters of that string to the string builder. The method always adds these characters at the end of the builder; the method adds the characters at a specified point. In your main method both and are still the same object as before the method call, but the content of is unchanged as strings are immutable, while the content of has been changed. If instead you had used the return values of both methods, then you would have the result you were expecting.\n\nFirst of all, is an immutable class in Java. An immutable class is simply a class whose instances cannot be modified. All information in an instance is initialized when the instance is created and the information can not be modified. Second, in java parameters are sent by values and not by reference. In your method 'test' you don't need , instead will be enough . If you check java docs for String object, you will see that most of the methods there, including concat, will generate a new String. So to have on output Sam4 also for the String, you will need in main method to have this ."
    },
    {
        "link": "https://simplilearn.com/tutorials/java-tutorial/stringbuilder-in-java",
        "document": ""
    },
    {
        "link": "https://chankok.com/java-modify-strings-with-stringbuilder",
        "document": "The class and class are identical. Both classes are mutable and have similar methods for inserting, replacing and modifying a strings.\n\nFor single-threaded program, it is recommended to use because it is faster than .\n\nIn this tutorial, we’ll show you some examples of how to use class to append, insert, replace, delete and reverse the strings in a string builder.\n\nAppend new strings at the end of a string builder.\n\nInsert new strings at a specified position in a string builder.\n\nReplace with new character or strings at a specified position in a string builder."
    },
    {
        "link": "https://geeksforgeeks.org/stringbuilder-class-in-java-with-examples",
        "document": "In Java, StringBuilder class is a part of the package that provides a mutable sequence of characters. Unlike , which creates a new object for every modification, StringBuilder allows in-place changes, making it memory-efficient and faster for large or frequent string manipulations.\n• None in Java creates an immutable sequence of characters, whereas StringBuilder creates a mutable sequence of characters, offering an alternative.\n• None Functionality of StringBuilder is similar to the StringBuffer class, as both provide mutable sequences of characters.\n• None StringBuilder is designed as a drop-in replacement for StringBuffer in scenarios where StringBuffer is used by a single thread.\n• None StringBuilder is faster than StringBuffer in most implementations.\n• None StringBuilder is not thread-safe and should not be used in multi-threaded environments. If thread safety is required, it is recommended to use StringBuffer instead.\n• None StringBuilder is high in performance but lacks thread-safety compared to StringBuffer.\n\nExample: Here, you can see all Type of methods which included , , , , , etc. in StringBuilder class.\n• None The code demonstrates the usage of multiple StringBuilder methods , , , , ,\n• “GeeksforGeeks” is used the operations to make the examples."
    },
    {
        "link": "https://ocw.mit.edu/ans7870/6/6.005/s16/classes/09-immutability",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/31382825/pass-by-value-stringbuilder-vs-string",
        "document": "I do not understand why System.out.println(name) outputs Sam without being affected by the method's concat function, while System.out.println(names) outputs Sam4 as a result of the method's append method. Why is StringBuilder affected and not String? Normally, calling methods on a reference to an object affects the caller, so I do not understand why the String result remains unchanged. Thanks in advance\n\nThis question already has answers here :\n\nBecause when you call , inside speak when you do it creates a new object because s are immutable. When you change the original string it creates a new object,I agree that you are returning it but you are not catching it. So essentially what you are doing is : name(new) = name(original) + '4'; // but you should notice that both the names are different objects. Of course now I think there is no need to explain why it's working with unless if you don't know that is mutable.\n\nOkay, what is method doing? creates new object, which is equal to , concatenated with . Then you return the reference to this new value with So, the original variable, passed within method is not modified, but the method returns modified value. In the method you actually modify variable without modifying the reference (the class is mutable, so variable if this type can be modified). Then we can see another question arising: why returns value, where it can seem redundant. The answer to this question lies in the description of \"builder\" pattern, for which it is the usual way of implementing modification methods. See wikipedia on Builder pattern.\n\nWhen you invoke it computes the new value, but discards it. the result will be the one you expect. With the , the object you pass is mutable: so changes the state of the current object (it also returns a reference to the same object, which is just a convenience to allow you to write code like etc.). So in the case of the , the object you are referencing when you call the method has actually changed, hence you see the changes.\n\nIn your method , the method returns a new String, the original object it was called on is unchanged (strings are immutable). As documented: If the length of the argument string is , then this object is returned. Otherwise, a object is returned that represents a character sequence that is the concatenation of the character sequence represented by this object and the character sequence represented by the argument string. Calling is the equivalent of . In your method the method modifies the content of the . As documented: The principal operations on a are the and methods, which are overloaded so as to accept data of any type. Each effectively converts a given datum to a string and then appends or inserts the characters of that string to the string builder. The method always adds these characters at the end of the builder; the method adds the characters at a specified point. In your main method both and are still the same object as before the method call, but the content of is unchanged as strings are immutable, while the content of has been changed. If instead you had used the return values of both methods, then you would have the result you were expecting.\n\nFirst of all, is an immutable class in Java. An immutable class is simply a class whose instances cannot be modified. All information in an instance is initialized when the instance is created and the information can not be modified. Second, in java parameters are sent by values and not by reference. In your method 'test' you don't need , instead will be enough . If you check java docs for String object, you will see that most of the methods there, including concat, will generate a new String. So to have on output Sam4 also for the String, you will need in main method to have this ."
    },
    {
        "link": "https://baeldung.com/java-mutable-vs-immutable-objects",
        "document": "When working with objects in Java, understanding the difference between mutable and immutable objects is crucial. These concepts impact the behavior and design of your Java code.\n\nIn this tutorial, let’s explore the definitions, examples, advantages, and considerations of both mutable and immutable objects.\n\nImmutable objects are objects whose state cannot be changed once they are created. Once an immutable object is instantiated, its values and properties remain constant throughout its lifetime.\n\nLet’s explore some examples of built-in immutable classes in Java.\n\nThe immutability of Strings in Java ensures thread safety, enhances security, and helps with the efficient use of memory through the String Pool mechanism.\n\nIn this example, the concat() method creates a new String, and the original String remains unchanged.\n\nIn Java, the Integer class is immutable, meaning its values cannot be changed once they are set. However, when you perform operations on an Integer, a new instance is created to hold the result.\n\nHere, the + operation creates a new Integer object, and the original object remains immutable.\n\nImmutable objects in Java offer several advantages that contribute to code reliability, simplicity, and performance. Let’s understand some of the benefits of using immutable objects:\n• Thread Safety: Immutability inherently ensures thread safety. Since the state of an immutable object cannot be modified after creation, it can be safely shared among multiple threads without the need for explicit synchronization. This simplifies concurrent programming and reduces the risk of race conditions.\n• Predictability and Debugging: The constant state of immutable objects makes code more predictable. Once created, an immutable object’s values remain unchanged, simplifying reasoning about code behavior.\n• Facilitates Caching and Optimization: Immutable objects can be easily cached and reused. Once created, an immutable object’s state does not change, allowing for efficient caching strategies.\n\nTherefore, developers can design more robust, predictable, and efficient systems using immutable objects in their Java applications.\n\nTo create an immutable object, let’s consider an example of a class named ImmutablePerson. The class is declared as final to prevent extension, and it contains private final fields with no setter methods, adhering to the principles of immutability.\n\nNow, let’s consider what happens when we attempt to modify the name of an instance of ImmutablePerson:\n\nThe attempt to modify the name of an ImmutablePerson instance will result in a compilation error. This is because the class is designed to be immutable, with no setter methods allowing changes to its state after instantiation.\n\nThe absence of setters and the declaration of the class as final ensure the immutability of the object, providing a clear and robust way to handle a constant state throughout its lifecycle.\n\nMutable objects in Java are entities whose state can be modified after their creation. This mutability introduces the concept of changeable internal data, allowing values and properties to be altered during the object’s lifecycle.\n\nLet’s explore a couple of examples to understand their characteristics.\n\nThe StringBuilder class in Java represents a mutable sequence of characters. Unlike its immutable counterpart, String, a StringBuilder allows the dynamic modification of its content.\n\nHere, the append method directly alters the internal state of the StringBuilder object, showcasing its mutability.\n\nThe ArrayList class is another example of a mutable object. It represents a dynamic array that can grow or shrink in size, allowing the addition and removal of elements.\n\nThe add method modifies the state of the ArrayList by adding an element, exemplifying its mutable nature.\n\nWhile mutable objects offer flexibility, they come with certain considerations that developers need to be mindful of:\n• Thread Safety: Mutable objects may require additional synchronization mechanisms to ensure thread safety in a multi-threaded environment. Without proper synchronization, concurrent modifications can lead to unexpected behavior.\n• Complexity in Code Understanding: The ability to modify the internal state of mutable objects introduces complexity in code understanding. Developers need to be cautious about the potential changes to an object’s state, especially in large codebases.\n• State Management Challenges: Managing the internal state of mutable objects requires careful consideration. Developers should track and control changes to ensure the object’s integrity and prevent unintended modifications.\n\nDespite these considerations, mutable objects provide a dynamic and flexible approach, allowing developers to adapt the state of an object based on changing requirements.\n\nWhen contrasting mutable and immutable objects, several factors come into play. Let’s explore the fundamental differences between these two types of objects:\n\nThe choice between mutability and immutability relies on the application’s requirements. If adaptability and frequent changes are necessary, opt for mutable objects. However, if consistency, safety, and a stable state are priorities, immutability is the way to go.\n\nConsider the concurrency aspect in multitasking scenarios. Immutability simplifies data sharing among tasks without the complexities of synchronization.\n\nAdditionally, assess your application’s performance needs. While immutable objects generally enhance performance, weigh whether this boost is more significant than the flexibility offered by mutable objects, especially in situations with infrequent data changes.\n\nMaintaining the right balance ensures your code aligns effectively with your application’s demands.\n\nIn conclusion, the choice between mutable and immutable objects in Java plays a crucial role in shaping the reliability, efficiency, and maintainability of your code. While immutability provides thread safety, predictability, and other advantages, mutability offers flexibility and dynamic state changes.\n\nAssessing your application’s requirements and considering factors such as concurrency, performance, and code complexity will help in making the appropriate choice for designing resilient and efficient Java applications.\n\nYou can find the examples used in this article over on GitHub."
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html",
        "document": "\n• argument. The overall effect is exactly as if the argument were converted to a string by the method , and the characters of that string were then to this character sequence.\n• Appends the specified string to this character sequence. The characters of the argument are appended, in order, increasing the length of this sequence by the length of the argument. If is , then the four characters are appended. Let n be the length of this character sequence just prior to execution of the method. Then the character at index k in the new character sequence is equal to the character at index k in the old character sequence, if k is less than n; otherwise, it is equal to the character at index k-n in the argument .\n• to this sequence. The characters of the argument are appended, in order, to this sequence, increasing the length of this sequence by the length of the argument. If is , then the four characters are appended to this sequence. Let n be the length of this character sequence just prior to execution of the method. Then the character at index k in the new character sequence is equal to the character at index k in the old character sequence, if k is less than n; otherwise, it is equal to the character at index k-n in the argument .\n• . Appends the specified character sequence to this Depending on which class implements the character sequence , the entire sequence may not be appended. For instance, if is a then the subsequence to append is defined by the buffer's position and limit. - The character sequence to append. If is , then the four characters are appended to this Appendable.\n• to this sequence. Appends a subsequence of the specifiedto this sequence. Characters of the argument , starting at index , are appended, in order, to the contents of this sequence up to the (exclusive) index . The length of this sequence is increased by the value of . Let n be the length of this character sequence just prior to execution of the method. Then the character at index k in this character sequence becomes equal to the character at index k in this sequence, if k is less than n; otherwise, it is equal to the character at index k+start-n in the argument . If is , then this method appends characters as if the s parameter was a sequence containing the four characters . - the starting index of the subsequence to be appended. - the end index of the subsequence to be appended. - if is negative, or is greater than or is greater than\n• array argument to this sequence. Appends the string representation of thearray argument to this sequence. The characters of the array argument are appended, in order, to the contents of this sequence. The length of this sequence increases by the length of the argument. The overall effect is exactly as if the argument were converted to a string by the method , and the characters of that string were then to this character sequence. - the characters to be appended.\n• array argument to this sequence. Appends the string representation of a subarray of thearray argument to this sequence. Characters of the array , starting at index , are appended, in order, to the contents of this sequence. The length of this sequence increases by the value of . The overall effect is exactly as if the arguments were converted to a string by the method , and the characters of that string were then to this character sequence. - the characters to be appended. - the index of the first to append. - the number of s to append. - if or or\n• argument to the sequence. Appends the string representation of theargument to the sequence. The overall effect is exactly as if the argument were converted to a string by the method , and the characters of that string were then to this character sequence.\n• argument to this sequence. Appends the string representation of theargument to this sequence. The argument is appended to the contents of this sequence. The length of this sequence increases by . The overall effect is exactly as if the argument were converted to a string by the method , and the character in that string were then to this character sequence.\n• argument to this sequence. Appends the string representation of theargument to this sequence. The overall effect is exactly as if the argument were converted to a string by the method , and the characters of that string were then to this character sequence.\n• argument to this sequence. Appends the string representation of theargument to this sequence. The overall effect is exactly as if the argument were converted to a string by the method , and the characters of that string were then to this character sequence.\n• argument to this sequence. Appends the string representation of theargument to this sequence. The overall effect is exactly as if the argument were converted to a string by the method , and the characters of that string were then to this character sequence.\n• argument to this sequence. Appends the string representation of theargument to this sequence. The overall effect is exactly as if the argument were converted to a string by the method , and the characters of that string were then to this character sequence.\n• argument to this sequence. Appends the string representation of theargument to this sequence. The argument is appended to the contents of this sequence. The length of this sequence increases by . The overall effect is exactly as if the argument were converted to a array by the method and the character in that array were then to this character sequence.\n• Removes the characters in a substring of this sequence. The substring begins at the specified and extends to the character at index or to the end of the sequence if no such character exists. If is equal to , no changes are made. - if is negative, greater than , or greater than .\n• at the specified position in this sequence. This sequence is shortened by one . Removes theat the specified position in this sequence. This sequence is shortened by one Note: If the character at the given index is a supplementary character, this method does not remove the entire character. If correct handling of supplementary characters is required, determine the number of s to remove by calling , where is this sequence. - if the is negative or greater than or equal to .\n• Replaces the characters in a substring of this sequence with characters in the specified . The substring begins at the specified and extends to the character at index or to the end of the sequence if no such character exists. First the characters in the substring are removed and then the specified is inserted at . (This sequence will be lengthened to accommodate the specified String if necessary.) - if is negative, greater than , or greater than .\n• Inserts the string representation of a subarray of the array argument into this sequence. The subarray begins at the specified and extends s. The characters of the subarray are inserted into this sequence at the position indicated by . The length of this sequence increases by s. - position at which to insert subarray. - the index of the first in subarray to be inserted. - the number of s in the subarray to be inserted. - if is negative or greater than , or or are negative, or is greater than .\n• argument into this character sequence. Inserts the string representation of theargument into this character sequence. The overall effect is exactly as if the second argument were converted to a string by the method , and the characters of that string were then into this character sequence at the indicated offset. The argument must be greater than or equal to , and less than or equal to the length of this sequence. - if the offset is invalid.\n• Inserts the string into this character sequence. The characters of the argument are inserted, in order, into this sequence at the indicated offset, moving up any characters originally above that position and increasing the length of this sequence by the length of the argument. If is , then the four characters are inserted into this sequence. The character at index k in the new character sequence is equal to:\n• the character at index k in the old character sequence, if k is less than\n• the character at index k in the argument , if k is not less than but is less than\n• the character at index k in the old character sequence, if k is not less than The argument must be greater than or equal to , and less than or equal to the length of this sequence. - if the offset is invalid.\n• array argument into this sequence. Inserts the string representation of thearray argument into this sequence. The characters of the array argument are inserted into the contents of this sequence at the position indicated by . The length of this sequence increases by the length of the argument. The overall effect is exactly as if the second argument were converted to a string by the method , and the characters of that string were then into this character sequence at the indicated offset. The argument must be greater than or equal to , and less than or equal to the length of this sequence. - if the offset is invalid.\n• into this sequence. The characters of the argument are inserted, in order, into this sequence at the indicated offset, moving up any characters originally above that position and increasing the length of this sequence by the length of the argument s. The result of this method is exactly the same as if it were an invocation of this object's (dstOffset, s, 0, s.length()) method. If is , then the four characters are inserted into this sequence. - the sequence to be inserted - if the offset is invalid.\n• into this sequence. Inserts a subsequence of the specifiedinto this sequence. The subsequence of the argument specified by and are inserted, in order, into this sequence at the specified destination offset, moving up any characters originally above that position. The length of this sequence is increased by . The character at index k in this sequence becomes equal to:\n• the character at index k in this sequence, if k is less than\n• the character at index k in the argument , if k is greater than or equal to but is less than\n• the character at index k in this sequence, if k is greater than or equal to The argument must be greater than or equal to , and less than or equal to the length of this sequence. The start argument must be nonnegative, and not greater than . The end argument must be greater than or equal to , and less than or equal to the length of s. If is , then this method inserts characters as if the s parameter was a sequence containing the four characters . - the offset in this sequence. - the sequence to be inserted. - the starting index of the subsequence to be inserted. - the end index of the subsequence to be inserted. - if is negative or greater than , or or are negative, or is greater than or is greater than\n• argument into this sequence. Inserts the string representation of theargument into this sequence. The overall effect is exactly as if the second argument were converted to a string by the method , and the characters of that string were then into this character sequence at the indicated offset. The argument must be greater than or equal to , and less than or equal to the length of this sequence. - if the offset is invalid.\n• argument into this sequence. Inserts the string representation of theargument into this sequence. The overall effect is exactly as if the second argument were converted to a string by the method , and the character in that string were then into this character sequence at the indicated offset. The argument must be greater than or equal to , and less than or equal to the length of this sequence. - if the offset is invalid.\n• argument into this sequence. Inserts the string representation of the secondargument into this sequence. The overall effect is exactly as if the second argument were converted to a string by the method , and the characters of that string were then into this character sequence at the indicated offset. The argument must be greater than or equal to , and less than or equal to the length of this sequence. - if the offset is invalid.\n• argument into this sequence. Inserts the string representation of theargument into this sequence. The overall effect is exactly as if the second argument were converted to a string by the method , and the characters of that string were then into this character sequence at the indicated offset. The argument must be greater than or equal to , and less than or equal to the length of this sequence. - if the offset is invalid.\n• argument into this sequence. Inserts the string representation of theargument into this sequence. The overall effect is exactly as if the second argument were converted to a string by the method , and the characters of that string were then into this character sequence at the indicated offset. The argument must be greater than or equal to , and less than or equal to the length of this sequence. - if the offset is invalid.\n• argument into this sequence. Inserts the string representation of theargument into this sequence. The overall effect is exactly as if the second argument were converted to a string by the method , and the characters of that string were then into this character sequence at the indicated offset. The argument must be greater than or equal to , and less than or equal to the length of this sequence. - if the offset is invalid.\n• k such that: is . Returns the index within this string of the first occurrence of the specified substring. The integer returned is the smallest valuesuch that:is if the string argument occurs as a substring within this object, then the index of the first character of the first such substring is returned; if it does not occur as a substring, is returned.\n• for which: If no such value of k exists, then -1 is returned. Returns the index within this string of the first occurrence of the specified substring, starting at the specified index. The integer returned is the smallest valuefor which:If no such value ofexists, then -1 is returned. - the substring for which to search. - the index from which to start the search. the index within this string of the first occurrence of the specified substring, starting at the specified index.\n• . The returned index is the largest value k such that is true. Returns the index within this string of the rightmost occurrence of the specified substring. The rightmost empty string \"\" is considered to occur at the index value. The returned index is the largest valuesuch thatis true. - the substring to search for. if the string argument occurs one or more times as a substring within this object, then the index of the first character of the last such substring is returned. If it does not occur as a substring, is returned.\n• k such that: If no such value of k exists, then -1 is returned. Returns the index within this string of the last occurrence of the specified substring. The integer returned is the largest valuesuch that:If no such value ofexists, then -1 is returned. - the substring to search for. - the index to start the search from. the index within this sequence of the last occurrence of the specified substring.\n• n be the character length of this character sequence (not the length in values) just prior to execution of the method. Then the character at index k in the new character sequence is equal to the character at index n-k-1 in the old character sequence. Causes this character sequence to be replaced by the reverse of the sequence. If there are any surrogate pairs included in the sequence, these are treated as single characters for the reverse operation. Thus, the order of the high-low surrogates is never reversed. Letbe the character length of this character sequence (not the length invalues) just prior to execution of themethod. Then the character at indexin the new character sequence is equal to the character at indexin the old character sequence. Note that the reverse operation may result in producing surrogate pairs that were unpaired low-surrogates and high-surrogates before the operation. For example, reversing \"\\uDC00\\uD800\" produces \"\\uD800\\uDC00\" which is a valid surrogate pair.\n• Returns a string representing the data in this sequence. A new object is allocated and initialized to contain the character sequence currently represented by this object. This is then returned. Subsequent changes to this sequence do not affect the contents of the . a string representation of this sequence of characters.\n• the length of the sequence of characters currently represented by this object\n• Returns the current capacity. The capacity is the amount of storage available for newly inserted characters, beyond which an allocation will occur.\n• \n• Twice the old capacity, plus . If the argument is nonpositive, this method takes no action and simply returns. Note that subsequent operations on this object can reduce the actual capacity below that requested here. Ensures that the capacity is at least equal to the specified minimum. If the current capacity is less than the argument, then a new internal array is allocated with greater capacity. The new capacity is the larger of:If theargument is nonpositive, this method takes no action and simply returns. Note that subsequent operations on this object can reduce the actual capacity below that requested here.\n• Attempts to reduce storage used for the character sequence. If the buffer is larger than necessary to hold its current sequence of characters, then it may be resized to become more space efficient. Calling this method may, but is not required to, affect the value returned by a subsequent call to the method.\n• k less than , the character at index k in the new character sequence is the same as the character at index k in the old sequence if k is less than the length of the old character sequence; otherwise, it is the null character . In other words, if the argument is less than the current length, the length is changed to the specified length. Sets the length of the character sequence. The sequence is changed to a new character sequence whose length is specified by the argument. For every nonnegative indexless than, the character at indexin the new character sequence is the same as the character at indexin the old sequence ifis less than the length of the old character sequence; otherwise, it is the null character. In other words, if theargument is less than the current length, the length is changed to the specified length. If the argument is greater than or equal to the current length, sufficient null characters ( ) are appended so that length becomes the argument. The argument must be greater than or equal to . - if the argument is negative.\n• value in this sequence at the specified index. The first value is at index , the next at index , and so on, as in array indexing. Returns thevalue in this sequence at the specified index. The firstvalue is at index, the next at index, and so on, as in array indexing. The index argument must be greater than or equal to , and less than the length of this sequence. If the value specified by the index is a surrogate, the surrogate value is returned. - the index of the desired value. the value at the specified index. - if is negative or greater than or equal to .\n• values (Unicode code units) and ranges from to . Returns the character (Unicode code point) at the specified index. The index refers tovalues (Unicode code units) and ranges fromto If the value specified at the given index is in the high-surrogate range, the following index is less than the length of this sequence, and the value at the following index is in the low-surrogate range, then the supplementary code point corresponding to this surrogate pair is returned. Otherwise, the value at the given index is returned. - the index to the values the code point value of the character at the - if the argument is negative or not less than the length of this sequence.\n• values (Unicode code units) and ranges from to Returns the character (Unicode code point) before the specified index. The index refers tovalues (Unicode code units) and ranges fromto If the value at is in the low-surrogate range, is not negative, and the value at is in the high-surrogate range, then the supplementary code point value of the surrogate pair is returned. If the value at is an unpaired low-surrogate or a high-surrogate, the surrogate value is returned. - the index following the code point that should be returned the Unicode code point value before the given index. - if the argument is less than 1 or greater than the length of this sequence.\n• Returns the number of Unicode code points in the specified text range of this sequence. The text range begins at the specified and extends to the at index . Thus the length (in s) of the text range is . Unpaired surrogates within this sequence count as one code point each. - the index to the first of the text range. - the index after the last of the text range. the number of Unicode code points in the specified text range - if the is negative, or is larger than the length of this sequence, or is larger than .\n• Returns the index within this sequence that is offset from the given by code points. Unpaired surrogates within the text range given by and count as one code point each. - the index to be offset the index within this sequence - if is negative or larger then the length of this sequence, or if is positive and the subsequence starting with has fewer than code points, or if is negative and the subsequence before has fewer than the absolute value of code points.\n• . The first character to be copied is at index ; the last character to be copied is at index . The total number of characters to be copied is . The characters are copied into the subarray of starting at index and ending at index: Characters are copied from this sequence into the destination character array. The first character to be copied is at index; the last character to be copied is at index. The total number of characters to be copied is. The characters are copied into the subarray ofstarting at indexand ending at index: - the array to copy the data into. - if any of the following is true:\n• the argument is greater than the argument.\n• . This sequence is altered to represent a new character sequence that is identical to the old character sequence, except that it contains the character at position . The character at the specified index is set to. This sequence is altered to represent a new character sequence that is identical to the old character sequence, except that it contains the characterat position The index argument must be greater than or equal to , and less than the length of this sequence. - the index of the character to modify. - if is negative or greater than or equal to .\n• Returns a new that contains a subsequence of characters currently contained in this character sequence. The substring begins at the specified index and extends to the end of this sequence. - if is less than zero, or greater than the length of this object.\n• Returns a new character sequence that is a subsequence of this sequence. An invocation of this method of the form behaves in exactly the same way as the invocation This method is provided so that this class can implement the behaves in exactly the same way as the invocationThis method is provided so that this class can implement the interface. - if or are negative, if is greater than , or if is greater than\n• Returns a new that contains a subsequence of characters currently contained in this sequence. The substring begins at the specified and extends to the character at index . - if or are negative or greater than , or is greater than ."
    }
]