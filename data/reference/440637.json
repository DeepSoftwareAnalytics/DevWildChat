[
    {
        "link": "https://pypi.org/project/pywinrm",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    },
    {
        "link": "https://github.com/diyan/pywinrm",
        "document": "pywinrm is a Python client for the Windows Remote Management (WinRM) service. It allows you to invoke commands on target Windows machines from any machine that can run Python.\n\nWinRM allows you to perform various management tasks remotely. These include, but are not limited to: running batch scripts, powershell scripts, and fetching WMI variables.\n\nUsed by Ansible for Windows support.\n\nFor more information on WinRM, please visit Microsoft's WinRM site.\n\nNOTE: pywinrm will try and guess the correct endpoint url from the following formats:\n\nPowershell scripts will be base64 UTF16 little-endian encoded prior to sending to the Windows host. Error messages are converted from the Powershell CLIXML format to a human readable format as a convenience.\n\npywinrm supports various transport methods in order to authenticate with the WinRM server. The options that are supported in the parameter are;\n• : Basic auth only works for local Windows accounts not domain accounts. Credentials are base64 encoded when sending to the server.\n• : Authentication is done through a certificate that is mapped to a local Windows account on the server.\n• : When used in conjunction with and it will use a certificate as above. If not will revert to basic auth over HTTPS.\n• : Will use Kerberos authentication for domain accounts which only works when the client is in the same domain as the server and the required dependencies are installed. Currently a Kerberos ticket needs to be initialized outside of pywinrm using the command.\n• : Will use NTLM authentication for both domain and local accounts.\n• : Will use CredSSP authentication for both domain and local accounts. Allows double hop authentication. This only works over a HTTPS endpoint and not HTTP.\n\nBy default, WinRM will not accept unencrypted communication with a client. There are two ways to enable encrypted communication with pywinrm:\n• Use an HTTPS endpoint instead of HTTP (Recommended)\n• Use NTLM, Kerberos, or CredSSP as the transport auth\n\nUsing an HTTPS endpoint is recommended, as it will encrypt all the data sent to the server (including all headers), works securely with all auth types, and can properly verify remote host identity (when used with certificates signed by a verifiable certificate authority).\n\nThe second option is to use NTLM, Kerberos, or CredSSP, and set the arg to protocol to (the default value) or . This will use the authentication GSS-API Wrap and Unwrap methods to encrypt the message contents sent to the server. This form of encryption is independent of the transport layer, and the strength of the encryption used varies with the underlying authentication type selected (NTLM generally being the weakest and CredSSP the strongest).\n\nTo configure message encryption you can use the argument when initialising protocol. This option has 3 values that can be set as shown below.\n• : Default, Will only use message encryption if it is available for the auth method and HTTPS isn't used.\n• : Will never use message encryption even when not over HTTPS.\n• : Will always use message encryption even when running over HTTPS (fails if encryption support is unavailable on the selected auth method).\n\nIf you set the value to and the transport opt doesn't support message encryption (e.g., auth or an old version of without message encryption support is installed), pywinrm will throw an exception.\n\nIf you do not use an HTTPS endpoint or message encryption, a default-configured WinRM server will automatically reject requests from pywinrm. Server settings can be modified allow unencrypted messages and credentials, but this is highly insecure and should only be used for diagnostic purposes. To allow unencrypted communications, run the following on the WinRM server (cmd and powershell versions provided):\n\nAgain, this should not be used in production environments, as your credentials and WinRM messages can be trivially recovered.\n\nEnable WinRM basic authentication. For domain users, it is necessary to use NTLM, Kerberos, or CredSSP authentication (Kerberos and NTLM authentication are enabled by default, CredSSP is not).\n\nEnable WinRM CredSSP authentication. This allows double hop support so you can authenticate with a network service when running command son the remote host. This command is run in Powershell.\n\nWant to help - send a pull request. I will accept good pull requests for sure."
    },
    {
        "link": "https://pypi.org/project/pywinrm/0.0.2dev",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    },
    {
        "link": "https://github.com/diyan/pywinrm/releases",
        "document": "To see all available qualifiers, see our documentation .\n\nSaved searches Use saved searches to filter your results more quickly\n\nWe read every piece of feedback, and take your input very seriously.\n\nYou signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    },
    {
        "link": "https://docs.rundeck.com/docs/learning/howto/configuring-windows-nodes.html",
        "document": "Rundeck allows users to execute jobs to remote Windows nodes to manage and automate tasks using Rundeck workflows. This article shows how to add a Windows node and execute Rundeck jobs and commands with windows-based systems.\n\nTo communicate with Windows nodes, Rundeck uses an out-of-the-box Node Execution/ File Copier plugin that uses the WinRM (Windows Remote Management) protocol.\n\nThe pywinrm plugin needs the following requirements on the Rundeck server to work properly. It is supported on Rundeck running on Linux, Mac OS X, or Windows operating systems.\n\nMake sure that your python installation is same that the one that is exported in your \"PATH\" environment variable, so the PyWinRm plugin can access its packages.\n• We recommend this commands to check the python installation: The path to the executable must be the same if we dispatch the command to the required node with the AD-HOC command functionality.\n\nThe pywinrm plugin uses the python WinRM Library to provide the WinRM implementation.\n• Pywinrm library (It can be installed with the following command: )\n• OpenSSL version 1.1.1 or higher. (openssl version can be checked with the following command: )\n\nNote: Due to networking complexity issues this exercise will not work with the Welcome Projects. These steps assume you have Rundeck installed using these instructions. For more information see the Additional Information section.\n\nTo follow this How to Guide, your Windows system needs the following requirements:\n• A Windows node in the same network as the Rundeck instance\n\nThe first step is to configure the Windows machine. To do this, go to the Windows instance and follow the these steps:\n• Create a new project: Name , and Label\n• Go to the Default Node Executor tab and then select WinRM Node Executor Python. It may be necessary to set the Python interpreter textbox to interpreter as the command/path.\n• Go to the Default File Copier tab and select the WinRM Python File Copier. Similar to the previous step, it may be necessary to define the Python interpreter textbox as interpreter for the command/path. \n\n\n\n \n\n\n\n\n\nThe following properties can optionally be set in the WinRM Node Executor and WinRM File Copier:\n• : When this is set to , SSL is not validated in the WinRM communication. This can be overridden on nodes with .\n• : Check this box to execute over TLS 1.0\n• : Optionally choose HTTP or HTTPS for the WinRM transport protocol. This can be overridden on nodes with .\n• : The WinRM port to use. The default is port 5985. This can be overridden on nodes with .\n• : Optional username. The username can be set at node level (using the attribute ) or at job level (using an input option called ).\n• : The path for SSL verification. This can be overridden on nodes with .\n• : The maximum seconds to wait before an HTTP connect/read times out (default 30). This value should be slightly higher than operation timeout, as the server can block at least that long. This can be overridden on nodes with .\n• : Optionally specify a proxy address for communicating with Windows nodes. Example HTTP proxy strings are and . An example SOCKS5 proxy string is .\n• : The maximum allowed time in seconds for any single wsman HTTP operation (default 20). Note that operation timeouts while receiving output will be silently retried indefinitely. This can be overridden on nodes with .\n• : The Windows shell interpreter. Options include and . This can be overridden on nodes .\n• : Script Exit Behaviour. Options include:\n• (default): if the std-error console has data, the process fails.\n• : script won't fail by default, the user must control the exit code, such as by using a try/catch block. See this link for more details.\n• : Retry the connection to the node if the connection fails. This can be overridden on nodes with .\n• : Delay in seconds between each retry attempt. This can be overridden on nodes with .\n• : Path to a file, either on the Runbook Automation server or Enterprise Runner's host.\n• : If True, TGT is sent to target server to allow multiple hops.\n\n\n\n\n\nNow Rundeck should ask about the model source. Let's start with the Windows node definition.\n\nDon't forget to add the Windows user password to the Rundeck key storage.\n• Go to the System Menu(Gear Icon) > Key Storage.\n• Click on the + Add or Upload a Key button.\n• Enter the Windows password as shown in the image and save. \n\n\n\n \n\n\n\n\n\nNow it's time to send some commands against the windows remote machine.\n• Click on the Commands section on the left sidebar.\n• On the Nodes section use a filter to dispatch only to the Windows machine, type:\n• On the Enter a command textbox type: (listing directories and files).\n• Click on the Run on 1 Node button. \n\n\n\n \n\n\n\n\n\nAnd now your Windows node is ready to receive PowerShell commands from the Rundeck instance.\n\nUsing Linux? Read the Using SSH on Linux/Unix Nodes article to learn more.\n\nDocker Desktop has some limitations to how it handles networking. Check out this information about how to get the Rundeck Welcome Projects to connect to a single host on your local network."
    },
    {
        "link": "http://hurryupandwait.io/blog/understanding-and-troubleshooting-winrm-connection-and-authentication-a-thrill-seekers-guide-to-adventure",
        "document": "Connecting to a remote windows machine is often far more difficult than one would have expected. This was my experience years ago when I made my first attempt to use powershell remoting to connect to an Azure VM. At the time, powershell 2 was the hotness and many were talking up its remoting capabilities. I had been using powershell for about a year at the time and thought I'd give it a go. It wasn't simple at all and took a few hours to finally succeed. Now armed with 2012R2 and more knowledge its simpler but lets say you are trying to connect from a linux box using one of the open source WinRM ports, there are several gotchas. I started working for Chef about six weeks ago and it is not at all uncommon to find customers and fellow employees struggling with failure to talk to a remote windows node. I'd like to lay out in this post some of the fundamental moving parts as well as the troubleshooting decision tree I often use to figure out where things are wrong and how to get connected. I'll address cross platform scenarios using plain WinRM, powershell remoting from windows and some Chef specific tooling using the knife-windows gem. In my experience these are the primary hurdles to WinRM sweet success. First is connecting. Can I successfully establish a connection on a WinRM port to the remote machine? There are several things to get in the way here. Then a yak shave or two later you get past connectivity but are not granted access. What's that you say? You are signing in with admin credentials to the box?...I'm sorry say that again?...huh?...I just can't hear you. I am going to go into detail in this post on the different gotchas and their accompanying settings needed to successfully connect and execute commands on a remote windows machine using WinRM. However, if you are stuck right now and don't want to sift through all of this, here is a cheat sheet list of things to set to get you out of trouble:\n• Accessing via cross platform tools like chef, vagrant, packer, ruby or go? Run these commands:\n\nThe above commands used the default WinRM HTTP port to attempt to connect to the remote WinRM endpoint - 5985. WinRM is a SOAP based HTTP protocol. Side Note: In 2002, I used to car pool to my job in Sherman Oaks California with my friend Jimmy Bizzaro and would kill time by reading \"Programming Web Services with SOAP\" an O'Reilly publication. This was cutting edge, cool stuff. Java talking to .net, Java talking to Java but from different machines. This was the future. REST was done in a bed or on a toilet. So always remember, today's GO and Rust could be tomorrow's soap. Anyhoo...WinRM can talk HTTP and HTTPS. The default ports are 5985 and 5986 respectfully. However the default ports can be changed. Now usually the change is driven by network address translation. Sure these ports can be changed locally too, but in my experience if you need to access WinRM on ports other than 5985 or 5986 its usually to accommodate NAT. So check your Virtualbox NAT config or your Azure or EC2 port mappings to see if there is a port forwarding to 5985/6 on the VM. Those would be the ports you need to use. The Test-WSMan cmdlet also takes a -port parameter where you can provide a non standard WinRM port. So now you know the port to test but you are getting a non 0 netcat response or an error thrown from Test-WSMan. Now What? This is the first question I ask. If winrm is not listening for requests, then there is nothing to connect to. There are a couple ways to do this. What you usually do NOT want to do is simply start the winrm service. Not that that is a bad thing, its just not likely going to be enough. The two best ways to \"turn on\" WinRM are:\n\nAs you can probably tell so far, alot can go wrong and there are several moving parts to establishing a successful connection with a remote windows machine over WinRM. However, we are not there yet. Most of the gotchas here are when you are using HTTP instead of HTTPS and you are not domain joined. This tends to describe 95% of the dev/test scenarios I come in contact with. As we saw above, there is quite a bit of ceremony involved in getting SSL just right and running WinRM over HTTPS. Lets be clear: its the right thing to do especially in production. However, you can avoid the ceremony but that just means there is other ceremonial sacrifices to be made. At this point, if you are connecting over HTTPS, authentication is pretty straight forward. If not, there are often additional steps to take. However these additional steps tend to be less friction laden, but more security heinous, than the SSL setup. Both the Ruby WinRM gem and the Go winrm package do not interact with the native windows APIs needed to make Negotiate authentication possible and therefore must use Basic Authentication when using the HTTP transport. So unless you are either using native windows WinRM via winrs or powershell remoting or using knife-windows on a windows client (more on this in a bit), you must tweak some of the WinRM settings on the remote windows server to allow plain text basic authentication over HTTP. Here are the commands to run:\n\nOne bit of easy guidance here is that if you can't use Negotiate authentication, you really really should be using HTTPS with verifiable certificates. However if you are just trying to get off the ground with local Vagrant boxes and you find yourself in a situation getting WinRM Authentication errors but know you are passing the correct credentials, please try running these on the remote machine before inflicting personal bodily harm. I always include these commands in windows packer test images because that's what packer and vagrant need to talk to a windows box since they always use HTTP and are cross platform without access to the Negotiate APIs. This is quite the security hole indeed but usually tempered by the fact that it is on a test box in a NATed network on the local host. Perhaps we are due for a vagrant PR allowing one to pass SSL options in the Vagrantfile. That would be simple to add. Chef uses a separate gem that mostly monkey patches the WinRM gem if it sees that winrm is authenticating from windows to windows. In this case it leverages win32 APIs to use Negotiate authentication instead of Basic Authentication and therefore the above winrm settings can be avoided. However, if accessing from a linux client, it will drop to Basic Authentication and the settings shown above must then be present. Windows remote communication tends to be easier when you are using domain accounts. This is because domains create implicit trust boundaries so windows adds restrictions when using local accounts. Unfortunately the error messages you can sometimes get do not at all make it clear what you need to do to get past these restrictions. There are two issues with local accounts that I will mention: One thing that has previously tripped me up and I have seen others struggle with is related to authenticating local users. You may have a local user (not a domain user) and it is getting access denied errors trying to login. However if you prefix the user name with './', then the error is resolved. The './' prefix is equivelent to '<local host or ip>\\<user>'. Note that the './' prefix may not work in a windows login dialog box. In that case use the host name or IP address of the remote machine instead of '.'. This does not apply to the built in administrator account. So if you only logon as administrator, you will not run into this. However lets say I create a local mwrock account and even add this account to the local Administrators security group. If I try to connect remotely with this account using the default remoting settings on the server, I will get an Access Denied error if using powershell remoting or a WinRMAuthentication error if using the winrm gem. This is typically only visible on 2012R2. By default, the winrm service is running on a newly installed 2012R2 machine with an HTTP listener but without the LocalAccountTokenFilterPolicy enabled, while 2008R2 and client SKUs have no winrm service running at all. Running winrm quickconfig or Enable-PSRemoting on any OS will enable the LocalAccountTokenFilterPolicy, which will allow local accounts to logon. This simply sets the LocalAccountTokenFilterPolicy subkey of HKLM\\software\\Microsoft\\Windows\\CurrentVersion\\Policies\\system to 1. There is an additional security restriction imposed by powershell remoting when connected over HTTP on a non domain joined (work group) environment. You need to add the host name of the machine you are connecting to the list of trusted hosts. This is a white list of hosts you consider ok to talk to. If there are many, you can comma delimit the list. You can also include wildcards for domains and subdomains:\n\nNext you need to edit the local security policy on the machine to allow delegation to specific endpoints. In the gpedit GUI, navigate to Computer Configuration > Administrative Templates > System > Credential Delegation and enable \"Allow Delegating Fresh Credentials\". Further, you need to add the endpoints you authorize delegation to. You can add WSMAN\\*.my_domain.com to allow all endpoints in the my_domain.com domain. You can add as many entries as you need. Even more secure than usernames and passwords is using a x509 certificate signed by a trusted certificate authority. Many use this techniue when using SSH with SSH keys. Well, the same is possible with WinRM. I won't get into the details here since I have blogged separately on this topic here. As of the date of this post, Microsoft has released technical preview 3 of its new Windows Nano flavored server OS. I have previously blogged about this super light weight os but here is a winrm related bit of info that is unique to nano as of this version at least: there are no tools to tweak the winrm settings. Neither the winrm command or the winrm powershell provider are present. In order to make changes, you must edit the registry directly. These settings are located at: I've written an entire post on this topic and will not go into the same detail here. Basically I have found that once winrm is correctly configured, there is still a small subset of operations that will fail in a remote context. Any interaction with wsus is an example but please read my previous post for more. When you hit one of these road blocks, you typically have two options:\n• Use a Scheduled Task to execute the command in a local context\n• Install an SSH server and use that The second option appears to be imminent and in the end will make all of this easier and perhaps render this post irrelevant."
    },
    {
        "link": "https://github.com/diyan/pywinrm",
        "document": "pywinrm is a Python client for the Windows Remote Management (WinRM) service. It allows you to invoke commands on target Windows machines from any machine that can run Python.\n\nWinRM allows you to perform various management tasks remotely. These include, but are not limited to: running batch scripts, powershell scripts, and fetching WMI variables.\n\nUsed by Ansible for Windows support.\n\nFor more information on WinRM, please visit Microsoft's WinRM site.\n\nNOTE: pywinrm will try and guess the correct endpoint url from the following formats:\n\nPowershell scripts will be base64 UTF16 little-endian encoded prior to sending to the Windows host. Error messages are converted from the Powershell CLIXML format to a human readable format as a convenience.\n\npywinrm supports various transport methods in order to authenticate with the WinRM server. The options that are supported in the parameter are;\n• : Basic auth only works for local Windows accounts not domain accounts. Credentials are base64 encoded when sending to the server.\n• : Authentication is done through a certificate that is mapped to a local Windows account on the server.\n• : When used in conjunction with and it will use a certificate as above. If not will revert to basic auth over HTTPS.\n• : Will use Kerberos authentication for domain accounts which only works when the client is in the same domain as the server and the required dependencies are installed. Currently a Kerberos ticket needs to be initialized outside of pywinrm using the command.\n• : Will use NTLM authentication for both domain and local accounts.\n• : Will use CredSSP authentication for both domain and local accounts. Allows double hop authentication. This only works over a HTTPS endpoint and not HTTP.\n\nBy default, WinRM will not accept unencrypted communication with a client. There are two ways to enable encrypted communication with pywinrm:\n• Use an HTTPS endpoint instead of HTTP (Recommended)\n• Use NTLM, Kerberos, or CredSSP as the transport auth\n\nUsing an HTTPS endpoint is recommended, as it will encrypt all the data sent to the server (including all headers), works securely with all auth types, and can properly verify remote host identity (when used with certificates signed by a verifiable certificate authority).\n\nThe second option is to use NTLM, Kerberos, or CredSSP, and set the arg to protocol to (the default value) or . This will use the authentication GSS-API Wrap and Unwrap methods to encrypt the message contents sent to the server. This form of encryption is independent of the transport layer, and the strength of the encryption used varies with the underlying authentication type selected (NTLM generally being the weakest and CredSSP the strongest).\n\nTo configure message encryption you can use the argument when initialising protocol. This option has 3 values that can be set as shown below.\n• : Default, Will only use message encryption if it is available for the auth method and HTTPS isn't used.\n• : Will never use message encryption even when not over HTTPS.\n• : Will always use message encryption even when running over HTTPS (fails if encryption support is unavailable on the selected auth method).\n\nIf you set the value to and the transport opt doesn't support message encryption (e.g., auth or an old version of without message encryption support is installed), pywinrm will throw an exception.\n\nIf you do not use an HTTPS endpoint or message encryption, a default-configured WinRM server will automatically reject requests from pywinrm. Server settings can be modified allow unencrypted messages and credentials, but this is highly insecure and should only be used for diagnostic purposes. To allow unencrypted communications, run the following on the WinRM server (cmd and powershell versions provided):\n\nAgain, this should not be used in production environments, as your credentials and WinRM messages can be trivially recovered.\n\nEnable WinRM basic authentication. For domain users, it is necessary to use NTLM, Kerberos, or CredSSP authentication (Kerberos and NTLM authentication are enabled by default, CredSSP is not).\n\nEnable WinRM CredSSP authentication. This allows double hop support so you can authenticate with a network service when running command son the remote host. This command is run in Powershell.\n\nWant to help - send a pull request. I will accept good pull requests for sure."
    },
    {
        "link": "https://stackoverflow.com/questions/32324023/how-to-connect-to-remote-machine-via-winrm-in-python-pywinrm-using-domain-acco",
        "document": "Use this powershell script to enable winrm and configure winrm to all your windows nodes"
    },
    {
        "link": "https://learn.microsoft.com/en-us/powershell/scripting/security/remoting/winrm-security?view=powershell-7.5",
        "document": "PowerShell Remoting is the recommended way to manage Windows systems. PowerShell Remoting is enabled by default in Windows Server 2012 R2 and higher. This document covers security concerns, recommendations, and best practices when using PowerShell Remoting.\n\nPowerShell Remoting uses Windows Remote Management (WinRM) to allow users to run PowerShell commands on remote computers. WinRM is the Microsoft implementation of the Web Services for Management (WS-Management) protocol. You can find more information about using PowerShell Remoting at Running Remote Commands.\n\nPowerShell Remoting isn't the same as using the ComputerName parameter of a cmdlet to run it on a remote computer, which uses Remote Procedure Call (RPC) as its underlying protocol.\n\nPowerShell Remoting (and WinRM) listen on the following ports:\n\nBy default, PowerShell Remoting only allows connections from members of the Administrators group. Sessions are launched under the user's context, so all operating system access controls applied to individual users and groups continue to apply to them while connected over PowerShell Remoting.\n\nOn private networks, the default Windows Firewall rule for PowerShell Remoting accepts all connections. On public networks, the default Windows Firewall rule allows PowerShell Remoting connections only from within the same subnet. You have to explicitly change that rule to open PowerShell Remoting to all connections on a public network.\n\nPowerShell Remoting uses WinRM for communication between computers. WinRM runs as a service under the Network Service account, and spawns isolated processes running as user accounts to host PowerShell instances. An instance of PowerShell running as one user has no access to a process running an instance of PowerShell as another user.\n\nFireEye has provided a good summary of the event logs and other security evidence generated by PowerShell Remoting sessions, available at Investigating PowerShell Attacks.\n\nIt's helpful to consider the security of a PowerShell Remoting connection from two perspectives: initial authentication, and ongoing communication.\n\nRegardless of the transport protocol used (HTTP or HTTPS), WinRM always encrypts all PowerShell remoting communication after initial authentication.\n\nAuthentication confirms the identity of the client to the server - and ideally - the server to the client.\n\nWhen a client connects to a domain server using its computer name, the default authentication protocol is Kerberos. Kerberos guarantees both the user identity and server identity without sending any sort of reusable credential.\n\nWhen a client connects to a domain server using its IP address, or connects to a workgroup server, Kerberos authentication isn't possible. In that case, PowerShell Remoting relies on the NTLM authentication protocol. The NTLM authentication protocol guarantees the user identity without sending any sort of delegable credential. To prove user identity, the NTLM protocol requires that both the client and server compute a session key from the user's password without ever exchanging the password itself. The server typically doesn't know the user's password, so it communicates with the domain controller, which does know the user's password and calculates the session key for the server.\n\nThe NTLM protocol doesn't, however, guarantee server identity. As with all protocols that use NTLM for authentication, an attacker with access to a domain-joined computer's machine account could invoke the domain controller to compute an NTLM session-key and thereby impersonate the server.\n\nNTLM-based authentication is disabled by default, but may be permitted by either configuring SSL on the target server, or by configuring the WinRM TrustedHosts setting on the client.\n\nSince the NTLM authentication protocol can't ensure the identity of the target server (only that it already knows your password), you can configure target servers to use SSL for PowerShell Remoting. Assigning a SSL certificate to the target server (if issued by a Certificate Authority that the client also trusts) enables NTLM-based authentication that guarantees both the user identity and server identity.\n\nIf deploying a SSL certificate to a server for NTLM connections is infeasible, you may suppress the resulting identity errors by adding the server to the WinRM TrustedHosts list. Please note that adding a server name to the TrustedHosts list shouldn't be considered as any form of statement of the trustworthiness of the hosts themselves - as the NTLM authentication protocol can't guarantee that you are in fact connecting to the host you are intending to connect to. Instead, you should consider the TrustedHosts setting to be the list of hosts for which you wish to suppress the error generated by being unable to verify the server's identity.\n\nOnce initial authentication is complete, the WinRM encrypts the ongoing communication. When connecting over HTTPS, the TLS protocol is used to negotiate the encryption used to transport data. When connecting over HTTP, message-level encryption is determined by initial authentication protocol used.\n• NTLM authentication uses an RC4 cipher with a 128-bit key.\n• Kerberos authentication encryption is determined by the in the TGS ticket. This is AES-256 on modern systems.\n• CredSSP encryption is uses the TLS cipher suite that was negotiated in the handshake.\n\nBy default, PowerShell Remoting uses Kerberos (if available) or NTLM for authentication. Both of these protocols authenticate to the remote machine without sending credentials to it. This is the most secure way to authenticate, but because the remote machine doesn't have the user's credentials, it can't access other computers and services on the user's behalf. This is known as the \"second hop problem\".\n\nThere are several ways to avoid this problem. For descriptions of these methods, and the pros and cons of each, see Making the second hop in PowerShell Remoting."
    },
    {
        "link": "https://stackoverflow.com/questions/43550273/python-winrm-connect-using-local-account",
        "document": "I'm trying to connect to Windows server 2012 via python 2.7.13 on CentOS using winrm. The server is not part of a domain. I created a separate local administrator account to connect to it.\n\nUsed to provide that user all access.\n\nAdded exception in the firewall and made sure the service is up.\n\nAlso, I enabled Auditing for failed/successful logons but I don't see either failed or success for my attempts to connect.\n\nPlease tell me what's missing? I want to connect via local user."
    }
]