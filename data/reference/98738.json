[
    {
        "link": "https://docs.docker.com/get-started/docker-concepts/building-images/writing-a-dockerfile",
        "document": "A Dockerfile is a text-based document that's used to create a container image. It provides instructions to the image builder on the commands to run, files to copy, startup command, and more.\n\nAs an example, the following Dockerfile would produce a ready-to-run Python application:\n\nSome of the most common instructions in a include:\n• - this specifies the base image that the build will extend.\n• - this instruction specifies the \"working directory\" or the path in the image where files will be copied and commands will be executed.\n• - this instruction tells the builder to copy files from the host and put them into the container image.\n• - this instruction tells the builder to run the specified command.\n• - this instruction sets an environment variable that a running container will use.\n• - this instruction sets configuration on the image that indicates a port the image would like to expose.\n• - this instruction sets the default user for all subsequent instructions.\n• - this instruction sets the default command a container using this image will run.\n\nTo read through all of the instructions or go into greater detail, check out the Dockerfile reference .\n\nTry it out\n\nJust as you saw with the previous example, a Dockerfile typically follows these steps:\n\nIn this quick hands-on guide, you'll write a Dockerfile that builds a simple Node.js application. If you're not familiar with JavaScript-based applications, don't worry. It isn't necessary for following along with this guide.\n\nDownload this ZIP file and extract the contents into a directory on your machine.\n\nNow that you have the project, you’re ready to create the .\n• None Create a file named in the same folder as the file . It's important to note that the has no file extension. Some editors will automatically add an extension to the file (or complain it doesn't have one).\n• None In the , define your base image by adding the following line:\n• None Now, define the working directory by using the instruction. This will specify where future commands will run and the directory files will be copied inside the container image.\n• None Copy all of the files from your project on your machine into the container image by using the instruction:\n• None Install the app's dependencies by using the CLI and package manager. To do so, run a command using the instruction:\n• None Finally, specify the default command to run by using the instruction: And with that, you should have the following Dockerfile:\n\nIt's important to note that this Dockerfile is not following all of the best practices yet (by design). It will build the app, but the builds won't be as fast, or the images as secure, as they could be. Keep reading to learn more about how to make the image maximize the build cache, run as a non-root user, and multi-stage builds.\n\nTo learn more about writing a Dockerfile, visit the following resources:\n\nNow that you have created a Dockerfile and learned the basics, it's time to learn about building, tagging, and pushing the images."
    },
    {
        "link": "https://docs.docker.com/get-started/docker-concepts/building-images",
        "document": "Building container images is both technical and an art. You want to keep the image small and focused to increase your security posture, but also need to balance potential tradeoffs, such as caching impacts. In this series, you’ll deep dive into the secrets of images, how they are built and best practices.\n\nLearn how to build production-ready images that are lean and efficient Docker images, essential for minimizing overhead and enhancing deployment in production environments.\n\nHave you ever wondered how images work? This guide will help you to understand image layers - the fundamental building blocks of container images. You'll gain a comprehensive understanding of how layers are created, stacked, and utilized to ensure efficient and optimized containers.\n\nBuilding, tagging, and publishing Docker images are key steps in the containerization workflow. In this guide, you’ll learn how to create Docker images, how to tag those images with a unique identifier, and how to publish your image to a public registry.\n\nUsing the build cache effectively allows you to achieve faster builds by reusing results from previous builds and skipping unnecessary steps. To maximize cache usage and avoid resource-intensive and time-consuming rebuilds, it's crucial to understand how cache invalidation works. In this guide, you’ll learn how to use the Docker build cache efficiently for streamlined Docker image development and continuous integration workflows.\n\nBy separating the build environment from the final runtime environment, you can significantly reduce the image size and attack surface. In this guide, you'll unlock the power of multi-stage builds to create lean and efficient Docker images, essential for minimizing overhead and enhancing deployment in production environments."
    },
    {
        "link": "https://docs.docker.com/build/concepts/dockerfile",
        "document": "It all starts with a Dockerfile.\n\nDocker builds images by reading the instructions from a Dockerfile. A Dockerfile is a text file containing instructions for building your source code. The Dockerfile instruction syntax is defined by the specification reference in the Dockerfile reference.\n\nHere are the most common types of instructions:\n\nDockerfiles are crucial inputs for image builds and can facilitate automated, multi-layer image builds based on your unique configurations. Dockerfiles can start simple and grow with your needs to support more complex scenarios.\n\nThe default filename to use for a Dockerfile is , without a file extension. Using the default name allows you to run the command without having to specify additional command flags.\n\nSome projects may need distinct Dockerfiles for specific purposes. A common convention is to name these . You can specify the Dockerfile filename using the flag for the command. Refer to the CLI reference to learn about the flag.\n\nDocker images consist of layers. Each layer is the result of a build instruction in the Dockerfile. Layers are stacked sequentially, and each one is a delta representing the changes applied to the previous layer.\n\nHere's what a typical workflow for building applications with Docker looks like.\n\nThe following example code shows a small \"Hello World\" application written in Python, using the Flask framework.\n\nIn order to ship and deploy this application without Docker Build, you would need to make sure that:\n• The required runtime dependencies are installed on the server\n• The Python code gets uploaded to the server's filesystem\n• The server starts your application, using the necessary parameters\n\nThe following Dockerfile creates a container image, which has all the dependencies installed and that automatically starts your application.\n\nHere's a breakdown of what this Dockerfile does:\n\nThe first line to add to a Dockerfile is a parser directive. While optional, this directive instructs the Docker builder what syntax to use when parsing the Dockerfile, and allows older Docker versions with BuildKit enabled to use a specific Dockerfile frontend before starting the build. Parser directives must appear before any other comment, whitespace, or Dockerfile instruction in your Dockerfile, and should be the first line in Dockerfiles.\n\nThe line following the syntax directive defines what base image to use:\n\nThe instruction sets your base image to the 22.04 release of Ubuntu. All instructions that follow are executed in this base image: an Ubuntu environment. The notation , follows the standard for naming Docker images. When you build images, you use this notation to name your images. There are many public images you can leverage in your projects, by importing them into your build steps using the Dockerfile instruction.\n\nDocker Hub contains a large set of official images that you can use for this purpose.\n\nThe following line executes a build command inside the base image.\n\nThis instruction executes a shell in Ubuntu that updates the APT package index and installs Python tools in the container.\n\nNote the line. This is a comment. Comments in Dockerfiles begin with the symbol. As your Dockerfile evolves, comments can be instrumental to document how your Dockerfile works for any future readers and editors of the file, including your future self!\n\nThe second instruction installs the dependency required by the Python application.\n\nA prerequisite for this instruction is that is installed into the build container. The first command installs , which ensures that we can use the command to install the flask web framework.\n\nThe next instruction uses the instruction to copy the file from the local build context into the root directory of our image.\n\nA build context is the set of files that you can access in Dockerfile instructions such as and .\n\nAfter the instruction, the file is added to the filesystem of the build container.\n\nIf your application uses environment variables, you can set environment variables in your Docker build using the instruction.\n\nThis sets a Linux environment variable we'll need later. Flask, the framework used in this example, uses this variable to start the application. Without this, flask wouldn't know where to find our application to be able to run it.\n\nThe instruction marks that our final image has a service listening on port .\n\nThis instruction isn't required, but it is a good practice and helps tools and team members understand what this application is doing.\n\nFinally, instruction sets the command that is run when the user starts a container based on this image.\n\nThis command starts the flask development server listening on all addresses on port . The example here uses the \"exec form\" version of . It's also possible to use the \"shell form\":\n\nThere are subtle differences between these two versions, for example in how they trap signals like and . For more information about these differences, see Shell and exec form\n\nTo build a container image using the Dockerfile example from the previous section, you use the command:\n\nThe option specifies the name and tag of the image.\n\nThe single dot ( ) at the end of the command sets the build context to the current directory. This means that the build expects to find the Dockerfile and the file in the directory where the command is invoked. If those files aren't there, the build fails.\n\nAfter the image has been built, you can run the application as a container with , specifying the image name:\n\nThis publishes the container's port 8000 to on the Docker host."
    },
    {
        "link": "https://docs.docker.com/build",
        "document": "Docker Build is one of Docker Engine's most used features. Whenever you are creating an image you are using Docker Build. Build is a key part of your software development life cycle allowing you to package and bundle your code and ship it anywhere.\n\nDocker Build is more than a command for building images, and it's not only about packaging your code. It's a whole ecosystem of tools and features that support not only common workflow tasks but also provides support for more complex and advanced scenarios."
    },
    {
        "link": "https://docs.docker.com/get-started/workshop/02_our_app",
        "document": "For the rest of this guide, you'll be working with a simple todo list manager that runs on Node.js. If you're not familiar with Node.js, don't worry. This guide doesn't require any prior experience with JavaScript.\n• You have installed the latest version of Docker Desktop.\n• You have an IDE or a text editor to edit files. Docker recommends using Visual Studio Code .\n\nBefore you can run the application, you need to get the application source code onto your machine.\n• None Clone the getting-started-app repository using the following command:\n• None View the contents of the cloned repository. You should see the following files and sub-directories.\n\nTo build the image, you'll need to use a Dockerfile. A Dockerfile is simply a text-based file with no file extension that contains a script of instructions. Docker uses this script to build a container image.\n• None In the directory, the same location as the file, create a file named with the following contents: This Dockerfile starts off with a base image, a light-weight Linux image that comes with Node.js and the Yarn package manager pre-installed. It copies all of the source code into the image, installs the necessary dependencies, and starts the application.\n• None Build the image using the following commands: In the terminal, make sure you're in the directory. Replace with the path to your directory. The command uses the Dockerfile to build a new image. You might have noticed that Docker downloaded a lot of \"layers\". This is because you instructed the builder that you wanted to start from the image. But, since you didn't have that on your machine, Docker needed to download the image. After Docker downloaded the image, the instructions from the Dockerfile copied in your application and used to install your application's dependencies. The directive specifies the default command to run when starting a container from this image. Finally, the flag tags your image. Think of this as a human-readable name for the final image. Since you named the image , you can refer to that image when you run a container. The at the end of the command tells Docker that it should look for the in the current directory.\n\nNow that you have an image, you can run the application in a container using the command.\n• None Run your container using the command and specify the name of the image you just created: The flag (short for ) runs the container in the background. This means that Docker starts your container and returns you to the terminal prompt. Also, it does not display logs in the terminal. The flag (short for ) creates a port mapping between the host and the container. The flag takes a string value in the format of , where is the address on the host, and is the port on the container. The command publishes the container's port 3000 to ( ) on the host. Without the port mapping, you wouldn't be able to access the application from the host.\n• None After a few seconds, open your web browser to http://localhost:3000 . You should see your app.\n• None Add an item or two and see that it works as you expect. You can mark items as complete and remove them. Your frontend is successfully storing items in the backend.\n\nAt this point, you have a running todo list manager with a few items.\n\nIf you take a quick look at your containers, you should see at least one container running that's using the image and on port . To see your containers, you can use the CLI or Docker Desktop's graphical interface.\n\nIn this section, you learned the basics about creating a Dockerfile to build an image. Once you built an image, you started a container and saw the running app.\n\nNext, you're going to make a modification to your app and learn how to update your running application with a new image. Along the way, you'll learn a few other useful commands."
    },
    {
        "link": "https://docs.docker.com/build/concepts/dockerfile",
        "document": "It all starts with a Dockerfile.\n\nDocker builds images by reading the instructions from a Dockerfile. A Dockerfile is a text file containing instructions for building your source code. The Dockerfile instruction syntax is defined by the specification reference in the Dockerfile reference.\n\nHere are the most common types of instructions:\n\nDockerfiles are crucial inputs for image builds and can facilitate automated, multi-layer image builds based on your unique configurations. Dockerfiles can start simple and grow with your needs to support more complex scenarios.\n\nThe default filename to use for a Dockerfile is , without a file extension. Using the default name allows you to run the command without having to specify additional command flags.\n\nSome projects may need distinct Dockerfiles for specific purposes. A common convention is to name these . You can specify the Dockerfile filename using the flag for the command. Refer to the CLI reference to learn about the flag.\n\nDocker images consist of layers. Each layer is the result of a build instruction in the Dockerfile. Layers are stacked sequentially, and each one is a delta representing the changes applied to the previous layer.\n\nHere's what a typical workflow for building applications with Docker looks like.\n\nThe following example code shows a small \"Hello World\" application written in Python, using the Flask framework.\n\nIn order to ship and deploy this application without Docker Build, you would need to make sure that:\n• The required runtime dependencies are installed on the server\n• The Python code gets uploaded to the server's filesystem\n• The server starts your application, using the necessary parameters\n\nThe following Dockerfile creates a container image, which has all the dependencies installed and that automatically starts your application.\n\nHere's a breakdown of what this Dockerfile does:\n\nThe first line to add to a Dockerfile is a parser directive. While optional, this directive instructs the Docker builder what syntax to use when parsing the Dockerfile, and allows older Docker versions with BuildKit enabled to use a specific Dockerfile frontend before starting the build. Parser directives must appear before any other comment, whitespace, or Dockerfile instruction in your Dockerfile, and should be the first line in Dockerfiles.\n\nThe line following the syntax directive defines what base image to use:\n\nThe instruction sets your base image to the 22.04 release of Ubuntu. All instructions that follow are executed in this base image: an Ubuntu environment. The notation , follows the standard for naming Docker images. When you build images, you use this notation to name your images. There are many public images you can leverage in your projects, by importing them into your build steps using the Dockerfile instruction.\n\nDocker Hub contains a large set of official images that you can use for this purpose.\n\nThe following line executes a build command inside the base image.\n\nThis instruction executes a shell in Ubuntu that updates the APT package index and installs Python tools in the container.\n\nNote the line. This is a comment. Comments in Dockerfiles begin with the symbol. As your Dockerfile evolves, comments can be instrumental to document how your Dockerfile works for any future readers and editors of the file, including your future self!\n\nThe second instruction installs the dependency required by the Python application.\n\nA prerequisite for this instruction is that is installed into the build container. The first command installs , which ensures that we can use the command to install the flask web framework.\n\nThe next instruction uses the instruction to copy the file from the local build context into the root directory of our image.\n\nA build context is the set of files that you can access in Dockerfile instructions such as and .\n\nAfter the instruction, the file is added to the filesystem of the build container.\n\nIf your application uses environment variables, you can set environment variables in your Docker build using the instruction.\n\nThis sets a Linux environment variable we'll need later. Flask, the framework used in this example, uses this variable to start the application. Without this, flask wouldn't know where to find our application to be able to run it.\n\nThe instruction marks that our final image has a service listening on port .\n\nThis instruction isn't required, but it is a good practice and helps tools and team members understand what this application is doing.\n\nFinally, instruction sets the command that is run when the user starts a container based on this image.\n\nThis command starts the flask development server listening on all addresses on port . The example here uses the \"exec form\" version of . It's also possible to use the \"shell form\":\n\nThere are subtle differences between these two versions, for example in how they trap signals like and . For more information about these differences, see Shell and exec form\n\nTo build a container image using the Dockerfile example from the previous section, you use the command:\n\nThe option specifies the name and tag of the image.\n\nThe single dot ( ) at the end of the command sets the build context to the current directory. This means that the build expects to find the Dockerfile and the file in the directory where the command is invoked. If those files aren't there, the build fails.\n\nAfter the image has been built, you can run the application as a container with , specifying the image name:\n\nThis publishes the container's port 8000 to on the Docker host."
    },
    {
        "link": "https://docs.docker.com/reference/cli/docker/buildx/build",
        "document": "You can add other hosts into a build container's file by using one or more flags. This example adds static addresses for hosts named and :\n\nIf you need your build to connect to services running on the host, you can use the special value for . In the following example, build containers resolve to the host's gateway IP.\n\nYou can wrap an IPv6 address in square brackets. and are both valid separators. Both formats in the following example are valid:\n\nAdd OCI annotations to the image index, manifest, or descriptor. The following example adds the annotation to the image manifests:\n\nYou can optionally add a type prefix to specify the level of the annotation. By default, the image manifest is annotated. The following example adds the annotation the image index instead of the manifests:\n\nYou can specify multiple types, separated by a comma (,) to add the annotation to multiple image components. The following example adds the annotation to image index, descriptors, manifests:\n\nYou can also specify a platform qualifier in square brackets ( ) in the type prefix, to apply the annotation to a subset of manifests with the matching platform. The following example adds the annotation only to the manifest with the platform:\n\nWildcards are not supported in the platform qualifier; you can't specify a type prefix like to add annotations only to manifests which has as the OS platform.\n\nFor more information about annotations, see Annotations.\n• None Use to generate an SBOM for an image at build-time. Alternatively, you can use the shorthand. For more information, see here.\n• None Use to generate provenance for an image at build-time. Alternatively, you can use the shorthand. By default, a minimal provenance attestation will be created for the build result, which will only be attached for images pushed to registries. For more information, see here.\n• - Allows executions without sandbox. See related Dockerfile extensions.\n\nFor entitlements to be enabled, the BuildKit daemon also needs to allow them with (see ).\n\nYou can use instructions in a Dockerfile to define variable values. These values persist in the built image. Often persistence isn't what you want. Users want to specify variables differently depending on which host they build an image on.\n\nA good example is or source versions for pulling intermediate files. The instruction lets Dockerfile authors define values that users can set at build-time using the flag:\n\nThis flag allows you to pass the build-time variables that are accessed like regular environment variables in the instruction of the Dockerfile. These values don't persist in the intermediate or final images like values do. You must add for each build argument.\n\nUsing this flag doesn't alter the output you see when the build process echoes the lines from the Dockerfile.\n\nFor detailed information on using and instructions, see the Dockerfile reference.\n\nYou can also use the flag without a value, in which case the daemon propagates the value from the local environment into the Docker container it's building:\n\nThis example is similar to how works. Refer to the documentation for more information.\n\nThere are also useful built-in build arguments, such as:\n• : trigger git context to keep the directory\n• : inline cache metadata to image config or not\n• : opt into deterministic output regardless of multi-platform output or not\n\nLearn more about the built-in build arguments in the Dockerfile reference docs.\n\nDefine additional build context with specified contents. In Dockerfile the context can be accessed when or is used. When Dockerfile defines a stage with the same name it is overwritten.\n\nThe value can be a local source directory, local OCI layout compliant directory , container image (with docker-image:// prefix), Git or HTTP URL.\n\nUse an OCI layout directory as build context\n\nSource an image from a local OCI layout compliant directory , either by tag, or by digest:\n\nThe OCI layout directory must be compliant with the OCI layout specification . You can reference an image in the layout using either tags, or the exact digest.\n\nUse an external cache source for a build (--cache-from)\n\nUse an external cache source for a build. Supported types are , , and .\n• source can import cache from a cache manifest or (special) image configuration on the registry.\n• source can import cache from local files previously exported with .\n• source can import cache from a previously exported cache with in your GitHub repository\n• source can import cache from a previously exported cache with in your S3 bucket\n\nIf no type is specified, exporter is used with a specified reference.\n\ndriver currently only supports importing build cache from the registry.\n\nMore info about cache exporters and available attributes: https://github.com/moby/buildkit#export-cache\n\nBuildKit frontends can support alternative modes of executions for builds, using frontend methods. Frontend methods are a way to change or extend the behavior of a build invocation, which lets you, for example, inspect, validate, or generate alternative outputs from a build.\n\nThe flag for lets you specify the frontend method that you want to execute. If this flag is unspecified, it defaults to executing the build and evaluating build checks.\n\nFor Dockerfiles, the available methods are:\n\nNote that other frontends may implement these or other methods. To see the list of available methods for the frontend you're using, use .\n\nThe and methods include descriptions for build targets and arguments, if available. Descriptions are generated from comments in the Dockerfile. A comment on the line before a instruction becomes the description of a build target, and a comment before an instruction the description of a build argument. The comment must lead with the name of the stage or argument, for example:\n\nWhen you run , the output includes the descriptions, as follows:\n\nFor more examples on how to write Dockerfile docstrings, check out the Dockerfile for Docker docs .\n\nThe method evaluates build checks without executing the build. The flag is a convenient shorthand for . Use the method to validate the build configuration before starting the build.\n\nUsing without specifying a target evaluates the entire Dockerfile. If you want to evaluate a specific target, use the flag.\n\nThe method prints the name of the specified target (or the default target, if isn't specified), and the build arguments that the target consumes, along with their default values, if set.\n\nThe following example shows the default target and its build arguments:\n\nThis means that the target is configurable using these build arguments:\n\nThe method lists all the build targets in the Dockerfile. These are the stages that you can build using the flag. It also indicates the default target, which is the target that will be built when you don't specify a target.\n\nExport build cache to an external cache destination. Supported types are , , , and .\n• type exports build cache to a cache manifest in the registry.\n• type exports cache to a local directory on the client.\n• type writes the cache metadata into the image configuration.\n\nThe driver only supports cache exports using the and cache backends.\n• - Specifies how many layers are exported with the cache. on only exports layers already in the final build stage, exports layers for all stages. Metadata is always exported for the whole build.\n\nMore info about cache exporters and available attributes: https://github.com/moby/buildkit#export-cache\n\nWhen you run with the option, the daemon runs the containers used in the build with the corresponding flag.\n\nSpecifies the filepath of the Dockerfile to use. If unspecified, a file named at the root of the build context is used by default.\n\nTo read a Dockerfile from stdin, you can use as the argument for .\n\nShorthand for . Will automatically load the single-platform build result to .\n\nTo output build metadata such as the image digest, pass the flag. The metadata will be written as a JSON object to the specified file. The directory of the specified file must already exist and be writable.\n\nSet the networking mode for the RUN instructions during build (--network)\n\nAvailable options for the networking mode are:\n\nFind more details in the Dockerfile reference.\n\nThe lets you specify one or more stages of a multi-stage Dockerfile for which build cache should be ignored. To specify multiple stages, use a comma-separated syntax:\n\nFor example, the following Dockerfile contains four stages:\n\nTo ignore the cache for the stage:\n\nTo ignore the cache the and stages:\n\nThe arguments for the flag must be names of stages.\n\nSet the export action for the build result (-o, --output)\n\nSets the export action for the build result. The default output, when using the build driver, is a container image exported to the local image store. The flag makes this step configurable allows export of results directly to the client's filesystem, an OCI image tarball, a registry, and more.\n\nBuildx with driver only supports the local, tarball, and image exporters. The driver supports all exporters.\n\nIf you only specify a filepath as the argument to , Buildx uses the local exporter. If the value is , Buildx uses the exporter and writes the output to stdout.\n\nYou can export multiple outputs by repeating the flag.\n\nThe export type writes all result files to a directory on the client. The new files will be owned by the current user. On multi-platform builds, all results will be put in subdirectories by their platform.\n• - destination directory where files will be written\n\nFor more information, see Local and tar exporters.\n\nThe export type writes all result files as a single tarball on the client. On multi-platform builds all results will be put in subdirectories by their platform.\n• - destination path where tarball will be written. “-” writes to stdout.\n\nFor more information, see Local and tar exporters.\n\nThe export type writes the result image or manifest list as an OCI image layout tarball on the client.\n• - destination path where tarball will be written. “-” writes to stdout.\n\nFor more information, see OCI and Docker exporters.\n\nThe export type writes the single-platform result image as a Docker image specification tarball on the client. Tarballs created by this exporter are also OCI compatible.\n\nThe default image store in Docker Engine doesn't support loading multi-platform images. You can enable the containerd image store, or push multi-platform images is to directly push to a registry, see .\n• - destination path where tarball will be written. If not specified, the tar will be loaded automatically to the local image store.\n• - name for the Docker context where to import the result\n\nFor more information, see OCI and Docker exporters.\n\nThe exporter writes the build result as an image or a manifest list. When using driver the image will appear in . Optionally, image can be automatically pushed to a registry by specifying attributes.\n• - name (references) for the new image.\n\nFor more information, see Image and registry exporters.\n\nThe exporter is a shortcut for .\n\nFor more information, see Image and registry exporters.\n\nSet the target platforms for the build (--platform)\n\nSet the target platform for the build. All commands inside the Dockerfile without their own flag will pull base images for this platform and this value will also be the platform of the resulting image.\n\nThe default value is the platform of the BuildKit daemon where the build runs. The value takes the form of or . For example, or . Additionally, the flag also supports a special value, which tells BuildKit to use the platform of the BuildKit client that invokes the build.\n\nWhen using driver with , this flag can accept multiple values as an input separated by a comma. With multiple values the result will be built for all of the specified platforms and joined together into a single manifest list.\n\nIf the needs to invoke the command, the builder needs runtime support for the specified platform. In a clean setup, you can only execute commands for your system architecture. If your kernel supports launchers for secondary architectures, buildx will pick them up automatically. Docker Desktop releases come with automatically configured for and architectures. You can see what runtime platforms your current builder instance supports by running .\n\nInside a , you can access the current platform value through build argument. Refer to the Dockerfile reference for the full description of automatic platform argument variants .\n\nYou can find the formatting definition for the platform specifier in the containerd source code .\n\nThe following example uses output during the build:\n\nThe output marshals the solve status events from BuildKit to JSON lines. This mode is designed to be read by an external program.\n\nShorthand for , used to configure provenance attestations for the build result. For example, can be used as an abbreviation for .\n\nAdditionally, can be used with Boolean values to enable or disable provenance attestations. For example, disables all provenance attestations, while enables all provenance attestations.\n\nBy default, a minimal provenance attestation will be created for the build result. Note that the default image store in Docker Engine doesn't support attestations. Provenance attestations only persist for images pushed directly to a registry if you use the default image store. Alternatively, you can switch to using the containerd image store.\n\nFor more information about provenance attestations, see here.\n\nShorthand for . Will automatically push the build result to registry.\n\nShorthand for , used to configure SBOM attestations for the build result. For example, can be used as an abbreviation for .\n\nAdditionally, can be used with Boolean values to enable or disable SBOM attestations. For example, disables all SBOM attestations.\n\nNote that the default image store in Docker Engine doesn't support attestations. Provenance attestations only persist for images pushed directly to a registry if you use the default image store. Alternatively, you can switch to using the containerd image store.\n\nFor more information, see here.\n\nSecret to expose to the build (--secret)\n\nExposes secrets (authentication credentials, tokens) to the build. A secret can be mounted into the build using a mount in the Dockerfile. For more information about how to use build secrets, see Build secrets.\n\nBuildx attempts to detect the automatically if unset. If an environment variable with the same key as is set, then Buildx uses and the variable value becomes the secret. If no such environment variable is set, and is not set, then Buildx falls back to .\n\nIn the following example, is automatically detected because no environment variable mathing (the ID) is set.\n\nIn the following example, is automatically detected because an environment variable matching is set.\n\nIn the following example, the build argument is set to contain the value of the environment variable .\n\nYou can also specify the name of the environment variable with or :\n\nSets the size of the shared memory allocated for build containers when using instructions.\n\nThe format is . must be greater than . Unit is optional and can be (bytes), (kilobytes), (megabytes), or (gigabytes). If you omit the unit, the system uses bytes.\n\nSSH agent socket or keys to expose to the build (--ssh)\n\nThis can be useful when some commands in your Dockerfile need specific SSH authentication (e.g., cloning a private repository).\n\nexposes SSH agent socket or keys to the build and can be used with the mount.\n\nExample to access Gitlab using an SSH agent socket:\n\nThis examples builds in the same way as the previous example, but it then tags the resulting image. The repository name will be and the tag .\n\nYou can apply multiple tags to an image. For example, you can apply the tag to a newly built image and add another tag that references a specific version.\n\nFor example, to tag an image both as and , use the following:\n\nWhen building a Dockerfile with multiple build stages, use the option to specify an intermediate build stage by name as a final stage for the resulting image. The builder skips commands after the target stage.\n\noverrides the default ulimits of build's containers when using instructions and are specified with a soft and hard limit as such: , for example:"
    },
    {
        "link": "https://docs.docker.com/reference/cli/docker",
        "document": "Depending on your Docker system configuration, you may be required to preface each command with . To avoid having to use with the command, your system administrator can create a Unix group called and add users to it.\n\nFor more information about installing Docker or configuration, refer to the installation instructions for your operating system.\n\nTo list the help on any command just execute the command, followed by the option.\n\nThe following list of environment variables are supported by the command line:\n\nBecause Docker is developed using Go, you can also use any environment variables used by the Go runtime. In particular, you may find these useful:\n\nSee the Go specification for details on these variables.\n\nSingle character command line options can be combined, so rather than typing , you can write .\n\nBoolean options take the form . The value you see in the help text is the default value which is set if you do not specify that flag. If you specify a Boolean flag without a value, this will set the flag to , irrespective of the default value.\n\nFor example, running will set the value to , so your container will run in \"detached\" mode, in the background.\n\nOptions which default to (e.g., ) can only be set to the non-default value by explicitly setting them to :\n\nYou can specify options like multiple times in a single command line, for example in these commands:\n\nSometimes, multiple options can call for a more complex value string as for :\n\nOptions like expect a string, and they can only be specified once. Options like expect an integer, and they can only be specified once.\n\nBy default, the Docker command line stores its configuration files in a directory called within your directory.\n\nDocker manages most of the files in the configuration directory and you shouldn't modify them. However, you can modify the file to control certain aspects of how the command behaves.\n\nYou can modify the command behavior using environment variables or command-line options. You can also use options within to modify some of the same behavior. If an environment variable and the flag are set, the flag takes precedent over the environment variable. Command line options override environment variables and environment variables override properties you specify in a file.\n\nTo specify a different directory, use the environment variable or the command line option. If both are specified, then the option overrides the environment variable. The example below overrides the command using a file located in the directory.\n\nThis flag only applies to whatever command is being ran. For persistent configuration, you can set the environment variable in your shell (e.g. or ). The example below sets the new directory to be .\n\nUse the Docker CLI configuration to customize settings for the CLI. The configuration file uses JSON formatting, and properties:\n\nBy default, configuration file is stored in . Refer to the change the directory section to use a different location.\n\nThese fields lets you customize the default output format for some commands if no flag is provided.\n\nThe property specifies a set of headers to include in all messages sent from the Docker client to the daemon. Docker doesn't try to interpret or understand these headers; it simply puts them into the messages. Docker does not allow these headers to change any headers it sets for itself.\n\nAlternatively, use the environment variable, which is available in v27.1 and higher. This environment-variable is experimental, and its exact behavior may change.\n\nThe property specifies an external binary to serve as the default credential store. When this property is set, will attempt to store credentials in the binary specified by which is visible on . If this property isn't set, credentials are stored in the property of the CLI configuration file. For more information, see the Credential stores section in the documentation\n\nThe property specifies a set of credential helpers to use preferentially over or when storing and retrieving credentials for specific registries. If this property is set, the binary will be used when storing or retrieving credentials for a specific registry. For more information, see the Credential helpers section in the documentation\n\nThe property specifies proxy environment variables to be automatically set on containers, and set as on containers used during . A set of proxies can be configured, and will be used for any Docker daemon that the client connects to, or a configuration per host (Docker daemon), for example, . The following properties can be set for each environment:\n\nThese settings are used to configure proxy settings for containers only, and not used as proxy settings for the CLI or the daemon. Refer to the environment variables and HTTP/HTTPS proxy sections for configuring proxy settings for the CLI and daemon.\n\nOnce attached to a container, users detach from it and leave it running using the using key sequence. This detach key sequence is customizable using the property. Specify a value for the property. The format of the is a comma-separated list of either a letter [a-Z], or the combined with any of the following:\n\nYour customization applies to all containers started in with your Docker client. Users can override your custom or the default key sequence on a per-container basis. To do this, the user specifies the flag with the , , or command.\n\nThe property contains settings specific to CLI plugins. The key is the plugin name, while the value is a further map of options, which are specific to that plugin.\n\nFollowing is a sample file to illustrate the format used for various fields:\n\nExperimental features provide early access to future product functionality. These features are intended for testing and feedback, and they may change between releases without warning or can be removed from a future release.\n\nStarting with Docker 20.10, experimental CLI features are enabled by default, and require no configuration to enable them.\n\nIf using your own notary server and a self-signed certificate or an internal Certificate Authority, you need to place the certificate at in your Docker config directory.\n\nAlternatively you can trust the certificate globally by adding it to your system's list of root Certificate Authorities.\n\nYou can use the , flag to specify a socket to use when you invoke a command. You can use the following protocols:\n\nIf you don't specify the flag, and you're not using a custom context, commands use the following default sockets:\n\nTo achieve a similar effect without having to specify the flag for every command, you could also create a context, or alternatively, use the environment variable.\n\nFor more information about the flag, see Daemon socket option.\n\nThe following example shows how to invoke over TCP, to a remote daemon with IP address , listening on port :\n\nWhen you use SSH invoke a command on a remote daemon, the request gets forwarded to the Unix socket on the SSH host.\n\nYou can optionally specify the location of the socket by appending a path component to the end of the SSH address."
    },
    {
        "link": "https://docs.docker.com/get-started/workshop/02_our_app",
        "document": "For the rest of this guide, you'll be working with a simple todo list manager that runs on Node.js. If you're not familiar with Node.js, don't worry. This guide doesn't require any prior experience with JavaScript.\n• You have installed the latest version of Docker Desktop.\n• You have an IDE or a text editor to edit files. Docker recommends using Visual Studio Code .\n\nBefore you can run the application, you need to get the application source code onto your machine.\n• None Clone the getting-started-app repository using the following command:\n• None View the contents of the cloned repository. You should see the following files and sub-directories.\n\nTo build the image, you'll need to use a Dockerfile. A Dockerfile is simply a text-based file with no file extension that contains a script of instructions. Docker uses this script to build a container image.\n• None In the directory, the same location as the file, create a file named with the following contents: This Dockerfile starts off with a base image, a light-weight Linux image that comes with Node.js and the Yarn package manager pre-installed. It copies all of the source code into the image, installs the necessary dependencies, and starts the application.\n• None Build the image using the following commands: In the terminal, make sure you're in the directory. Replace with the path to your directory. The command uses the Dockerfile to build a new image. You might have noticed that Docker downloaded a lot of \"layers\". This is because you instructed the builder that you wanted to start from the image. But, since you didn't have that on your machine, Docker needed to download the image. After Docker downloaded the image, the instructions from the Dockerfile copied in your application and used to install your application's dependencies. The directive specifies the default command to run when starting a container from this image. Finally, the flag tags your image. Think of this as a human-readable name for the final image. Since you named the image , you can refer to that image when you run a container. The at the end of the command tells Docker that it should look for the in the current directory.\n\nNow that you have an image, you can run the application in a container using the command.\n• None Run your container using the command and specify the name of the image you just created: The flag (short for ) runs the container in the background. This means that Docker starts your container and returns you to the terminal prompt. Also, it does not display logs in the terminal. The flag (short for ) creates a port mapping between the host and the container. The flag takes a string value in the format of , where is the address on the host, and is the port on the container. The command publishes the container's port 3000 to ( ) on the host. Without the port mapping, you wouldn't be able to access the application from the host.\n• None After a few seconds, open your web browser to http://localhost:3000 . You should see your app.\n• None Add an item or two and see that it works as you expect. You can mark items as complete and remove them. Your frontend is successfully storing items in the backend.\n\nAt this point, you have a running todo list manager with a few items.\n\nIf you take a quick look at your containers, you should see at least one container running that's using the image and on port . To see your containers, you can use the CLI or Docker Desktop's graphical interface.\n\nIn this section, you learned the basics about creating a Dockerfile to build an image. Once you built an image, you started a container and saw the running app.\n\nNext, you're going to make a modification to your app and learn how to update your running application with a new image. Along the way, you'll learn a few other useful commands."
    },
    {
        "link": "https://docs.docker.com/build",
        "document": "Docker Build is one of Docker Engine's most used features. Whenever you are creating an image you are using Docker Build. Build is a key part of your software development life cycle allowing you to package and bundle your code and ship it anywhere.\n\nDocker Build is more than a command for building images, and it's not only about packaging your code. It's a whole ecosystem of tools and features that support not only common workflow tasks but also provides support for more complex and advanced scenarios."
    }
]