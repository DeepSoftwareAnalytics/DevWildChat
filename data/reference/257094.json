[
    {
        "link": "https://gorm.io/docs/error_handling.html",
        "document": "Effective error handling is a cornerstone of robust application development in Go, particularly when interacting with databases using GORM. GORM’s approach to error handling, influenced by its chainable API, requires a nuanced understanding.\n\nGORM integrates error handling into its chainable method syntax. The instance contains an field, which is set when an error occurs. The common practice is to check this field after executing database operations, especially after Finisher Methods.\n\nAfter a chain of methods, it’s crucial to check the field:\n\nGORM returns when no record is found using methods like , , .\n\nMany databases return errors with specific codes, which can be indicative of various issues like constraint violations, connection problems, or syntax errors. Handling these error codes in GORM requires parsing the error returned by the database and extracting the relevant code\n\nGORM can return specific errors related to the database dialect being used, when is enabled, GORM converts database-specific errors into its own generalized errors.\n\nThis error occurs when an insert operation violates a unique constraint:\n\nThis error is encountered when a foreign key constraint is violated:\n\nBy enabling , GORM provides a more unified way of handling errors across different databases, translating database-specific errors into common GORM error types.\n\nFor a complete list of errors that GORM can return, refer to the Errors List in GORM’s documentation."
    },
    {
        "link": "https://gorm.io/docs/transactions.html",
        "document": "GORM perform write (create/update/delete) operations run inside a transaction to ensure data consistency, you can disable it during initialization if it is not required, you will gain about 30%+ performance improvement after that\n\nTo perform a set of operations within a transaction, the general flow is as below.\n\nGORM supports nested transactions, you can rollback a subset of operations performed within the scope of a larger transaction, for example:\n\nGORM provides , to save points and roll back to a savepoint, for example:"
    },
    {
        "link": "https://gorm.io/es_ES/docs/error_handling.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/65405255/how-to-deal-with-gorm-commit-rollback-error",
        "document": "In exactly the same situations where you might get an error from some other database call:\n\nFor , your error options are somewhat limited, since there's no data (yet) that could be inconsistent. But for and any of those errors are possible, as well as the case where there's no active transaction to be committed (because of a previous error, because it was already committed, or because it was already rolled back).\n\nNo. There's no possible way GORM could, since it doesn't know your application logic. As with all failures, of all types, it is up to the programmer to determine what is the appropriate action. Maybe you should retry. Maybe you should only retry N times. Maybe you should ignore the failure and continue as if it succeeded. Maybe you should return an error to the user. Maybe you should panic and crash the entire program. GORM obviously has no way of knowing the proper response.\n\nAs eluded to in my last paragraph, only you can know this. What is your application attempting to do? Waht is the right thing to do in case of a failure?\n\nThis has nothing to do with GORM. \"Best practice\" in handling errors is simply to reason about what an error indicates, and what your application ought to do in that case."
    },
    {
        "link": "https://tillitsdone.com/blogs/gorm-error-handling-guide",
        "document": "When working with GORM in Go applications, proper error handling is crucial for maintaining robust and reliable database operations. In this guide, we’ll explore common GORM errors and learn effective strategies to debug and resolve them.\n\nGORM provides several ways to handle errors, and understanding these patterns is essential for writing maintainable code. The most basic form is checking the error returned by GORM operations:\n\nHowever, real-world applications require more sophisticated error handling approaches. Let’s dive into common scenarios and their solutions.\n\nOne of the most frequent issues developers encounter is handling missing records. GORM provides a specific error type for this:\n\nForeign key violations can be tricky to debug. Here’s how to handle them effectively:\n• Always check for errors after database operations\n• Use custom error types for better error handling\n\nHere’s an example of implementing these practices:\n\nRemember that effective error handling is not just about catching errors – it’s about providing meaningful feedback and maintaining data integrity."
    },
    {
        "link": "https://pkg.go.dev/context",
        "document": "Package context defines the Context type, which carries deadlines, cancellation signals, and other request-scoped values across API boundaries and between processes. Incoming requests to a server should create a Context, and outgoing calls to servers should accept a Context. The chain of function calls between them must propagate the Context, optionally replacing it with a derived Context created using WithCancel, WithDeadline, WithTimeout, or WithValue. A Context may be canceled to indicate that work done on its behalf should stop. A Context with a deadline is canceled after the deadline passes. When a Context is canceled, all Contexts derived from it are also canceled. The WithCancel, WithDeadline, and WithTimeout functions take a Context (the parent) and return a derived Context (the child) and a CancelFunc. Calling the CancelFunc directly cancels the child and its children, removes the parent's reference to the child, and stops any associated timers. Failing to call the CancelFunc leaks the child and its children until the parent is canceled. The go vet tool checks that CancelFuncs are used on all control-flow paths. The WithCancelCause, WithDeadlineCause, and WithTimeoutCause functions return a CancelCauseFunc, which takes an error and records it as the cancellation cause. Calling Cause on the canceled context or any of its children retrieves the cause. If no cause is specified, Cause(ctx) returns the same value as ctx.Err(). Programs that use Contexts should follow these rules to keep interfaces consistent across packages and enable static analysis tools to check context propagation: Do not store Contexts inside a struct type; instead, pass a Context explicitly to each function that needs it. This is discussed further in https://go.dev/blog/context-and-structs. The Context should be the first parameter, typically named ctx: Do not pass a nil Context, even if a function permits it. Pass context.TODO if you are unsure about which Context to use. Use context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions. The same Context may be passed to functions running in different goroutines; Contexts are safe for simultaneous use by multiple goroutines. See https://go.dev/blog/context for example code for a server that uses Contexts.\n\nAfterFunc arranges to call f in its own goroutine after ctx is canceled. If ctx is already canceled, AfterFunc calls f immediately in its own goroutine. Multiple calls to AfterFunc on a context operate independently; one does not replace another. Calling the returned stop function stops the association of ctx with f. It returns true if the call stopped f from being run. If stop returns false, either the context is canceled and f has been started in its own goroutine; or f was already stopped. The stop function does not wait for f to complete before returning. If the caller needs to know whether f is completed, it must coordinate with f explicitly. If ctx has a \"AfterFunc(func()) func() bool\" method, AfterFunc will use it to schedule the call. This example uses AfterFunc to define a function which waits on a sync.Cond, stopping the wait when a context is canceled. package main import ( \"context\" \"fmt\" \"sync\" \"time\" ) func main() { waitOnCond := func(ctx context.Context, cond *sync.Cond, conditionMet func() bool) error { stopf := context.AfterFunc(ctx, func() { // We need to acquire cond.L here to be sure that the Broadcast // below won't occur before the call to Wait, which would result // in a missed signal (and deadlock). cond.L.Lock() defer cond.L.Unlock() // If multiple goroutines are waiting on cond simultaneously, // we need to make sure we wake up exactly this one. // That means that we need to Broadcast to all of the goroutines, // which will wake them all up. // // If there are N concurrent calls to waitOnCond, each of the goroutines // will spuriously wake up O(N) other goroutines that aren't ready yet, // so this will cause the overall CPU cost to be O(N²). cond.Broadcast() }) defer stopf() // Since the wakeups are using Broadcast instead of Signal, this call to // Wait may unblock due to some other goroutine's context being canceled, // so to be sure that ctx is actually canceled we need to check it in a loop. for !conditionMet() { cond.Wait() if ctx.Err() != nil { return ctx.Err() } } return nil } cond := sync.NewCond(new(sync.Mutex)) var wg sync.WaitGroup for i := 0; i < 4; i++ { wg.Add(1) go func() { defer wg.Done() ctx, cancel := context.WithTimeout(context.Background(), 1*time.Millisecond) defer cancel() cond.L.Lock() defer cond.L.Unlock() err := waitOnCond(ctx, cond, func() bool { return false }) fmt.Println(err) }() } wg.Wait() } This example uses AfterFunc to define a function which reads from a net.Conn, stopping the read when a context is canceled. package main import ( \"context\" \"fmt\" \"net\" \"time\" ) func main() { readFromConn := func(ctx context.Context, conn net.Conn, b []byte) (n int, err error) { stopc := make(chan struct{}) stop := context.AfterFunc(ctx, func() { conn.SetReadDeadline(time.Now()) close(stopc) }) n, err = conn.Read(b) if !stop() { // The AfterFunc was started. // Wait for it to complete, and reset the Conn's deadline. <-stopc conn.SetReadDeadline(time.Time{}) return n, ctx.Err() } return n, err } listener, err := net.Listen(\"tcp\", \"localhost:0\") if err != nil { fmt.Println(err) return } defer listener.Close() conn, err := net.Dial(listener.Addr().Network(), listener.Addr().String()) if err != nil { fmt.Println(err) return } defer conn.Close() ctx, cancel := context.WithTimeout(context.Background(), 1*time.Millisecond) defer cancel() b := make([]byte, 1024) _, err = readFromConn(ctx, conn, b) fmt.Println(err) } This example uses AfterFunc to define a function which combines the cancellation signals of two Contexts. package main import ( \"context\" \"errors\" \"fmt\" ) func main() { // mergeCancel returns a context that contains the values of ctx, // and which is canceled when either ctx or cancelCtx is canceled. mergeCancel := func(ctx, cancelCtx context.Context) (context.Context, context.CancelFunc) { ctx, cancel := context.WithCancelCause(ctx) stop := context.AfterFunc(cancelCtx, func() { cancel(context.Cause(cancelCtx)) }) return ctx, func() { stop() cancel(context.Canceled) } } ctx1, cancel1 := context.WithCancelCause(context.Background()) defer cancel1(errors.New(\"ctx1 canceled\")) ctx2, cancel2 := context.WithCancelCause(context.Background()) mergedCtx, mergedCancel := mergeCancel(ctx1, ctx2) defer mergedCancel() cancel2(errors.New(\"ctx2 canceled\")) <-mergedCtx.Done() fmt.Println(context.Cause(mergedCtx)) } Cause returns a non-nil error explaining why c was canceled. The first cancellation of c or one of its parents sets the cause. If that cancellation happened via a call to CancelCauseFunc(err), then Cause returns err. Otherwise Cause(c) returns the same value as c.Err(). Cause returns nil if c has not been canceled yet. WithCancel returns a derived context that points to the parent context but has a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first. Canceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this Context complete. This example demonstrates the use of a cancelable context to prevent a goroutine leak. By the end of the example function, the goroutine started by gen will return without leaking. package main import ( \"context\" \"fmt\" ) func main() { // gen generates integers in a separate goroutine and // sends them to the returned channel. // The callers of gen need to cancel the context once // they are done consuming generated integers not to leak // the internal goroutine started by gen. gen := func(ctx context.Context) <-chan int { dst := make(chan int) n := 1 go func() { for { select { case <-ctx.Done(): return // returning not to leak the goroutine case dst <- n: n++ } } }() return dst } ctx, cancel := context.WithCancel(context.Background()) defer cancel() // cancel when we are finished consuming integers for n := range gen(ctx) { fmt.Println(n) if n == 5 { break } } } WithCancelCause behaves like WithCancel but returns a CancelCauseFunc instead of a CancelFunc. Calling cancel with a non-nil error (the \"cause\") records that error in ctx; it can then be retrieved using Cause(ctx). Calling cancel with nil sets the cause to Canceled. WithDeadline returns a derived context that points to the parent context but has the deadline adjusted to be no later than d. If the parent's deadline is already earlier than d, WithDeadline(parent, d) is semantically equivalent to parent. The returned [Context.Done] channel is closed when the deadline expires, when the returned cancel function is called, or when the parent context's Done channel is closed, whichever happens first. Canceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this Context complete. This example passes a context with an arbitrary deadline to tell a blocking function that it should abandon its work as soon as it gets to it. d := time.Now().Add(shortDuration) ctx, cancel := context.WithDeadline(context.Background(), d) // Even though ctx will be expired, it is good practice to call its // cancellation function in any case. Failure to do so may keep the // context and its parent alive longer than necessary. defer cancel() select { case <-neverReady: fmt.Println(\"ready\") case <-ctx.Done(): fmt.Println(ctx.Err()) } WithDeadlineCause behaves like WithDeadline but also sets the cause of the returned Context when the deadline is exceeded. The returned CancelFunc does not set the cause. Canceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this Context complete: This example passes a context with a timeout to tell a blocking function that it should abandon its work after the timeout elapses. // Pass a context with a timeout to tell a blocking function that it // should abandon its work after the timeout elapses. ctx, cancel := context.WithTimeout(context.Background(), shortDuration) defer cancel() select { case <-neverReady: fmt.Println(\"ready\") case <-ctx.Done(): fmt.Println(ctx.Err()) // prints \"context deadline exceeded\" } WithTimeoutCause behaves like WithTimeout but also sets the cause of the returned Context when the timeout expires. The returned CancelFunc does not set the cause.\n\nA CancelCauseFunc behaves like a CancelFunc but additionally sets the cancellation cause. This cause can be retrieved by calling Cause on the canceled Context or on any of its derived Contexts. If the context has already been canceled, CancelCauseFunc does not set the cause. For example, if childContext is derived from parentContext:\n• if parentContext is canceled with cause1 before childContext is canceled with cause2, then Cause(parentContext) == Cause(childContext) == cause1\n• if childContext is canceled with cause2 before parentContext is canceled with cause1, then Cause(parentContext) == cause1 and Cause(childContext) == cause2 A CancelFunc tells an operation to abandon its work. A CancelFunc does not wait for the work to stop. A CancelFunc may be called by multiple goroutines simultaneously. After the first call, subsequent calls to a CancelFunc do nothing. type Context interface { Deadline() (deadline time.Time, ok bool) Done() <-chan struct{} Err() error Value(key any) any } A Context carries a deadline, a cancellation signal, and other values across API boundaries. Context's methods may be called by multiple goroutines simultaneously. Background returns a non-nil, empty Context. It is never canceled, has no values, and has no deadline. It is typically used by the main function, initialization, and tests, and as the top-level Context for incoming requests. TODO returns a non-nil, empty Context. Code should use context.TODO when it's unclear which Context to use or it is not yet available (because the surrounding function has not yet been extended to accept a Context parameter). WithValue returns a derived context that points to the parent Context. In the derived context, the value associated with key is val. Use context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions. The provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface. This example demonstrates how a value can be passed to the context and also how to retrieve it if it exists. package main import ( \"context\" \"fmt\" ) func main() { type favContextKey string f := func(ctx context.Context, k favContextKey) { if v := ctx.Value(k); v != nil { fmt.Println(\"found value:\", v) return } fmt.Println(\"key not found:\", k) } k := favContextKey(\"language\") ctx := context.WithValue(context.Background(), k, \"Go\") f(ctx, k) f(ctx, favContextKey(\"color\")) } found value: Go key not found: color WithoutCancel returns a derived context that points to the parent context and is not canceled when parent is canceled. The returned context returns no Deadline or Err, and its Done channel is nil. Calling Cause on the returned context returns nil."
    },
    {
        "link": "https://tip.golang.org/doc/go1.20",
        "document": "The latest Go release, version 1.20, arrives six months after Go 1.19. Most of its changes are in the implementation of the toolchain, runtime, and libraries. As always, the release maintains the Go 1 promise of compatibility. We expect almost all Go programs to continue to compile and run as before.\n\nChanges to the language\n\nGo 1.20 includes four changes to the language.\n\nGo 1.17 added conversions from slice to an array pointer. Go 1.20 extends this to allow conversions from a slice to an array: given a slice , can now be written instead of .\n\nThe package defines three new functions , , and . Along with Go 1.17’s , these functions now provide the complete ability to construct and deconstruct slice and string values, without depending on their exact representation.\n\nThe specification now defines that struct values are compared one field at a time, considering fields in the order they appear in the struct type definition, and stopping at the first mismatch. The specification could previously have been read as if all fields needed to be compared beyond the first mismatch. Similarly, the specification now defines that array values are compared one element at a time, in increasing index order. In both cases, the difference affects whether certain comparisons must panic. Existing programs are unchanged: the new spec wording describes what the implementations have always done.\n\nComparable types (such as ordinary interfaces) may now satisfy constraints, even if the type arguments are not strictly comparable (comparison may panic at runtime). This makes it possible to instantiate a type parameter constrained by (e.g., a type parameter for a user-defined generic map key) with a non-strictly comparable type argument such as an interface type, or a composite type containing an interface type.\n\nGo 1.20 is the last release that will run on any release of Windows 7, 8, Server 2008 and Server 2012. Go 1.21 will require at least Windows 10 or Server 2016.\n\nGo 1.20 is the last release that will run on macOS 10.13 High Sierra or 10.14 Mojave. Go 1.21 will require macOS 10.15 Catalina or later.\n\nGo 1.20 adds experimental support for FreeBSD on RISC-V ( , ).\n\nThe directory no longer stores pre-compiled package archives for the standard library: no longer writes them, the build no longer checks for them, and the Go distribution no longer ships them. Instead, packages in the standard library are built as needed and cached in the build cache, just like packages outside . This change reduces the size of the Go distribution and also avoids C toolchain skew for packages that use cgo.\n\nThe implementation of has been improved to make it more robust. Programs that run do not need any updates. Programs that invoke directly should now run the test binary with (for example, or ) instead of plain .\n\nA related change to is the addition of an event with set to at the beginning of each test program’s execution. When running multiple tests using the command, these start events are guaranteed to be emitted in the same order as the packages named on the command line.\n\nThe command now defines architecture feature build tags, such as , to allow selecting a package implementation file based on the presence or absence of a particular architecture feature. See for details.\n\nThe subcommands now accept to change directory to <dir> before performing the command, which may be useful for scripts that need to execute commands in multiple different modules.\n\nThe and commands no longer accept the flag, which has been deprecated since Go 1.16.\n\nThe command now accepts to skip directives matching .\n\nThe command now accepts to skip tests, subtests, or examples matching .\n\nWhen the main module is located within , no longer installs libraries for non- packages to , and no longer reports a field for such packages. (In module mode, compiled packages are stored in the build cache only, but a bug had caused the install targets to unexpectedly remain in effect.)\n\nThe , , and other build-related commands now support a flag that enables profile-guided optimization, which is described in more detail in the Compiler section below. The flag specifies the file path of the profile. Specifying causes the command to search for a file named in the main package’s directory and use it if present. This mode currently requires a single main package to be specified on the command line, but we plan to lift this restriction in a future release. Specifying turns off profile-guided optimization.\n\nThe , , and other build-related commands now support a flag that builds the specified target with code coverage instrumentation. This is described in more detail in the Cover section below.\n\nThe command now supports reading more types of Go binaries, most notably, Windows DLLs built with and Linux binaries without execute permission.\n\nThe command now disables by default on systems without a C toolchain. More specifically, when the environment variable is unset, the environment variable is unset, and the default C compiler (typically or ) is not found in the path, defaults to . As always, you can override the default by setting explicitly.\n\nThe most important effect of the default change is that when Go is installed on a system without a C compiler, it will now use pure Go builds for packages in the standard library that use cgo, instead of using pre-distributed package archives (which have been removed, as noted above) or attempting to use cgo and failing. This makes Go work better in some minimal container environments as well as on macOS, where pre-distributed package archives have not been used for cgo-based packages since Go 1.16.\n\nThe packages in the standard library that use cgo are , , and . On macOS, the and packages have been rewritten not to use cgo: the same code is now used for cgo and non-cgo builds as well as cross-compiled builds. On Windows, the and packages have never used cgo. On other systems, builds with cgo disabled will use a pure Go version of these packages.\n\nA consequence is that, on macOS, if Go code that uses the package is built with , linking the resulting archive into a C program requires passing when linking the C code.\n\nOn macOS, the race detector has been rewritten not to use cgo: race-detector-enabled programs can be built and run without Xcode. On Linux and other Unix systems, and on Windows, a host C toolchain is required to use the race detector.\n\nGo 1.20 supports collecting code coverage profiles for programs (applications and integration tests), as opposed to just unit tests.\n\nTo collect coverage data for a program, build it with ’s flag, then run the resulting binary with the environment variable set to an output directory for coverage profiles. See the ‘coverage for integration tests’ landing page for more on how to get started. For details on the design and implementation, see the proposal.\n\nThe tool now reports references to loop variables following a call to within subtest function bodies. Such references may observe the value of the variable from a different iteration (typically causing test cases to be skipped) or an invalid state due to unsynchronized concurrent access.\n\nThe tool also detects reference mistakes in more places. Previously it would only consider the last statement of the loop body, but now it recursively inspects the last statements within if, switch, and select statements.\n\nThe vet tool now reports use of the time format 2006-02-01 (yyyy-dd-mm) with and . This format does not appear in common date standards, but is frequently used by mistake when attempting to use the ISO 8601 date format (yyyy-mm-dd).\n\nSome of the garbage collector’s internal data structures were reorganized to be both more space and CPU efficient. This change reduces memory overheads and improves overall CPU performance by up to 2%.\n\nThe garbage collector behaves less erratically with respect to goroutine assists in some circumstances.\n\nGo 1.20 adds a new package containing APIs for writing coverage profile data at runtime from long-running and/or server programs that do not terminate via .\n\nGo 1.20 adds preview support for profile-guided optimization (PGO). PGO enables the toolchain to perform application- and workload-specific optimizations based on run-time profile information. Currently, the compiler supports pprof CPU profiles, which can be collected through usual means, such as the or packages. To enable PGO, pass the path of a pprof profile file via the flag to , as mentioned above. Go 1.20 uses PGO to more aggressively inline functions at hot call sites. Benchmarks for a representative set of Go programs show enabling profile-guided inlining optimization improves performance about 3–4%. See the PGO user guide for detailed documentation. We plan to add more profile-guided optimizations in future releases. Note that profile-guided optimization is a preview, so please use it with appropriate caution.\n\nThe Go 1.20 compiler upgraded its front-end to use a new way of handling the compiler’s internal data, which fixes several generic-types issues and enables type declarations within generic functions and methods.\n\nThe compiler now rejects anonymous interface cycles with a compiler error by default. These arise from tricky uses of embedded interfaces and have always had subtle correctness issues, yet we have no evidence that they’re actually used in practice. Assuming no reports from users adversely affected by this change, we plan to update the language specification for Go 1.22 to formally disallow them so tools authors can stop supporting them too.\n\nGo 1.18 and 1.19 saw regressions in build speed, largely due to the addition of support for generics and follow-on work. Go 1.20 improves build speeds by up to 10%, bringing it back in line with Go 1.17. Relative to Go 1.19, generated code performance is also generally slightly improved.\n\nOn Linux, the linker now selects the dynamic interpreter for or at link time.\n\nOn Windows, the Go linker now supports modern LLVM-based C toolchains.\n\nGo 1.20 uses and prefixes for compiler-generated symbols rather than and . This avoids confusion for user packages whose name starts with . The package understands this new naming convention for binaries built with Go 1.20 and newer.\n\nWhen building a Go release from source and is not set, previous versions of Go looked for a Go 1.4 or later bootstrap toolchain in the directory ( on Windows). Go 1.18 and Go 1.19 looked first for or before falling back to , in anticipation of requiring Go 1.17 for use when bootstrapping Go 1.20. Go 1.20 does require a Go 1.17 release for bootstrapping, but we realized that we should adopt the latest point release of the bootstrap toolchain, so it requires Go 1.17.13. Go 1.20 looks for or before falling back to (to support systems that hard-coded the path $HOME/go1.4 but have installed a newer Go toolchain there). In the future, we plan to move the bootstrap toolchain forward approximately once a year, and in particular we expect that Go 1.22 will require the final point release of Go 1.20 for bootstrap.\n\nGo 1.20 adds a new package to provide explicit support for Elliptic Curve Diffie-Hellman key exchanges over NIST curves and Curve25519.\n\nPrograms should use instead of the lower-level functionality in for ECDH, and third-party modules for more advanced use cases.\n\nGo 1.20 expands support for error wrapping to permit an error to wrap multiple other errors.\n\nAn error can wrap more than one error by providing an method that returns a .\n\nThe and functions have been updated to inspect multiply wrapped errors.\n\nThe function now supports multiple occurrences of the format verb, which will cause it to return an error that wraps all of those error operands.\n\nThe new function returns an error wrapping a list of errors.\n\nThe new type provides access to extended per-request functionality not handled by the interface.\n\nPreviously, we have added new per-request functionality by defining optional interfaces which a can implement, such as . These interfaces are not discoverable and clumsy to use.\n\nThe type provides a clearer, more discoverable way to add per-handler controls. Two such controls also added in Go 1.20 are and , which allow setting per-request read and write deadlines. For example:\n\nThe forwarding proxy includes a new hook function, superseding the previous hook.\n\nThe hook accepts a parameter, which includes both the inbound request received by the proxy and the outbound request that it will send. Unlike hooks, which only operate on the outbound request, this permits hooks to avoid certain scenarios where a malicious inbound request may cause headers added by the hook to be removed before forwarding. See issue #50580.\n\nThe method routes the outbound request to a provided destination and supersedes the function. Unlike , also sets the header of the outbound request.\n\nThe method sets the , , and headers of the outbound request. When using a , these headers are not added by default.\n\nAn example of a hook using these features is:\n\nno longer adds a header to forwarded requests when the incoming request does not have one.\n\nMinor changes to the library\n\nAs always, there are various minor changes and updates to the library, made with the Go 1 promise of compatibility in mind. There are also various performance improvements, not enumerated here.\n\nWhen the environment variable is set, method will now return the error for an entry with a file name that is an absolute path, refers to a location outside the current directory, contains invalid characters, or (on Windows) is a reserved name such as . A future version of Go may disable insecure paths by default.\n\nWhen the environment variable is set, will now return the error when opening an archive which contains any file name that is an absolute path, refers to a location outside the current directory, contains invalid characters, or (on Windows) is a reserved names such as . A future version of Go may disable insecure paths by default.\n\nReading from a directory file that contains file data will now return an error. The zip specification does not permit directory files to contain file data, so this change only affects reading from invalid archives.\n\nThe new and functions are like and but also report whether the string was trimmed.\n\nThe new function allocates a copy of a byte slice.\n\nThe new function provides a way to cancel a context with a given error. That error can be retrieved by calling the new function.\n\nWhen using supported curves, all operations are now implemented in constant time. This led to an increase in CPU time between 5% and 30%, mostly affecting P-384 and P-521.\n\nThe new method converts an to an .\n\nThe method and the function now support signing pre-hashed messages with Ed25519ph, indicated by an that returns . They also now support Ed25519ctx and Ed25519ph with context, indicated by setting the new field.\n\nThe new field allows configuring the MGF1 hash separately for OAEP decryption.\n\ncrypto/rsa now uses a new, safer, constant-time backend. This causes a CPU runtime increase for decryption operations between approximately 15% (RSA-2048 on amd64) and 45% (RSA-4096 on arm64), and more on 32-bit architectures. Encryption operations are approximately 20x slower than before (but still 5-10x faster than decryption). Performance is expected to improve in future releases. Programs must not modify or manually generate the fields of .\n\nThe new function XORs two byte slices together.\n\nParsed certificates are now shared across all clients actively using that certificate. The memory savings can be significant in programs that make many concurrent connections to a server or collection of servers sharing any part of their certificate chains.\n\nFor a handshake failure due to a certificate verification failure, the TLS client and server now return an error of the new type , which includes the presented certificates.\n\nand now support keys of type . and now support keys of type . Parsing NIST curve keys still returns values of type and . Use their new methods to convert to the types.\n\nThe new function allows a program to define a set of fallback root certificates in case an operating system verifier or standard platform root bundle is unavailable at runtime. It will most commonly be used with a new package, golang.org/x/crypto/x509roots/fallback, which will provide an up to date root bundle.\n\nAttempts to read from a section using or the reader returned by now return an error.\n\nAdditional constants are defined for use with LoongArch systems.\n\nAdditional constants are defined for use with PPC64 ELFv2 relocations.\n\nThe constant value for is corrected, from 61 to 62.\n\nDue to a change of Go’s symbol naming conventions, tools that process Go binaries should use Go 1.20’s package to transparently handle both old and new binaries.\n\nAdditional constants are defined for use with RISC-V systems.\n\nThe and functions will now return after reading a partial value, rather than .\n\nThe new method can be used to check for unclosed elements when finished encoding.\n\nThe decoder now rejects element and attribute names with more than one colon, such as , as well as namespaces that resolve to an empty string, such as .\n\nThe decoder now rejects elements that use different namespace prefixes in the opening and closing tag, even if those prefixes both denote the same namespace.\n\nThe new function returns an error wrapping a list of errors.\n\nThe function supports multiple occurrences of the format verb, returning an error that unwraps to the list of all arguments to .\n\nThe new function recovers the formatting directive corresponding to a , which can be useful in . implementations.\n\nThe new field records the position of the keyword in a range statement.\n\nThe new and fields record the position of the start and end of the entire source file.\n\nThe new method removes a file from a . Long-running programs can use this to release memory associated with files they no longer need.\n\nThe new function reports whether a type satisfies a constraint. This change aligns with the new language semantics that distinguish satisfying a constraint from implementing an interface.\n\nGo 1.20.3 and later disallow actions in ECMAScript 6 template literals. This behavior can be reverted by the setting.\n\nThe new wraps an underlying and provides , , and methods that adjust their effective file offset position by a fixed amount.\n\nThe new error terminates a immediately but successfully.\n\nThe math/big package’s wide scope and input-dependent timing make it ill-suited for implementing cryptography. The cryptography packages in the standard library no longer call non-trivial Int methods on attacker-controlled inputs. In the future, the determination of whether a bug in math/big is considered a security vulnerability will depend on its wider impact on the standard library.\n\nThe math/rand package now automatically seeds the global random number generator (used by top-level functions like and ) with a random value, and the top-level function has been deprecated. Programs that need a reproducible sequence of random numbers should prefer to allocate their own random source, using .\n\nPrograms that need the earlier consistent global seeding behavior can set in their environment.\n\nThe top-level function has been deprecated. In almost all cases, is more appropriate.\n\nThe function now allows duplicate parameter names, so long as the values of the names are the same.\n\nMethods of the type now wrap errors returned by the underlying .\n\nIn Go 1.19.8 and later, this package sets limits the size of the MIME data it processes to protect against malicious inputs. and limit the number of headers in a part to 10000 and limits the total number of headers in all to 10000. These limits may be adjusted with the setting. further limits the number of parts in a form to 1000. This limit may be adjusted with the setting.\n\nThe function now consistently returns the contents of a record when one exists. Previously on Unix systems and when using the pure Go resolver, would return an error if a record referred to a name that with no , , or record. This change modifies to match the previous behavior on Windows, allowing to succeed whenever a exists.\n\nnow includes the new flag , indicating an operationally active interface. An interface which is administratively configured but not active (for example, because the network cable is not connected) will have set but not .\n\nThe new field contains a callback function similar to the existing hook, that additionally accepts the dial context as a parameter. is ignored when is not nil.\n\nThe Go DNS resolver recognizes the resolver option. When is set in , the Go resolver will set the AD bit in DNS queries. The resolver does not make use of the AD bit in responses.\n\nDNS resolution will detect changes to and reload the file when it changes. Checks are made at most once every five seconds, matching the previous handling of and .\n\nThe new configuration setting allows disabling the default handler.\n\nThe new hook is called when a receives an HTTP response from a proxy for a request.\n\nThe HTTP server now accepts HEAD requests containing a body, rather than rejecting them as invalid.\n\nHTTP/2 stream errors returned by functions may be converted to a using .\n\nLeading and trailing spaces are trimmed from cookie names, rather than being rejected as invalid. For example, a cookie setting of “name =value” is now accepted as setting the cookie “name”.\n\nA with an empty Expires field is now considered valid. only checks Expires when it is set.\n\nThe new and functions are the equivalents of and .\n\nOn Windows, the name is no longer treated as a special case in and .\n\nOn Windows, now uses the file handle to retrieve attributes when the file is a directory. Previously it would use the path passed to , which may no longer be the file represented by the file handle if the file has been moved or replaced. This change modifies to open directories without the access, which match the behavior of regular files.\n\nOn Windows, now supports seeking to the beginning of a directory.\n\nThe new fields and specify the behavior of the when its associated is canceled or its process exits with I/O pipes still held open by a child process.\n\nThe new error terminates a immediately but successfully.\n\nThe new function reports whether a path is lexically local to a directory. For example, if is , then will refer to a file that is lexically within the subtree rooted at the current directory.\n\nThe new and methods can be used to compare two s for equality. reports whether is a valid operation for a given receiver.\n\nThe new method extends a slice to guarantee space for another elements.\n\nThe new method sets a value to be the zero value for its type.\n\nGo 1.18 introduced and methods. These are optimizations: is meant to be equivalent to . The implementations incorrectly omitted a check for use of unexported fields that was present in the unoptimized forms. Go 1.20 corrects these methods to include the unexported field check.\n\nGo 1.19.2 and Go 1.18.7 included a security fix to the regular expression parser, making it reject very large expressions that would consume too much memory. Because Go patch releases do not introduce new API, the parser returned in this case. Go 1.20 adds a more specific error, , which the parser now returns instead.\n\nGo 1.20 adds new marker type. Code generated by cgo will use to mark an incomplete C type.\n\nGo 1.20 adds new supported metrics, including the current setting ( ), the number of cgo calls executed ( ), total mutex block time ( ), and various measures of time spent in garbage collection.\n\nTime-based histogram metrics are now less precise, but take up much less memory.\n\nMutex profile samples are now pre-scaled, fixing an issue where old mutex profile samples would be scaled incorrectly if the sampling rate changed during execution.\n\nProfiles collected on Windows now include memory mapping information that fixes symbolization issues for position-independent binaries.\n\nThe garbage collector’s background sweeper now yields less frequently, resulting in many fewer extraneous events in execution traces.\n\nThe new and functions are like and but also report whether the string was trimmed.\n\nThe new methods , , and allow existing map entries to be updated atomically.\n\nOn FreeBSD, compatibility shims needed for FreeBSD 11 and earlier have been removed.\n\nOn Linux, additional constants are defined for use with the field.\n\nOn Linux, the new and fields provide a way to place a child process into a specific cgroup.\n\nThe new method reports the current elapsed time of the benchmark, which may be useful for calculating rates to report with .\n\nCalling from a function passed to was never well-defined, and will now panic.\n\nThe new time layout constants , , and provide names for three of the most common layout strings used in a survey of public Go source code.\n\nThe new method compares two times.\n\nnow ignores sub-nanosecond precision in its input, instead of reporting those digits as an error.\n\nThe method is now more strict about adherence to RFC 3339.\n\nThe new function appends the UTF-16 encoding of a given rune to a uint16 slice, analogous to ."
    },
    {
        "link": "https://golang.google.cn/pkg/context",
        "document": "Package context defines the Context type, which carries deadlines, cancellation signals, and other request-scoped values across API boundaries and between processes. Incoming requests to a server should create a Context, and outgoing calls to servers should accept a Context. The chain of function calls between them must propagate the Context, optionally replacing it with a derived Context created using WithCancel, WithDeadline, WithTimeout, or WithValue. A Context may be canceled to indicate that work done on its behalf should stop. A Context with a deadline is canceled after the deadline passes. When a Context is canceled, all Contexts derived from it are also canceled. The WithCancel, WithDeadline, and WithTimeout functions take a Context (the parent) and return a derived Context (the child) and a CancelFunc. Calling the CancelFunc directly cancels the child and its children, removes the parent's reference to the child, and stops any associated timers. Failing to call the CancelFunc leaks the child and its children until the parent is canceled. The go vet tool checks that CancelFuncs are used on all control-flow paths. The WithCancelCause, WithDeadlineCause, and WithTimeoutCause functions return a CancelCauseFunc, which takes an error and records it as the cancellation cause. Calling Cause on the canceled context or any of its children retrieves the cause. If no cause is specified, Cause(ctx) returns the same value as ctx.Err(). Programs that use Contexts should follow these rules to keep interfaces consistent across packages and enable static analysis tools to check context propagation: Do not store Contexts inside a struct type; instead, pass a Context explicitly to each function that needs it. This is discussed further in https://go.dev/blog/context-and-structs. The Context should be the first parameter, typically named ctx: Do not pass a nil Context, even if a function permits it. Pass context.TODO if you are unsure about which Context to use. Use context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions. The same Context may be passed to functions running in different goroutines; Contexts are safe for simultaneous use by multiple goroutines. See https://go.dev/blog/context for example code for a server that uses Contexts.\n\nCanceled is the error returned by [Context.Err] when the context is canceled for some reason other than its deadline passing.\n\nDeadlineExceeded is the error returned by [Context.Err] when the context is canceled due to its deadline passing.\n\nAfterFunc arranges to call f in its own goroutine after ctx is canceled. If ctx is already canceled, AfterFunc calls f immediately in its own goroutine.\n\nMultiple calls to AfterFunc on a context operate independently; one does not replace another.\n\nCalling the returned stop function stops the association of ctx with f. It returns true if the call stopped f from being run. If stop returns false, either the context is canceled and f has been started in its own goroutine; or f was already stopped. The stop function does not wait for f to complete before returning. If the caller needs to know whether f is completed, it must coordinate with f explicitly.\n\nIf ctx has a \"AfterFunc(func()) func() bool\" method, AfterFunc will use it to schedule the call.\n\nCause returns a non-nil error explaining why c was canceled. The first cancellation of c or one of its parents sets the cause. If that cancellation happened via a call to CancelCauseFunc(err), then Cause returns err. Otherwise Cause(c) returns the same value as c.Err(). Cause returns nil if c has not been canceled yet.\n\nWithCancel returns a derived context that points to the parent context but has a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this Context complete.\n\nWithCancelCause behaves like WithCancel but returns a CancelCauseFunc instead of a CancelFunc. Calling cancel with a non-nil error (the \"cause\") records that error in ctx; it can then be retrieved using Cause(ctx). Calling cancel with nil sets the cause to Canceled.\n\nWithDeadline returns a derived context that points to the parent context but has the deadline adjusted to be no later than d. If the parent's deadline is already earlier than d, WithDeadline(parent, d) is semantically equivalent to parent. The returned [Context.Done] channel is closed when the deadline expires, when the returned cancel function is called, or when the parent context's Done channel is closed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this Context complete.\n\nWithDeadlineCause behaves like WithDeadline but also sets the cause of the returned Context when the deadline is exceeded. The returned CancelFunc does not set the cause.\n\nCanceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this Context complete:\n\nWithTimeoutCause behaves like WithTimeout but also sets the cause of the returned Context when the timeout expires. The returned CancelFunc does not set the cause.\n\nA CancelCauseFunc behaves like a CancelFunc but additionally sets the cancellation cause. This cause can be retrieved by calling Cause on the canceled Context or on any of its derived Contexts.\n\nIf the context has already been canceled, CancelCauseFunc does not set the cause. For example, if childContext is derived from parentContext:\n• if parentContext is canceled with cause1 before childContext is canceled with cause2, then Cause(parentContext) == Cause(childContext) == cause1\n• if childContext is canceled with cause2 before parentContext is canceled with cause1, then Cause(parentContext) == cause1 and Cause(childContext) == cause2\n\nA CancelFunc tells an operation to abandon its work. A CancelFunc does not wait for the work to stop. A CancelFunc may be called by multiple goroutines simultaneously. After the first call, subsequent calls to a CancelFunc do nothing.\n\nA Context carries a deadline, a cancellation signal, and other values across API boundaries.\n\nContext's methods may be called by multiple goroutines simultaneously.\n\nBackground returns a non-nil, empty Context. It is never canceled, has no values, and has no deadline. It is typically used by the main function, initialization, and tests, and as the top-level Context for incoming requests.\n\nTODO returns a non-nil, empty Context. Code should use context.TODO when it's unclear which Context to use or it is not yet available (because the surrounding function has not yet been extended to accept a Context parameter).\n\nWithValue returns a derived context that points to the parent Context. In the derived context, the value associated with key is val.\n\nUse context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface.\n\nWithoutCancel returns a derived context that points to the parent context and is not canceled when parent is canceled. The returned context returns no Deadline or Err, and its Done channel is nil. Calling Cause on the returned context returns nil."
    },
    {
        "link": "https://pkg.go.dev/std",
        "document": ""
    },
    {
        "link": "https://medium.com/@jamal.kaksouri/the-complete-guide-to-context-in-golang-efficient-concurrency-management-43d722f6eaea",
        "document": "Concurrency is a fundamental aspect of Go programming, and effectively managing concurrent operations is crucial for building robust and efficient applications. One of the key features that aids in achieving this is the Context package in Golang. Context provides a mechanism to control the lifecycle, cancellation, and propagation of requests across multiple goroutines. In this comprehensive guide, we will delve into the depths of context in Golang, exploring its purpose, usage, and best practices with real-world examples from the software industry.\n• Best Practices for Using Context\n\nContext is a built-in package in the Go standard library that provides a powerful toolset for managing concurrent operations. It enables the propagation of cancellation signals, deadlines, and values across goroutines, ensuring that related operations can gracefully terminate when necessary. With context, you can create a hierarchy of goroutines and pass important information down the chain.\n\nConsider a scenario where you need to fetch data from multiple APIs concurrently. By using context, you can ensure that all the API requests are canceled if any of them exceeds a specified timeout.\n\nIn this example, we create a context with a timeout of 5 seconds. We then launch multiple goroutines to fetch data from different APIs concurrently. The function is used to create an HTTP request with the provided context. If any of the API requests exceed the timeout duration, the context's cancellation signal is propagated, canceling all other ongoing requests.\n\nTo create a context, you can use the function, which returns an empty, non-cancelable context as the root of the context tree. You can also create a context with a specific timeout or deadline using or functions.\n\nIn this example, we create a context with a timeout of 2 seconds and use it to simulate a time-consuming operation.\n\nIn this example, the function simulates a long-running task that takes 5 seconds to complete. However, since the context has a timeout of only 2 seconds, the operation is terminated prematurely, resulting in a timeout.\n\nOnce you have a context, you can propagate it to downstream functions or goroutines by passing it as an argument. This allows related operations to share the same context and be aware of its cancellation or other values.\n\nIn this example, we create a parent context and propagate it to multiple goroutines to perform concurrent tasks.\n\nIn this example, we create a parent context using . We then use to attach a user ID to the context. The context is then passed to the goroutine, which retrieves the user ID using .\n\nIn addition to propagating context, you can also retrieve values stored within the context. This allows you to access important data or parameters within the scope of a specific goroutine or function.\n\nIn this example, we create a context with user information and retrieve it in a downstream function.\n\nIn this example, we create a context using and store the user ID. The context is then passed to the function, where we retrieve the user ID using type assertion and use it for further processing.\n\nCancellation is an essential aspect of context management. It allows you to gracefully terminate operations and propagate cancellation signals to related goroutines. By canceling a context, you can avoid resource leaks and ensure the timely termination of concurrent operations.\n\nIn this example, we create a context and cancel it to stop ongoing operations.\n\nIn this example, we create a context using and defer the cancellation function. The goroutine continuously performs a task until the context is canceled. After 2 seconds, we call the cancel function to initiate the cancellation process. As a result, the goroutine detects the cancellation signal and terminates the task.\n\nSetting timeouts and deadlines is crucial when working with context in Golang. It ensures that operations complete within a specified timeframe and prevents potential bottlenecks or indefinite waits.\n\nIn this example, we create a context with a deadline and perform a task that exceeds the deadline.\n\nIn this example, we create a context with a deadline of 2 seconds using . The goroutine waits for the context to be canceled or for the deadline to be exceeded. After 3 seconds, we let the program exit, triggering the deadline exceeded error.\n\nContext plays a vital role in managing HTTP requests in Go. It allows you to control request cancellation, timeouts, and pass important values to downstream handlers.\n\nExample: Using Context in HTTP Requests\n\nIn this example, we make an HTTP request with a custom context and handle timeouts.\n\nIn this example, we create a context with a timeout of 2 seconds using . We then create an HTTP request with the custom context using . The context ensures that if the request takes longer than the specified timeout, it will be canceled.\n\nContext is also useful when dealing with database operations in Golang. It allows you to manage query cancellations, timeouts, and pass relevant data within the database transactions.\n\nExample: Using Context in Database Operations\n\nIn this example, we demonstrate how to use context with a PostgreSQL database operation.\n\nIn this example, we create a context with a timeout of 2 seconds using . We then open a connection to a PostgreSQL database using the function. When executing the database query with , the context ensures that the operation will be canceled if it exceeds the specified timeout.\n\n9. Best Practices for Using Context\n\nWhen working with context in Golang, it is essential to follow some best practices to ensure efficient and reliable concurrency management.\n\nExample: Implementing Best Practices for Context Usage\n\nHere are some best practices to consider:\n• Pass Context Explicitly: Always pass the context as an explicit argument to functions or goroutines instead of using global variables. This makes it easier to manage the context’s lifecycle and prevents potential data races.\n• Use context.TODO(): If you are unsure which context to use in a particular scenario, consider using . However, make sure to replace it with the appropriate context later.\n• Avoid Using context.Background(): Instead of using directly, create a specific context using or to manage its lifecycle and avoid resource leaks.\n• Prefer Cancel Over Timeout: Use for cancellation when possible, as it allows you to explicitly trigger cancellation when needed. is more suitable when you need an automatic cancellation mechanism.\n• Keep Context Size Small: Avoid storing large or unnecessary data in the context. Only include the data required for the specific operation.\n• Avoid Chaining Contexts: Chaining contexts can lead to confusion and make it challenging to manage the context hierarchy. Instead, propagate a single context throughout the application.\n• Be Mindful of Goroutine Leaks: Always ensure that goroutines associated with a context are properly closed or terminated to avoid goroutine leaks.\n\nContext in Golang is widely used in various real-world scenarios. Let’s explore some practical examples where context plays a crucial role.\n\nIn a microservices architecture, each service often relies on various external dependencies and communicates with other services. Context can be used to propagate important information, such as authentication tokens, request metadata, or tracing identifiers, throughout the service interactions.\n\nWeb servers handle multiple concurrent requests, and context helps manage the lifecycle of each request. Context can be used to set timeouts, propagate cancellation signals, and pass request-specific values to the different layers of a web server application.\n\nWhen writing test suites, context can be utilized to manage test timeouts, control test-specific configurations, and enable graceful termination of tests. Context allows tests to be canceled or skipped based on certain conditions, enhancing test control and flexibility.\n• Not propagating the context — Child functions need the context passed to them in order to honor cancelation. Don’t create contexts and keep them confined to one function.\n• Forgetting to call cancel — When done with a cancelable context, call the cancel function. This releases resources and stops any associated goroutines.\n• Leaking goroutines — Goroutines started with a context must check the Done channel to exit properly. Otherwise they risk leaking when the context is canceled.\n• Using basic context.Background for everything — Background lacks cancelation and timeouts. Use the WithCancel, WithTimeout, or WithDeadline functions to add control.\n• Passing nil contexts — Passing nil instead of a real context causes panics. Make sure context is never nil when passing it.\n• Checking context too early — Don’t check context conditions like Done() early in an operation. This risks canceling before the work starts.\n• Using blocking calls — Blocking calls like file/network IO should be wrapped to check context cancellation. This avoids hanging.\n• Overusing contexts — Contexts are best for request-scoped operations. For globally shared resources, traditional patterns may be better.\n• Assuming contexts have timeouts — The context.Background has no deadline. Add timeouts explicitly when needed.\n• Forgetting contexts expire — Don’t start goroutines with a context and assume they will run forever. The context may expire.\n\nContexts in Go are used to manage the lifecycle and cancellation signaling of goroutines and other operations. A root context is usually created, and child contexts can be derived from it. Child contexts inherit cancellation from their parent contexts.\n\nIf a goroutine is started with a context, but does not properly exit when that context is canceled, it can result in a goroutine leak. The goroutine will persist even though the operation it was handling has been canceled.\n\nHere is an example of a goroutine leak due to improper context handling:\n\nIn this example, the goroutine started with the context does not properly exit when that context is canceled. This will result in a goroutine leak, even though the main context is canceled.\n\nTo fix it, the goroutine needs to call the context’s Done() channel when the main context is canceled:\n\nNow the goroutine will cleanly exit when the parent context is canceled, avoiding the leak. Proper context propagation and lifetime management is key to preventing goroutine leaks in Go programs.\n\nSometimes we need using third-party packages. However, many third-party libraries and APIs do not natively support context. So when using such libraries, you need to take some additional steps to integrate context usage properly:\n• Wrap the third-party APIs you call in functions that accept a context parameter.\n• In the wrapper function, call the third-party API as normal.\n• Before calling the API, check if the context is done and return immediately if so. This propagates cancellation.\n• After calling the API, check if the context is done and return immediately if so. This provides early return on cancellation.\n• Make sure to call the API in a goroutine if it involves long-running work that could block.\n• Define reasonable defaults for context values like timeout and deadline, so the API call isn’t open-ended.\n\nThis provides context integration even with APIs that don’t natively support it. The key points are wrapping API calls, propagating cancellation, using goroutines, and setting reasonable defaults.\n\nManaging cleanup and finalization tasks is an important consideration in Go, especially when dealing with concurrency. The context package provides a useful tool for this through its function.\n\nallows you to schedule functions to run asynchronously after a context ends. This enables deferred cleanup routines that will execute reliably once some operation is complete.\n\nFor example, imagine we have an API server that needs to process incoming requests from a queue. We spawn goroutines to handle each request:\n\nBut we also want to make sure any pending requests are processed if handleRequests has to exit unexpectedly. This is where can help.\n\nWe can schedule a cleanup function to run after the context is cancelled:\n\nNow our cleanup logic will run after the context ends. But since we call stop(), it is canceled before executing.\n\nallows deferred execution tied to a context’s lifetime. This provides a robust way to build asynchronous applications with proper finalization.\n\nWhen using contexts with deadlines in Go, timeout errors are common — a context will routinely expire if an operation takes too long. But the generic “context deadline exceeded” error lacks detail on the source of the timeout.\n\nThis is where comes in handy. It allows you to associate a custom error cause with a context’s deadline:\n\nNow if the deadline is exceeded, the context’s Err() method will return:\n\nThis extra cause string gives critical context on the source of the timeout. Maybe it was due to a backend RPC call failing, or a network request timing out.\n\nWithout the cause, debugging the timeout requires piecing together where it came from based on call stacks and logs. But allows directly propagating the source of the timeout through the context.\n\nTimeouts tend to cascade through systems — a low-level timeout bubbles up to eventually become an HTTP 500. Maintaining visibility into the original cause is crucial for diagnosing these issues.\n\nenables this by letting you customize the deadline exceeded error with contextual details. The error can then be inspected at any level of the stack to understand the timeout source.\n\nManaging timeouts is an important aspect of writing reliable Go programs. When using context timeouts, the error “context deadline exceeded” is generic and lacks detail on the source of the timeout.\n\nThe function addresses this by allowing you to associate a custom error cause with a context’s timeout duration:\n\nNow if that ctx hits the timeout deadline, the context’s Err() will return:\n\nThis provides critical visibility into the source of the timeout when it propagates up a call stack. Maybe it was caused by a slow database query, or a backend RPC service timing out.\n\nWithout a customized cause, debugging timeouts requires piecing together logs and traces to determine where it originated. But allows directly encoding the source of the timeout into the context error.\n\nSome key benefits of using :\n• More context for handling and recovering from timeout errors\n\ngives more control over timeout errors to better handle them programmatically and debug them when issues arise.\n\nIn Go, contexts form parent-child relationships — a canceled parent context will propagate down and cancel all children. This allows canceling an entire tree of operations.\n\nHowever, sometimes you want to branch off a child context and detach it from the parent’s lifetime. This is useful when you have a goroutine or operation that needs to keep running independently, even if the parent context is canceled.\n\nFor example, consider a server handling incoming requests:\n\nIf the parent ctx is canceled, the handleRequest goroutines will be abruptly canceled as well. This may interrupt requests that are mid-flight.\n\nWe can use to ensure the handler goroutines finish:\n\nNow the parent can be canceled, but each handler finishes independently.\n\nlets you selectively extract parts of a context tree to isolate from cancelation. This provides more fine-grained control over concurrency when using contexts.\n\nIn conclusion, understanding and effectively using context in Golang is crucial for developing robust and efficient applications. Context provides a powerful tool for managing concurrency, controlling request lifecycles, and handling cancellations and timeouts.\n\nBy creating, propagating, and canceling contexts, you can ensure proper handling of concurrent operations, control resource utilization, and enhance the overall reliability of your applications.\n\nRemember to follow best practices when working with context and consider real-world scenarios where context can significantly improve the performance and reliability of your Golang applications.\n\nWith a strong grasp of context, you’ll be well-equipped to tackle complex concurrency challenges and build scalable and responsive software systems.\n\nQ1: Can I pass custom values in the context?\n\nYes, you can pass custom values in the context using the function. It allows you to associate key-value pairs with the context, enabling the sharing of specific data across different goroutines or functions.\n\nWhen a context is canceled or times out, the function returns an error explaining the reason for cancellation. You can handle this error and take appropriate actions based on your application's requirements.\n\nYes, you can create a hierarchy of contexts by using and passing the parent context as an argument. However, it's important to consider the potential complexity and overhead introduced by nested contexts, and ensure proper management of the context lifecycle.\n\nQ4: Is it possible to pass context through HTTP middleware?\n\nYes, you can pass context through HTTP middleware to propagate values, manage timeouts, or handle cancellation. Middleware intercepts incoming requests and can enrich the request context with additional information or modify the existing context.\n\nQ5: How does context help with graceful shutdowns?\n\nContext allows you to propagate cancellation signals to goroutines, enabling graceful shutdowns of concurrent operations. By canceling the context, you can signal goroutines to complete their tasks and release any resources they hold before terminating.\n\nI hope this comprehensive guide on context in Golang has provided you with a deep understanding of its importance and practical usage. By leveraging the power of context, you can write efficient, scalable, and robust Golang applications.\n\nThank you for reading!\n\nPlease note that the examples provided in this article are for illustrative purposes only and may require additional code and error handling in real-world scenarios."
    }
]