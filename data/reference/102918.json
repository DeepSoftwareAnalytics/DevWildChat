[
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/direct3ddxgi/desktop-dup-api",
        "document": "Windows 8 disables standard Windows 2000 Display Driver Model (XDDM) mirror drivers and offers the desktop duplication API instead. The desktop duplication API provides remote access to a desktop image for collaboration scenarios. Apps can use the desktop duplication API to access frame-by-frame updates to the desktop. Because apps receive updates to the desktop image in a DXGI surface, the apps can use the full power of the GPU to process the image updates.\n\nDXGI provides a surface that contains a current desktop image through the new IDXGIOutputDuplication::AcquireNextFrame method. The format of the desktop image is always DXGI_FORMAT_B8G8R8A8_UNORM no matter what the current display mode is. Along with this surface, these IDXGIOutputDuplication methods return the indicated types of info that help you determine which pixels within the surface you need to process:\n• IDXGIOutputDuplication::GetFrameDirtyRects returns dirty regions, which are non-overlapping rectangles that indicate the areas of the desktop image that the operating system updated since you processed the previous desktop image.\n• IDXGIOutputDuplication::GetFrameMoveRects returns move regions, which are rectangles of pixels in the desktop image that the operating system moved to another location within the same image. Each move region consists of a destination rectangle and a source point. The source point specifies the location from where the operating system copied the region and the destination rectangle specifies to where the operating system moved that region. Move regions are always non-stretched regions so the source is always the same size as the destination.\n\nSuppose the desktop image was transmitted over a slow connection to your remote client app. The amount of data that is sent over the connection is reduced by receiving only data about how your client app must move regions of pixels rather than actual pixel data. To process the moves, your client app must have stored the complete last image.\n\nWhile the operating system accumulates unprocessed desktop image updates, it might run out of space to accurately store the update regions. In this situation, the operating system starts to accumulate the updates by coalescing them with existing update regions to cover all new updates. As a result, the operating system covers pixels that it has not actually updated in that frame yet. But this situation doesn’t produce visual issues on your client app because you receive the entire desktop image and not just the updated pixels.\n\nTo reconstruct the correct desktop image, your client app must first process all the move regions and then process all the dirty regions. Either of these lists of dirty and move regions can be completely empty. The example code from the Desktop Duplication Sample shows how to process both the dirty and move regions in a single frame:\n\nYou must add explicit code to your desktop duplication client app to support rotated modes. In a rotated mode, the surface that you receive from IDXGIOutputDuplication::AcquireNextFrame is always in the un-rotated orientation, and the desktop image is rotated within the surface. For example, if the desktop is set to 768x1024 at 90 degrees rotation, AcquireNextFrame returns a 1024x768 surface with the desktop image rotated within it. Here are some rotation examples.\n\nThe code in your desktop duplication client app must rotate the desktop image appropriately before you display the desktop image.\n\nYou need to use the desktop duplication API to determine if your client app must draw the mouse pointer shape onto the desktop image. Either the mouse pointer is already drawn onto the desktop image that IDXGIOutputDuplication::AcquireNextFrame provides or the mouse pointer is separate from the desktop image. If the mouse pointer is drawn onto the desktop image, the pointer position data that is reported by AcquireNextFrame (in the PointerPosition member of DXGI_OUTDUPL_FRAME_INFO that the pFrameInfo parameter points to) indicates that a separate pointer isn’t visible. If the graphics adapter overlays the mouse pointer on top of the desktop image, AcquireNextFrame reports that a separate pointer is visible. So, your client app must draw the mouse pointer shape onto the desktop image to accurately represent what the current user will see on their monitor.\n\nTo draw the desktop’s mouse pointer, use the PointerPosition member of DXGI_OUTDUPL_FRAME_INFO from the pFrameInfo parameter of AcquireNextFrame to determine where to locate the top left hand corner of the mouse pointer on the desktop image. When you draw the first frame, you must use the IDXGIOutputDuplication::GetFramePointerShape method to obtain info about the shape of the mouse pointer. Each call to AcquireNextFrame to get the next frame also provides the current pointer position for that frame. On the other hand, you need to use GetFramePointerShape again only if the shape changes. So, keep a copy of the last pointer image and use it to draw on the desktop unless the shape of the mouse pointer changes.\n\nThis example code from the Desktop Duplication Sample shows how to get the mouse pointer shape:"
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows-hardware/drivers/display/desktop-duplication-api",
        "document": "Windows 8 introduced a DirectX Graphics Infrastructure (DXGI)-based API called the Desktop Duplication API. This API makes it easier for independent software vendors (ISVs) to support desktop collaboration and remote desktop access.\n\nSuch applications are widely used in enterprise and educational scenarios. These applications share a common requirement: they need access to the contents of a desktop together with the ability to transport the contents to a remote location.\n\nThe API provides access to the desktop contents by using bitmaps and associated metadata for optimizations. It works with the Aero theme enabled, and isn't dependent on the graphics API that applications use. If a user can view the application on the local console, then the content can be viewed remotely as well. This means that even full screen DirectX applications can be duplicated. The API provides protection against accessing protected video content.\n\nThe API enables an application to request Windows to provide access to the contents of the desktop along monitor boundaries. The application can duplicate one or more of the active displays. When an application requests duplication, the following occurs:\n• Windows renders the desktop and provides a copy to the application.\n• Each rendered frame is placed in GPU memory.\n• Each rendered frame comes with the following metadata:\n• Application is provided access to frame and metadata.\n• Application is responsible for processing each frame:\n• Application can choose to optimize based on dirty region.\n• Application can choose to use hardware acceleration to process move and mouse data.\n• Application can choose to use hardware acceleration for compression before streaming out.\n\nFor detailed documentation and samples, see Desktop Duplication API."
    },
    {
        "link": "https://stackoverflow.com/questions/77548249/desktop-duplication-api-dxgi-outdupl-frame-info-lastpresenttime-is-0-for-the-f",
        "document": "I use Desktop Duplication API to take screenshots of the desktop. It works fine, except the first 5 minutes after I restart my computer. In these first 5 minutes is always 0, so the CaptureScreen() function exits without taking a screenshot. If I take out the if with the check, then the code works, but it takes a screenshot at every mouse movement, even if the screen does not changed.\n\nAccording to the documentation for LastPresentTime: \"a zero value indicates that the desktop image was not updated since an application last called the IDXGIOutputDuplication::AcquireNextFrame method to acquire the next frame of the desktop image.\" But this is not true for me, even if I watch a 60fps youtube video, LastPresentTime is 0 for the first 5 minutes after a computer restart.\n\nHere is the code:"
    },
    {
        "link": "https://github.com/jangxx/node-win-desktop-duplication",
        "document": "A native module for Node.js to use the Desktop Duplication API, which is part of Windows 8 and higher.\n\nMore examples, including ones on how to write the data into png-files, can be found in the examples/ directory. You need to install pngjs before you can use them however ( ).\n\nAll of the methods returning images return an object with the format:\n\nThe data in the buffer are the raw pixel values in RGBA order with one byte per channel. This object format is referred to as the \"default format\" in the rest of this documentation.\n\nstatic getMonitorCount()\n\n Static method to get the number of available monitors.\n\nconstructor(screenNum)\n\n Creates a new instance for the screen . Use the method to get the number of available screens.\n\ninitialize()\n\n Set up the required DirectX objects. Use a try/catch block to catch errors in the initialization process.\n\ngetFrame(?retryCount)\n\n Synchronously gets a single frame in the default format. If the procedure fails, retry up to times (default: 5). If there was no image captured after all retries are used up, this method throws an error.\n\ngetFrameAsync(?retryCount)\n\n Like , but returning a promise instead which resolves to image data. The capture and image processing is also run in a separate thread for better performance.\n\nstartAutoCapture(delay, ?allowSkips)\n\n Starts a new thread, which tries to capture the screen every milliseconds. Image data is then emitted as a frame event. This method functions similar to , but with the added bonus of all the timing stuff happening in native code and a separate thread for better performance. Note: You can only have one of these threads running at any time, so subsequent calls to without stopping the auto capture in between have no effect. The optional parameter controls how the thread queues up the frame events. If the event did not have a chance to fire before the next image is captured, it can either be queued up ( ) or just be thrown away ( , default).\n\nstopAutoCapture(?clearBacklog)\n\n Stops the auto capture thread. By default, no futher frame events will be emitted after this method has been called, since is by default. If you want to process every captured frame set to .\n\nEvent 'frame'\n\n Emitted in an interval determined by the delay parameter in the method. The event handler will be called with an object in the default image format.\n\nThis error is thrown if multiple simultaneous requests to capture an image are attempted. Different from how one might expect the DesktopDuplication to work, it does not actually simply return an image of the current desktop content. Instead, the user has to request an image and Windows will only return one if the contents have changed since the last request. The request is given a timeout (the maximum time it will block) in case no image is returned. This behavior does not mesh well with having multiple threads running however, since this library only uses a single DesktopDuplication instance for all methods as well as a timeout of 1 second. It is therefore very easy to request two images at the same time if or are used. To avoid the error you can either only use the blocking , or make sure that no calls to and and no running auto capture threads happen at the same time."
    },
    {
        "link": "https://github.com/MurkyYT/DXGICapture",
        "document": "This library is used by CSAuto to capture the screen of CS2\n\nC# Example DXGIcapture.cs class in here\n\n//Get pointer to the bitmap"
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/api/d3d11/nf-d3d11-d3d11createdevice",
        "document": "A pointer to the video adapter to use when creating a device. Pass NULL to use the default adapter, which is the first adapter that is enumerated by IDXGIFactory1::EnumAdapters.\n\nThe D3D_DRIVER_TYPE, which represents the driver type to create.\n\nA handle to a DLL that implements a software rasterizer. If DriverType is D3D_DRIVER_TYPE_SOFTWARE, Software must not be NULL. Get the handle by calling LoadLibrary, LoadLibraryEx , or GetModuleHandle.\n\nThe runtime layers to enable (see D3D11_CREATE_DEVICE_FLAG); values can be bitwise OR'd together.\n\nA pointer to an array of D3D_FEATURE_LEVELs, which determine the order of feature levels to attempt to create. If pFeatureLevels is set to NULL, this function uses the following array of feature levels:\n\nThe number of elements in pFeatureLevels.\n\nReturns the address of a pointer to an ID3D11Device object that represents the device created. If this parameter is NULL, no ID3D11Device will be returned.\n\nIf successful, returns the first D3D_FEATURE_LEVEL from the pFeatureLevels array which succeeded. Supply NULL as an input if you don't need to determine which feature level is supported.\n\nReturns the address of a pointer to an ID3D11DeviceContext object that represents the device context. If this parameter is NULL, no ID3D11DeviceContext will be returned.\n\nThis method can return one of the Direct3D 11 Return Codes.\n\nThis method returns E_INVALIDARG if you set the pAdapter parameter to a non-NULL value and the DriverType parameter to the D3D_DRIVER_TYPE_HARDWARE value.\n\nThis method returns DXGI_ERROR_SDK_COMPONENT_MISSING if you specify D3D11_CREATE_DEVICE_DEBUG in Flags and the incorrect version of the debug layer is installed on your computer. Install the latest Windows SDK to get the correct version.\n\nThis entry-point is supported by the Direct3D 11 runtime, which is available on Windows 7, Windows Server 2008 R2, and as an update to Windows Vista (KB971644).\n\nTo create a Direct3D 11.1 device (ID3D11Device1), which is available on Windows 8, Windows Server 2012, and Windows 7 and Windows Server 2008 R2 with the Platform Update for Windows 7 installed, you first create a ID3D11Device with this function, and then call the QueryInterface method on the ID3D11Device object to obtain the ID3D11Device1 interface.\n\nTo create a Direct3D 11.2 device (ID3D11Device2), which is available on Windows 8.1 and Windows Server 2012 R2, you first create a ID3D11Device with this function, and then call the QueryInterface method on the ID3D11Device object to obtain the ID3D11Device2 interface.\n\nSet ppDevice and ppImmediateContext to NULL to determine which feature level is supported by looking at pFeatureLevel without creating a device.\n\nFor an example, see How To: Create a Device and Immediate Context; to create a device and a swap chain at the same time, use D3D11CreateDeviceAndSwapChain.\n\nIf you set the pAdapter parameter to a non-NULL value, you must also set the DriverType parameter to the D3D_DRIVER_TYPE_UNKNOWN value. If you set the pAdapter parameter to a non-NULL value and the DriverType parameter to the D3D_DRIVER_TYPE_HARDWARE value, D3D11CreateDevice returns an HRESULT of E_INVALIDARG.\n\nThe function signature PFN_D3D11_CREATE_DEVICE is provided as a typedef, so that you can use dynamic linking techniques (GetProcAddress) instead of statically linking."
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/api/d3d11/nf-d3d11-d3d11createdeviceandswapchain",
        "document": "Creates a device that represents the display adapter and a swap chain used for rendering.\n\nA pointer to the video adapter to use when creating a device. Pass NULL to use the default adapter, which is the first adapter enumerated by IDXGIFactory1::EnumAdapters.\n\nThe D3D_DRIVER_TYPE, which represents the driver type to create.\n\nA handle to a DLL that implements a software rasterizer. If DriverType is D3D_DRIVER_TYPE_SOFTWARE, Software must not be NULL. Get the handle by calling LoadLibrary, LoadLibraryEx , or GetModuleHandle. The value should be non-NULL when D3D_DRIVER_TYPE is D3D_DRIVER_TYPE_SOFTWARE and NULL otherwise.\n\nThe runtime layers to enable (see D3D11_CREATE_DEVICE_FLAG); values can be bitwise OR'd together.\n\nA pointer to an array of D3D_FEATURE_LEVELs, which determine the order of feature levels to attempt to create. If pFeatureLevels is set to NULL, this function uses the following array of feature levels:\n\nThe number of elements in pFeatureLevels.\n\nA pointer to a swap chain description (see DXGI_SWAP_CHAIN_DESC) that contains initialization parameters for the swap chain.\n\nReturns the address of a pointer to the IDXGISwapChain object that represents the swap chain used for rendering.\n\nReturns the address of a pointer to an ID3D11Device object that represents the device created. If this parameter is NULL, no ID3D11Device will be returned'.\n\nReturns a pointer to a D3D_FEATURE_LEVEL, which represents the first element in an array of feature levels supported by the device. Supply NULL as an input if you don't need to determine which feature level is supported.\n\nReturns the address of a pointer to an ID3D11DeviceContext object that represents the device context. If this parameter is NULL, no ID3D11DeviceContext will be returned.\n\nThis method can return one of the Direct3D 11 Return Codes.\n\nThis method returns DXGI_ERROR_NOT_CURRENTLY_AVAILABLE if you call it in a Session 0 process.\n\nThis method returns E_INVALIDARG if you set the pAdapter parameter to a non-NULL value and the DriverType parameter to the D3D_DRIVER_TYPE_HARDWARE value.\n\nThis method returns DXGI_ERROR_SDK_COMPONENT_MISSING if you specify D3D11_CREATE_DEVICE_DEBUG in Flags and the incorrect version of the debug layer is installed on your computer. Install the latest Windows SDK to get the correct version.\n\nThis entry-point is supported by the Direct3D 11 runtime, which is available on Windows 7, Windows Server 2008 R2, and as an update to Windows Vista (KB971644).\n\nTo create a Direct3D 11.1 device (ID3D11Device1), which is available on Windows 8, Windows Server 2012, and Windows 7 and Windows Server 2008 R2 with the Platform Update for Windows 7 installed, you first create a ID3D11Device with this function, and then call the QueryInterface method on the ID3D11Device object to obtain the ID3D11Device1 interface.\n\nTo create a Direct3D 11.2 device (ID3D11Device2), which is available on Windows 8.1 and Windows Server 2012 R2, you first create a ID3D11Device with this function, and then call the QueryInterface method on the ID3D11Device object to obtain the ID3D11Device2 interface.\n\nAlso, see the remarks section in D3D11CreateDevice for details about input parameter dependencies. To create a device without creating a swap chain, use the D3D11CreateDevice function.\n\nIf you set the pAdapter parameter to a non-NULL value, you must also set the DriverType parameter to the D3D_DRIVER_TYPE_UNKNOWN value. If you set the pAdapter parameter to a non-NULL value and the DriverType parameter to the D3D_DRIVER_TYPE_HARDWARE value, D3D11CreateDeviceAndSwapChain returns an HRESULT of E_INVALIDARG.\n\nThe function signature PFN_D3D11_CREATE_DEVICE_AND_SWAP_CHAIN is provided as a typedef, so that you can use dynamic linking techniques (GetProcAddress) instead of statically linking."
    },
    {
        "link": "https://github.com/MicrosoftDocs/sdk-api/blob/docs/sdk-api-src/content/d3d11/nf-d3d11-d3d11createdevice.md",
        "document": "A pointer to the video adapter to use when creating a device. Pass NULL to use the default adapter, which is the first adapter that is enumerated by IDXGIFactory1::EnumAdapters.\n\nThe D3D_DRIVER_TYPE, which represents the driver type to create.\n\nA handle to a DLL that implements a software rasterizer. If DriverType is D3D_DRIVER_TYPE_SOFTWARE, Software must not be NULL. Get the handle by calling LoadLibrary, LoadLibraryEx , or GetModuleHandle.\n\nThe runtime layers to enable (see D3D11_CREATE_DEVICE_FLAG); values can be bitwise OR'd together.\n\nA pointer to an array of D3D_FEATURE_LEVELs, which determine the order of feature levels to attempt to create. If pFeatureLevels is set to NULL, this function uses the following array of feature levels:\n\nThe number of elements in pFeatureLevels.\n\nReturns the address of a pointer to an ID3D11Device object that represents the device created. If this parameter is NULL, no ID3D11Device will be returned.\n\nIf successful, returns the first D3D_FEATURE_LEVEL from the pFeatureLevels array which succeeded. Supply NULL as an input if you don't need to determine which feature level is supported.\n\nReturns the address of a pointer to an ID3D11DeviceContext object that represents the device context. If this parameter is NULL, no ID3D11DeviceContext will be returned.\n\nThis method can return one of the Direct3D 11 Return Codes.\n\nThis method returns E_INVALIDARG if you set the pAdapter parameter to a non-NULL value and the DriverType parameter to the D3D_DRIVER_TYPE_HARDWARE value.\n\nThis method returns DXGI_ERROR_SDK_COMPONENT_MISSING if you specify D3D11_CREATE_DEVICE_DEBUG in Flags and the incorrect version of the debug layer is installed on your computer. Install the latest Windows SDK to get the correct version.\n\nThis entry-point is supported by the Direct3D 11 runtime, which is available on Windows 7, Windows Server 2008 R2, and as an update to Windows Vista (KB971644).\n\nTo create a Direct3D 11.1 device (ID3D11Device1), which is available on Windows 8, Windows Server 2012, and Windows 7 and Windows Server 2008 R2 with the Platform Update for Windows 7 installed, you first create a ID3D11Device with this function, and then call the QueryInterface method on the ID3D11Device object to obtain the ID3D11Device1 interface.\n\nTo create a Direct3D 11.2 device (ID3D11Device2), which is available on Windows 8.1 and Windows Server 2012 R2, you first create a ID3D11Device with this function, and then call the QueryInterface method on the ID3D11Device object to obtain the ID3D11Device2 interface.\n\nSet ppDevice and ppImmediateContext to NULL to determine which feature level is supported by looking at pFeatureLevel without creating a device.\n\nFor an example, see How To: Create a Device and Immediate Context; to create a device and a swap chain at the same time, use D3D11CreateDeviceAndSwapChain.\n\nIf you set the pAdapter parameter to a non-NULL value, you must also set the DriverType parameter to the D3D_DRIVER_TYPE_UNKNOWN value. If you set the pAdapter parameter to a non-NULL value and the DriverType parameter to the D3D_DRIVER_TYPE_HARDWARE value, D3D11CreateDevice returns an HRESULT of E_INVALIDARG.\n\nThe function signature PFN_D3D11_CREATE_DEVICE is provided as a typedef, so that you can use dynamic linking techniques (GetProcAddress) instead of statically linking."
    },
    {
        "link": "https://stackoverflow.com/questions/74070795/how-to-pass-an-existing-idxgiadapter-to-d3d11createdevice-to-create-a-d3d11dev",
        "document": "I would like to pass a previously instantiated to so that I have the control which adapter is used when creating the D3D11 device.\n\nI am using the following sources of inspiration and in-dept analysis:\n• CUDA sample for interop with DirectX 11 (code can be seen here)\n• DirectX basic construct that allows me to experiment (code can be seen here - click on to reveal the full code)\n• Visual Studio 2017 Pro incl. the MSVC toolkit that comes with it\n\nWhenever I try to pass anything but as to I get an equal to .\n\nMy goal is to be able to use CUDA DX11 interop to process D3D11 buffers using CUDA (incl. , that is PyTorch in C++).\n\nMany PCs contain at least one DX-capable GPU, however not every such GPU is CUDA-capable (e.g. integrated GPU or AMD/Intel dedicated GPU). Multiple GPUs are also not excluded in my case. Therefore the starting point for me is answering the question:\n\nThe CUDA sample I have linked above contains two important functions namely as well as . The first one detects if CUDA is at all available, while the second (although not in a perfect way) detects a DX-compatible device that also supports CUDA.\n\nI adopted and modified the second function like this (it's not without bugs...):\n\nThe function still needs further refinement (currently it's just taking the first DX11-CUDA capable device and returns it) but the result is enough for me to investigate further.\n\nUsing the DirectX 11 basic setup I posted at the beginning I added\n\nright after the initialization of the swap chain and replaced the previously used\n\nwith the intention to\n• use the adapter retrieved in\n\nDirectX however disagrees with me and whenever I run my code I get an for that call. I nailed it down to the first argument namely the that is passed onto the function. If I set it to , no error occurs.\n\nHow do I instruct DX that I want to use a specific adapter whenever I create a new D3D11 device?"
    },
    {
        "link": "http://code4k.blogspot.com/2010/10/managed-netc-direct3d-11-api-generated.html",
        "document": "\n• API is generated from DirectX SDK headers : the mapping is able to perform \"complex transformation\", extracting all relevant information like enumerations, structures, interfaces, functions, macro definitions, guids from the C++ source headers. For example, the mapping process is able to generated properties for interfaces or inner group interface like the one you have in SlimDX : meaning that instead of having a \"device.IASetInputLayout\" you are able to write \"device.InputAssembler.InputLayout = ...\".\n• Full support of Direct3D 11, DXGI 1.0/1.1, D3DCompiler API : Due to the whole auto-generated process, the actual coverage is 100%. Although, I have limited the generated code to those library but that could be extended to others API quite easily (like XAudio2, Direct2D, DirectWrite... etc.).\n• Pure managed .NET API : assemblies are compiled with AnyCpu target. You can run your code on a x64 or a x86 machine with the same assemblies.\n• API Extensibility The generated code is in C#, all the types are marked \"partial\" and are easily extensible to provide new helpers method. The code generator is able to hide some methods/types internally in order to use them in helper methods and to hide them from the public api.\n• C++/CLI Speed : the framework is using a genuine way to avoid any C++/CLI while still achieving comparable performance.\n• Separate assemblies : a core assembly containing common classes and an assembly for each subgroup API (Direct3D, DXGI, D3DCompiler)\n• Lightweight assemblies : generated assemblies are lightweight, 300Ko in total, 70Ko compressed in an archive (similar assemblies in C++/CLI would be closer to 1Mo, one for each architecture, and depend from MSVCRT10)\n• API naming convention very close to SlimDX API (To make it 100% equals would just require to specify the correct mapping names while generating the code)\n• Raw DirectX object life management : No overhead of ObjectTable or RCW mechanism, the API is using direct native management with classic COM method \"Release\". Currently, instead of calling Dispose, you should call Release (and call AddRef if you are duplicating references, like in C++). I might evaluate how to safely integrate Dispose method call.\n• Easily obfuscatable : Due to the fact the framework is not using any mixed assemblies\n• DirectX SDK Documentation integrated in the .NET xml comments : The whole API is also generated with the MSDN documentation. Meaning that you have exactly the same documentation for DirectX and for this API (this is working even for method parameters, remarks, enum items...etc.). Reference to other types inside the documentation are correctly linked to the .NET API.\n• Prototype for a partial support of the Effects11 API in full managed .NET.\n\nAn attempt to a SlimDX next gen\n• Making object life management closer to the real thing (no Dispose but raw Release instead)\n• Working on the API more with C# than in C++/CLI\n• Support automatic platform architecture switching (running transparently an executable on a x86 and x64 machine without recompiling anything).\n• Convert from the DirectX SDK C++ Headers to an intermediate format called \"XIDL\" which is a mix of XML and \"IDL\". This first part is responsible to reverse engineering the headers, extract back all existing and useful information (more on the following section), and produce a kind of IDL (Intermediate Definition Language). In fact, If I had access to the IDL used internally at Microsoft, It wouldn't have been necessary to write this whole part, but sadly, the DirectX 11 IDL is not available, although you can clearly verify from the D3D11.h that this file is generated from an IDL. This module is also responsible to access MSDN website and crawl the needed documentation, and associate it with all the languages elements (structures, structures fields, enums, enum items, interfaces, interfaces methods, method parameters...etc.). Once a documentation has been retrieved, It's stored on the disk and is not retrieved next time the conversion process is re-runned.\n• Convert from the XIDL file to several C# files. This part is responsible to perform from a set of mapping rules a translation of C++ definition to C# definition. The mapping is as complex as identifying which include would map to assembly/namespace, which type could be moved to an assembly/namespace, how to rename the types,functions, fields, parameters, how to add missing information from the XIDL file...etc. The current mapping rules are express in less then 600 lines of C# code... There is also a trick here not described in the picture. This process is also generating a small interop assembly which is only used at compile time, dynamically generated at runtime and responsible for filling the gap between what is possible in C# and what you can do in C++/CLI (there are lots of small usefull IL bytecode instructions generated in C++/CLI that are not accessible from C#, this assembly is here for that....more on this in the Convert to XIDL section).\n• Integrate the generated files in several Visual Studio projects and a global solution. Each project is generating an assembly. It is where you can add custom code that could not be generated (like Vector3 math functions, or general framework objects like a ComObject). The generated code is also fully marked with \"partial\" class, one of the cool things of C# : you can have multiple files contributing to the same class declaration... making things easy to have generated code on the side of custom hand made code.\n\nID3D11DeviceChild A device-child interface accesses data used by a device. \" \" IUnknown GetDevice Get a pointer to the device that created this interface. Any returned interfaces will have their reference count incremented by one, so be sure to call ::release() on the returned pointer(s) before they are freed or else you will have a memory leak. \" \" voidReturns nothing. \" \" void > false false \" \" StdCall 3 ppDevice Address of a pointer to a device (see {{ID3D11Device}}).\n• Reading XIDL model and prepare the model for mapping: remove types, add information to some methods.\n• Generate a C# model with the XIDL model and a set of mapping rules\n• Generate C# files from the C# model. I have used T4 \"Text Template Transformation Toolkit\" engine as a text templatizer, which is part of VS2010 and is really easy to use, integrated in VS2010 with a third party syntax highlighting plugin.\n\nPreamble) How to avoid the usage of C++/CLI in C#\n• Add missing C++ attributes (In, InOut, Buffer) information to some method's parameter\n• Replace the type of some method parameters : for example in DirectX, there are lots of parameter that are taking a flags, which is in fact an already declared enum... but for some unknown reason, they are declaring the method with an \"int\" instead of using the enum...\n• Remove some types. For example, the D3D_PRIMITIVE_TOPOLOGY is holding a bunch of D3D11 and D3D10 enum, duplicating D3D_PRIMITIVE enums... So I'm removing them.\n• Add some tag directly on the XIDL model in order to ease the next mapping process : those tags are for example used for tagging the C# visibility of the method, or forcing a method to not be interpreted as a \"property\")\n\nII) Generate C# model from XIDL and mapping rules\n\nGenerate C# code from C# model and adding custom classes\n• For enums, the mapping is straightforward, resulting in an almost one-to-one mapping\n• For structures, the mapping is quite straightforward, resulting in an almost one-to-one mapping for most of the types. Although there are a couple of case where the mapping need to generate some marshalling code, essentially when there is a bool in the struct, or when there is a string pointer, or a fixed array of struct inside a struct.\n• For Interfaces the mapping is quite complex, because it is necessary to handle lost of different cases:\n• Perform some custom marshaling (for example, with the previous BlendDescription structure)\n• Generating properties for methods that are property elligible\n• For functions, the mapping is quite straightforward, because we are relying on a plain pinvoke interop. This was the easiest choice and easier to generate. Although pInvoke calls are still hidden in order to perform some parameter transformation, mostly in order to support the custom COM Object model generated.\n\nExtend the model in C#\n• A core assembly that contains non generated code (ComObject, DataStream, Vectors, Utilities...) and common enumeration and structs for Direct3D (structures that are usually shared between D3D10, D3D10.1 and D3D11).\n• An assembly for DXGI that has a dependency to the core assembly\n• An assembly for D3DCompiler that has a dependency to the core assembly\n• An assembly for D3D11 that has a dependency to the core, DXGI and D3DCompiler\n• Extension classes : They are placed in a subdirectory Extension with the filename of the extended class .e.g. Factory.cs\n• Non generated classes : For example, VertexBufferBinding which is used by a custom SetVertexBuffers in order to set strides, offsets and buffers in a more friendly way like :\n\nThe great news is that looking at the C++ Effects11 sample, I have been able to port the most interesting part : decoding an Effect bytecode to extract usefull information, like constant buffers, techniques, stages, shader's bytecodes...etc. I'm not going to support the whole fx_5_0 profile, because I'm usually using a subset of this : for example, I don't find practical to declare samplers state, blending...etc. in the shader and I do prefer to have them instantiated from the C# code. On the other hand, I like a lot the way the Effects library is encapsulating constant buffer and shader resource view binding to shader stages. This is one of the most laborious things to do if you are going with the raw Direct3D 11 interface. So if I could have an Effect framework supporting at least techniques, pass and proper automatic constant buffer and SRV bindings, I would be very happy. This part will deserve another post!\n\nAlso, working more with SlimDX and this new API wrapper, I have been working with a XNA like API on top of a Direct3D 11 API, and It was in fact really easy to achieve (of course, without the content pipeline, which is the true benefit of XNA). Why do we need such a higher API? Well, Direct3D 11 is really powerful with its buffer/resource management, but the fact is that it's much more verbose. But think about it : When you use a Texture2D, you will need most of the time a ShaderResourceView on it.... If you want a texture2D as a render target, you will probably need a RenderTargetView, and because It's a RenderTarget, you will probably use this RenderTarget as a ShaderResourceView for another pass... So in the end, there are lots of things that can be handled in the background, even if you are using a Direct3D 11 API. The nice thing about this kind of API is that you can play with some geometry or compute shaders, while still having the pleasure to work with a high level API. This will also probably be part of a post!\n\nSo, what's next? I just finished the mapping and the port of the MiniTri yesterday. The current wrapper is probably not yet fully usable and doesn't have the same level of API richness than SlimDX. Threre are still lots of -small- extensions code to add to make the coding experience better than a somewhat raw D3D11 API. Within the next days, I'm going to play much more with this new wrapper and see how far can it go..."
    },
    {
        "link": "https://stackoverflow.com/questions/72986817/how-to-use-idxgioutputduplication-to-capture-multiple-screens",
        "document": "Is there a way to screen capture multi monitor setups with windows duplication api (IDXIOutputDuplication) rather than gdi? Windows duplication is now the preferred (faster and more efficient) way of screen capturing on Windows machines. This is a question on the Microsoft forum but the link to the code is broken and I can't find it anywhere on their website 1. Examples of multi monitor screen casting with GDI can be found but they use a separate API 2,3.\n\nI have successfully captured one monitor in C++ using the links for Windows duplication api found here 4. The problem is that the api requires an adapter and an output. I could possibly create two threads and run the windows api on each for separate adapters. I was just wondering if there was a more elegant/better performance solution.\n\nP.S. I have had trouble posting questions on StackOverflow in the past. Before closing this question, please let me know how I can change the content to better suit the rules:)\n\nIn response to the request for code, here is a snippet from the header file\n\nfrom the cpp file (there are two parts, initializing and capuring):\n\nDeskDupl is tied to a specific adapter and output."
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/api/dxgi1_2/nf-dxgi1_2-idxgioutput1-duplicateoutput",
        "document": "Creates a desktop duplication interface from the IDXGIOutput1 interface that represents an adapter output.\n\nA pointer to the Direct3D device interface that you can use to process the desktop image. This device must be created from the adapter to which the output is connected.\n\nA pointer to a variable that receives the new IDXGIOutputDuplication interface.\n• E_INVALIDARG for one of the following reasons:\n• The specified device (pDevice) is invalid, was not created on the correct adapter, or was not created from IDXGIFactory1 (or a later version of a DXGI factory interface that inherits from IDXGIFactory1).\n• The calling application is already duplicating this desktop output.\n• E_ACCESSDENIED if the application does not have access privilege to the current desktop image. For example, only an application that runs at LOCAL_SYSTEM can access the secure desktop.\n• DXGI_ERROR_UNSUPPORTED if the created IDXGIOutputDuplication interface does not support the current desktop mode or scenario. For example, 8bpp and non-DWM desktop modes are not supported. If DuplicateOutput fails with DXGI_ERROR_UNSUPPORTED, the application can wait for system notification of desktop switches and mode changes and then call DuplicateOutput again after such a notification occurs. For more information, refer to EVENT_SYSTEM_DESKTOPSWITCH and mode change notification (WM_DISPLAYCHANGE).\n• DXGI_ERROR_NOT_CURRENTLY_AVAILABLE if DXGI reached the limit on the maximum number of concurrent duplication applications (default of four). Therefore, the calling application cannot create any desktop duplication interfaces until the other applications close.\n• DXGI_ERROR_SESSION_DISCONNECTED if DuplicateOutput failed because the session is currently disconnected.\n• Other error codes are described in the DXGI_ERROR topic.\n\nPlatform Update for Windows 7: On Windows 7 or Windows Server 2008 R2 with the Platform Update for Windows 7 installed, DuplicateOutput fails with E_NOTIMPL. For more info about the Platform Update for Windows 7, see Platform Update for Windows 7.\n\nIf an application wants to duplicate the entire desktop, it must create a desktop duplication interface on each active output on the desktop. This interface does not provide an explicit way to synchronize the timing of each output image. Instead, the application must use the time stamp of each output, and then determine how to combine the images.\n\nFor DuplicateOutput to succeed, you must create pDevice from IDXGIFactory1 or a later version of a DXGI factory interface that inherits from IDXGIFactory1.\n\nIf the current mode is a stereo mode, the desktop duplication interface provides the image for the left stereo image only.\n\nBy default, only four processes can use a IDXGIOutputDuplication interface at the same time within a single session. A process can have only one desktop duplication interface on a single desktop output; however, that process can have a desktop duplication interface for each output that is part of the desktop.\n\nFor improved performance, consider using DuplicateOutput1."
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/direct3ddxgi/desktop-dup-api",
        "document": "Windows 8 disables standard Windows 2000 Display Driver Model (XDDM) mirror drivers and offers the desktop duplication API instead. The desktop duplication API provides remote access to a desktop image for collaboration scenarios. Apps can use the desktop duplication API to access frame-by-frame updates to the desktop. Because apps receive updates to the desktop image in a DXGI surface, the apps can use the full power of the GPU to process the image updates.\n\nDXGI provides a surface that contains a current desktop image through the new IDXGIOutputDuplication::AcquireNextFrame method. The format of the desktop image is always DXGI_FORMAT_B8G8R8A8_UNORM no matter what the current display mode is. Along with this surface, these IDXGIOutputDuplication methods return the indicated types of info that help you determine which pixels within the surface you need to process:\n• IDXGIOutputDuplication::GetFrameDirtyRects returns dirty regions, which are non-overlapping rectangles that indicate the areas of the desktop image that the operating system updated since you processed the previous desktop image.\n• IDXGIOutputDuplication::GetFrameMoveRects returns move regions, which are rectangles of pixels in the desktop image that the operating system moved to another location within the same image. Each move region consists of a destination rectangle and a source point. The source point specifies the location from where the operating system copied the region and the destination rectangle specifies to where the operating system moved that region. Move regions are always non-stretched regions so the source is always the same size as the destination.\n\nSuppose the desktop image was transmitted over a slow connection to your remote client app. The amount of data that is sent over the connection is reduced by receiving only data about how your client app must move regions of pixels rather than actual pixel data. To process the moves, your client app must have stored the complete last image.\n\nWhile the operating system accumulates unprocessed desktop image updates, it might run out of space to accurately store the update regions. In this situation, the operating system starts to accumulate the updates by coalescing them with existing update regions to cover all new updates. As a result, the operating system covers pixels that it has not actually updated in that frame yet. But this situation doesn’t produce visual issues on your client app because you receive the entire desktop image and not just the updated pixels.\n\nTo reconstruct the correct desktop image, your client app must first process all the move regions and then process all the dirty regions. Either of these lists of dirty and move regions can be completely empty. The example code from the Desktop Duplication Sample shows how to process both the dirty and move regions in a single frame:\n\nYou must add explicit code to your desktop duplication client app to support rotated modes. In a rotated mode, the surface that you receive from IDXGIOutputDuplication::AcquireNextFrame is always in the un-rotated orientation, and the desktop image is rotated within the surface. For example, if the desktop is set to 768x1024 at 90 degrees rotation, AcquireNextFrame returns a 1024x768 surface with the desktop image rotated within it. Here are some rotation examples.\n\nThe code in your desktop duplication client app must rotate the desktop image appropriately before you display the desktop image.\n\nYou need to use the desktop duplication API to determine if your client app must draw the mouse pointer shape onto the desktop image. Either the mouse pointer is already drawn onto the desktop image that IDXGIOutputDuplication::AcquireNextFrame provides or the mouse pointer is separate from the desktop image. If the mouse pointer is drawn onto the desktop image, the pointer position data that is reported by AcquireNextFrame (in the PointerPosition member of DXGI_OUTDUPL_FRAME_INFO that the pFrameInfo parameter points to) indicates that a separate pointer isn’t visible. If the graphics adapter overlays the mouse pointer on top of the desktop image, AcquireNextFrame reports that a separate pointer is visible. So, your client app must draw the mouse pointer shape onto the desktop image to accurately represent what the current user will see on their monitor.\n\nTo draw the desktop’s mouse pointer, use the PointerPosition member of DXGI_OUTDUPL_FRAME_INFO from the pFrameInfo parameter of AcquireNextFrame to determine where to locate the top left hand corner of the mouse pointer on the desktop image. When you draw the first frame, you must use the IDXGIOutputDuplication::GetFramePointerShape method to obtain info about the shape of the mouse pointer. Each call to AcquireNextFrame to get the next frame also provides the current pointer position for that frame. On the other hand, you need to use GetFramePointerShape again only if the shape changes. So, keep a copy of the last pointer image and use it to draw on the desktop unless the shape of the mouse pointer changes.\n\nThis example code from the Desktop Duplication Sample shows how to get the mouse pointer shape:"
    },
    {
        "link": "https://stackoverflow.com/questions/64468119/dxgi-desktop-duplication-capture-only-a-particular-rect",
        "document": "Is there any way that we could crop a particular RECT from the image captured using the Desktop Duplication and renders it back to the window after applying some effects.\n\nplease have a look at this picture:\n\nTake notepad as the example ,so as per the above picture i want to capture the red rectangular area (the window RECT area) and renders it back to a window. and when the window is moved from one position to another the capturing source RECT should also move along with the window (exactly like the windows magnifier window).\n\nI have already referred to DXGI desktop duplication sample and it looks very complicated.\n\nNote: I will use WDA_EXCLUDEFROMCAPTURE to remove the window from the capturing RECT so that I will be able to get the visual behind the window"
    },
    {
        "link": "https://github.com/diederickh/screen_capture/blob/master/src/test/test_win_api_directx_research.cpp",
        "document": ""
    }
]