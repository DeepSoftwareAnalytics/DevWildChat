[
    {
        "link": "https://stackoverflow.com/questions/48464979/navigating-a-grid",
        "document": "There is also a mathematical solution (which is probably what you used):\n\nThis works because the number of paths is the same as the number of ways to choose to go right or down over steps, where you go right w times, which is equal to , or .\n\nWith missing grid squares, I think there is a combinatoric solution, but it's very slow if there are many missing squares, so dynamic programming would probably be better there.\n\nFor example, the following should work:"
    },
    {
        "link": "https://reddit.com/r/algorithms/comments/1qeyub/how_to_make_a_random_nonintersecting_walk_of",
        "document": "Back in college I had to make a clone of the game \"Oregon Trail\". In the process of making said game, I ran into an algorithms question that I still haven't come up with a good solution for. In the game, when drawing the map, I wanted to be able to draw a random path with length L connecting two points on the map. (Without self-intersections, as that would make the path longer than it needed to be to get from A to B) (Assuming L >= the geometric distance between A and B)\n\nHere's a rough sketch of a final idea I had (It doesn't work) (I had a semi-working algorithm that meets my goal, but it's extremely inelegant and has self-intersections)\n\nDoes anyone have any better ideas to solving this problem? I'd love to see a pretty solution to the problem."
    },
    {
        "link": "https://geeksforgeeks.org/tutorial-on-path-problems-in-a-grid-maze-or-matrix",
        "document": "Path in a Grid or Maze refers to problems that involve navigating through a grid-like structure from the source (starting point) to the destination (endpoint) while avoiding the obstacles i.e., following rules and constraints.\n\nA grid or a maze is generally represented as a 2D array or matrix consisting of rows and columns. Each cell is a intersection of a particular row and column and it represents a location in the grid. The cells in the grid may be open for traversal or may be blocked by an obstacle. If a cell is blocked by an obstacle that cell cannot be visited.\n• None The most standard problem involves finding path from a given starting point to a given ending point in the grid. This often involves finding a sequence of connected cells that lead from the start to the end. \n\nExample:- Given a N*N grid, each cell of a grid is either a '.' representing a empty space or a '#' representing a obstacle. The task is to determine any valid path from source (1,1) to destination (N,N) without visiting any obstacle.\n• None In some of the problems we have find the total number of unique paths from the starting point to the ending point under some rules and constraints. \n\nExample:- Given a N*N grid, the task is to find all possible paths that the rat can take to reach from source to destination. The directions in which the you can move are 'U'(up), 'D'(down), 'L' (left), 'R' (right). Value 0 at a cell in the matrix represents that it is blocked and one cannot move to it while value 1 at a cell in the matrix represents that one can be travel through it.\n• None In some of the problems, the task will be to find the shortest path from the source to the destination. The shortest path is the minimum number of steps to reach destination. \n\nExample:- In this problem a MxN matrix is given where each cell can either be 0 or 1. We need to find the shortest path between a given source cell to a destination cell. The path can only be created out of a cell if its value is 1.\n\nPathfinding problems often require the use of various algorithms like:-\n• : DFS is generally used to traverse the maze and to explore various paths. This algorithm is basically used in all of the grid/maze problems because in every problem we have to traverse the grid.\n• None Backtracking in Maze Problems is used when exploring all possible paths from source to destination is needed. \n\nExample:- A rat is placed at (0, 0) m[ ][ ] n and has to reach the destination at (n-1, n-1) . The task is to find a sorted array of strings denoting all the possible directions which the rat can take to reach the destination at (n-1, n-1) . The directions in which the rat can move are ‘U'(up), ‘D'(down), ‘L’ (left), ‘R’ (right).\n• None Dynamic Programming is used when we need to avoid redundant calculations in Maze Problems. It is generally used when we have to find the number of paths from source to destination under some constraints. \n\nExample:- Given a grid with each cell consisting of positive, negative or no points i.e, zero points. We can move across a cell only if we have positive points ( > 0 ). Whenever we pass through a cell, points in that cell are added to our overall points. We need to find minimum initial points to reach cell (m-1, n-1) from (0, 0).\n• None BFS is used when we need to find the shortest path from source to destination. \n\nExample:- Given a n*m grid. You are at point (0, 0) (n-1, m-1) . If any cell contains 0 , it is a free cell, if it contains 1 , there is an obstacle and you can’t pass through the cell, and if it contains 2, that means it is free and if you step into this cell, you can pass through any adjacent cell of it that contains obstacles. In one step you can go one unit in any four directions (Inside the grid), the task is to find the minimum number of steps to reach the destination if it is impossible return -1.\n\nGiven below are the most common Grid/Maze problems:"
    },
    {
        "link": "https://stackoverflow.com/questions/44013359/finding-all-possible-walks-without-repetition-in-an-nm-grid",
        "document": "I added some tracing instrumentation. Output starting from (0,0) is below that. The print statements are indented according to level, and I just print out the current location in a few useful spots.\n\nIn the output (I printed only the first 1/4), note how you cover only one linear path from the (0,0) starting point: you step to (0,1), then (1,0), and finally (1,1). However, when you return from each of those steps, you fail to cover any other options, such as moving (0,0) => (0,1) => (1,1) and from there to (1,0).\n\nThe fatal flaw is that you don't manage your status lists when you backtrack. In the case shown below, when you backtrack even to (0,0), you still have the entire grid marked as walked. Instead, try either reset code: just before you return from the routine,\n\n... or make a local copy of , rather than dealing with a what is essentially a global master list.\n\nI'll leave the handling of up to you, now that you have the hint."
    },
    {
        "link": "https://reddit.com/r/algorithms/comments/1dqlhce/im_looking_for_a_grid_navigation_algorithm",
        "document": "Hello everyone, this is my first post.\n\nI'm looking for the name of an algorithm that matches the following behavior:\n\nI have an object moving freely on a grid (by freely, I mean the object can move in floating points, not just integers). The object is moving X distance towards a direction, let's say (x1.0, y0.5) (so up and to the right).\n\nIf the object \"hits\" a wall on the y-axis, it continues on the x-axis, and vice versa. If the object \"hits\" a wall on both the x and y axes, it stops.\n\nI believe that the algorithm should receive a starting point, direction, and grid2D, and return the final position.\n\nHere's a clearer illustration (I don't know how to upload an image with this post so link):\n\nhttps://ibb.co/9nLsVCZ\n\nDoes this algorithm have a name? PS: I only need the names of possible algorithms. :)"
    },
    {
        "link": "https://stackoverflow.com/questions/32121016/moving-items-in-2d-array-python",
        "document": "I made this might be what you are looking for, it is in JavaScript because I am not currently on my own computer but here it is:\n\nWhat it does is go column by column, from the top to bottom, and checks:\n• if there is a gap, and the cell under it isn't, it moves the cell up\n• else if two cells are the same number, they are added up if none of\n• if after one loop (from top to bottom), neither of the above conditions took place, it moves to the next column\n\nAlso, in case you would like to apply this for the three other directions, I recommend rotating the table instead of doing 3 more of the above function. If you have trouble transcribing it to Python, I'll be able to help you later this evening.\n\nHere you go, the same thing, but in Python:\n\nOh, and the original 2048 does not allow a tile to merge twice during the same turn, so you might want to tweak the elif to fit that, since it merges them until it cannot anymore."
    },
    {
        "link": "https://stackoverflow.com/questions/47525815/python-move-elements-in-a-2-dimensional-array",
        "document": "How can I code something in Python that shifts once to the end each time it's called? However, it has to stop if it reaches a positive value.\n\nSo I get something like this\n\nThis is what I have. It works for condition 1 but it does not work for condition 2. What can I tweak so condition 2 also works?\n\nThis is what I am getting currently. I want to get the expected for Condition 2 listed in the code snipped above.:\n\nUpdate @Furas: Something like this to find the positive value location?"
    },
    {
        "link": "https://geeksforgeeks.org/python-using-2d-arrays-lists-the-right-way",
        "document": "Python | Using 2D arrays/lists the right way\n\nPython provides powerful data structures called lists, which can store and manipulate collections of elements. Also provides many ways to create 2-dimensional lists/arrays. However one must know the differences between these ways because they can create complications in code that can be very difficult to trace out. In this article, we will explore the right way to use 2D arrays/lists in Python.\n\nUsing 2D arrays/lists the right way\n\nUsing 2D arrays/lists the right way involves understanding the structure, accessing elements, and efficiently manipulating data in a two-dimensional grid. When working with structured data or grids, 2D arrays or lists can be useful. A 2D array is essentially a list of lists, which represents a table-like structure with rows and columns.\n\nIn Python, Initializing a collection of elements in a linear sequence requires creating a 1D array, which is a fundamental process. Although Python does not have a built-in data structure called a ‘1D array’, we can use a list that can achieve the same functionality. Python lists are dynamic and versatile, making them an excellent choice for representing 1D arrays. Let’s start by looking at common ways of creating a 1d array of size N initialized with 0s.\n\nManually initializing and populating a list without using any advanced features or constructs in Python is known as creating a 1D list using “Naive Methods”.\n\nHere we are multiplying the number of rows by the empty list and hence the entire list is created with every element zero.\n\nUsing 2D arrays/lists the right way involves understanding the structure, accessing elements, and efficiently manipulating data in a two-dimensional grid. By mastering the use of 2D arrays, you can significantly improve your ability to handle complex data and efficiently perform various operations.\n\nHere we are multiplying the number of columns and hence we are getting the 1-D list of size equal to the number of columns and then multiplying it with the number of rows which results in the creation of a 2-D list.\n\nNote: Using this method can sometimes cause unexpected behaviors. In this method, each row will be referencing the same column. This means, even if we update only one element of the array, it will update the same column in our array.\n\nHere we are basically using the concept of list comprehension and applying a loop for a list inside a list and hence creating a 2-D list.\n\nHere we are appending zeros as elements for a number of columns times and then appending this 1-D list into the empty row list and hence creating the 2-D list.\n\nThe provided code demonstrates two different approaches to initializing a 2D array in Python. First, the array is initialized using a 2D list comprehension, where each row is created as . The entire array is created as a list of references to the same inner list, resulting in aliasing. Any change made to an element in one row will be reflected in all rows. The code then shows another approach using a nested list comprehension to create the 2D array . This method avoids aliasing by creating a new list for each row, resulting in a proper 2D array.\n\nWe expect only the first element of the first row to change to 1 but the first element of every row gets changed to 1 in method 2a. This peculiar functioning is because Python uses shallow lists which we will try to understand.\n\nIn method 1a, Python doesn’t create 5 integer objects but creates only one integer object, and all the indices of the array arr point to the same int object as shown.\n\n\n\nIf we assign the 0th index to another integer say 1, then a new integer object is created with the value of 1 and then the 0th index now points to this new int object as shown below\n\nSimilarly, when we create a 2d array as “arr = [[0]*cols]*rows” we are essentially extending the above analogy.\n• None Only one integer object is created.\n• None A single 1d list is created and all its indices point to the same int object in point 1.\n• None Now, arr[0], arr[1], arr[2] …. arr[n-1] all point to the same list object above in point 2.\n\nThe above setup can be visualized in the image below.\n\nNow lets change the first element in first row of “arr” as arr[0][0] = 1\n• None arr[0] points to the single list object we created we above.(Remember arr[1], arr[2] …arr[n-1] all point to the same list object too).\n• None The assignment of arr[0][0] will create a new int object with the value 1 and arr[0][0] will now point to this new int object.(and so will arr[1][0], arr[2][0] … arr[n-1][0])\n\nThis can be clearly seen in the below image.\n\n\n\nSo when 2d arrays are created like this, changing values at a certain row will affect all the rows since there is essentially only one integer object and only one list object being referenced by the all the rows of the array.\n\nAs you would expect, tracing out errors caused by such usage of shallow lists is difficult. Hence the better way to declare a 2d array is\n\nThis method creates 5 separate list objects, unlike method 2a. One way to check this is by using the ‘is’ operator which checks if the two operands refer to the same object.\n\nPython | Using 2D arrays/lists the right way – FAQs\n\nHow to convert 2D array to list in Python?\n\nHow to store 2D array in Python list?\n\nHow do you navigate a 2D list in Python?\n\nHow to get data from 2D array in Python?\n\nHow to read data from 2D array?\n\nHow to get value in 2D array?"
    },
    {
        "link": "https://geeksforgeeks.org/matrix-manipulation-python",
        "document": ""
    },
    {
        "link": "https://ioflood.com/blog/python-2d-array",
        "document": "Are you needing to use 2D arrays in Python, but don’t know where to start? Many developers find themselves puzzled when it comes to handling 2D arrays in Python, but we’re here to help.\n\nThink of Python’s 2D arrays as a multi-storey building – allowing us to store data in multiple dimensions, providing a versatile and handy tool for various tasks.\n\nIn this guide, we’ll walk you through the process of working with 2D arrays in Python, from their creation, manipulation, and usage. We’ll cover everything from the basics of multi-dimensional arrays to more advanced techniques, as well as alternative approaches.\n\nTL;DR: How Do I Create a 2D Array in Python?\n\nIn this example, we’ve created a 2D array (or a matrix) with three rows and three columns. Each inner list , , and represents a row in the 2D array. When we print the array, we get the output as a nested list, which is the Pythonic way of representing a 2D array.\n\nIn Python, a 2D array is essentially a list of lists. The outer list represents the rows, and each inner list represents a row of elements, similar to how a row works in a matrix. Let’s dive into the basics of creating, accessing, modifying, and iterating over a 2D array in Python.\n\nFirst, let’s create a 2D array. As mentioned in the TL;DR section, we can create a 2D array by nesting lists within a list. Here’s an example:\n\nIn this example, we’ve created a 2D array with three rows and three columns. Each inner list represents a row in the 2D array.\n\nTo access elements in a 2D array, you need two indices – one for the row and one for the column. The first index refers to the row number and the second index refers to the column number.\n\nLet’s access the element in the second row, third column (remember, Python indexing starts at 0):\n\nModifying elements in a 2D array is similar to accessing elements. You specify the row and column indices of the element you want to modify. Let’s change the value in the first row, first column to 10:\n\nTo iterate over a 2D array, you can use a nested for loop. The outer loop iterates over the rows, and the inner loop iterates over each row’s elements. Here’s an example:\n\nIn this example, we printed each element in the 2D array, with each row’s elements separated by a space and each row separated by a new line.\n\nOnce you’ve grasped the basics of 2D arrays in Python, you can start exploring more complex uses. This section dives into multi-dimensional arrays and nested list comprehensions.\n\nPython allows you to create arrays with more than two dimensions. These are called multi-dimensional arrays. They are created and used similarly to 2D arrays but with an extra level of nesting for each additional dimension. Let’s create a 3D array:\n\nIn this example, we have a 3D array with two 2D arrays, each containing two rows of three elements. To access an element, we need three indices – one for the 2D array, one for the row, and one for the column.\n\nPython’s list comprehensions provide a concise way to create lists. You can also use them to create 2D arrays. Here’s an example of creating a 2D array using a nested list comprehension:\n\nIn this example, we’ve created a 2D array where each element is the product of its row and column indices (starting from 1). The outer list comprehension ( ) creates the rows, and the inner list comprehension ( ) creates the elements within each row.\n\nPython’s built-in list structure is versatile and powerful, but when it comes to numerical computations and handling large 2D arrays, there’s a more efficient alternative – the numpy library.\n\nNumpy is a Python library used for numerical computations and has a built-in 2D array object that offers more functionalities than the native Python 2D array. Let’s create a 2D array using numpy:\n\nAccessing and modifying elements in a numpy 2D array is similar to Python’s native 2D array. However, numpy provides more advanced features like element-wise operations, mathematical functions, and more.\n\nWhile numpy 2D arrays offer more functionalities and are more efficient for large-scale computations, they come with their own limitations. Numpy arrays are homogeneous, which means all elements must be of the same type. If you need to store different types of data, Python’s native 2D array (list of lists) would be more suitable.\n\nIf you’re working with numerical data, especially large data sets, numpy is a great choice due to its efficiency and additional functionalities. However, for general use and when working with mixed data types, Python’s native 2D arrays would be more suitable.\n\nWhile working with 2D arrays in Python, you might encounter a few common issues. This section will discuss these problems and how to overcome them.\n\nOne common issue is the ‘IndexError: list index out of range’ error. This occurs when you try to access an element at an index that doesn’t exist in the array. For example:\n\nIn this example, we tried to access the element in the fourth row, first column. However, our array only has three rows, so we get an ‘IndexError’.\n\nTo avoid this error, always ensure that the indices you’re using to access elements are within the range of the array’s dimensions.\n\nAnother common issue is trying to modify an element in an array of immutable elements, like strings. Python’s strings are immutable, so if you try to change a character in a string within a 2D array, you’ll get a ‘TypeError’.\n\nTo overcome this issue, you can create a new string with the desired changes and replace the old string in the array.\n\nWhen working with large 2D arrays, memory can become a concern. Python’s native 2D arrays (list of lists) can consume a lot of memory due to their flexible nature. If you’re working with large 2D arrays, you might want to consider using numpy 2D arrays, which are more memory-efficient.\n\nBefore we delve deeper into the intricacies of 2D arrays in Python, it’s essential to understand the fundamental concept of arrays and their implementation in Python.\n\nAn array is a data structure that stores a fixed-size sequence of elements of the same type. It’s like a container that holds a specific number of items, and all items are of the same type. This structure is beneficial when you want to store multiple items of the same type, like a list of integers or a list of strings.\n\nIn Python, arrays can be created using the ‘array’ module, but more often than not, lists are used instead due to their flexibility and functionality. In fact, Python’s ‘array’ module arrays are quite limited compared to lists, and are only used when you need to perform some operation that requires a specific functionality provided by these arrays.\n\nIn Python, arrays are implemented as lists. A list in Python is an ordered collection of items, and these items can be of any type. This is different from the traditional concept of arrays, where all elements must be of the same type.\n\nHere’s an example of a Python list:\n\nAs you can see, Python lists (or arrays) are very flexible. They can store items of different types, and they can be resized dynamically (items can be added or removed).\n\nIn the broader context of Python’s data structures, arrays (or lists) are just one of many. Python also provides other data structures like tuples, sets, and dictionaries, each with its own advantages and use cases.\n\nHowever, when it comes to storing and manipulating a collection of related items, arrays are one of the most commonly used data structures due to their flexibility and the wide range of operations they support.\n\nExpanding Your Knowledge: 2D Arrays and Beyond\n\nUnderstanding 2D arrays is just the beginning. They are the stepping stones to more complex data structures and techniques. The concept of 2D arrays is not limited to small scripts but is widely used in larger projects, data analysis, machine learning, and more. Let’s explore some of these related concepts.\n\nOnce you’re comfortable with 2D arrays, you might want to explore 3D arrays. These are arrays of 2D arrays, adding an extra level of complexity and usefulness. They are particularly useful in fields like physics and computer graphics.\n\nMatrices, which are a mathematical concept, can be represented as 2D arrays in Python. You can perform various matrix operations using Python’s numpy library.\n\nPandas is a Python library used for data manipulation and analysis. It provides data structures and functions needed to manipulate structured data.\n\nIt includes two primary data structures, Series (1-dimensional) and DataFrame (2-dimensional), to handle a vast majority of typical use cases in finance, statistics, social science, and engineering.\n\nTo deepen your understanding of Python arrays and related concepts, here are some resources you might find useful:\n• Python Data Types Tutorial: Getting Started – Learn how Python handles integers, floats, and complex numbers for numerical processing.\n• None Simplifying Variable Usage in Python – Learn how to declare and manipulate variables in Python for effective programming.\n• None Set Modification in Python Explained – Master the art of modifying sets in Python to perform set operations effectively.\n• None Python’s official documentation provides a comprehensive overview of data structures, including lists (or arrays).\n• None Numpy’s official documentation is a great resource for understanding numpy arrays and the operations you can perform on them.\n• None Pandas’ official documentation is a must-read if you’re interested in data analysis or data manipulation in Python.\n\nIn this comprehensive guide, we’ve delved into the world of Python 2D arrays, exploring their creation, manipulation, and usage. From basic operations to advanced techniques, we’ve covered a wide range of topics to give you a solid understanding of 2D arrays in Python.\n\nWe began with the basics, learning how to create a 2D array, access and modify its elements, and iterate over it. We then ventured into more advanced territory, exploring multi-dimensional arrays and nested list comprehensions.\n\nAlong the way, we tackled common issues you might encounter when working with 2D arrays in Python, such as out of range errors and memory considerations, providing you with solutions and workarounds for each issue.\n\nWe also looked at alternative approaches to handling 2D arrays, introducing the numpy library and its advantages and disadvantages. Here’s a quick comparison of these methods:\n\nWhether you’re a beginner just starting out with Python 2D arrays or an experienced developer looking to level up your skills, we hope this guide has given you a deeper understanding of 2D arrays in Python and their capabilities. Happy coding!"
    }
]