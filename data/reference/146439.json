[
    {
        "link": "https://docs.oracle.com/javase/tutorial/uiswing/index.html",
        "document": "The Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nAlso known as The Swing Tutorial\n\nThis trail tells you how to create graphical user interfaces (GUIs) for applications and applets, using the Swing components. If you would like to incorporate JavaFX into your Swing application, please see Integrating JavaFX into Swing Applications.\n\nGetting Started with Swing is a quick start lesson. First it gives you a bit of background about Swing. Then it tells you how to compile and run programs that use Swing components.\n\nLearning Swing with the NetBeans IDE is the fastest and easiest way to begin working with Swing. This lesson explores the NetBeans IDE's GUI builder, a powerful feature that lets you visually construct your Graphical User Interfaces.\n\nUsing Swing Components tells you how to use each of the Swing components  buttons, tables, text components, and all the rest. It also tells you how to use borders and icons.\n\nConcurrency in Swing discusses concurrency as it applies to Swing programming. Information on the event dispatch thread and the SwingWorker class are included.\n\nUsing Other Swing Features tells you how to use actions, timers, and the system tray; how to integrate with the desktop class, how to support assistive technologies, how to print tables and text, how to create a splash screen, and how to use modality in dialogs.\n\nLaying Out Components Within a Container tells you how to choose a layout manager, how to use each of the layout manager classes the Java platform provides, how to use absolute positioning instead of a layout manager, and how to create your own layout manager.\n\nModifying the Look and Feel tells you how to specify the look and feel of Swing components.\n\nDrag and Drop and Data Transfer tells you what you need to know to implement data transfer in your application.\n\nWriting Event Listeners tells you how to handle events in your programs.\n\nPerforming Custom Painting gives you information on painting your own Swing components. It discusses painting issues specific to Swing components, provides an overview of painting concepts, and has examples of custom components that paint themselves.\n\nAlthough this is the main trail for learning about GUIs, it isn't the only trail with UI-related information.\n• 2D Graphics, which describes the 2D graphics features available in the JDK.\n• Sound, which discusses the sound capabilities available in the JDK.\n• Java Applets, which describes API available only to applets.\n• Essential Java Classes, which covers many topics, including properties and the standard I/O streams.\n• The JavaFX Documentation, which describes how to build UIs with JavaFX.\n• The Bonus trail contains Full-Screen Exclusive Mode API, a lesson that describes how to use API introduced in v1.4 to render graphics directly to the screen."
    },
    {
        "link": "https://github.com/anmarjarjees/java-ui-swing",
        "document": "Welcome to the VS Code Java world. Here is a guideline to help you get started to write Java code in Visual Studio Code.\n\nThe workspace contains two folders by default, where:\n\nMeanwhile, the compiled output files will be generated in the folder by default.\n\nThe view allows you to manage your dependencies. More details can be found here.\n\nThe Java Client consists of Java Deployment (Applets and Web Start) and Java UI (Swing, AWT and JavaFX) technologies.\n\nWe can develop GUI Applications in Java using:\n\nFor VS Code user, you can check this article \"Working with GUI applications in VS Code\".\n\nYou can check this article about \"Java Client Roadmap Update\"\n\nTo create Swing Application, we can use and IDE that provides WYSIWYG (What You See Is What You Get) editor to make it easy and faster to arrange the components on the window/frame/panel, or writing or Swing code from scratch.\n\nSome IDEs comes with WYSIWYG like NetBeans. Without WYSIWYG, we need to use layout our component then adding all the even handling manually.\n\nMost of the Swing GUI components are inherited from \"JComponent\" and the hierarchy for \"JComponent\" class: \"JComponent\" class = extends => \"Container\" class = extends => \"Component\" class = extends => \"Object\" class\n\nThe base class for all Swing components except top-level containers. To use a component that inherits from JComponent, you must place the component in a containment hierarchy whose root is a top-level Swing container. Top-level Swing containers -- such as JFrame, JDialog, and JApplet -- are specialized components that provide a place for other Swing components to paint themselves.\n\nYou can read more about \"javax.swing - Class JComponent\"\n\nSwing has a list of top level container that are used to contain the GUI components including JFrame (the one that we will use), JWindow, JDialog, JApplet. All the above containers rely on the \"JRootPane\". JRootPane manges all Swing containers so it's acting as a container delegate for the top level Swing containers.\n\nThese Top-Level containers like our main one \"JFrame\" has a content pane, like \"Panel\". Panel is used to contain the visual components of GUI.\n\nExample: 1- JFrame => the top-level container (Represent the GUI window) 2- To add item(s) to the GUI window, we need to add another frame \"JPanel\" 3- Adding JPanel to the JFrame 4- Adding JComponents (text fields, buttons, list,...) to the JPanel\n• We can change the order in coding like adding JComponents to the JPanel, then adding JPanel to the JFrame. Or, adding JPanel to the JFrame then adding JComponents to the JFrame, is the same.\n• We cannot add JComponents directly to JFrame as the last components will replace all the previous ones, you can see the issue in my code example \"Main1.java\". So the JComponents have to be added to the \"JPanel\".\n• After instantiating our frame, we can add one or more panels that contain(s) the GUI components\n• Frame can be instantiated with or without a title. The JFrame has two instructors:\n• A constructor that accept a string to represent the Window/Frame title. Notice that title can be added later also using .setTitle() method for the JFrame object.\n• Panel(s), JPanel can be added to the JFrame. Swing Application can have multiple JPanels objects inside the JFrame, but only one JFrame object/instance.\n• All our graphical components are being added to the \"JPanel\"\n• JPanel has a default layout called \"FlowLayout\", the components are being added from left to write and wrap to the next line when they run out room. Think about the \"FlowLayout\" is like floating all the HTML element to the left inside their container element.\n\nRepresents the window itself. all the components of the user interface will be inside this window\n• All components inherit from the JComponent class\n\nCheck this interesting page \"A Visual Guide to Swing Components\" from Massachusetts Institute of Technology.\n• Layout Managers are classes that control the size and location of each item of the components inside the container.\n• The default layout is called \"FlowLayout\" which adds elements from left to right (as discussed above)\n\nSwing provides many different layout managers\n• BorderLayout: Divides the window into five areas: North, South, East, West and Center (the content pane default)\n• BoxLayout: Places/Stacks components in a single row (besides each other) or column (top or each other)\n• CardLayout: Places and manages different/multiple components in a specified area or that share the same display area at different times\n• FlowLayout: Places left to right in a wrapping line/row (the jPanel default)\n• GridBagLayout: Displays components in a grid of cells or in rows and columns; allows components to span cells (rows/columns) and varying sizes\n• GridLayout: Places components in a grid of rows and columns or in equally sized rows and columns\n• SpringLayout: Places by relative spacing which is a flexible layout tht emulates all other layouts\n\nOne of the oldest GUI frameworks in Java. AWT is an API for creating GUI applications in Java. first AWT in Wikipedia\n• Open the Class File you want to move\n• From the top panel select the package name\n\nYou can learn more about \"Moving in VS Code\"\n\nUsing Swing and AWT for Creating GUI with Java\n• p3user_interface_events (package): We will have at least two source code files\"\n• The main program that has the main() method\n• The class file that extends *JFrame class and contains the GUI components\n\nJFrame is the basic window class for a Swing GUI. JFrame can be used in two different ways:\n• Attaching GUI components directly to an object/instance of the class JFrame as we did in the previous package\n• Extending the JFrame class to create your new custom subclass of JFrame that contain the specific component that are needed for our application\n\nUser can interact with the GUI by performing actions with a mouse, keyboard, or other input device. These actions cause \"events\" and the program can respond to these events and it's known as \"Event-Handling\".\n\nTo make our program (Java class) able to recognize these events, it needs one or more \"EventListener\" interface to be added (implemented) by importing the \"java.awt.event\" package.\n\nJava documentation includes many \"EventListener\" Interfaces. The most common ones are listed below with brief description:\n• ActionListener => Action listeners are probably the easiest — and most common — event handlers to implement. You implement an action listener to define what should be done when an user performs certain operation.\n\nEach \"EventListener\" interface has one ore more associated event-handler method(s) that has/have to be implemented when an event is recognized. For example, the \"ActionListener\" interface has one associated method named \"actionPerformed()\" and passes an \"ActionEvent\" object as its argument.\n\nYou can check this article about \"Java Event Listeners and How They Work\".\n\nAn action event occurs, whenever an action is performed by the user. Examples: When the user clicks a button, chooses a menu item, presses Enter in a text field. The result is that an actionPerformed message is sent to all action listeners that are registered on the relevant component.\n\nFor example, to have respond to a button click, the \"ActionListener\" interface can be implemented by our custom class and the button's \"addActionListener()\" method must be called the passing the argument \"this\". This makes the button generate an event when it gets clicked.\n\nCode Example for creating a button that generates events:\n• Java How to Program, 11/e By by Paul Deitel and Harvey Deitel"
    },
    {
        "link": "https://stackoverflow.com/questions/77279626/creating-a-game-interface-with-java-swing-awt",
        "document": "I started coding a few weeks ago and I am currently trying to create a Java GUI for a game using Swing and AWT. I have created the code below.\n\nWith this code I create a panel with a background image and a play button at the top of the screen. However, what I would like to do is center the play button to the center of the image, and that it doesn't take the full screen size but just a fix size (perhaps 50x50 pixels). How can I do this?"
    },
    {
        "link": "https://www3.ntu.edu.sg/home/ehchua/programming/java/J4a_GUI.html",
        "document": "So far, we have covered the basic programming constructs (such as variables, data types, decision, loop, array and method) and introduced the important concept of Object-Oriented Programming (OOP). As discussed, OOP permits higher level of abstraction than traditional Procedural-Oriented Languages (such as C). You can create high-level abstract data types called classes to mimic real-life things. These classes are self-contained and are reusable.\n\nIn this article, I shall show you how you can reuse the graphics classes provided in JDK for constructing your own Graphical User Interface (GUI) applications. Writing your own graphics classes (and re-inventing the wheels) is mission impossible! These graphics classes, developed by expert programmers, are highly complex and involve many advanced design patterns. However, re-using them are not so difficult, if you follow the API documentation, samples and templates provided.\n\nI shall assume that you have a good grasp of OOP, including composition, inheritance, polymorphism, abstract class and interface; otherwise, read the earlier articles. I will describe another important OO concept called nested class (or inner class) in this article.\n\nThere are current three sets of Java APIs for graphics programming: AWT (Abstract Windowing Toolkit), Swing and JavaFX.\n• AWT API was introduced in JDK 1.0. Most of the AWT UI components have become obsolete and should be replaced by newer Swing UI components.\n• Swing API, a much more comprehensive set of graphics libraries that enhances the AWT, was introduced as part of Java Foundation Classes (JFC) after the release of JDK 1.1. JFC consists of Swing, Java2D, Accessibility, Internationalization, and Pluggable Look-and-Feel Support APIs. JFC has been integrated into core Java since JDK 1.2.\n• The latest JavaFX, which was integrated into JDK 8, was meant to replace Swing. JavaFX was moved out from the JDK in JDK 11, but still available as a separate module.\n\nOther than AWT/Swing/JavaFX graphics APIs provided in JDK, other organizations/vendors have also provided graphics APIs that work with Java, such as Eclipse's Standard Widget Toolkit (SWT) (used in Eclipse), Google Web Toolkit (GWT) (used in Android), 3D Graphics API such as Java bindings for OpenGL (JOGL), Java3D, and etc. Furthermore, developers have moved to use technologies such as HTML5 as the basis of webapps.\n\nYou need to refer to the \"JDK API documentation\" for the AWT/Swing APIs (under module ) while reading this chapter. The best online reference for Graphics programming is the \"Swing Tutorial\" @ http://docs.oracle.com/javase/tutorial/uiswing/. For advanced 2D graphics programming, read \"Java 2D Tutorial\" @ http://docs.oracle.com/javase/tutorial/2d/index.html. For 3D graphics, read my 3D articles.\n\nI shall start with the AWT before moving into Swing to give you a complete picture of Java Graphics.\n\nAWT is huge! It consists of 12 packages of 370 classes (Swing is even bigger, with 18 packages of 737 classes as of JDK 8). Fortunately, only 2 packages - and - are commonly-used.\n• The package contains the core AWT graphics classes:\n• GUI Component classes, such as , , and .\n• GUI Container classes, such as and .\n• Layout managers, such as , and .\n• Custom graphics classes, such as , and .\n• The package supports event handling:\n• Event classes, such as , , and ,\n• Event Listener Interfaces, such as , , , and ,\n• Event Listener Adapter classes, such as , , and .\n\nAWT provides a platform-independent and device-independent interface to develop graphic programs that runs on all platforms, including Windows, macOS, and Unixes.\n\nThere are two groups of GUI elements:\n• Component (Widget, Control): Components are elementary GUI entities, such as , , and . They are also called widgets, controls in other graphics systems.\n• Container: Containers, such as and , are used to hold components in a specific layout (such as or ). A container can also hold sub-containers.\n\nIn the above figure, there are three containers: a and two s. A is the top-level container of an AWT program. A has a title bar (containing an icon, a title, and the minimize/maximize/close buttons), an optional menu bar and the content display area. A is a rectangular area used to group related GUI components in a certain layout. In the above figure, the top-level contains two s. There are five components: a (providing description), a (for users to enter text), and three s (for user to trigger certain programmed actions).\n\nIn a GUI program, a component must be kept (or added) in a container. You need to identify a container to hold the components. Every container has a method called . A (say ) can invoke to add into itself. For example,\n\nGUI components are also called controls (e.g., Microsoft ActiveX Control), widgets (e.g., Eclipse's Standard Widget Toolkit, Google Web Toolkit), which allow users to interact with (or control) the application.\n\nEach GUI program has a top-level container. The commonly-used top-level containers in AWT are , and :\n• A provides the \"main window\" for your GUI application. It has a title bar (containing an icon, a title, the minimize, maximize/restore-down and close buttons), an optional menu bar, and the content display area. To write a GUI program, we typically start with a subclass extending from to inherit the main window as follows:\n• An AWT is a \"pop-up window\" used for interacting with the users. A has a title-bar (containing an icon, a title and a close button) and a content display area, as illustrated.\n• An AWT (in package ) is the top-level container for an applet, which is a Java program running inside a browser. Applet is no longer supported in most of the browsers.\n\nSecondary containers are placed inside a top-level container or another secondary container. AWT provides these secondary containers:\n• : a rectangular box used to layout a set of related GUI components in pattern such as grid or flow.\n\nThe hierarchy of the AWT classes is as follows:\n\nAs illustrated, a has a to layout the components in a certain pattern, e.g., flow, grid.\n\nAWT provides many ready-made and reusable GUI components in package . The frequently-used are: , , , , (radio buttons), , and , as illustrated below.\n\nA provides a descriptive text string. Take note that prints to the system console, NOT to the graphics screen. You could use a to label another component (such as text field) to provide a text description.\n\nThe class has three constructors:\n• The first constructor constructs a object with the given text string in the given alignment. Note that three constants , , and are defined in the class for you to specify the alignment (rather than asking you to memorize arbitrary integer values).\n• The second constructor constructs a object with the given text string in default of left-aligned.\n• The third constructor constructs a object with an initially empty string. You could set the label text via the method later.\n\nThese three constants are defined for specifying the alignment of the 's text, as used in the above constructor.\n\nThe and methods can be used to read and modify the 's text. Similarly, the and methods can be used to retrieve and modify the alignment of the text.\n\nConstructing a Component and Adding the Component into a Container\n\nThree steps are necessary to create and place a GUI component:\n• Declare the component with an identifier (name);\n• Construct the component by invoking an appropriate constructor via the operator;\n• Identify the container (such as or ) designed to hold this component. The container can then add this component onto itself via method. Every container has a method. Take note that it is the container that actively and explicitly adds a component onto itself, NOT the other way.\n\nYou can create a without specifying an identifier, called anonymous instance. In the case, the Java compiler will assign an anonymous identifier for the allocated object. You will not be able to reference an anonymous instance in your program after it is created. This is usually alright for a instance as there is often no need to reference a after it is constructed.\n\nA is a GUI component that triggers a certain programmed action upon clicking.\n\nThe class has two constructors. The first constructor creates a object with the given label painted over the button. The second constructor creates a object with no label.\n\nThe and methods can be used to read the current label and modify the label of a button, respectively.\n\nNote: The latest Swing's replaces with to be consistent with all the components. We will describe Swing later.\n\nClicking a button fires a so-called and triggers a certain programmed action. I will explain event-handling later.\n\nA is single-line text box for users to enter texts. (There is a multiple-line text box called .) Hitting the \"ENTER\" key on a object fires an .\n\nHitting the \"ENTER\" key on a fires a , and triggers a certain programmed action.\n\nTake note that operates on . You can convert a to a primitive, such as or via method or . To convert a primitive to a , simply concatenate the primitive with an empty .\n\nLet's assemble a few components together into a simple GUI counter program, as illustrated. It has a top-level container , which contains three components - a \"Counter\", a non-editable to display the current count, and a \"Count\" . The shall display count of initially.\n\nEach time you click the button, the counter's value increases by 1.\n\nTo exit this program, you have to close the CMD-shell (or press \"control-c\" on the CMD console); or push the \"red\" close button in Eclipse's Application Console. This is because we have yet to write the handler for the 's close button. We shall do that in the later example.\n• The statements (Lines 1-2) are needed, as AWT container and component classes, such as , , , and are kept in the package; while AWT events and event-listener interfaces, such as and are kept in the package.\n• A GUI program needs a top-level container, and is often written as a subclass of (Line 5). In other words, this class is a , and inherits all the attributes and behaviors of a , such as the title bar and content pane.\n• Lines 11 to 47 define a constructor, which is used to setup the GUI components and event handlers.\n• In Line 13, the (inherited from the superclass ) is used to set the layout of the container. is used which arranges the components in left-to-right and flows into next row in a top-to-bottom manner.\n• A , (non-editable), and are constructed. We invoke the method (inherited from the superclass ) to add these components into container .\n• In Line 36-37, we invoke the and the (inherited from the superclass ) to set the initial size and the title of the . The method (Line 42) is then invoked to show the display.\n• Line 27 (or Line 29-30) is used to setup the callback event-handler, which will be discussed in length later. In brief, whenever the button is clicked, the will be called. In the (Lines 61-66), the counter value increases by 1 and displayed on the .\n• In the entry method (Lines 52-56), an instance of is constructed. The constructor is executed to initialize the GUI components and setup the event-handlers. The GUI program then waits for the user action.\n\nIt is interesting to inspect the GUI objects via the , to gain an insight to these classes. (Alternatively, use a graphic debugger in Eclipse/NetBeans or study the JDK source code.) For example, if we insert the following code before and after the :\n\nIn this example, the top-level container is again the typical . It contains 4 components: a \"Enter an Integer\", a for accepting user input, another \"The Accumulated Sum is\", and another non-editable for displaying the sum. The components are arranged in of 2 rows 2 columns.\n\nThe program shall accumulate the number entered into the input and display the sum in the output .\n• An AWT GUI program extends from (Line 6) - the top-level window container.\n• In the constructor (Line 14), we constructs 4 components - 2 anonymous s and 2 s. The adds the components, in .\n• ( ) is the source object, which fires an upon hitting the Enter key. adds an anonymous instance of as an handler (Line 23). The listener class needs to implement interface and provides implementation to method . Whenever an user hits Enter on the ( ), the will be called back.\n\nJava adopts the so-called \"Event-Driven\" (or \"Event-Delegation\") programming model for event-handling, similar to most of the visual programming languages like Visual Basic.\n\nIn event-driven programming, a piece of event-handling codes is executed (or called back by the graphics subsystem) when an event was fired in response to an user input (such as clicking a mouse button or hitting the ENTER key in a text field).\n\nIn the above examples, the method is known as a callback method. In other words, you never invoke in your codes explicitly. The is called back by the graphics subsystem under certain circumstances in response to certain user actions.\n\nJavaScript can attach a Callback method to an Event Directly\n\nIn some languages, you can directly attach a method (or function) to an event (such as mouse-click). For example, the following JavaScript code (called ) implement a counter similar to the , with a text label, text field and button:\n\nIn Java, we CANNOT attach a method to a source object directly, as method is not a first-class object in Java. For example, a Java method cannot accept methods as its arguments and it cannot return a method; you cannot assign a method to a variable, etc. (JavaScript and C language CAN!).\n\nThe AWT's event-handling classes are kept in package .\n\nThree kinds of objects are involved in the event-handling: a source, listener(s) and an event object.\n\nThe source object (such as and ) interacts with the user. Upon triggered, the source object creates an event object to capture the action (e.g., mouse-click x and y, texts entered, etc). This event object will be messaged to all the registered listener object(s), and an appropriate event-handler method of the listener(s) is called-back to provide the response. In other words, triggering a source fires an event to all its listener(s), and invoke an appropriate event handler of the listener(s).\n\nTo express interest for a certain source's event, the listener(s) must be registered with the source. In other words, the listener(s) \"subscribes\" to a source's event, and the source \"publishes\" the event to all its subscribers upon activation. This is known as subscribe-publish or observable-observer design pattern.\n\nThe sequence of steps is illustrated above:\n• The source object registers its listener(s) for a certain type of event. A source fires an event when triggered. For example, clicking a fires an , clicking a mouse button fires , typing a key fires , and etc. How the source and listener understand each other? The answer is via an agreed-upon interface. For example, if a source is capable of firing an event called (e.g., ). Firstly, we need to declare an interface called (e.g., ) containing the names of the handler methods (recall that an contains only methods without implementation). For example, the interface is declared as follows: Secondly, all listeners must implement the interface. That is, the listeners must provide their own implementations (i.e., programmed responses) to all the methods declared in the interface. In this way, the listener(s) can response to these events appropriately. For example, Thirdly, in the source, we need to maintain a list of listener object(s), and define two methods: and to add and remove a listener from this list. For the , the signature of the methods are: Take note that the takes a object as its sole parameter. In other words, it can only add objects of the type , and its sub-type. Since is an , you cannot create instance of , but need to create instance of a subclass implementing the . In summary, we identify the source, the event-listener interface, and the listener object. The listener must implement the event-listener interface. The source object then registers listener object via the method.\n• The source is triggered by a user.\n• The source create a object, which encapsulates the necessary information about the activation. For example, the position of the mouse pointer, the text entered, etc.\n• Finally, for each of the listeners in the listener list, the source invokes the appropriate handler on the listener(s), which provides the programmed response.\n\nIn summary, triggering a source fires an event to all its registered listeners, and invoke an appropriate handler of the listener.\n\nClicking a (or hitting the \"Enter\" key on a ) fires an to all its listener(s). An listener must implement the interface, which declares one method called as follow:\n\nHere are the event-handling steps:\n• We identify (of ) as the source object.\n• Clicking fires an to all its listener(s).\n• The listener(s) is required to implement interface, and override the method to provide the response. In Line 56-65, we write an inner class called , which override the to increment and display the count. An inner class is a class defined inside an outer class, and it can access the private entities of the outer class. We will elaborate on the inner class in the next section.\n• The source object registers listener via the . In this example, the source ( ) adds an instance of as a listener via: Note that takes an argument of the type . , which implements interface (i.e., a subclass of ), is upcasted and passed to the method.\n• Upon button-click, the creates an object, and calls back the method of all its registered listener(s) with the object created:\n\nThe sequence diagram is as follows:\n\nIn this example,\n• We identify the (of ) as the source object.\n• Hitting the \"Enter\" key on a fires an to all its listener(s).\n• In Line 46-59, we define an inner class called as the listener.The listener is required to implement the interface, and override the method to provide the programmed response upon activation.\n• The source object (of ) registers an anonymous instance of as its listener via the (Line 23).\n\nA is fired (to all its listeners) when a window (e.g., ) has been opened/closed, activated/deactivated, iconified/deiconified via the 3 buttons at the top-right corner or other means. The source of shall be a top-level window-container such as .\n\nA listener must implement interface, which declares 7 event-handling methods, as follows. Among them, the , which is called back upon clicking the window-close button, is the most commonly-used.\n\nThe following program added support for \"close-window button\" to \"Example 1: AWTCounter\".\n\nIn this example, we shall modify the earlier example to handle the . Recall that pushing the \"close-window\" button on the has no effect, as it did not handle the of . We included the handling codes in this example.\n• We identify the as the source object.\n• The fires the to all its registered listener(s).\n• In Line 53-69, we define an inner class called as the listener. It is required to implement the interface, which declares 7 abstract methods: , , , , , and .\n• We register an anonymous instance of as the listener to the source via method .\n• We override the handler to terminate the program using . We ignore the other 6 handlers, but required to provide an empty body for compilation.\n\nThe sequence diagram is as follow:\n\nA is fired when you press, release, or click (press followed by release) a mouse-button (left or right button) at the source object; or position the mouse-pointer at (enter) and away (exit) from the source object.\n\nA listener must implement the interface, which declares the following five methods:\n\nIn this example, we setup a GUI with 4 components (two anonymous s and two non-editable s) inside a top-level container , arranged in .\n• We identity as the source object.\n• The fires a to all its listener(s) when you click/press/release a mouse-button or enter/exit with the mouse-pointer.\n• In Line 42-56, we define an inner class called as the listener. It is required to implement the interface, which declares 5 abstract methods: , , , , and . We override the to display the (x, y) coordinates of the mouse click on the two displayed s. We ignore all the other handlers (for simplicity - but you need to provide an empty body for compilation).\n• We register an anonymous instance of as the listener to (source) via the method .\n\nTry: Include a to handle the close-window button.\n\nA is also fired when you move and drag the mouse pointer at the source object. But you need to use to handle the mouse-move and mouse-drag. The interface declares the following two abstract methods:\n\nIn this example, we shall illustrate both the and .\n• We identify the as the source, which fires the to its registered and .\n• In Line 53-80, we define an inner class called as both the and .\n• We register an instance of as the listener to via method and .\n• The needs to implement 2 abstract methods: and declared in the interface.\n• We override the to display the (x, y) position of the mouse pointer. We ignore the handler by providing an empty body for compilation.\n\nTry: Include a to handle the close-window button.\n\nA is fired when you pressed, released, and typed (pressed followed by released) a key on the source object. A listener must implement interface, which declares three abstract methods:\n\nIn this example:\n• We identify the (of ) as the source object.\n• The source fires a when you press/release/type a key to all its listener(s).\n• In Line 35-46, we define an inner class called as the listener.\n• We register an anonymous instance of as the listener to the source via method .\n• The listener needs to implement the interface, which declares 3 abstract methods: , , .\n• We override the to display key typed on the display . We ignore the and .\n\nIn our example, suppose we would like to write an external ordinary class (say ) as our listener. This class shall implement interface and override the method. An example is as follows:\n\nCan you see the problem? This external class cannot access the variables such as and in the class. We can fix this problem, but the solution is messy. An easy solution is to use an inner class instead of an ordinary external class (to be explained in the following sections).\n\nWhat are Inner classes?\n\nA nested class (or commonly called inner class) is a class defined inside another class - introduced in JDK 1.1. As an illustration, two nested classes and are defined inside the definition of an outer class called .\n• A nested class is a proper class. That is, it could contain constructors, member variables and member methods. You can create an instance of a nested class via the operator and constructor.\n• A nested class is a member of the outer class, just like any member variables and methods defined inside a class.\n• Most importantly, a nested class can access the members (variables/methods) of the enclosing outer class, as it is at the same level as these members. This is the property that makes inner class useful.\n• A nested class can have , , , or the default access, just like any member variables and methods defined inside a class. A inner class is only accessible by the enclosing outer class, and is not accessible by any other classes. [An top-level outer class cannot be declared , as no one can use a outer class.]\n• A nested class can also be declared , or , just like any ordinary class.\n• A nested class is NOT a subclass of the outer class. That is, the nested class does not inherit the variables and methods of the outer class. It is an ordinary self-contained class. [Nonetheless, you could declare it as a subclass of the outer class, via keyword \" \", in the nested class's definition.]\n\nThe usages of nested class are:\n• To control visibilities (of the member variables and methods) between inner/outer class. The nested class, being defined inside an outer class, can access members of the outer class.\n• To place a piece of class definition codes closer to where it is going to be used, to make the program clearer and easier to understand.\n\nExample 7: A Named Inner Class as Event Listener (Revisit Example 1 )\n\nA nested class is useful if you need a small class which relies on the enclosing outer class for its private variables and methods. It is ideal in an event-driven environment for implementing event handlers. This is because the event handling methods (in a listener) often require access to the private variables (e.g., a private ) of the outer class.\n\nIn this example (revisit Example 1 ), we define an inner class called , and create an instance of as the listener for the . The needs to implement the interface, and override the handler. needs to be defined as an inner class, as it needs to access private variables ( and ) of the outer class.\n• An inner class named is used as the .\n• An anonymous instance of the inner class is constructed. The source object adds this instance as a listener, as follows:\n• The inner class can access the variable and of the outer class.\n• The inner class is compiled into , in the format of .\n\n(Advanced) Using an Ordinary (Outer) Class as Listener\n\nTry moving the class outside, and define it as an ordinary class. You would need to pass a reference of the into the constructor of , and use this reference to access variables and , through getters or granting them to access.\n\nThis code is messy! Inner class provides a much cleaner solution!\n\nExample 8: An Anonymous Inner Class as Event Listener\n\nInstead of using a named inner class (called in the previous example), we shall use an inner class without a name, known as anonymous inner class as the in this example.\n• The anonymous inner class is given a name generated by the compiler, and compiled into , where is a running number of the inner classes of this outer class.\n• An anonymous instance of an anonymous inner class is constructed, and passed as the argument of the method as follows: The above codes is equivalent to and compiled as:\n• From JDK 8, you can write the event handler using \"Lambda Expression\" in a one-liner as follows:\n• The anonymous inner class is define inside a method, instead of a member of the outer class (class member). It is local to the method and cannot be marked with access modifier (such as , ) or , just like any local variable of a method.\n• An anonymous inner class must always extend a superclass or implement an interface. The keyword \" \" or \" \" is NOT required in its declaration. An anonymous inner class must implement all the abstract methods in the superclass or in the interface.\n• An anonymous inner class always uses the default (no-arg) constructor from its superclass to create an instance. If an anonymous inner class implements an interface, it uses the .\n• An anonymous inner class is compiled into a class named , where is a running number of inner classes within the outer class.\n• An instance of an anonymous inner class is constructed via this syntax: The created instance can be assigned to a variable or used as an argument of a method.\n\nExample 9: An Anonymous Inner Class for Each Source\n\nLet's modify our example to include 3 buttons for counting up, counting down, and reset the count, respectively. We shall attach an anonymous inner class as the listener to each of buttons.\n• Each of the s uses one anonymous instance of an anonymous inner class as its listener.\n\nExample 10: Using the Same Listener Instance for All the Buttons\n\nIf you use the same instance as the listener for all the 3 buttons, you need to determine which button has fired the event. It is because all the 3 buttons trigger the same event-handler method.\n\nIn the following example, we use the same instance of a \"named\" inner class as the listener for all the 3 buttons. The listener needs to determine which button has fired the event. This can be accomplished via the 's method, which returns the button's label.\n\nBesides the , which is only available for , you can use the method, which is available to all event objects, to retrieve a reference to the source object that has fired the event. returns a . You may need to downcast it to the proper type of the source object. For example,\n\nRefer to the , a listener is required to implement the interface, which declares 7 methods. Although we are only interested in , we need to provide an empty body to the other 6 methods in order to compile the program. This is tedious, e.g., we can rewrite the using an inner class implementing as follows:\n\nAn adapter class called is therefore provided, which implements the interface and provides default implementations to all the 7 methods. You can then derive a subclass from and override only methods of interest and leave the rest to their default implementation. For example,\n\nClearly, the adapter greatly simplifies the codes.\n\nSimilarly, adapter classes such as , , , are available for , , , and , respectively.\n\nThere is no for , because there is only one method (i.e. ) declared in the interface. This method has to be overridden and there is no need for an adapter.\n\nIf you read some old books, you may find many examples that use \" \" object as the event listener.\n\nThere is only ONE class in this code. But this code is much harder to understand and seldom used nowadays. Using inner class is a better solution.\n\nA container has a so-called layout manager to arrange its components. The layout managers provide a level of abstraction to map your user interface on all windowing systems, so that the layout can be platform-independent.\n\nAWT provides the following layout managers (in package ): , , , , , , and others. Swing added more layout manager in package , to be described later.\n\nA container has a method to set its layout manager:\n\nTo set up the layout of a (such as , , , or ), you have to:\n• Construct an instance of the chosen layout object, via and constructor, e.g., )\n• Invoke the method of the , with the layout object created as the argument;\n• Place the GUI components into the using the method in the correct order; or into the correct zones.\n\nYou can get the current layout via 's method.\n\n(and Swing's ) provides a constructor to set its initial layout manager. It is because a primary function of is to layout a group of component in a particular layout.\n\nIn the , components are arranged from left-to-right inside the container in the order that they are added (via method ). When one row is filled, a new row will be started. The actual appearance depends on the width of the display window.\n\nIn , components are arranged in a grid (matrix) of rows and columns inside the . Components are added in a left-to-right, top-to-bottom manner in the order they are added (via method ).\n\nIn , the container is divided into 5 zones: , , , , and . Components are added using method , where is either (or ), (or ), (or ), (or ), or .\n\nYou need not place components to all the 5 zones. The and components may be stretched horizontally; the and components may be stretched vertically; the component may stretch both horizontally and vertically to fill any space left over.\n\nUsing s as Sub-Container to Organize Components\n\nAn AWT is a rectangular pane, which can be used as sub-container to organized a group of related components in a specific layout (e.g., , ). s are secondary containers, which shall be added into a top-level container (such as ), or another .\n\nFor example, the following figure shows a in containing two - in and in . is added to the , and is added to the .\n\nReference: Read \"How to Use GridBagLayout\" @ https://docs.oracle.com/javase/tutorial/uiswing/layout/gridbag.html.\n\nRun the program, the output is in (a), where all components have their natural width and height, placed in center ( ) with extra x and y spaces at the 4 margins. The increases the internal y-padding for button-4 (spans 3 columns). Button 5 (spans second and third columns) has top margin specified by , and anchor at the bottom-right corner ( ).\n\nUncomment the (line 14). The output is in (b), where ALL components fill horizontally with equal column width.\n\nUncomment all (lines 20, 26, 32). The output is in (c). The extra x spaces are distributed according to the of (0.5, 1.0, 0.5).\n\nUncomment the (line 49). The output is in (d). The extra y spaces are given to row 3, as row 1 and 2 have of 0 and non-participating in the distribution of extra y-spaces.\n\nBoxLayout arrange components in a single row or column. It respects components' requests on the minimum sizes.\n\nSwing is part of the so-called \"Java Foundation Classes (JFC)\" (have you heard of MFC?), which was introduced in 1997 after the release of JDK 1.1. JFC was subsequently included as an integral part of JDK since JDK 1.2. JFC consists of:\n• Accessibility API: provides assistive technology for the disabled.\n\nThe goal of Java GUI programming is to allow the programmer to build GUI that looks good on ALL platforms. JDK 1.0's AWT was awkward and non-object-oriented (using many ). JDK 1.1's AWT introduced event-delegation (event-driven) model, much clearer and object-oriented. JDK 1.1 also introduced inner class and JavaBeans – a component programming model for visual programming environment (similar to Visual Basic).\n\nSwing appeared after JDK 1.1. It was introduced into JDK 1.1 as part of an add-on JFC (Java Foundation Classes). Swing is a rich set of easy-to-use, easy-to-understand JavaBean GUI components that can be dragged and dropped as \"GUI builders\" in visual programming environment. Swing is now an integral part of Java since JDK 1.2.\n\nSwing is huge (consists of 18 packages of 737 classes as in JDK 1.8) and has great depth. Compared with AWT, Swing provides a huge and comprehensive collection of reusable GUI components, as shown in the Figure below (extracted form Swing Tutorial).\n\nThe main features of Swing are (extracted from the Swing website):\n• Swing is written in pure Java (except a few classes) and therefore is 100% portable.\n• Swing components are lightweight. The AWT components are heavyweight (in terms of system resource utilization). Each AWT component has its own opaque native display, and always displays on top of the lightweight components. AWT components rely heavily on the underlying windowing subsystem of the native operating system. For example, an AWT button ties to an actual button in the underlying native windowing subsystem, and relies on the native windowing subsystem for their rendering and processing. Swing components ( s) are written in Java. They are generally not \"weight-down\" by complex GUI considerations imposed by the underlying windowing subsystem.\n• Swing components support pluggable look-and-feel. You can choose between Java look-and-feel and the look-and-feel of the underlying OS (e.g., Windows, UNIX or macOS). If the later is chosen, a Swing button runs on the Windows looks like a Windows' button and feels like a Window's button. Similarly, a Swing button runs on the UNIX looks like a UNIX's button and feels like a UNIX's button.\n• Swing supports mouse-less operation, i.e., it can operate entirely using keyboard.\n• Swing components are JavaBeans – a Component-based Model used in Visual Programming (like Visual Basic). You can drag-and-drop a Swing component into a \"design form\" using a \"GUI builder\" and double-click to attach an event handler.\n• Swing application uses AWT event-handling classes (in package ). Swing added some new classes in package , but they are not frequently used.\n• Swing application uses AWT's layout manager (such as and in package ). It added new layout managers, such as , , and (in package ).\n\nIf you understood the AWT programming (in particular, container/component and event-handling), switching over to Swing (or any other Graphics packages) is straight-forward.\n\nCompared with the AWT component classes (in package ), Swing component classes (in package ) begin with a prefix , e.g., , , , , , or .\n\nThe above figure shows the class hierarchy of the swing GUI classes. Similar to AWT, there are two groups of classes: containers and components. A container is used to hold components. A container can also hold containers because it is a (subclass of) component.\n\nAs a rule, do not mix heavyweight AWT components and lightweight Swing components in the same program, as the heavyweight components will always be painted on top of the lightweight components.\n\nJust like AWT application, a Swing application requires a top-level container. There are three top-level containers in Swing:\n• : used for the application's main window (with an icon, a title, minimize/maximize/close buttons, an optional menu-bar, and a content-pane), as illustrated.\n• : used for secondary pop-up window (with a title, a close button, and a content-pane).\n• : used for the applet's display-area (content-pane) inside a browser’s window.\n\nSimilarly to AWT, there are secondary containers (such as ) which can be used to group and layout relevant components.\n\nHowever, unlike AWT, the shall not be added onto the top-level container (e.g., , ) directly because they are lightweight components. The must be added onto the so-called content-pane of the top-level container. Content-pane is in fact a that can be used to group and layout components.\n• get the content-pane via from a top-level container, and add components onto it. For example,\n• set the content-pane to a (the main panel created in your application which holds all your GUI components) via 's .\n\nNotes: If a component is added directly into a , it is added into the content-pane of instead, i.e.,\n\nSwing uses the AWT event-handling classes (in package ). Swing introduces a few new event-handling classes (in package ) but they are not frequently used.\n\nIn summary, to write a Swing application, you have:\n• Use the Swing components with prefix in package , e.g., , , , , etc.\n• A top-level container (typically ) is needed. The should not be added directly onto the top-level container. They shall be added onto the content-pane of the top-level container. You can retrieve a reference to the content-pane by invoking method from the top-level container.\n• Run the constructor in the Event Dispatcher Thread (instead of Main thread) for thread safety, as shown in the following program template.\n\nI will explain this template in the following Swing example.\n\nLet's convert the earlier AWT application example into Swing. Compare the two source files and note the changes (which are highlighted). The display is shown below. Note the differences in look and feel between the AWT GUI components and Swing's.\n\nThe 's method returns the content-pane (which is a ) of the . You can then set its layout (the default layout is ), and add components into it. For example,\n\nYou can also use the 's method to directly set the content-pane to a (or a ). For example,\n\nInstead of writing a listener with a handler to process the \"close-window\" button, provides a method called to sets the default operation when the user initiates a \"close\" on this frame. Typically, we choose the option , which terminates the application via a .\n\nRunning the GUI Construction Codes on the Event-Dispatching Thread\n\nIn the previous examples, we invoke the constructor directly in the entry method to setup the GUI components. For example,\n\nThe constructor will be executed in the so-called \"Main-Program\" thread. This may cause multi-threading issues (such as unresponsive user-interface and deadlock).\n\nIt is recommended to execute the GUI setup codes in the so-called \"Event-Dispatching\" thread, instead of \"Main-Program\" thread, for thread-safe operations. Event-dispatching thread, which processes events, should be used when the codes updates the GUI.\n\nTo run the constructor on the event-dispatching thread, invoke method to asynchronously queue the constructor on the event-dispatching thread. The codes will be run after all pending events have been processed. For example,\n\nNote: is a cover for (which is used in the NetBeans' Visual GUI Builder).\n\nAt times, for example in game programming, the constructor or the may contains non-GUI codes. Hence, it is a common practice to create a dedicated method called (used in NetBeans visual GUI builder) or (used in Swing tutorial) to handle all the GUI codes (and another method called to handle initialization of the game's objects). This GUI init method shall be run in the event-dispatching thread.\n\nWarning Message \"The serialization class does not declare a static final serialVersionUID field of type long\"\n\nThis warning message is triggered because (via its superclass ) implements the interface. This interface enables the object to be written out to an output stream serially (via method ); and read back into the program (via method ). The serialization runtime uses a number (called ) to ensure that the object read into the program is compatible with the class definition, and not belonging to another version.\n\nYou have these options:\n• Simply ignore this warning message. If a class does not explicitly declare a , then the serialization runtime will calculate a default value for that class based on various aspects of the class.\n• Suppress this particular warning via annotation (in package ) (JDK 1.5):\n\nIf you have a complicated layout for your GUI application, you should use a GUI Builder, such as NetBeans or Eclipse to layout your GUI components in a drag-and-drop manner, similar to the popular visual languages such as Visual Basic.\n\nFor using NetBeans GUI Builder, read my \"Writing Java GUI (AWT/Swing) Application in NetBeans\"; or Swing Tutorial's \"Learning Swing with the NetBeans IDE\".\n\nFor using Eclipse GUI Builder, read \"Writing Swing Applications using Eclipse GUI Builder\"."
    },
    {
        "link": "https://chegg.com/homework-help/questions-and-answers/apply-knowledge-gui-programming-java-java-gui-programming-play-jbutton-scores-1-create-gui-q55407254",
        "document": "Apply your knowledge of GUI programming in Java.|| Java GUI Programming \"Play with JButton Scores\" 1. Create a GUI application to add and subtract scores for the red team and the blue team. Name the program ScoreButton##where ## is your initials. Be sure to have the proper program documentation/comments. All methods must have the proper JavaDoc comments. Hint: Refer to the practice exercise for tips on how to create this application. OUTPUT Play with JButton Scores! Red Team Blue Team 0 0 Red Score! Blue Score! -1 for Red -1 for Blue Reset Score"
    },
    {
        "link": "https://stackoverflow.com/questions/5473828/java-swing-gui-best-practices-from-a-code-standpoint",
        "document": "As a contrast to this wiki, I am looking for the proper way to implement Swing GUI controls from a coding standpoint.\n\nI have been on a quest to learn Java and its GUI tools but I find internet tutorial after internet tutorial that throws everything in and I know this isn't right.\n\nI've also tried RAD systems like Netbeans and other \"visual\" editors but by the time I get to coding I've got a heap of code that I don't know half of what it does, so I'm intent on learning to hand code swing, and I know the basic controls and layout, but want to do it the right way.\n\nIs there a model or standard I'm missing?\n\ndo I extend JFrame and create my own frame object? (I would assume yes)\n\ndo I encapsulate the main menu inside that frame object? or do I create its own? etc...\n\nHow to I separate \"View\" logic from \"Application\" logic?\n\nBasically, I'm looking for what the industry standard is, on how to organize GUI code."
    },
    {
        "link": "https://medium.com/@hemay9717/building-user-friendly-interfaces-with-java-swing-a-step-by-step-guide-22b1f067281",
        "document": "In the world of software development, creating user-friendly interfaces is of paramount importance. An interface that is intuitive, responsive, and aesthetically pleasing can greatly enhance user experience and contribute to the overall success of an application. One of the powerful tools for building such interfaces in Java applications is Java Swing. In this comprehensive guide, we will take you through the process of building user-friendly interfaces with Java Swing, step by step.\n\nJava Swing is a graphical user interface (GUI) toolkit that comes bundled with the Java Development Kit (JDK). It provides a set of components and libraries for building rich and interactive user interfaces for Java applications. Swing is platform-independent, meaning that the same code can run on different operating systems without modification.\n• Platform Independence: Swing components are implemented purely in Java, allowing applications to run on any platform that supports Java.\n• Customizable Look and Feel: Swing allows developers to choose different look and feel themes to match the native appearance of various operating systems.\n• Rich Set of Components: Swing provides a wide range of components such as buttons, labels, text fields, checkboxes, radio buttons, and more.\n• Layout Managers: Swing offers layout managers that simplify the arrangement of components within containers, adapting to different screen sizes and orientations.\n• Event Handling: Swing components can respond to various user-generated events like clicks, key presses, and mouse movements.\n\nBefore diving into Java Swing, ensure that you have the following prerequisites installed:\n• Integrated Development Environment (IDE) such as IntelliJ IDEA, Eclipse, or NetBeans\n• Launch your chosen IDE and create a new Java project.\n• Create a new class that will serve as the entry point of your application.\n• Import the necessary Swing classes, usually done by adding the following line at the beginning of your code:\n• Inside the main method, set up the basic structure of your Swing application:\n\n// Create and set up the main window (JFrame)\n\n// Add components and set up layout here\n\nSwing provides a plethora of components for building user interfaces. Some common components include:\n• JButton: Used for triggering actions when clicked.\n\nSwing components are often organized within containers such as JPanel. Panels can be nested to create complex layouts. Layout managers help in arranging components within these containers, ensuring consistent layouts across different platforms.\n• FlowLayout: Arranges components in a linear flow, either horizontally or vertically.\n• BorderLayout: Divides the container into five regions: North, South, East, West, and Center.\n• GridLayout: Places components in a grid of rows and columns.\n• GridBagLayout: Provides flexibility by using constraints to define component placement.\n\nBefore diving into coding, plan your user interface on paper or using design tools. Consider user workflows, the placement of components, and the overall visual hierarchy.\n\nConsistency in colors and fonts enhances the visual appeal of your application. Stick to a color scheme and font combination that matches your application’s purpose.\n\nUse layout managers to establish a visual hierarchy. Place important components prominently and group related elements together for a clean and organized appearance.\n\nLet’s create a simple login form using Swing components. We’ll use JLabels, JTextFields, JPasswordField, and a JButton. The components will be organized using layout managers.\n\nTo make the “Login” button functional, you can attach an ActionListener to it. This listener will execute code when the button is clicked, such as validating the username and password.\n\nSwing components can listen to various events such as button clicks and text input. You can use ActionListener for buttons, DocumentListener for text fields, and other listeners based on your application’s requirements.\n\nSwing provides JTable for tabular data and JList for displaying lists of items. These components are highly customizable and can be integrated with other Swing components.\n\nWhen dealing with large amounts of data, it’s essential to use JScrollPane to provide scrollable views for components like tables and text areas.\n\nYou can enhance your interface by incorporating icons and images. Use JLabels or JButton with ImageIcon to display images and provide visual cues to users.\n\nSwing’s layout managers help create responsive interfaces. Components automatically adjust their positions and sizes based on the available space.\n\nSwing Timers can be used for animations or periodic tasks. They ensure that animation runs smoothly without blocking the user interface thread.\n\nConsider designing your UI to be responsive across various screen sizes. Test your application on different devices and use layout managers effectively.\n\nTooltips provide additional information when users hover over components. Use the setToolTipText() method to add tooltips to Swing components.\n\nEnsure that user input is valid before processing it. Use InputVerifier or DocumentFilter to control the input in text fields.\n\nSwing provides JOptionPane for displaying various types of dialog boxes, such as alerts, messages, and confirmations.\n\nSwing supports internationalization (i18n) by using resource bundles to store translated text. This allows your application to be used by people speaking different languages.\n\nFollow accessibility guidelines to make your application usable by people with disabilities. Use accessible component names and provide keyboard shortcuts.\n\nSwing components inherently support accessibility. Use the AccessibleContext to provide additional information about components to assistive technologies.\n\nPackage your Swing application as an executable JAR file. Ensure that all required resources and libraries are included.\n\nExternalize strings, images, and other resources from your code. This simplifies maintenance and localization efforts.\n\nEnsure that your application runs consistently on various operating systems. Test your application thoroughly on different platforms to identify and fix potential issues.\n\nAvoid cluttering the interface with unnecessary elements. Prioritize functionality that aligns with the application’s purpose.\n\nFollow coding standards, modularize your code, and use meaningful names for components and variables. This makes your codebase more readable and maintainable.\n\nThoroughly test your application to identify bugs and usability issues. Gather user feedback to continuously improve the user experience.\n\nPlan the layout for the to-do list, including components like JList for displaying tasks and JButton for adding and deleting tasks.\n\nUse DefaultListModel to manage the tasks in the list. Add event listeners to update the list when tasks are added or removed.\n\nImplement data persistence using file I/O or a database. Serialize the tasks to a file to save the to-do list and load them when the application starts.\n\nWhile Swing remains a reliable option for building UIs, JavaFX is gaining popularity for modern Java applications. JavaFX provides richer graphics and animation capabilities.\n\nAs UI/UX trends evolve, consider integrating responsive design, dark mode, touch-friendly interfaces, and other features to keep your applications up to date.\n\nJava Swing remains a powerful tool for creating user-friendly interfaces in Java applications. By following the steps outlined in this guide, you can build robust and visually appealing user interfaces that enhance the overall user experience. Keep in mind that UI development is an ongoing process, so continuously gather feedback from users and stay updated with the latest UI/UX trends to ensure your applications remain competitive in the ever-changing landscape of software development. To know more about Java and its fundamentals, consider enrolling in a Java course from a reputed Java Training Course in Jaipur, Mumbai, Delhi, Noida and many other cities in India."
    },
    {
        "link": "https://stackoverflow.com/questions/18895049/java-best-practice-for-event-handling-and-reflect-results-back",
        "document": "Since I start to programming in Java, every time when I want to create a GUI and a more complex business logic every time I encounter the same problem.\n• How can you entirely separate the GUI part from the logic part? Edited: Maybe is slightly wrong said \"GUI part from the logic part\". Rather, more correctly is \"GUI part from the listeners part\" because we don't want files with a huge amount of lines like when we wrote anonymous functions or inner classes.\n\nA result can be that:\n\nIf some of you know a better way to do that please tell to me.\n• None How to make the GUI respond with a refresh when an action is taken from? Because in the above example we wrote:\n\nso only button b knows when the action was performed.\n\nIn case that my solution for the first problem is not reliable for the second one please provide a complete solution for this post.\n\nI hope that will be helpful for more people."
    },
    {
        "link": "https://quora.com/What-are-the-best-practices-for-Java-GUI-development-with-Swing-API",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://codeknowcode.com/mastering-event-handling-in-java-swing-building-interactive-guis",
        "document": "Welcome to our guide on Event Handling in Java Swing. Event handling is a crucial aspect of building interactive graphical user interfaces using Swing. It allows your application to respond to user actions such as button clicks, mouse movements, and keyboard input. In this post, we’ll explore the basics of event handling in Java Swing, how it works, and how to implement it effectively.\n\nIn Java Swing, events are generated when a user interacts with GUI components like buttons, text fields, or menus. These interactions trigger specific actions or behaviors within the application. Event handling is the mechanism that allows your program to respond to these events.\n\nEvents in Swing follow the observer pattern, where components generate events, and listeners (event handlers) respond to these events. The Swing event handling model consists of three main components:\n• Event Sources: These are the components that generate events, such as buttons, text fields, and checkboxes.\n• Event Objects: When an event occurs, an event object is created. This object contains information about the event, such as its type and source.\n• Event Listeners: These are classes that implement listener interfaces. They “listen” for specific types of events and define methods to respond to those events.\n\nLet’s take a look at a simple example to understand how event handling works in Java Swing:\n\nIn this example, we create a simple Swing application with a button. We attach an to the button using the method. When the button is clicked, the method of the is called, and a message dialog is displayed.\n\nSwing provides a wide range of events and corresponding listener interfaces to handle various interactions. Here are some of the common Swing events and their associated listener interfaces:\n• ActionEvent: Generated when a component like a button is activated (e.g., clicked). Handled by .\n• MouseEvent: Generated when a mouse event occurs, such as clicking or moving the mouse. Handled by and .\n• KeyEvent: Generated when a key is pressed, released, or typed. Handled by .\n• ItemEvent: Generated when an item (e.g., checkbox, radio button) is selected or deselected. Handled by .\n\nIt’s important to choose the appropriate listener interface for the event you want to handle. Implement the necessary methods in the listener interface to define the desired behavior when the event occurs.\n\nTo add an event listener to a Swing component, you need to:\n• Create an instance of the appropriate listener interface and implement its methods.\n• Use the component’s method (e.g., , ) to attach the listener to the component.\n\nLet’s take a look at another example where we use a to handle mouse events:\n\nIn this example, we create a and attach a to it using the method. When the panel is clicked, the method of the listener is called, and a message dialog is displayed.\n\nEvent handling is a fundamental aspect of building interactive Java Swing applications. By understanding how events, event sources, and event listeners work together, you can create responsive and user-friendly GUIs. Whether it’s handling button clicks or mouse movements, the ability to respond to user interactions is essential for creating rich and engaging applications."
    }
]