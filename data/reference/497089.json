[
    {
        "link": "https://stackoverflow.com/questions/8012002/create-a-unique-number-with-javascript-time",
        "document": "It's been a while since I've done this and I don't have the code anymore. Anyone have the code to do this, or have a better suggestion for generating a unique ID?\n\nI need to generate unique id numbers on the fly using javascript. In the past, I've done this by creating a number using time. The number would be made up of the four digit year, two digit month, two digit day, two digit hour, two digit minute, two digit second, and three digit millisecond. So it would look something like this: 20111104103912732 ... this would give enough certainty of a unique number for my purposes.\n\nThe shortest way to create a number that you can be pretty sure will be unique among as many separate instances as you can think of is If there is a 1 millisecond difference in function call, it is 100% guaranteed to generate a different number. For function calls within the same millisecond you should only start to be worried if you are creating more than a few million numbers within this same millisecond, which is not very probable. For more on the probability of getting a repeated number within the same millisecond see https://stackoverflow.com/a/28220928/4617597\n\nUpdated for 2021, numbers and ids are not guaranteed to be unique but should be satisfactory unique enough: // a pseudo-random floating number based on Date.now() const generateRandomNumber = () => Math.log2(Date.now()) + Math.random(); console.log(\"a pseudo-random floating number based on Date.now():\"); console.log(generateRandomNumber()); // a locally unique-ish HTML id const generateUniqueId = () => `_${Date.now().toString(36)}${Math.floor(Number.MAX_SAFE_INTEGER * Math.random()).toString(36)}`; console.log(\"a locally unique-ish HTML id:\"); console.log(generateUniqueId()) // a pseudo-random BigInt const generateRandomBigInt = () => BigInt(Date.now()) * BigInt(Number.MAX_SAFE_INTEGER) + BigInt(Math.floor(Number.MAX_SAFE_INTEGER * Math.random())); console.log(\"a pseudo-random BigInt:\"); console.log(generateRandomBigInt().toString()); // same but base32-encoded (each char is 5 bits) console.log(\"same but base32-encoded (each char is 5 bits):\"); console.log(generateRandomBigInt().toString(32)); // extracting the \"Date.now\" timestamp of when it was generated: console.log('extracting the \"Date.now\" timestamp of when it was generated:'); console.log(Number(generateRandomBigInt() / BigInt(Number.MAX_SAFE_INTEGER))) // generate a run of random BigInt in ascending order function generateRandomBigIntFactory() { let count = 0, prev = 0; return () => { const now = Date.now(); if (now === prev) { ++count; } else { count = 0; prev = now; } return (BigInt(now) * BigInt(16384) + BigInt(count)) * BigInt(Number.MAX_SAFE_INTEGER) + BigInt(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)); } } // verify the order is ascending const generate = generateRandomBigIntFactory(); let prev = 0; for (let i = 0; i < 65536; i++) { const num = generate(); if (num <= prev) console.log(`error: ${prev}, ${num}`); prev = num; } console.log(\"the last random BigInt:\"); console.log(prev.toString());\n\nSince milliseconds are not updated every millisecond in node, following is an answer. This generates a unique human readable ticket number. I am new to programming and nodejs. Please correct me if I am wrong. function get2Digit(value) { if (value.length == 1) return \"0\" + \"\" + value; else return value; function get3Digit(value) { if (value.length == 1) return \"00\" + \"\" + value; else return value; function generateID() { var d = new Date(); var year = d.getFullYear(); var month = get2Digit(d.getMonth() + 1); var date = get2Digit(d.getDate()); var hours = get2Digit(d.getHours()); var minutes = get2Digit(d.getMinutes()); var seconds = get2Digit(d.getSeconds()); var millSeconds = get2Digit(d.getMilliseconds()); var dateValue = year + \"\" + month + \"\" + date; var uniqueID = hours + \"\" + minutes + \"\" + seconds + \"\" + millSeconds; if (lastUniqueID == \"false\" || lastUniqueID < uniqueID) lastUniqueID = uniqueID; else lastUniqueID = Number(lastUniqueID) + 1; return dateValue + \"\" + lastUniqueID; }\n\nI came across this question while trying to find a simple UID generation technique that was also sortable (so I can order by uid and items will appear in order of creation / uid generation). The major problem with most (all?) of the solutions here is that they either rely on millisecond accuracy (at best) == clashes(!) or a pseudo-random number == clashes(!) && non-sortable(!). Technique below uses micro-second precision where available (i.e. not where fingerprinting-resistance techniques are in play, e.g. firefox) combined with an incrementing, stateful suffix. Not perfect, or particularly performant for large numbers of IDs (see example with 1,000,000 below), but it works and is reversible. // return a uid, sortable by creation order let increment; let tuidPrev; const uid = (uidPrev) => { // get current time to microsecond precision (if available) and remove decimals const tuid = ((performance.timing.navigationStart + performance.now()) * 1000) // convert timestamp to base36 string .toString(36); // previous uid has been provided (stateful) if (uidPrev) { tuidPrev = uidPrev.slice(0, 10); increment = uidPrev.length > 10 ? parseInt(uidPrev.slice(10), 36) : 0; } // if tuid is changed reset the increment if (tuid !== tuidPrev) { tuidPrev = tuid; increment = 0; } // return timed uid + suffix (4^36 values) === very unique id! return tuid + ('000' + (increment++).toString(36)).slice(-4); } // EXAMPLE (check the console!) const iterations = 1000000; const uids = []; const uidMap = {}; const timeMap = {} const microMap = {}; let time = performance.now(); for (let i = 0; i < iterations; i++) { const id = uid(); uids.push(id); uidMap[id] = i; timeMap[Date.now()] = i; microMap[performance.now()] = i; } console.log(`Time taken: ${performance.now() - time}ms`); console.log('Unique IDs:', Object.keys(uidMap).length.toLocaleString()); console.log('Clashing timestamps:', (iterations - Object.keys(timeMap).length).toLocaleString()); console.log('Clashing microseconds:', (iterations - Object.keys(microMap).length).toLocaleString()); console.log('Sortable:', !uids.slice().sort().find((id, i) => uids[i] !== id))\n\nAssumed that the solution proposed by @abarber it's a good solution because uses so it has a windows of milliseconds and sum a in case of collisions in this interval, we could consider to use built-in as we can clearly see here in action: Fist we can see here how there can be collisions in the 1/1000 window frame using : console.log( (new Date()).getTime() ); console.log( (new Date()).getTime() ) VM1155:1 1469615396590 VM1155:1 1469615396591 console.log( (new Date()).getTime() ); console.log( (new Date()).getTime() ) VM1156:1 1469615398845 VM1156:1 1469615398846 console.log( (new Date()).getTime() ); console.log( (new Date()).getTime() ) VM1158:1 1469615403045 VM1158:1 1469615403045 Second we try the proposed solution that avoid collisions in the 1/1000 window: That said we could consider to use functions like the node that is called in the event loop as a single and it's well explained here. Of course in the browser there is no so we have to figure how how to do that. This implementation will install a function in the browser using the most closer functions to the I/O in the browser that are , , . As suggested here we could add the , but I leave this to the reader since it needs a as well. I have modified the original module versions to keep it simpler here: getUniqueID = (c => { if(typeof(nextTick)=='undefined') nextTick = (function(window, prefixes, i, p, fnc) { while (!fnc && i < prefixes.length) { fnc = window[prefixes[i++] + 'equestAnimationFrame']; } return (fnc && fnc.bind(window)) || window.setImmediate || function(fnc) {window.setTimeout(fnc, 0);}; })(window, 'r webkitR mozR msR oR'.split(' '), 0); nextTick(() => { return c( (new Date()).getTime() ) }) }) So we have in the 1/1000 window:"
    },
    {
        "link": "https://stackoverflow.com/questions/29605672/how-to-generate-short-unique-names-for-uploaded-files-in-nodejs",
        "document": "Update: shortid is deprecated. Use Nano ID instead. The answer below applies to Nano ID as well.\n\nYou may want to check out the shortid NPM module, which generates short ids (shockingly, I know :) ) similar to the ones you were posting as example. The result is configurable, but by default it's a string between 7 and 14 characters (length is random too), all URL-friendly ( in a regex).\n\nTo answer your (and other posters') concerns:\n• Unless your server has a true random number generator (highly unlikely), every solution will use a PRNG (Pseudo-Random Number Generator). shortid uses Node.js crypto module to generate PRNG numbers, however, which is a much better generator than Math.random()\n• shortid's are not sequential, which makes it even harder to guess them\n• While shortid's are not guaranteed to be unique, the likelihood of a collision is extremely small. Unless you generate billions of entries per year, you could safely assume that a collision will never happen.\n• For most cases, relying on probability to trust that collisions won't happen is enough. If your data is too important to risk even that tiny amount, you could make the shortid basically 100% unique by just prepending a timestamp to it. As an additional benefit, the file names will be harder to guess too. (Note: I wrote \"basically 100% unique\" because you could still, in theory, have a collision if two items are generated in the same timestamp, i.e. the same second. However, I would never be concerned of this. To have a real 100% certainty your only option is to run a check against a database or the filesystem, but that requires more resources.)\n• The reason why shortid doesn't do that by itself is because for most applications the likelihood of a collision is too small to be a concern, and it's more important to have the shortest possible ids."
    },
    {
        "link": "https://dev.to/rahmanfadhil/how-to-generate-unique-id-in-javascript-1b13",
        "document": "There are several ways to generate unique identifier in JavaScript. This could very useful in many cases, such as rendering list efficiently, or storing documents or records in database.\n\nUUID is the abbreviation of univerally unique identifier, which is an identification number to uniquely identify something. The main idea of this thing is everytime we generate this numbers, it will be universally unique, which means no one could generate the exact same id as yours.\n\nI personally prefer this approach in any case. In JavaScript, we can use a library called to generate UUID.\n\n\n\nUUID has several versions, but the version that appropriate for generating unique id is version 4. And, that code will generate something like this.\n\n\n\nMath.random is a JavaScript built-in function which allows us to generate a random number. Which means that everytime we run it, it will return a unique combination of numbers.\n\n\n\nalways returns a decimal number, so we need to rounding off that number first. By multiply it with 100, it will return any number between 0 to 99. You can increase the number if you want to get better result.\n\nDate.now is another JavaScript built-in function which allows us to get the number of miliseconds elapsed since January 1, 1970."
    },
    {
        "link": "https://medium.com/@ryan_forrester_/javascript-unique-id-generation-how-to-guide-0d6752318823",
        "document": "Have you ever found yourself scratching your head, trying to come up with a foolproof way to generate unique identifiers in JavaScript?\n\nYou’re not alone. As our applications grow more complex, the need for reliable, efficient, and truly unique IDs becomes increasingly critical.\n\nLet’s dive into JavaScript unique ID generation, exploring techniques that go beyond the typical “Math.random()” approach.\n\nBefore we delve into more robust solutions, let’s address the elephant in the room: why can’t we just use Math.random() or Date.now() and call it a day?\n\nWhile these methods might seem tempting due to their simplicity, they come with significant drawbacks. Math.random() doesn’t guarantee uniqueness, especially when generating a large number of IDs in quick succession. Date.now(), on the other hand, can produce duplicate IDs if multiple calls happen within the same millisecond.\n\nIn high-performance environments or distributed systems, these simple approaches can lead to collisions, potentially causing data integrity issues or hard-to-debug problems.\n\nEnter UUIDs (Universally Unique Identifiers). These 128-bit numbers are designed to be unique across both space and time, making them an excellent choice for many applications.\n\nWhile JavaScript doesn’t have built-in UUID generation, we can implement it ourselves or use well-maintained libraries. Here’s a basic implementation of UUID v4:\n\nThis method generates IDs that are unique enough for most purposes. However, for cryptographically secure UUIDs, you might want to use the Web Crypto API:\n\nFor scenarios where you need a balance of uniqueness, readability, and performance, consider combining timestamps with a Web Worker. This approach allows for high-speed ID generation while maintaining uniqueness:\n\nThis approach generates IDs like “kq9qmus-0”, where the first part is a timestamp and the second part is a counter for IDs generated within the same millisecond.\n\nChoosing the Right Method for Your Needs\n\nThe “best” method for generating unique IDs depends on your specific requirements. Consider the following factors:\n\n1. **Uniqueness Guarantee**: How critical is it that your IDs are globally unique?\n\n2. **Performance**: Are you generating IDs at a high frequency?\n\n3. **Readability**: Do humans need to read or work with these IDs?\n\n4. **Security**: Are these IDs used in security-sensitive contexts?\n\n5. **Persistence**: Do the IDs need to be reproducible or just unique within a session?\n\nFor most web applications, the UUID v4 approach provides a good balance of uniqueness and simplicity. For high-performance scenarios, the timestamp-worker combo can be an excellent choice. And for situations requiring cryptographic security, always opt for the Web Crypto API.\n\nGenerating unique IDs is only part of the story. How you use and manage these IDs can significantly impact your application’s performance and maintainability.\n\nWhen working with databases, consider the storage implications of your chosen ID format. While UUIDs provide excellent uniqueness, they can be less efficient for indexing compared to auto-incrementing integers. If you’re using UUIDs in a database, ensure your database is optimized for UUID storage and querying.\n\nDepending on your ID format, you might need to implement validation logic. For UUIDs, a simple regex can do the trick:\n\nFor custom formats, like our timestamp-worker IDs, you might want to implement parsing functions:\n\nIn scenarios where you’re frequently generating or working with the same IDs, consider implementing caching or memoization techniques to improve performance.\n\nGenerating unique IDs in JavaScript is a deceptively complex topic with far-reaching implications for your application’s architecture and performance. By understanding the strengths and weaknesses of different approaches, you can make informed decisions that balance uniqueness, efficiency, and security.\n\nRemember, the key is to choose a method that aligns with your specific needs. Don’t be afraid to experiment with different techniques or even combine approaches to create a solution tailored to your unique requirements."
    },
    {
        "link": "https://dev.to/torstendittmann/the-most-absurd-way-of-creating-unique-identifiers-2nie",
        "document": "Today I ran into an issue. The guy sitting next to me in the university was trying out PouchDB and was confused by the identifiers. It was illogical for him why he had to determine the ID for each document himself.\n\n In my last project I just generated a random number and asked if it already existed. Actually quite bad, but it worked.\n\nThen I asked my friend Google and came across a solution on Stackoverflow.\n\nAt that moment I was shocked how simple this approach was and how I never came up with this idea.\n\nJust create an ID using the current UNIX Timestamp with\n\nBut after a short thought I asked myself a question. Does this approach still work when my code generates many records in a row?\n\nFor the demonstration I use PouchDB.\n\nWith PouchDB you can create a batch of documents with\n\nAs you might expect, only the first entry will be created and the second one will return an error because it is done in the same timestamp and end up with the same .\n\nI needed something more accurate than milliseconds. I was helped by .\n\nUnlike other timing data available to JavaScript (for example Date.now), the timestamps returned by performance.now() are not limited to one-millisecond resolution. Instead, they represent times as floating-point numbers with up to microsecond precision.\n\nAlso unlike Date.now(), the values returned by performance.now() always increase at a constant rate, independent of the system clock (which might be adjusted manually or skewed by software like NTP).\n\nSo if I combine these two methods, I should end up with a very accurate Unique Identifier.\n\nEven if this seems completely absurd in my eyes, I can hardly think of a possibility that he runs on an error because of an already existing ID.\n\nBecause in every millisecond of the current UNIX timestamp the value of five thousandths of a millisecond (5 microseconds) of the runtime is added.\n\nLet's use above uniqueID() function like this:\n\nAs you can see, between the two entries, the difference from the results is large enough.\n\nOf course, this approach can lead to a problem if millions of users work with the same database. But on a small scale it shouldn't run into a problem.\n\nI am always open for ideas or suggestions. What do you think about this approach?"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Using_images",
        "document": "Until now we have created our own shapes and applied styles to them. One of the more exciting features of is the ability to use images. These can be used to do dynamic photo compositing or as backdrops of graphs, for sprites in games, and so forth. External images can be used in any format supported by the browser, such as PNG, GIF, or JPEG. You can even use the image produced by other canvas elements on the same page as the source! Importing images into a canvas is basically a two step process:\n• Get a reference to an object or to another canvas element as a source. It is also possible to use images by providing a URL.\n• Draw the image on the canvas using the function. Let's take a look at how to do this.\n\nThe canvas API is able to use any of the following data types as an image source: These are images created using the constructor, as well as any element. These are images embedded using the element. Using an HTML element as your image source grabs the current frame from the video and uses it as an image. You can use another element as your image source. A bitmap image, eventually cropped. Such type are used to extract part of an image, a sprite, from a larger image A special kind of that is not displayed and is prepared without being displayed. Using such an image source allows to switch to it without the composition of the content to be visible to the user. An image representing one single frame of a video. There are several ways to get images for use on a canvas.\n\nAnother option is to create new objects in our script. To do this, we have the convenience of an constructor: When this script gets executed, the image starts loading, but if you try to call before the image has finished loading, it won't do anything. Older browsers may even throw an exception, so you need to be sure to use the load event so you don't draw the image to the canvas before it's ready: If you're using one external image, this can be a good approach, but once you want to use many images or lazy-load resources, you probably need to wait for all the files to be available before drawing to the canvas. The examples below that deal with multiple images use an async function and Promise.all to wait for all images to load before calling : async function draw() { // Wait for all images to be loaded: await Promise.all( Array.from(document.images).map( (image) => new Promise((resolve) => image.addEventListener(\"load\", resolve)), ), ); const ctx = document.getElementById(\"canvas\").getContext(\"2d\"); // call drawImage() as usual } draw();\n\nAnother possible way to include images is via the data: URL. Data URLs allow you to completely define an image as a Base64 encoded string of characters directly in your code. One advantage of data URLs is that the resulting image is available immediately without another round trip to the server. Another potential advantage is that it is also possible to encapsulate in one file all of your CSS, JavaScript, HTML, and images, making it more portable to other locations. Some disadvantages of this method are that your image is not cached, and for larger images the encoded URL can become quite long.\n\nIn this example, we'll use an image as a wallpaper and repeat it several times on the canvas. This is done by looping and placing the scaled images at different positions. In the code below, the first loop iterates over the rows. The second loop iterates over the columns. The image is scaled to one third of its original size, which is 50x38 pixels. Note: Images can become blurry when scaling up or grainy if they're scaled down too much. Scaling is probably best not done if you've got some text in it which needs to remain legible. function draw() { const ctx = document.getElementById(\"canvas\").getContext(\"2d\"); const img = new Image(); img.onload = () => { for (let i = 0; i < 4; i++) { for (let j = 0; j < 3; j++) { ctx.drawImage(img, j * 50, i * 38, 50, 38); } } }; img.src = \"https://mdn.github.io/shared-assets/images/examples/rhino.jpg\"; } draw(); The resulting canvas looks like this:\n\nThe third and last variant of the method has eight parameters in addition to the image source. It lets us cut out a section of the source image, then scale and draw it on our canvas. Given an , this function takes the area of the source image specified by the rectangle whose top-left corner is ( , ) and whose width and height are and and draws it into the canvas, placing it on the canvas at ( , ) and scaling it to the size specified by and , maintaining its aspect ratio. To really understand what this does, it may help to look at this image: The first four parameters define the location and size of the slice on the source image. The last four parameters define the rectangle into which to draw the image on the destination canvas. Slicing can be a useful tool when you want to make compositions. You could have all elements in a single image file and use this method to composite a complete drawing. For instance, if you want to make a chart you could have a PNG image containing all the necessary text in a single file and depending on your data could change the scale of your chart fairly easily. Another advantage is that you don't need to load every image individually, which can improve load performance.\n\nIn this example, we'll use the same rhino as in the previous example, but we'll slice out its head and composite it into a picture frame. The picture frame image is a 24-bit PNG which includes a drop shadow. Because 24-bit PNG images include a full 8-bit alpha channel, unlike GIF and 8-bit PNG images, it can be placed onto any background without worrying about a matte color. async function draw() { // Wait for all images to be loaded. await Promise.all( Array.from(document.images).map( (image) => new Promise((resolve) => image.addEventListener(\"load\", resolve)), ), ); const canvas = document.getElementById(\"canvas\"); const ctx = canvas.getContext(\"2d\"); // Draw slice ctx.drawImage( document.getElementById(\"source\"), 33, 71, 104, 124, 21, 20, 87, 104, ); // Draw frame ctx.drawImage(document.getElementById(\"frame\"), 0, 0); } draw(); We took a different approach to loading the images this time. Instead of loading them by creating new objects, we included them as tags in our HTML source and retrieved the images from those when drawing to the canvas. The images are hidden from page by setting the CSS property to for those images. Each is assigned an ID attribute, so we have one for a and one for the , which makes them easy to select using . We're using Promise.all to wait for all images to load before calling . slices the rhino out of the first image and scales it onto the canvas. Lastly, we draw the picture frame using a second call."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 . * Some parts of this feature may have varying levels of support.\n\nThe method of the Canvas 2D API provides different ways to draw an image onto the canvas.\n\nAn element to draw into the context. The specification permits any canvas image source, specifically, an , an , an , an , an , an , or a . The x-axis coordinate of the top left corner of the sub-rectangle of the source to draw into the destination context. Use the 3- or 5-argument syntax to omit this argument. The y-axis coordinate of the top left corner of the sub-rectangle of the source to draw into the destination context. Use the 3- or 5-argument syntax to omit this argument. The width of the sub-rectangle of the source to draw into the destination context. If not specified, the entire rectangle from the coordinates specified by and to the bottom-right corner of the image is used. Use the 3- or 5-argument syntax to omit this argument. A negative value will flip the image. The height of the sub-rectangle of the source to draw into the destination context. Use the 3- or 5-argument syntax to omit this argument. A negative value will flip the image. The x-axis coordinate in the destination canvas at which to place the top-left corner of the source . The y-axis coordinate in the destination canvas at which to place the top-left corner of the source . The width to draw the in the destination canvas. This allows scaling of the drawn image. If not specified, the image is not scaled in width when drawn. Note that this argument is not included in the 3-argument syntax. The height to draw the in the destination canvas. This allows scaling of the drawn image. If not specified, the image is not scaled in height when drawn. Note that this argument is not included in the 3-argument syntax.\n\nDrawing an image to the canvas This example draws an image to the canvas using the method. The source image is taken from the coordinates (33, 71), with a width of 104 and a height of 124. It is drawn to the canvas at (21, 20), where it is given a width of 87 and a height of 104.\n\nThe method uses the source element's intrinsic size in CSS pixels when drawing. For example, if you load an and specify the optional size parameters in its constructor, you will have to use the and properties of the created instance to properly calculate things like crop and scale regions, rather than and . The same goes for and if the element is a element, and so on. const canvas = document.getElementById(\"canvas\"); const ctx = canvas.getContext(\"2d\"); const image = new Image(60, 45); // Using optional size for image image.onload = drawImageActualSize; // Draw when image has loaded // Load an image of intrinsic size 300x227 in CSS pixels image.src = \"https://mdn.github.io/shared-assets/images/examples/rhino.jpg\"; function drawImageActualSize() { // Use the intrinsic size of image in CSS pixels for the canvas element canvas.width = this.naturalWidth; canvas.height = this.naturalHeight; // Will draw the image as 300x227, ignoring the custom size of 60x45 // given in the constructor ctx.drawImage(this, 0, 0); // To use the custom size we'll have to specify the scale parameters // using the element's width and height properties - lets draw one // on top in the corner: ctx.drawImage(this, 0, 0, this.width, this.height); }"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API",
        "document": "The Canvas API provides a means for drawing graphics via JavaScript and the HTML element. Among other things, it can be used for animation, game graphics, data visualization, photo manipulation, and real-time video processing. The Canvas API largely focuses on 2D graphics. The WebGL API, which also uses the element, draws hardware-accelerated 2D and 3D graphics.\n\nThe method gets a reference to the HTML element. Next, the method gets that element's context—the thing onto which the drawing will be rendered. The actual drawing is done using the interface. The property makes the rectangle green. The method places its top-left corner at (10, 10), and gives it a size of 150 units wide by 100 tall.\n\nThe Canvas API is extremely powerful, but not always simple to use. The libraries listed below can make the creation of canvas-based projects faster and easier.\n• EaselJS is an open-source canvas library that makes creating games, generative art, and other highly graphical experiences easy.\n• Fabric.js is an open-source canvas library with SVG parsing capabilities.\n• heatmap.js is an open-source library for creating canvas-based data heat maps.\n• Konva.js is a 2D canvas library for desktop and mobile applications.\n• p5.js has a full set of canvas drawing functionality for artists, designers, educators, and beginners.\n• Paper.js is an open-source vector graphics scripting framework that runs on top of the HTML Canvas.\n• Phaser is a fast, free and fun open source framework for Canvas and WebGL powered browser games.\n• Pts.js is a library for creative coding and visualization in canvas and SVG.\n• Rekapi is an animation key-framing API for Canvas.\n• Scrawl-canvas is an open-source JavaScript library for creating and manipulating 2D canvas elements.\n• The ZIM framework provides conveniences, components, and controls for coding creativity on the canvas — includes accessibility and hundreds of colorful tutorials.\n• Sprig is a beginner-friendly, open-source, tile-based game development library that uses Canvas. Note: See the WebGL API for 2D and 3D libraries that use WebGL."
    },
    {
        "link": "https://stackoverflow.com/questions/14757659/loading-an-image-onto-a-canvas-with-javascript",
        "document": "I am currently testing using the element to draw all of the backgrounds (I will add effects later to these images later and is the reason I'm not using CSS to load the images). That said, I'm currently having difficulty loading a image on to the canvas. Here is the code:\n\nI think that I'm not loading the image correctly, but I'm not sure."
    },
    {
        "link": "https://w3schools.com/jsref/api_canvas.asp",
        "document": "You access a element with the HTML DOM method .\n\nTo draw in the canvas you need to create a 2D context object:\n\nThe common way to draw on the canvas is to:\n\nThere are only 3 methods to draw directly on the canvas:\n\nThe canvas object also supports the standard properties and events.\n\nThe element is an HTML5 standard (2014).\n\nis supported in all modern browsers:"
    },
    {
        "link": "https://medium.com/@lydiahallie/javascript-visualized-promises-async-await-a3f1aad8a943",
        "document": "🔥💸 If you don’t want to deal with the paywall, here is the original article! Ever had to deal with JS code that just… didn’t run the way you expected it to? Maybe it seemed like functions got executed at random, unpredictable times, or the execution got delayed. There’s a chance you were dealing with a cool new feature that ES6 introduced: Promises! My curiosity from many years ago has paid off and my sleepless nights have once again given me the time to make some animations. Time to talk about Promises: why would you use them, how do they work “under the hood”, and how can we write them in the most modern way? If you haven’t read my previous post on the JavaScript Event Loop yet, it may be useful to read that first! I’ll be covering the event loop again assuming some basic knowledge about the call stack, Web API and the queue, but this time we’ll also be covering some exciting extra features 🤩\n\nWhen writing JavaScript, we often have to deal with tasks that rely on other tasks! Let’s say that we want to get an image, compress it, apply a filter, and save it 📸 The very first thing we need to do, is get the image that we want to edit. A function can take care of this! Only once that image has been loaded successfully, we can pass that value to a function. When the image has been resized successfully, we want to apply a filter to the image in the function. After the image has been compressed and we've added a filter, we want to save the image and let the user know that everything worked correctly! 🥳 In the end, we’ll end up with something like this: Hmm… Notice anything here? Although it’s… fine, it’s not great. We end up with many nested callback functions that are dependent on the previous callback function. This is often referred to as a callback hell, as we end up with tons of nested callback functions that make the code quite difficult to read! Luckily, we now got something called promises to help us out! Let’s take a look at what promises are, and how they can help us in situations like these! 😃\n\nES6 introduced Promises. In many tutorials, you’ll read something like: “A promise is a placeholder for a value that can either resolve or reject at some time in the future” Yeah… That explanation never made things clearer for me. In fact it only made me feel like a Promise was a weird, vague, unpredictable piece of magic. So let’s look at what promises really are. We can create a promise, using a constructor that receives a callback. Okay cool, let's try it out! Wait woah, what just got returned? 🤯 A is an object that contains a status, ( ) and a value ( ). In the above example, you can see that the value of is , and the value of the promise is . Don’t worry — you’ll never have to interact with this object, you can’t even access the and properties! However, the values of these properties are important when working with promises.\n\nThe value of the , the state, can be one of three values:\n• ✅ : The promise has been . Everything went fine, no errors occurred within the promise 🥳\n• ❌ : The promise has been . Argh, something went wrong..\n• ⏳ : The promise has neither resolved nor rejected (yet), the promise is still . Alright this all sounds great, but when is a promise status , or ? And why does that status even matter? In the above example, we just passed the simple callback function to the constructor. However, this callback function actually receives two arguments. The value of the first argument, often called or , is the method to be called when the Promise should resolve. The value of the second argument, often called or , is the value method to be called when the Promise should reject, something went wrong. Let’s try and see that gets logged when we invoke either the or method! In my example, I called the method , and the method . Awesome! We finally know how to get rid of the status and the value! The status of a promise is if we invoked the method, and the status of the promise is \" if we invoked the method. The value of a promise, the value of , is the value that we pass to the either the or method as their argument. Fun fact, I let Jake Archibald proofread this article and he actually pointed out there’s a bug in Chrome that currently shows the status as instead of . Thanks to Mathias Bynens it's now fixed in Canary! 🥳🕺🏼\n\nOkay so, now we know a little better how to control that vague \n\nobject. But what is it used for? In the introductory section, I showed an example in which we get an image, compress it, apply a filer, and save it! Eventually, this ended up being a nested callback mess. Luckily, Promises can help us fix this! First, let’s rewrite the entire code block, so that each function returns a instead. If the image is loaded and everything went fine, let’s resolve the promise with the loaded image! Else, if there was an error somewhere while loading the file, let’s reject the promise with the error that occurred. Let’s see what happens when we run this in the terminal! Cool! A promise got returned with the value of the parsed data, just like we expected. But… what now? We don’t care about that entire promise object, we only care about the value of the data! Luckily, there are built-in methods to get a promise’s value. To a promise, we can attach 3 methods:\n• : Always gets called, whether the promise resolved or rejected. The method receives the value passed to the method. The method receives the value passed to the method Finally, we have the value that got resolved by the promise without having that entire promise object! We can now do whatever we want with this value.\n\nThe engine encounters the method. It gets added to the call stack immediately, after which it logs the value to the console, gets popped off the call stack, and the engine continues. The engine sees the callstack is empty now. Since the call stack is empty, it’s going to check whether there are queued tasks in the microtask queue! And yes there are, the promise callback is waiting for its turn! It gets popped onto the call stack, after which it logs the resolved value of the promise: the string in this case. The engine sees the call stack is empty, so it’s going to check the microtask queue once again to see if tasks are queued. Nope, the microqueue is all empty. It’s time to check the (macro)task queue: the callback is still waiting there! The callback gets popped on to the callstack. The callback function returns the method, which logs the string . The callback get popped off the callstack. Finally, all done! 🥳 It seems like the output we saw earlier wasn’t so unexpected after all."
    },
    {
        "link": "https://stackoverflow.com/questions/18536321/best-practices-for-implementing-asynchronous-javascript-programming-with-promise",
        "document": "Already had a layer in JS which helps Gets and Posts to the server with the following implementations :\n\nUsing these implementations on DataService layer :\n\nHowever we use webapi, wich in some cases, a request depends the result of another request generating a \"Pyramid of Doom \". For more elegance of code we are implementing the library Q for asynchronous programming.\n\nTo follow the pattern shown above using Q promisses was implemented new method of get as show:\n\nI'm trying to use this implementation on DataService layer this way:\n\nAnyway in my layer viewmodel javascript suppose I need to use 3 finds and one depends on the outcome of the other:\n\nI admit that I am not able to implement the right way, because all my functions inside .then() are coming with undefined args.\n\nI wonder know what is the best practice to meet the scenario propose here."
    },
    {
        "link": "https://hackernoon.com/mastering-asynchronous-javascript-an-in-depth-guide-to-javascript-promises-and-best-practices",
        "document": "Handling asynchronous operations in Javascript is a fundamental part of creating responsive and interactive web applications. Asynchronous programming allows tasks like API calls, file reading, or timers to run in the background, ensuring the application remains responsive. Enter JavaScript Promises, a powerful abstraction for managing these asynchronous operations.\n\nA Promise in JavaScript represents the eventual completion (or failure) of an asynchronous operation and its resulting value. A promise can be in one of three states:\n• Pending: The initial state where the operation has not been completed yet.\n\nThe basic syntax for creating a promise is:\n\nCreating a promise involves passing an executor function to the Promise constructor, which contains the asynchronous operation and dictates whether the promise should be resolved or rejected.\n\nOnce a promise is created, it can be used with , , and methods to handle the fulfilled or rejected state.\n\nallows you to chain multiple promises, creating a sequence of asynchronous operations that execute one after the other.\n\nProper error handling is crucial in asynchronous programming to ensure the reliability and robustness of web applications. Promises provide a clean and straightforward way to catch and handle errors.\n\nThe .catch() method is used to handle any errors that occur in the promise chain.\n\nError propagation in promises ensures that if an error is not caught by a in the chain, it will bubble up to the next .\n\nPromises in JavaScript offer more than just basic functionality. There are several advanced features designed to handle complex asynchronous patterns efficiently.\n\nWhen you need to run multiple promises in parallel and wait for all of them to complete, is incredibly useful.\n\nis similar to , but it resolves or rejects as soon as one of the promises in the iterable resolves or rejects, with the value or reason from that promise.\n\nThis method returns a promise that resolves after all of the given promises have either been resolved or rejected, with an array of objects that each describe the outcome of each promise.\n\ntakes an iterable of Promise objects and, as soon as one of the promises in the iterable fulfills, returns a single promise that resolves with the value from that promise.\n\nPromises are not just theoretical constructs but have practical applications in everyday programming. Here are a couple of examples:\n\nOne common use case is fetching data from a remote API:\n\nAnother practical use is to wrap callback-based functions (like those in Node.js) into promises for a cleaner, more modern API usage:\n\nWhile promises are powerful on their own, the async/await syntax introduced in ES2017 provides a more straightforward way to work with asynchronous operations, making your code cleaner and easier to understand.\n\nasync/await is syntactic sugar over promises and can be used wherever promises are used.\n\nTo make the most out of promises, here are some best practices and common pitfalls to avoid:\n• Avoid Promise Hell: Just like callback hell, promise chains can become nested and complicated. Use Promise.all() or async/await to keep your code clean and readable.\n• Always Catch Errors: Unhandled promise rejections can cause hard-to-find bugs. Always use .catch() or try/catch with async/await.\n• Chain Properly: Remember to return promises from your .then() handlers to keep the chain going.\n\nJavaScript promises are a robust tool for handling asynchronous operations, offering a more manageable approach to callbacks. By understanding and leveraging promises, you can write cleaner, more efficient JavaScript code. Keep experimenting with promises and async/await to find the patterns that work best for your applications."
    },
    {
        "link": "https://medium.com/@ignatovich.dm/modern-methods-for-working-with-asynchronous-code-in-javascript-a-comparison-and-best-practices-037d91db60b1",
        "document": "Asynchronous programming is at the heart of JavaScript, enabling tasks like data fetching, file reading, and animation to happen without blocking the main thread. Over the years, new methods and paradigms for handling asynchronous code have emerged, offering better readability, maintainability, and error handling.\n\nThis article explores modern methods for working with asynchronous code, their differences, and best practices to maximize efficiency and code clarity.\n\nCallbacks were the original method for handling asynchronous code in JavaScript. They involve passing a function (callback) to be executed once the asynchronous task completes.\n• Callback Hell: When tasks are nested, code can become hard to read and debug."
    },
    {
        "link": "https://stackoverflow.com/questions/43552801/using-nodejs-to-perform-image-manipulations-async-and-cannot-understand-promises",
        "document": "I apologize for asking a question that has been posted many times already but I cannot understand how to adapt the examples/solutions/tutorials to my code. I am constrained by modifying someone else's code and cannot start from scratch.\n\nI am using nodejs v6.10 and async code processing is difficult to implement for me despite reading many articles and wikis.\n\nI am trying to determine exactly when all the operations are complete and I believe promises are the right way for me. I cannot figure out how to get it to work correctly, but I am not getting any warnings or errors anymore.\n\nI think my biggest problem is that my image manipulation functions don't return anything and I'm trying to force them to without success.\n\nhere is my basic code:\n\nI realize it's a lot of loops, but this is the architecture that is my constraint for now. I also realize that I only put the promise at the manipulateImage step. This is because the resize operation completes before the manipulateImages operation starts.\n\nIn this configuration, the manipulateImages function is called many times, but nothing is output. If I strip out the \"return new Promise\" wrapper around the code, it works fine. But then I don't know how to return anything that can be passed back to main to wait until the promises.all() returns resolved.\n\nCan someone please educate me on how to allow me to console.log the exact time when all the operations are complete? Thank you."
    }
]