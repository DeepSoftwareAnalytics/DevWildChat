[
    {
        "link": "https://freecodecamp.org/news/with-open-in-python-with-statement-syntax-example",
        "document": "The Python programming language has various functions and statements for working with a file. The statement and function are two of those statements and functions.\n\nIn this article, you will learn how to use both the statement and function to work with files in Python.\n\nWhat Does Do in Python?\n\nTo work with files in Python, you have to open the file first. So, the function does what the name implies – it opens a file for you so you can work with the file.\n\nTo use the open function, you declare a variable for it first. The function takes up to 3 parameters – the filename, the mode, and the encoding. You can then specify what you want to do with the file in a print function.\n\nThat’s not all. The function does not close the file, so you also have to close the file with the method.\n\nSo, a proper way to use the open function looks like this:\n\nThe read mode is the default file mode in Python, so if you don’t specify the mode, the code above still works fine:\n\nHow Does the Statement Work in Python?\n\nThe statement works with the function to open a file.\n\nSo, you can re-write the code we used in the function example like this:\n\nUnlike where you have to close the file with the method, the statement closes the file for you without you telling it to.\n\nThis is because the statement calls 2 built-in methods behind the scene – and .\n\nThe method closes the file when the operation you specify is done.\n\nWith the method, you also write to the file as I did below:\n\nYou can also loop through the file and print the text line by line:\n\nYou might be wondering which way you should use to work with files between the combo of and and just the function.\n\nI would advise you to use the combination of and because the statement closes the file for you and you get to write less code."
    },
    {
        "link": "https://geeksforgeeks.org/file-handling-python",
        "document": "File handling refers to the process of performing operations on a file such as creating, opening, reading, writing and closing it, through a programming interface. It involves managing the data flow between the program and the file system on the storage device, ensuring that data is handled safely and efficiently.\n\nTo open a file we can use function, which requires file path and mode as arguments:\n\nWhen opening a file, we must specify the mode we want to which specifies what we want to do with the file. Here’s a table of the different modes available:\n\nOpens the file for reading. File must exist; otherwise, it raises an error. Opens the file for reading binary data. File must exist; otherwise, it raises an error. Opens the file for both reading and writing. File must exist; otherwise, it raises an error. Opens the file for both reading and writing binary data. File must exist; otherwise, it raises an error. Opens the file for writing. Creates a new file or truncates the existing file. Opens the file for writing binary data. Creates a new file or truncates the existing file. Opens the file for both writing and reading. Creates a new file or truncates the existing file. Opens the file for both writing and reading binary data. Creates a new file or truncates the existing file. Opens the file for appending data. Creates a new file if it doesn’t exist. Opens the file for appending binary data. Creates a new file if it doesn’t exist. Opens the file for appending and reading. Creates a new file if it doesn’t exist. Opens the file for appending and reading binary data. Creates a new file if it doesn’t exist. Creates a new file. Raises an error if the file already exists. Creates a new binary file. Raises an error if the file already exists. Creates a new file for reading and writing. Raises an error if the file exists. Exclusive creation with read and write in binary mode. Creates a new binary file for reading and writing. Raises an error if the file exists.\n\nFor this article we are using text file with text:\n\nReading a file can be achieved by file.read() which reads the entire content of the file. After reading the file we can close the file using file.close() which closes the file after reading it, which is necessary to free up system resources.\n\nWriting to a file is done using file.write() which writes the specified string to the file. If the file exists, its content is erased. If it doesn’t exist, a new file is created.\n\nExample: Writing to a File in Write Mode (w)\n\nIt is done using adds the specified string to the end of the file without erasing its existing content.\n\nExample: For this example, we will use the Python file created in the previous example.\n\nClosing a file is essential to ensure that all resources used by the file are properly released. loses the file and ensures that any changes made to the file are saved.\n\nstatement is used for resource management. It ensures that file is properly closed after its suite finishes, even if an exception is raised. with open() as method automatically handles closing the file once the block of code is exited, even if an error occurs. This reduces the risk of file corruption and resource leakage.\n\nIt’s important to handle exceptions to ensure that files are closed properly, even if an error occurs during file operations.\n• None Versatility : File handling in Python allows us to perform a wide range of operations, such as creating, reading, writing, appending, renaming and deleting files.\n• Flexibility : File handling in Python is highly flexible, as it allows us to work with different file types (e.g. text files, binary files, CSV files , etc.) and to perform different operations on files (e.g. read, write, append, etc.).\n• User – friendly : Python provides a user-friendly interface for file handling, making it easy to create, read and manipulate files.\n• Cross-platform : Python file-handling functions work across different platforms (e.g. Windows, Mac, Linux), allowing for seamless integration and compatibility.\n• Error-prone: File handling operations in Python can be prone to errors, especially if the code is not carefully written or if there are issues with the file system (e.g. file permissions, file locks, etc.).\n• Security risks : File handling in Python can also pose security risks, especially if the program accepts user input that can be used to access or modify sensitive files on the system.\n• Complexity : File handling in Python can be complex, especially when working with more advanced file formats or operations. Careful attention must be paid to the code to ensure that files are handled properly and securely.\n• Performance : File handling operations in Python can be slower than other programming languages, especially when dealing with large files or performing complex operations.\n\nWhat are the types of files in Python?\n\nWhat are the 4 file handling functions?\n\nWhy is file handling useful?\n\nIn Python file handling, is a method of file objects that returns the current position of the file pointer (cursor) within the file. It returns an integer representing the byte offset from the beginning of the file where the next read or write operation will occur. # Open a file in read mode file = open('example.txt', 'r') # Read the first 10 characters content = file.read(10) print(content) # Check the current position of the file pointer position = file.tell() print(\"Current position:\", position) # Close the file file.close()\n• None reads the first 10 characters from the file.\n• None returns the current position of the file pointer after reading."
    },
    {
        "link": "https://docs.python.org/3/tutorial/inputoutput.html",
        "document": "There are several ways to present the output of a program; data can be printed in a human-readable form, or written to a file for future use. This chapter will discuss some of the possibilities.\n\nSo far we’ve encountered two ways of writing values: expression statements and the function. (A third way is using the method of file objects; the standard output file can be referenced as . See the Library Reference for more information on this.) Often you’ll want more control over the formatting of your output than simply printing space-separated values. There are several ways to format output.\n• None To use formatted string literals, begin a string with or before the opening quotation mark or triple quotation mark. Inside this string, you can write a Python expression between and characters that can refer to variables or literal values.\n• None The method of strings requires more manual effort. You’ll still use and to mark where a variable will be substituted and can provide detailed formatting directives, but you’ll also need to provide the information to be formatted. In the following code block there are two examples of how to format variables: Notice how the are padded with spaces and a negative sign only for negative numbers. The example also prints multiplied by 100, with 2 decimal places and followed by a percent sign (see Format Specification Mini-Language for details).\n• None Finally, you can do all the string handling yourself by using string slicing and concatenation operations to create any layout you can imagine. The string type has some methods that perform useful operations for padding strings to a given column width. When you don’t need fancy output but just want a quick display of some variables for debugging purposes, you can convert any value to a string with the or functions. The function is meant to return representations of values which are fairly human-readable, while is meant to generate representations which can be read by the interpreter (or will force a if there is no equivalent syntax). For objects which don’t have a particular representation for human consumption, will return the same value as . Many values, such as numbers or structures like lists and dictionaries, have the same representation using either function. Strings, in particular, have two distinct representations. The value of x is 32.5, and y is 40000... # The repr() of a string adds string quotes and backslashes: # The argument to repr() may be any Python object: The module contains a class that offers yet another way to substitute values into strings, using placeholders like and replacing them with values from a dictionary, but offers much less control of the formatting. Formatted string literals (also called f-strings for short) let you include the value of Python expressions inside a string by prefixing the string with or and writing expressions as . An optional format specifier can follow the expression. This allows greater control over how the value is formatted. The following example rounds pi to three places after the decimal: 'The value of pi is approximately The value of pi is approximately 3.142. Passing an integer after the will cause that field to be a minimum number of characters wide. This is useful for making columns line up. Other modifiers can be used to convert the value before it is formatted. applies , applies , and applies : 'My hovercraft is full of My hovercraft is full of eels. 'My hovercraft is full of My hovercraft is full of 'eels'. The specifier can be used to expand an expression to the text of the expression, an equal sign, then the representation of the evaluated expression: See self-documenting expressions for more information on the specifier. For a reference on these format specifications, see the reference guide for the Format Specification Mini-Language. Basic usage of the method looks like this: We are the knights who say \"Ni!\" The brackets and characters within them (called format fields) are replaced with the objects passed into the method. A number in the brackets can be used to refer to the position of the object passed into the method. If keyword arguments are used in the method, their values are referred to by using the name of the argument. Positional and keyword arguments can be arbitrarily combined: The story of Bill, Manfred, and Georg. If you have a really long format string that you don’t want to split up, it would be nice if you could reference the variables to be formatted by name instead of by position. This can be done by simply passing the dict and using square brackets to access the keys. This could also be done by passing the dictionary as keyword arguments with the notation. This is particularly useful in combination with the built-in function , which returns a dictionary containing all local variables: __name__: __main__; __doc__: None; __package__: None; __loader__: ... As an example, the following lines produce a tidily aligned set of columns giving integers and their squares and cubes: For a complete overview of string formatting with , see Format String Syntax. Here’s the same table of squares and cubes, formatted manually: # Note use of 'end' on previous line The method of string objects right-justifies a string in a field of a given width by padding it with spaces on the left. There are similar methods and . These methods do not write anything, they just return a new string. If the input string is too long, they don’t truncate it, but return it unchanged; this will mess up your column lay-out but that’s usually better than the alternative, which would be lying about a value. (If you really want truncation you can always add a slice operation, as in .) There is another method, , which pads a numeric string on the left with zeros. It understands about plus and minus signs: The % operator (modulo) can also be used for string formatting. Given (where format is a string), conversion specifications in format are replaced with zero or more elements of values. This operation is commonly known as string interpolation. For example: 'The value of pi is approximately The value of pi is approximately 3.142. More information can be found in the printf-style String Formatting section.\n\nreturns a file object, and is most commonly used with two positional arguments and one keyword argument: The first argument is a string containing the filename. The second argument is another string containing a few characters describing the way in which the file will be used. mode can be when the file will only be read, for only writing (an existing file with the same name will be erased), and opens the file for appending; any data written to the file is automatically added to the end. opens the file for both reading and writing. The mode argument is optional; will be assumed if it’s omitted. Normally, files are opened in text mode, that means, you read and write strings from and to the file, which are encoded in a specific encoding. If encoding is not specified, the default is platform dependent (see ). Because UTF-8 is the modern de-facto standard, is recommended unless you know that you need to use a different encoding. Appending a to the mode opens the file in binary mode. Binary mode data is read and written as objects. You can not specify encoding when opening file in binary mode. In text mode, the default when reading is to convert platform-specific line endings ( on Unix, on Windows) to just . When writing in text mode, the default is to convert occurrences of back to platform-specific line endings. This behind-the-scenes modification to file data is fine for text files, but will corrupt binary data like that in or files. Be very careful to use binary mode when reading and writing such files. It is good practice to use the keyword when dealing with file objects. The advantage is that the file is properly closed after its suite finishes, even if an exception is raised at some point. Using is also much shorter than writing equivalent - blocks: # We can check that the file has been automatically closed. If you’re not using the keyword, then you should call to close the file and immediately free up any system resources used by it. Calling without using the keyword or calling might result in the arguments of not being completely written to the disk, even if the program exits successfully. After a file object is closed, either by a statement or by calling , attempts to use the file object will automatically fail. The rest of the examples in this section will assume that a file object called has already been created. To read a file’s contents, call , which reads some quantity of data and returns it as a string (in text mode) or bytes object (in binary mode). size is an optional numeric argument. When size is omitted or negative, the entire contents of the file will be read and returned; it’s your problem if the file is twice as large as your machine’s memory. Otherwise, at most size characters (in text mode) or size bytes (in binary mode) are read and returned. If the end of the file has been reached, will return an empty string ( ). 'This is the entire file.\n\n' reads a single line from the file; a newline character ( ) is left at the end of the string, and is only omitted on the last line of the file if the file doesn’t end in a newline. This makes the return value unambiguous; if returns an empty string, the end of the file has been reached, while a blank line is represented by , a string containing only a single newline. 'This is the first line of the file.\n\n' 'Second line of the file\n\n' For reading lines from a file, you can loop over the file object. This is memory efficient, fast, and leads to simple code: This is the first line of the file. If you want to read all the lines of a file in a list you can also use or . writes the contents of string to the file, returning the number of characters written. Other types of objects need to be converted – either to a string (in text mode) or a bytes object (in binary mode) – before writing them: returns an integer giving the file object’s current position in the file represented as number of bytes from the beginning of the file when in binary mode and an opaque number when in text mode. To change the file object’s position, use . The position is computed from adding offset to a reference point; the reference point is selected by the whence argument. A whence value of 0 measures from the beginning of the file, 1 uses the current file position, and 2 uses the end of the file as the reference point. whence can be omitted and defaults to 0, using the beginning of the file as the reference point. # Go to the 6th byte in the file # Go to the 3rd byte before the end In text files (those opened without a in the mode string), only seeks relative to the beginning of the file are allowed (the exception being seeking to the very file end with ) and the only valid offset values are those returned from the , or zero. Any other offset value produces undefined behaviour. File objects have some additional methods, such as and which are less frequently used; consult the Library Reference for a complete guide to file objects. Strings can easily be written to and read from a file. Numbers take a bit more effort, since the method only returns strings, which will have to be passed to a function like , which takes a string like and returns its numeric value 123. When you want to save more complex data types like nested lists and dictionaries, parsing and serializing by hand becomes complicated. Rather than having users constantly writing and debugging code to save complicated data types to files, Python allows you to use the popular data interchange format called JSON (JavaScript Object Notation). The standard module called can take Python data hierarchies, and convert them to string representations; this process is called serializing. Reconstructing the data from the string representation is called deserializing. Between serializing and deserializing, the string representing the object may have been stored in a file or data, or sent over a network connection to some distant machine. The JSON format is commonly used by modern applications to allow for data exchange. Many programmers are already familiar with it, which makes it a good choice for interoperability. If you have an object , you can view its JSON string representation with a simple line of code: Another variant of the function, called , simply serializes the object to a text file. So if is a text file object opened for writing, we can do this: To decode the object again, if is a binary file or text file object which has been opened for reading: JSON files must be encoded in UTF-8. Use when opening JSON file as a text file for both of reading and writing. This simple serialization technique can handle lists and dictionaries, but serializing arbitrary class instances in JSON requires a bit of extra effort. The reference for the module contains an explanation of this. Contrary to JSON, pickle is a protocol which allows the serialization of arbitrarily complex Python objects. As such, it is specific to Python and cannot be used to communicate with applications written in other languages. It is also insecure by default: deserializing pickle data coming from an untrusted source can execute arbitrary code, if the data was crafted by a skilled attacker."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/python-read-file-open-write-delete-copy",
        "document": "In this tutorial, you will work on the different file operations in Python. You will go over how to use Python to read a file, write to a file, delete files, and much more. File operations are a fundamental aspect of programming, and Python provides a robust set of tools to handle them efficiently.\n\nWe’ll start by understanding how to open files in different modes, such as read, write, and append. Then, we’ll explore how to read from and write to files, including handling different file formats like text and binary files. We’ll also cover how to handle common file-related errors, such as , and best practices for managing file resources using the statement.\n\nIn addition to basic file operations, you will learn more advanced topics like copying and moving files, working with directories, and using libraries like and for file manipulation.\n\nBy the end of this tutorial, you’ll have a comprehensive understanding of file operations in Python and be well-equipped to handle file-related tasks in your projects.\n\nIn the previous tutorial, you used console to take input. Now, we will be taking input using a file. That means, we will read from and write into files. To do so, we need to maintain some steps. Those are-\n• Take input from that file / Write output to that file\n\nWe will also learn some useful operations such as copy file and delete file.\n\nWhy are file operations in Python needed?\n\nWhen working with large datasets in machine learning problems, working with files is a basic necessity. Since Python is a majorly used language for data science, you need to be proficient with the different file operations that Python offers.\n\nSo, let’s explore some of the Python file operations here.\n\n1. Open a file in Python with the open() function\n\nThe first step to working with files in Python is to learn how to open a file. You can open files using the method.\n\nThe open() function in Python accepts two arguments. The first one is the file name along with the complete path and the second one is the file open mode.\n\nBelow, I’ve listed some of the common reading modes for files:\n• ‘r’ : This mode indicate that file will be open for reading only\n• ‘w’ : This mode indicate that file will be open for writing only. If file containing containing that name does not exists, it will create a new one\n• ‘a’ : This mode indicate that the output of that program will be append to the previous output of that file\n• ‘r+’ : This mode indicate that file will be open for both reading and writing\n\nAdditionally, for the Windows operating system, you can append ‘b’ for accessing the file in binary. This is is because Windows differentiates between a binary text file and a regular text file.\n\nSuppose, we place a text file name ‘file.txt’ in the same directory where our code is placed. Now we want to open that file.\n\nHowever, the open(filename, mode) function returns a file object. With that file object you can proceed your further operation.\n\nThe output of the following code will be\n\n2. Read and write to files in Python\n\nPython offers various methods to read and write to files where each functions behaves differently. One important thing to note is the file operations mode. To read a file, you need to open the file in the read or write mode. While to write to a file in Python, you need the file to be open in write mode.\n\nHere are some of the functions in Python that allow you to read and write to files:\n• read() : This function reads the entire file and returns a string\n• readline() : This function reads lines from that file and returns as a string. It fetch the line n, if it is been called nth time.\n• readlines() : This function returns a list where each element is single line of that file.\n• readlines() : This function returns a list where each element is single line of that file.\n• write() : This function writes a fixed sequence of characters to a file.\n• append() : This function append string to the file instead of overwriting the file.\n\nLet’s take an example file “abc.txt”, and read individual lines from the file with a for loop:\n\nNow, that we know how to read a file in Python, let’s move ahead and perform a write operation here with the writelines() function.\n\n3. Copy files in Python using the method\n\nWe can use the shutil module to copy files in Python. This utility allows us to perform copy and move operations in Python on different files. Let’s work on this with an example:\n\n4. Delete files in Python with the method\n\nPython’s shutil module offers the remove() method to delete files from the file system. Let’s take a look at how we can perform a delete operation in Python.\n\n5. Close an open file in Python with the method\n\nWhen you open a file in Python, it’s extremely important to close the file after you make the changes. This saves any changes that you’ve previously made, removes the file from the memory, and prevents any further reads or writes within the program.\n\nSyntax to close an open file in Python:\n\nIf we continue on from our previous examples where we read files, here’s how you’d close the file:\n\nAdditionally, you can avoid closing files manually if you use the with block. As soon as the with block is executed, the files are closed and are no longer available for reading and writing.\n\nIt’s common to receive the FileNotFoundError when working with files in Python. It can be easily avoided by providing complete file paths when creating the file object.\n\nTo fix the , you simply need to verify that the path you’ve mentioned for the file open method is correct.\n\nThese are the most essential file operations in Python. There are many more ways you can use files within Python, including reading and writing plain text files, handling raw strings, and efficiently reading large text files. For more detailed guides, you can refer to the following tutorials:\n• Learn how to handle plain text files in Python to understand the basics of file operations.\n• Understand the usage of raw strings in Python for better handling of file paths and regular expressions.\n• Explore methods to read large text files in Python efficiently to manage memory usage and performance.\n\nAdditionally, here’s an article on how you can use the Pandas module to read CSV datasets in Python.\n\nHow do you remove spaces from a string in Python?\n\nThere are several ways, depending on which spaces you want to remove:\n• To remove all spaces: Use :\n• To remove leading and trailing spaces only: Use :\n• To remove spaces using a regular expression (to handle multiple whitespace types):\n\nHow to remove spaces in string?\n\nTo remove all spaces, use . To remove only leading and trailing spaces, use .\n\nWhat does do in Python?\n\nThe method returns a new string by removing all leading (at the start) and trailing (at the end) whitespace characters. For example:\n\nHow do you remove spaces trim in Python string?\n\nTo “trim” spaces—meaning to remove them only from the start and end of the string—use the method:\n\nWhat is stripping whitespace in Python?\n\n“Stripping whitespace” refers to removing any leading and trailing whitespace characters (including spaces, tabs, and newlines) from a string. The , , and methods are commonly used for this purpose.\n\nHow do I remove part of a string in Python?\n\nTo remove a known substring from a string, you can use :\n\nIf you need to remove content by index, you can use slicing:\n\nWhich method is used to remove whitespace?\n\nThe method is used to remove whitespace from the start and end of a string. For removing whitespace from the entire string, can be used, and for more sophisticated patterns, you can use regular expressions via the module.\n\nHow to remove space in Python print?\n\nWhen using with multiple arguments, Python adds a space by default. To avoid this, you can specify the sep parameter:\n\nIf your string already contains spaces you want to remove, apply or before printing:"
    },
    {
        "link": "https://w3schools.com/python/python_file_handling.asp",
        "document": "File handling is an important part of any web application.\n\nPython has several functions for creating, reading, updating, and deleting files.\n\nThe key function for working with files in Python is the function.\n\nThe function takes two parameters; filename, and mode.\n\nThere are four different methods (modes) for opening a file:\n\n- Read - Default value. Opens a file for reading, error if the file does not exist - Append - Opens a file for appending, creates the file if it does not exist - Write - Opens a file for writing, creates the file if it does not exist - Create - Creates the specified file, returns an error if the file exists\n\nIn addition you can specify if the file should be handled as binary or text mode\n\nTo open a file for reading it is enough to specify the name of the file:\n\nThe code above is the same as:\n\nBecause for read, and for text are the default values, you do not need to specify them.\n\nNote: Make sure the file exists, or else you will get an error."
    },
    {
        "link": "https://geeksforgeeks.org/file-handling-python",
        "document": "File handling refers to the process of performing operations on a file such as creating, opening, reading, writing and closing it, through a programming interface. It involves managing the data flow between the program and the file system on the storage device, ensuring that data is handled safely and efficiently.\n\nTo open a file we can use function, which requires file path and mode as arguments:\n\nWhen opening a file, we must specify the mode we want to which specifies what we want to do with the file. Here’s a table of the different modes available:\n\nOpens the file for reading. File must exist; otherwise, it raises an error. Opens the file for reading binary data. File must exist; otherwise, it raises an error. Opens the file for both reading and writing. File must exist; otherwise, it raises an error. Opens the file for both reading and writing binary data. File must exist; otherwise, it raises an error. Opens the file for writing. Creates a new file or truncates the existing file. Opens the file for writing binary data. Creates a new file or truncates the existing file. Opens the file for both writing and reading. Creates a new file or truncates the existing file. Opens the file for both writing and reading binary data. Creates a new file or truncates the existing file. Opens the file for appending data. Creates a new file if it doesn’t exist. Opens the file for appending binary data. Creates a new file if it doesn’t exist. Opens the file for appending and reading. Creates a new file if it doesn’t exist. Opens the file for appending and reading binary data. Creates a new file if it doesn’t exist. Creates a new file. Raises an error if the file already exists. Creates a new binary file. Raises an error if the file already exists. Creates a new file for reading and writing. Raises an error if the file exists. Exclusive creation with read and write in binary mode. Creates a new binary file for reading and writing. Raises an error if the file exists.\n\nFor this article we are using text file with text:\n\nReading a file can be achieved by file.read() which reads the entire content of the file. After reading the file we can close the file using file.close() which closes the file after reading it, which is necessary to free up system resources.\n\nWriting to a file is done using file.write() which writes the specified string to the file. If the file exists, its content is erased. If it doesn’t exist, a new file is created.\n\nExample: Writing to a File in Write Mode (w)\n\nIt is done using adds the specified string to the end of the file without erasing its existing content.\n\nExample: For this example, we will use the Python file created in the previous example.\n\nClosing a file is essential to ensure that all resources used by the file are properly released. loses the file and ensures that any changes made to the file are saved.\n\nstatement is used for resource management. It ensures that file is properly closed after its suite finishes, even if an exception is raised. with open() as method automatically handles closing the file once the block of code is exited, even if an error occurs. This reduces the risk of file corruption and resource leakage.\n\nIt’s important to handle exceptions to ensure that files are closed properly, even if an error occurs during file operations.\n• None Versatility : File handling in Python allows us to perform a wide range of operations, such as creating, reading, writing, appending, renaming and deleting files.\n• Flexibility : File handling in Python is highly flexible, as it allows us to work with different file types (e.g. text files, binary files, CSV files , etc.) and to perform different operations on files (e.g. read, write, append, etc.).\n• User – friendly : Python provides a user-friendly interface for file handling, making it easy to create, read and manipulate files.\n• Cross-platform : Python file-handling functions work across different platforms (e.g. Windows, Mac, Linux), allowing for seamless integration and compatibility.\n• Error-prone: File handling operations in Python can be prone to errors, especially if the code is not carefully written or if there are issues with the file system (e.g. file permissions, file locks, etc.).\n• Security risks : File handling in Python can also pose security risks, especially if the program accepts user input that can be used to access or modify sensitive files on the system.\n• Complexity : File handling in Python can be complex, especially when working with more advanced file formats or operations. Careful attention must be paid to the code to ensure that files are handled properly and securely.\n• Performance : File handling operations in Python can be slower than other programming languages, especially when dealing with large files or performing complex operations.\n\nWhat are the types of files in Python?\n\nWhat are the 4 file handling functions?\n\nWhy is file handling useful?\n\nIn Python file handling, is a method of file objects that returns the current position of the file pointer (cursor) within the file. It returns an integer representing the byte offset from the beginning of the file where the next read or write operation will occur. # Open a file in read mode file = open('example.txt', 'r') # Read the first 10 characters content = file.read(10) print(content) # Check the current position of the file pointer position = file.tell() print(\"Current position:\", position) # Close the file file.close()\n• None reads the first 10 characters from the file.\n• None returns the current position of the file pointer after reading."
    },
    {
        "link": "https://realpython.com/read-write-files-python",
        "document": "One of the most common tasks that you can do with Python is reading and writing files. Whether it’s writing to a simple text file, reading a complicated server log, or even analyzing raw byte data, all of these situations require reading or writing a file.\n• What makes up a file and why that’s important in Python\n• The basics of reading and writing files in Python\n• Some basic scenarios of reading and writing files\n\nThis tutorial is mainly for beginner to intermediate Pythonistas, but there are some tips in here that more advanced programmers may appreciate as well.\n\nBefore we can go into how to work with files in Python, it’s important to understand what exactly a file is and how modern operating systems handle some of their aspects. At its core, a file is a contiguous set of bytes used to store data. This data is organized in a specific format and can be anything as simple as a text file or as complicated as a program executable. In the end, these byte files are then translated into binary and for easier processing by the computer. Files on most modern file systems are composed of three main parts:\n• Header: metadata about the contents of the file (file name, size, type, and so on)\n• Data: contents of the file as written by the creator or editor\n• End of file (EOF): special character that indicates the end of the file What this data represents depends on the format specification used, which is typically represented by an extension. For example, a file that has an extension of most likely conforms to the Graphics Interchange Format specification. There are hundreds, if not thousands, of file extensions out there. For this tutorial, you’ll only deal with or file extensions. When you access a file on an operating system, a file path is required. The file path is a string that represents the location of a file. It’s broken up into three major parts:\n• Folder Path: the file folder location on the file system where subsequent folders are separated by a forward slash (Unix) or backslash (Windows)\n• File Name: the actual name of the file\n• Extension: the end of the file path pre-pended with a period ( ) used to indicate the file type Here’s a quick example. Let’s say you have a file located within a file structure like this: Let’s say you wanted to access the file, and your current location was in the same folder as . In order to access the file, you need to go through the folder and then the folder, finally arriving at the file. The Folder Path is . The File Name is . The File Extension is . So the full path is . Now let’s say that your current location or current working directory (cwd) is in the folder of our example folder structure. Instead of referring to the by the full path of , the file can be simply referenced by the file name and extension . / │ ├── path/ | │ | ├── to/ ← Your current working directory (cwd) is here | │ └── cats.gif ← Accessing this file | │ | └── dog_breeds.txt | └── animals.csv But what about ? How would you access that without using the full path? You can use the special characters double-dot ( ) to move one directory up. This means that will reference the file from the directory of : / │ ├── path/ ← Referencing this parent folder | │ | ├── to/ ← Current working directory (cwd) | │ └── cats.gif | │ | └── dog_breeds.txt ← Accessing this file | └── animals.csv The double-dot ( ) can be chained together to traverse multiple directories above the current directory. For example, to access from the folder, you would use . One problem often encountered when working with file data is the representation of a new line or line ending. The line ending has its roots from back in the Morse Code era, when a specific pro-sign was used to communicate the end of a transmission or the end of a line. Later, this was standardized for teleprinters by both the International Organization for Standardization (ISO) and the American Standards Association (ASA). ASA standard states that line endings should use the sequence of the Carriage Return ( or ) and the Line Feed ( or ) characters ( or ). The ISO standard however allowed for either the characters or just the character. Windows uses the characters to indicate a new line, while Unix and the newer Mac versions use just the character. This can cause some complications when you’re processing files on an operating system that is different than the file’s source. Here’s a quick example. Let’s say that we examine the file that was created on a Windows system: This same output will be interpreted on a Unix device differently: This can make iterating over each line problematic, and you may need to account for situations like this. Another common problem that you may face is the encoding of the byte data. An encoding is a translation from byte data to human readable characters. This is typically done by assigning a numerical value to represent a character. The two most common encodings are the ASCII and UNICODE Formats. ASCII can only store 128 characters, while Unicode can contain up to 1,114,112 characters. ASCII is actually a subset of Unicode (UTF-8), meaning that ASCII and Unicode share the same numerical to character values. It’s important to note that parsing a file with the incorrect character encoding can lead to failures or misrepresentation of the character. For example, if a file was created using the UTF-8 encoding, and you try to parse it using the ASCII encoding, if there is a character that is outside of those 128 values, then an error will be thrown.\n\nWhen you want to work with a file, the first thing to do is to open it. This is done by invoking the built-in function. has a single required argument that is the path to the file. has a single return, the file object: After you open a file, the next thing to learn is how to close it. Warning: You should always make sure that an open file is properly closed. To learn why, check out the Why Is It Important to Close Files in Python? tutorial. It’s important to remember that it’s your responsibility to close the file. In most cases, upon termination of an application or script, a file will be closed eventually. However, there is no guarantee when exactly that will happen. This can lead to unwanted behavior including resource leaks. It’s also a best practice within Python (Pythonic) to make sure that your code behaves in a way that is well defined and reduces any unwanted behavior. When you’re manipulating a file, there are two ways that you can use to ensure that a file is closed properly, even when encountering an error. The first way to close a file is to use the block: # Further file processing goes here If you’re unfamiliar with what the block is, check out Python Exceptions: An Introduction. The second way to close a file is to use the statement: # Further file processing goes here The statement automatically takes care of closing the file once it leaves the block, even in cases of error. I highly recommend that you use the statement as much as possible, as it allows for cleaner code and makes handling any unexpected errors easier for you. Most likely, you’ll also want to use the second positional argument, . This argument is a string that contains multiple characters to represent how you want to open the file. The default and most common is , which represents opening the file in read-only mode as a text file: # Further file processing goes here Other options for modes are fully documented online, but the most commonly used ones are the following: Open for writing, truncating (overwriting) the file first Let’s go back and talk a little about file objects. A file object is: “an object exposing a file-oriented API (with methods such as or ) to an underlying resource.” (Source) There are three different categories of file objects: Each of these file types are defined in the module. Here’s a quick rundown of how everything lines up. A text file is the most common file that you’ll encounter. Here are some examples of how these files are opened: With these types of files, will return a file object: This is the default file object returned by . A buffered binary file type is used for reading and writing binary files. Here are some examples of how these files are opened: With these types of files, will return either a or file object: “generally used as a low-level building-block for binary and text streams.” (Source) It is therefore not typically used. Here’s an example of how these files are opened: With these types of files, will return a file object:\n\nOnce you’ve opened up a file, you’ll want to read or write to the file. First off, let’s cover reading a file. There are multiple methods that can be called on a file object to help you out: What It Does This reads from the file based on the number of bytes. If no argument is passed or or is passed, then the entire file is read. This reads at most number of characters from the line. This continues to the end of the line and then wraps back around. If no argument is passed or or is passed, then the entire line (or rest of the line) is read. This reads the remaining lines from the file object and returns them as a list. Using the same file you used above, let’s go through some examples of how to use these methods. Here’s an example of how to open and read the entire file using : Here’s an example of how to read 5 bytes of a line each time using the Python method: # Read & print the first 5 characters of the line 5 times # Notice that line is greater than the 5 chars and continues # down the line, reading 5 chars each time until the end of the # line and then \"wraps\" around Here’s an example of how to read the entire file as a list using the Python method: The above example can also be done by using to create a list out of the file object: Iterating Over Each Line in the File A common thing to do while reading a file is to iterate over each line. Here’s an example of how to use the Python method to perform that iteration: # Read and print the entire file line by line # The EOF char is an empty string Another way you could iterate over each line in the file is to use the Python method of the file object. Remember, returns a list where each element in the list represents a line in the file: However, the above examples can be further simplified by iterating over the file object itself: # Read and print the entire file line by line This final approach is more Pythonic and can be quicker and more memory efficient. Therefore, it is suggested you use this instead. Note: Some of the above examples contain . The is to prevent Python from adding an additional newline to the text that is being printed and only print what is being read from the file. Now let’s dive into writing files. As with reading files, file objects have multiple methods that are useful for writing to a file: What It Does This writes the string to the file. This writes the sequence to the file. No line endings are appended to each sequence item. It’s up to you to add the appropriate line ending(s). Here’s a quick example of using and : # Alternatively you could use # Write the dog breeds to the file in reversed order Sometimes, you may need to work with files using byte strings. This is done by adding the character to the argument. All of the same methods for the file object apply. However, each of the methods expect and return a object instead: Opening a text file using the flag isn’t that interesting. Let’s say we have this cute picture of a Jack Russell Terrier ( ): You can actually open that file in Python and examine the contents! Since the file format is well defined, the header of the file is 8 bytes broken up like this: A “magic” number to indicate that this is the start of a Sure enough, when you open the file and read these bytes individually, you can see that this is indeed a header file: Let’s bring this whole thing home and look at a full example of how to read and write to a file. The following is a like tool that will convert a file that contains line endings of to . This tool is broken up into three major sections. The first is , which converts a string from line endings to . The second is , which converts a string that contains characters into . calls internally. Finally, there’s the block, which is called only when the file is executed as a script. Think of it as the function found in other programming languages. A simple script and library to convert files or strings from dos like Converts the string from \\r\n\n line endings to \n\n The string whose line endings will be converted Converts a file that contains Dos like line endings into Unix like The path to the source file to be converted The path to the converted file for output # Create our Argument parser and set its description \"Script that converts a DOS like file to an Unix like file\" # - source_file: the source file we want to convert # - dest_file: the destination where the output should go # Note: the use of the argument type of argparse.FileType could 'The location of the source ' # Parse the args (argparse automatically grabs the values from # If the destination file wasn't passed, then assume we want to # create a new file based on the old one\n\nNow that you’ve mastered the basics of reading and writing files, here are some tips and tricks to help you grow your skills. The attribute is a special attribute of modules, similar to . It is: “the pathname of the file from which the module was loaded, if it was loaded from a file.” (Source Note: To re-iterate, returns the path relative to where the initial Python script was called. If you need the full system path, you can use to get the current working directory of your executing code. Here’s a real world example. In one of my past jobs, I did multiple tests for a hardware device. Each test was written using a Python script with the test script file name used as a title. These scripts would then be executed and could print their status using the special attribute. Here’s an example folder structure: I was able to run and get the status of all my tests dynamically through use of the special attribute. Sometimes, you may want to append to a file or start writing at the end of an already populated file. This is easily done by using the character for the argument: When you examine again, you’ll see that the beginning of the file is unchanged and is now added to the end of the file: Working With Two Files at the Same Time There are times when you may want to read a file and write to another file at the same time. If you use the example that was shown when you were learning how to write to a file, it can actually be combined into the following: There may come a time when you’ll need finer control of the file object by placing it inside a custom class. When you do this, using the statement can no longer be used unless you add a few magic methods: and . By adding these, you’ll have created what’s called a context manager. is invoked when calling the statement. is called upon exiting from the statement block. Here’s a template that you can use to make your custom class: Now that you’ve got your custom class that is now a context manager, you can use it similarly to the built-in: Here’s a good example. Remember the cute Jack Russell image we had? Perhaps you want to open other files but don’t want to parse the header file each time. Here’s an example of how to do this. This example also uses custom iterators. If you’re not familiar with them, check out Python Iterators: # Every .png file contains this in the header. Use it to verify # the file is indeed a .png. # Ensure the file has the right extension \"The File is not a properly formatted .png file!\" # This and __next__() are used to create a custom iterator # The file hasn't been opened or reached EOF. This means we # can't go any further so stop the iteration by raising the # Each chunk has a len, type, data (based on len) and crc # Grab these values and return them as a tuple You can now open files and properly parse them using your custom context manager:"
    },
    {
        "link": "https://stackoverflow.com/questions/5627425/what-is-a-good-way-to-handle-exceptions-when-trying-to-read-a-file-in-python",
        "document": "I updated Tim Pietzcker answer, because it uses Python 2 which is not maintained anymore.\n\nI tried to edit the answer first, but I got: edit queue is full, so I could not.\n\nYou should check the errno number of your exception, which helps you narrow down the error\n\nYou should write error and log messages into and not into (default for print), because then you can redirect your error messages into a different file.\n\nYou should return a non-zero exit code (documented here) which is a must if you want to make your python code usable in a Unix environment, such as a shell script:"
    },
    {
        "link": "https://thedkpatel.medium.com/10-best-practices-for-secure-and-efficient-file-handling-in-python-part-1-6a102a80e166",
        "document": "In this article, we explore Python file handling best practices, highlighting both bad and good approaches.\n\nFile handling is an essential part of many Python applications. Proper file handling ensures data integrity, prevents data loss, and makes your applications robust.\n\nNeglecting to close files can lead to resource leaks and data corruption.\n\nFile operations can fail due to various reasons (e.g., missing files, permission issues). Always handle exceptions gracefully."
    },
    {
        "link": "https://stackoverflow.com/questions/491921/unicode-utf-8-reading-and-writing-to-files-in-python",
        "document": "You have stumbled over the general problem with encodings: How can I tell in which encoding a file is?\n\nAnswer: You can't unless the file format provides for this. XML, for example, begins with:\n\nThis header was carefully chosen so that it can be read no matter the encoding. In your case, there is no such hint, hence neither your editor nor Python has any idea what is going on. Therefore, you must use the module and use which provides the missing bit in Python.\n\nAs for your editor, you must check if it offers some way to set the encoding of a file.\n\nThe point of UTF-8 is to be able to encode 21-bit characters (Unicode) as an 8-bit data stream (because that's the only thing all computers in the world can handle). But since most OSs predate the Unicode era, they don't have suitable tools to attach the encoding information to files on the hard disk.\n\nThe next issue is the representation in Python. This is explained perfectly in the comment by heikogerlach. You must understand that your console can only display ASCII. In order to display Unicode or anything >= charcode 128, it must use some means of escaping. In your editor, you must not type the escaped display string but what the string means (in this case, you must enter the umlaut and save the file).\n\nThat said, you can use the Python function eval() to turn an escaped string into a string:\n\nAs you can see, the string \"\\xc3\" has been turned into a single character. This is now an 8-bit string, UTF-8 encoded. To get Unicode:\n\nGregg Lind asked: I think there are some pieces missing here: the file f2 contains: hex:\n\n, for example, reads them all in a separate chars (expected) Is there any way to write to a file in ASCII that would work?\n\nAnswer: That depends on what you mean. ASCII can't represent characters > 127. So you need some way to say \"the next few characters mean something special\" which is what the sequence \"\\x\" does. It says: The next two characters are the code of a single character. \"\\u\" does the same using four characters to encode Unicode up to 0xFFFF (65535).\n\nSo you can't directly write Unicode to ASCII (because ASCII simply doesn't contain the same characters). You can write it as string escapes (as in f2); in this case, the file can be represented as ASCII. Or you can write it as UTF-8, in which case, you need an 8-bit safe stream.\n\nYour solution using does work, but you must be aware how much memory you use: Three times the amount of using .\n\nRemember that a file is just a sequence of bytes with 8 bits. Neither the bits nor the bytes have a meaning. It's you who says \"65 means 'A'\". Since should become \"à\" but the computer has no means to know, you must tell it by specifying the encoding which was used when writing the file."
    }
]