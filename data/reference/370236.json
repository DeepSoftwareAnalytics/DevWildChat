[
    {
        "link": "https://typescriptlang.org/docs/handbook/utility-types.html",
        "document": ""
    },
    {
        "link": "https://typescriptlang.org/docs/handbook/advanced-types.html",
        "document": "This page lists some of the more advanced ways in which you can model types, it works in tandem with the Utility Types doc which includes types which are included in TypeScript and available globally.\n\nUnion types are useful for modeling situations when values can overlap in the types they can take on. What happens when we need to know specifically whether we have a ? A common idiom in JavaScript to differentiate between two possible values is to check for the presence of a member. As we mentioned, you can only access members that are guaranteed to be in all the constituents of a union type.\n\nTo get the same code working via property accessors, we’ll need to use a type assertion:\n\nThis isn’t the sort of code you would want in your codebase however.\n\nIt would be much better if once we performed the check, we could know the type of within each branch.\n\nIt just so happens that TypeScript has something called a type guard. A type guard is some expression that performs a runtime check that guarantees the type in some scope.\n\nTo define a type guard, we simply need to define a function whose return type is a type predicate:\n\nis our type predicate in this example. A predicate takes the form , where must be the name of a parameter from the current function signature.\n\nAny time is called with some variable, TypeScript will narrow that variable to that specific type if the original type is compatible.\n\nNotice that TypeScript not only knows that is a in the branch; it also knows that in the branch, you don’t have a , so you must have a .\n\nYou may use the type guard to filter an array of and obtain an array of :\n\nThe operator also acts as a narrowing expression for types.\n\nFor a expression, where is a string literal or string literal type and is a union type, the “true” branch narrows to types which have an optional or required property , and the “false” branch narrows to types which have an optional or missing property .\n\nLet’s go back and write the code for a version of which uses union types. We could write it with type predicates as follows:\n\nHowever, having to define a function to figure out if a type is a primitive is kind of a pain. Luckily, you don’t need to abstract into its own function because TypeScript will recognize it as a type guard on its own. That means we could just write these checks inline.\n\nThese type guards are recognized in two different forms: and , where can be one of operator’s return values ( , , , , , , , or ). While TypeScript won’t stop you from comparing to other strings, the language won’t recognize those expressions as type guards.\n\nIf you’ve read about type guards and are familiar with the operator in JavaScript, you probably have some idea of what this section is about.\n\ntype guards are a way of narrowing types using their constructor function. For instance, let’s borrow our industrial strength string-padder example from earlier:\n\nThe right side of the needs to be a constructor function, and TypeScript will narrow down to:\n• the type of the function’s property if its type is not\n• the union of types returned by that type’s construct signatures\n\nTypeScript has two special types, and , that have the values null and undefined respectively. We mentioned these briefly in the Basic Types section.\n\nBy default, the type checker considers and assignable to anything. Effectively, and are valid values of every type. That means it’s not possible to stop them from being assigned to any type, even when you would like to prevent it. The inventor of , Tony Hoare, calls this his “billion dollar mistake”.\n\nThe flag fixes this: when you declare a variable, it doesn’t automatically include or . You can include them explicitly using a union type:\n\nNote that TypeScript treats and differently in order to match JavaScript semantics. is a different type than and .\n\nFrom TypeScript 3.7 and onwards, you can use optional chaining to simplify working with nullable types.\n\nThe same is true for optional properties:\n\nSince nullable types are implemented with a union, you need to use a type guard to get rid of the . Fortunately, this is the same code you’d write in JavaScript:\n\nThe elimination is pretty obvious here, but you can use terser operators too:\n\nIn cases where the compiler can’t eliminate or , you can use the type assertion operator to manually remove them. The syntax is postfix : removes and from the type of :\n\nType aliases create a new name for a type. Type aliases are sometimes similar to interfaces, but can name primitives, unions, tuples, and any other types that you’d otherwise have to write by hand.\n\nAliasing doesn’t actually create a new type - it creates a new name to refer to that type. Aliasing a primitive is not terribly useful, though it can be used as a form of documentation.\n\nJust like interfaces, type aliases can also be generic - we can just add type parameters and use them on the right side of the alias declaration:\n\nWe can also have a type alias refer to itself in a property:\n\nTogether with intersection types, we can make some pretty mind-bending types:\n\nAs we mentioned, type aliases can act sort of like interfaces; however, there are some subtle differences.\n\nAlmost all features of an are available in , the key distinction is that a type cannot be re-opened to add new properties vs an interface which is always extendable.\n\nBecause an interface more closely maps how JavaScript objects work by being open to extension, we recommend using an interface over a type alias when possible.\n\nOn the other hand, if you can’t express some shape with an interface and you need to use a union or tuple type, type aliases are usually the way to go.\n\nAs mentioned in our section on enums, enum members have types when every member is literal-initialized.\n\nMuch of the time when we talk about “singleton types”, we’re referring to both enum member types as well as numeric/string literal types, though many users will use “singleton types” and “literal types” interchangeably.\n\nA polymorphic type represents a type that is the subtype of the containing class or interface. This is called F-bounded polymorphism, a lot of people know it as the fluent API pattern. This makes hierarchical fluent interfaces much easier to express, for example. Take a simple calculator that returns after each operation:\n\nSince the class uses types, you can extend it and the new class can use the old methods with no changes.\n\nWithout types, would not have been able to extend and keep the fluent interface. would have returned , which doesn’t have the method. However, with types, returns , which is here.\n\nWith index types, you can get the compiler to check code that uses dynamic property names. For example, a common JavaScript pattern is to pick a subset of properties from an object:\n\nHere’s how you would write and use this function in TypeScript, using the index type query and indexed access operators:\n\nThe compiler checks that and are actually properties on . The example introduces a couple of new type operators. First is , the index type query operator. For any type , is the union of known, public property names of . For example:\n\nis completely interchangeable with . The difference is that if you add another property to , say , then will automatically update to be . And you can use in generic contexts like , where you can’t possibly know the property names ahead of time. That means the compiler will check that you pass the right set of property names to :\n\nThe second operator is , the indexed access operator. Here, the type syntax reflects the expression syntax. That means that has the type — which in our example is just . However, just like index type queries, you can use in a generic context, which is where its real power comes to life. You just have to make sure that the type variable . Here’s another example with a function named .\n\nIn , and , so that means . Once you return the result, the compiler will instantiate the actual type of the key, so the return type of will vary according to which property you request.\n\nand interact with index signatures. An index signature parameter type must be ‘string’ or ‘number’. If you have a type with a string index signature, will be (and not just , since in JavaScript you can access an object property either by using strings ( ) or numbers ( )). And is just the type of the index signature:\n\nIf you have a type with a number index signature, will just be .\n\nA common task is to take an existing type and make each of its properties optional:\n\nOr we might want a readonly version:\n\nThis happens often enough in JavaScript that TypeScript provides a way to create new types based on old types — mapped types. In a mapped type, the new type transforms each property in the old type in the same way. For example, you can make all properties optional or of a type . Here are a couple of examples:\n\nAnd to use it:\n\nNote that this syntax describes a type rather than a member. If you want to add members, you can use an intersection type:\n\nLet’s take a look at the simplest mapped type and its parts:\n\nThe syntax resembles the syntax for index signatures with a inside. There are three parts:\n• The type variable , which gets bound to each property in turn.\n• The string literal union , which contains the names of properties to iterate over.\n• The resulting type of the property.\n\nIn this simple example, is a hard-coded list of property names and the property type is always , so this mapped type is equivalent to writing:\n\nReal applications, however, look like or above. They’re based on some existing type, and they transform the properties in some way. That’s where and indexed access types come in:\n\nBut it’s more useful to have a general version.\n\nIn these examples, the properties list is and the resulting type is some variant of . This is a good template for any general use of mapped types. That’s because this kind of transformation is homomorphic, which means that the mapping applies only to properties of and no others. The compiler knows that it can copy all the existing property modifiers before adding any new ones. For example, if was readonly, would be readonly and optional.\n\nHere’s one more example, in which is wrapped in a class:\n\nNote that and are so useful, they are included in TypeScript’s standard library along with and :\n\n, and are homomorphic whereas is not. One clue that is not homomorphic is that it doesn’t take an input type to copy properties from:\n\nNon-homomorphic types are essentially creating new properties, so they can’t copy property modifiers from anywhere.\n\nNote that represents the type of any value that can be used as an index to an object. In otherwords, is currently equal to .\n\nNow that you know how to wrap the properties of a type, the next thing you’ll want to do is unwrap them. Fortunately, that’s pretty easy:\n\nNote that this unwrapping inference only works on homomorphic mapped types. If the mapped type is not homomorphic you’ll have to give an explicit type parameter to your unwrapping function.\n\nA conditional type selects one of two possible types based on a condition expressed as a type relationship test:\n\nThe type above means when is assignable to the type is , otherwise the type is .\n\nA conditional type is either resolved to or , or deferred because the condition depends on one or more type variables. When or contains type variables, whether to resolve to or , or to defer, is determined by whether or not the type system has enough information to conclude that is always assignable to .\n\nAs an example of some types that are immediately resolved, we can take a look at the following example:\n\nAnother example would be the type alias, which uses nested conditional types:\n\nBut as an example of a place where conditional types are deferred - where they stick around instead of picking a branch - would be in the following:\n\nIn the above, the variable has a conditional type that hasn’t yet chosen a branch. When another piece of code ends up calling , it will substitute in with some other type, and TypeScript will re-evaluate the conditional type, deciding whether it can actually pick a branch.\n\nIn the meantime, we can assign a conditional type to any other target type as long as each branch of the conditional is assignable to that target. So in our example above we were able to assign to since no matter what the conditional evaluates to, it’s known to be either or .\n\nConditional types in which the checked type is a naked type parameter are called distributive conditional types. Distributive conditional types are automatically distributed over union types during instantiation. For example, an instantiation of with the type argument for is resolved as .\n\nIn instantiations of a distributive conditional type , references to within the conditional type are resolved to individual constituents of the union type (i.e. refers to the individual constituents after the conditional type is distributed over the union type). Furthermore, references to within have an additional type parameter constraint (i.e. is considered assignable to within ).\n\nNotice that has the additional constraint within the true branch of and it is therefore possible to refer to the element type of the array as . Also, notice how the conditional type is distributed over the union type in the last example.\n\nThe distributive property of conditional types can conveniently be used to filter union types:\n\nConditional types are particularly useful when combined with mapped types:\n\nNote, conditional types are not permitted to reference themselves recursively. For example the following is an error.\n\nWithin the clause of a conditional type, it is now possible to have declarations that introduce a type variable to be inferred. Such inferred type variables may be referenced in the true branch of the conditional type. It is possible to have multiple locations for the same type variable.\n\nFor example, the following extracts the return type of a function type:\n\nConditional types can be nested to form a sequence of pattern matches that are evaluated in order:\n\nThe following example demonstrates how multiple candidates for the same type variable in co-variant positions causes a union type to be inferred:\n\nLikewise, multiple candidates for the same type variable in contra-variant positions causes an intersection type to be inferred:\n\nWhen inferring from a type with multiple call signatures (such as the type of an overloaded function), inferences are made from the last signature (which, presumably, is the most permissive catch-all case). It is not possible to perform overload resolution based on a list of argument types.\n\nIt is not possible to use declarations in constraint clauses for regular type parameters:\n\nHowever, much the same effect can be obtained by erasing the type variables in the constraint and instead specifying a conditional type:\n\nTypeScript adds several predefined conditional types, you can find the full list and examples in Utility Types."
    },
    {
        "link": "https://refine.dev/blog/typescript-partial-utility-type",
        "document": "This article was last updated on November 18, 2024, to include a clear introduction to TypeScript partial and its practical use cases.\n\nWhat is TypeScript Partial? is a utility type in TypeScript which represents all properties of a given type are optional.\n\nIn this article, we discuss object type transformations in TypeScript using . This is the third part of the series titled TypeScript Utility Type Series.\n\nIn the previous post, we went through an example where we derived a type by omitting a property from the base type, , with .\n\nIn this post, we will consider an example of TypeScript by modifying our type to assume a more realistic scenario.\n\nFor our blog, we would have s who are not allowed to like or comment on a post. We would allow registered s to like and comment. So, the scenario goes:\n• a must register with their and become a .\n• they receive a link to set their password in an email sent to their .\n• they are able to set their , and afterwards.\n\nIn such a scenario, the type we derived previously, which effectively has the shape below, does not deliver our needs the way we want:\n\nTypeScript complains about the inconformity of to type. This is because it sets all the fields to be required by default. If we set , and to optional manually, it is happy:\n\nBut this comes with the overhead of defining manually in the first place and additionally then setting individual optional properties. In real APIs, it's not a good idea to define a shape manually.\n\nWe want to remove the hassle and do this much more comfortably from the type returned from . So what we want to do is set all the properties of the returned type to be optional with :\n\nNo complains, which is great!\n\nSo, we are now free to set values for , and :\n\nBut, like before, TypeScript complains again if we add the properties that disrupts the shape of :\n\nSo, the benefits of using TypeScript to derive a partial type includes its support for partial assignment of the object's properties that is allowed by JavaScript and not allowed by default TypeScript. It also warns about possible undesired assignments to the partial.\n\nWe get the same result if we use an interface for our base type:\n\nWe can also refactor the return type from into an intermediary type, , and pass it as the argument of TypeScript Partial:\n• API Responses: When some of the fields are not returned at all. Example: Fetching user data with optional fields.\n• Form Handling: Partial data in forms that might have some input fields not filled.\n• Object Updates: Every time any part of an already existing object is updated, that does not imply all fields are modified.\n\nQ: What is in TypeScript?\n\nA: Well, is a utility type that makes every property of a type optional.\n\nQ: Can I use Partial with interfaces?\n\nA: Yes, absolutely, works for both types and interfaces.\n\nQ: How is Partial different from Pick?\n\nA: makes all properties optional; selects some properties from a type.\n\nIn this post, we covered partial object transformations with using the utility transformer Partial. We found out that it is preferable to setting certain properties of a type to optional manually, especially when dealing with types returned from APIs."
    },
    {
        "link": "https://geeksforgeeks.org/typescript-partialtype-utility-type",
        "document": "The Partial<Type> utility in TypeScript creates a new type by making all properties of an existing type optional. This allows you to create flexible object types where only some properties are required, streamlining code and reducing redundancy when working with complex data structures.\n\nPartial<Type> is a TypeScript utility type that transforms all properties of a given type T into optional properties. This simplifies creating objects with optional properties, saving time and reducing the likelihood of introducing errors.\n• T: T is the type we want to make partial.\n• keyof: This operator is used to a union of all the property names in T.\n• ? operator: It is used set the property to optional.\n\nApproach: If we already have a typescript interface with some properties, and all of the properties are initially required. Now let’s say, we have a scenario where we need to use the already existing interface but we don’t need all its properties of it has, so instead of making a new interface with some of its properties, we can use the same interface and create a new type with all the properties of it optional by using the Partial<Type>, so in that case we can use any properties to do the job.\n\nExample 1: Using the Partial<Type> Utility in TypeScript\n• Original Interface: The User interface has required properties: name, age, and email.\n• Partial Transformation: Partial<User> creates a new type with all properties optional.\n• Object Creation: The updateUser object only defines name, making age and email optional.\n\nExample 2: Using Partial<Type> in a Function\n• Original Type: The User type has mandatory name and age properties.\n• Function Output: When called, getUser handles both complete and incomplete User objects, defaulting age to “Unknown” if missing.\n\nIn this article, we explored the Partial<Type> utility type in TypeScript, its syntax, and practical examples demonstrating how to use it. Partial<Type> is a useful tool for creating new types with only some of the properties of an existing type, especially helpful when working with complex objects or functions that require many properties to be defined. By using Partial<Type>, developers can write cleaner, more maintainable code and avoid redundant type definitions.\n\nHow does Partial<Type> differ from Required<Type>?\n\nDoes Partial<Type> affect method types within an interface?\n\nCan Partial<Type> be combined with other utility types in TypeScript?\n\nHow do I create a partial type for a specific set of properties?"
    },
    {
        "link": "https://graphite.dev/guides/typescript-omit-utility-type",
        "document": "TypeScript's type is a utility that allows developers to create new types by excluding specific properties from an existing type. This utility is particularly useful for creating types that are subsets of other types, but with fewer properties.\n\nThis guide will explore how to effectively use in TypeScript, including handling multiple properties and applying to various use cases like object types and class properties.\n\nThe type is a utility in TypeScript that constructs a new type by picking all properties from an existing type but excluding a set of keys. The syntax for is:\n• is the original type you are modifying.\n• is the property or properties to omit from the .\n\nHow to use Omit in TypeScript\n\nHere’s a step-by-step process on how to use in various scenarios:\n• None\n• None Suppose you have a type and you want to create a new type that excludes the property:\n• None will have only the and properties.\n• None\n• None If you need to omit more than one property, you can list them in the utility separated by a comma within the type literal:\n• None This will create a type that includes only the property.\n• None\n• None Sometimes, you might want to create a type where some properties are optional and some are omitted entirely. This can be achieved by combining and :\n• None This type makes and optional but completely omits .\n• None\n• None can be particularly useful in functions where you want to ensure certain object properties are not passed:\n• None This function will accept an object of type but without the property.\n• None\n• None When working with classes, you can use to define types that are used for instance creation without certain properties:\n• None This constructor allows creating a object without the property.\n• Form handling: Use to exclude sensitive properties that should not be manipulated through forms.\n• API responses: When fetching data from an API, use to exclude properties that are not relevant or sensitive.\n• Component props: In React or other UI libraries, use to exclude certain props from being passed to a component.\n\nFor further reading on in TypeScript see the official documentation."
    },
    {
        "link": "https://medium.com/@asyncme/a-guide-to-creating-charts-in-react-with-typescript-8ac9fd17fa74",
        "document": "Visualizing data is a critical component of many modern web applications, and using charts effectively can significantly improve user experience. React, with its declarative nature, combined with TypeScript’s strong typing system, provides a robust environment for building interactive and type-safe charts. This blog post will guide you through the process of integrating charts into a React application using TypeScript.\n\nWhy Use TypeScript with React for Charts?\n\nTypeScript helps catch potential bugs and improves the development experience by providing type safety. When creating charts, TypeScript ensures that your data structures, configurations, and event handling are well-defined, preventing common runtime errors. With React’s component-driven architecture, you can easily integrate, customize, and manage charts in your web applications.\n\nIn this guide, we’ll walk through setting up charts in a React project using TypeScript and a popular charting library.\n\nFirst, let’s set up a new React project with TypeScript:\n\nThis command initializes a new React project with TypeScript as the default configuration.\n\nThere are many charting libraries available for React, such as:\n• Recharts: Built on top of D3.js for React.\n\nFor this example, we’ll use as it provides an easy-to-use API and good documentation for React and TypeScript.\n\nNow that we have our project set up and the charting library installed, let’s create a basic bar chart.\n\nIn this example:\n• We define a type, ensuring that every data point has a (string) and a (number).\n• We create a simple bar chart using Recharts’ component. We configure the chart with axes, a tooltip, and a legend, and make the chart responsive using .\n• The component renders the bars, and we pass the as to tell the chart where to pull the numerical values from.\n• Use the in your app:\n\nOpen and add the new chart component.\n\nYou should see a bar chart displayed on the screen with sample data. This is a simple example, but the structure allows you to scale easily and add other chart types or more complex configurations.\n\nLet’s take this a step further by making our chart component reusable with type-safe props.\n\nNow, the accepts props for , , and , which allow you to customize which properties to map to the X and Y axes. This type-safe structure ensures that any data you pass must conform to the type, preventing mismatches and errors.\n\nYou can now use the component like this:\n\nRecharts offers a variety of charts such as line charts, pie charts, and area charts, all of which you can configure with TypeScript. Here’s an example of a Line Chart with custom tooltips:\n\nMany real-world scenarios involve fetching data from an API and rendering it in charts. You can handle asynchronous data in TypeScript with tools like or libraries like :\n\nThis example demonstrates fetching data from an API and updating the chart once the data has been retrieved.\n\nCreating charts in React with TypeScript offers both flexibility and type safety, making it easier to handle data, manage props, and ensure that your chart components work as expected. With libraries like Recharts, you can quickly build a variety of charts, while TypeScript’s strong typing helps prevent bugs.\n• Choose a charting library that fits your project needs.\n• Leverage TypeScript to define clear types for your chart data and props.\n• Customize charts based on your application’s requirements for interactivity and design.\n\nWith this approach, you’ll have a solid foundation for creating robust and scalable data visualizations in React using TypeScript."
    },
    {
        "link": "https://stackoverflow.com/questions/15477008/how-to-create-charts-using-nodejs",
        "document": "d3 is probably your best bet. It can generate nearly any type of chart imaginable.\n\nYou can generate the charts directly in the browser, or if you really need an image file, you can use the module in node and convert the output to an image."
    },
    {
        "link": "https://reddit.com/r/reactjs/comments/11dald6/what_chart_libraries_are_modern",
        "document": "I’m relatively new to react and am wondering where to begin when it comes to charts in 2023. Curious what to go for when considering responsiveness, ease of use, and customisability.\n\nWhat are your preferences/recommendations and why?"
    },
    {
        "link": "https://echarts.apache.org/handbook/en/how-to/interaction/drag",
        "document": "This is a tiny example, introducing how to implement dragging of graphic elements in Apache EChartsTM. From this example, we will see how to make an application with rich intractivity based on echarts API.\n\nThis example mainly implements that dragging points of a curve and by which the curve is modified. Although it is simple example, but we can do more based on that, like edit charts viually. So let's get started from this simple example.\n\nFirst of all, we create a basic line chart (line series):\n\nSince the symbols in line is not draggable, we make them draggable by using graphic component to add draggable circular elements to symbols respectively.\n\nIn the code above, API convertToPixel is used to convert data to its \"pixel coodinate\", based on which each graphic elements can be rendered on canvas. The term \"pixel coodinate\" means the coordinate is in canvas pixel, whose origin is the top-left of the canvas. In the sentence , the first parameter indicates that should be converted in the first grid component (cartesian).\n\nNotice: should not be called before the first time that called. Namely, it can only be used after coordinate systems (grid/polar/...) initialized.\n\nNow points have been made draggable. Then we will bind event listeners on dragging to those points.\n\nIn the code above, API convertFromPixel is used, which is the reversed process of convertToPixel. converts a pixel coordinate to data item in grid (cartesian).\n\nFinally, add those code to make graphic elements responsive to change of canvas size.\n\nNow basic functionality have been implemented by parte 1. If we need the data can be displayed realtime when dragging, we can use tooltip component to do that. Nevertheless, tooltip component has its default \"show/hide rule\", which is not applicable in this case. So we need to customize the \"show/hide rule\" for our case.\n\nAdd these snippets to the code block above:\n\nThe API dispatchAction is used to show/hide tooltip content, where actions showTip and hideTip is dispatched.\n\nWith knowledge introduced above, more feature can be implemented. For example, dataZoom component can be added to cooperate with the cartesian, or we can make a plotting board on coordinate systems. Use your imagination ~"
    },
    {
        "link": "https://stackoverflow.com/questions/64217403/using-two-json-objects-to-make-chart-js-bar-chart-dynamic-in-typescript-angula",
        "document": "I'm using Chart.JS to make a bar chart, but I'm having issues using two JSON objects that I created to make the chart dynamic. I'm not sure of how I should do this but the objects can change values and I want to make the chart support that.\n\nThis is my object for labels:\n\nand I have a similar object for my data sets.\n\nThe object values can be any number so I want to make my chart dynamic to support that.\n\nWhat can I change in my code to make that happen?\n\nI want to remove the second and third datapoint and only have one dataset that will support multiple bars in the chart. So I would like to loop or map through both the label JSON object and data JSON object to make the chart."
    }
]