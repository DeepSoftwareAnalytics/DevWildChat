[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.drawing.bitmap?view=windowsdesktop-9.0",
        "document": "The following code example demonstrates how to construct a new Bitmap from a file, using the GetPixel and SetPixel methods to recolor the image. It also uses the PixelFormat, Width, and Height properties.\n\nThis example is designed to be used with a Windows Forms that contains a Label, PictureBox, and Button named , , and , respectively. Paste the code into the form and associate the method with the button's Click event.\n\nA bitmap consists of the pixel data for a graphics image and its attributes. There are many standard formats for saving a bitmap to a file. GDI+ supports the following file formats: BMP, GIF, EXIF, JPG, PNG, and TIFF. For more information about supported formats, see Types of Bitmaps.\n\nYou can create images from files, streams, and other sources by using one of the Bitmap constructors and save them to a stream or to the file system with the Save method. Images are drawn to the screen or to memory by using the DrawImage method of the Graphics object. For a list of topics about working with image files, see Working with Images, Bitmaps, Icons, and Metafiles."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.drawing?view=net-9.0",
        "document": "Encapsulates a GDI+ bitmap, which consists of the pixel data for a graphics image and its attributes. A Bitmap is an object used to work with images defined by pixel data. Specifies that, when interpreting ToolboxBitmapAttribute declarations, the assembly should look for the indicated resources in the same assembly, but with the BitmapSuffix configuration value appended to the declared file name. Specifies that, when interpreting ToolboxBitmapAttribute declarations, the assembly should look for the indicated resources in a satellite assembly, but with the BitmapSuffix configuration value appended to the declared file name. Defines objects used to fill the interiors of graphical shapes such as rectangles, ellipses, pies, polygons, and paths. Brushes for all the standard colors. This class cannot be inherited. Provides methods for creating graphics buffers that can be used for double buffering. Provides access to the main buffered graphics context object for the application domain. Converts colors from one data type to another. Access this class through the TypeDescriptor. Translates colors to and from GDI+ Color structures. This class cannot be inherited. Defines a particular format for text, including font face, size, and style attributes. This class cannot be inherited. Converts Font objects from one data type to another. FontConverter.FontNameConverter is a type converter that is used to convert a font name to and from various other representations. Converts font units to and from other unit types. Defines a group of type faces having a similar basic design and certain variations in styles. This class cannot be inherited. Encapsulates a GDI+ drawing surface. This class cannot be inherited. Represents a Windows icon, which is a small bitmap image that is used to represent an object. Icons can be thought of as transparent bitmaps, although their size is determined by the system. Converts an Icon object from one data type to another. Access this class through the TypeDescriptor object. An abstract base class that provides functionality for the Bitmap and Metafile descended classes. Animates an image that has time-based frames. ImageConverter is a class that can be used to convert Image objects from one data type to another. Access this class through the TypeDescriptor object. ImageFormatConverter is a class that can be used to convert ImageFormat objects from one data type to another. Access this class through the TypeDescriptor object. Defines an object used to draw lines and curves. This class cannot be inherited. Pens for all the standard colors. This class cannot be inherited. Converts a Point object from one data type to another. Converts rectangles from one data type to another. Access this class through the TypeDescriptor. Describes the interior of a graphics shape composed of rectangles and paths. This class cannot be inherited. The SizeConverter class is used to convert from one data type to another. Access this class through the TypeDescriptor object. Converts SizeF objects from one type to another. Defines a brush of a single color. Brushes are used to fill graphics shapes, such as rectangles, ellipses, pies, polygons, and paths. This class cannot be inherited. Encapsulates text layout information (such as alignment, orientation and tab stops) display manipulations (such as ellipsis insertion and national digit substitution) and OpenType features. This class cannot be inherited. Each property of the SystemBrushes class is a SolidBrush that is the color of a Windows display element. Each property of the SystemColors class is a Color structure that is the color of a Windows display element. Specifies the fonts used to display text in Windows display elements. Each property of the SystemIcons class is an Icon object for Windows system-wide icons. This class cannot be inherited. Each property of the SystemPens class is a Pen that is the color of a Windows display element and that has a width of 1 pixel. Each property of the TextureBrush class is a Brush object that uses an image to fill the interior of a shape. This class cannot be inherited. Allows you to specify an icon to represent a control in a container, such as the Microsoft Visual Studio Form Designer.\n\nRepresents an ordered pair of integer x- and y-coordinates that defines a point in a two-dimensional plane. Represents an ordered pair of floating-point x- and y-coordinates that defines a point in a two-dimensional plane. Stores a set of four integers that represent the location and size of a rectangle. Stores a set of four floating-point numbers that represent the location and size of a rectangle. For more advanced region functions, use a Region object. Stores an ordered pair of integers, which specify a Height and Width. Stores an ordered pair of floating-point numbers, typically the width and height of a rectangle.\n\nSpecifies alignment of content on the drawing surface. Determines how the source color in a copy pixel operation is combined with the destination color to result in a final color. Specifies the unit of measure for the given data. Specifies how much an image is rotated and the axis used to flip the image. Provides icon identifiers for use with GetStockIcon(StockIconId, StockIconOptions). Provides options for use with GetStockIcon(StockIconId, StockIconOptions). Specifies the alignment of a text string relative to its layout rectangle. The StringDigitSubstitute enumeration specifies how to substitute digits in a string according to a user's locale or language. Specifies the display and layout information for text strings. Specifies how to trim characters from a string that does not completely fit into a layout shape. Specifies the units of measure for a text string.\n\nThe namespace has some limitations for certain operating systems and application types.\n• None On Windows, depends on the GDI+ native library, which is shipped as part of the OS. Some Windows SKUs, like Windows Server Core or Windows Nano, don't include this native library as part of the OS. If you use this namespace and the library can't be loaded, exceptions will be thrown at run time.\n• None Some types in the namespace rely on GDI+, which is not supported in Windows services and ASP.NET Core and ASP.NET apps. These types are in the System.Drawing.Common NuGet package and include System.Drawing.Bitmap and System.Drawing.Font. However, primitive types in the namespace, such as System.Drawing.Color, System.Drawing.Size, System.Drawing.Point, and System.Drawing.Rectangle, can be used in any application.\n• None In .NET 5 and previous versions, the System.Drawing.Common NuGet package works on Windows, Linux, and macOS. However, there are some platform differences. On Linux and macOS, the GDI+ functionality is implemented by the libgdiplus) library. This library is not installed by default in most Linux distributions and doesn't support all the functionality of GDI+ on Windows and macOS. There are also platforms where libgdiplus is not available at all. To use types from the System.Drawing.Common package on Linux and macOS, you must install libgdiplus separately. For more information, see Install .NET on Linux or Install .NET on macOS.\n• None In .NET 6 and later versions, the System.Drawing.Common NuGet package is only supported on Windows operating systems. For more information, see System.Drawing.Common only supported on Windows. If you can't use with your application, recommended alternatives include ImageSharp, SkiaSharp, Windows Imaging Components, and Microsoft.Maui.Graphics.\n\nThe Graphics class provides methods for drawing to the display device. Classes such as Rectangle and Point encapsulate GDI+ primitives. The Pen class is used to draw lines and curves, while classes derived from the abstract class Brush are used to fill the interiors of shapes."
    },
    {
        "link": "https://stackoverflow.com/questions/8431175/net-system-drawing-namespace-what-are-the-differences-between-bitmap-image-a",
        "document": "I'm new to image manipulation in .net and a little bit confused about the available classes in the framework.\n\nAs far as I know the main classes are\n\nCould someone explain which class is used for what?"
    },
    {
        "link": "https://stackoverflow.com/questions/33344200/manipulating-images-with-net-core",
        "document": "I have updated my project from .NET 4.5 to .NET Core (with ASP.NET Core). I had some very simple code in my previous version that used the bitmap object from to resize an image.\n\nAs I understand cannot be used in .NET Core because it is not cross platform, but what can be used instead?\n\nI have googled this and cannot find anything. The only thing I can find is this post, which has no code on it what so ever."
    },
    {
        "link": "https://hanselman.com/blog/how-do-you-use-systemdrawing-in-net-core",
        "document": "I've been doing .NET image processing since the beginning. In fact I wrote about it over 13 years ago on this blog when I talked about Compositing two images into one from the ASP.NET Server Side and in it I used System.Drawing to do the work. For over a decade folks using System.Drawing were just using it as a thin wrapper over GDI (Graphics Device Interface) which were very old Win32 (Windows) unmanaged drawing APIs. We use them because they work fine.\n\nFor a while there was a package called CoreCompat.System.Drawing that was a .NET Core port of a Mono version of System.Drawing.\n\nHowever, since then Microsoft has released System.Drawing.Common to provide access to GDI+ graphics functionality cross-platform.\n\nThere is a lot of existing code - mine included - that makes assumptions that .NET would only ever run on Windows. Using System.Drawing was one of those things. The \"Windows Compatibility Pack\" is a package meant for developers that need to port existing .NET Framework code to .NET Core. Some of the APIs remain Windows only but others will allow you to take existing code and make it cross-platform with a minimum of trouble.\n\nHere's a super simple app that resizes a PNG to 128x128. However, it's a .NET Core app and it runs in both Windows and Linux (Ubuntu!)\n\nHere it is running on Ubuntu:\n\nNOTE that on Ubuntu (and other Linuxes) you may need to install some native dependencies as System.Drawing sits on top of native libraries\n\nThere's lots of great options for image processing on .NET Core now! It's important to understand that this System.Drawing layer is great for existing System.Drawing code, but you probably shouldn't write NEW image management code with it. Instead, consider one of the great other open source options.\n• ImageSharp - A cross-platform library for the processing of image files; written in C#\n• Compared to ImageSharp has been able to develop something much more flexible, easier to code against, and much, much less prone to memory leaks. Gone are system-wide process-locks; ImageSharp images are thread-safe and fully supported in web environments.\n\nHere's how you'd resize something with ImageSharp:\n\nIt's awesome that there are so many choices with .NET Core now!\n\nSponsor: Rider 2018.2 is here! Publishing to IIS, Docker support in the debugger, built-in spell checking, MacBook Touch Bar support, full C# 7.3 support, advanced Unity support, and more."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.drawing.graphics.copyfromscreen?view=windowsdesktop-9.0",
        "document": "Some information relates to prerelease product that may be substantially modified before it’s released. Microsoft makes no warranties, express or implied, with respect to the information provided here.\n\nPerforms a bit-block transfer of the color data, corresponding to a rectangle of pixels, from the screen to the drawing surface of the Graphics. Public Sub CopyFromScreen (sourceX As Integer, sourceY As Integer, destinationX As Integer, destinationY As Integer, blockRegionSize As Size) The x-coordinate of the point at the upper-left corner of the source rectangle. The y-coordinate of the point at the upper-left corner of the source rectangle. The x-coordinate of the point at the upper-left corner of the destination rectangle. The y-coordinate of the point at the upper-left corner of the destination rectangle. The size of the area to be transferred. The following code example demonstrates how to use the CopyFromScreen for printing a copy of the current form. using System; using System.Windows.Forms; using System.Drawing; using System.Drawing.Printing; public class Form1 : Form { private Button printButton = new Button(); private PrintDocument printDocument1 = new PrintDocument(); public Form1() { printButton.Text = \"Print Form\"; printButton.Click += new EventHandler(printButton_Click); printDocument1.PrintPage += new PrintPageEventHandler(printDocument1_PrintPage); this.Controls.Add(printButton); } void printButton_Click(object sender, EventArgs e) { CaptureScreen(); printDocument1.Print(); } Bitmap memoryImage; private void CaptureScreen() { Graphics myGraphics = this.CreateGraphics(); Size s = this.Size; memoryImage = new Bitmap(s.Width, s.Height, myGraphics); Graphics memoryGraphics = Graphics.FromImage(memoryImage); memoryGraphics.CopyFromScreen(this.Location.X, this.Location.Y, 0, 0, s); } private void printDocument1_PrintPage(System.Object sender, System.Drawing.Printing.PrintPageEventArgs e) { e.Graphics.DrawImage(memoryImage, 0, 0); } public static void Main() { Application.Run(new Form1()); } } Imports System.Windows.Forms Imports System.Drawing Imports System.Drawing.Printing Public Class Form1 Inherits Form Private WithEvents printButton As New Button Private WithEvents printDocument1 As New PrintDocument Public Sub New() printButton.Text = \"Print Form\" Me.Controls.Add(printButton) End Sub Dim memoryImage As Bitmap Private Sub CaptureScreen() Dim myGraphics As Graphics = Me.CreateGraphics() Dim s As Size = Me.Size memoryImage = New Bitmap(s.Width, s.Height, myGraphics) Dim memoryGraphics As Graphics = Graphics.FromImage(memoryImage) memoryGraphics.CopyFromScreen(Me.Location.X, Me.Location.Y, 0, 0, s) End Sub Private Sub printDocument1_PrintPage(ByVal sender As System.Object, _ ByVal e As System.Drawing.Printing.PrintPageEventArgs) Handles _ printDocument1.PrintPage e.Graphics.DrawImage(memoryImage, 0, 0) End Sub Private Sub printButton_Click(ByVal sender As System.Object, ByVal e As _ System.EventArgs) Handles printButton.Click CaptureScreen() printDocument1.Print() End Sub Public Shared Sub Main() Application.Run(New Form1()) End Sub End Class The CopyFromScreen methods are useful for layering one image on top of another. To specify how the source and destination colors are blended, use one of the CopyFromScreen methods that takes a CopyPixelOperation parameter.\n• How to: Copy Pixels For Reducing Flicker in Windows Forms"
    },
    {
        "link": "https://stackoverflow.com/questions/32438736/taking-a-screenshot-using-graphics-copyfromscreen-with-150-scaling",
        "document": "I'm trying to create a screenshot/bitmap of my screen. I wrote this function:\n\nThis function is being called in my overlay form that should draw the bitmap onto itself. I'm currently using GDI+ for the whole process.\n\nYep, I dispose the bitmap later, so don't worry. ;) On my laptop and desktop computer this works fine. I've tested this with different resolutions and the calculations are correct. I can see an image of the screen on the form.\n\nThe problem starts with the Surface 3. All elements are being scaled by a factor of 1.5 (150%). This consequently means that the DPI changes. If I try to take a screenshot there, it does only capture like the upper-left part of the screen but not the whole one. I've made my way through Google and StackOverflow and tried out different things:\n• Get the DPI, divide it by 96 and multiply the size components (X and Y) of the screen with this factor.\n• Add an entry to application.manifest to make the application DPI-aware.\n\nThe first way did not bring the desired result. The second one did, but the whole application would have to be adjusted then and this is quite complicated in Windows Forms.\n\nNow my question would be: Is there any way to capture a screenshot of the whole screen, even if it is has a scalation factor higher than 1 (higher DPI)? There must be a way to do this in order to make it working everywhere.\n\nBut at this point I had no real search results that could help me. Thanks in advance."
    },
    {
        "link": "https://stackoverflow.com/questions/26953581/how-does-the-graphics-copyfromscreen-method-copy-into-a-bitmap",
        "document": "Devices that can display graphics are virtualized in Windows. The concept is called a \"device context\" in the winapi, underlying representation is a \"handle\". The Graphics class wraps that handle, it does not itself store the pixels. Note the Graphics.GetHdc() method, a way to get to that handle.\n\nThe class otherwise just contains the drawing methods that produce graphics output on the device represented by that handle. Actual devices can be the screen, a printer, a metafile, a bitmap. With the big advantage in your own code that it can be used to produce output where ever you want it to go. So printing is just as easy as painting it to the screen or drawing to a bitmap that you store to a file.\n\nSo by calling Graphics.FromImage(), you associate the Graphics object to the bitmap. All of its draw methods actually set pixels in the bitmap. Like CopyFromScreen(), it simply copies pixels from the video adapter's frame buffer to the device context, in effect setting the pixels in the bitmap. So the expected return value of this code is the actual bitmap. The Graphics object should be disposed before that happens since it is no longer useful. Or in other words, the underlying handle needs to be released so the operating system de-allocates its own resources to represent the device context.\n\nThat's a bug in the code snippet. Repeated calls to this method can easily crash the program when Windows refuses to create more device contexts. And the garbage collector doesn't otherwise catch up fast enough. It should be written as:"
    },
    {
        "link": "https://dotnetcurry.com/ShowArticle.aspx?ID=117",
        "document": "Abstract: The Graphics class exposes a method called CopyFromScreen(). According to MSDN, this method performs a bit-block transfer of the color data, corresponding to a rectangle of pixels, from the screen to the drawing surface of the Graphics. In short, it is used to capture a rectangle and draw it to an image. Let us see how to use this method to capture the current screen.\n\nHow to capture the current screen using Windows Forms\n\nThe Graphics class exposes a method called CopyFromScreen(). According to MSDN, this method performs a bit-block transfer of the color data, corresponding to a rectangle of pixels, from the screen to the drawing surface of the Graphics. In short, it is used to capture a rectangle and draw it to an image. Let us see how to use this method to capture the current screen.\n\nThe signature of this method is as follows :\n\nwhere sourceX and sourceY are the x and y coordinate of the point at the upper-left corner of the ‘source’ rectangle. The destinationX and destinationY are the x and y coordinate of the point at the upper-left corner of the ‘destination’ rectangle.\n\nIn this example, we will be creating a bitmap equal to the height and width of the primary display. We then create a new Graphics from the specified bitmap. The Graphics.CopyFromScreen() is used to capture the screen and draw it in the bitmap. Once done, the image is saved to the desktop. Let us see some code.\n\nCreate a form and drop a button on it from the toolbar. Rename the button as btnCapture.\n\nThat was quiet easy right. You have built the ‘Print Screen’ functionality successfully using Windows Forms. I hope this article was useful and I thank you for viewing it.\n\nThis article has been editorially reviewed by Suprotim Agarwal.\n\nC# and .NET have been around for a very long time, but their constant growth means there’s always more to learn. We at DotNetCurry are very excited to announce The Absolutely Awesome Book on C# and .NET. This is a 500 pages concise technical eBook available in PDF, ePub (iPad), and Mobi (Kindle). Organized around concepts, this Book aims to provide a concise, yet solid foundation in C# and .NET, covering C# 6.0, C# 7.0 and .NET Core, with chapters on the latest .NET Core 3.0, .NET Standard and C# 8.0 (final release) too. Use these concepts to deepen your existing knowledge of C# and .NET, to have a solid grasp of the latest in C# and .NET OR to crack your next .NET Interview. Click here to Explore the Table of Contents or Download Sample Chapters!"
    },
    {
        "link": "https://daniweb.com/programming/software-development/threads/215952/c-graphics-copyfromscreen-issue",
        "document": "Welcome to daniweb TotallyBroke! Please use code tags when posting code You probably need call and or on the form. If you the screen but don't invalidate the region and repaint it -- then your screen shot will look like what it did before you set the properties. Please see this example: private void button4_Click(object sender, EventArgs e) { button4.BackColor = Color.Red; //You have to invalidate and repaint or else the button wont change colors until //AFTER the screenshot happens, thus you wont find the pixel! this.Invalidate(true); this.Update(); Color searchColor = button4.BackColor; Rectangle clip = new Rectangle(this.Location, this.Size); //only search the active window Point loc = PixelSearcher.PixelSearch(clip, searchColor.ToArgb(), 5); Cursor.Position = loc; } I don't know what your ShowWindow() is calling so you may have to use a different approach.\n\nSomething else came to mind. If ShowWindow() is a w32 call you could call which will process the message queue for the application and hide it. Note -- is unsafe to call in most cases. If this works and the first suggestion does not work then you need to find another way to repaint the form. It is possible for a user to click a button, then while the button's code is running click the \"X\" in the upper right corner, then the button's code makes a call to DoEvents() and it shuts down the application while code is still running -- which will throw an error.\n\nMany thanks Scott for such a quick response. I'll need to provide more detail I think. The app has, what could be called, a parent Form (this is not MDI). On this form there are many panels (user created). The panels in question (Scrolling Banner Panels) have an associate exe that renders scrolling banner output to the surface of the panel (using DX). The exe gets what's under this panel and renders as a background texture to give the impression of a transparent background ( for various reasons I can't use \"Transparency\" for this). The ShowWindow() function is from the user32.dll ( [DllImport(\"user32.dll\")] static extern bool ShowWindow(IntPtr hwnd, int nCmdShow); ). I've tested that the ShowWindow function is operating by excluding the ShowWindow(SBHnd, VISIBLE);. This results in the panel disappearing. So how can g.CopyFromScreen(rct.x, rct.y, 0, 0, new Size(rct.Width, rct.Height)) display it, if it's not there? BTW: SBHnd is the handle for the associated Panel. This is how the exe renders to the panel. If, as an experiment, I change the Coords during runtime so it renders its background from a different location (1st from the area under it and then 5secs later from another location), I don't get the problem. This proves, I believe, that it is somehow rendering an invisible panel.\n\n>> If, as an experiment, I change the Coords during runtime so it renders its background from a different location (1st from the area under it and then 5secs later from another location), I don't get the problem. This proves, I believe, that it is somehow rendering an invisible panel. I don't think I agree with that statement. What the proves is that making an unmanaged call to win32 doesn't take effect in the screenshot versus making a managed call by changing the coordinate. When you change a color, location, size, etc on a Control the .NET framework marks that control as \"needing to be repainted and updated\". You bypass all of the built-in checks by calling Win32 yourself, thus you are responsible for updating the screen. Try this as a test: RECT rct = new RECT(); GetWindowRect((IntPtr)SBHnd, ref rct); Bitmap bmp = new Bitmap(PanWidth, PanHeight); Graphics g = Graphics.FromImage(bmp); ShowWindow(SBHnd, INVISIBLE); Application.DoEvents(); //try this g.CopyFromScreen(rct.x, rct.y, 0, 0, new Size(rct.Width, rct.Height)); ShowWindow(SBHnd, VISIBLE);\n\nYou are correct. It simply uses the Panel as a dumb old rendering surface for the directX exe. It does have some of it's own functions but this is just to change loc, resize, regions, etc. The exe takes, as a bmp, what's under it and uses this bmp as a texture (background) for the Scrolling text to run over. The whole lot is then rendered to the panel using its windows handle. It simply uses CopyFromScreen to get what's under this panel as the bmp for the texture.\n\nYou are correct. If I take a screen shot from a different location, no matter how many times I make it take a screen shot of this loc it only renders what's visible. If however, and bearing in mind that I've made the panel invisible, I take a screen shot from the location of the area the panel was occupying, it gives me a background which includes a shot of scrolling banner (with text) which is invisible. I see where you are going with the DoEvents() call. If, however, I thread sleep before I call CopyFromScreen would this not allow messages to have completed? I apologies if this is rubbish, still quite new to all this\n\nI looked around and I think this will probably turn out to be a difficult task to do properly. A workaround could be to set the Opacity on your form to 0, send a message to repaint the region (or call doevents), take the screenshot, then restore it. This will cause a flicker though. Other than that I don't see how people are doing it. I know it can be done but i'm not quite sure how"
    },
    {
        "link": "https://stackoverflow.com/questions/2411893/recognize-numbers-in-images",
        "document": "I've been searching for resources for number recognition in images on the web. I found many links providing lots of resources on that topic. But unfortunately it's more confusing than helping, I don't know where to start.\n\nI've got an image with 5 numbers in it, non-disturbed (no captcha or something like this). The numbers are black on a white background, written in a standard font.\n\nMy first step was to separate the numbers. The algorithm I currently use is quite simple, it just checks if a column is entirely white and thus a space. Then it trims each character, so that there is no white border around it. This works quite well.\n\nBut now I'm stuck with the actual recognition of the number. I don't know what's the best way of guessing the correct one. I don't think directly comparing to the font is a good idea, because if the numbers only differ a little, it will no more work.\n\nCould anyone give me a hint on how this is done?\n\nIt doesn't matter to the question, but I'll be implementing this in C# or Java. I found some libraries which would do the job, but I'd like to implement it myself, to learn something."
    },
    {
        "link": "https://ironsoftware.com/csharp/ocr/how-to/input-images",
        "document": "OCR, or Optical Character Recognition, is a technology that is used to recognize and extract text from images. This technology is particularly useful for digitizing printed documents, as it allows you to extract and work with the textual content from scanned pages, photographs, or other image files.\n\nIronOCR supports various image formats, including jpg, png, gif, tiff, and bmp. Image filters are also available to enhance the reading capability.\n\nBegin by instantiating the IronTesseract class to enable OCR. Utilize the 'using' statement to create an OcrImageInput object, specifying the image file path. This ensures the proper disposal of resources when they are no longer needed. IronOCR supports input images in various formats, including jpg, png, gif, tiff, and bmp. Finally, use the method to perform OCR.\n\nVisit the How to Read Multi-Frame/Page GIFs and TIFFs article to learn more about reading TIFF and GIF images.\n\nApart from the plain old filepath, the OcrImageInput class also accepts image information in the form of bytes, AnyBitmap, Stream, as well as Image. The AnyBitmap is a bitmap object of IronSoftware.Drawing.AnyBitmap.\n\nA CropRectangle is also accepted when instantiating the OcrImageInput class. This allows you to specify which region of the image document should be OCR'ed. Depending on the image document, specifying the region to scan can significantly improve performance. In the code example I provide, I specify that only the chapter number and title should be read.\n\nChaknith is the Sherlock Holmes of developers. It first occurred to him he might have a future in software engineering, when he was doing code challenges for fun. His focus is on IronXL and IronBarcode, but he takes pride in helping customers with every product. Chaknith leverages his knowledge from talking directly with customers, to help further improve the products themselves. His anecdotal feedback goes beyond Jira tickets and supports product development, documentation and marketing, to improve customer’s overall experience.When he isn’t in the office, he can be found learning about machine learning, coding and hiking. Chaknith is the Sherlock Holmes of developers. It first occurred to him he might have a future in software engineering, when he was doing code challenges for fun. His focus is on IronXL and IronBarcode, but he takes pride in helping customers with every product. Chaknith leverages his knowledge from talking directly with customers, to help further improve the products themselves. His anecdotal feedback goes beyond Jira tickets and supports product development, documentation and marketing, to improve customer’s overall experience.When he isn’t in the office, he can be found learning about machine learning, coding and hiking."
    },
    {
        "link": "https://codeproject.com/Articles/2008/Image-Processing-for-Dummies-with-Csharp-and-GDIpl",
        "document": "The second in a series of articles which will build an image processing library in C# and GDI+.\n\nWelcome back for the second installment in this series. This installment serves as an introduction to the world of convolution filters. It is also the first version of our program that offers one level of undo. We'll build on that later, but for now I thought it mandatory that you be able to undo your experiments without having to reload the image every time.\n\nSo what is a convolution filter ? Essentially, it's a matrix, as follows:\n\nThe idea is that the pixel we are processing, and the eight that surround it, are each given a weight. The total value of the matrix is divided by a factor, and optionally an offset is added to the end value. The matrix above is called an identity matrix, because the image is not changed by passing through it. Usually the factor is the value derived from adding all the values in the matrix together, which ensures the end value will be in the range 0-255. Where this is not the case, for example, in an embossing filter where the values add up to 0, an offet of 127 is common. I should also mention that convolution filters come in a variety of sizes, 7x7 is not unheard of, and edge detection filters in particular are not symmetrical. Also, the bigger the filter, the more pixels we cannot process, as we cannot process pixels that do not have the number of surrounding pixels our matrix requires. In our case, the outer edges of the image to a depth of one pixel will go unprocessed.\n\nFirst of all we need to establish a framework from which to write these filters, otherwise we'll find ourselves writing the same code over and again. As our filter now relies on surrounding values to get a result, we are going to need a source and a destination bitmap. I tend to create a copy of the bitmap coming in and use the copy as the source, as it is the one getting discarded in the end. To facilitate this, I define a matrix class as follows:\n\nI'm sure you noticed that it is an identity matrix by default. I also define a method that sets all the elements of the matrix to the same value.\n\nThe pixel processing code is more complex than our last article, because we need to access nine pixels, and two bitmaps. I do this by defining constants for jumping one and two rows ( because we want to avoid calculations as much as possible in the main loop, we define both instead of adding one to itself, or multiplying it by 2 ). We can then use these values to write our code. As our initial offset into the different color is 0, 1, and 2, we end up with 3 and 6 added to each of those values to create indices for three pixels across, and use our constants to add the rows. In order to ensure we don't have any values jumping from the bottom of the image to the top, we need to create one int, which is used to calculate each pixel value, then clamped and stored. Here is the entire function:\n\nNot the sort of thing you want to have to write over and over, is it ? Now we can use our ConvMatrix class to define filters, and just pass them into this function, which does all the gruesome stuff for us.\n\nGiven what I've told you about the mechanics of this filter, it is obvious how we create a smoothing effect. We ascribe values to all our pixels, so that the weight of each pixel is spread over the surrounding area. The code looks like this:\n\nAs you can see, it's simple to write the filters in the context of our framework. Most of these filters have at least one parameter, unfortunately C# does not have default values, so I put them in a comment for you. The net result of apply this filter several times is as follows:\n\nGaussian Blur filters locate significant color transitions in an image, then create intermediary colors to soften the edges. The filter looks like this:\n\nThe middle value is the one you can alter with the filter provided, you can see that the default value especially makes for a circular effect, with pixels given less weight the further they go from the edge. In fact, this sort of smoothing generates an image not unlike an out of focus lens.\n\nOn the other end of the scale, a sharpen filter looks like this:\n\nIf you compare this to the gaussian blur you'll note it's almost an exact opposite. It sharpens an image by enhancing the difference between pixels. The greater the difference between the pixels that are given a negative weight and the pixel being modified, the greater the change in the main pixel value. The degree of sharpening can be adjusted by changing the centre weight. To show the effect better I have started with a blurred picture for this example.\n\nThe Mean Removal filter is also a sharpen filter, it looks like this:\n\nUnlike the previous filter, which only worked in the horizontal and vertical directions, this one spreads it's influence diagonally as well, with the following result on the same source image. Once again, the central value is the one to change in order to change the degree of the effect.\n\nProbably the most spectacular filter you can do with a convolution filter is embossing. Embossing is really just an edge detection filter. I'll cover another simple edge detection filter after this and you'll notice it's quite similar. Edge detection generally works by offsetting a positive and a negative value across an axis, so that the greater the difference between the two pixels, the higher the value returned. With an emboss filter, because our filter values add to 0 instead of 1, we use an offset of 127 to brighten the image, otherwise much of it would clamp to black.\n\nThe filter I have implemented looks like this:\n\nand it looks like this:\n\nAs you might have noticed, this emboss works in both diagonal directions. I've also included a custom dialog where you can enter your own filters, you might like to try some of these for embossing:\n\nThe horizontal and vertical only filters differ for no other reason than to show two variations. You can actually rotate these filters as well, by rotating the values around the central point. You'll notice the filter I have used is the horz/vertical filter rotated by one degree, for example.\n\nLet's not get carried away\n\nAlthough this is kinda cool, you will notice if you run Photoshop that it offers a lot more functionality than the emboss I've shown you here. Photoshop creates an emboss using a more specifically written filter, and only part of that functionality can be simulated using convolution filters. I have spent some time writing a more flexible emboss filter, once we've covered bilinear filtering and the like, I may write an article on a more complete emboss filter down the track.\n\nFinally, just a simple edge detection filter, as a foretaste of the next article, which will explore a number of ways to detect edges. The filter looks like this:\n\nLike all edge detection filters, this filter is not concerned with the value of the pixel being examined, but rather in the difference between the pixels surrounding it. As it stands it will detect a horizontal edge, and, like the embossing filters, can be rotated. As I said before, the embossing filters are essentially doing edge detection, this one just heightens the effect.\n\nThe next article will be covering a variety of edge detection methods. I'd also encourage you to search the web for convolution filters. The comp.graphics.algorithms newsgroup tends to lean towards 3D graphics, but if you search an archive like google news for 'convolution' you'll find plenty more ideas to try in the custom dialog."
    },
    {
        "link": "https://reddit.com/r/csharp/comments/i52apl/where_to_start_with_image_analysis_symbol",
        "document": "Create your account and connect with a world of communities.\n\nBy continuing, you agree to our\n\nand acknowledge that you understand the"
    },
    {
        "link": "https://stackoverflow.com/questions/19467878/c-sharp-image-recognition",
        "document": "I'm currently searching for a C# image recognition library.\n\nWhat I want to do: I want to write a function that scans an image and returns if another image is part of it. Or at least something that looks familiar in case that the angles of the two objects are different.\n\nThe link to a possible library and a short code example would be great!\n\nThank you in advance!"
    }
]