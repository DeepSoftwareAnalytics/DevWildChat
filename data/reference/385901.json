[
    {
        "link": "https://wpf-tutorial.com/misc-controls/the-slider-control",
        "document": "The Slider control allows you to pick a numeric value by dragging a thumb along a horizontal or vertical line. You see it in a lot of user interfaces, but it can still be a bit hard to recognize from the description alone, so here's a very basic example:\n\nThis will allow the end-user to select a value between 0 and 100 by dragging the button (referred to as the thumb) along the line.\n\nIn the example, I have dragged the thumb beyond the middle, but it's obviously hard to see the exact value. One way to remedy this is to turn on ticks, which are small markers shown on the line to give a better indication on how far the thumb is. Here's an example:\n\nI turn on the tick markers by giving the TickPlacement property another value than None, which is the default. In my example, I want the ticks placed below the line, but you can use TopLeft or even Both as possible values, to change this.\n\nAlso notice my use of the TickFrequency property. It defaults to 1, but in an example where the range of possible values goes from 0 to 100, this will result in 100 tick markers, which will have to be fitted into the limited space. In a case like this, it makes sense to raise the TickFrequency to something that will make it look less crowded.\n\nIf you have a look at the screenshot above, you will see that the thumb is between ticks. This makes sense, since there are five values between each tick, as specified by the TickFrequency property. Also, the value of the Slider control is in fact by default a double, meaning that the value can (and will likely) be a non-integer. We can change this by using the IsSnapToTickEnabled property, like in the below example:\n\nNotice that I've changed the TickFrequency to 10, and then enabled the IsSnapToTickEnabled property. This ensures that the thumb can only be placed directly on a tick value, so for this example, it can only be 0, 10, 20, 30, 40 and so on.\n\nSo far, we've just used the Slider illustratively, but of course, the actual purpose is to read its current value and use it for something. The Slider has a Value property for that, which you can of course read from Code-behind, or even bind to.\n\nA common scenario in using the Slider is to combine it with a TextBox, which will allow the user to see the currently selected value, as well as changing it by entering a number instead of dragging the Slider thumb. Normally, you would have to subscribe to change events on both the Slider and the TextBox and then update accordingly, but a simple binding can do all of that for us:\n\nNow you can change the value by using either the Slider or by entering a value in the TextBox, and it will be immediately reflected in the other control. As an added bonus, we get simple validation as well, without any extra work, like if we try to enter a non-numeric value in the TextBox:\n\nOf course, while bindings are very cool for a lot of purposes, you still may want to respond to changes in the Slider value from your Code-behind. Fortunately for us, the Slider comes with a ValueChanged event which will help us with that. To illustrate this, I've created a more complex sample with three sliders, where we change the Red, Green and Blue (RGB) values of a color:\n\nIn the XAML part of the code, we have three DockPanels, each with a Label, a Slider and a TextBox control. Just like before, the Text property of the TextBox controls have been bound to the Value of the Slider.\n\nEach slider subscribes to the same ValueChanged event, in which we create a new Color instance, based on the currently selected values and then uses this color to create a new SolidColorBrush for the Background property of the Window.\n\nAll in all, this is a pretty good example of what the Slider control can be used for."
    },
    {
        "link": "https://wpf-tutorial.com/el/64/misc-controls/the-slider-control",
        "document": "The community is working on translating this tutorial into Greek, but it seems that no one has started the translation process for this article yet. If you can help us, then please click \"More info\". If you are fluent in Greek, then please help us - just point to any untranslated element (highlighted with a yellow left border - remember that images should have their titles translated as well!) inside the article and click the translation button to get started. Or have a look at the current translation status for the Greek language. If you see a translation that you think looks wrong, then please consult the original article to make sure and then use the vote button to let us know about it. Please help us by translating the following metadata for the article/chapter, if they are not already translated. If you are not satisfied with the translation of a specific metadata item, you may vote it down - when it reaches a certain negative threshold, it will be removed. Please only submit an altered translation of a metadata item if you have good reasons to do so! Already logged in? Please try reloading the page!\n• Looking for the original article in English?\n\nThe Slider control allows you to pick a numeric value by dragging a thumb along a horizontal or vertical line. You see it in a lot of user interfaces, but it can still be a bit hard to recognize from the description alone, so here's a very basic example:\n\nThis will allow the end-user to select a value between 0 and 100 by dragging the button (referred to as the thumb) along the line.\n\nIn the example, I have dragged the thumb beyond the middle, but it's obviously hard to see the exact value. One way to remedy this is to turn on ticks, which are small markers shown on the line to give a better indication on how far the thumb is. Here's an example:\n\nI turn on the tick markers by giving the TickPlacement property another value than None, which is the default. In my example, I want the ticks placed below the line, but you can use TopLeft or even Both as possible values, to change this.\n\nAlso notice my use of the TickFrequency property. It defaults to 1, but in an example where the range of possible values goes from 0 to 100, this will result in 100 tick markers, which will have to be fitted into the limited space. In a case like this, it makes sense to raise the TickFrequency to something that will make it look less crowded.\n\nIf you have a look at the screenshot above, you will see that the thumb is between ticks. This makes sense, since there are five values between each tick, as specified by the TickFrequency property. Also, the value of the Slider control is in fact by default a double, meaning that the value can (and will likely) be a non-integer. We can change this by using the IsSnapToTickEnabled property, like in the below example:\n\nNotice that I've changed the TickFrequency to 10, and then enabled the IsSnapToTickEnabled property. This ensures that the thumb can only be placed directly on a tick value, so for this example, it can only be 0, 10, 20, 30, 40 and so on.\n\nSo far, we've just used the Slider illustratively, but of course, the actual purpose is to read its current value and use it for something. The Slider has a Value property for that, which you can of course read from Code-behind, or even bind to.\n\nA common scenario in using the Slider is to combine it with a TextBox, which will allow the user to see the currently selected value, as well as changing it by entering a number instead of dragging the Slider thumb. Normally, you would have to subscribe to change events on both the Slider and the TextBox and then update accordingly, but a simple binding can do all of that for us:\n\nNow you can change the value by using either the Slider or by entering a value in the TextBox, and it will be immediately reflected in the other control. As an added bonus, we get simple validation as well, without any extra work, like if we try to enter a non-numeric value in the TextBox:\n\nOf course, while bindings are very cool for a lot of purposes, you still may want to respond to changes in the Slider value from your Code-behind. Fortunately for us, the Slider comes with a ValueChanged event which will help us with that. To illustrate this, I've created a more complex sample with three sliders, where we change the Red, Green and Blue (RGB) values of a color:\n\nIn the XAML part of the code, we have three DockPanels, each with a Label, a Slider and a TextBox control. Just like before, the Text property of the TextBox controls have been bound to the Value of the Slider.\n\nEach slider subscribes to the same ValueChanged event, in which we create a new Color instance, based on the currently selected values and then uses this color to create a new SolidColorBrush for the Background property of the Window.\n\nAll in all, this is a pretty good example of what the Slider control can be used for."
    },
    {
        "link": "https://stackoverflow.com/questions/20946760/make-a-slider-use-an-existing-ivalueconverter",
        "document": "I think the issue you are having with the answers is that everyone is assuming (correctly in the case of common WPF usage) that your slider's value is being bound to some other control (textbox for example) or a ViewModel property. In this common case, the converter is applied within the binding (see all other answers) and converts the slider's internal linear value to your logarithmic value.\n\nIf you are just using this in a basic application where your code-behind or other application code is actually just polling the slider control directly, then you can use your converter as such:\n\nBut I have to say that this makes little sense as you could simply use a method or place the conversion in line in your code. Using the converter would only potentially make sense if this is also being used through binding somewhere else in your UI and that converter code might change.\n\nSince you are making a custom control anyway, another approach would be to add a new DependencyProperty to your slider control (maybe call it 'LogSlider.LogValue') that handles this conversion directly:\n\nNow you can access the LogValue directly from your custom Slider control as well as bind bidirectionally to it in the UI - with changes to the linear value being reflected in the log and vice versa."
    },
    {
        "link": "https://tutorialspoint.com/wpf/wpf_slider.htm",
        "document": "A slider is a control with the help of which a user can select from a range of values by moving a Thumb control along a track. The hierarchical inheritance of Slider class is as follows −\n\nGiven below are the most commonly used properties of Slider. Gets or sets the content for the control's header. Gets or sets the DataTemplate used to display the content of the control's header. Gets or sets the value of the Slider while the user is interacting with it, before the value is snapped to either the tick or step value. The value the Slider snaps to is specified by the SnapsTo property. Gets or sets a value that indicates the direction of increasing value. Gets or sets a value that determines whether the slider value is shown in a tool tip for the Thumb component of the Slider. Gets or sets the orientation of a Slider. Gets or sets the value part of a value range that steps should be created for. Gets or sets the converter logic that converts the range value of the Slider into tool tip content. Gets or sets the increment of the value range that ticks should be created for. Gets or sets a value that indicates where to draw tick marks in relation to the track.\n• None Lets create a new WPF project with the name WPFDialog.\n• None Drag one slider and two text blocks from the Toolbox.\n• None Change the background color from the properties window.\n• None The following example shows the usage of Slider in an XAML application. The following XAML code creates a Slider and text blocks and initializes them with some properties and events.\n\nHere is the implementation in C# for ValueChanged event.\n\nWhen you compile and execute the above code, it will produce the following output −\n\nWe recommend that you execute the above example code and try the other properties and events of Slider class."
    },
    {
        "link": "https://stackoverflow.com/questions/54964917/binding-a-command-from-mainwindowviewmodel-to-a-slider-value-change-event-in-a-u",
        "document": "So it sounds like you want to create custom events and then subscribe to those events in your view model. This is actually two different things.\n\nThe first bit involves creating a custom event in your control, similar to the ones you're already familiar with like and etc. Lots of information here and here on that. You can use the default and classes if you want, but chances are you'll want to pass additional parameters, so start by creating a new class for it:\n\nThen in your custom class you create a delegate for a handler to accept this, and you create the routed event itself:\n\nSo now your user control can raise this event at any time by simply doing this:\n\nSo now when you use your custom control you can add handlers for it just as you would for any other event:\n\nThe second part of your question is basically how you route events to command handlers in your view model. To do that you get rid of the event handler and user an interactivity event trigger instead:\n\nThen back in your view model you create a handler for it:"
    },
    {
        "link": "https://stackoverflow.com/questions/4944553/what-is-best-practise-for-ivalueconverter",
        "document": "What is best practise for IValueConverter: Is it ok to put Exception in Convert method or should it return \"something\"?\n\nHere is an example:"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/desktop/wpf/data/how-to-convert-bound-data?view=netframeworkdesktop-4.8",
        "document": "This example shows how to apply conversion to data that is used in bindings.\n\nTo convert data during binding, you must create a class that implements the IValueConverter interface, which includes the Convert and ConvertBack methods.\n\nThe following example shows the implementation of a date converter that converts the date value passed in so that it only shows the year, the month, and the day. When implementing the IValueConverter interface, it is a good practice to decorate the implementation with a ValueConversionAttribute attribute to indicate to development tools the data types involved in the conversion, as in the following example:\n\nOnce you have created a converter, you can add it as a resource in your Extensible Application Markup Language (XAML) file. In the following example, src maps to the namespace in which DateConverter is defined.\n\nFinally, you can use the converter in your binding using the following syntax. In the following example, the text content of the TextBlock is bound to StartDate, which is a property of an external data source.\n\nThe style resources referenced in the above example are defined in a resource section not shown in this topic."
    },
    {
        "link": "https://stackoverflow.com/questions/43651791/what-is-the-best-practise-if-i-want-to-use-a-ivalueconverter-in-wpf-and-uwp-proj",
        "document": "I have a UWP project as well as a WPF project. Both project needing the same converter. But the Interface is in UWP in another namespace as in WPF, furthermore is the last parameter not the same (in WPF it is CultureInfo in UWP it is a string). So what is the best practice to create a converter for both projects?\n\nMy solution is I have a netstandard project which has a class ValueConverterBase which defines each two methods from the WPF IValueConverter and the IValueConverter from UWP. It also defines two abstract methods which a sepcific converter has to implement :\n\nNow I can create a converter in the netstandard project which does the logic. To be able to use this converter in UWP and WPF each project has to create a class which derives from the converter and the specific IValueConverter:\n\nThe problem with this solution I have to add for each converter three new classes. Also every developer has to know about this workaround. Another point is that I am unable to use WPF or UWP specific logic in the converter. Does anybody has another solution?\n\nI combined my first solution with the answers from @Anton Tykhyy and @Heinzi. I created a Shared project which will contain my converter and added there my ValueConverterBase:"
    },
    {
        "link": "https://wpf-tutorial.com/as/39/data-binding/value-conversion-with-ivalueconverter",
        "document": "The community is working on translating this tutorial into Assamese, but it seems that no one has started the translation process for this article yet. If you can help us, then please click \"More info\". If you are fluent in Assamese, then please help us - just point to any untranslated element (highlighted with a yellow left border - remember that images should have their titles translated as well!) inside the article and click the translation button to get started. Or have a look at the current translation status for the Assamese language. If you see a translation that you think looks wrong, then please consult the original article to make sure and then use the vote button to let us know about it. Please help us by translating the following metadata for the article/chapter, if they are not already translated. If you are not satisfied with the translation of a specific metadata item, you may vote it down - when it reaches a certain negative threshold, it will be removed. Please only submit an altered translation of a metadata item if you have good reasons to do so! Already logged in? Please try reloading the page!\n• Looking for the original article in English?\n\nSo far we have used some simple data bindings, where the sending and receiving property was always compatible. However, you will soon run into situations where you want to use a bound value of one type and then present it slightly differently.\n\nWhen to use a value converter\n\nValue converters are very frequently used with data bindings. Here are some basic examples:\n• You have a numeric value but you want to show zero values in one way and positive numbers in another way\n• You want to check a CheckBox based on a value, but the value is a string like \"yes\" or \"no\" instead of a Boolean value\n• You have a file size in bytes but you wish to show it as bytes, kilobytes, megabytes or gigabytes based on how big it is\n\nThese are some of the simple cases, but there are many more. For instance, you may want to check a checkbox based on a Boolean value, but you want it reversed, so that the CheckBox is checked if the value is false and not checked if the value is true. You can even use a converter to generate an image for an ImageSource, based on the value, like a green sign for true or a red sign for false - the possibilities are pretty much endless!\n\nFor cases like this, you can use a value converter. These small classes, which implement the IValueConverter interface, will act like middlemen and translate a value between the source and the destination. So, in any situation where you need to transform a value before it reaches its destination or back to its source again, you likely need a converter.\n\nAs mentioned, a WPF value converter needs to implement the IValueConverter interface, or alternatively, the IMultiValueConverter interface (more about that one later). Both interfaces just requires you to implement two methods: Convert() and ConvertBack(). As the name implies, these methods will be used to convert the value to the destination format and then back again.\n\nLet's implement a simple converter which takes a string as input and then returns a Boolean value, as well as the other way around. If you're new to WPF, and you likely are since you're reading this tutorial, then you might not know all of the concepts used in the example, but don't worry, they will all be explained after the code listings:\n\nSo, let's start from the back and then work our way through the example. We have implemented a converter in the Code-behind file called YesNoToBooleanConverter. As advertised, it just implements the two required methods, called Convert() and ConvertBack(). The Convert() methods assumes that it receives a string as the input (the value parameter) and then converts it to a Boolean true or false value, with a fallback value of false. For fun, I added the possibility to do this conversion from French words as well.\n\nThe ConvertBack() method obviously does the opposite: It assumes an input value with a Boolean type and then returns the English word \"yes\" or \"no\" in return, with a fallback value of \"no\".\n\nYou may wonder about the additional parameters that these two methods take, but they're not needed in this example. We'll use them in one of the next chapters, where they will be explained.\n\nIn the XAML part of the program, we start off by declaring an instance of our converter as a resource for the window. We then have a TextBox, a couple of TextBlocks and a CheckBox control and this is where the interesting things are happening: We bind the value of the TextBox to the TextBlock and the CheckBox control and using the Converter property and our own converter reference, we juggle the values back and forth between a string and a Boolean value, depending on what's needed.\n\nIf you try to run this example, you will be able to change the value in two places: By writing \"yes\" in the TextBox (or any other value, if you want false) or by checking the CheckBox. No matter what you do, the change will be reflected in the other control as well as in the TextBlock.\n\nThis was an example of a simple value converter, made a bit longer than needed for illustrational purposes. In the next chapter we'll look into a more advanced example, but before you go out and write your own converter, you might want to check if WPF already includes one for the purpose. As of writing, there are more than 20 built-in converters that you may take advantage of, but you need to know their name. I found the following list which might come in handy for you: http://stackoverflow.com/questions/505397/built-in-wpf-ivalueconverters"
    },
    {
        "link": "https://michaelscodingspot.com/4-tips-increase-productivity-wpf-converters",
        "document": "When starting with WPF, I had a hard time realizing when to use converters and just how powerful they can be. I would often create styles with complicated Data Triggers, or abuse my ViewModel instead of doing some simple converter magic.\n\nI’ll share with you some converter tips and tricks that make my development easier every day.\n\nTip #1: When starting a new project, get a converters library\n\nA lot of standard converters are reused in every WPF application. No need to recode the wheel. There are several open source libraries available we can use:\n\nTip #2: Write C# code in XAML with QuickConverter\n\nThis is a real gem. This library actually allows to write c# code in XAML.\n\n Here’s an example:\n\nIn this example the FontSize is changing according to Message’s length. If there’s over 300 characters, the FontSize will be smaller.\n\nI used it in our code base and I think it’s awesome. It’s more readable and we need much less code for simple logic as in the examples above.\n\nFor documentation check out this post , the documentation on CodePlex and QuickConverter on NuGet .\n\nThis doesn’t cancel out regular converters. We still would want a lot of reusable converters as regular C# classes.\n\nEDIT: Since writing this post I discovered a better-maintained library, CalcBinding , that achieves the same goal. I would now suggest using CalcBinding rather than QuickConverter.\n\nUsing a converter requires you to create an instance of the converter. The conventional way is using a StaticResource:\n\nIn the above example, we will use the same instance of the converter every time we use StaticResource. This is both good and bad.\n\n Good because we might gain in performance for not having to create a new instance.\n\n Bad because if we want to use parameters with out converter, those parameters will be the same every time we use the StaticResource.\n\nConsider having the converters derive from MarkupExtension. We will be able to write like this:\n\nOur converter will have to derive from MarkupExtension:\n\nThis is easier to read and will create a new instance of the converter every time. Which is usually what I want. I want to be able to give different parameters to my converter every time and the performance loss of creating a new instance is negligible.\n\nHere’s a nice post that explains about converters as MarkupExtension in more detail.\n\nSometimes, we need to do a “double” conversion. Or, in other words, convert the result of our conversion.\n\nLet’s use the example from Tip #2. In a TextBlock, we want to use a smaller font if the message is too long (More than 300 characters).\n\nWe saw how to do this easily with QuickConverter, but let’s assume we want to do it the old fashion way for whatever reasons.\n\nInstead of creating a new custom converter, we can save some time and effort and use our standard converters. Like these two:\n\nHere’s the code that combines the above standard converters to our custom needs:\n\nTo be able to do that, we need to add ResultConverter to our BaseConverter class. Like this:\n\nThis is really convenient, trust me. It will save time writing those extra unnecessary converters.\n\nIn the last example we saw a BaseConverter that derives from MarkupExtension and uses ResultConverter. It is missing the methods ConvertBack and ConvertBackInternal to make the base class usable.\n\nAlso, I suggest having a base class for MultiValueConverer that has the same concepts.\n\nI showed you some tricks that make my WPF development more productive and the code more readable.\n\nI hope I gave you some value and maybe made converters look a bit more useful and easier."
    }
]