[
    {
        "link": "https://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html",
        "document": ""
    },
    {
        "link": "https://robotframework.org",
        "document": ""
    },
    {
        "link": "https://robotframework.org/robotframework",
        "document": "This page contains links to version specific Robot Framework User Guide, standard library, and built-in tool documentation. See http://robotframework.org and GitHub project pages for more information about the framework and the rich ecosystem around it in general.\n\nRobot Framework User Guide is a reference manual explaining all Robot Framework features in detail. You can either the selected version online or it as a zip package. This package contains also standard library documentation under libraries directory.\n\nThese test libraries are distributed with Robot Framework. Click to view the selected version online, and use or equivalent to save the opened page locally if needed\n\nNew standard libraries are added time to time. Dropdown menus list versions in which libraries are available.\n\nIn addition to the core test execution engine, there are some supporting tools built-in to Robot Framework. Clicking opens the documentation of the selected tool online. In practice the documentation is opened from the selected User Guide version.\n\nDropdown menus list versions in which tools are available."
    },
    {
        "link": "https://github.com/robotframework/robotframework",
        "document": "Robot Framework ® is a generic open source automation framework for acceptance testing, acceptance test driven development (ATDD), and robotic process automation (RPA). It has simple plain text syntax and it can be extended easily with generic and custom libraries.\n\nRobot Framework is operating system and application independent. It is implemented using Python which is also the primary language to extend it. The framework has a rich ecosystem around it consisting of various generic libraries and tools that are developed as separate projects. For more information about Robot Framework and the ecosystem, see http://robotframework.org.\n\nRobot Framework project is hosted on GitHub where you can find source code, an issue tracker, and some further documentation. Downloads are hosted on PyPI.\n\nRobot Framework development is sponsored by non-profit Robot Framework Foundation. If you are using the framework and benefiting from it, consider joining the foundation to help maintaining the framework and developing it further.\n\nIf you already have Python with pip installed, you can simply run:\n\nFor more detailed installation instructions, including installing Python, see INSTALL.rst.\n\nRobot Framework requires Python 3.8 or newer and runs also on PyPy. The latest version that supports Python 3.6 and 3.7 is Robot Framework 6.1.1. If you need to use Python 2, Jython or IronPython, you can use Robot Framework 4.1.3.\n\nBelow is a simple example test case for testing login to some system. You can find more examples with links to related demo projects from http://robotframework.org.\n\nTests (or tasks) are executed from the command line using the command or by executing the module directly like .\n\nThe basic usage is giving a path to a test (or task) file or directory as an argument with possible command line options before the path:\n\nAdditionally, there is the tool for combining results and otherwise post-processing outputs:\n\nRun and for more information about the command line usage. For a complete reference manual see Robot Framework User Guide.\n\nInterested to contribute to Robot Framework? Great! In that case it is a good start by looking at the CONTRIBUTING.rst. If you do not already have an issue you would like to work on, you can check issues with good new issue and help wanted labels.\n\nRemember also that there are many other tools and libraries in the wider Robot Framework ecosystem that you can contribute to!\n\nRobot Framework is open source software provided under the Apache License 2.0. Robot Framework documentation and other similar content use the Creative Commons Attribution 3.0 Unported license. Most libraries and tools in the ecosystem are also open source, but they may use different licenses."
    },
    {
        "link": "https://forum.robotframework.org/t/robot-framework-for-hardware-testing/3909",
        "document": "Python is getting more and more popular for testing embedded hardware devices. These use cases requires the control of of external signal generators and measurement devices. Libraries for accessing this kind of equipment would be very useful. Also more advanced user dialogs could be useful for testing. Are there others around using the Robot Framework for hardware testing?\n\nthanks a lot for your answer. I have at the moment one small project ongoing to find out if RF is suitable or not. We looked into Pytest, RF and start from scratch. At the moment it looks like the fastest way is to use Python without using any test framework from the software domain. Wish you a nice summer up in Finland,\n\nWhat python does really well is providing many many modules for doing many many things including interfacing with hardware What python doesn’t do well (but better than some other programming languages (C programmer here )) is readability to non coders and test reporting (something that Robot Framework does exceptionally well in my opinion) So I would suggest you consider a more hybrid approach, since you are prepared to go down the path of writing python code anyway, write the python code as a library of generic keywords for Robot Framework, then you can have the best of both worlds.\n\nthanks a lot for your thoughts concerning my hardware testing question. Until for some few days ago I believe a hybrid approach would be the best solution too, reusing the RF report and the SSHLibrary for communication to the embedded Linux target. We started the programming of two competing prototypes, one based on RF and own Python libraries and a second using exclusively Python programming. After seeing the progress of our Python programmer I changed my mind. He had generated HTML and pdf reports using some existing libraries. He had also added tables for measurement data and embedded nice graphical plots. The SSHLibrary is very useful for testing Linux targets. We will now reuse this code and give it a Python interface. The third advantage of RF is the human readable Robot files. To solve this problem we used some Python dictionaries storing all relevant data for the tests and exported this into a JSON string. This JSON sting is used to control the test sequencer. The only missing part now is the graphical user interface. For this part we don’t have a prototype yet, but we have a concept for it. It is reading the JSON sting and populates all graphical objects automatically according to the test specification. Probably we will program this part in Python too. We need to maintain the code for +20 years so maintainability is very important. If we make something useful out this we will probably make it open source.\n\nconcerning my hardware testing question. Until for some few days ago I believe a hybrid approach would be the best solution too, reusing the RF report and the SSHLibrary for communication to the embedded Linux target. I’m developing some libraries to manipulate ADP3450 from digilent to automate some hardware tests here, I also worked in a library to manipulate the TI debugger to make some on-target testing on DSP. I’ll come back here later to explain it better.\n\nI‘ve been experimenting with robotframework for wrapping some end to end integration tests for a complex embedded linux device some years ago. I consider robotframework very interesting cause you can abstract away all the complexity of embedded hardware interfacing (anything which is Python scriptable) and web interfaces commonly used in more complex devices (RESTful API, …) management friendly BDD. I know that some robotics companies use it… on sevice level as well probably."
    },
    {
        "link": "https://github.com/robotframework/HowToWriteGoodTestCases/blob/master/HowToWriteGoodTestCases.rst",
        "document": "\n• These are high-level guidelines for writing good test cases using Robot Framework.\n• How to actually interact with the system under test is out of the scope of this document.\n• Most important guideline is keeping test cases as easy to understand as possible for people familiar with the domain.\n• For more information about this subject, you may want to take a look at these great resources:\n• Robot Framework Dos and Don'ts slides that are based on this how-to.\n• How to Structure a Scalable And Maintainable Acceptance Test Suite blog post by Andreas Ebbert-Karroum.\n• Suite names should be as descriptive as possible.\n• Names are created automatically from file or directory names:\n• If name is all lower case, words are capitalized.\n• Names can be relatively long, but overly long names are not convenient for the file system.\n• The name of the top level suite can be overridden from the command line using the option if needed.\n• Test names should be descriptive like the suite names.\n• If a suite contains many similar tests and is well named, test names can be shorter.\n• Name is exactly the same as you specified in the test case file without any conversion.\n\nFor example, if we have tests related to invalid login in a file , these would be OK test case names:\n\nThese names would be somewhat long:\n\nLogin With Empty Username And Password Should Fail Login With Invalid Username And Invalid Password Should Fail\n• Keyword names should be descriptive and clear.\n• Should explain what the keyword does, not how it does its task(s).\n• Very different abstraction levels (e.g. or ).\n• There is no clear guideline on whether a keyword should be fully title cased or have only the first letter be capitalized.\n• Title casing is often used when the keyword name is short (e.g. ).\n• Capitalizing just the first letter typically works better with keywords that are like sentences (e.g. ). These type of keywords are often higher level.\n• Try to use name that describes what is done.\n• More abstract names are acceptable if a setup or teardown contains unrelated steps.\n• Listing steps in name is duplication and a maintenance problem (e.g. ).\n• Often better to use something generic (e.g. ).\n• BuiltIn keyword Run Keywords can work well if keywords implementing lower level steps already exist.\n• Not reusable so best used when the setup or teardown scenario is needed only once.\n• Everyone working with these tests should always understand what a setup or teardown does.\n\nGood (if only used once):\n• Often a good idea to add overall documentation to test case files.\n• Should contain background information, why tests are created, notes about execution environment, etc.\n• Do not just repeat test suite name.\n• Better to have no documentation if it is not really needed.\n• Do not include too much details about test cases.\n• Tests should be clear enough to understand alone.\n• Documentation can contain links to more information.\n• Consider using test suite metadata if you need to document information represented as name-value pairs (e.g. or ).\n• Documentation and metadata of the top level suite can be set from the command line using and options, respectively.\n\nBad (especially if suite is named well like ):\n• Test normally does not need documentation.\n• Name and possible documentation of the parent suite and test's own name should give enough background information.\n• Test case structure should be clear enough without documentation or other comments.\n• Tags are generally more flexible and provide more functionality (statistics, include/exclude, etc.) than documentation.\n• Sometimes test documentation is useful. No need to be afraid to use it.\n\n... and password and checks that the welcome page is open. ... This is a smoke test. Created in iteration 3. Open Browser Input Text field1 Input Text field2 Click Button button_12 Title Should Be Welcome Page\n• Not needed if keyword is relatively simple.\n• Good keyword, argument names and clear structure should be enough.\n• Shown in resource file documentation generated with Libdoc and editors such as RIDE can show it in keyword completion and elsewhere.\n• Tests in a suite should be related to each other.\n• Should not have too many tests (max 10) in one file unless they are data-driven tests.\n• Tests should be independent. Initialization using setup/teardown.\n• Sometimes dependencies between tests cannot be avoided.\n• For example, it can take too much time to initialize all tests separately.\n• Never have long chains of dependent tests.\n• Consider verifying the status of the previous test using the built-in variable.\n• Test case should be easy to understand.\n• One test case should be testing one thing.\n• Things can be small (part of a single feature) or large (end-to-end).\n• Select suitable abstraction level.\n• Do not include unnecessary details on the test case level.\n• Generally have these phases:\n• Action (do something to the system)\n• Cleanup (optional, always in teardown to make sure it is executed)\n• Keywords describe what a test does.\n• Should contain enough information to run manually.\n• Should never need documentation or commenting to explain what the test does.\n• Different tests can have different abstraction levels.\n• Tests for a detailed functionality are more precise.\n• End-to-end tests can be on very high level.\n• One test should use only one abstraction level\n• Different styles:\n• More technical tests for lower level details and integration tests.\n• Everyone (including customer and/or product owner) should always understand.\n• No complex logic on the test case level.\n• No for loops or if/else constructs.\n• Test cases should not look like scripts!\n\nSee the web demo project for executable versions of the above examples.\n• One high-level keyword per test.\n• One test can run the same keyword multiple times to validate multiple related variations\n• If the keyword is implemented as a user keyword, it typically contains a similar workflow as workflow tests.\n• Unless needed elsewhere, it is a good idea to create it in the same file as tests using it.\n• Recommended to use the test template functionality.\n• No need to repeat the keyword multiple times.\n• Easier to test multiple variations in one test.\n• Possible, and recommended, to name column headings\n• If a really big number of tests is needed, consider generating them based on an external model.\n\nThe web demo project contains an executable version of this example too.\n• Should be easy to understand.\n• Same rules as with workflow tests.\n• Can contain some programming logic (for loops, if/else).\n• Complex logic in libraries rather than in user keywords.\n• Pass information from them command line using the option.\n• Clear but not too long names.\n• Can use comments in variable table to document them more.\n• Use case consistently:\n• Lower case with local variables only available inside a certain scope.\n• Upper case with others (global, suite or test level).\n• Both space and underscore can be used as a word separator.\n• Recommended to also list variables that are set dynamically in the variable table.\n• The initial value should explain where/how the real value is set.\n• Common approach is to return values from keywords, assign them to variables and then pass them as arguments to other keywords.\n• Looks like programming and thus not so good on the test case level.\n• Alternative approach is storing information in a library or using the BuiltIn Set Test Variable keyword.\n• Can be more complex to follow and make reusing keywords harder.\n• Sleeping is a very fragile way to synchronize tests.\n• Safety margins cause too long sleeps on average.\n• Instead of sleeps, use keyword that polls has a certain action occurred.\n• Should have a maximum time to wait.\n• Possible to wrap other keywords inside the BuiltIn keyword Wait Until Keyword Succeeds.\n• Sometimes sleeping is the easiest solution.\n• Always use with care.\n• Never use in user keywords that are used often by tests or other keywords.\n• Can be useful in debugging to stop execution."
    },
    {
        "link": "https://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/embedded/comments/1diu8lx/how_to_unit_test_best_practices_practical_examples",
        "document": "TLDR: looking for resources on unit testing and modern c++ best practices focused on embedded development so I can see how a good well structured large scale project works.\n\nHi there, I'm about 6 months into my first job after graduating electronic engineering. It's mostly embedded and PCB design for esp32 based products using platformio and freeRTOS. I don't think my company really does things \"the right way\" (if there is even such a thing). We don't do unit tests or anything.\n\nAre there any open source embedded projects with examples of how to write unit tests for embedded code? I understand mostly how it would work for normal programming but when Interfacing with peripherals it doesn't seem as straight forward.\n\nWe also use c++ and I try to write classes that would work in isolation and aren't tied to the main portion of the code base, but I still feel like I could be doing things better. There are some aspects that my manager is not keen on changing (our cursed Hungarian notation being my biggest pet peeve), but generally I have a lot of freedom to do things that way i feel is best."
    },
    {
        "link": "https://valagroup.com/blog/a-beginners-guide-to-robot-framework-test-automation",
        "document": "Robot Framework is a powerful open-source automation framework designed to make automation easier and more efficient. It provides a comprehensive and user-friendly way to automate various tasks.\n\nThis guide provides an overview of Robot Framework and how it can be used to automate testing. Additionally, it will discuss the benefits of using Robot Framework, as well as provide tips and tricks for getting started.\n\nWith this guide, you’ll have a basic level of knowledge and tools to successfully begin automating with Robot Framework.\n\nFirst a little motivation picked up from Robot Framework User Guide. Directly quoted, here are 13 good reasons why you would like to use Robot Framework.\n• Enables easy-to-use tabular syntax for creating test cases in a uniform way.\n• Provides ability to create reusable higher-level keywords from the existing keywords.\n• Provides easy-to-read result reports and logs in HTML format.\n• Provides a simple library API for creating customized test libraries which can be implemented natively with Python.\n• Provides a command line interface and XML based output files for integration into existing build infrastructure (continuous integration systems).\n• Provides support for testing web applications, rest APIs, mobile applications, running processes, connecting to remote systems via Telnet or SSH, and so on.\n• Has built-in support for variables, practical particularly for testing in different environments.\n• Provides tagging to categorize and select test cases to be executed.\n• Enables easy integration with source control: test suites are just files and directories that can be versioned with the production code.\n• Provides test-case and test-suite -level setup and teardown.\n• The modular architecture supports creating tests even for applications with several diverse interfaces.\n\nRobot Framework is an open source automation framework that can be used to automate tasks across a wide range of applications. It is easy to learn, and provides a powerful yet simple way to create automated tests across many different platforms.\n\nRobot Framework makes use of a keyword-driven approach, meaning that tests and applications are built from a set of keywords, rather than from long lines of code. This makes it easy to create tests and applications quickly, and it also makes it much easier to maintain and update them.\n\nRF also has a large selection of libraries and tools that can be used to extend the functionality of the framework. Finally, Robot Framework is built on top of Python, making it easy to integrate with other Python libraries and frameworks.\n\nSetting up Robot Framework is relatively straightforward and easy. First, you will need to install the Python interpreter, as Robot Framework runs on Python. You can find instructions to install Python on the official Robot Framework website.\n\nOnce Python is installed, you can use the pip command to install Robot Framework itself. Again, instructions to do this can be found in the Robot Framework website.\n\nAfter installation, you need to create a project folder and create a test suite inside this folder. This is where you will include your automated tests.\n\nOnce all of these steps are completed, you can begin to create automated tests using Robot Framework.\n\nTest cases written with Robot Framework are organized into test suites. When writing test cases with Robot Framework, it is important to ensure that all tests are thoroughly documented, as this will make it easier for developers to understand how the tests work and why it is being used.\n\nAdditionally, it is important to consider the data that will be used in the test. Finally, it is important to ensure that the test cases are organized in a logical way, as this will make it easier for developers to debug any issues that may arise.\n\nNeed help writing good test cases? This documentation in Github by Pekka Klärck et. al. is a perfect place to begin.\n\nUsing Variables and Keywords in Robot Framework\n\nVariables and keywords are the backbone of Robot Framework. Variables are used to store data that can be used throughout a test suite, while keywords are used to perform specific tasks.\n\nVariables are defined using the Set Variable keyword, which can be used to assign a value to a variable. Keywords are defined using the keywords section of a test suite, and are reusable across test suites.\n\nKeywords can be used to automate a variety of tasks, such as clicking on a button, entering text into a field, or launching a web page. They can also be used to perform validation checks, such as verifying that the expected text is present on a page.\n\nUsing libraries in Robot Framework is an essential part of creating effective automated tests.\n\nLibraries allow users to create custom keywords, which can be used within test cases. These custom keywords can be created to perform complex tasks, such as accessing a web page, sending/receiving data, and collecting data from a database.\n\nLibraries can also be used to extend the functionality of Robot Framework by integrating external libraries, such as Selenium or Appium.\n\nHere you can find the instructions for creating test libraries.\n\nDebugging and troubleshooting in Robot Framework can be a challenging task, but with the right tools and techniques, it can be done efficiently.\n\nThere are 3rd party debugging libraries like this one, which allow the user to easily debug and troubleshoot their tests. RF also includes a rich set of tools that can help to debug and troubleshoot tests, including a log viewer, command-line support, and a variable inspector.\n\nFinally, Robot Framework also provides support for third-party debugging tools, such as Visual Studio Code and PyCharm, to further enhance the debugging and troubleshooting process. With the right tools and techniques, debugging and troubleshooting in Robot Framework can be made much easier.\n\nRobot Framework is a great tool for generating reports. It allows you to quickly and easily generate reports in HTML, XML, and even plain text formats.\n\nThe reports generated in Robot Framework are comprehensive and provide valuable insights into test execution.\n\nRobot Framework also provides many options for customizing the reports, such as including charts, tables, and even screenshots. With the ability to customize the report, you can tailor it to fit the needs of your team or organization.\n\nAlso, Robot Framework makes it easy to share the reports with members of the team, allowing everyone to stay up to date on progress. This comprehensive reporting system is a great way to ensure that your automation efforts are running smoothly and efficiently.\n\nBy integrating RF with popular Continuous Integration/Continuous Delivery (CI/CD) systems, users can further reduce time and effort spent on testing by automating the testing process.\n\nCI/CD systems help to automate the entire software development lifecycle, including test automation. By integrating RF with CI/CD, users can continuously run tests as part of their CI/CD pipelines, thus reducing manual effort and ensuring that tests are run on a regular basis.\n\nMoreover, this integration helps to quickly identify any issues that may arise during the process, allowing for immediate corrective action to be taken. Ultimately, integrating RF with CI/CD helps to ensure that tests are always up-to-date and running efficiently.\n\nBest Practices for Writing Tests in Robot Framework\n\nWriting tests in Robot Framework requires a few simple best practices to ensure accuracy and efficiency.\n\nFirst, it is important to keep test cases short and understandable. This ensures that tests are easy to read and can be easily maintained. Keeping the tests small makes it also easier to identify which part of the application is causing issues and to fix them quickly.\n\nSecondly, tests should be written in a modular format, allowing for easier reuse of code. Using modular format will also reduce duplication of code and make test cases more readable. This will make it easier to maintain and update tests also in the future.\n\nFinally, when writing tests, it is important to use appropriate keywords to ensure the test is understood correctly by the system. These keywords should be consistent throughout the test and should use meaningful names. This will make it easier to understand what the test does and what it is testing. Tests can also be grouped together and keywords and tags can be used to identify which tests need to be run in which environments. This makes management and execution of tests in different environments a lot easier.\n\nFollowing these best practices will help ensure that Robot Framework tests are accurate and efficient.\n\nIn conclusion, Robot Framework is a powerful and versatile platform that can be used to automate various tasks and test cases.\n\nWith its easy-to-use syntax, robust library of libraries, and comprehensive documentation, Robot Framework is an excellent choice for automation.\n\nAlso, its extensibility allows users to create their own custom libraries and adapt the framework to their specific needs.\n\nFinally, its open-source nature ensures that it will remain an accessible and reliable tool for future automation needs."
    },
    {
        "link": "https://groups.google.com/g/robotframework-users/c/jZ6wM0C9FQo",
        "document": "Sign in to reply to author You do not have permission to delete messages in this group Either email addresses are anonymous for this group or you need the view member email addresses permission to view the original message Hi, \n\n \n\nIs it possible to use Robot Framework for embedded software anyhow? I \n\nwould be very interested in the detailed information if anyone knows \n\nmore about it. \n\n \n\nI just noticed in the guide that \"It can be used for testing \n\ndistributed, heterogeneous applications, where verification requires \n\ntouching several technologies and interfaces.\" but with my \n\nunderstanding of the written text I would need an \"iron wire example\" \n\nfrom this - maybe because English is not my mother tongue. \n\n \n\n-Caizu- \n\n\n\nSign in to reply to author You do not have permission to delete messages in this group Either email addresses are anonymous for this group or you need the view member email addresses permission to view the original message \n\n>\n\n> Is it possible to use Robot Framework for embedded software anyhow? I\n\n> would be very interested in the detailed information if anyone knows\n\n> more about it. It definitely is possible. If your embedded system can run Python you\n\nmight even be able to run RF on it directly, but in most cases it's\n\nenough and easier to just test the system using it's external\n\ninterfaces. If you have existing tools that can interact with those\n\ninterfaces you should be able to control them somehow, but you may\n\nalso want to (or need to) create new libraries to interact with the\n\ninterfaces directly. For example I'm going to work next week with at\n\nteam building a modem, and I expect that we'll use Telnet library [1]\n\nto control external simulators and also need to implement a new\n\nlibrary to interact with serial port using pySerial [2]. Giving any more detailed information is pretty much impossible without\n\nknowing your system and its interfaces better.\n\nSign in to reply to author You do not have permission to delete messages in this group Either email addresses are anonymous for this group or you need the view member email addresses permission to view the original message \n\n \n\nThe basic approach is that you need to be able to communicate with your embedded system in some way. We have one way to communicate that allows us to send keystrokes to the calculator as if a user were pressing keys on the keypad. We then have other keywords that allow us to query the calculator state in order to verify the result of the keypresses. This is used for user scenario testing via the calculator UI. We have another way of communicating with the software on the embedded device that allows us to make XML-RPC API calls to various exposed APIs in the calculator software. We use this approach to test the math algorithms on the calculator and have >2M such test cases, all driven via Robot Framework. \n\n \n\nIf you can share anything about your particular embedded device and how you want to test it I'd be willing to continue this discussion with you. \n\n \n\nCheers, \n\nMartin \n\n At Texas Instruments we use Robot Framework and a number of proprietary keyword libraries that I've built to test the embedded software on TI Calculators. Unfortunately I cannot share much about this because this software is all proprietary.The basic approach is that you need to be able to communicate with your embedded system in some way. We have one way to communicate that allows us to send keystrokes to the calculator as if a user were pressing keys on the keypad. We then have other keywords that allow us to query the calculator state in order to verify the result of the keypresses. This is used for user scenario testing via the calculator UI. We have another way of communicating with the software on the embedded device that allows us to make XML-RPC API calls to various exposed APIs in the calculator software. We use this approach to test the math algorithms on the calculator and have >2M such test cases, all driven via Robot Framework.If you can share anything about your particular embedded device and how you want to test it I'd be willing to continue this discussion with you.Cheers,Martin\n\nSign in to reply to author You do not have permission to delete messages in this group Either email addresses are anonymous for this group or you need the view member email addresses permission to view the original message \n\n>\n\n> At Texas Instruments we use Robot Framework and a number of proprietary keyword libraries that I've built to test the embedded software on TI Calculators. Unfortunately I cannot share much about this because this software is all proprietary.\n\n>\n\n> The basic approach is that you need to be able to communicate with your embedded system in some way. We have one way to communicate that allows us to send keystrokes to the calculator as if a user were pressing keys on the keypad. We then have other keywords that allow us to query the calculator state in order to verify the result of the keypresses. This is used for user scenario testing via the calculator UI. This is exactly the technique I would have recommend to use in this\n\ncase. The same idea obviously works great also with mobile phones and\n\nother similar devices. > We have another way of communicating with the software on the embedded device that allows us to make XML-RPC API calls to various exposed APIs in the calculator software. We use this approach to test the math algorithms on the calculator and have >2M such test cases, all driven via Robot Framework. This is a great idea too. Must be somewhat faster than running two\n\nmillion tests through the UI. This kind of a approach where the most important scenarios are tested\n\nthrough the UI similarly as a user would do them and business logic\n\ntests are run through some lower level interface is obviously not\n\nlimited to the embedded testing domain. It can be applied to web\n\ntesting, testing native desktop applications, etc. One variation of\n\nthe theme is executing tests through the lower level interface in\n\ncontinuous integration and running the same tests through the slower\n\nUI few times per day. With Robot Framework this is pretty easy to do\n\nby using variables in library and/or resource imports and setting\n\ncorrect variables from the command line.\n\nSign in to reply to author You do not have permission to delete messages in this group Either email addresses are anonymous for this group or you need the view member email addresses permission to view the original message \n\nsent to the rf-users list and added it to Cc.] [This mail was sent to me only, but I suspect it was supposed to besent to the rf-users list and added it to Cc.] 2010/9/14 Eileen Wei <eileen...@gmail.com>:\n\n> I found this discussion and this is something I am very interested\n\n> too. I will be testing desktop applications that's designed in C++, I\n\n> am wondering if anyone has any experience on exposing the C++\n\n> interface to Python so Robot Framework can use it? We have instructions, with an executable example, on how to use C from\n\nRobot Framework test libraries [1]. The example uses Python's ctypes\n\nmodule [2], and probably you can use it also to interact with C++ code\n\nsomehow. Please share your findings if you decide to try it! \n\n>>\n\n>>\n\n>>\n\n>> > At Texas Instruments we use Robot Framework and a number of proprietary keyword libraries that I've built to test the embedded software on TI Calculators. Unfortunately I cannot share much about this because this software is all proprietary.\n\n>>\n\n>> > The basic approach is that you need to be able to communicate with your embedded system in some way. We have one way to communicate that allows us to send keystrokes to the calculator as if a user were pressing keys on the keypad. We then have other keywords that allow us to query the calculator state in order to verify the result of the keypresses. This is used for user scenario testing via the calculator UI.\n\n>>\n\n>> This is exactly the technique I would have recommend to use in this\n\n>> case. The same idea obviously works great also with mobile phones and\n\n>> other similar devices.\n\n>>\n\n>> > We have another way of communicating with the software on the embedded device that allows us to make XML-RPC API calls to various exposed APIs in the calculator software. We use this approach to test the math algorithms on the calculator and have >2M such test cases, all driven via Robot Framework.\n\n>>\n\n>> This is a great idea too. Must be somewhat faster than running two\n\n>> million tests through the UI.\n\n>>\n\n>> This kind of a approach where the most important scenarios are tested\n\n>> through the UI similarly as a user would do them and business logic\n\n>> tests are run through some lower level interface is obviously not\n\n>> limited to the embedded testing domain. It can be applied to web\n\n>> testing, testing native desktop applications, etc. One variation of\n\n >> the theme is executing tests through the lower level interface incontinuousintegrationand running the same tests through the slower"
    }
]