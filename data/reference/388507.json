[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API",
        "document": "The Canvas API provides a means for drawing graphics via JavaScript and the HTML element. Among other things, it can be used for animation, game graphics, data visualization, photo manipulation, and real-time video processing. The Canvas API largely focuses on 2D graphics. The WebGL API, which also uses the element, draws hardware-accelerated 2D and 3D graphics.\n\nThe method gets a reference to the HTML element. Next, the method gets that element's context—the thing onto which the drawing will be rendered. The actual drawing is done using the interface. The property makes the rectangle green. The method places its top-left corner at (10, 10), and gives it a size of 150 units wide by 100 tall.\n\nThe Canvas API is extremely powerful, but not always simple to use. The libraries listed below can make the creation of canvas-based projects faster and easier.\n• EaselJS is an open-source canvas library that makes creating games, generative art, and other highly graphical experiences easy.\n• Fabric.js is an open-source canvas library with SVG parsing capabilities.\n• heatmap.js is an open-source library for creating canvas-based data heat maps.\n• Konva.js is a 2D canvas library for desktop and mobile applications.\n• p5.js has a full set of canvas drawing functionality for artists, designers, educators, and beginners.\n• Paper.js is an open-source vector graphics scripting framework that runs on top of the HTML Canvas.\n• Phaser is a fast, free and fun open source framework for Canvas and WebGL powered browser games.\n• Pts.js is a library for creative coding and visualization in canvas and SVG.\n• Rekapi is an animation key-framing API for Canvas.\n• Scrawl-canvas is an open-source JavaScript library for creating and manipulating 2D canvas elements.\n• The ZIM framework provides conveniences, components, and controls for coding creativity on the canvas — includes accessibility and hundreds of colorful tutorials.\n• Sprig is a beginner-friendly, open-source, tile-based game development library that uses Canvas. Note: See the WebGL API for 2D and 3D libraries that use WebGL."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes",
        "document": "Before we can start drawing, we need to talk about the canvas grid or coordinate space. Our HTML skeleton from the previous page had a canvas element 150 pixels wide and 150 pixels high. Normally 1 unit in the grid corresponds to 1 pixel on the canvas. The origin of this grid is positioned in the top left corner at coordinate (0,0). All elements are placed relative to this origin. So the position of the top left corner of the blue square becomes x pixels from the left and y pixels from the top, at coordinate (x,y). Later in this tutorial we'll see how we can translate the origin to a different position, rotate the grid and even scale it, but for now we'll stick to the default.\n\nUnlike SVG, only supports two primitive shapes: rectangles and paths (lists of points connected by lines). All other shapes must be created by combining one or more paths. Luckily, we have an assortment of path drawing functions which make it possible to compose very complex shapes. First let's look at the rectangle. There are three functions that draw rectangles on the canvas: Clears the specified rectangular area, making it fully transparent. Each of these three functions takes the same parameters. and specify the position on the canvas (relative to the origin) of the top-left corner of the rectangle. and provide the rectangle's size. Below is the function from the previous page, but now it is making use of these three functions.\n\nNow let's look at paths. A path is a list of points, connected by segments of lines that can be of different shapes, curved or not, of different width and of different color. A path, or even a subpath, can be closed. To make shapes using paths, we take some extra steps:\n• First, you create the path.\n• Then you use drawing commands to draw into the path.\n• Once the path has been created, you can stroke or fill the path to render it. Here are the functions used to perform these steps: Creates a new path. Once created, future drawing commands are directed into the path and used to build the path up. Methods to set different paths for objects. Adds a straight line to the path, going to the start of the current sub-path. Draws the shape by stroking its outline. The first step to create a path is to call the . Internally, paths are stored as a list of sub-paths (lines, arcs, etc.) which together form a shape. Every time this method is called, the list is reset and we can start drawing new shapes. Note: When the current path is empty, such as immediately after calling , or on a newly created canvas, the first path construction command is always treated as a , regardless of what it actually is. For that reason, you will almost always want to specifically set your starting position after resetting a path. The second step is calling the methods that actually specify the paths to be drawn. We'll see these shortly. The third, and an optional step, is to call . This method tries to close the shape by drawing a straight line from the current point to the start. If the shape has already been closed or there's only one point in the list, this function does nothing. Note: When you call , any open shapes are closed automatically, so you don't have to call . This is not the case when you call .\n\nOne very useful function, which doesn't actually draw anything but becomes part of the path list described above, is the function. You can probably best think of this as lifting a pen or pencil from one spot on a piece of paper and placing it on the next. Moves the pen to the coordinates specified by and . When the canvas is initialized or is called, you typically will want to use the function to place the starting point somewhere else. We could also use to draw unconnected paths. Take a look at the smiley face below. To try this for yourself, you can use the code snippet below. Just paste it into the function we saw earlier. The result looks like this: If you'd like to see the connecting lines, you can remove the lines that call . Note: To learn more about the function, see the Arcs section below.\n\nFor drawing straight lines, use the method. Draws a line from the current drawing position to the position specified by and . This method takes two arguments, and , which are the coordinates of the line's end point. The starting point is dependent on previously drawn paths, where the end point of the previous path is the starting point for the following, etc. The starting point can also be changed by using the method. The example below draws two triangles, one filled and one outlined. This starts by calling to start a new shape path. We then use the method to move the starting point to the desired position. Below this, two lines are drawn which make up two sides of the triangle. You'll notice the difference between the filled and stroked triangle. This is, as mentioned above, because shapes are automatically closed when a path is filled, but not when they are stroked. If we left out the for the stroked triangle, only two lines would have been drawn, not a complete triangle.\n\nTo draw arcs or circles, we use the or methods. Draws an arc which is centered at (x, y) position with radius r starting at startAngle and ending at endAngle going in the given direction indicated by counterclockwise (defaulting to clockwise). Draws an arc with the given control points and radius, connected to the previous point by a straight line. Let's have a more detailed look at the method, which takes six parameters: and are the coordinates of the center of the circle on which the arc should be drawn. is self-explanatory. The and parameters define the start and end points of the arc in radians, along the curve of the circle. These are measured from the x axis. The parameter is a Boolean value which, when , draws the arc counterclockwise; otherwise, the arc is drawn clockwise. Note: Angles in the function are measured in radians, not degrees. To convert degrees to radians you can use the following JavaScript expression: . The following example is a little more complex than the ones we've seen above. It draws 12 different arcs all with different angles and fills. The two loops are for looping through the rows and columns of arcs. For each arc, we start a new path by calling . In the code, each of the parameters for the arc is in a variable for clarity, but you wouldn't necessarily do that in real life. The and coordinates should be clear enough. and are fixed. The starts at 180 degrees (half a circle) in the first column and is increased by steps of 90 degrees, culminating in a complete circle in the last column. The statement for the parameter results in the first and third row being drawn as clockwise arcs and the second and fourth row as counterclockwise arcs. Finally, the statement makes the top half stroked arcs and the bottom half filled arcs. Note: This example requires a slightly larger canvas than the others on this page: 150 x 200 pixels. function draw() { const canvas = document.getElementById(\"canvas\"); if (canvas.getContext) { const ctx = canvas.getContext(\"2d\"); for (let i = 0; i < 4; i++) { for (let j = 0; j < 3; j++) { ctx.beginPath(); const x = 25 + j * 50; // x coordinate const y = 25 + i * 50; // y coordinate const radius = 20; // Arc radius const startAngle = 0; // Starting point on circle const endAngle = Math.PI + (Math.PI * j) / 2; // End point on circle const counterclockwise = i % 2 !== 0; // clockwise or counterclockwise ctx.arc(x, y, radius, startAngle, endAngle, counterclockwise); if (i > 1) { ctx.fill(); } else { ctx.stroke(); } } } } }\n\nThe next type of paths available are Bézier curves, available in both cubic and quadratic varieties. These are generally used to draw complex organic shapes. Draws a quadratic Bézier curve from the current pen position to the end point specified by and , using the control point specified by and . Draws a cubic Bézier curve from the current pen position to the end point specified by and , using the control points specified by ( , ) and ( , ). The difference between these is that a quadratic Bézier curve has a start and an end point (blue dots) and just one control point (indicated by the red dot) while a cubic Bézier curve uses two control points. The and parameters in both of these methods are the coordinates of the end point. and are the coordinates of the first control point, and and are the coordinates of the second control point. Using quadratic and cubic Bézier curves can be quite challenging, because unlike vector drawing software like Adobe Illustrator, we don't have direct visual feedback as to what we're doing. This makes it pretty hard to draw complex shapes. In the following example, we'll be drawing some simple organic shapes, but if you have the time and, most of all, the patience, much more complex shapes can be created. There's nothing very difficult in these examples. In both cases we see a succession of curves being drawn which finally result in a complete shape. This example uses multiple quadratic Bézier curves to render a speech balloon. This example draws a heart using cubic Bézier curves.\n\nAs we have seen in the last example, there can be a series of paths and drawing commands to draw objects onto your canvas. To simplify the code and to improve performance, the object, available in recent versions of browsers, lets you cache or record these drawing commands. You are able to play back your paths quickly. Let's see how we can construct a object: The constructor returns a newly instantiated object, optionally with another path as an argument (creates a copy), or optionally with a string consisting of SVG path data. new Path2D(); // empty path object new Path2D(path); // copy from another Path2D object new Path2D(d); // path from SVG path data All path methods like , , or , etc., which we got to know above, are available on objects. The API also adds a way to combine paths using the method. This can be useful when you want to build objects from several components, for example. Adds a path to the current path with an optional transformation matrix."
    },
    {
        "link": "https://docs.tizen.org/application/web/guides/w3c/graphics/canvas",
        "document": "The HTML5 canvas allows you to use graphics on the screen, and draw and manage various shapes. The HTML Canvas 2D Context API (in mobile, wearable, and TV applications) defines a special canvas element that expresses images or shapes with JavaScript.\n\nThe main features of the Canvas Element API include the following:\n• To draw and manage shapes, you must insert a <canvas> element in the HTML page.\n• You can use images on the canvas by using the applicable method of the HTML Canvas 2D Context API.\n• With the HTML Canvas 2D Context API, you can draw various shapes, such as rectangles, circles, and lines to a canvas. You can also draw and mask objects on the canvas.\n• You can use a canvas to create text or lines other than images and shapes.\n\nFor all canvas objects (images, shapes, text, and lines), you can define colors (the and attributes), shadows (the and attributes), and gradation (the method). You can also use the transformation methods, such as , , , and , to implement, for example, transparency or shape gradient transformations.\n\nIn mobile applications only, in HTML5, the Scalable Vector Graphics (SVG) 2 API provides similar features as the canvas. Their difference is that SVG expresses graphics using vectors, while the canvas is based on pixels. To express complex graphics, use the canvas, and to express graphics with a liberal expansion or reduction, use SVG.\n\nTo create a canvas in your application, follow these steps:\n• The canvas assigns the region (canvas context) where images are drawn with JavaScript: If no and attributes are inserted, the default value is .\n• To check the information on the image connected to the canvas, use the method to restore the URL of the image used on the canvas. To create a blob object of the image file, use the method.\n• Use the interface (in mobile, wearable, and TV applications) to connect to the canvas and get the canvas context: The interface has various methods and attributes for expressing images and shapes.\n• To manage the work stack of the canvas, use the following methods:\n• : Pushes the current state onto the stack.\n• : Pops the top state on the stack, restoring the context to that state.\n\nThere is a need to separately check whether the canvas 2D context can be used by using the method:\n\nFor the complete source code related to this use case, see the following files:\n\nUse images on the canvas\n\nTo use images on the canvas, use the method of the HTML Canvas 2D Context API. The method receives information, such as the image URL and position, and where it is indicated, and then creates the image on the canvas. The created image is pixel-based.\n\nTo use images on a canvas, follow these steps:\n• Use the method to express an image on the canvas. When you define the URL of the image to be imported and its coordinates, the original image is imported as it is. You can hide certain parts of the image by assigning its size accordingly:\n• When the image is connected to the canvas, extract the color value through the method. Re-input the transformed values with the method:\n• Use the interface to transform the selected object, for example, its size, angle, or position. By connecting to the image used on the canvas, you can also rotate it: The following figure applies to mobile applications only.\n\nFor the complete source code related to this use case, see the following files:\n\nWith the HTML Canvas 2D Context API, you can draw various shapes, such as rectangles ( ), circles ( and ), and lines ( and ), to a canvas. You can define the position and size of the shapes, and also merge shapes with other shape objects.\n\nTo create and draw shapes on a canvas, follow these steps:\n• Use the method to create a rectangle. Use the canvas context to assign the rectangle attributes, such as position and size: The following figure applies to mobile applications only.\n• Use the method to create a circle. Use the canvas context to assign the circle attributes, such as position and radius. (The following figure applies to mobile applications only.)\n• Use the interface to transform the created shapes. With compositing, a certain part of the shape can be made transparent. The following figure applies to mobile applications only.\n\nFor the complete source code related to this use case, see the following file:\n\nTo draw masks on a canvas, follow these steps:\n• Create the HTML layout with a canvas and 2 button input elements for brush selection:\n• Define the CSS style for the background image:\n• Declare the JavaScript variables needed in the application. The and variables indicate the last position of a user event. The variable indicates whether a button or touch event has occurred, and the variable indicates the current brush size:\n• Draw an image on the canvas using the method. The user is able to replace the image with another using a brush. Create a new object, including the path of the image file. Define the line width to be based on the brush size selected by the user:\n• The and events only store the event coordinates, the and events define the position and direction of the drawing, and the and events indicate that the user event ends, as illustrated in the following figure.\n• Use the method to update the and variable values. The real coordinates can be calculated by reducing the offset position of the canvas element from the touch position coordinates. The string indicates that the event is a touch event:\n• When the user starts drawing, the or event calls the method, which updates the event position, sets the composite operations property to make the drawing a mask, begins to draw a new path, moves the drawing point to the selected coordinates, and sets the button or touch event state to :\n• While the user is drawing, the and events are handled with the method based on the button state retrieved from the variable. The method calls the method only when the mouse or finger is being moved. Use the method to make the drawn line visible:\n• When the touch event ends or the mouse button is released, use the method to stop drawing:\n\nFor the complete source code related to this use case, see the following file:\n\nCreat text and lines on the canvas\n\nTo create text and lines on a canvas, follow these steps:\n• To draw a line, use the method to assign the beginning point of the line, and the method to assign the end point of the line. The method draws the full line:\n• When adding text on the canvas, use various attributes and methods to define how the text looks and where it is located. The attribute defines the font style, and the attribute the vertical alignment of the text:\n• Use the attribute and the method to position the text in the assigned location:\n\nFor the complete source code related to this use case, see the following files:\n\nPerformance comparison of Canvas 2D and WebGL™ in mobile applications\n\nIn Web documents prior to HTML5, only simple image loading was supported. To create graphic animations, you had to use a separate plug-in. However, as the graphic-related APIs have become more standardized, you can now express graphics by using only JavaScript, without a separate plug-in.\n\nWhen developing Web applications that need to express complex graphics, such as games, the most important issue to consider is graphic performance. Currently, the HTML Canvas 2D Context API and WebGL™ are used to express graphic elements in many games. The following example illustrates how to create an effective graphic animation by comparing the performance of the renderers in the Canvas 2D Context API and WebGL™.\n\nTo compare the performance, 2 simple Web applications must be created, using the Canvas 2D Context API and WebGL™:\n• Create the applications with the following logic:\n• Render the loaded image in the random location of the canvas.\n• Use the method of the Timing control for script-based animations API (in mobile, wearable, and TV applications) to change the color of the loaded image, based on different times.\n• Create a logic that measures FPS (frames per second) in order to check the performance.\n• Execute the applications and measure the FPS.\n• Increase only the number of objects so that the same 1~N images, under the same conditions, are shown repeatedly based on 1~N.\n• Measure the FPS as the number of repeatedly shown objects increase.\n\nThe following figure shows the result of the test: As the number of objects increase, the performance of the Canvas 2D Context API rapidly decreases compared to WebGL™ (the result is subject to change according to the complexity of the application logic). As such, when expressing many graphic objects all differently, it is much more efficient to use WebGL™ than the Canvas 2D Context API.\n\nThere is one problem with using WebGL™; the ratio of mobile browsers supporting it is quite low compared to the Canvas 2D Context API, and even when it is supported, usually only partial features are included (support for 3D acceleration, reflection effect, and camera effect is particularly low). The following figure shows the support status of WebGL™ in computer (top) and mobile (bottom) browsers, as published in http://webglstats.com/ in June 2013.\n\nMany mobile browsers do not support WebGL™ or only partially support WebGL™. Even though Tizen supports WebGL™, it is recommended to use the Canvas 2D Context API for small numbers of 2D drawings, since the API is supported in most mobile browsers. However, for performance critical applications, use WebGL™ for faster 2D performance."
    },
    {
        "link": "https://w3schools.com/jsref/api_canvas.asp",
        "document": "You access a element with the HTML DOM method .\n\nTo draw in the canvas you need to create a 2D context object:\n\nThe common way to draw on the canvas is to:\n\nThere are only 3 methods to draw directly on the canvas:\n\nThe canvas object also supports the standard properties and events.\n\nThe element is an HTML5 standard (2014).\n\nis supported in all modern browsers:"
    },
    {
        "link": "https://w3schools.com/tags/ref_canvas.asp",
        "document": "You can add a canvas element anywhere in an HTML page with the tag:\n\nYou can access a element with the HTML DOM method .\n\nTo draw in the canvas you need to create a 2D context object:\n\nAfter you have created a 2D context, you can draw on the canvas.\n\nThe fillRect() method draws a black rectangle with a top-left corner at position 20,20. The rectangle is 150 pixel wide and 100 pixels high.\n\nThe fillStyle property sets the fill color of the drawing object:\n\nYou can also create a new element with the method, and add the element to an existing HTML page:\n\nThe common way to draw on the canvas is to:\n\nThere are only 3 methods to draw directly on the canvas:\n\nThe canvas object also supports the standard properties and events.\n\nThe element is an HTML5 standard (2014).\n\nis supported in all modern browsers:"
    },
    {
        "link": "https://stackoverflow.com/questions/10750125/scaling-html5-canvas-width-preserving-w-h-aspect-ratio",
        "document": "I was playing around with this for a while myself. The concept revolves around knowing the width of the canvas. You also need to make sure all your canvas assets also use calculations to for posting dependent on the browser with. I documented my code, I hope it helps,"
    },
    {
        "link": "https://stackoverflow.com/questions/1664785/resize-html5-canvas-to-fit-window",
        "document": "The recommended way in 2022 to check if an element resized is to use\n\nIt's better than or because it handles EVERY case of the canvas resizing, even when it's not related to the window resizing.\n\nSimilarly it makes no sense to use , . You want the size of the canvas itself, not the size of the window. That way, no matter where you put the canvas you'll get the correct size for the situation and won't have to re-write your sizing code.\n\nAs for getting the canvas to fill the window\n\nThe reason you need is because by default the canvas is which means it includes extra space at the end. Without you'll get a scrollbar. Many people fix the scrollbar issue by adding to the body of the document but that's just hiding the fact that the canvas's CSS was not set correctly. It's better to fix the bug (set the canvas to than to hide the bug with\n\nYou might ask, why do we save the width and height in the callback instead of just setting the canvas size directly. The reason is, the HTML5 spec says that callbacks happen after callbacks but before compositing. Setting the width or height of canvas clears the canvas. Together that means, if the user resizes the order of operations will be\n\nWhich will end up with flicker. You can see it in this example which sets the canvas size directly inside the resizeobserver. Run it, pick \"Full page\", then size the browser window.\n\nIf you need to handle multiple canvases then you'll need a way to store the size for each . One way is with a\n\nNote: there are other issues related to resizing the canvas. Specifically if you want to deal with different devicePixelRatio settings. See this article for more."
    },
    {
        "link": "https://dev.to/georgedoescode/html5-canvas-responsive-2keh",
        "document": "I recently decided to learn SVG to see how it could help me with creative coding / generative art. Safe to say, I was blown away by how incredibly simple and easy it was to create truly responsive, scalable works that I could embed anywhere.\n\nThis was amazing for a while, until I started getting a craving for some bitmap action.\n\nNope, not cool. I had forgotten how painful it was to make actually look good.\n\nThe default element was a million miles away from the responsive, crisp rendering nirvana of SVG.\n\nEverything looked blurry on my retina screen, making the element fluid was a living nightmare and loosing my drawing state on resize made me sad (especially for generative stuff)\n\nAs a remedy to the issues outlined above, I have created a JavaScript library - that addresses the responsive issues of the default element.\n\nIt does this by introducing a attribute that works just like SVG's.\n\nYou can check the library out here on Github or here on NPM\n\nIn short, you can define a for your canvas - say (x, y, w, h) and draw everything relative to those coordinates. The setup looks something like this:\n\n\n\nThe element will then automatically scale / respond exactly like an element. You can set any dimensions you like, VBCanvas will take care of all the scaling for you.\n\nHere is a simple example in which the canvas is always scaled to fit it's container. Much like in CSS or for SVG.\n\nAnd here is an example where the canvas is scaled to fill it's container. Much like in CSS or for SVG.\n\nThe code for the two above examples is exactly the same, apart from the option which defines how the canvas should scale.\n\nNote: I have noticed that sometimes jumps frame rate in iFrames / embeds, if you notice some slightly wacky speed stuff in the examples, it's that.\n\nI suggest opening the examples up and seeing how the canvas responds to resizing the viewport.\n\nI hope some people find this library useful, and please do give me a shout on twitter @georgedoescode if you have any feedback. PRs / issues are of course always welcome 🙏"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas",
        "document": "Use the HTML element with either the canvas scripting API or the WebGL API to draw graphics and animations.\n\nThe height of the coordinate space in CSS pixels. Defaults to 150. Lets the canvas know whether translucency will be a factor. If the canvas knows there's no translucency, painting performance can be optimized. This is only supported by Mozilla-based browsers; use the standardized instead. The width of the coordinate space in CSS pixels. Defaults to 300.\n\nThe displayed size of the canvas can be changed using CSS, but if you do this the image is scaled during rendering to fit the styled size, which can make the final graphics rendering end up being distorted. It is better to specify your canvas dimensions by setting the and attributes directly on the elements, either directly in the HTML or by using JavaScript.\n\nThe exact maximum size of a element depends on the browser and environment. While in most cases the maximum dimensions exceed 10,000 x 10,000 pixels, notably iOS devices limit the canvas size to only 4,096 x 4,096 pixels. See canvas size limits in different browsers and devices. Note: Exceeding the maximum dimensions or area renders the canvas unusable — drawing commands will not work.\n\nA canvas can be rendered using the API where the document and canvas are decoupled. The benefit is that a worker thread can handle canvas rendering and the main thread of your web application is not blocked by canvas operations. By parallelizing work, other UI elements of your web application will remain responsive even if you are running complex graphics on an offscreen canvas. For more information, see the API documentation."
    },
    {
        "link": "https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html",
        "document": "Here's what you need to know to change the size of the canvas.\n\nEvery canvas has 2 sizes. The size of its drawingbuffer. This is how many pixels are in the canvas. The second size is the size the canvas is displayed. CSS determines the size the canvas is displayed.\n\nYou can set the size of the canvas's drawingbuffer in 2 ways. One using HTML\n\nThe other using JavaScript\n\nAs for setting a canvas's display size if you don't have any CSS that affects the canvas's display size the display size will be the same size as its drawingbuffer. So in the 2 examples above the canvas's drawingbuffer is 400x300 and its display size is also 400x300.\n\nHere's an example of a canvas whose drawingbuffer is 10x15 pixels that is displayed 400x300 pixels on the page\n\nor for example like this\n\nIf we draw a single pixel wide rotating line into that canvas we'll see something like this\n\nWhy is it so blurry? Because the browser takes our 10x15 pixel canvas and stretches it to 400x300 pixels and generally it filters it when it stretches it.\n\nSo, what do we do if, for example, we want the canvas to fill the window? Well, first we can get the browser to stretch the canvas to fill the window with CSS. Example\n\nNow we just need to make the drawingbuffer match whatever size the browser has stretched the canvas. This is unfortunately a complicated topic. Let's go over some different methods\n\nThis is the easiest way. and are properties every element in HTML has that tell us the size of the element in CSS pixels.\n\nUsing JavaScript we can check what size that element is being displayed and then adjust its drawingbuffer size to match.\n\nLet's call this function just before we render so it will always adjust the canvas to our desired size just before drawing.\n\nHey, something is wrong? Why is the line not covering the entire area?\n\nThe reason is when we resize the canvas we also need to call to set the viewport. tells WebGL how to convert from clip space (-1 to +1) back to pixels and where to do it within the canvas. When you first create the WebGL context WebGL will set the viewport to match the size of the canvas but after that it's up to you to set it. If you change the size of the canvas you need to tell WebGL a new viewport setting.\n\nLet's change the code to handle this. On top of that, since the WebGL context has a reference to the canvas let's pass that into resize.\n\nOpen that in a separate window, size the window, notice it always fills the window.\n\nI can hear you asking, why doesn't WebGL set the viewport for us automatically when we change the size of the canvas? The reason is it doesn't know how or why you are using the viewport. You could be rendering to a framebuffer or doing something else that requires a different viewport size. WebGL has no way of knowing your intent so it can't automatically set the viewport for you.\n\nWhy is that not the end of it? Well, This is where it gets complicated.\n\nThe first thing to understand is that most sizes in the browser are in CSS pixel units. This is an attempt to make the sizes device independent. So for example at the top of this article we set the canvas's display size to 400x300 CSS pixels. Depending on if the user has an HD-DPI display, or is zoomed in or zoomed out, or has an OS zoom level set, how many actual pixels that becomes on the monitor will be different.\n\nwill tell us in general, the ratio of CSS pixels to actual pixels on your monitor. For example here's your browser's current setting\n\nIf you're on a desktop or laptop try pressing + and + to zoom in and out ( + and + on Mac). You should see the number change except in Safari.\n\nSo if we want the number of pixels in the canvas to match the number of pixels actually used to display it the seemingly obvious solution would be to multiply and by the like this:\n\nWe need to call (or , or or ) to get the number to an integer because and are always in integers so our comparison might fail if is not an integer which is common, especially if the user's zooms.\n\nIn any case, this will not actually work. The new problem is that given a that is not 1.0 the CSS size the canvas needs to be to fill a given area might not be an integer value but and are defined as integers. Let's say the window is 999 actual device pixels wide your devicePixelRatio = 2.0 and you ask for 100% size canvas. There's no integer CSS size * 2.0 that = 999.\n\nThe next solution is to use . It returns a that has a and . It's the same client rect as represented by and but it is not required to be an integer.\n\nBelow is a purple that's set to of its container. Zoom out a few times to 75% or 60% and you may see its and its diverge.\n\nOn my machines I get these readings\n\nNote: Firefox showed 700 in this particular setup but with enough various test I've seen it give a non-integer result from for example make the window thin so that the 100% canvas is smaller than 700 and you might get a non-integer result on Firefox.\n\nSo, given that we could try using .\n\nSo are we done? Unfortunately no. It turns out that can not always return the exact correct size. The reason is complicated but it has to do with the way the browser decides to draw things. Some parts are decided at the HTML level and some parts are decided later at the \"compositor\" level (the part that actually draws). happens at the HTML level but certain things happen after that which could affect what size the canvas is actually drawn.\n\nI think an example is the HTML part works in the abstract and the compositor works in the concrete. So lets say you have a window that's 999 device pixels wide and a devicePixelRatio of 2.0. You make two elements side by side that are . So HTML computes each one should be 499.5 device pixels. But when it actually comes time to draw the compositor can't draw 499.5 pixels so one element gets 499 and the other gets 500. Which one gets or loses a pixel is undefined by any specs.\n\nThe solution the browser vendors came up with is to use the API and provide the actual size used via the property of the entries it provides. It returns the actual number of device pixels that were used. Note it's called the not the which means it's the actual part of the canvas element showing the content of the canvas so it doesn't include the padding like the , and , a nice benefit.\n\nIt's returned this way because the result is asynchronous. The \"compositor\" mentioned above runs asynchronously from the page. It can figure out the size it's actually going to use and then send you that size out of band.\n\nUnfortunately while the is available in all modern browser the is only available in Chrome/Edge so far. Here's how to use it.\n\nWe create a and we pass it a function to call anytime any elements we're observing change size. In our case that's our canvas.\n\nThe code above creates a that will call the function (below) when an element we observe changes size. We tell it to our canvas. We tell it to observe when the changes size. This is important and a little confusing. We could ask it to tell us when the changes size but let's imagine we have a canvas that is some percentage size of the window like the common 100% of our line example above. In that case our canvas will always be the same number of device pixels regardless of zoom level. The window hasn't changed size when we zoom so there's still the same number of device pixels. On the otherhand the will change as we zoom because it's measured in CSS pixels and so as we zoom, more or less CSS pixels fit in the number of device pixels.\n\nIf we don't care about the zoom level then we could just observe . It will throw an error if it's not supported so we'd do something like this\n\nThe function will be called with an array of s. One for each thing that changed size. We'll record the size in a map so that we can handle more than one element.\n\nThat's kind of a mess. You can see the API shipped at least 3 different versions before supporting 😂\n\nNow we'll change our resize function to use this data\n\nHere's an example using this code\n\nIt may be difficult to see any difference. If you have an HD-DPI display like your smartphone or all Macs since 2019 or maybe a 4k monitor then this line should be thinner than the line of the previous example.\n\nOtherwise, if you zoom in (I suggest you open the example in a new window), as you zoom in the line should stay the same resolution where as if you zoom in on the previous example the line will get thicker and lower-resolution since it's not adjusting to the .\n\nJust as a test here are all 3 methods above just using a simple canvas 2d. To keep it simple it does not use WebGL. Instead it uses Canvas 2D and makes 2 patterns, a 2x2 pixel vertical black and white pattern and a 2x2 pixel horizontal black and white pattern. It draws the horizontal pattern ▤ on the left and the vertical pattern ▥ on the right.\n\nResize this window, or better, open it in a new window and zoom in an out using the keys mentioned above. At different zoom levels resize the window, and notice only the bottom one works in all cases (in Chrome/Edge). Note the higher your device's the harder it may be to see problems. What you should see is an unvarying pattern on left and on the right. If you see harsh patterns or you see differing darkness like a gradient then it's not working. Since it will only work in Chrome/Edge you'll need to try it there to see it work.\n\nAlso note, some OSes (MacOS) provide an OS level scaling option that is mostly hidden from apps. In this case you'll see a slight pattern on the bottom example (assuming your in Chrome/Edge) but it will be a regular pattern.\n\nThis brings up the issue that there is no good solution on the other browsers but, do you need a real solution? The majority of WebGL apps do something like draw some things in 3D with textures and or lighting on them. As such it's often not noticeable to either use the top solution where we ignored or to use , or * and not worry about it past that.\n\nFurther, blindly using can really slow down your performance. On iPhoneX or iPhone11 is which means you'll be drawing 9 times as many pixels. On A Samsung Galaxy S8 that value is which means you'd be drawing 16 times as many pixels. That can really slow down your program. In fact it's a common optimization in games to actually render less pixels than are displayed and let the GPU scale them up. It really depends on what your needs are. If you're drawing a graph for printing you might want to support HD-DPI. If you're making a game you might not or you might want to give the user the option to turn support on or off if their system is not fast enough to draw so many pixels.\n\nOne other caveat is, at least in January 2021 the works on most modern browsers IF and ONLY IF the canvas is the full size of the window like the line example above. The exception is Safari where it doesn't work if the user's zoom level is not 100%. Here's an example using the patterns\n\nYou'll notice if you zoom and resize this page it will fail with . This is because the canvas is not the full window, it's in an iframe. Open the example in a separate window and it will work.\n\nWhich solution you use is up to you. For me, 99% of the time I don't use . It makes my pages slow and except for a few graphics pros most people won't notice a difference. On this site there are a few diagrams where it's used it but majority of examples do not.\n\nIf you look at many WebGL programs they handle resizing or setting the size of the canvas in many different ways. I think it's arguable the best way is to let the browser chose the size to display canvas with CSS and then looking up what size it chose and adjusting the number of pixels in the canvas in response. If you're curious here are some of the reasons I think the way described above is the preferable way."
    }
]