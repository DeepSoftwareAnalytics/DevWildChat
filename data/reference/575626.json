[
    {
        "link": "https://stackoverflow.com/questions/37709644/optimizing-java-8-stream-operations",
        "document": "So I was trying to optimize my code as much as possible. The following code used to run on 5,something seconds, however I managed to reduce it to about 1,4 seconds, however it's still not enough. What can I do to optimize this code even more? (Maybe I should mention that the times I talked about happen when the aux Map ends up with 170080 keys).\n\nAll the methods I use here are almost O(1) complexity and the comparator isn't too taxing either so that shouldn't be the problem, is there something I may not know that could help me optimize this stream operations? Maybe the entrySet I use can be avoided...? Because it's probably the most expensive operation here...\n\nEDIT1: Maybe I should explain the idea behind this method. It's main purpose is to order the map aux and return a list with the keys ordered (the keys are also modified but that's not the main intention)"
    },
    {
        "link": "https://rameshfadatare.medium.com/how-to-use-java-8-stream-api-in-java-projects-real-world-use-cases-ecf9d19d0c75",
        "document": "This is a member-only article. For non-members, read this article for free on my blog: How to Use Java 8 Stream API in Java Projects.\n\nThe Java 8 Stream API is one of the most powerful features introduced in Java 8. It provides a functional and declarative way to process collections efficiently. Unlike traditional loops, streams enable lazy evaluation, parallel execution, and concise code.\n\nIn this guide, we will explore real-world use cases of the Java Stream API with practical examples.\n\nA Stream is a sequence of elements supporting aggregate operations like filtering, mapping, and reducing. Streams do not modify the original collection; instead, they create a new transformed version.\n\n✔ Supports functional programming (using lambdas)\n\n ✔ Lazy evaluation (processes elements only when needed)\n\n ✔ Parallel execution ( )\n\n ✔ Works with Collections, Arrays, Files, and I/O\n\nIn an e-commerce application, we may need to filter products by price and sort them by name."
    },
    {
        "link": "https://linkedin.com/pulse/how-java-streams-make-your-code-more-efficient-nikhil-gargatte",
        "document": "How Java Streams Are More Efficient\n\nWhen you work with streams, you typically perform a series of operations on the data. These operations can include filtering, mapping, sorting, and reducing the elements of the stream. When you chain these operations together, Java creates a pipeline of operations that is executed on the data as it flows through the stream. Java streams can optimize these pipelines to minimize intermediate operations and improve performance. This is done automatically by the Java stream library, so you don't have to worry about optimizing your code manually. This can save you time and effort and ensure that your code is always running as efficiently as possible.\n\nOne of the key advantages of streams is that they can perform these operations lazily (we talk about this later in the article). This means that the operations are only executed as needed, and only on the elements of the stream that are actually used. This can help to reduce the amount of memory that is required and improve the performance of your code.\n\nIn this optimized pipeline, we use the mapToInt() method to square all the numbers in the stream, but we set the value to 0 for any odd numbers. This allows us to filter out the odd numbers and square the even numbers in a single pass over the data, without having to perform two separate operations.\n\nIn this example, the stream() method creates a stream from the list of strings. The filter() method then filters out all the strings that don't start with the letter \"a\". The findFirst() method returns the first string that matches the filter, or null if no such string exists. The orElse() method then returns the result or null if there is no result.\n\nJava streams are a powerful feature introduced in Java 8 that can help you write more efficient and readable code. By using Java streams, you can take advantage of stream pipeline optimization, parallel processing, lazy evaluation, and code readability. Hopefully, this article has given you a better understanding of Java streams and how they can be used to improve your Java code."
    },
    {
        "link": "https://stackoverflow.com/questions/44298236/how-optimized-are-java-8-stream-filters-over-collection-methods",
        "document": "Without tests it's impossible to tell, details internally can change of how one solutions of another acts, so the best way is to measure. It is know though that streams are a bit slower - they do have an infrastructure behind them...\n\nHere is a naive simple test (with little data):\n\nEven if you don't understand the code the results are simple numbers that you can compare:\n\nI am not going to show the rest of the results (for other parameters) since they are in the same range.\n\nBottom line is they do differ, by up to 100 ns; let me re-iterate that: nano-seconds.\n\nThere is a difference indeed; but if you really honestly care about this diff, then csv parsing is probably the wrong choice in the first place."
    },
    {
        "link": "https://medium.com/@mehmed6/mastering-data-manipulation-in-java-with-streams-a-comprehensive-guide-49b3e9918fd7",
        "document": "Java, a versatile and widely used programming language, empowers developers with tools to efficiently handle data. Among these tools, Java’s Stream API stands out as a powerful mechanism for data manipulation and processing within collections. In this comprehensive guide, we’ll embark on a journey through the fascinating world of Java Streams, exploring their intricacies, advanced features, and best practices.\n\nStreams, introduced in Java 8 and enhanced in subsequent versions, are a revolutionary addition to the language’s toolkit. They represent a sequence of elements that you can process sequentially or in parallel, providing a concise and functional approach to data manipulation. Streams allow you to perform a series of operations on data, such as filtering, mapping, sorting, and more, in a fluent and expressive style.\n\nLet’s start by delving into some fundamental Stream operations:\n\nFiltering enables you to select elements from a collection based on a specified condition. Here’s an example:\n\nIn this example, we filter and collect names longer than four characters.\n\nMapping transforms elements from one form to another using a provided function. Here’s a mapping example:\n\nIn this case, we map the words to their respective lengths.\n\nYou can sort elements using the operation. Both natural and custom sorting criteria can be specified:\n\nThis sorts the numbers in ascending order.\n\nThe operation allows you to reduce a collection to a single value, such as finding the sum or maximum value:\n\nHere, we calculate the sum and find the maximum value.\n\nThe operation restricts the number of elements in a Stream:\n\nThis selects the first five numbers.\n\nStreams are invaluable for grouping and summarizing data:\n\nHere, we group people by age and count people of each age.\n\nJava Streams also support parallel processing, utilizing multi-core processors for enhanced performance. To use parallel Streams, simply call the method:\n\nThis example filters and sums even numbers in parallel.\n\nWhen working with Streams, here are some best practices and considerations to keep in mind:\n• Use Streams for complex data manipulations and filtering to make your code more concise and expressive.\n• Be cautious with parallel Streams; they are not always faster due to the overhead of parallelization. Benchmarking is often necessary.\n• Consider immutability when using Streams to avoid side effects and ensure thread safety.\n• Streams are lazy by nature, so they only execute operations when necessary, optimizing performance.\n\nJava Streams provide a powerful and expressive way to manipulate data in collections. Whether you’re working with lists, sets, or even custom data sources, Streams can simplify your code and make it more readable. This guide has covered the basics and advanced use cases of Stream operations, as well as parallel processing. Mastering Streams will significantly enhance your Java programming skills and help you write efficient, elegant, and maintainable code.\n\nFor a deeper dive and a plethora of real-world examples, continue your exploration of the vast world of Java Streams. Happy coding!"
    },
    {
        "link": "https://baeldung.com/java-hashmap-remove-entry",
        "document": "In this article, we’ll discuss different ways to remove an entry from a Java HashMap.\n\nHashMap stores entries in (Key, Value) pairs with unique keys. Thus, one idea would be to use the key as an identifier to remove an associated entry from the map.\n\nWe can use the methods provided by the java.util.Map interface for entry removal using the key as an input.\n\nLet’s try it out using a simple example. We’ve got a map that associates food items with food types:\n\nLet’s remove the entry with the key “Apple”:\n\nThis is a variant of the first method and accepts both key and value as inputs. We use this method in case we want to delete an entry only if a key is mapped to a specific value.\n\nIn foodItemTypeMap, the key “Grape” is not mapped with the “Vegetable” value.\n\nAs a result, the below operation won’t lead to any updates:\n\nNow, let’s explore other scenarios of entry removal in a HashMap.\n\nThe HashMap class is unsynchronized. If we try to add or delete an entry concurrently, it might result in ConcurrentModificationException. Therefore, we need to synchronize the remove operation externally.\n\nOne approach is to synchronize on an object that encapsulates the HashMap. For example, we can use the entrySet() method of the java.util.Map interface to fetch a Set of entries in a HashMap. The returned Set is backed by the associated Map.\n\nThus, any structural modification of the Set would result in an update to the Map as well.\n\nLet’s remove an entry from the foodItemTypeMap using this approach:\n\nStructural modifications on the map might not be supported unless we’re using the iterator’s own methods for an update. As we can see in the above snippet, we’re invoking the remove() method on the iterator object instead of the map. This provides a thread-safe removal operation.\n\nWe can achieve the same result in Java 8 or later using the removeIf operation:\n\nThe java.util.concurrent.ConcurrentHashMap class provides thread-safe operations. Iterators for ConcurrentHashMap use only one thread at a time. Hence, they enable deterministic behavior for concurrent operations.\n\nWe can specify the number of concurrent thread operations permitted using ConcurrencyLevel.\n\nLet’s use the basic remove method for removing entries in a ConcurrentHashMap:\n\nWe have explored different scenarios of entry removal in a Java HashMap. If not iterating, we can use the standard entry removal methods provided by the java.util.Map interface safely.\n\nIn case we’re updating the Map during iteration, it’s imperative to use remove methods on an encapsulating object. Additionally, we analyzed an alternative class, ConcurrentHashMap, that enables thread-safe update operations on Map."
    },
    {
        "link": "https://stackoverflow.com/questions/1884889/iterating-over-and-removing-from-a-map",
        "document": "Well, there is, definitely, a better way to do so in a single statement, but that depends on the condition based on which elements are removed.\n\nFor eg: remove all those elements where is test, then use below:\n\nUPDATE It can be done in a single line using Lambda expression in Java 8.\n\nI know this question is way too old, but there isn't any harm in updating the better way to do the things :)"
    },
    {
        "link": "https://stackoverflow.com/questions/29876083/behavior-of-entryset-removeif-in-concurrenthashmap",
        "document": "I would like to use ConcurrentHashMap to let one thread delete some items from the map periodically and other threads to put and get items from the map at the same time.\n\nI'm using in the removing thread. I'm wondering what assumptions I can make about its behavior. I can see that method uses iterator to go through elements in the map, check the given condition and then remove them if needed using .\n\nDocumentation gives some info about ConcurrentHashMap iterators behavior:\n\nSimilarly, Iterators, Spliterators and Enumerations return elements reflecting the state of the hash table at some point at or since the creation of the iterator/enumeration. hey do not throw ConcurrentModificationException. However, iterators are designed to be used by only one thread at a time.\n\nAs the whole call happens in one thread I can be sure that the iterator is not used by more than one thread at the time. Still I'm wondering if the course of events described below is possible:\n• Deleting Thread calls inside call and gets the iterator reflecting the current state of the collection\n• Deleting thread still sees mapping (iterator reflects the old state) and because is true it decides to remove A key from the map.\n• The map now contains but deleting thread saw the old value of and the entry is removed even though it shouldn't be. The map is empty.\n\nI can imagine that the behavior may be prevented by the implementation in many ways. For example: maybe iterators are not reflecting put/remove operations but are always reflecting value updates or maybe the remove method of the iterator checks if the whole mapping (both key and value) is still present in the map before calling remove on the key. I couldn't find info about any of those things happening and I'm wondering if there's something which makes that use case safe."
    },
    {
        "link": "https://lankydan.dev/2019/03/03/removing-elements-from-a-map-in-java",
        "document": "Very short and simple post on removing elements from a in Java. We will be focusing on removing multiple elements and ignore the fact you can remove a single element using .\n\nThe below will be used for this post:\n\nThere are a few ways to remove elements. You could loop through the code manually and remove them:\n\nThis is how you would do it without access to Java 8+. The is needed to prevent s when removing elements from the .\n\nIf you do have access to newer versions of Java (8+) then you can choose from the below instead:\n\nis a method available to s. Yes, a itself is not a and does not have access to itself. But, by using: , or , a view of the ‘s contents is returned. This view implements allowing to be called on it.\n\nThe contents returned by , and are very important. Below is an extract of the JavaDoc for :\n\nThis JavaDoc explains that the returned by is backed by the and that changing either the or the will alter the other. I don’t think I can explain what the JavaDoc is saying any better than what is already written there… So I’ll stop trying on that part now. I have only shown the documentation for , but you can trust me when I say that and are also both backed by the ‘s contents. You can read the docs yourself if you don’t believe me.\n\nThis also links back to the first example using an older Java version. The documentation specifies that can be used. This is what is used earlier. Furthermore, the implementation of is very similar to the example. After talking about it, I might as well show it:\n\nThere is a bit extra to it. But, otherwise it is pretty much the same.\n\nSo, that’s that. Not much to conclude other than me telling you to remember that using: , , or will provide access to allowing easy removal of entries.\n\nIf you found this post helpful, you can follow me on Twitter at @LankyDanDev to keep up with my new posts."
    },
    {
        "link": "https://javarevisited.blogspot.com/2017/08/how-to-remove-key-value-pairs-from-hashmap-java8-example.html",
        "document": "How to delete a Key, Value, or Entry from a HashMap using the removeIf() function\n• What is the default method in Java 8? (example)\n• How to join String in Java 8 (example)\n• How to use filter() method in Java 8 (tutorial)\n• How to format/parse the date with LocalDateTime in Java 8? (tutorial)\n• How to use Stream class in Java 8 (tutorial)\n• How to convert List to Map in Java 8 (solution)\n• Difference between abstract class and interface in Java 8? (answer)\n• 20 Examples of Date and Time in Java 8 (tutorial)\n• How to use peek() method in Java 8 (example)\n• How to sort the map by keys in Java 8? (example)\n• How to sort the may by values in Java 8? (example)\n• 10 examples of Optionals in Java 8? (example)\n\nIn the last article, I have shown how to remove key/value pairs from a map in Java-based upon some conditions like removing all entries where values are greater than some values. I have told you that you must use the Iterator's remove() method for removing mapping while iteration to avoid ConcurrentModificationException, but that's not required anymore in Java 8. From JDK 8 onwards, you can selectively remove mapping without iterating over Map. The JDK 8 API has added several new methods to existing interfaces e.g.etc because the interface can now contain concrete methods in the form of static and default methods One such method is themethod of the Collection class which allows you to remove entries based upon some condition or predicate.It takes a lambda expression , which can be used to supply the predicate you want. For example, you can rewrite the above code in Java 8 as shown in the following example:Since here we need to compare values, I have called the values() method which returns a collection of values.Once you got that, you can simply callmethod which takes a. Just pass the condition you want to check for removing values from the map.Btw, if you are not familiar with the new functional programming API added on Java 8 then I suggest you first go through a comprehensive and up-to-date Java course. If you need recommendations, you can also check this list of the. It covers all important topics for Java developers and is also regularly updated to the latest Java versions.Btw, If you want to test keys from the Map for removing the mapping, you can just call the keySet() or entrySet() methods and apply thecall as shown below:Also here is more code to copy-paste and try yourself:You can see how easy it is to remove key-value pairs based upon some condition in Java. You can use the newly addedmethod from Collection to achieve that.So, all we did on our whole program, you can simply do it in just one line in Java 8. That's the beauty of Java 8. I strongly suggest you read a good book on Java 8 liketo learn more about such useful tricks.That's all about. You can see that now you can safely remove entries based upon some conditions without iterating over them, hence you don't need to use the Iterator'smethod to avoidin Java while removing entries from HashMap.If you are interested in learning more about the new features of Java 8, here are my earlier articles covering some of the important concepts of Java 8:Thanks for reading this article so far. If you like this article then please share it with your friends and colleagues. If you have any questions or suggestions then please drop a comment.If you are new to Java 8 features, particularly lambda expression and Stream API, and looking for a free online course to improve your functional programming skills then you can also join(FREE) course on Udemy. It's completely free and more than 27,000 students have already benefited from it."
    }
]