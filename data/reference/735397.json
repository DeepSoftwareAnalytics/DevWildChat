[
    {
        "link": "https://gnu.org/s/make/manual/html_node/Conditional-Syntax.html",
        "document": "The syntax of a simple conditional with no is as follows:\n\nThe may be any lines of text, to be considered as part of the makefile if the condition is true. If the condition is false, no text is used instead.\n\nThe syntax of a complex conditional is as follows:\n\nThere can be as many “ ” clauses as necessary. Once a given condition is true, is used and no other clause is used; if no condition is true then is used. The and can be any number of lines of text.\n\nThe syntax of the is the same whether the conditional is simple or complex; after an or not. There are four different directives that test different conditions. Here is a table of them:\n\nExpand all variable references in and and compare them. If they are identical, the is effective; otherwise, the , if any, is effective. Often you want to test if a variable has a non-empty value. When the value results from complex expansions of variables and functions, expansions you would consider empty may actually contain whitespace characters and thus are not seen as empty. However, you can use the function (see Functions for String Substitution and Analysis) to avoid interpreting whitespace as a non-empty value. For example: will evaluate even if the expansion of contains whitespace characters. Expand all variable references in and and compare them. If they are different, the is effective; otherwise, the , if any, is effective. The form takes the name of a variable as its argument, not a reference to a variable. If the value of that variable has a non-empty value, the is effective; otherwise, the , if any, is effective. Variables that have never been defined have an empty value. The text is expanded, so it could be a variable or function that expands to the name of a variable. For example: The variable reference is expanded, yielding , which is considered to be the name of a variable. The variable is not expanded, but its value is examined to determine if it is non-empty. Note that only tests whether a variable has a value. It does not expand the variable to see if that value is nonempty. Consequently, tests using return true for all definitions except those like . To test for an empty value, use . For example, bar = foo = $(bar) ifdef foo frobozz = yes else frobozz = no endif foo = ifdef foo frobozz = yes else frobozz = no endif If the variable has an empty value, the is effective; otherwise, the , if any, is effective. The rules for expansion and testing of are identical to the directive.\n\nExtra spaces are allowed and ignored at the beginning of the conditional directive line, but a tab is not allowed. (If the line begins with a tab, it will be considered part of a recipe for a rule.) Aside from this, extra spaces or tabs may be inserted with no effect anywhere except within the directive name or within an argument. A comment starting with ‘ ’ may appear at the end of the line.\n\nThe other two directives that play a part in a conditional are and . Each of these directives is written as one word, with no arguments. Extra spaces are allowed and ignored at the beginning of the line, and spaces or tabs at the end. A comment starting with ‘ ’ may appear at the end of the line.\n\nConditionals affect which lines of the makefile uses. If the condition is true, reads the lines of the as part of the makefile; if the condition is false, ignores those lines completely. It follows that syntactic units of the makefile, such as rules, may safely be split across the beginning or the end of the conditional.\n\nevaluates conditionals when it reads a makefile. Consequently, you cannot use automatic variables in the tests of conditionals because they are not defined until recipes are run (see Automatic Variables).\n\nTo prevent intolerable confusion, it is not permitted to start a conditional in one makefile and end it in another. However, you may write an directive within a conditional, provided you do not attempt to terminate the conditional inside the included file."
    },
    {
        "link": "https://web.mit.edu/gnu/doc/html/make_7.html",
        "document": "Go to the previous, next section.\n\nA causes part of a makefile to be obeyed or ignored depending on the values of variables. Conditionals can compare the value of one variable to another, or the value of a variable to a constant string. Conditionals control what actually \"sees\" in the makefile, so they cannot be used to control shell commands at the time of execution.\n\nThe following example of a conditional tells to use one set of libraries if the variable is , and a different set of libraries otherwise. It works by controlling which of two command lines will be used as the command for a rule. The result is that as an argument to changes not only which compiler is used but also which libraries are linked.\n\nThis conditional uses three directives: one , one and one .\n\nThe directive begins the conditional, and specifies the condition. It contains two arguments, separated by a comma and surrounded by parentheses. Variable substitution is performed on both arguments and then they are compared. The lines of the makefile following the are obeyed if the two arguments match; otherwise they are ignored.\n\nThe directive causes the following lines to be obeyed if the previous conditional failed. In the example above, this means that the second alternative linking command is used whenever the first alternative is not used. It is optional to have an in a conditional.\n\nThe directive ends the conditional. Every conditional must end with an . Unconditional makefile text follows.\n\nAs this example illustrates, conditionals work at the textual level: the lines of the conditional are treated as part of the makefile, or ignored, according to the condition. This is why the larger syntactic units of the makefile, such as rules, may cross the beginning or the end of the conditional.\n\nWhen the variable has the value , the above example has this effect:\n\nWhen the variable has any other value, the effect is this:\n\nEquivalent results can be obtained in another way by conditionalizing a variable assignment and then using the variable unconditionally:\n\nThe syntax of a simple conditional with no is as follows:\n\nThe may be any lines of text, to be considered as part of the makefile if the condition is true. If the condition is false, no text is used instead.\n\nThe syntax of a complex conditional is as follows:\n\nIf the condition is true, is used; otherwise, is used instead. The can be any number of lines of text.\n\nThe syntax of the is the same whether the conditional is simple or complex. There are four different directives that test different conditions. Here is a table of them:\n\nExtra spaces are allowed and ignored at the beginning of the conditional directive line, but a tab is not allowed. (If the line begins with a tab, it will be considered a command for a rule.) Aside from this, extra spaces or tabs may be inserted with no effect anywhere except within the directive name or within an argument. A comment starting with may appear at the end of the line.\n\nThe other two directives that play a part in a conditional are and . Each of these directives is written as one word, with no arguments. Extra spaces are allowed and ignored at the beginning of the line, and spaces or tabs at the end. A comment starting with may appear at the end of the line.\n\nConditionals affect which lines of the makefile uses. If the condition is true, reads the lines of the as part of the makefile; if the condition is false, ignores those lines completely. It follows that syntactic units of the makefile, such as rules, may safely be split across the beginning or the end of the conditional.\n\nevaluates conditionals when it reads a makefile. Consequently, you cannot use automatic variables in the tests of conditionals because they are not defined until commands are run (see section Automatic Variables).\n\nTo prevent intolerable confusion, it is not permitted to start a conditional in one makefile and end it in another. However, you may write an directive within a conditional, provided you do not attempt to terminate the conditional inside the included file.\n\nYou can write a conditional that tests command flags such as by using the variable together with the function (see section Functions for String Substitution and Analysis). This is useful when is not enough to make a file appear up to date.\n\nThe function determines whether one string appears as a substring of another. If you want to test for the flag, use as the first string and the value of as the other.\n\nFor example, here is how to arrange to use to finish marking an archive file up to date:\n\nThe prefix marks those command lines as \"recursive\" so that they will be executed despite use of the flag. See section Recursive Use of .\n\nGo to the previous, next section."
    },
    {
        "link": "https://stackoverflow.com/questions/8811526/using-conditional-rules-in-a-makefile",
        "document": "You need a space between and the string, and the string needs to be terminated:\n\nSurely you need an before the second ? (Even if it is not syntactically mandatory, I'd recommend it.)\n\nAdditionally, only executes commands such as is supposed to be when processing a target (rule). It won't execute there; it will simply object that you cannot define commands without them being actions for a target. Despite everything that GNU Make adds to a makefile, the language in a makefile is a declarative language and not a procedural language.\n\nAnother way of handling this is to define default values for the macros:\n\nDefine default values that do something semi-reasonable; let the user override the default if they want to. You can have a rule such as:\n\nYou can leave as the first rule. I have some directories where the first rule is:\n\nThis is equivalent to what you have (except that does not echo the command before running it, so I only see the message instead of the echo command line and the message; that's the at work). The makefile this comes from also has a rule which is otherwise usually the most sensible first (default) rule."
    },
    {
        "link": "https://docs.google.com/document/d/1oUR7iMnaNzkeT3TTOS-Gwul6_V3TE8caIDAd1FwPyNc/edit?usp=sharing",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/15977796/if-conditions-in-a-makefile-inside-a-target",
        "document": "I'm trying to setup a Makefile that will search and copy some files (if-else condition) and I can't figure out what exactly is wrong with it? (thou I'm pretty sure it's because a combination of spaces/tabs written in the wrong place). Can I get some help with it, please?\n\nHere's what I have currently:\n\nAnyways, that'll print \"Yes\", \"Copying header\" twice and then it will quit saying that sed can't read (which of course it can't read as I'm on a x64 system). I could say that just isn't understanding the if/else and instead is running everything line by line."
    },
    {
        "link": "https://stackoverflow.com/questions/19105241/how-do-you-conditionally-call-a-target-based-on-a-target-variable-makefile",
        "document": "I want a different version of the clean target to run based on whether or are run on a makefile.\n\nI'm not compiling anything per se, just want to conditionally call a particular target or set of targets based on a variable, for example:\n\nIs there a way to do this with Makefiles? I havent found anything yet that illustrates this use-case.\n\nI'm not trying to specifically clean anything or build anything this is just an example of me trying to conditionally call a set of targets. The actual targets could be anything else."
    },
    {
        "link": "https://stackoverflow.com/questions/30465466/using-condition-statements-with-makefile-targets",
        "document": "You did not indicate on what system you are running the Makefile, as there are slightly differing make programs available. Make can be run on linux and windows and comes in different variants.\n\nHowever, I have worked with most variants, and there is a common way you can resolve your problem. You have to realise that the makefile is not a program executed in the conventional sequential manner. It is a series of declarations or definitions of actions to be performed at some future time. You cannot read through it in a sequential manner like a program. In particular the definitions of dependencies are not executed and cannot be embedded within statements, even pre-processed statements.\n\nThe best way to achieve what you want it to put the dependencies in a variable and set that variable conditionally, like this:\n\nThis should work on most implementations."
    },
    {
        "link": "https://sciencedirect.com/topics/computer-science/conditional-execution",
        "document": ""
    },
    {
        "link": "https://gnu.org/s/make/manual/make.html",
        "document": ""
    },
    {
        "link": "https://github.com/nuke-build/nuke/issues/873",
        "document": "I would like to define based on input parameter. I have targets and and both can be executed separately on their own. But when I specify a parameter, then target should depend on target and so both will be run:\n\n_ _ c // This does not work, it is only for illustratory purpose.\n\nI tried and , but this way I cannot config target dependencies. Using as in exmaple above, it seems, that I can configure dependencies. But evaluation of runs very early and input parameters are not populated into the class. So the value of parameter is always .\n\n→ Runs only target .\n\n → Runs only target .\n\n → Runs target first, then target .\n\nI can manually run both targets , but it would be nice to make this logic just base on parameter value."
    }
]