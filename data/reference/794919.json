[
    {
        "link": "https://doc.traefik.io/traefik/providers/docker",
        "document": "Attach labels to your containers and let Traefik do the rest!\n\nWhen using Docker as a provider, Traefik uses container labels to retrieve its routing configuration.\n\nSee the list of labels in the dedicated routing section.\n\nBy default, Traefik watches for container level labels on a standalone Docker Engine.\n\nWhen using Docker Compose, labels are specified by the directive from the \"services\" objects.\n\nTraefik retrieves the private IP and port of containers from the Docker API.\n\nPort detection for private communication works as follows:\n• If a container exposes a single port, then Traefik uses this port.\n• If a container exposes multiple ports, then Traefik uses the lowest port. E.g. if and are exposed, Traefik will use .\n• If a container does not expose any port, or the selection from multiple ports does not fit, then you must manually specify which port Traefik should use for communication by using the label (Read more on this label in the dedicated section in routing).\n\nWhen exposing containers that are configured with host networking, the IP address of the host is resolved as follows:\n• if the lookup was unsuccessful, try a lookup of , (Podman equivalent of )\n• if that lookup was also unsuccessful, fall back to\n\nOn Linux, for versions of Docker older than 20.10.0, for to be defined, it should be provided as an to the Traefik container, using the flag. For example, to set it to the IP address of the bridge interface ( by default):\n\nWhen using a docker stack that uses IPv6, Traefik will use the IPv4 container IP before its IPv6 counterpart. Therefore, on an IPv6 Docker stack, Traefik will use the IPv6 container IP.\n\nTraefik requires access to the docker socket to get its dynamic configuration.\n\nYou can specify which Docker API Endpoint to use with the directive .\n\nSee the Docker API Access section for more information.\n\nDefines the username for Basic HTTP authentication. This should be used when the Docker daemon socket is exposed through an HTTP proxy that requires Basic HTTP authentication.\n\nDefines the password for Basic HTTP authentication. This should be used when the Docker daemon socket is exposed through an HTTP proxy that requires Basic HTTP authentication.\n\nTraefik routes requests to the IP/port of the matching container. When setting , you tell Traefik to use the IP/Port attached to the container's binding instead of its inner network IP/Port.\n\nWhen used in conjunction with the label (that tells Traefik to route requests to a specific port), Traefik tries to find a binding on port . If it cannot find such a binding, Traefik falls back on the internal network IP of the container, but still uses the that is set in the label.\n\nExpose containers by default through Traefik. If set to , containers that do not have a label are ignored from the resulting routing configuration.\n\nFor additional information, refer to Restrict the Scope of Service Discovery.\n\nDefines a default docker network to use for connections to all containers.\n\nThis option can be overridden on a per-container basis with the label.\n\nThe option defines what routing rule to apply to a container if no rule is defined by a label.\n\nIt must be a valid Go template, and can use sprig template functions. The container name can be accessed with the identifier. The service name can be accessed with the identifier. The template has access to all the labels defined on this container with the identifier.\n\nDefines the client timeout (in seconds) for HTTP connections. If its value is , no timeout is set.\n\nThe option can be set to an expression that Traefik matches against the container labels to determine whether to create any route for that container. If none of the container labels match the expression, no route for that container is created. If the expression is empty, all detected containers are included.\n\nThe expression syntax is based on the , and functions, as well as the usual boolean logic, as shown in examples below.\n\nFor additional information, refer to Restrict the Scope of Service Discovery.\n\nDefines the TLS configuration used for the secure connection to Docker.\n\nis the path to the certificate authority used for the secure connection to Docker, it defaults to the system bundle.\n\nis the path to the public certificate used for the secure connection to Docker. When using this option, setting the option is required.\n\nis the path to the private key used for the secure connection Docker. When using this option, setting the option is required.\n\nIf is , the TLS connection to Docker accepts any certificate presented by the server regardless of the hostnames it covers.\n\nIf the parameter is set to , any servers load balancer defined for Docker containers is created regardless of the healthiness of the corresponding containers. It also then stays alive and responsive even at times when it becomes empty, i.e. when all its children containers become unhealthy. This results in HTTP responses instead of ones, in the above cases."
    },
    {
        "link": "https://doc.traefik.io/traefik/reference/install-configuration/providers/docker",
        "document": "You can enable the Docker provider as detailed below:\n\nAttach labels to containers (in your Docker compose file)\n\nSee the Docker API Access section for more information.\n\nTraefik routes requests to the IP/port of the matching container. When setting , you tell Traefik to use the IP/Port attached to the container's binding instead of its inner network IP/Port.\n\nWhen used in conjunction with the label (that tells Traefik to route requests to a specific port), Traefik tries to find a binding on port . If it cannot find such a binding, Traefik falls back on the internal network IP of the container, but still uses the that is set in the label.\n\nThe option defines what routing rule to apply to a container if no rule is defined by a label.\n\nIt must be a valid Go template, and can use sprig template functions. The container name can be accessed with the identifier. The service name can be accessed with the identifier. The template has access to all the labels defined on this container with the identifier.\n\nThe option can be set to an expression that Traefik matches against the container labels to determine whether to create any route for that container. If none of the container labels match the expression, no route for that container is created. If the expression is empty, all detected containers are included.\n\nThe expression syntax is based on the , and functions, as well as the usual boolean logic, as shown in examples below.\n\nFor additional information, refer to Restrict the Scope of Service Discovery.\n\nWhen using Docker as a provider, Traefik uses container labels to retrieve its routing configuration.\n\nSee the list of labels in the dedicated routing section.\n\nBy default, Traefik watches for container level labels on a standalone Docker Engine.\n\nWhen using Docker Compose, labels are specified by the directive from the \"services\" objects.\n\nTraefik retrieves the private IP and port of containers from the Docker API.\n\nPort detection for private communication works as follows:\n• If a container exposes a single port, then Traefik uses this port.\n• If a container exposes multiple ports, then Traefik uses the lowest port. E.g. if and are exposed, Traefik will use .\n• If a container does not expose any port, or the selection from multiple ports does not fit, then you must manually specify which port Traefik should use for communication by using the label (Read more on this label in the dedicated section in routing).\n\nWhen exposing containers that are configured with host networking, the IP address of the host is resolved as follows:\n• if the lookup was unsuccessful, try a lookup of , (Podman equivalent of )\n• if that lookup was also unsuccessful, fall back to\n\nOn Linux, for versions of Docker older than 20.10.0, for to be defined, it should be provided as an to the Traefik container, using the flag. For example, to set it to the IP address of the bridge interface ( by default): .\n\nWhen using a docker stack that uses IPv6, Traefik will use the IPv4 container IP before its IPv6 counterpart. Therefore, on an IPv6 Docker stack, Traefik will use the IPv6 container IP.\n\nTraefik requires access to the docker socket to get its dynamic configuration.\n\nYou can specify which Docker API Endpoint to use with the directive ."
    },
    {
        "link": "https://docs.docker.com/guides/traefik",
        "document": "During local development, it’s quite common to need to run multiple HTTP services. You might have both an API and a frontend app, a WireMock service to mock data endpoints, or a database visualizer (such as phpMyAdmin or pgAdmin). In many development setups, these services are exposed on different ports, which then requires you to remember what’s on what port but can also introduce other problems (such as CORS).\n\nA reverse proxy can dramatically simplify this setup by being the single exposed service and then routing requests to the appropriate service based on the request URL (either by path or hostname). Traefik is a modern, cloud-native reverse proxy and load balancer that makes developing and deploying multi-service applications easier. This guide will show you how to use Traefik with Docker to enhance your development environment.\n\nIn this guide, you will learn how to:\n• Configure routing rules to split traffic between two containers\n• Use Traefik to send requests to non-containerized workloads\n\nThe following prerequisites are required to follow along with this how-to guide:\n\nOne of the unique features of Traefik is its ability to be configured in many ways. When using the Docker provider, Traefik gets its configuration from other running containers using labels . Traefik will watch engine events (for container starts and stops), extract the labels, and update its configuration.\n\nWhile there are many Traefik-monitored labels , the two most common will be:\n• - used to indicate the routing rule ( view all of the available rules here )\n• - indicates the port Traefik should forward the request to. Note that this container port does not need to be exposed on your host machine ( read about port detection here )\n\nLet’s do a quick demo of starting Traefik and then configuring two additional containers to be accessible using different hostnames.\n• None In order for two containers to be able to communicate with each other, they need to be on the same network. Create a network named using the command:\n• None Start a Traefik container using the following command. The command exposes Traefik on port 80, mounts the Docker socket (which is used to monitor containers to update configuration), and passes the argument to configure Traefik to use the Docker provider.\n• None Now, start a simple Nginx container and define the labels Traefik is watching for to configure the HTTP routing. Note that the Nginx container is not exposing any ports. Once the container starts, open your browser to http://nginx.localhost to see the app (all Chromium-based browsers route *.localhost requests locally with no additional setup).\n• None Start a second application that will use a different hostname. Once the container starts, open your browser to http://welcome.localhost . You should see a “Welcome to Docker” website.\n\nNow that you’ve experienced Traefik, it’s time to try using it in a development environment. In this example, you will use a sample application that has a split frontend and backend. This app stack has the following configuration:\n• All requests to /api to go to the API service\n• All other requests to localhost go to the frontend client\n• Since the app uses MySQL, db.localhost should provide phpMyAdmin to make it easy to access the database during development\n\nThe application can be accessed on GitHub at dockersamples/easy-http-routing-with-traefik .\n• None In the file, Traefik is using the following configuration: Note that this is essentially the same configuration as used earlier, but now in a Compose syntax.\n• None The client service has the following configuration, which will start the container and provide it with the labels to receive requests at localhost.\n• None The api service has a similar configuration, but you’ll notice the routing rule has two conditions - the host must be “localhost” and the URL path must have a prefix of “/api”. Since this rule is more specific, Traefik will evaluate it first compared to the client rule.\n• None And finally, the service is configured to receive requests for the hostname “db.localhost”. The service also has environment variables defined to automatically log in, making it a little easier to get into the app.\n• None Before starting the stack, stop the Nginx container if it is still running.\n\nAnd that’s it. Now, you only need to spin up the Compose stack with a and all of the services and applications will be ready for development.\n\nIn some situations, you may want to forward requests to applications not running in containers. In the following architecture diagram, the same application from before is used, but the API and React apps are now running natively on the host machine.\n\nTo accomplish this, Traefik will need to use another method to configure itself. The File provider lets you define the routing rules in a YAML document. Here is an example file:\n\nThis configuration indicates that requests that for will be forwarded to a service named , which then forwards the request to http://host.docker.internal:3000 . The hostname is a name that Docker Desktop provides to send requests to the host machine.\n\nWith this file, the only change is to the Compose configuration for Traefik. There are specifically two things that have changed:\n• The configuration file is mounted into the Traefik container (the exact destination path is up to you)\n• The is updated to add the file provider and point to the location of the configuration file\n\nTo run the example app that forwards requests from Traefik to native-running apps, use the following steps:\n• None If you have the Compose stack still running, stop it with the following command:\n• None Start the application using the provided file: Opening http://localhost will return a 502 Bad Gateway because the other apps aren’t running yet.\n• None Start the API by running the following steps:\n• None Start the frontend by running the following steps in a new terminal (starting from the root of the project):\n• None Open the app at http://localhost . You should see an app that fetches a message from http://localhost/api/messages . You can also open http://db.localhost to view or adjust the available messages directly from the Mongo database. Traefik will ensure the requests are properly routed to the correct container or application.\n• None When you’re done, run to stop the containers and stop the Yarn apps by hitting .\n\nRunning multiple services doesn’t have to require tricky port configuration and a good memory. With tools like Traefik, it’s easy to launch the services you need and easily access them - whether they’re for the app itself (such as the frontend and backend) or for additional development tooling (such as phpMyAdmin)."
    },
    {
        "link": "https://hub.docker.com/_/traefik",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/Traefik/comments/1ano7r4/using_both_host_network_and_docker_containers",
        "document": "I'm new to traefik (and not greatly experienced with docker), and I'm struggling to understand how to configure it for my use case.\n\nTraefik is running in a docker container, alongside some other containers on the same docker host. This part works great, including letsencrypt certificates.\n\nI also have some other applications running on other hosts on my network that I would like to have behind traefik.\n\nBut I don't understand how to configure traefik/docker to allow traefik to manage requests to these other hosts.\n\nSo my setup is something like:\n\nCan someone tell me how I can achieve this?\n\nEDIT: I now have it working!\n\nFirst I needed the correct router/service setup, which is, for me:\n\nNext, I was using the wrong network configuration in docker. Using the default network seemed to help.\n\nAnd finally I had to add:\n\nIt helped enormously to turn on logging for traefik to see what problems there were, which I did with:\n\nwhere in the traefik container is mapped to a folder on the host that I could easily look at.\n\nThanks for everyone's help!"
    },
    {
        "link": "https://community.traefik.io/t/setting-up-traefik-for-docker-and-external-services/14151",
        "document": "An advanced Guide on how to setup and use Traefik 2.0"
    },
    {
        "link": "https://community.traefik.io/t/routing-traefik-2-to-mutiple-hosts-outside-hosted-docker-enviroment/9885",
        "document": "so, little new here... maybe I don't know what I need to be asking.... but here goes...\n\nI have mutiple containers running... all on different ports... redirecting their internal port (80->8080) example....\n\nhow do I configure mapping a host in my network... running another application:\n\nInternet traffic ports 80/443 directed to 192.168.1.100\n\n Container 1 runs on port 8080 on 192.168.1.100\n\n Container 2 runs on port 8081 on 192.168.1.100\n\n Container 3 runs on port 8082 on 192.168.1.100\n\nContainer 4 runs on port 8090 on 192.168.1.101\n\n Container 5 runs on port 8091 on 192.168.1.101\n\nI need :\n\n 8080 to resolve to app1.mydomain.com\n\n 8081 to resolve to app2...\n\n 8082 to resolve to app3...\n\n 8090 to resolve to app4...\n\n 8091 to resolve to app5...\n\nI am not sure where I can make these changes, or what this specifically is called....\n\nany help would be greatly appreciated.\n\nI am hosting on cloudflare so....\n\nthanks for any assistance anyone can provide."
    },
    {
        "link": "https://reddit.com/r/Traefik/comments/dc2pn7/how_to_direct_traefik_v2_to_nondocker_services",
        "document": "I figured it's something like ...loadbalancers.server.url, but I just get 404s. The Traefik debug logs seem to show anything.\n\nI've had a hell of a time containerizing Plex, so I'm trying to redirect Plex.mydomain to localhost:32400. There's a couple others I want to do this for, too.\n\nThis is my file provider:"
    },
    {
        "link": "https://forums.docker.com/t/how-to-let-traefik-reverse-proxy-services-that-are-outside-of-docker-that-running-traefik/126041",
        "document": "Hi,I am new to docker and I find docker is easy to deploy services and I like it.I have use traefik to reverse-proxy containers on the same docker,and I can visit their webpages with domain.But I can’t apply the same thing to services that are outside of docker.\n\n I have done some research,the answer may be related to docker’s nat.So I created a new VM to test it.The new VM only installed docker,and has only one container which is nginx.Let’s call the new VM’s nginx n2,because the old VM I used has a nginx too,let’s call that n1.I will use n1 as a reverse proxy later with traefik disabled.\n\n Before test,I will tell you what I have done yet.I run VMware on a windows machine which IP address is 192.168.0.197,and use it to create 2 VMs.And there is a service running on windows has a webpage.Frist VM,VM1,is using Ubuntu server 20.04 as OS,with webmin and docker 20.10.17 installed,with 3 containers(portainer,traefik,nginx),IP 192.168.0.130.Second VM,VM2,also Ubuntu server 20.04,docker 20.10.17,nginx,IP 192.168.0.120.VM1 have are not enabled promiscuous mode yet.VM2 will not enable promiscuous mode.\n\n All file related are show below:\n\n traefik.yml nginx.conf(I actually use one at a time) This the line I created macvlan,Don’t worry they will not confilct with my other devices. So let’s start the test.N1 was not configed yet.I first used traefik as reverse proxy provider,opened traefik dashboard and saw services running,then visiting webpages one by one,then changed network type one by one.Then I shuted down traefik,changed configraton in nginx.conf one by one.And changed n1’s port to 80.And repeat.Then enabled promiscuous mode on VM1 and repeat.Then deleted nginx.conf and changed n1’s port to 180 and started traefik.And repeat.\n\n Test result:\n\n \n\n N2 is showing 404.App is showing 504.\n\n From start to end,traefik cannot reverse-proxy services outside of docker,not even by traefik’s ip.Last line is the most interested.With promiscuous mode enabled,and macvlan mode,although I can’t visit n2 and app by domain,but I can visit them by nginx’s ip.So it means container using macvlan with promiscuous mode enabled can communicate with services outside of docker.But why not by domain?\n\n Messing up with promiscuous mode eventually caused VM1’s docker broke down.I can’t visit containers’ webpage on VM1 again.\n\n So can anyone teach me how to let traefik reverse-proxy services outside of docker.\n\nThis is a rather complex setup, and without testing it probably will always remain guessing, but we can still try to untangle it. Your config.yml looks fine, except that’s I am unsure if support the sequence style you used and the key/value style. The documentation uses the later. Until the setup works as you intended, I would suggest to comment or remove the entrypoints from the config. Once overything is running, you can still re-add them. The example you shared is for running the vm’s network interfaces in bridge mode (=getting a local lan ip) and running the containers on each docker engine in bridge mode as well. You should be able to reach each of those urls from a browser on your windows system - does it work for all of them? If this is not working then you already have a another problem to solve first. Regardings your macvlan: I would higly recommend to use the option and provide a range that is not handled by your networks dhcp server. Also: a mac vlan parent interface is not able to directly communicate with any of its child interfaces or vise versa (this is not a limitation introduced by docker, but there is a way to work arround that limitation). Afaik, If traefik is not using a macvlan ip itself, it will not be able to communicate with the other macvlan ips on the same node. Your windows host on the other side should be able to communicate with every macvlan ip - of course that is if promiscous mode is enabled for the interface.\n\n Again: test if you can reach all target ip:ports from your Windows host to make sure the services themself work as they should. One more thing: is you local dns able to resolve the domains you use?\n\nI would suggest to comment or remove the entrypoints from the config. I have tried change web to “web” or comment the entrypoints from the config,and still the same,I can’t even see a change in traefik dashboard. The example you shared is for running the vm’s network interfaces in bridge mode (=getting a local lan ip) and running the containers on each docker engine in bridge mode as well. You should be able to reach each of those urls from a browser on your windows system - does it work for all of them? If this is not working then you already have a another problem to solve first. Yes the VMs’ network interfaces are in bridge mode.N2 was using bridge mode too.Treafik and n1 used bridge,host and macvlan mode one by one.App was on windows.Webmin was running on VM1.I can visit them with ip:port,except traefik,since it didn’t expose port.But I can visit traefik with domain.Those services were working fine. a mac vlan parent interface is not able to directly communicate with any of its child interfaces or vise versa Yes,I tested it today,and it returned 404.I must have joined traefik and nginx to traefik_test network thatday. Afaik, If traefik is not using a macvlan ip itself, it will not be able to communicate with the other macvlan ips on the same node. I’ve done a new test today.I only used VM1 this time.VM1’s promiscous mode was enabled.Traefik and jellyfin were both in macvlan mode.And I cannot use traefik to reverse proxy jellyfin.But traefik can ping jellyfin. Your windows host on the other side should be able to communicate with every macvlan ip - of course that is if promiscous mode is enabled for the interface. My windows can communicate with traefik in macvlan mode with or without promiscous mode enabled. Again: test if you can reach all target ip:ports from your Windows host to make sure the services themself work as they should. Yes, I can reach all target ip:ports. One more thing: is you local dns able to resolve the domains you use?\n\nThere is one thing that realy is confusing in the example from above.\n• The routers have a rule per router to forward traffic to a service loadbalancer based by a full qualliifed domain name. The loadbalancer targets are called by ip.\n• The nginx config, has different server blocks which listen on ip and port, but use a proxy_pass directive, which uses the same full qualified domain name, the router rule in treafik used… Something is not adding up here… To which ip do the dns overrides resolve all the domains? If you want to use traefik, they must resolve to the ip of traefik. Your nginx.conf looks weird: the should be a fqdn or ip, but not fqdn:port or ip:port. The port is already handled by the directive. You must be running three different instances, which each need one of the server blocks you declared. Also the node where nginx is running must have the pihole as first nameserver in /etc/resolv.conf in order to leverage the overrides… and even if it doesn’t… don’t you create a recursive loop, as you point them to traefik again?\n\nOh,I just find out I put IP:ports in location and domain in server name.Sorry about that,I can’t find the edit button there,so I can’t edit the config to right.I pasted the wrong config instead.But don’t worry,I used the right configs when testing frist.And I changed to the wrong configs to test again when I could visit services by nginx’s ip and nothing crushed.Because I’m not familiar with nginx,I ran it 12 times,each time there is only one service in nginx.conf,I didn’t put 3 services all in.After nginx’s tests were over,I deleted nginx.conf,so they will not confilct with traefik.\n\n And I don’t want to use nginx.I just learn it last minute trying to prove traefik is not alone useless when trying to reverse proxy services outside of docker.I just want to use traefik.So let’s ignore nginx.Just focus on traefik.I’m positive about my traefik’s config.They work flawlessly in bridge mode.\n\n The name server is always pihole.As far as I know,neither traefik nor nginx is name server.\n\nAs far as I know,neither traefik nor nginx is name server. not sure what this is supposed to mean, but the underlying nodes need to be configured to have pihole as first nameserver configured if they (and containers running on them) should be able to resolve the domain names. The big picture still feels ambigous, and always in flux for me, I won’t be able to help. You might want to post your current state with all details relevant to the setup with actual configurations… Sometimes people tend to create abstract examples, where they leave out parts they think are irrelevant, but in fact cause the problem… I have seen this a lot in the past…\n\nThat line means I thought windows has pihole as name server,so it knows services’ ip,but doesn’t know the port,so reverse proxy sould tell the port,but traefik has it own ip,so I change windows’ name server to traefik,and everything become 404. I am not entirely sure what you try to do there, but I wrote a couple of times that the first nameserver of the hosts (in your case the vm’s) need to have the nameserver entry for pihole as first entry in /etc/resolv.conf. Why would they (=vm’s) care what nameserver is configured in your windows host?! update: This is only relevant if containers or the nodes should be able to resolve the domain names. For traefik itself, it doesn’t matter, as it reads the information from the http header (same is true for https, when tls-offloading is used). Do you realy just want your traefik api to be reachable via https`? and the rest only via http? Never the less, I feel there is not much I can do for you. I hope someone else is able to pitch in."
    },
    {
        "link": "https://reddit.com/r/Traefik/comments/xoodmw/routing_from_docker_to_host_services",
        "document": "I have a Raspberry Pi 4 running Traefik for reverse proxy and it works great with other docker containers. I also have a couple of services I run on the host without docker. I have been trying to route traefik to the services without docker for days but I can not seem to manage. Maybe I am phrasing it wrong on but I hope you get the point.\n\nAny suggestions on how to solve this problem or which words to choose to search?"
    }
]