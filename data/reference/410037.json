[
    {
        "link": "https://kotlinlang.org/docs/classes.html",
        "document": "Classes in Kotlin are declared using the keyword :\n\nThe class declaration consists of the class name, the class header (specifying its type parameters, the primary constructor, and some other things), and the class body surrounded by curly braces. Both the header and the body are optional; if the class has no body, the curly braces can be omitted.\n\nA class in Kotlin has a primary constructor and possibly one or more secondary constructors. The primary constructor is declared in the class header, and it goes after the class name and optional type parameters.\n\nIf the primary constructor does not have any annotations or visibility modifiers, the keyword can be omitted:\n\nThe primary constructor initializes a class instance and its properties in the class header. The class header can't contain any runnable code. If you want to run some code during object creation, use initializer blocks inside the class body. Initializer blocks are declared with the keyword followed by curly braces. Write any code that you want to run within the curly braces.\n\nDuring the initialization of an instance, the initializer blocks are executed in the same order as they appear in the class body, interleaved with the property initializers:\n\n//sampleStart class InitOrderDemo(name: String) { val firstProperty = \"First property: $name\".also(::println) init { println(\"First initializer block that prints $name\") } val secondProperty = \"Second property: ${name.length}\".also(::println) init { println(\"Second initializer block that prints ${name.length}\") } } //sampleEnd fun main() { InitOrderDemo(\"hello\") }\n\nPrimary constructor parameters can be used in the initializer blocks. They can also be used in property initializers declared in the class body:\n\nKotlin has a concise syntax for declaring properties and initializing them from the primary constructor:\n\nSuch declarations can also include default values of the class properties:\n\nYou can use a trailing comma when you declare class properties:\n\nMuch like regular properties, properties declared in the primary constructor can be mutable ( ) or read-only ( ).\n\nIf the constructor has annotations or visibility modifiers, the keyword is required and the modifiers go before it:\n\nA class can also declare secondary constructors, which are prefixed with : class Person(val pets: MutableList<Pet> = mutableListOf()) class Pet { constructor(owner: Person) { owner.pets.add(this) // adds this pet to the list of its owner's pets } } If the class has a primary constructor, each secondary constructor needs to delegate to the primary constructor, either directly or indirectly through another secondary constructor(s). Delegation to another constructor of the same class is done using the keyword: Code in initializer blocks effectively becomes part of the primary constructor. Delegation to the primary constructor happens at the moment of access to the first statement of a secondary constructor, so the code in all initializer blocks and property initializers is executed before the body of the secondary constructor. Even if the class has no primary constructor, the delegation still happens implicitly, and the initializer blocks are still executed: If a non-abstract class does not declare any constructors (primary or secondary), it will have a generated primary constructor with no arguments. The visibility of the constructor will be public. If you don't want your class to have a public constructor, declare an empty primary constructor with non-default visibility: On the JVM, if all of the primary constructor parameters have default values, the compiler will generate an additional parameterless constructor which will use the default values. This makes it easier to use Kotlin with libraries such as Jackson or JPA that create class instances through parameterless constructors."
    },
    {
        "link": "https://medium.com/@appdevinsights/companion-object-in-kotlin-c3a1203cd63c",
        "document": "In Kotlin, the is a special type of object that is associated with a class rather than an instance of the class. It's similar to static members in other programming languages, but with some added functionality.\n\nHere’s how you can declare a in Kotlin:\n\nIn the example above:\n• Inside , there's a declared using the keyword.\n• Members inside the can be accessed using the class name without creating an instance of the class.\n• Interfaces: The can extend interfaces. This is useful when you want to define methods that are related to the class but don't require an instance.\n• Single Instance: A is a single instance associated with the class, and its members are shared among all instances of the class.\n• Initialization: The is initialized when the class is loaded (similar to a static block in Java).\n\n5. Visibility: Members of the can be accessed from outside the class using the class name, similar to static members in other languages.\n\n6. Nameless by Default: The doesn't have a name, but it's implicitly named \"Companion\" by default. However, you can provide a custom name if needed.\n\nCommon use cases for in Kotlin:\n\nDifference between object and companion Object in kotlin\n\nIn Kotlin, both and are used to define objects, but they serve different purposes:\n• : Represents a singleton object that is not associated with any particular class instance. It is a standalone object.\n• : Represents an object associated with a specific class. It is tied to the class itself and can access its private members.\n• : Can be accessed directly by its name. It is not associated with a class and doesn't have access to class members.\n• : Can access private members of the class it belongs to. It is tightly linked to the class and is accessed through the class name.\n• : Can be given any name when defined. It doesn't have a default name and is accessed using that name.\n• : If not explicitly named, it is named by default. It is accessed using the class name.\n• : Cannot have a constructor with parameters. Initialization is done in the body of the object.\n• : Can have a constructor, allowing it to be initialized with parameters. It also supports an optional initializer block.\n• : Members are accessed directly through the object instance.\n• : Members are accessed through the class name. If explicitly named, the name is used for access.\n\nThese differences highlight the distinct roles and capabilities of and in Kotlin, with providing a way to create standalone singleton objects, and providing a mechanism to associate an object with a specific class.\n\nCompanion objects in Kotlin and static members in Java serve similar purposes, providing a way to associate methods and properties with a class rather than an instance. However, there are some differences between companion objects in Kotlin and static members in Java:\n• In Kotlin, a companion object is explicitly named using the keyword. This allows you to give it a meaningful name.\n• In Java, static members do not have a specific name like “companion,” and they are simply defined using the keyword.\n• In Kotlin, a companion object can have an initializer block, allowing you to perform additional setup when the companion object is created.\n• Java does not have explicit initializer blocks for static members.\n• In Kotlin, a companion object can implement interfaces, allowing it to define methods required by an interface.\n• In Kotlin, the companion object can have its own visibility modifier, allowing you to control its visibility separately from the enclosing class.\n• In Java, static members share the visibility of the enclosing class."
    },
    {
        "link": "https://stackoverflow.com/questions/38120494/how-to-access-kotlin-companion-object-in-java",
        "document": "I convert one of my Java class to Kotlin and the class as below.\n\nI still have a Java function accessing it.\n\nIt was good when MainApplication is in Java. But not when MainApplication in Kotlin, the above code error\n\nHow could I access in my Java code above?"
    },
    {
        "link": "https://kotlinlang.org/docs/coding-conventions.html",
        "document": "Commonly known and easy-to-follow coding conventions are vital for any programming language. Here we provide guidelines on the code style and code organization for projects that use Kotlin.\n\nIn pure Kotlin projects, the recommended directory structure follows the package structure with the common root package omitted. For example, if all the code in the project is in the package and its subpackages, files with the package should be placed directly under the source root, and files in should be in the subdirectory of the source root. On JVM: In projects where Kotlin is used together with Java, Kotlin source files should reside in the same source root as the Java source files, and follow the same directory structure: each file should be stored in the directory corresponding to each package statement. If a Kotlin file contains a single class or interface (potentially with related top-level declarations), its name should be the same as the name of the class, with the extension appended. It applies to all types of classes and interfaces. If a file contains multiple classes, or only top-level declarations, choose a name describing what the file contains, and name the file accordingly. Use upper camel case, where the first letter of each word is capitalized. For example, . The name of the file should describe what the code in the file does. Therefore, you should avoid using meaningless words such as in file names. In multiplatform projects, files with top-level declarations in platform-specific source sets should have a suffix associated with the name of the source set. For example: As for the common source set, files with top-level declarations should not have a suffix. For example, . We recommend following this file naming scheme in multiplatform projects due to JVM limitations: it doesn't allow top-level members (functions, properties). To work around this, the Kotlin JVM compiler creates wrapper classes (so-called \"file facades\") that contain top-level member declarations. File facades have an internal name derived from the file name. In turn, JVM doesn't allow several classes with the same fully qualified name (FQN). This might lead to situations when a Kotlin project cannot be compiled to JVM: Here both files are in the same package, so the Kotlin JVM compiler produces two file facades, both of which have FQN . This produces the \"Duplicate JVM classes\" error. The simplest way to avoid that is renaming one of the files according to the guideline above. This naming scheme helps avoid clashes while retaining code readability. There are two scenarios where these recommendations may seem redundant, but we still advise to follow them:\n• None Non-JVM platforms don't have issues with duplicating file facades. However, this naming scheme can help you keep file naming consistent.\n• None On JVM, if source files don't have top-level declarations, the file facades aren't generated, and you won't face naming clashes. However, this naming scheme can help you avoid situations when a simple refactoring or an addition could include a top-level function and result in the same \"Duplicate JVM classes\" error. Placing multiple declarations (classes, top-level functions or properties) in the same Kotlin source file is encouraged as long as these declarations are closely related to each other semantically, and the file size remains reasonable (not exceeding a few hundred lines). In particular, when defining extension functions for a class which are relevant for all clients of this class, put them in the same file with the class itself. When defining extension functions that make sense only for a specific client, put them next to the code of that client. Avoid creating files just to hold all extensions of some class. The contents of a class should go in the following order: Do not sort the method declarations alphabetically or by visibility, and do not separate regular methods from extension methods. Instead, put related stuff together, so that someone reading the class from top to bottom can follow the logic of what's happening. Choose an order (either higher-level stuff first, or vice versa) and stick to it. Put nested classes next to the code that uses those classes. If the classes are intended to be used externally and aren't referenced inside the class, put them in the end, after the companion object. When implementing an interface, keep the implementing members in the same order as members of the interface (if necessary, interspersed with additional private methods used for the implementation). Always put overloads next to each other in a class.\n\nPackage and class naming rules in Kotlin are quite simple:\n• None Names of packages are always lowercase and do not use underscores ( ). Using multi-word names is generally discouraged, but if you do need to use multiple words, you can either just concatenate them together or use camel case ( ).\n• None Names of classes and objects use upper camel case: Names of functions, properties and local variables start with a lowercase letter and use camel case with no underscores: Exception: factory functions used to create instances of classes can have the same name as the abstract return type: In tests (and only in tests), you can use method names with spaces enclosed in backticks. Note that such method names are only supported by Android runtime from API level 30. Underscores in method names are also allowed in test code. Names of constants (properties marked with , or top-level or object properties with no custom function that hold deeply immutable data) should use all uppercase, underscore-separated names following the (screaming snake case) convention: Names of top-level or object properties which hold objects with behavior or mutable data should use camel case names: Names of properties holding references to singleton objects can use the same naming style as declarations: For enum constants, it's OK to use either all uppercase, underscore-separated (screaming snake case) names ( ) or upper camel case names, depending on the usage. If a class has two properties which are conceptually the same but one is part of a public API and another is an implementation detail, use an underscore as the prefix for the name of the private property: The name of a class is usually a noun or a noun phrase explaining what the class is: , . The name of a method is usually a verb or a verb phrase saying what the method does: , . The name should also suggest if the method is mutating the object or returning a new one. For instance is sorting a collection in place, while is returning a sorted copy of the collection. The names should make it clear what the purpose of the entity is, so it's best to avoid using meaningless words ( , ) in names. When using an acronym as part of a declaration name, follow these rules:\n• None For two-letter acronyms, use uppercase for both letters. For example, .\n• None For acronyms longer than two letters, capitalize only the first letter. For example, or .\n\nUse four spaces for indentation. Do not use tabs. For curly braces, put the opening brace at the end of the line where the construct begins, and the closing brace on a separate line aligned horizontally with the opening construct. if (elements != null) { for (element in elements) { // ... } } In Kotlin, semicolons are optional, and therefore line breaks are significant. The language design assumes Java-style braces, and you may encounter surprising behavior if you try to use a different formatting style.\n• None Put spaces around binary operators ( ). Exception: don't put spaces around the \"range to\" operator ( ).\n• None Do not put spaces around unary operators ( ).\n• None Put spaces between control flow keywords ( , , , and ) and the corresponding opening parenthesis.\n• None Do not put a space before an opening parenthesis in a primary constructor declaration, method declaration or method call.\n• None Never put a space after , , or before , .\n• None Never put a space around or : , .\n• None Do not put spaces around angle brackets used to specify type parameters: .\n• None Do not put spaces around : , .\n• None Do not put a space before used to mark a nullable type: . As a general rule, avoid horizontal alignment of any kind. Renaming an identifier to a name with a different length should not affect the formatting of either the declaration or any of the usages. Put a space before in the following scenarios:\n• None When it's used to separate a type and a supertype.\n• None When delegating to a superclass constructor or a different constructor of the same class. Don't put a space before when it separates a declaration and its type. Classes with a few primary constructor parameters can be written in a single line: Classes with longer headers should be formatted so that each primary constructor parameter is in a separate line with indentation. Also, the closing parenthesis should be on a new line. If you use inheritance, the superclass constructor call, or the list of implemented interfaces should be located on the same line as the parenthesis: For multiple interfaces, the superclass constructor call should be located first and then each interface should be located in a different line: For classes with a long supertype list, put a line break after the colon and align all supertype names horizontally: To clearly separate the class header and body when the class header is long, either put a blank line following the class header (as in the example above), or put the opening curly brace on a separate line: Use regular indent (four spaces) for constructor parameters. This ensures that properties declared in the primary constructor have the same indentation as properties declared in the body of a class. If a declaration has multiple modifiers, always put them in the following order: public / protected / private / internal expect / actual final / open / abstract / sealed / const external override lateinit tailrec vararg suspend inner enum / annotation / fun // as a modifier in `fun interface` companion inline / value infix operator data Unless you're working on a library, omit redundant modifiers (for example, ). Place annotations on separate lines before the declaration to which they are attached, and with the same indentation: Annotations without arguments may be placed on the same line: A single annotation without arguments may be placed on the same line as the corresponding declaration: File annotations are placed after the file comment (if any), before the statement, and are separated from with a blank line (to emphasize the fact that they target the file and not the package). If the function signature doesn't fit on a single line, use the following syntax: Use regular indent (four spaces) for function parameters. It helps ensure consistency with constructor parameters. Prefer using an expression body for functions with the body consisting of a single expression. If the function has an expression body whose first line doesn't fit on the same line as the declaration, put the sign on the first line and indent the expression body by four spaces. For very simple read-only properties, consider one-line formatting: For more complex properties, always put and keywords on separate lines: For properties with an initializer, if the initializer is long, add a line break after the sign and indent the initializer by four spaces: If the condition of an or statement is multiline, always use curly braces around the body of the statement. Indent each subsequent line of the condition by four spaces relative to the statement start. Put the closing parentheses of the condition together with the opening curly brace on a separate line: This helps align the condition and statement bodies. Put the , , keywords, as well as the keyword of a loop, on the same line as the preceding curly brace: if (condition) { // body } else { // else part } try { // body } finally { // cleanup } In a statement, if a branch is more than a single line, consider separating it from adjacent case blocks with a blank line: Put short branches on the same line as the condition, without braces. In long argument lists, put a line break after the opening parenthesis. Indent arguments by four spaces. Group multiple closely related arguments on the same line. Put spaces around the sign separating the argument name and value. When wrapping chained calls, put the character or the operator on the next line, with a single indent: val anchor = owner ?.firstChild!! .siblings(forward = true) .dropWhile { it is PsiComment || it is PsiWhiteSpace } The first call in the chain should usually have a line break before it, but it's OK to omit it if the code makes more sense that way. In lambda expressions, spaces should be used around the curly braces, as well as around the arrow which separates the parameters from the body. If a call takes a single lambda, pass it outside parentheses whenever possible. If assigning a label for a lambda, do not put a space between the label and the opening curly brace: When declaring parameter names in a multiline lambda, put the names on the first line, followed by the arrow and the newline: If the parameter list is too long to fit on a line, put the arrow on a separate line: A trailing comma is a comma symbol after the last item in a series of elements: Using trailing commas has several benefits:\n• None It makes version-control diffs cleaner – as all the focus is on the changed value.\n• None It makes it easy to add and reorder elements – there is no need to add or delete the comma if you manipulate elements.\n• None It simplifies code generation, for example, for object initializers. The last element can also have a comma. Trailing commas are entirely optional – your code will still work without them. The Kotlin style guide encourages the use of trailing commas at the declaration site and leaves it at your discretion for the call site. To enable trailing commas in the IntelliJ IDEA formatter, go to Settings/Preferences | Editor | Code Style | Kotlin, open the Other tab and select the Use trailing comma option.\n\nFor longer documentation comments, place the opening on a separate line and begin each subsequent line with an asterisk: /** * This is a documentation comment * on multiple lines. */ Short comments can be placed on a single line: Generally, avoid using and tags. Instead, incorporate the description of parameters and return values directly into the documentation comment, and add links to parameters wherever they are mentioned. Use and only when a lengthy description is required which doesn't fit into the flow of the main text. // Avoid doing this: /** * Returns the absolute value of the given number. * @param number The number to return the absolute value for. * @return The absolute value. */ fun abs(number: Int): Int { /*...*/ } // Do this instead: /** * Returns the absolute value of the given [number]. */ fun abs(number: Int): Int { /*...*/ }\n\nPrefer using immutable data to mutable. Always declare local variables and properties as rather than if they are not modified after initialization. Always use immutable collection interfaces ( , , , ) to declare collections which are not mutated. When using factory functions to create collection instances, always use functions that return immutable collection types when possible: // Bad: use of a mutable collection type for value which will not be mutated fun validateValue(actualValue: String, allowedValues: HashSet<String>) { ... } // Good: immutable collection type used instead fun validateValue(actualValue: String, allowedValues: Set<String>) { ... } // Bad: arrayListOf() returns ArrayList<T>, which is a mutable collection type val allowedValues = arrayListOf(\"a\", \"b\", \"c\") // Good: listOf() returns List<T> val allowedValues = listOf(\"a\", \"b\", \"c\") If you have a functional type or a type with type parameters which is used multiple times in a codebase, prefer defining a type alias for it: If you use a private or internal type alias for avoiding name collision, prefer the mentioned in Packages and Imports. In lambdas which are short and not nested, it's recommended to use the convention instead of declaring the parameter explicitly. In nested lambdas with parameters, always declare parameters explicitly. Avoid using multiple labeled returns in a lambda. Consider restructuring the lambda so that it will have a single exit point. If that's not possible or not clear enough, consider converting the lambda into an anonymous function. Do not use a labeled return for the last statement in a lambda. Use the named argument syntax when a method takes multiple parameters of the same primitive type, or for parameters of type, unless the meaning of all parameters is absolutely clear from context. Prefer using the expression form of , , and . The above is preferable to: Prefer using for binary conditions instead of . For example, use this syntax with : Instead of this one with : Prefer using if there are three or more options. Use parentheses when combining multiple boolean expressions in expressions or statements with guard conditions: when (status) { is Status.Ok if (status.info.isEmpty() || status.info.id == null) -> \"no information\" } when (status) { is Status.Ok if status.info.isEmpty() || status.info.id == null -> \"no information\" } If you need to use a nullable in a conditional statement, use or checks. Prefer using higher-order functions ( , etc.) to loops. Exception: (prefer using a regular loop instead, unless the receiver of is nullable or is used as part of a longer call chain). When making a choice between a complex expression using multiple higher-order functions and a loop, understand the cost of the operations being performed in each case and keep performance considerations in mind. Use the operator to loop over an open-ended range: for (i in 0..n - 1) { /*...*/ } // bad for (i in 0..<n) { /*...*/ } // good To maintain indentation in multiline strings, use when the resulting string does not require any internal indentation, or when internal indentation is required: Learn the difference between Java and Kotlin multiline strings. In some scenarios, functions with no arguments might be interchangeable with read-only properties. Although the semantics are similar, there are some stylistic conventions on when to prefer one to another. Prefer a property over a function when the underlying algorithm:\n• None Is cheap to calculate (or cached on the first run).\n• None Returns the same result over invocations if the object state hasn't changed. Use extension functions liberally. Every time you have a function that works primarily on an object, consider making it an extension function accepting that object as a receiver. To minimize API pollution, restrict the visibility of extension functions as much as it makes sense. As necessary, use local extension functions, member extension functions, or top-level extension functions with private visibility. Declare a function as only when it works on two objects which play a similar role. Good examples: , , . Bad example: . Do not declare a method as if it mutates the receiver object. If you declare a factory function for a class, avoid giving it the same name as the class itself. Prefer using a distinct name, making it clear why the behavior of the factory function is special. Only if there is really no special semantics, you can use the same name as the class. If you have an object with multiple overloaded constructors that don't call different superclass constructors and can't be reduced to a single constructor with default argument values, prefer to replace the overloaded constructors with factory functions. A public function/method returning an expression of a platform type must declare its Kotlin type explicitly: Any property (package-level or class-level) initialized with an expression of a platform type must declare its Kotlin type explicitly: A local value initialized with an expression of a platform type may or may not have a type declaration: Kotlin provides a set of functions to execute a block of code in the context of a given object: , , , , and . For the guidance on choosing the right scope function for your case, refer to Scope Functions."
    },
    {
        "link": "https://reddit.com/r/Kotlin/comments/gkbswd/what_is_the_point_of_companion_objects",
        "document": "Just wander what was the reason for adding such feature to the language. Why were they needed, what problem do they solve?"
    },
    {
        "link": "https://developer.android.com/guide/fragments/create",
        "document": "A fragment represents a modular portion of the user interface within an activity. A fragment has its own lifecycle, receives its own input events, and you can add or remove fragments while the containing activity is running.\n\nThis document describes how to create a fragment and include it in an activity.\n\nFragments require a dependency on the AndroidX Fragment library. You need to add the Google Maven repository to your project's file in order to include this dependency.\n\nTo include the AndroidX Fragment library to your project, add the following dependencies in your app's file:\n\nTo create a fragment, extend the AndroidX class, and override its methods to insert your app logic, similar to the way you would create an class. To create a minimal fragment that defines its own layout, provide your fragment's layout resource to the base constructor, as shown in the following example:\n\nThe Fragment library also provides more specialized fragment base classes:\n\nGenerally, your fragment must be embedded within an AndroidX to contribute a portion of UI to that activity's layout. is the base class for , so if you're already subclassing to provide backward compatibility in your app, then you do not need to change your activity base class.\n\nYou can add your fragment to the activity's view hierarchy either by defining the fragment in your activity's layout file or by defining a fragment container in your activity's layout file and then programmatically adding the fragment from within your activity. In either case, you need to add a that defines the location where the fragment should be placed within the activity's view hierarchy. It is strongly recommended to always use a as the container for fragments, as includes fixes specific to fragments that other view groups such as do not provide.\n\nTo declaratively add a fragment to your activity layout's XML, use a element.\n\nHere's an example activity layout containing a single :\n\nThe attribute specifies the class name of the to instantiate. When the activity's layout is inflated, the specified fragment is instantiated, is called on the newly instantiated fragment, and a is created to add the fragment to the .\n\nTo programmatically add a fragment to your activity's layout, the layout should include a to serve as a fragment container, as shown in the following example:\n\nUnlike the XML approach, the attribute isn't used on the here, so no specific fragment is automatically instantiated. Instead, a is used to instantiate a fragment and add it to the activity's layout.\n\nWhile your activity is running, you can make fragment transactions such as adding, removing, or replacing a fragment. In your , you can get an instance of the , which can be used to create a . Then, you can instantiate your fragment within your activity's method using , passing in the ID of the container in your layout and the fragment class you want to add and then commit the transaction, as shown in the following example:\n\nIn the previous example, note that the fragment transaction is only created when is . This is to ensure that the fragment is added only once, when the activity is first created. When a configuration change occurs and the activity is recreated, is no longer , and the fragment does not need to be added a second time, as the fragment is automatically restored from the .\n\nIf your fragment requires some initial data, arguments can be passed to your fragment by providing a in the call to , as shown below:\n\nThe arguments can then be retrieved from within your fragment by calling , and the appropriate getter methods can be used to retrieve each argument.\n\nFragment transactions and the are covered in more detail in the Fragment manager guide."
    },
    {
        "link": "https://developer.android.com/guide/fragments/fragmentmanager",
        "document": "is the class responsible for performing actions on your app's fragments, such as adding, removing, or replacing them and adding them to the back stack.\n\nYou might never interact with directly if you're using the Jetpack Navigation library, as it works with the on your behalf. However, any app using fragments is using at some level, so it's important to understand what it is and how it works.\n• How to access the .\n• The role of in relation to your activities and fragments.\n• How to manage the back stack with .\n• How to provide data and dependencies to your fragments.\n\nYou can access the from an activity or from a fragment.\n\nand its subclasses, such as , have access to the through the method.\n\nFragments can host one or more child fragments. Inside a fragment, you can get a reference to the that manages the fragment's children through . If you need to access its host , you can use .\n\nHere are a couple of examples to see the relationships between fragments, their hosts, and the instances associated with each.\n\nFigure 1 shows two examples, each of which has a single activity host. The host activity in both of these examples displays top-level navigation to the user as a that is responsible for swapping out the host fragment with different screens in the app. Each screen is implemented as a separate fragment.\n\nThe host fragment in Example 1 hosts two child fragments that make up a split-view screen. The host fragment in Example 2 hosts a single child fragment that makes up the display fragment of a swipe view.\n\nGiven this setup, you can think about each host as having a associated with it that manages its child fragments. This is illustrated in figure 2 along with property mappings between , , and .\n\nThe appropriate property to reference depends on where the callsite is in the fragment hierarchy along with which fragment manager you are trying to access.\n\nOnce you have a reference to the , you can use it to manipulate the fragments being displayed to the user.\n\nGenerally speaking, your app consists of a single or small number of activities in your application project, with each activity representing a group of related screens. The activity might provide a point to place top-level navigation and a place to scope objects and other view-state between fragments. A fragment represents an individual destination in your app.\n\nIf you want to show multiple fragments at once, such as in a split-view or a dashboard, you can use child fragments that are managed by your destination fragment and its child fragment manager.\n\nOther use cases for child fragments are the following:\n• Screen slides, using a in a parent fragment to manage a series of child fragment views.\n• Jetpack Navigation uses child fragments as individual destinations. An activity hosts a single parent and fills its space with different child destination fragments as users navigate through your app.\n\nThe manages the fragment back stack. At runtime, the can perform back stack operations like adding or removing fragments in response to user interactions. Each set of changes is committed together as a single unit called a . For a more in-depth discussion about fragment transactions, see the fragment transactions guide.\n\nWhen the user taps the Back button on their device, or when you call , the top-most fragment transaction pops off of the stack. If there are no more fragment transactions on the stack, and if you aren't using child fragments, the Back event bubbles up to the activity. If you are using child fragments, see special considerations for child and sibling fragments.\n\nWhen you call on a transaction, the transaction can include any number of operations, such as adding multiple fragments or replacing fragments in multiple containers.\n\nWhen the back stack is popped, all these operations reverse as a single atomic action. However, if you committed additional transactions prior to the call, and if you didn't use for the transaction, these operations don't reverse. Therefore, within a single , avoid interleaving transactions that affect the back stack with those that don't.\n\nTo display a fragment within a layout container, use the to create a . Within the transaction, you can then perform an or operation on the container.\n\nFor example, a simple might look like this:\n\nIn this example, replaces the fragment, if any, that is currently in the layout container identified by the ID. Providing the fragment's class to the method lets the handle instantiation using its . For more information, see the Provide dependencies to your fragments section.\n\noptimizes the state changes of the fragments involved in the transaction so that animations and transitions work correctly. For more information on navigating with animations and transitions, see Fragment transactions and Navigate between fragments using animations.\n\nCalling commits the transaction to the back stack. The user can later reverse the transaction and bring back the previous fragment by tapping the Back button. If you added or removed multiple fragments within a single transaction, all those operations are undone when the back stack is popped. The optional name provided in the call gives you the ability to pop back to a specific transaction using .\n\nIf you don't call when you perform a transaction that removes a fragment, then the removed fragment is destroyed when the transaction is committed, and the user cannot navigate back to it. If you do call when removing a fragment, then the fragment is only and is later when the user navigates back. Its view is destroyed in this case. For more information, see Fragment lifecycle.\n\nYou can get a reference to the current fragment within a layout container by using . Use to look up a fragment either by the given ID when inflated from XML or by the container ID when added in a . Here's an example:\n\nAlternatively, you can assign a unique tag to a fragment and get a reference using . You can assign a tag using the XML attribute on fragments that are defined within your layout or during an or operation within a .\n\nOnly one can control the fragment back stack at any given time. If your app shows multiple sibling fragments on the screen at the same time, or if your app uses child fragments, then one is designated to handle your app's primary navigation.\n\nTo define the primary navigation fragment inside of a fragment transaction, call the method on the transaction, passing in the instance of the fragment whose has primary control.\n\nConsider the navigation structure as a series of layers, with the activity as the outermost layer, wrapping each layer of child fragments underneath. Each layer has a single primary navigation fragment.\n\nWhen the Back event occurs, the innermost layer controls navigation behavior. Once the innermost layer has no more fragment transactions from which to pop back, control returns to the next layer out, and this process repeats until you reach the activity.\n\nWhen two or more fragments are displayed at the same time, only one of them is the primary navigation fragment. Setting a fragment as the primary navigation fragment removes the designation from the previous fragment. Using the preceding example, if you set the detail fragment as the primary navigation fragment, the main fragment's designation is removed.\n\nIn some cases, your app might need to support multiple back stacks. A common example is if your app uses a bottom navigation bar. lets you support multiple back stacks with the and methods. These methods let you swap between back stacks by saving one back stack and restoring a different one.\n\nworks similarly to calling with the optional parameter: the specified transaction and all transactions after it on the stack are popped. The difference is that saves the state of all fragments in the popped transactions.\n\nFor example, suppose you previously added a fragment to the back stack by committing a using , as shown in the following example:\n\nIn that case, you can save this fragment transaction and the state of by calling :\n\nYou can call with the same name parameter to restore all of the popped transactions and all of the saved fragment states:\n\nWhen adding a fragment, you can instantiate the fragment manually and add it to the .\n\nWhen you commit the fragment transaction, the instance of the fragment you created is the instance used. However, during a configuration change, your activity and all of its fragments are destroyed and then recreated with the most applicable Android resources. The handles all of this for you: it recreates instances of your fragments, attaches them to the host, and recreates the back stack state.\n\nBy default, the uses a that the framework provides to instantiate a new instance of your fragment. This default factory uses reflection to find and invoke a no-argument constructor for your fragment. This means that you can't use this default factory to provide dependencies to your fragment. It also means that any custom constructor you used to create your fragment the first time is not used during recreation by default.\n\nTo provide dependencies to your fragment, or to use any custom constructor, instead create a custom subclass and then override . You can then override the default factory of the with your custom factory, which is then used to instantiate your fragments.\n\nSuppose you have a that is responsible for displaying popular desserts in your hometown, and that has a dependency on a class that provides it with the information it needs to display the correct UI to your user.\n\nYou might define your to require a instance in its constructor.\n\nA simple implementation of your might look similar to the following.\n\nThis example subclasses , overriding the method to provide custom fragment creation logic for a . Other fragment classes are handled by the default behavior of through .\n\nYou can then designate as the factory to use when constructing your app's fragments by setting a property on the . You must set this property prior to your activity's to ensure that is used when recreating your fragments.\n\nSetting the in the activity overrides fragment creation throughout the activity's fragment hierarchy. In other words, the of any child fragments you add uses the custom fragment factory set here unless overridden at a lower level.\n\nIn a single activity architecture, test your fragments in isolation using the class. Since you can't rely on the custom logic of your activity, you can instead pass the in as an argument to your fragments test, as shown in the following example:\n\nFor detailed information about this testing process and for full examples, see Test your fragments."
    },
    {
        "link": "https://medium.com/@Max_Sir/mastering-android-fragments-managers-transactions-and-best-practices-in-kotlin-af00cb9b44ac",
        "document": "Fragments are a fundamental part of Android development, allowing developers to create dynamic and flexible user interfaces that work across a variety of devices and screen sizes. This article delves into the intricacies of Fragments, FragmentManagers, FragmentTransactions, and best practices for using them with architecture components. We will also explore common pitfalls such as and how to avoid them.\n\nA Fragment is a reusable portion of your app’s UI that encapsulates its own layout and behavior. Fragments can be combined within a single activity to create a multi-pane UI or reused across multiple activities. They are essential for building responsive and modular applications.\n• Lifecycle: Fragments have their own lifecycle, which is tied to their host activity’s lifecycle but with additional states such as , , and .\n• Modularity: Fragments allow you to encapsulate UI and behavior, making your app more modular and reusable.\n• Dynamic UI: You can dynamically add, remove, replace, or hide fragments at runtime.\n\nis responsible for managing fragments in an activity. It provides methods to perform fragment transactions and manage the back stack.\n• Parent FragmentManager: Manages the fragments at the activity level.\n\nrepresents an atomic set of operations to perform on fragments. You can use it to add, remove, replace, and perform other operations on fragments.\n\nis part of Android's architecture components and is designed to store and manage UI-related data in a lifecycle-conscious way. It allows data to survive configuration changes such as screen rotations.\n\nis a lifecycle-aware data holder class that can be observed within the scope of a . This ensures UI components only update when they are active.\n\nExample: Using ViewModel with Fragments\n\nWhat is it?\n\nWhen committing a , using ensures that the transaction is committed immediately. However, if you call after the activity's state has been saved (e.g., during ), it may result in an . To avoid this, you can use , which allows the transaction to commit even if the state loss occurs.\n\nWhile can prevent crashes, it should be used with caution. It may lead to lost UI states and unpredictable behavior, especially if used excessively.\n\noften occurs when attempting to commit a after the activity's state has been saved. This is typically seen in lifecycle methods such as , , or .\n• Check Lifecycle State: Ensure that transactions are committed during appropriate lifecycle states.\n• Avoid Committing After State Loss: Use sparingly and only when necessary.\n• UI-related Logic in UI Thread: Perform fragment transactions on the main thread to avoid concurrency issues.\n• Add: Adds a fragment on top of the existing fragment. Useful for maintaining multiple fragments on the screen.\n• Replace: Replaces the existing fragment with a new fragment. Cleans up the previous fragment.\n• Hide: Hides an existing fragment without removing it. Useful for temporary UI changes.\n• Detach: Detaches a fragment, keeping its state in memory but removing its UI.\n\nMastering fragments, fragment managers, and fragment transactions is essential for creating flexible and responsive Android applications. By leveraging architecture components like and , and following best practices, you can avoid common pitfalls and ensure a robust and maintainable codebase. Remember to handle fragment transactions thoughtfully, particularly regarding lifecycle states and potential state loss, to provide a seamless user experience."
    },
    {
        "link": "https://androidguide.hashnode.dev/understanding-fragments-and-fragment-management-in-android-a-comprehensive-guide-for-developers",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/67650932/how-to-create-and-display-fragments-from-inside-an-android-library",
        "document": "I'm relatively new to Android / Kotlin.\n\nI wonder how Android libraries like AdMob manage to create and show a View (especially an Intersitial Ad) from inside a library without any layout preparation of the integrating app. I assume this View is some sort of Fragment.\n\nSample code to show an intersitial ad from AdMob:\n\nI think it somehow has to do with the Activity passed as a parameter in the show method.\n\nThis Guide states, that to add a fragment programmatically, \"the layout should include a FragmentContainerView\". Additionally in the sample code from the same guide the id of said FragmentContainerView is used to add the fragment. This id is not known inside the library.\n\nHow does such a library achieve this?"
    }
]