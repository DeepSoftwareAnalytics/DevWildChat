[
    {
        "link": "https://blog.bitsrc.io/async-await-in-javascript-simplifying-asynchronous-code-39075ea4cd03",
        "document": "Async/await is a feature of JavaScript that simplifies asynchronous programming. We will define , describe how it functions, and give some practical examples in this blog article.\n\nAsynchronous programming is a programming pattern where tasks are completed simultaneously and the results are returned as soon as they are ready. Traditional synchronous programming executes tasks sequentially, which might cause the user to wait a very long time.\n\nJavascript offers asynchronous programming in primarily three different ways: callbacks, promises, and .\n\nCallbacks are functions that are executed after a task is completed and are passed as arguments in other functions. Promises are objects that stand in for values that might not be available right away but will be fulfilled eventually. Async/await is a modern method for managing asynchronous programming that makes the code syntax simpler and more readable.\n\nI recommend to read JavaScript Promise before delving into Async/await for a better understanding of the underlying concepts.\n\nProgrammers can write asynchronous code more synchronously using JavaScript’s syntax feature. It is based on and offers a cleaner, more legible approach to construct asynchronous programmes.\n\nWhen a function is marked with the “ ” prefix, it means that it will always return a . The “ ” keyword is used to halt the execution of the programme inside an async function until the Promise is fulfilled.\n\nHow to use Async/Await?\n\nlet’s look at an example to understand working of . Consider the case where a function returns a Promise that resolves after some time:\n\nWe can use this function to create a delay in our code. For instance, We can delay the execution of the function by one second by using the code below:\n\nIn this code, we have marked the “delayedFunction” as asynchronous using the “ ” keyword. We have also used the “ ” keyword to pause the execution of the code until the returned by “wait” function is resolved. Once the Promise is resolved, the console will log the message “Delayed function executed”.\n\nError handling is simplified when async/await is used, which is one of its advantages. We can use the “try/catch” to handle the error in a more synchronous way. For instance, that we have a function that returns a Promise which expires after some time:\n\nWe can use this function to simulate an error in our code. For example, we can handle the error in the following way:\n\nIn this code, we have used the “ ” statement to handle the error thrown by the Promise returned by “waitAndReject”. If the is rejected, the error message “Error” will be logged to the console.\n\nLet’s take a look at how to use async/await with the Fetch API to retrieve data from a third-party API:\n\nIn this code, we have used with the Fetch API to make an HTTP request to the Chuck Norris Jokes API and retrieve a random joke for a given category. We have also used to handle any errors that may occur during the request.\n\nThe Chuck Norris Jokes API is a public API that provides random jokes about Chuck Norris in different categories such as “dev”, “science”, “movie”, etc. This example demonstrates how to use async/await to retrieve data from a third-party API and use it in your application.\n\nUsing has several benefits over traditional asynchronous programming methods. First, it simplifies the syntax and makes the code more readable by avoiding callback nesting and chaining. Second, it allows for better error handling by using try/catch blocks to handle exceptions. Finally, it improves the performance of web applications by allowing tasks to execute concurrently and reducing the wait time for the user.\n\nBest Practices for Using Async/Await\n\nWhile async/await provides a simpler and more concise way to write asynchronous code, there are still some best practices to keep in mind. Here are a few tips to help you write efficient and maintainable async/await code:\n• Always use blocks to handle exceptions and errors.\n• Use method to execute multiple asynchronous tasks and return the result of the first task that resolves or rejects.\n• Avoid using inside loops, as it can block the execution of other tasks.\n• Use third-party libraries such as or to handle complex asynchronous tasks."
    },
    {
        "link": "https://codinn.dev/javascript/async-await",
        "document": "JavaScript's asynchronous model is based on the event loop, which allows for non-blocking I/O and improves performance.\n\nWhile callbacks and promises have been the primary ways to handle asynchronous programming in JavaScript, async/await has become a popular alternative in recent years.\n\nIn this article, we'll explore what async/await is and how it works. We'll also look at some real-world examples and best practices for using async/await in your JavaScript projects.\n• Best Practices for Using Async/Await\n\nasync/await is a syntactic sugar built on top of JavaScript's existing asynchronous programming model. It was introduced in ES2017 to simplify asynchronous programming and make it more readable and intuitive.\n\nasync/await allows you to write asynchronous code that looks and behaves like synchronous code. It uses keywords async and await to achieve this.\n\nasync is used to define a function that returns a promise, and await is used to wait for the promise to resolve or reject.\n\nasync/await is built on top of two key concepts: async functions and await operator.\n\nasync functions are functions that return a promise. They are defined using the async keyword before the function declaration.\n\nHere's an example of an async function:\n\nIn the above example, the getData() function returns a promise that resolves to the data returned from the API.\n\nThe await keyword is used to wait for the fetch() and response.json() methods to complete before proceeding.\n\nThe await operator is used to wait for a promise to resolve or reject. It can only be used inside an async function.\n\nHere's an example of using await:\n\nIn the above example, the await keyword is used to wait for the getData() function to return the data before assigning it to the data variable.\n\nasync/await also allows for better error handling than traditional callbacks or promises. You can use the try/catch statement to catch errors that occur in async functions.\n\nIf an error occurs in the fetch() or response.json() methods, the catch block will catch the error and log it to the console.\n\nasync/await has several benefits over traditional callback or promise-based asynchronous programming:\n• Simplicity: async/await makes asynchronous programming simpler and more intuitive by allowing you to write asynchronous code that looks and behaves like synchronous code.\n• Error Handling: async/await allows for better error handling with the try/catch statement.\n• Readability: async/await makes code more readable by avoiding deep nesting of callbacks and promises.\n• Debugging: async/await makes debugging easier by allowing you to use traditional debugging techniques, like setting breakpoints and stepping through code.\n\nBest Practices for Using Async/Await\n\nWhile async/await can simplify asynchronous programming, it's important to follow best practices to avoid potential issues. Here are some best practices for using async/await:\n• Avoid Using Async/Await in Loops async/await should not be used in loops, as it can cause performance issues and make the code difficult to debug. Instead, you can use the Promise.all() method to run multiple asynchronous functions concurrently.\n• Use Promise.all() to Run Multiple Async Functions Concurrently Promise.all() allows you to run multiple asynchronous functions concurrently and wait for all of them to complete before proceeding. This can improve performance and reduce the amount of time it takes for your code to execute.\n\nIn the above example, we use Promise.all() to run three asynchronous functions concurrently and wait for all of them to complete before returning the data.\n• Use try/catch for Error Handling async/await allows for better error handling with the try/catch statement. When using async/await, it's best practice to wrap your code in a try/catch block to handle errors that occur during execution.\n• Keep Functions Small and Focused It's a good practice to keep your async functions small and focused. Large async functions can be difficult to understand and debug, and can also negatively impact performance.\n• Real-World Examples Let's take a look at some real-world examples of using async/await.\n\nIn the above example, we use async/await to fetch data from an API and handle errors that occur during the process.\n\nIn this example, we use to upload a file to a server using the API and handle errors that occur during the process.\n\nis a powerful feature in JavaScript that simplifies asynchronous programming and improves code readability. By using with promises and the statement, you can write more efficient and error-resistant code.\n\n1. What is the difference between and promises?\n\nis a syntax feature that simplifies working with promises by allowing you to write asynchronous code that looks and behaves like synchronous code. Promises are a pattern for handling asynchronous code and are used in conjunction with to provide a more readable and manageable codebase.\n\n2. Can be used with callbacks?\n\nNo, cannot be used with callbacks. It is designed to work with promises, which provide a simpler and more intuitive way to work with asynchronous code.\n\n3. What is the difference between and generators?\n\nand generators are both used to handle asynchronous code, but they are fundamentally different. is designed to work with promises and provides a simpler syntax for working with them. Generators, on the other hand, are used to create iterators and are more flexible in their usage.\n\n4. Can be used in all browsers?\n\nis supported in all modern browsers, but may not be supported in older browsers. To ensure that your code works across all browsers, it's a good practice to use a transpiler like Babel to convert your code into ES5-compatible code.\n\n5. Is it possible to use without promises?\n\nNo, is designed to work with promises and cannot be used without them. Promises provide a way to handle asynchronous code and are a fundamental part of working with ."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function",
        "document": "An declaration creates an object. Each time when an async function is called, it returns a new which will be resolved with the value returned by the async function, or rejected with an exception uncaught within the async function.\n\nAsync functions can contain zero or more expressions. Await expressions make promise-returning functions behave as though they're synchronous by suspending execution until the returned promise is fulfilled or rejected. The resolved value of the promise is treated as the return value of the await expression. Use of and enables the use of ordinary / blocks around asynchronous code.\n\nNote: The keyword is only valid inside async functions within regular JavaScript code. If you use it outside of an async function's body, you will get a . can be used on its own with JavaScript modules.\n\nAsync functions always return a promise. If the return value of an async function is not explicitly a promise, it will be implicitly wrapped in a promise.\n\nFor example, consider the following code:\n\nIt is similar to:\n\nNote that even though the return value of an async function behaves as if it's wrapped in a , they are not equivalent. An async function will return a different reference, whereas returns the same reference if the given value is a promise. It can be a problem when you want to check the equality of a promise and a return value of an async function.\n\nThe body of an async function can be thought of as being split by zero or more await expressions. Top-level code, up to and including the first await expression (if there is one), is run synchronously. In this way, an async function without an await expression will run synchronously. If there is an await expression inside the function body, however, the async function will always complete asynchronously.\n\nIt is also equivalent to:\n\nCode after each await expression can be thought of as existing in a callback. In this way a promise chain is progressively constructed with each reentrant step through the function. The return value forms the final link in the chain.\n\nIn the following example, we successively await two promises. Progress moves through function in three stages.\n• The first line of the body of function is executed synchronously, with the await expression configured with the pending promise. Progress through is then suspended and control is yielded back to the function that called .\n• Some time later, when the first promise has either been fulfilled or rejected, control moves back into . The result of the first promise fulfillment (if it was not rejected) is returned from the await expression. Here is assigned to . Progress continues, and the second await expression is evaluated. Again, progress through is suspended and control is yielded.\n• Some time later, when the second promise has either been fulfilled or rejected, control re-enters . The result of the second promise resolution is returned from the second await expression. Here is assigned to . Control moves to the return expression (if any). The default return value of is returned as the resolution value of the current promise.\n\nNote how the promise chain is not built-up in one go. Instead, the promise chain is constructed in stages as control is successively yielded from and returned to the async function. As a result, we must be mindful of error handling behavior when dealing with concurrent asynchronous operations.\n\nFor example, in the following code an unhandled promise rejection error will be thrown, even if a handler has been configured further along the promise chain. This is because will not be \"wired into\" the promise chain until control returns from .\n\ndeclarations behave similar to declarations — they are hoisted to the top of their scope and can be called anywhere in their scope, and they can be redeclared only in certain contexts."
    },
    {
        "link": "https://geeksforgeeks.org/async-await-function-in-javascript",
        "document": "Async and Await in JavaScript is used to simplify handling asynchronous operations using promises. By enabling asynchronous code to appear synchronous, they enhance code readability and make it easier to manage complex asynchronous flows.\n\nThe function allows us to write promise-based code as if it were synchronous. This ensures that the execution thread is not blocked. Async functions always return a promise. If a value is returned that is not a promise, JavaScript automatically wraps it in a resolved promise.\n\nThe keyword is used to wait for a promise to resolve. It can only be used within an async block. Await makes the code wait until the promise returns a result, allowing for cleaner and more manageable asynchronous code.\n• async keyword transforms a regular JavaScript function into an asynchronous function, causing it to return a Promise.\n• await keyword is used inside an async function to pause its execution and wait for a Promise to resolve before continuing.\n\nJavaScript provides predefined arguments for handling promises: resolve and reject.\n• resolve: Used when an asynchronous task is completed successfully.\n• reject: Used when an asynchronous task fails, providing the reason for failure.\n• Improved Readability: Async and Await allow asynchronous code to be written in a synchronous style, making it easier to read and understand.\n• Avoids Callback Hell: Async and Await prevent nested callbacks and complex promise chains, making the code more linear and readable.\n• Better Debugging: Debugging async/await code is more intuitive since it behaves similarly to synchronous code.\n\nWhat does async do?\n\nWhat does await do?\n\nCan you use await outside async functions?\n\nWhat happens if an async function throws an error?\n\nHow is Async/Await different from Promises?"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Async_JS/Introducing",
        "document": "In this article, we'll explain what asynchronous programming is, why we need it, and briefly discuss some of the ways asynchronous functions have historically been implemented in JavaScript.\n• To gain familiarity with what asynchronous JavaScript is, how it differs from synchronous JavaScript, and why we need it.\n• What synchronous programming is, and why it can sometimes be problematic.\n• How asynchronous programming aims to solve these problems.\n• Event handlers and callback functions, and how they relate to asynchronous programming. Asynchronous programming is a technique that enables your program to start a potentially long-running task and still be able to be responsive to other events while that task runs, rather than having to wait until that task has finished. Once that task has finished, your program is presented with the result. Many functions provided by browsers, especially the most interesting ones, can potentially take a long time, and therefore, are asynchronous. For example:\n• Asking a user to select files using So even though you may not have to implement your own asynchronous functions very often, you are very likely to need to use them correctly. In this article, we'll start by looking at the problem with long-running synchronous functions, which make asynchronous programming a necessity.\n\nConsider the following code: const name = \"Miriam\"; const greeting = `Hello, my name is ${name}!`; console.log(greeting); // \"Hello, my name is Miriam!\"\n• Declares another string called , which uses .\n• Outputs the greeting to the JavaScript console. We should note here that the browser effectively steps through the program one line at a time, in the order we wrote it. At each point, the browser waits for the line to finish its work before going on to the next line. It has to do this because each line depends on the work done in the preceding lines. That makes this a synchronous program. It would still be synchronous even if we called a separate function, like this: function makeGreeting(name) { return `Hello, my name is ${name}!`; } const name = \"Miriam\"; const greeting = makeGreeting(name); console.log(greeting); // \"Hello, my name is Miriam!\" Here, is a synchronous function because the caller has to wait for the function to finish its work and return a value before the caller can continue.\n\nThe next example is just like the last one, except we added a text box for you to type in. This time, click \"Generate primes\", and try typing in the text box immediately after. You'll find that while our function is running, our program is completely unresponsive: you can't type anything, click anything, or do anything else. <label for=\"quota\">Number of primes:</label> <input type=\"text\" id=\"quota\" name=\"quota\" value=\"1000000\" /> <button id=\"generate\">Generate primes</button> <button id=\"reload\">Reload</button> <textarea id=\"user-input\" rows=\"5\" cols=\"62\"> Try typing in here immediately after pressing \"Generate primes\" </textarea> <div id=\"output\"></div> const MAX_PRIME = 1000000; function isPrime(n) { for (let i = 2; i <= Math.sqrt(n); i++) { if (n % i === 0) { return false; } } return n > 1; } const random = (max) => Math.floor(Math.random() * max); function generatePrimes(quota) { const primes = []; while (primes.length < quota) { const candidate = random(MAX_PRIME); if (isPrime(candidate)) { primes.push(candidate); } } return primes; } const quota = document.querySelector(\"#quota\"); const output = document.querySelector(\"#output\"); document.querySelector(\"#generate\").addEventListener(\"click\", () => { const primes = generatePrimes(quota.value); output.textContent = `Finished generating ${quota.value} primes!`; }); document.querySelector(\"#reload\").addEventListener(\"click\", () => { document.location.reload(); }); The reason for this is that this JavaScript program is single-threaded. A thread is a sequence of instructions that a program follows. Because the program consists of a single thread, it can only do one thing at a time: so if it is waiting for our long-running synchronous call to return, it can't do anything else. What we need is a way for our program to:\n• Have that function start the operation and return immediately, so that our program can still be responsive to other events.\n• Have the function execute the operation in a way that does not block the main thread, for example by starting a new thread.\n• Notify us with the result of the operation when it eventually completes. That's precisely what asynchronous functions enable us to do. The rest of this module explains how they are implemented in JavaScript.\n\nThe description we just saw of asynchronous functions might remind you of event handlers, and if it does, you'd be right. Event handlers are really a form of asynchronous programming: you provide a function (the event handler) that will be called, not right away, but whenever the event happens. If \"the event\" is \"the asynchronous operation has completed\", then that event could be used to notify the caller about the result of an asynchronous function call. Some early asynchronous APIs used events in just this way. The API enables you to make HTTP requests to a remote server using JavaScript. Since this can take a long time, it's an asynchronous API, and you get notified about the progress and eventual completion of a request by attaching event listeners to the object. The following example shows this in action. Press \"Click to start request\" to send a request. We create a new and listen for its event. The handler logs a \"Finished!\" message along with the status code. After adding the event listener we send the request. Note that after this, we can log \"Started XHR request\": that is, our program can continue to run while the request is going on, and our event handler will be called when the request is complete. const log = document.querySelector(\".event-log\"); document.querySelector(\"#xhr\").addEventListener(\"click\", () => { log.textContent = \"\"; const xhr = new XMLHttpRequest(); xhr.addEventListener(\"loadend\", () => { log.textContent = `${log.textContent}Finished with status: ${xhr.status}`; }); xhr.open( \"GET\", \"https://raw.githubusercontent.com/mdn/content/main/files/en-us/_wikihistory.json\", ); xhr.send(); log.textContent = `${log.textContent}Started XHR request\n\n`; }); document.querySelector(\"#reload\").addEventListener(\"click\", () => { log.textContent = \"\"; document.location.reload(); }); This is an event handler just the same as handlers for user actions such as the user clicking a button. This time, however, the event is a change in the state of an object.\n\nAn event handler is a particular type of callback. A callback is just a function that's passed into another function, with the expectation that the callback will be called at the appropriate time. As we just saw, callbacks used to be the main way asynchronous functions were implemented in JavaScript. However, callback-based code can get hard to understand when the callback itself has to call functions that accept a callback. This is a common situation if you need to perform some operation that breaks down into a series of asynchronous functions. For example, consider the following: Here we have a single operation that's split into three steps, where each step depends on the last step. In our example, the first step adds 1 to the input, the second adds 2, and the third adds 3. Starting with an input of 0, the end result is 6 (0 + 1 + 2 + 3). As a synchronous program, this is very straightforward. But what if we implemented the steps using callbacks? Because we have to call callbacks inside callbacks, we get a deeply nested function, which is much harder to read and debug. This is sometimes called \"callback hell\" or the \"pyramid of doom\" (because the indentation looks like a pyramid on its side). When we nest callbacks like this, it can also get very hard to handle errors: often you have to handle errors at each level of the \"pyramid\", instead of having error handling only once at the top level. For these reasons, most modern asynchronous APIs don't use callbacks. Instead, the foundation of asynchronous programming in JavaScript is the , and that's the subject of the next article."
    },
    {
        "link": "https://docs.minecraftforge.net",
        "document": "This is the official documentation for MinecraftForge, the Minecraft modding API.\n\nThis documentation is only for Forge, this is not a Java tutorial.\n\nIf you would like to contribute to the docs, read Contributing to the Docs."
    },
    {
        "link": "https://forums.minecraftforge.net/topic/39033-1710-worldsetblock-method",
        "document": "I am currently working on my first real minecraft mod. I have a bit over a year in Java experience, and know how to use google so I've already tried looking for solutions to my issue.\n\nMy mod is 'grey-goo' inspired, with the idea that my mod's 'goo' blocks, over time randomly replace other adjacent blocks with itself, who then go one to spread and so forth until you've got an entire chunk of land 'transformed/devoured' by this 'goo block'\n\nSo for i have a block, and a tile entity.\n\nAnd finally the Basic Entity Class, where the magic happens:\n\nWhat happens at the moment, is very strange.\n\nI place down a 'virus/grey goo' block, and after a few seconds it infects an adjacent block or two and so on. However, if i place another block on SOME of these newly infected goos, they instantly revert to what they were before, and in a few seconds are infected again by adjacent goos.\n\nThe amount of times for me to be be able to watch a block be infected, place any block on it(by right clicking) watch it revert, be infected by nearby viruses until it stops reverting is anywhere between 1 and 10.\n\nI believe the only reason for this would be the 'setblock' method.\n\nI am setting the metadata of the new block to 0, this doesn't do anything as my blocks do not use any metadata, and the 'flag' is set to 1, because it makes no difference to my block whether i set it from 1-4.\n\nIf anyone could give any input on how i may be using setBlock() wrong, please respond!\n\nThanks so much for the help."
    },
    {
        "link": "https://stackoverflow.com/questions/75778192/how-to-use-setblock-with-custom-block-in-forge",
        "document": "So, i was making a mod and i wanted to use level.setBlock() which i used like this: and it worked but when i want to set my custom block, i have this error: The method setBlock(BlockPos, BlockState, int) in the type Level is not applicable for the arguments (BlockPos, RegistryObject<Block>, int).\n\nThe problem is that i can't use defaultBlockState() with my custom block but i want to do ."
    },
    {
        "link": "https://skmedix.github.io/ForgeJavaDocs/javadoc/forge/1.9.4-12.17.0.2051/net/minecraft/world/World.html",
        "document": "Used in the getEntitiesWithinAABB functions to expand the search area for entities. Modders should change this variable to a higher value if it is less then the radius of one of there entities."
    },
    {
        "link": "https://stuffaboutcode.com/p/minecraft-api-reference.html",
        "document": "\n• Class Minecraft - main class for connecting and interacting with the game\n• Class events - retreiving events which have occured in the game\n\nNot all functions and block types are available on all version of the api, by each function you will see a logo which shows whether that function is available:\n\n#retrieves the block type for the block at 0,0,0\n\n\n\n \n\n .getBlockWithData(x,y,z)\n\n \n\n .setBlocks(x0,y0,z0,x1,y1,z1,blockType, blockData)\n\n \"Set a cuboid of blocks (x0,y0,z0,x1,y1,z1,id,[data])\"\n\n \n\n \n\n \n\n .getHeight(x,z)\n\n \"Get the height of the world (x,z) => int\"\n\n #find the y (vertical) of an x, z co-ordinate which represents the 'highest' (non-air) block \n\n \n\n \n\n .getPlayerEntityIds()\n\n \"Get the entity ids of the connected players => [id:int]\"\n\n #get the entity id's of the players connected to the game \n\n \n\n \n\n \n\n \n\n .getPlayerEntityId(playerName)\n\n \"Get the entity id for a named player => [id:int]\"\n\n \n\n \n\n \n\n \n\n .saveCheckpoint()\n\n \"Save a checkpoint that can be used for restoring the world\"\n\n \n\n .restoreCheckpoint()\n\n \"Restore the world state to the checkpoint\"\n\n \"Get a cuboid of blocks (x0,y0,z0,x1,y1,z1) => [id:int]\"\"Set a cuboid of blocks (x0,y0,z0,x1,y1,z1,id,[data])\"\"Get the height of the world (x,z) => int\"\"Get the entity ids of the connected players => [id:int]\"\"Get the entity id for a named player => [id:int]\"\"Save a checkpoint that can be used for restoring the world\"\"Restore the world state to the checkpoint\"\n\n#get the position of the tile the players is on\n\n#set the position of the tile the player is on\n\n#get the rotation of the player\n\n#get the pitch for the player\n\nThe entity functions are used in conjunction with the .getPlayerEntityIds() function to interact with the entity (or players) in a game. Entity functions are useful for multiplayer games.\n\n#get the entity id's of the players connected to the game \n\n \n\n \n\n \n\n\n\n#get the position of the tile the entity is on\n\n#set the position of the tile the entity is on\n\n\n\n.getRotation(entityId)\n\n \"Get the rotational angle (0 to 360) for an entity => [angle:float]\"\n\n #get the rotation of an entity \n\n \n\n \n\n \n\n.getPitch(entityId)\n\n \"Get the pitch angle (-90 to 90) for an entity => [pitch:float]\"\n\n \n\n \n\n \n\n \n\n.getDirection(entityId)\n\n \"Get unit vector of x,y,z for an entities direction => [Vec3]\"\n\n \n\n \n\n \n\n \"Get the rotational angle (0 to 360) for an entity => [angle:float]\"\"Get the pitch angle (-90 to 90) for an entity => [pitch:float]\"\"Get unit vector of x,y,z for an entities direction => [Vec3]\"\n\n#get block event hits that have occured since the last time the function was run\n\n#get chat post events (messages) since the last time the function was run\n\n\n\n \n\n 2: Pointing west\n\n 3: Pointing south\n\n 4: Pointing north\n\n 5: Facing up\n\n \n\n STONE_BRICK:\n\n 0: Stone brick\n\n 1: Mossy stone brick\n\n 2: Cracked stone brick\n\n 3: Chiseled stone brick\n\n \n\n STONE_SLAB / STONE_SLAB_DOUBLE:\n\n 0: Stone\n\n 1: Sandstone\n\n 2: Wooden\n\n 3: Cobblestone\n\n 4: Brick\n\n 5: Stone Brick\n\n Below - not on Pi\n\n 6: Nether Brick\n\n 7: Quartz\n\n \n\n Not on Pi\n\n SNOW_BLOCK:\n\n 0-7: Height of snow, 0 being the lowest, 7 being the highest.\n\n \n\n TNT:\n\n 0: Inactive\n\n 1: Ready to explode\n\n \n\n LEAVES:\n\n 1: Oak leaves\n\n 2: Spruce leaves\n\n 3: Birch leaves\n\n \n\n SANDSTONE:\n\n 0: Sandstone\n\n 1: Chiseled sandstone\n\n 2: Smooth sandstone\n\n \n\n STAIRS_[COBBLESTONE, WOOD]:\n\n 0: Ascending east\n\n 1: Ascending west\n\n 2: Ascending south\n\n 3: Ascending north\n\n 4: Ascending east (upside down)\n\n 5: Ascending west (upside down)\n\n 6: Ascending south (upside down)\n\n 7: Ascending north (upside down)\n\n \n\n LADDERS, CHESTS, FURNACES, FENCE_GATE:\n\n 2: Facing north\n\n 3: Facing south\n\n 4: Facing west\n\n 5: Facing east\n\n \n\n [WATER, LAVA]_STATIONARY:\n\n 0-7: Level of the water, 0 being the highest, 7 the lowest\n\n \n\n NETHER_REACTOR_CORE:\n\n 0: Unused\n\n 1: Active\n\n 2: Stopped / used up\n\n \n\n \"The definition of a BlockEvent in Minecraft, used to describe an event in Minecraft affecting blocks; returned by the Minecraft.events.pollBlockHits() method.\"\n\n \n\n \n\n \n\n .type\n\n \"Type of block event; there is only 1 event currently implemented BlockEvent.HIT\"\n\n \n\n \n\n BlockEvent types:\n\n 0: BlockEvent.HIT\n\n \n\n .pos\n\n \"The position of the block where the event occured, i.e. the block which was hit. .pos returns a Vec3 object of x,y,z co-ordinates\"\n\n \n\n \n\n .face\n\n \"The face of the block where the event occured\"\n\n \n\n \n\n .entityId\n\n \"entityId of the player who caused the block event, i.e. the player who hit the block\"\n\n \n\n \"The definition of a ChatEvent in Minecraft, used to describe an event when a message is posted to the chat bar in Minecraft, returned by Minecraft.events.pollBlockHits() method.\"\n\n \n\n \n\n \n\n .type\n\n \"Type of block event; there is only 1 event currently implemented ChatEvent.POST\"\n\n \n\n \n\n ChatEvent types:\n\n 0: ChatEvent.POST\n\n \n\n .message\n\n \"The message which was posted to the chat window.\"\n\n \n\n \n\n .entityId\n\n \"entityId of the player who posted the message to the chat.\"\n\n \n\n \"The definition of a 3 part vector in Minecraft, i.e. a set of x, y, z co-ordinates; x and z are the horizontal positions, y the vertical\" \"The id (or type) of block\"2: Pointing west3: Pointing south4: Pointing north5: Facing upSTONE_BRICK:0: Stone brick1: Mossy stone brick2: Cracked stone brick3: Chiseled stone brickSTONE_SLAB / STONE_SLAB_DOUBLE:0: Stone1: Sandstone2: Wooden3: Cobblestone4: Brick5: Stone BrickBelow - not on Pi6: Nether Brick7: QuartzNot on PiSNOW_BLOCK:0-7: Height of snow, 0 being the lowest, 7 being the highest.TNT:0: Inactive1: Ready to explodeLEAVES:1: Oak leaves2: Spruce leaves3: Birch leavesSANDSTONE:0: Sandstone1: Chiseled sandstone2: Smooth sandstoneSTAIRS_[COBBLESTONE, WOOD]:0: Ascending east1: Ascending west2: Ascending south3: Ascending north4: Ascending east (upside down)5: Ascending west (upside down)6: Ascending south (upside down)7: Ascending north (upside down)LADDERS, CHESTS, FURNACES, FENCE_GATE:2: Facing north3: Facing south4: Facing west5: Facing east[WATER, LAVA]_STATIONARY:0-7: Level of the water, 0 being the highest, 7 the lowestNETHER_REACTOR_CORE:0: Unused1: Active2: Stopped / used up\"The definition of a BlockEvent in Minecraft, used to describe an event in Minecraft affecting blocks; returned by the Minecraft.events.pollBlockHits() method.\"\"Type of block event; there is only 1 event currently implemented BlockEvent.HIT\"0: BlockEvent.HIT\"The position of the block where the event occured, i.e. the block which was hit. .pos returns a Vec3 object of x,y,z co-ordinates\"\"The face of the block where the event occured\"\"entityId of the player who caused the block event, i.e. the player who hit the block\"\"The definition of a ChatEvent in Minecraft, used to describe an event when a message is posted to the chat bar in Minecraft, returned by Minecraft.events.pollBlockHits() method.\"\"Type of block event; there is only 1 event currently implemented ChatEvent.POST\"0: ChatEvent.POST\"The message which was posted to the chat window.\"\"entityId of the player who posted the message to the chat.\""
    }
]