[
    {
        "link": "https://stackoverflow.com/questions/62480629/sort-a-list-of-tuples-by-a-custom-comparator-in-python",
        "document": "I have a list of tuple that looks like the following:\n\nI want to sort this list by the rgb value. I am given a \"target\" color and have to sort the list by how close each rgb tuple is to the target color. I have a function called that takes in two colors and returns the distance between them. I want to use this color distance function as a comparator function to sort my list of tuples by each tuple's rgb value distance to the target color.\n\nI could sort the list by selection sort and use my color_distance function to compare but I want it sorted faster/ using a library function.\n\nI am trying to use the function in python but don't know how."
    },
    {
        "link": "https://stackoverflow.com/questions/32807791/custom-sort-of-a-list-of-tuples",
        "document": "I only started learning Python few days ago, and I wanted to implement my little project in it. I need to sort a list of in a descending order by the number value, but alphabetically if the number is the same for more than one tuple. So I have a list, say:\n\nBut what I want to get is:\n\nIn Java I just implemented a comparator for a custom tuple:\n\nBut I'm not sure how to go about doing that in a expression in Python."
    },
    {
        "link": "https://geeksforgeeks.org/python-sort-tuple-list-on-basis-of-difference-of-elements",
        "document": "Sometimes, while working with data, we can have a problem of sorting them. There are many types of basis on which sorting can be performed. But this article discusses sorting on basis of difference of both elements of pair. Let’s discuss certain ways in which this can be done.\n\nMethod #1 : Using sorted() + lambda The combination of above functionalities can be used to solve this problem. In this, sorting is performed by sorted() and lambda function is fed as key to perform desired sorting.\n\nTime Complexity: O(nlogn), where n is the length of the input list. This is because we’re using sorted() + lambda which has a time complexity of O(nlogn) in the worst case.\n\nAuxiliary Space: O(n), as we’re using additional space res other than the input list itself with the same size of input list.\n\nMethod #2 : Using sort() + comparator + cmp() This is yet another way to perform this task. In this, we pass the sort(), a comparator function which performs the similar difference logic using cmp(). Works only in Python2.\n\nTime Complexity: O(n*nlogn), where n is the length of the list test_dict\n\nAuxiliary Space: O(n) additional space of size n is created where n is the number of elements in the res list\n\nIn this, we import the itemgetter function from the operator module. The itemgetter function takes an index as input and returns a function that retrieves that index from a tuple. We then use the itemgetter function to retrieve the first and second elements of each tuple and calculate their absolute difference. Finally, we pass the lambda function as the key for the sorted function to sort the list based on the difference between the elements of each tuple. The resulting sorted list is then printed to the console.\n\nThe complexity analysis of the code is as follows:\n\nDefining the original list of tuples:\n\nThis step takes O(n) time, where n is the size of the original list.\n\nSorting the list by difference using itemgetter as key:\n\nSorting takes O(nlogn) time in the worst case, where n is the size of the original list. Since we are sorting based on the difference between the first and second elements of each tuple, the time complexity of each comparison operation between the elements of the list is O(1). Therefore, the overall time complexity of the sorting operation in this code is O(nlogn).\n\nPrinting the sorted list:\n\nThis step takes O(n) time, where n is the size of the sorted list.\n\n1.Create a heap of tuples, where each tuple contains the difference between the two elements of the input tuple and the input tuple itself.\n\n2.Heapify the created heap.\n\n3.Pop the elements from the heap and add them to the output list until the heap is empty.\n\nTime Complexity:\n\nThe time complexity of creating the heap is O(n), where n is the number of tuples in the input list. The time complexity of heapifying the heap is O(nlogn). The time complexity of popping the elements from the heap is O(nlogn). Therefore, the overall time complexity is O(nlogn).\n\nSpace Complexity:\n\nThe space complexity of creating the heap is O(n), where n is the number of tuples in the input list. The space complexity of heapifying the heap is O(1). The space complexity of popping the elements from the heap is O(1). Therefore, the overall space complexity is O(n)."
    },
    {
        "link": "https://ioflood.com/blog/python-sort-algorithms",
        "document": "Sorting data is a fundamental task in programming. Whether you’re a data scientist needing to organize large datasets or a developer wanting to order user inputs, sorting algorithms are essential.\n\nPython, like a master librarian, offers several ways to sort your data, each with its own advantages and use cases.\n\nIn this guide, we’ll walk you through the different sorting algorithms available in Python, from the simplest to the most complex. We’ll start with Python’s built-in and functions, then delve into more advanced algorithms like quicksort, mergesort, and heapsort. Along the way, we’ll discuss time complexities, use cases, and even troubleshoot common issues.\n\nLet’s start our journey into the world of Python sorting algorithms!\n\nTL;DR: How Do I Sort Lists in Python?\n\nHere’s a simple example of using :\n\nIn this example, we have a list of numbers. We use the function to sort the numbers in ascending order. The function modifies the list in-place, meaning the original list is sorted, and no new list is created.\n\nPython provides two built-in functions for sorting: and . These functions are the most straightforward way to sort data in Python, making them perfect for beginners.\n\nThe function is a method that you can call on lists in Python. It modifies the list it is called on, meaning it sorts the list in-place and does not create a new list. Here’s an example:\n\nIn this example, we call on our list of numbers, and it sorts the numbers in ascending order. The original list is modified to be sorted.\n\nThe function, on the other hand, works on any iterable, not just lists. It creates a new sorted list from the iterable it is called on. Here’s an example:\n\nIn this example, we call on a tuple of numbers. It returns a new list that is sorted in ascending order. The original tuple remains unchanged.\n\nBoth and use a sorting algorithm called Timsort, which is a hybrid sorting algorithm derived from merge sort and insertion sort. The time complexity of Timsort is O(n log n) for the worst case and average case, and O(n) for the best case (when the input is already sorted). This makes and efficient for large datasets.\n\nWhile Python’s built-in and functions are powerful, understanding the mechanics of more complex sorting algorithms, such as quicksort, mergesort, and heapsort, can offer greater control and efficiency in certain scenarios.\n\nQuicksort is a divide-and-conquer algorithm. It works by selecting a ‘pivot’ element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. The sub-arrays are then recursively sorted. Here’s a simple implementation of quicksort in Python:\n\nIn this example, we first check if the list is empty or contains a single element. If so, it is already sorted. If not, we select a pivot and partition the list into elements less than, equal to, and greater than the pivot. We then recursively sort the ‘less than’ and ‘greater than’ sub-lists.\n\nQuicksort’s time complexity is O(n log n) in the best and average cases, and O(n^2) in the worst case when the list is already sorted. Despite its worst-case scenario, quicksort is often faster in practice than other O(n log n) algorithms, such as mergesort and heapsort.\n\nMergesort is another divide-and-conquer algorithm. It works by dividing the unsorted list into n sublists, each containing one element (a list of one element is considered sorted), and repeatedly merging sublists to produce new sorted sublists until there is only one sublist remaining. Here’s an example:\n\nIn this example, we first check if the list is empty or contains a single element. If so, it is already sorted. If not, we divide the list into two halves. We then recursively sort each half and merge the sorted halves.\n\nMergesort’s time complexity is O(n log n) in all cases, making it efficient for large datasets. However, it requires O(n) auxiliary space, meaning it uses more memory than in-place algorithms like quicksort.\n\nHeapsort is a comparison-based sorting algorithm. It works by visualizing the elements of the array as a special kind of complete binary tree called a heap. Here’s an example:\n\nIn this example, we use Python’s built-in module to push all elements onto a heap. We then pop off the smallest elements one at a time, resulting in a sorted list.\n\nHeapsort’s time complexity is O(n log n) in all cases, and it sorts in place, meaning it doesn’t require extra space. However, it’s not a stable sort, meaning equal elements may not keep their original order.\n\nWhile Python provides robust built-in sorting methods and allows for advanced sorting techniques such as quicksort, mergesort, and heapsort, there might be instances where you need to implement custom sorting algorithms tailored to specific needs or constraints. This section explores how to create such custom sorting algorithms, complete with code examples, and discusses their potential advantages and disadvantages.\n\nBoth and functions in Python accept a parameter for custom sorting. The function transforms each element before sorting, it doesn’t affect the original content. Here’s an example of sorting a list of strings based on their length:\n\nIn this example, is used as the function. This sorts the list based on the length of the strings, rather than their lexicographical order.\n\nFor more complex custom sorting, you can use a lambda function as the function. A lambda function is a small anonymous function that can take any number of arguments, but can only have one expression. Here’s an example of sorting a list of tuples based on the second element of each tuple:\n\nIn this example, the lambda function is used as the function. This sorts the list based on the second element of each tuple.\n\nCustom sorting algorithms provide flexibility and can be tailored to specific needs. However, they can be more complex to implement and maintain than using built-in sorting functions or algorithms. As with any algorithm, it’s important to consider the trade-offs between simplicity, performance, and adaptability to specific requirements.\n\nWhile Python’s sorting algorithms are powerful and versatile, like any tool, they can present challenges. This section discusses common issues that can arise when sorting data in Python, such as handling non-comparable data types, and provides solutions to these problems.\n\nPython’s sorting functions, and , work by comparing elements. This works well when sorting lists of numbers or strings, but what happens when you try to sort a list of different data types?\n\nAs seen in the example above, trying to sort a list of mixed data types results in a . This is because Python doesn’t know how to compare an integer and a string.\n\nThe solution is to ensure that all elements in the list are of a comparable type. If you have control over the data, this might mean converting all elements to strings or all elements to numbers before sorting. If not, you can use a custom function to transform the elements for the purpose of sorting.\n\nIn this example, we use as the function to convert all elements to strings before comparing them. This allows the function to compare the elements and sort the list.\n\nRemember that the function doesn’t modify the original elements—it only transforms them for the purpose of sorting. The original list still contains the original elements, in their original types, but in sorted order.\n\nSorting can become complex when dealing with more complex data types, like lists of custom objects or nested lists. But with a solid understanding of Python’s sorting algorithms and the parameter, you can sort almost anything.\n\nBefore diving into the specifics of Python sort algorithms, it’s crucial to understand the fundamental theory behind sorting algorithms and the concept of time complexity.\n\nA sorting algorithm is a method that organizes elements in a particular order. Most commonly, this order is numerical (ascending or descending) or lexicographical. Sorting is a key tool in many areas of computer science and programming, from data analysis to machine learning, and is one of the most studied types of algorithms.\n\nSorting algorithms can be classified based on their mechanism of action into various types, including exchange sorts (like bubble sort), selection sorts, insertion sorts, merge sorts, and distribution sorts (like bucket sort).\n\nTime complexity is a computational concept that describes the amount of computer time taken by an algorithm to run, as a function of the size of the input to the program. It’s usually expressed using Big O notation, which describes the upper bound of the time complexity in the worst case scenario. Here are some common time complexities:\n\nFor example, a simple linear search algorithm has a time complexity of O(n), meaning the time taken to execute increases linearly with the number of input elements. On the other hand, a binary search algorithm has a time complexity of O(log n), meaning it’s much more efficient for large datasets.\n\nUnderstanding time complexity is crucial when dealing with large datasets, as inefficient algorithms can lead to significantly longer running times or even make the task unfeasible.\n\nIn the context of Python sort algorithms, the built-in and functions have a time complexity of O(n log n) due to their use of Timsort, a highly efficient sorting algorithm. Other algorithms, like quicksort, mergesort, and heapsort, also have a time complexity of O(n log n) in the best or average case, but this can degrade to O(n^2) in the worst case for quicksort.\n\nBy understanding the theory behind sorting algorithms and the concept of time complexity, you can make informed decisions about which algorithm to use based on the specific requirements of your task.\n\nSorting algorithms are not just theoretical concepts, they are fundamental tools used in a variety of real-world Python applications. Understanding and choosing the right sort algorithm can have a significant impact on the performance and efficiency of your Python projects.\n\nIn the field of data analysis, sorting algorithms are used to organize and process large datasets. For instance, you might need to sort a dataset of customer transactions by date, or a list of products by price. Using an efficient sort algorithm can significantly speed up these operations, especially for large datasets.\n\nIn machine learning, sorting algorithms can be used in various ways. For example, in the k-nearest neighbors algorithm, a common task is to sort the distances between a new data point and all existing data points to find the ‘k’ closest ones. Efficiently sorting these distances can significantly improve the performance of the algorithm.\n\nTo further enhance your understanding and skills in Python sort algorithms, here are some additional resources:\n• Python Built-In Functions: Quick Dive – Dive deep into Python’s functions for working with iterators and generators.\n• None Python sleep() Function: Introducing Delays in Code – Discover Python’s “sleep” function for delays in code execution.\n• None Python Absolute Value: Finding Magnitude with abs() -Python’s “abs” function for getting a number’s absolute value.\n• None Mastering Basic Algorithms in the Python Language – This book provides an in-depth look at the core algorithms in Python.\n• None Python Sorting Tutoroial by Real Python explains Python’s built-in sorting methods and implementing your own sorting algorithms.\n• None The Algorithm Design Manual – While not a Python-specific book, it covers everything from sorting to searching with algorithms.\n\nAs you continue your journey in Python programming, consider exploring related topics such as searching algorithms in Python, which are often used in conjunction with sorting algorithms to efficiently find elements in a list or other data structure.\n\nIn this comprehensive guide, we’ve delved deep into the world of Python sort algorithms. We’ve explored the built-in and functions, and ventured into more advanced territory with quicksort, mergesort, and heapsort.\n\nWe began with the basics, understanding how to use Python’s built-in sorting functions. This was followed by an in-depth exploration of more complex sorting algorithms, their code implementations, and their time complexities. We also discussed how to implement custom sorting algorithms and tackled common issues that can arise when sorting data in Python.\n\nWhether you’re a beginner just starting out with Python sort algorithms or an experienced developer looking to level up your skills, we hope this guide has given you a deeper understanding of Python’s sorting capabilities.\n\nWith this knowledge, you can make informed decisions about which algorithm to use based on the specific requirements of your task. Happy coding!"
    },
    {
        "link": "https://medium.com/@huzaifazahoor654/sorting-with-all-data-structures-in-python-c697a34931c0",
        "document": "Sorting is a fundamental operation in programming that allows us to arrange data in a specific order, making it easier to analyze, search, and retrieve information. Python, being a versatile and powerful programming language, provides various data structures to store and manage data efficiently. In this comprehensive guide, we will explore the art of sorting with all the major data structures in Python, empowering you with the knowledge and skills to tackle sorting tasks with confidence.\n\nWhether you are working with lists, tuples, sets, dictionaries, or arrays, Python offers intuitive methods and functions to sort data effectively. Understanding how to leverage these sorting techniques will not only enhance your programming capabilities but also optimize the performance of your code. So, let’s dive into the world of sorting with Python and discover the techniques to organize and arrange data in a structured and meaningful way.\n\nUsing the sorted() function for List Sorting\n\nSorting a list using the built-in sorted() function provides a convenient way to obtain a sorted version of the list without modifying the original. The sorted() function returns a new sorted list based on the elements’ natural order or a custom sorting key.\n\nThe sort() method allows sorting a list in-place, modifying the original list. It arranges the elements of the list in ascending order by default but can be customized using the key parameter.\n\nPython’s sorting functions support the key parameter, which allows defining a function to extract a value for comparison. This enables sorting based on specific criteria, such as sorting a list of strings based on the length of each string.\n\nWhen sorting a list of objects, the key parameter can be used to specify the attribute or property of the objects to use for comparison. This enables sorting based on specific object attributes.\n\nTuples are immutable in Python, meaning their elements cannot be modified. However, sorting tuples is possible by creating a sorted version using the sorted() function, similar to sorting lists.\n\nTo sort tuples based on specific criteria, the key parameter can be used with sorted() to define a custom function or lambda expression that extracts the desired value for comparison.\n\nSets in Python are unordered collections of unique elements. While sets don’t have a specific order, you can sort them by converting them to a list and using the sorted() function.\n\nSince sets are unordered, sorting them using the sorted() function returns a new sorted list based on the elements’ natural order.\n\nDictionaries in Python are unordered collections of key-value pairs. However, if you need to retrieve the keys in sorted order, you can use the sorted() function with the dictionary’s keys() method.\n\nTo sort dictionaries based on their values, the sorted() function can be used with the dictionary’s items() method and a custom key function or lambda expression.\n\nArrays in Python are provided by the module, allowing efficient storage of homogeneous data types. Sorting arrays can be done using the sorted() function or the array's method.\n\nArrays provide a method that allows sorting the array in-place, modifying the original array. This method sorts the elements in ascending order by default.\n\nTo sort a data frame by one or more columns, you can use the method. This method allows you to specify the column(s) to sort by and the desired sorting order (ascending or descending).\n\nTo sort a DataFrame by multiple columns, you can pass a list of column names to the method. The DataFrame will be sorted based on the specified column order.\n\nSorting a Series: To sort a Series object, you can use the method, similar to sorting a DataFrame. This method returns a new Series with the sorted values.\n\nIf you want to sort a Series based on its index, you can use the method. This method returns a new Series with the values sorted based on the index.\n\nFactors to Consider when Selecting an Algorithm\n\nWhen choosing a sorting algorithm, it’s essential to consider factors such as the size of the data set, the desired level of sorting stability, and the specific requirements of the problem.\n\nDifferent sorting algorithms have varying performance characteristics. Some algorithms, like Bubble Sort, have a higher time complexity, making them inefficient for large data sets. Other algorithms, like Quick Sort and Merge Sort, offer better time complexity and are suitable for larger data sets.\n\nBubble Sort compares adjacent elements and swaps them if they are in the wrong order. This process is repeated until the list is sorted.\n\nSelection Sort: Simplicity at the Cost of Efficiency\n\nSelection Sort divides the list into sorted and unsorted parts. It repeatedly selects the smallest element from the unsorted part and places it at the end of the sorted part.\n\nInsertion Sort builds the final sorted array one item at a time. It iterates through the list, comparing each element to its previous ones and inserting it into the correct position.\n\nMerge Sort divides the list into smaller sublists, sorts them recursively, and then merges them back together to create the sorted list.\n\nQuick Sort selects a pivot element and partitions the list around it, moving elements smaller than the pivot to its left and elements larger than the pivot to its right. It then recursively sorts the sub-lists.\n\nSorting is a fundamental operation in computer science and programming. In Python, you have various options and algorithms to efficiently sort different data structures such as lists, tuples, sets, dictionaries, Pandas, and arrays. By understanding the characteristics and trade-offs of different sorting algorithms, you can choose the most appropriate one for your specific requirements.\n\nRemember to consider the size of the data set, the stability of the sorting algorithm, and the efficiency needed for your application. With the knowledge gained from this comprehensive guide, you are equipped to optimize your sorting operations in Python and enhance the performance of your code.\n\nNow it’s time to apply your newfound knowledge and choose the right sorting algorithm for your next programming task. Happy sorting in Python!"
    },
    {
        "link": "https://geeksforgeeks.org/python-remove-duplicate-tuples-from-list-of-tuples",
        "document": "Given a list of tuples, Write a Python program to remove all the duplicated tuples from the given list.\n\nMethod #1 : List comprehension This is a naive approach to use list comprehension. Here, we use two for loops and set data structure to cancel out all the duplicates.\n\nTime complexity: O(n*logn), where n is the length of the input list. \n\nAuxiliary space: O(n), where n is the length of the input list.\n\nMethod #2 : List comprehension (Efficient approach) This method is efficient as compared to the above method, here we use a single for loop within list comprehension and then convert it to set to remove duplicates and then again convert it to list.\n\nTime complexity: O(n) where n is the number of tuples in the list. \n\nAuxiliary space: O(n).\n\nTime complexity: O(n^2), where n is the length of the input list. \n\nAuxiliary space: O(n^2).\n\nThis method involves creating a dictionary where the keys are the tuples, and the values are a boolean indicating whether the tuple has been encountered before. We can then iterate through the list and add the tuples to the result list if they have not been encountered before.\n\nTime complexity: O(n), where n is the number of tuples in the list.\n\nAuxiliary Space: O(n), as we are creating a dictionary with n keys.\n\nTime complexity: O(n), where n is the number of tuples in the list.\n\nAuxiliary Space: O(n), as we are creating a n function call.\n\nTime complexity: O(n log n), where n is the length of the input list. \n\nAuxiliary space: O(n), where n is the length of the input list."
    },
    {
        "link": "https://stackoverflow.com/questions/19416786/remove-duplicate-tuples-from-a-list-if-they-are-exactly-the-same-including-order",
        "document": "This will probably do what you want, but it's vast overkill. It's a low-level prototype for a generator that may be added to some day. It's low level to ease re-implementing it in C. Where is the length of the iterable input, it requires worst-case space and does at most element comparisons, regardless of how many anagrams are generated. Both of those are optimal ;-)\n\nYou'd use it like so:\n\nThere will be no duplicates in the output. Note: this is Python 3 code. It needs a few changes to run under Python 2."
    },
    {
        "link": "https://stackoverflow.com/questions/48300501/how-to-remove-duplicate-tuples-from-a-list-in-python",
        "document": "I have a list that contains list of tuples as follows.\n\nI want to remove the duplicate tuples from and get an output as follows.\n\nIt seems like in python does not work for it.\n\nIs there any fast and easy way of doing this in python (perhaps using libraries)?"
    },
    {
        "link": "https://dataquest.io/blog/how-to-remove-duplicates-from-a-python-list",
        "document": "How to Easily Remove Duplicates from a Python List (2023)\n\nA Python list is an ordered, zero-indexed, and mutable collection of objects. We create it by placing objects of similar or different data types inside square brackets separated by commas. For a refresher on how a Python List works, kindly refer to this DataQuest tutorial.\n\nRemoving duplicates from a list is an important data preprocessing step — for example, identifying the unique customers who purchased from a gift shop in the past month for promotional offers. Several customers may have bought gifts from the shop more than once in the past month, and their names will appear as many times as they visited the shop.\n\nIn this tutorial, we'll learn the different methods for removing duplicates from a Python List.\n\nWe use the keyword to delete objects from a list with their index position. We use this method when the size of the list is small and there aren't many duplicate elements. For example, a class of six students were asked about their favorite programming language, and their responses were saved in the list. Several students preferred the same programming language, so we have duplicates in the list that we'll remove using the keyword.\n\nWe successfully removed the duplicates from the list. But why did we use index 3 twice? The of the original list is 6. A Python List is zero-indexed. The first element in the list has an index of 0, and the last element has an index of 5. The duplicate has an index of 3. After deleting the duplicate, the of the list is reduced by 1. The element after the duplicate now assumes its index position. This is why the duplicate index changes from 4 to 3. The disadvantage of using this method is that we have to keep track of the duplicates' indices, which keep changing. This would be difficult for a very large list.\n\nNext, we'll remove duplicates from a list more efficiently using .\n\nWe use to iterate over an iterable: for example, a Python List. For a referesher on how works, kindly refer to this for-loop tutorial on DataQuest blog.\n\nTo remove duplicates using , first you create a new empty list. Then, you iterate over the elements in the list containing duplicates and append only the first occurrence of each element in the new list. The code below shows how to use to remove duplicates from the list.\n\nVoilà! We successfully removed the duplicates without having to keep track of the elements' indices. This method can help us remove duplicates in a large list. However, this required a lot of code. There should be a simpler way to do this. Any guesses?\n\nList comprehension! We'll simplify the above code using list comprehension in the next example:\n\nWe got the job done with fewer lines of code. We can combine with the and functions to write exotic bits of code to remove duplicates. The idea behind how these codes work is the same as in the examples shown above.\n\nNext, we will see how to remove duplicates from a list without iterating using a .\n\nSets in Python are unordered collections of unique elements. By their nature, duplicates aren't allowed. Therefore, converting a list into a set removes the duplicates. Changing the set into a list yields a new list without duplicates.\n\nThe following example shows how to remove duplicates from the list using .\n\nNotice that the order of the elements in the list is different from our previous examples. This is because a doesn't preserve order. Next, we'll see how to remove duplicates from a list using a dictionary.\n\nA Python dictionary is a collection of key-value pairs with the requirement that keys must be unique. So, we'll remove the duplicates in a Python List if we can make the elements of the list be the keys of a dictionary. We cannot convert the simple list to a dictionary because a dictionary is created with a key-value pair. We get the following error if we try to convert the list to a dictionary:\n\nHowever, we can create a dictionary from a list of tuples — after which we'll get the unique keys of the dictionary and convert them into a list. A vectorized way of getting the list of tuples from the list is using the map function:\n\nIn the above code block, every element in the list is passed through the function to create a tuple, . When the list of tuples is changed into a dictionary, the first element in the tuple is the key and the second element is the value. The unique keys are from the dictionary with the method and changed into a list:\n\nThe method converts a list into a list of tuples and the list of tuples into a dictionary in one go. We can then get the unique dictionary keys and convert them to a list. However, we used the method to get the unique keys from the dictionary before converting to a list. This isn't really necessary. By default, operations on a dictionary like iteration and converting to a list use the dictionary keys.\n\nWe can remove duplicates from a Python list using dictionary subclasses like and . Both and work in the same way. They are collections wherein the unique elements are the dictionary keys and counts of their occurence are the values. As in a dictionary, the list without duplicates comes from the dictionary keys.\n\nBoth and take a list with duplicates and return a unique array of the elements in the list. The resulting arrays are converted to lists. While sorts the unique elements in ascending order, maintains the order of the elements in the list.\n\nIn this section, we'll revisit our gift shop illustration. The gift shop is in a neigborhood of 50 people. An average of 10 people purchase from the shop every day, and the shop is open 10 days a month. You received a list of lists containing the names of the customers who purchased from the shop in the previous month, and your task is to get the names of the unique customers for a promotional offer.\n\nIn the above code block, we randomly generated customers who purchased from the store in the past month as a list of lists. We want to get the unique customers who purchased from the store every month, so we'll create the function for this task.\n\nWe have included the optional input and output data types. Python is a dynamically typed programming language and implicitly handles this during runtime. However, it's useful to show the input and output data types for complicated data structures. Alternatively, we can describe the input and output of the function with a . tells us that the parameter is a list that contains lists with strings, and the tells us that the function returns a list that contains tuples with a string and an integer.\n\nThe names of the customers were randomly generated — yours may be different if you don't use the same value. The names of the unique customers in comes from first converting the list of tuples to a dictionary and then converting the dictionary keys to a list:\n\nIn this tutorial, we learned how to remove duplicates from a Python List. We learned how to remove duplicates with the keyword for small lists. For larger lists, we saw that using and list comprehension methods were more efficient than using the keyword. Furthermore, we learned that the values of a and the keys of a dictionary are unique, which makes them suitable for removing duplicates from a list. Finally, we learned that dictionary subclasses remove duplicates from a list in much the same way as a dictionary, and we saw the NumPy and pandas methods for getting unique elements from a list."
    },
    {
        "link": "https://geeksforgeeks.org/python-removing-duplicates-from-tuple",
        "document": "Many times, while working with Python tuples, we can have a problem removing duplicates. This is a very common problem and can occur in any form of programming setup, be it regular programming or web development. Let’s discuss certain ways in which this task can be performed.\n\nMethod #1 : Using set() + tuple() This is the most straight forward way to remove duplicates. In this, we convert the tuple to a set, removing duplicates and then converting it back again using tuple().\n\nTime complexity: O(n), where n is the length of the input tuple.\n\nAuxiliary space: O(n), where n is the length of the input tuple.\n\nThe combination of the above functions can also be used to perform this particular task. In this, we convert the tuples to dictionaries removing duplicates and then accessing its keys.\n\nTime complexity: O(n), where n is the length of the input tuple. \n\nAuxiliary space: O(n), where n is the length of the input tuple.\n\nMethod #3: Using in, not in operators and tuple()\n\nTime complexity: O(n), where n is the length of the input tuple. \n\nAuxiliary space: O(n), where n is the length of the input tuple.\n\nTime complexity: O(n), where n is the number of elements in the tuple. \n\nAuxiliary space: O(k), where k is the number of distinct elements in the tuple."
    }
]