[
    {
        "link": "https://requests.readthedocs.io/en/master/user/quickstart",
        "document": "Eager to get started? This page gives a good introduction in how to get started with Requests.\n\nFirst, make sure that:\n\nLet’s get started with some simple examples.\n\nMaking a request with Requests is very simple. Now, let’s try to get a webpage. For this example, let’s get GitHub’s public timeline: Now, we have a object called . We can get all the information we need from this object. Requests’ simple API means that all forms of HTTP request are as obvious. For example, this is how you make an HTTP POST request: Nice, right? What about the other HTTP request types: PUT, DELETE, HEAD and OPTIONS? These are all just as simple: That’s all well and good, but it’s also only the start of what Requests can do.\n\nYou often want to send some sort of data in the URL’s query string. If you were constructing the URL by hand, this data would be given as key/value pairs in the URL after a question mark, e.g. . Requests allows you to provide these arguments as a dictionary of strings, using the keyword argument. As an example, if you wanted to pass and to , you would use the following code: You can see that the URL has been correctly encoded by printing the URL: Note that any dictionary key whose value is will not be added to the URL’s query string. You can also pass a list of items as a value:\n\nWe can read the content of the server’s response. Consider the GitHub timeline again: Requests will automatically decode content from the server. Most unicode charsets are seamlessly decoded. When you make a request, Requests makes educated guesses about the encoding of the response based on the HTTP headers. The text encoding guessed by Requests is used when you access . You can find out what encoding Requests is using, and change it, using the property: If you change the encoding, Requests will use the new value of whenever you call . You might want to do this in any situation where you can apply special logic to work out what the encoding of the content will be. For example, HTML and XML have the ability to specify their encoding in their body. In situations like this, you should use to find the encoding, and then set . This will let you use with the correct encoding. Requests will also use custom encodings in the event that you need them. If you have created your own encoding and registered it with the module, you can simply use the codec name as the value of and Requests will handle the decoding for you.\n\nThere’s also a builtin JSON decoder, in case you’re dealing with JSON data: In case the JSON decoding fails, raises an exception. For example, if the response gets a 204 (No Content), or if the response contains invalid JSON, attempting raises . This wrapper exception provides interoperability for multiple exceptions that may be thrown by different python versions and json serialization libraries. It should be noted that the success of the call to does not indicate the success of the response. Some servers may return a JSON object in a failed response (e.g. error details with HTTP 500). Such JSON will be decoded and returned. To check that a request is successful, use or check is what you expect.\n\nIn the rare case that you’d like to get the raw socket response from the server, you can access . If you want to do this, make sure you set in your initial request. Once you do, you can do this: In general, however, you should use a pattern like this to save what is being streamed to a file: Using will handle a lot of what you would otherwise have to handle when using directly. When streaming a download, the above is the preferred and recommended way to retrieve the content. Note that can be freely adjusted to a number that may better fit your use cases. An important note about using versus . will automatically decode the and transfer-encodings. is a raw stream of bytes – it does not transform the response content. If you really need access to the bytes as they were returned, use .\n\nIf you’d like to add HTTP headers to a request, simply pass in a to the parameter. For example, we didn’t specify our user-agent in the previous example: Note: Custom headers are given less precedence than more specific sources of information. For instance:\n• None Authorization headers set with will be overridden if credentials are specified in , which in turn will be overridden by the parameter. Requests will search for the netrc file at , , or at the path specified by the environment variable.\n• None Authorization headers will be removed if you get redirected off-host.\n• None Proxy-Authorization headers will be overridden by proxy credentials provided in the URL.\n• None Content-Length headers will be overridden when we can determine the length of the content. Furthermore, Requests does not change its behavior at all based on which custom headers are specified. The headers are simply passed on into the final request. Note: All header values must be a , bytestring, or unicode. While permitted, it’s advised to avoid passing unicode header values.\n\nTypically, you want to send some form-encoded data — much like an HTML form. To do this, simply pass a dictionary to the argument. Your dictionary of data will automatically be form-encoded when the request is made: The argument can also have multiple values for each key. This can be done by making either a list of tuples or a dictionary with lists as values. This is particularly useful when the form has multiple elements that use the same key: There are times that you may want to send data that is not form-encoded. If you pass in a instead of a , that data will be posted directly. For example, the GitHub API v3 accepts JSON-Encoded POST/PATCH data: Please note that the above code will NOT add the header (so in particular it will NOT set it to ). If you need that header set and you don’t want to encode the yourself, you can also pass it directly using the parameter (added in version 2.4.2) and it will be encoded automatically: Note, the parameter is ignored if either or is passed.\n\nYou can set the filename, content_type and headers explicitly: If you want, you can send strings to be received as files: In the event you are posting a very large file as a request, you may want to stream the request. By default, does not support this, but there is a separate package which does - . You should read the toolbelt’s documentation for more details about how to use it. For sending multiple files in one request refer to the advanced section. It is strongly recommended that you open files in binary mode. This is because Requests may attempt to provide the header for you, and if it does this value will be set to the number of bytes in the file. Errors may occur if you open the file in text mode.\n\nWe can view the server’s response headers using a Python dictionary: The dictionary is special, though: it’s made just for HTTP headers. According to RFC 7230, HTTP Header names are case-insensitive. So, we can access the headers using any capitalization we want: It is also special in that the server could have sent the same header multiple times with different values, but requests combines them so they can be represented in the dictionary within a single mapping, as per RFC 7230: A recipient MAY combine multiple header fields with the same field name into one “field-name: field-value” pair, without changing the semantics of the message, by appending each subsequent field value to the combined field value in order, separated by a comma.\n\nYou can tell Requests to stop waiting for a response after a given number of seconds with the parameter. Nearly all production code should use this parameter in nearly all requests. Failure to do so can cause your program to hang indefinitely: is not a time limit on the entire response download; rather, an exception is raised if the server has not issued a response for seconds (more precisely, if no bytes have been received on the underlying socket for seconds). If no timeout is specified explicitly, requests do not time out.\n\nIn the event of a network problem (e.g. DNS failure, refused connection, etc), Requests will raise a exception. will raise an if the HTTP request returned an unsuccessful status code. If a request times out, a exception is raised. If a request exceeds the configured number of maximum redirections, a exception is raised. All exceptions that Requests explicitly raises inherit from . Ready for more? Check out the advanced section."
    },
    {
        "link": "https://geeksforgeeks.org/python-requests-post-request-with-headers-and-body",
        "document": "HTTP headers let the client and the server pass additional information with an HTTP request or response. All the headers are case-insensitive, headers fields are separated by colon, key-value pairs in clear-text string format.\n\nRequests do not change its behavior at all based on which headers are specified. The headers are simply passed on into the final request. All header values must be a string, bytestring, or Unicode. While permitted, it’s advised to avoid passing Unicode header values. We can make requests with the headers we specify and by using the headers attribute we can tell the server with additional information about the request.\n\nHeaders can be Python Dictionaries like, { “Name of Header”: “Value of the Header” }\n\nThe Authentication Header tells the server who you are. Typically, we can send the authentication credentials through the Authorization header to make an authenticated request.\n\nPOST requests pass their data through the message body, The Payload will be set to the data parameter. data parameter takes a dictionary, a list of tuples, bytes, or a file-like object. You’ll want to adapt the data you send in the body of your request to the specified URL.\n\nGiven below are few implementations to help understand the concept better.\n\nExample 1: Sending requests with data as a payload\n\nExample 2: Sending requests with JSON data and headers\n\nHow Do You Send POST Request with Body in Python?\n\nTo send a POST request with a body in Python, you can use the library, which simplifies making HTTP requests. Here’s a basic example of how to send a POST request with data in the body: \n\n\n\n \n\n data = {'key': 'value'} # Dictionary that will be sent in the POST body \n\n \n\n\n\nHow to Pass Headers in Requests in Python?\n\nWhat is the Payload of a Request in Python?\n\nIn the context of HTTP and the library in Python, the payload of a request refers to the body of the request—it’s the data you send with your request. For POST requests, this is typically provided as a dictionary, JSON, or files, which will encode to the appropriate format based on the header.\n\nHow to Perform a POST Request Using JSON File as Body?\n\nTo perform a POST request using a JSON file as the body in Python, you need to load the JSON content into a Python dictionary and then pass it to the method with the parameter. Here’s how you can do it: \n\n\n\n\n\n \n\n # Assuming 'data.json' is in the same directory as your script \n\n \n\n \n\n\n\n \n\n The library automatically sets the to when you use the parameter. This simplifies the process of sending JSON data over HTTP POST requests."
    },
    {
        "link": "https://requests.readthedocs.io",
        "document": "Requests is an elegant and simple HTTP library for Python, built for human beings.\n\nRequests allows you to send HTTP/1.1 requests extremely easily. There’s no need to manually add query strings to your URLs, or to form-encode your POST data. Keep-alive and HTTP connection pooling are 100% automatic, thanks to urllib3."
    },
    {
        "link": "https://realpython.com/python-requests",
        "document": "The Requests library is the de facto standard for making HTTP requests in Python. It abstracts the complexities of making requests behind a beautiful, simple API so that you can focus on interacting with services and consuming data in your application.\n\nThroughout this tutorial, you’ll see some of the most useful features that Requests has to offer as well as ways to customize and optimize those features for different situations that you may come across. You’ll also learn how to use Requests in an efficient way as well as how to prevent requests to external services from slowing down your application.\n\nIn this tutorial, you’ll learn how to:\n• Make requests using the most common HTTP methods\n• Customize your requests’ headers and data using the query string and message body\n• Inspect data from your requests and responses\n• Configure your requests to help prevent your application from backing up or slowing down\n\nFor the best experience working through this tutorial, you should have basic general knowledge of HTTP. That said, you still may be able to follow along fine without it.\n\nIn the upcoming sections, you’ll see how you can install and use in your application. If you want to play with the code examples that you’ll see in this tutorial, as well as some additional ones, then you can download the code examples and work with them locally:\n\nEven though the Requests library is a common staple for many Python developers, it’s not included in Python’s standard library. There are good reasons for that decision, primarily that the library can continue to evolve more freely as a self-standing project. Note: Requests doesn’t support asynchronous HTTP requests directly. If you need async support in your program, you should try out AIOHTTP or HTTPX. The latter library is broadly compatible with Requests’ syntax. Because Requests is a third-party library, you need to install it before you can use it in your code. As a good practice, you should install external packages into a virtual environment, but you may choose to install into your global environment if you’re planning to use it across multiple projects. Whether you’re working in a virtual environment or not, you’ll need to install : Once has finished installing , you can use it in your application. Importing looks like this: Now that you’re all set up, it’s time to begin your journey through Requests. Your first goal will be learning how to make a request.\n\nA is a powerful object for inspecting the results of the request. Make that same request again, but this time store the return value in a variable so that you can get a closer look at its attributes and behaviors: In this example, you’ve captured the return value of , which is an instance of , and stored it in a variable called . You can now use to see a lot of information about the results of your request. The first bit of information that you can gather from is the status code. A status code informs you of the status of the request. For example, a status means that your request was successful, whereas a status means that the resource you were looking for wasn’t found. There are many other possible status codes as well to give you specific insights into what happened with your request. By accessing , you can see the status code that the server returned: returned , which means that your request was successful and the server responded with the data that you were requesting. Sometimes, you might want to use this information to make decisions in your code: With this logic, if the server returns a status code, then your program will print . If the result is a , then your program will print . Requests goes one step further in simplifying this process for you. If you use a instance in a conditional expression, then it’ll evaluate to if the status code was smaller than , and otherwise. Therefore, you can simplify the last example by rewriting the statement: In the code snippet above, you implicitly check whether the of is between and . If it’s not, then you raise an exception that includes the non-success status code in an f-string. Note: This truth value test is possible because is an overloaded method on . This means that the adapted default behavior of takes the status code into account when determining the truth value of the object. Keep in mind that this method is not verifying that the status code is equal to . The reason for this is that other status codes within the to range, such as and , are also considered successful in the sense that they provide some workable response. For example, the status code tells you that the response was successful, but there’s no content to return in the message body. So, make sure you use this convenient shorthand only if you want to know if the request was generally successful. Then, if necessary, you’ll need to handle the response appropriately based on the status code. Let’s say you don’t want to check the response’s status code in an statement. Instead, you want to use Request’s built-in capacities to raise an exception if the request was unsuccessful. You can do this using : If you invoke , then Requests will raise an for status codes between and . If the status code indicates a successful request, then the program will proceed without raising that exception. Now, you know a lot about how to deal with the status code of the response that you got back from the server. However, when you make a request, you rarely only care about the status code of the response. Usually, you want to see more. Next, you’ll see how to view the actual data that the server sent back in the body of the response. The response of a request often has some valuable information, known as a payload, in the message body. Using the attributes and methods of , you can view the payload in a variety of different formats. To see the response’s content in , you use : While gives you access to the raw bytes of the response payload, you’ll often want to convert them into a string using a character encoding such as UTF-8. will do that for you when you access : Because the decoding of to a requires an encoding scheme, Requests will try to guess the encoding based on the response’s headers if you don’t specify one. You can provide an explicit encoding by setting before accessing : If you take a look at the response, then you’ll see that it’s actually serialized JSON content. To get a dictionary, you could take the that you retrieved from and deserialize it using . However, a simpler way to accomplish this task is to use : The of the return value of is a dictionary, so you can access values in the object by key: You can do a lot with status codes and message bodies. But, if you need more information, like metadata about the response itself, then you’ll need to look at the response’s headers. The response headers can give you useful information, such as the content type of the response payload and a time limit on how long to cache the response. To view these headers, access : returns a dictionary-like object, allowing you to access header values by key. For example, to see the content type of the response payload, you can access : There’s something special about this dictionary-like headers object, though. The HTTP specification defines headers as case-insensitive, which means that you’re able to access these headers without worrying about their capitalization: Whether you use the key or , you’ll get the same value. Now that you’ve seen the most useful attributes and methods of in action, you already have a good overview of Requests’ basic usage. You can get content from the Internet and work with the response that you receive. But there’s more to the Internet than plain and straightforward URLs. In the next section, you’ll take a step back and see how your responses change when you customize your requests to account for query string parameters.\n\nAccording to the HTTP specification, , , and the less common requests pass their data through the message body rather than through parameters in the query string. Using Requests, you’ll pass the payload to the corresponding function’s parameter. takes a dictionary, a list of tuples, bytes, or a file-like object. You’ll want to adapt the data that send in the body of your request to the specific needs of the service that you’re interacting with. For example, if your request’s content type is , then you can send the form data as a dictionary: You can also send that same data as a list of tuples: If, however, you need to send JSON data, then you can use the parameter. When you pass JSON data via , Requests will serialize your data and add the correct header for you. Like you learned earlier, the httpbin service accepts test requests and responds with data about the requests. For instance, you can use it to inspect a basic request: You can see from the response that the server received your request data and headers as you sent them. Requests also provides this information to you in the form of a that you’ll inspect in more detail in the next section.\n\nAuthentication helps a service understand who you are. Typically, you provide your credentials to a server by passing data through the header or a custom header defined by the service. All the functions of Requests that you’ve seen to this point provide a parameter called , which allows you to pass your credentials: The request succeeds if the credentials that you pass in the tuple to are valid. When you pass your credentials in a tuple to the parameter, Requests applies the credentials using HTTP’s Basic access authentication scheme under the hood. You may wonder where the string that Requests set as the value for your header comes from. In short, it’s a Base64-encoded string of the username and password with the prefix :\n• First, Requests combines the username and password that you provided, putting a colon in between them. So for the username and password , this becomes .\n• Then, Requests encodes this string in Base64 using . The encoding converts the string to .\n• Finally, Requests adds in front of this Base64 string. This is how the final value for the header becomes in the example shown above. HTTP Basic authentication isn’t very secure, because you can decode the username and password from the Base64 string. That’s why it’s important to always send these requests over HTTPS, which provides an additional layer of security by encrypting the entire HTTP request. You could make the same request by passing explicit Basic authentication credentials using : Though you don’t need to be explicit for Basic authentication, you may want to authenticate using another method. Requests provides other methods of authentication out of the box, such as and . A real-world example of an API that requires authentication is GitHub’s authenticated user API. This endpoint provides information about the authenticated user’s profile. If you try to make a request without credentials, then you’ll see that the status code is : If you don’t provide authentication credentials when accessing a service that requires them, then you’ll get an HTTP error code as a response. To make a request to GitHub’s authenticated user API, you first need to generate a personal access token with the read:user scope. Then you can pass this token as the second element in a tuple to : Like you learned previously, this approach passes the credentials to , which expects a username and a password and sends the credentials as a Base64-encoded string with the prefix : This works, but it’s not the right way to authenticate with a Bearer token—and using an empty string input for the superfluous username is awkward. With Requests, you can supply your own authentication mechanism to fix that. To try this out, create a subclass of and implement : \"\"\"Attach an API token to the Authorization header.\"\"\" Here, your custom mechanism receives a token, then includes that token in the header of your request, also setting the recommended prefix to the string. You can now use this custom token authentication to make your call to GitHub’s authenticated user API: Your custom created a well-formatted string for the header. You can now use this more intuitive way of interacting with a token-based authentication scheme such as the one that parts of GitHub’s API require. Note: While you could construct the authentication string outside of a custom authentication class and pass it directly with , this appoach is discouraged because it can lead to unexpected behavior. When you attempt to set your authentication credentials directly using , then Requests may internally overwrite your input. This can happen, for example, if you have a file that provides authentication credentials. Requests will attempt to get the credentials from the file if you don’t provide an authentication method using . Bad authentication mechanisms can lead to security vulnerabilities. Unless a service requires a custom authentication mechanism for some reason, you’ll always want to use a tried-and-true auth scheme like the built-in Basic authentication or OAuth, for example through Requests-OAuthlib. While you’re thinking about security, consider dealing with SSL certificates using Requests.\n\nAnytime the data that you’re trying to send or receive is sensitive, security is important. The way that you communicate with secure sites over HTTP is by establishing an encrypted connection using SSL, which means that verifying the target server’s SSL certificate is critical. The good news is that Requests does this for you by default. However, there are some cases where you might want to change this behavior. If you want to disable SSL certificate verification, then you pass to the parameter of the request function: InsecureRequestWarning: Unverified HTTPS request is being made to host Requests even warns you when you’re making an insecure request to help you keep your data safe! Note: Requests uses a package called to provide certificate authorities. This lets Requests know which authorities it can trust. Therefore, you should update frequently to keep your connections as secure as possible. Now that you know how to make all sorts of HTTP requests using Requests, authenticated or not, you may wonder about how you can make sure that your program works as quickly as possible. In the next section, you’ll learn about a few ways that you can improve performance with the help of Requests.\n\nWhen using Requests, especially in a production application environment, it’s important to consider performance implications. Features like timeout control, sessions, and retry limits can help you keep your application running smoothly. When you make an inline request to an external service, your system will need to wait for the response before moving on. If your application waits too long for that response, requests to your service could back up, your user experience could suffer, or your background jobs could hang. By default, Requests will wait indefinitely on the response, so you should almost always specify a timeout duration to prevent these issues from happening. To set the request’s timeout, use the parameter. can be an integer or float representing the number of seconds to wait on a response before timing out: In the first request, the request will time out after 1 second. In the second request, the request will time out after 3.05 seconds. You can also pass a tuple to with the following two elements:\n• Connect timeout: The time it allows for the client to establish a connection to the server\n• Read timeout: The time it’ll wait on a response once your client has established a connection Both of these elements should be numbers, and can be of type or : If the request establishes a connection within 3.05 seconds and receives data within 5 seconds of the connection being established, then the response will be returned as it was before. If the request times out, then the function will raise a exception: \"The request did not time out\" Your program can catch the exception and respond accordingly. Until now, you’ve been dealing with high-level APIs such as and . These functions are abstractions of what’s going on when you make your requests. They hide implementation details, such as how connections are managed, so that you don’t have to worry about them. Underneath those abstractions is a class called . If you need to fine-tune your control over how requests are being made or improve the performance of your requests, you may need to use a instance directly. Sessions are used to persist parameters across requests. For example, if you want to use the same authentication across multiple requests, then you can use a session: In this code example, you use a context manager to ensure that the session releases the resources when it doesn’t need them anymore. In line 7, you log in using your custom . You only need to log in once per session, and then you can make multiple authenticated requests. Requests will persist the credentials while the session exists. You then make two requests to the authenticated user API in lines 9 and 10 using instead of . The primary performance optimization of sessions comes in the form of persistent connections. When your app makes a connection to a server using a , it keeps that connection around in a connection pool. When your app wants to connect to the same server again, it’ll reuse a connection from the pool rather than establishing a new one. When a request fails, you may want your application to retry the same request. However, Requests won’t do this for you by default. To apply this functionality, you need to implement a custom transport adapter. Transport adapters let you define a set of configurations for each service that you’re interacting with. For example, say you want all requests to to retry two times before finally raising a . You’d build a transport adapter, set its parameter, and mount it to an existing : In this example, you’ve set up your session so that it’ll retry a maximum of two times when your request to GitHub’s API doesn’t work as expected. When you mount the —in this case, —to , then will adhere to its configuration for each request to . Note: While the implementation shown above works, you won’t see any effect of the retry behavior unless there’s something wrong with your network connection or GitHub’s servers. If you want to play around with code that builds on top of this example, and you’d like to inspect when the retries happen, then you’re in luck. You can download the materials of this tutorial and take a look at : Get Your Code: Click here to download the free sample code that shows you how to use Python’s Requests library. The code in this file improves on the example shown above by using the underlying to further customize the retry functionality. It also adds logging to display debugging output, which gives you a chance to monitor when Python attempted the retries. Requests comes packaged with intuitive implementations for timeouts, transport adapters, and sessions that can help you keep your code efficient and your application resilient."
    },
    {
        "link": "https://stackoverflow.com/questions/47540268/how-to-send-file-using-request-python-with-some-headers",
        "document": "For Basic Authentication you can follow the requests docs. It's visible on the very first line of code in the example on that page.\n\nUse the keyword argument to supply a 2-tuple of username and password:\n\nIf you want to send actual headers, rather than things like Basic Auth, you can do that with the keyword argument. This allows you to give a dict of headers you would like to send. For example:\n\nThe argument, should be a simplification of the above because Basic Auth is so common, but don't quote me on that one."
    },
    {
        "link": "https://stackoverflow.com/questions/9733638/how-to-post-json-data-with-python-requests",
        "document": "I need to POST a JSON from a client to a server. I'm using Python 2.7.1 and simplejson. The client is using Requests. The server is CherryPy. I can GET a hard-coded JSON from the server (code not shown), but when I try to POST a JSON to the server, I get \"400 Bad Request\".\n\nHere is my client code:\n\nHere is the server code."
    },
    {
        "link": "https://stackoverflow.com/questions/71356248/how-to-post-json-with-data-payload-and-header-with-python-requests",
        "document": "I am trying to do some scraping from websites using GET and POST methods, but now I am facing a new challenge.\n\nI am trying to get data from a credit simulator, I found this portuguese site (https://www.bancomontepio.pt/particulares/credito/pessoal/credito-pessoal-online).\n\nAs far as I know, I need to use POST method, but I have to specify the data (the Amount value, the Term...). I usually do it by creating a dictionary structure but that is not working.\n\nI'm kinda lost to be fair, maybe the problem is on the header...\n\nHere is my code:\n\nIf i take off the .json(), I get the error Response [410].\n\nThe goal is to get the TAN or TAEG that change when term (\"Prazo\") or amount (\"Montante\") values change.\n\nNow I'm getting a empty json()... Response 200 but I got this structure:\n\nAs far as I know, the status should be \"OK\" to get some info on the Result."
    },
    {
        "link": "https://apidog.com/blog/python-requests-post-json",
        "document": "Are you looking to send JSON data to a server using Python Requests? If so, you’re in the right place! In this blog post, we’ll go over how to use Python Requests to POST JSON data. We’ll cover everything from the basics of sending a POST request to handling the response received from the server, and even handling errors that may occur along the way. So, let’s get started!\n\nPython Requests is a Python 3.7+ library that simplifies the process of sending HTTP/1.1 requests. It provides a simple API for interacting with HTTP methods such as GET, POST, PUT, PATCH and more.\n\nThe following code snippet demonstrates how to use the library to send an HTTP POST request:\n\nIn this example, we are sending an HTTP POST request to with a JSON payload containing a username and password. The method is used to send the request, and the response status code and content are printed to the console.\n\nYou can install the library using the following command:\n\nIn this blog post, we’ll be focusing on how to use Python Requests to send a POST request with JSON data.\n\nJSON stands for JavaScript Object Notation. It's a standardized format for representing structured data. It is a text-based format that uses human-readable text to store and transmit data objects consisting of attribute-value pairs and arrays (or other serializable values). JSON is commonly used for transmitting data in web applications, such as sending data from the server to the client, or vice versa.\n\nJSON can represent six types of data natively: strings, numbers, booleans, null, arrays, and objects. For example, here is a JSON representation of a blog post:\n\nThis example demonstrates all the JSON data types. It also illustrates the concision of JSON-formatted data, one of the characteristics that’s made it so appealing for use in APIs.\n\nIn other terms, it’s a lightweight data-interchange format that is easy for humans to read and write, and easy for machines to parse and generate. JSON is a text format that is completely language-independent, making it an ideal choice for data exchange between different programming languages.\n\nA POST request is a type of HTTP request method that is used to send data to a server to create or update a resource. It is often used when uploading a file or when submitting a completed web form. The POST request method requests that a web server accepts the data enclosed in the body of the request message, most likely for storing it.\n\nJSON's standardized format for representing objects and data makes it a popular choice for sending data in POST requests. By using JSON, developers can ensure that the data sent to the server is well-organized and easily understandable, enhancing the efficiency of resource creation and updates.\n\nIn contrast to the HTTP GET request method, which retrieves information from the server, the POST request method requests that a web server accept the data enclosed in the body of the request message, most likely for storing it. An arbitrary amount of data of any type can be sent to the server in the body of the request message.\n\nHere’s an example of how to use the library to send an HTTP POST request:\n\nIn this example, we are sending an HTTP POST request to with a JSON payload containing a username and password. The method is used to send the request, and the response status code and content are printed to the console.\n\nHow to Use Python Requests to POST JSON Data?\n\nNow that we have a basic understanding of what Python Requests and JSON are, let’s dive into how to use Python Requests to POST JSON data. Here’s an example of how to do it:\n\nIn this example, we are sending an HTTP POST request to with a JSON payload containing a username and password. The method is used to send the request, and the response status code and content are printed to the console. Note that we are using the method to convert the dictionary to a JSON string before sending it in the request body.\n\nYou can install the library using the following command:\n\nAfter sending the POST request, we’ll receive a response from the server. We can handle the response using the object that we created earlier. Here’s an example of how to handle the response:\n\nIn this example, we’re checking the status code of the response to see if the request was successful. If the status code is 200, we’ll print “Success!”. Otherwise, we’ll print “An error occurred.”.\n\nSometimes, things don’t go as planned. In the event that an error occurs while sending the POST request, we’ll want to handle it gracefully. Here’s an example of how to handle errors:\n\nIn this example, we’re using a / block to catch any errors that may occur while sending the POST request. If an error occurs, we’ll print the error message.\n\nHow to Send Python POST Requests with JSON Data in Apidog?\n\nApidog is a powerful testing solution that provides developers with a more robust interface testing experience. Its advanced features like creating custom test cases, generating reports, and load testing empower developers with greater flexibility and capabilities within their testing workflows. Compared to Postman, Apidog stands out as a more comprehensive and powerful testing solution.\n\nTo send a POST request with JSON data in Apidog, follow these steps:\n\nStep 2: Click on the Request tab and select POST from the dropdown menu.\n\nStep 3: Enter the URL of the API endpoint you want to test, in the Headers section, add any required headers. In the Body section, select JSON from the dropdown menu and enter the JSON data you want to send in the request body.\n\nStep 4: Click on the Send button to send the request and check the response.\n\nThat’s it! You have successfully sent a Python POST request with JSON data in Apidog.\n\nIn this blog post, we’ve covered how to use Python Requests to POST JSON data. We’ve gone over the basics of sending a POST request, handling the response, and handling errors. We hope that this blog post has been helpful to you, and that you’re now able to use Python Requests to POST JSON data with ease!\n\n1. What is the difference between GET and POST requests in Python Requests?\n\nGET requests are used to retrieve data from a server, whereas POST requests are used to send data to the server to create or update resources. In Python Requests, you use for GET requests and for POST requests.\n\n2. How do I include headers when sending a POST request with JSON data?\n\nTo include headers in a POST request, you can use the parameter in the method. For example, to specify the content type as JSON:\n\n3. Why should I use the parameter instead of when sending JSON data?\n\nWhen you use the parameter, Python Requests automatically converts your Python dictionary into a JSON string and sets the correct header ( ). This eliminates the need to manually serialize the data using .\n\n4. How can I handle non-200 status codes in the response?\n\nTo handle errors in HTTP responses, you can check the response’s status code and take appropriate action. Here's an example:\n\n5. What should I do if the server returns an error when sending the request?\n\nYou can use a block to catch potential exceptions when making the request. For example:\n\n6. How do I send JSON data in a POST request without using the parameter?\n\nIf you don’t want to use the parameter, you can manually serialize your data using the method and pass it in the parameter. However, make sure to set the correct header:\n\n7. Can I test POST requests with JSON data in Apidog?\n\nYes, you can test POST requests with JSON data in Apidog. Just select the POST method, enter the URL, set the content type to JSON in the headers, and input your JSON data in the body of the request. Apidog also allows you to check the response and validate it efficiently, making it a great tool for API testing.\n\n8. How can I debug a POST request if it’s not working as expected?\n\nTo debug a POST request, check the following:\n• Status code: Ensure the server is responding with the expected status code (e.g., 200 for success).\n• Response content: Look at the response content to get more details about what went wrong.\n• Headers: Double-check the request headers (especially and authorization tokens).\n• Data format: Verify that the JSON data you are sending is well-formed.\n\n9. What are common errors when sending JSON data with Python Requests?\n• Invalid JSON: If the JSON is malformed, you'll get an error such as .\n• Incorrect Content-Type: Ensure that you set in the headers if you're sending JSON data.\n• Connection Errors: If the URL or the server is unreachable, you’ll encounter a ."
    },
    {
        "link": "https://realpython.com/python-requests",
        "document": "The Requests library is the de facto standard for making HTTP requests in Python. It abstracts the complexities of making requests behind a beautiful, simple API so that you can focus on interacting with services and consuming data in your application.\n\nThroughout this tutorial, you’ll see some of the most useful features that Requests has to offer as well as ways to customize and optimize those features for different situations that you may come across. You’ll also learn how to use Requests in an efficient way as well as how to prevent requests to external services from slowing down your application.\n\nIn this tutorial, you’ll learn how to:\n• Make requests using the most common HTTP methods\n• Customize your requests’ headers and data using the query string and message body\n• Inspect data from your requests and responses\n• Configure your requests to help prevent your application from backing up or slowing down\n\nFor the best experience working through this tutorial, you should have basic general knowledge of HTTP. That said, you still may be able to follow along fine without it.\n\nIn the upcoming sections, you’ll see how you can install and use in your application. If you want to play with the code examples that you’ll see in this tutorial, as well as some additional ones, then you can download the code examples and work with them locally:\n\nEven though the Requests library is a common staple for many Python developers, it’s not included in Python’s standard library. There are good reasons for that decision, primarily that the library can continue to evolve more freely as a self-standing project. Note: Requests doesn’t support asynchronous HTTP requests directly. If you need async support in your program, you should try out AIOHTTP or HTTPX. The latter library is broadly compatible with Requests’ syntax. Because Requests is a third-party library, you need to install it before you can use it in your code. As a good practice, you should install external packages into a virtual environment, but you may choose to install into your global environment if you’re planning to use it across multiple projects. Whether you’re working in a virtual environment or not, you’ll need to install : Once has finished installing , you can use it in your application. Importing looks like this: Now that you’re all set up, it’s time to begin your journey through Requests. Your first goal will be learning how to make a request.\n\nA is a powerful object for inspecting the results of the request. Make that same request again, but this time store the return value in a variable so that you can get a closer look at its attributes and behaviors: In this example, you’ve captured the return value of , which is an instance of , and stored it in a variable called . You can now use to see a lot of information about the results of your request. The first bit of information that you can gather from is the status code. A status code informs you of the status of the request. For example, a status means that your request was successful, whereas a status means that the resource you were looking for wasn’t found. There are many other possible status codes as well to give you specific insights into what happened with your request. By accessing , you can see the status code that the server returned: returned , which means that your request was successful and the server responded with the data that you were requesting. Sometimes, you might want to use this information to make decisions in your code: With this logic, if the server returns a status code, then your program will print . If the result is a , then your program will print . Requests goes one step further in simplifying this process for you. If you use a instance in a conditional expression, then it’ll evaluate to if the status code was smaller than , and otherwise. Therefore, you can simplify the last example by rewriting the statement: In the code snippet above, you implicitly check whether the of is between and . If it’s not, then you raise an exception that includes the non-success status code in an f-string. Note: This truth value test is possible because is an overloaded method on . This means that the adapted default behavior of takes the status code into account when determining the truth value of the object. Keep in mind that this method is not verifying that the status code is equal to . The reason for this is that other status codes within the to range, such as and , are also considered successful in the sense that they provide some workable response. For example, the status code tells you that the response was successful, but there’s no content to return in the message body. So, make sure you use this convenient shorthand only if you want to know if the request was generally successful. Then, if necessary, you’ll need to handle the response appropriately based on the status code. Let’s say you don’t want to check the response’s status code in an statement. Instead, you want to use Request’s built-in capacities to raise an exception if the request was unsuccessful. You can do this using : If you invoke , then Requests will raise an for status codes between and . If the status code indicates a successful request, then the program will proceed without raising that exception. Now, you know a lot about how to deal with the status code of the response that you got back from the server. However, when you make a request, you rarely only care about the status code of the response. Usually, you want to see more. Next, you’ll see how to view the actual data that the server sent back in the body of the response. The response of a request often has some valuable information, known as a payload, in the message body. Using the attributes and methods of , you can view the payload in a variety of different formats. To see the response’s content in , you use : While gives you access to the raw bytes of the response payload, you’ll often want to convert them into a string using a character encoding such as UTF-8. will do that for you when you access : Because the decoding of to a requires an encoding scheme, Requests will try to guess the encoding based on the response’s headers if you don’t specify one. You can provide an explicit encoding by setting before accessing : If you take a look at the response, then you’ll see that it’s actually serialized JSON content. To get a dictionary, you could take the that you retrieved from and deserialize it using . However, a simpler way to accomplish this task is to use : The of the return value of is a dictionary, so you can access values in the object by key: You can do a lot with status codes and message bodies. But, if you need more information, like metadata about the response itself, then you’ll need to look at the response’s headers. The response headers can give you useful information, such as the content type of the response payload and a time limit on how long to cache the response. To view these headers, access : returns a dictionary-like object, allowing you to access header values by key. For example, to see the content type of the response payload, you can access : There’s something special about this dictionary-like headers object, though. The HTTP specification defines headers as case-insensitive, which means that you’re able to access these headers without worrying about their capitalization: Whether you use the key or , you’ll get the same value. Now that you’ve seen the most useful attributes and methods of in action, you already have a good overview of Requests’ basic usage. You can get content from the Internet and work with the response that you receive. But there’s more to the Internet than plain and straightforward URLs. In the next section, you’ll take a step back and see how your responses change when you customize your requests to account for query string parameters.\n\nAccording to the HTTP specification, , , and the less common requests pass their data through the message body rather than through parameters in the query string. Using Requests, you’ll pass the payload to the corresponding function’s parameter. takes a dictionary, a list of tuples, bytes, or a file-like object. You’ll want to adapt the data that send in the body of your request to the specific needs of the service that you’re interacting with. For example, if your request’s content type is , then you can send the form data as a dictionary: You can also send that same data as a list of tuples: If, however, you need to send JSON data, then you can use the parameter. When you pass JSON data via , Requests will serialize your data and add the correct header for you. Like you learned earlier, the httpbin service accepts test requests and responds with data about the requests. For instance, you can use it to inspect a basic request: You can see from the response that the server received your request data and headers as you sent them. Requests also provides this information to you in the form of a that you’ll inspect in more detail in the next section.\n\nAuthentication helps a service understand who you are. Typically, you provide your credentials to a server by passing data through the header or a custom header defined by the service. All the functions of Requests that you’ve seen to this point provide a parameter called , which allows you to pass your credentials: The request succeeds if the credentials that you pass in the tuple to are valid. When you pass your credentials in a tuple to the parameter, Requests applies the credentials using HTTP’s Basic access authentication scheme under the hood. You may wonder where the string that Requests set as the value for your header comes from. In short, it’s a Base64-encoded string of the username and password with the prefix :\n• First, Requests combines the username and password that you provided, putting a colon in between them. So for the username and password , this becomes .\n• Then, Requests encodes this string in Base64 using . The encoding converts the string to .\n• Finally, Requests adds in front of this Base64 string. This is how the final value for the header becomes in the example shown above. HTTP Basic authentication isn’t very secure, because you can decode the username and password from the Base64 string. That’s why it’s important to always send these requests over HTTPS, which provides an additional layer of security by encrypting the entire HTTP request. You could make the same request by passing explicit Basic authentication credentials using : Though you don’t need to be explicit for Basic authentication, you may want to authenticate using another method. Requests provides other methods of authentication out of the box, such as and . A real-world example of an API that requires authentication is GitHub’s authenticated user API. This endpoint provides information about the authenticated user’s profile. If you try to make a request without credentials, then you’ll see that the status code is : If you don’t provide authentication credentials when accessing a service that requires them, then you’ll get an HTTP error code as a response. To make a request to GitHub’s authenticated user API, you first need to generate a personal access token with the read:user scope. Then you can pass this token as the second element in a tuple to : Like you learned previously, this approach passes the credentials to , which expects a username and a password and sends the credentials as a Base64-encoded string with the prefix : This works, but it’s not the right way to authenticate with a Bearer token—and using an empty string input for the superfluous username is awkward. With Requests, you can supply your own authentication mechanism to fix that. To try this out, create a subclass of and implement : \"\"\"Attach an API token to the Authorization header.\"\"\" Here, your custom mechanism receives a token, then includes that token in the header of your request, also setting the recommended prefix to the string. You can now use this custom token authentication to make your call to GitHub’s authenticated user API: Your custom created a well-formatted string for the header. You can now use this more intuitive way of interacting with a token-based authentication scheme such as the one that parts of GitHub’s API require. Note: While you could construct the authentication string outside of a custom authentication class and pass it directly with , this appoach is discouraged because it can lead to unexpected behavior. When you attempt to set your authentication credentials directly using , then Requests may internally overwrite your input. This can happen, for example, if you have a file that provides authentication credentials. Requests will attempt to get the credentials from the file if you don’t provide an authentication method using . Bad authentication mechanisms can lead to security vulnerabilities. Unless a service requires a custom authentication mechanism for some reason, you’ll always want to use a tried-and-true auth scheme like the built-in Basic authentication or OAuth, for example through Requests-OAuthlib. While you’re thinking about security, consider dealing with SSL certificates using Requests.\n\nAnytime the data that you’re trying to send or receive is sensitive, security is important. The way that you communicate with secure sites over HTTP is by establishing an encrypted connection using SSL, which means that verifying the target server’s SSL certificate is critical. The good news is that Requests does this for you by default. However, there are some cases where you might want to change this behavior. If you want to disable SSL certificate verification, then you pass to the parameter of the request function: InsecureRequestWarning: Unverified HTTPS request is being made to host Requests even warns you when you’re making an insecure request to help you keep your data safe! Note: Requests uses a package called to provide certificate authorities. This lets Requests know which authorities it can trust. Therefore, you should update frequently to keep your connections as secure as possible. Now that you know how to make all sorts of HTTP requests using Requests, authenticated or not, you may wonder about how you can make sure that your program works as quickly as possible. In the next section, you’ll learn about a few ways that you can improve performance with the help of Requests.\n\nWhen using Requests, especially in a production application environment, it’s important to consider performance implications. Features like timeout control, sessions, and retry limits can help you keep your application running smoothly. When you make an inline request to an external service, your system will need to wait for the response before moving on. If your application waits too long for that response, requests to your service could back up, your user experience could suffer, or your background jobs could hang. By default, Requests will wait indefinitely on the response, so you should almost always specify a timeout duration to prevent these issues from happening. To set the request’s timeout, use the parameter. can be an integer or float representing the number of seconds to wait on a response before timing out: In the first request, the request will time out after 1 second. In the second request, the request will time out after 3.05 seconds. You can also pass a tuple to with the following two elements:\n• Connect timeout: The time it allows for the client to establish a connection to the server\n• Read timeout: The time it’ll wait on a response once your client has established a connection Both of these elements should be numbers, and can be of type or : If the request establishes a connection within 3.05 seconds and receives data within 5 seconds of the connection being established, then the response will be returned as it was before. If the request times out, then the function will raise a exception: \"The request did not time out\" Your program can catch the exception and respond accordingly. Until now, you’ve been dealing with high-level APIs such as and . These functions are abstractions of what’s going on when you make your requests. They hide implementation details, such as how connections are managed, so that you don’t have to worry about them. Underneath those abstractions is a class called . If you need to fine-tune your control over how requests are being made or improve the performance of your requests, you may need to use a instance directly. Sessions are used to persist parameters across requests. For example, if you want to use the same authentication across multiple requests, then you can use a session: In this code example, you use a context manager to ensure that the session releases the resources when it doesn’t need them anymore. In line 7, you log in using your custom . You only need to log in once per session, and then you can make multiple authenticated requests. Requests will persist the credentials while the session exists. You then make two requests to the authenticated user API in lines 9 and 10 using instead of . The primary performance optimization of sessions comes in the form of persistent connections. When your app makes a connection to a server using a , it keeps that connection around in a connection pool. When your app wants to connect to the same server again, it’ll reuse a connection from the pool rather than establishing a new one. When a request fails, you may want your application to retry the same request. However, Requests won’t do this for you by default. To apply this functionality, you need to implement a custom transport adapter. Transport adapters let you define a set of configurations for each service that you’re interacting with. For example, say you want all requests to to retry two times before finally raising a . You’d build a transport adapter, set its parameter, and mount it to an existing : In this example, you’ve set up your session so that it’ll retry a maximum of two times when your request to GitHub’s API doesn’t work as expected. When you mount the —in this case, —to , then will adhere to its configuration for each request to . Note: While the implementation shown above works, you won’t see any effect of the retry behavior unless there’s something wrong with your network connection or GitHub’s servers. If you want to play around with code that builds on top of this example, and you’d like to inspect when the retries happen, then you’re in luck. You can download the materials of this tutorial and take a look at : Get Your Code: Click here to download the free sample code that shows you how to use Python’s Requests library. The code in this file improves on the example shown above by using the underlying to further customize the retry functionality. It also adds logging to display debugging output, which gives you a chance to monitor when Python attempted the retries. Requests comes packaged with intuitive implementations for timeouts, transport adapters, and sessions that can help you keep your code efficient and your application resilient."
    },
    {
        "link": "https://geeksforgeeks.org/python-requests-post-request-with-headers-and-body",
        "document": "HTTP headers let the client and the server pass additional information with an HTTP request or response. All the headers are case-insensitive, headers fields are separated by colon, key-value pairs in clear-text string format.\n\nRequests do not change its behavior at all based on which headers are specified. The headers are simply passed on into the final request. All header values must be a string, bytestring, or Unicode. While permitted, it’s advised to avoid passing Unicode header values. We can make requests with the headers we specify and by using the headers attribute we can tell the server with additional information about the request.\n\nHeaders can be Python Dictionaries like, { “Name of Header”: “Value of the Header” }\n\nThe Authentication Header tells the server who you are. Typically, we can send the authentication credentials through the Authorization header to make an authenticated request.\n\nPOST requests pass their data through the message body, The Payload will be set to the data parameter. data parameter takes a dictionary, a list of tuples, bytes, or a file-like object. You’ll want to adapt the data you send in the body of your request to the specified URL.\n\nGiven below are few implementations to help understand the concept better.\n\nExample 1: Sending requests with data as a payload\n\nExample 2: Sending requests with JSON data and headers\n\nHow Do You Send POST Request with Body in Python?\n\nTo send a POST request with a body in Python, you can use the library, which simplifies making HTTP requests. Here’s a basic example of how to send a POST request with data in the body: \n\n\n\n \n\n data = {'key': 'value'} # Dictionary that will be sent in the POST body \n\n \n\n\n\nHow to Pass Headers in Requests in Python?\n\nWhat is the Payload of a Request in Python?\n\nIn the context of HTTP and the library in Python, the payload of a request refers to the body of the request—it’s the data you send with your request. For POST requests, this is typically provided as a dictionary, JSON, or files, which will encode to the appropriate format based on the header.\n\nHow to Perform a POST Request Using JSON File as Body?\n\nTo perform a POST request using a JSON file as the body in Python, you need to load the JSON content into a Python dictionary and then pass it to the method with the parameter. Here’s how you can do it: \n\n\n\n\n\n \n\n # Assuming 'data.json' is in the same directory as your script \n\n \n\n \n\n\n\n \n\n The library automatically sets the to when you use the parameter. This simplifies the process of sending JSON data over HTTP POST requests."
    },
    {
        "link": "https://scrapfly.io/blog/python-requests-headers-guide",
        "document": "How to Find All URLs on a Domain\n\nLearn how to efficiently find all URLs on a domain using Python and web crawling. Guide on how to crawl entire domain to collect all website data"
    },
    {
        "link": "https://realpython.com/python-requests",
        "document": "The Requests library is the de facto standard for making HTTP requests in Python. It abstracts the complexities of making requests behind a beautiful, simple API so that you can focus on interacting with services and consuming data in your application.\n\nThroughout this tutorial, you’ll see some of the most useful features that Requests has to offer as well as ways to customize and optimize those features for different situations that you may come across. You’ll also learn how to use Requests in an efficient way as well as how to prevent requests to external services from slowing down your application.\n\nIn this tutorial, you’ll learn how to:\n• Make requests using the most common HTTP methods\n• Customize your requests’ headers and data using the query string and message body\n• Inspect data from your requests and responses\n• Configure your requests to help prevent your application from backing up or slowing down\n\nFor the best experience working through this tutorial, you should have basic general knowledge of HTTP. That said, you still may be able to follow along fine without it.\n\nIn the upcoming sections, you’ll see how you can install and use in your application. If you want to play with the code examples that you’ll see in this tutorial, as well as some additional ones, then you can download the code examples and work with them locally:\n\nEven though the Requests library is a common staple for many Python developers, it’s not included in Python’s standard library. There are good reasons for that decision, primarily that the library can continue to evolve more freely as a self-standing project. Note: Requests doesn’t support asynchronous HTTP requests directly. If you need async support in your program, you should try out AIOHTTP or HTTPX. The latter library is broadly compatible with Requests’ syntax. Because Requests is a third-party library, you need to install it before you can use it in your code. As a good practice, you should install external packages into a virtual environment, but you may choose to install into your global environment if you’re planning to use it across multiple projects. Whether you’re working in a virtual environment or not, you’ll need to install : Once has finished installing , you can use it in your application. Importing looks like this: Now that you’re all set up, it’s time to begin your journey through Requests. Your first goal will be learning how to make a request.\n\nA is a powerful object for inspecting the results of the request. Make that same request again, but this time store the return value in a variable so that you can get a closer look at its attributes and behaviors: In this example, you’ve captured the return value of , which is an instance of , and stored it in a variable called . You can now use to see a lot of information about the results of your request. The first bit of information that you can gather from is the status code. A status code informs you of the status of the request. For example, a status means that your request was successful, whereas a status means that the resource you were looking for wasn’t found. There are many other possible status codes as well to give you specific insights into what happened with your request. By accessing , you can see the status code that the server returned: returned , which means that your request was successful and the server responded with the data that you were requesting. Sometimes, you might want to use this information to make decisions in your code: With this logic, if the server returns a status code, then your program will print . If the result is a , then your program will print . Requests goes one step further in simplifying this process for you. If you use a instance in a conditional expression, then it’ll evaluate to if the status code was smaller than , and otherwise. Therefore, you can simplify the last example by rewriting the statement: In the code snippet above, you implicitly check whether the of is between and . If it’s not, then you raise an exception that includes the non-success status code in an f-string. Note: This truth value test is possible because is an overloaded method on . This means that the adapted default behavior of takes the status code into account when determining the truth value of the object. Keep in mind that this method is not verifying that the status code is equal to . The reason for this is that other status codes within the to range, such as and , are also considered successful in the sense that they provide some workable response. For example, the status code tells you that the response was successful, but there’s no content to return in the message body. So, make sure you use this convenient shorthand only if you want to know if the request was generally successful. Then, if necessary, you’ll need to handle the response appropriately based on the status code. Let’s say you don’t want to check the response’s status code in an statement. Instead, you want to use Request’s built-in capacities to raise an exception if the request was unsuccessful. You can do this using : If you invoke , then Requests will raise an for status codes between and . If the status code indicates a successful request, then the program will proceed without raising that exception. Now, you know a lot about how to deal with the status code of the response that you got back from the server. However, when you make a request, you rarely only care about the status code of the response. Usually, you want to see more. Next, you’ll see how to view the actual data that the server sent back in the body of the response. The response of a request often has some valuable information, known as a payload, in the message body. Using the attributes and methods of , you can view the payload in a variety of different formats. To see the response’s content in , you use : While gives you access to the raw bytes of the response payload, you’ll often want to convert them into a string using a character encoding such as UTF-8. will do that for you when you access : Because the decoding of to a requires an encoding scheme, Requests will try to guess the encoding based on the response’s headers if you don’t specify one. You can provide an explicit encoding by setting before accessing : If you take a look at the response, then you’ll see that it’s actually serialized JSON content. To get a dictionary, you could take the that you retrieved from and deserialize it using . However, a simpler way to accomplish this task is to use : The of the return value of is a dictionary, so you can access values in the object by key: You can do a lot with status codes and message bodies. But, if you need more information, like metadata about the response itself, then you’ll need to look at the response’s headers. The response headers can give you useful information, such as the content type of the response payload and a time limit on how long to cache the response. To view these headers, access : returns a dictionary-like object, allowing you to access header values by key. For example, to see the content type of the response payload, you can access : There’s something special about this dictionary-like headers object, though. The HTTP specification defines headers as case-insensitive, which means that you’re able to access these headers without worrying about their capitalization: Whether you use the key or , you’ll get the same value. Now that you’ve seen the most useful attributes and methods of in action, you already have a good overview of Requests’ basic usage. You can get content from the Internet and work with the response that you receive. But there’s more to the Internet than plain and straightforward URLs. In the next section, you’ll take a step back and see how your responses change when you customize your requests to account for query string parameters.\n\nAccording to the HTTP specification, , , and the less common requests pass their data through the message body rather than through parameters in the query string. Using Requests, you’ll pass the payload to the corresponding function’s parameter. takes a dictionary, a list of tuples, bytes, or a file-like object. You’ll want to adapt the data that send in the body of your request to the specific needs of the service that you’re interacting with. For example, if your request’s content type is , then you can send the form data as a dictionary: You can also send that same data as a list of tuples: If, however, you need to send JSON data, then you can use the parameter. When you pass JSON data via , Requests will serialize your data and add the correct header for you. Like you learned earlier, the httpbin service accepts test requests and responds with data about the requests. For instance, you can use it to inspect a basic request: You can see from the response that the server received your request data and headers as you sent them. Requests also provides this information to you in the form of a that you’ll inspect in more detail in the next section.\n\nAuthentication helps a service understand who you are. Typically, you provide your credentials to a server by passing data through the header or a custom header defined by the service. All the functions of Requests that you’ve seen to this point provide a parameter called , which allows you to pass your credentials: The request succeeds if the credentials that you pass in the tuple to are valid. When you pass your credentials in a tuple to the parameter, Requests applies the credentials using HTTP’s Basic access authentication scheme under the hood. You may wonder where the string that Requests set as the value for your header comes from. In short, it’s a Base64-encoded string of the username and password with the prefix :\n• First, Requests combines the username and password that you provided, putting a colon in between them. So for the username and password , this becomes .\n• Then, Requests encodes this string in Base64 using . The encoding converts the string to .\n• Finally, Requests adds in front of this Base64 string. This is how the final value for the header becomes in the example shown above. HTTP Basic authentication isn’t very secure, because you can decode the username and password from the Base64 string. That’s why it’s important to always send these requests over HTTPS, which provides an additional layer of security by encrypting the entire HTTP request. You could make the same request by passing explicit Basic authentication credentials using : Though you don’t need to be explicit for Basic authentication, you may want to authenticate using another method. Requests provides other methods of authentication out of the box, such as and . A real-world example of an API that requires authentication is GitHub’s authenticated user API. This endpoint provides information about the authenticated user’s profile. If you try to make a request without credentials, then you’ll see that the status code is : If you don’t provide authentication credentials when accessing a service that requires them, then you’ll get an HTTP error code as a response. To make a request to GitHub’s authenticated user API, you first need to generate a personal access token with the read:user scope. Then you can pass this token as the second element in a tuple to : Like you learned previously, this approach passes the credentials to , which expects a username and a password and sends the credentials as a Base64-encoded string with the prefix : This works, but it’s not the right way to authenticate with a Bearer token—and using an empty string input for the superfluous username is awkward. With Requests, you can supply your own authentication mechanism to fix that. To try this out, create a subclass of and implement : \"\"\"Attach an API token to the Authorization header.\"\"\" Here, your custom mechanism receives a token, then includes that token in the header of your request, also setting the recommended prefix to the string. You can now use this custom token authentication to make your call to GitHub’s authenticated user API: Your custom created a well-formatted string for the header. You can now use this more intuitive way of interacting with a token-based authentication scheme such as the one that parts of GitHub’s API require. Note: While you could construct the authentication string outside of a custom authentication class and pass it directly with , this appoach is discouraged because it can lead to unexpected behavior. When you attempt to set your authentication credentials directly using , then Requests may internally overwrite your input. This can happen, for example, if you have a file that provides authentication credentials. Requests will attempt to get the credentials from the file if you don’t provide an authentication method using . Bad authentication mechanisms can lead to security vulnerabilities. Unless a service requires a custom authentication mechanism for some reason, you’ll always want to use a tried-and-true auth scheme like the built-in Basic authentication or OAuth, for example through Requests-OAuthlib. While you’re thinking about security, consider dealing with SSL certificates using Requests.\n\nAnytime the data that you’re trying to send or receive is sensitive, security is important. The way that you communicate with secure sites over HTTP is by establishing an encrypted connection using SSL, which means that verifying the target server’s SSL certificate is critical. The good news is that Requests does this for you by default. However, there are some cases where you might want to change this behavior. If you want to disable SSL certificate verification, then you pass to the parameter of the request function: InsecureRequestWarning: Unverified HTTPS request is being made to host Requests even warns you when you’re making an insecure request to help you keep your data safe! Note: Requests uses a package called to provide certificate authorities. This lets Requests know which authorities it can trust. Therefore, you should update frequently to keep your connections as secure as possible. Now that you know how to make all sorts of HTTP requests using Requests, authenticated or not, you may wonder about how you can make sure that your program works as quickly as possible. In the next section, you’ll learn about a few ways that you can improve performance with the help of Requests.\n\nWhen using Requests, especially in a production application environment, it’s important to consider performance implications. Features like timeout control, sessions, and retry limits can help you keep your application running smoothly. When you make an inline request to an external service, your system will need to wait for the response before moving on. If your application waits too long for that response, requests to your service could back up, your user experience could suffer, or your background jobs could hang. By default, Requests will wait indefinitely on the response, so you should almost always specify a timeout duration to prevent these issues from happening. To set the request’s timeout, use the parameter. can be an integer or float representing the number of seconds to wait on a response before timing out: In the first request, the request will time out after 1 second. In the second request, the request will time out after 3.05 seconds. You can also pass a tuple to with the following two elements:\n• Connect timeout: The time it allows for the client to establish a connection to the server\n• Read timeout: The time it’ll wait on a response once your client has established a connection Both of these elements should be numbers, and can be of type or : If the request establishes a connection within 3.05 seconds and receives data within 5 seconds of the connection being established, then the response will be returned as it was before. If the request times out, then the function will raise a exception: \"The request did not time out\" Your program can catch the exception and respond accordingly. Until now, you’ve been dealing with high-level APIs such as and . These functions are abstractions of what’s going on when you make your requests. They hide implementation details, such as how connections are managed, so that you don’t have to worry about them. Underneath those abstractions is a class called . If you need to fine-tune your control over how requests are being made or improve the performance of your requests, you may need to use a instance directly. Sessions are used to persist parameters across requests. For example, if you want to use the same authentication across multiple requests, then you can use a session: In this code example, you use a context manager to ensure that the session releases the resources when it doesn’t need them anymore. In line 7, you log in using your custom . You only need to log in once per session, and then you can make multiple authenticated requests. Requests will persist the credentials while the session exists. You then make two requests to the authenticated user API in lines 9 and 10 using instead of . The primary performance optimization of sessions comes in the form of persistent connections. When your app makes a connection to a server using a , it keeps that connection around in a connection pool. When your app wants to connect to the same server again, it’ll reuse a connection from the pool rather than establishing a new one. When a request fails, you may want your application to retry the same request. However, Requests won’t do this for you by default. To apply this functionality, you need to implement a custom transport adapter. Transport adapters let you define a set of configurations for each service that you’re interacting with. For example, say you want all requests to to retry two times before finally raising a . You’d build a transport adapter, set its parameter, and mount it to an existing : In this example, you’ve set up your session so that it’ll retry a maximum of two times when your request to GitHub’s API doesn’t work as expected. When you mount the —in this case, —to , then will adhere to its configuration for each request to . Note: While the implementation shown above works, you won’t see any effect of the retry behavior unless there’s something wrong with your network connection or GitHub’s servers. If you want to play around with code that builds on top of this example, and you’d like to inspect when the retries happen, then you’re in luck. You can download the materials of this tutorial and take a look at : Get Your Code: Click here to download the free sample code that shows you how to use Python’s Requests library. The code in this file improves on the example shown above by using the underlying to further customize the retry functionality. It also adds logging to display debugging output, which gives you a chance to monitor when Python attempted the retries. Requests comes packaged with intuitive implementations for timeouts, transport adapters, and sessions that can help you keep your code efficient and your application resilient."
    },
    {
        "link": "https://stackoverflow.com/questions/32651362/how-do-i-set-the-content-type-for-post-requests-in-python-requests-library",
        "document": "Reach devs & technologists worldwide about your product, service or employer brand"
    },
    {
        "link": "https://stackoverflow.com/questions/8685790/adding-headers-to-requests-module",
        "document": "Earlier I used module to add a header in the request. Now I am trying the same thing with the module.\n\nThis is the python request module I am using: http://pypi.python.org/pypi/requests\n\nHow can I add a header to and . Say I have to add key in each request in the header."
    },
    {
        "link": "https://rahulbeniwal26119.medium.com/mastering-requests-in-python-unlock-the-power-of-http-with-headers-and-beyond-ada4dc35c3ef",
        "document": "Mastering Requests in Python: Unlock the Power of HTTP with Headers and Beyond 👇 World is evolving blah blah 😀 !!! but today everything is connected to internet either games, video calls, chatting and countless other things. In all these one things is common that is transfer of information or ability to interact with web which we developers also termed as data transfer. Python provides a powerful library requests that simplifies the process of sending and receiving HTTP Requests, consume APIs and retrieve valuable data. In this article we will dive into some core concept for requests, focusing on Headers and other fundamental aspect of HTTP. By the end of article you’ll have confidence to interact with web and third party integrations will look like ease to you.\n\nBrief Intro to HTTP and its Components HTTP stands for Hypertext Transfer Protocol which governs the communication between two clients or web servers. It is a set of rules or protocols for communication between two entities on the web. It defines the structure and format for request and response.\n• Client Server Architecture: HTTP follows client-server architecture where client usually web browsers sends requests to the server and get a response.\n• HTTP Verbs: HTTP verbs or methods which defines purpose of request. Most used methods are\n• GET -> Retrieves a resource from (such as web page) from server.\n• POST -> Submit data to server use to create new record. 3. Request Headers: HTTP requests contains headers that provide additional details regarding the request. Popular headers are\n• User-Agent: Info regarding the agent who is making the request. The server can customize the response according to User-Agent.\n• Content-Type: It informs the receipt how to interpret the data. Common values are “text/html” for HTML content, “application/json” for JSON data, and “image/jpeg” for JPEG images.\n• Accept: This header indicates the media types that the client can handle as a response.\n• Authorization: This header contains the authentication credentials for accessing protected resources. It can contain a token, username, and password to authenticate with the server.\n• Cache-Control: Cache-Control header provide directives regarding caching of the response. It indicates whether a response should be cached or not, and if should then for how long.\n• Cookie: Cookie header carries cookies sent by the server to the client and included in subsequent requests. Cookies can be used to remember user preferences and track user activity. 4. HTTP Status Codes: Once a server processed the request it contains an HTTP response which may contain response data or error message based on request input. HTTP status codes can be used to indicate the outcome of a request like 200 for success and 404 for not found. 5. URL: Uniform Resource Locator (URL) is a string of characters that specifies an address of a resource on the internet. It serves as a unique identifier for addressing resources such as images, videos, APIs, and more. Image Credit to MDN. Know more about HTTP\n\nTired of terms let’s start with some code. First, Install requests from PIP.. That’s all we need to start now either open a .py file or notebook or python shell. I will consume https://jsonplaceholder.typicode.com/posts/ for example below which contains data regarding posts. import requests\n\n\n\nurl = \"https://jsonplaceholder.typicode.com/posts/1\"\n\n\n\nresponse = requests.get(url)\n\n\n\nprint(response.status_code)\n\n# 200\n\n\n\nresponse.content\n\n# b'{\n\n \"userId\": 1,\n\n \"id\": 1,\n\n \"title\": \"sunt aut facere repellat provident occaecati excepturi optio reprehenderit\",\n\n \"body\": \"quia et suscipit\\\n\nsuscipit recusandae consequuntur expedita et cum\\\n\nreprehenderit molestiae ut ut quas totam\\\n\nnostrum rerum est autem sunt rem eveniet architecto\"\n\n}'\n\n\n\nresponse.text\n\n# '{\n\n \"userId\": 1,\n\n \"id\": 1,\n\n \"title\": \"sunt aut facere repellat provident occaecati excepturi optio reprehenderit\",\n\n \"body\": \"quia et suscipit\\\n\nsuscipit recusandae consequuntur expedita et cum\\\n\nreprehenderit molestiae ut ut quas totam\\\n\nnostrum rerum est autem sunt rem eveniet architecto\"\n\n}'\n\n\n\nresponse.json()\n\n# {'userId': 1,\n\n# 'id': 1,\n\n# 'title': 'sunt aut facere repellat provident occaecati excepturi optio reprehenderit',\n\n# 'body': 'quia et suscipit\n\nsuscipit recusandae consequuntur expedita et cum\n\nreprehenderit molestiae ut ut quas totam\n\nnostrum rerum est autem sunt rem eveniet architecto'\n\n# }\n\n\n\nresponse.headers\n\n# { \n\n# 'Date': 'Mon, 12 Jun 2023 01:55:12 GMT', \n\n# 'Content-Type': 'application/json; charset=utf-8', \n\n# 'Transfer-Encoding': 'chunked', \n\n# 'Connection': 'keep-alive', \n\n# 'X-Powered-By': 'Express', \n\n# 'X-Ratelimit-Limit': '1000', \n\n# 'X-Ratelimit-Remaining': '998', \n\n# 'X-Ratelimit-Reset': '1686132597', \n\n# 'Vary': 'Origin, Accept-Encoding', \n\n# 'Access-Control-Allow-Credentials': 'true', \n\n# 'Cache-Control': 'max-age=43200', \n\n# 'Pragma': 'no-cache', \n\n# 'Expires': '-1', \n\n# 'X-Content-Type-Options': 'nosniff', \n\n# 'Etag': 'W/\"124-yiKdLzqO5gfBrJFrcdJ8Yq0LGnU\"', \n\n# 'Via': '1.1 vegur', \n\n# 'CF-Cache-Status': 'HIT', \n\n# 'Age': '26065', \n\n# 'Report-To': '{\"endpoints\":[{\"url\":\"https:\\\\/\\\\/a.nel.cloudflare.com\\\\/report\\\\/v3?s=7Wo6Rf6EuOChHaVo%2BVqvm%2FtF%2BFMkvvL%2FeumplV4IIeMrEvdYkh9YjuPHliZUohzhNjPGtv2Ke9sM42p9BFZO1iSsX%2Foi88jOSrE6Hcffqth3N7FUx4cZsoU3X1zv9I9zJ7Ik9TvngUNXVHz%2Bt2E%3D\"}],\"group\":\"cf-nel\",\"max_age\":604800}', \n\n# 'NEL': '{\"success_fraction\":0,\"report_to\":\"cf-nel\",\"max_age\":604800}', \n\n# 'Server': 'cloudflare', \n\n# 'CF-RAY': '7d5e78612c9cf462-BOM', \n\n# 'Content-Encoding': 'gzip'\n\n# }\n\n\n\nresponse.request.headers\n\n# {\n\n# 'User-Agent': 'python-requests/2.31.0', \n\n# 'Accept-Encoding': 'gzip, deflate', \n\n# 'Accept': '*/*', \n\n# 'Connection': 'keep-alive'\n\n# } This URL contains the information regarding posts that belongs to a user with id 1. requests. get(url) will make a request and return a response. Let’s explore the properties of response. It is an integer that represents the HTTP status code for a request returned by the server. This returns the raw content of the response as bytes. It represents actual data received from the server, including any HTML, JSON, XML, or any other content that the server sent in the response body. This returns the response content as a Unicode string (decoded from response.text based on encoding in response headers.) This method parses the HTTP response into Python objects and it will work only if the response content is valid JSON. If content is not JSON serializable it will raise either exception. This is a dict that contains info about response headers. This attribute access to PreparedRequest object that was used to send requests. It can help us to examine the request that we sent. There are also other properties like elapsed, cookies, and others.\n\nLets create a new Post from user with userId 1. import requests\n\n\n\nurl = \"https://jsonplaceholder.typicode.com/posts/\"\n\n\n\nrequest_body = {\n\n \"title\": 'new_blog',\n\n 'body': 'new_blog is new blog',\n\n 'userId': 1\n\n}\n\n\n\nresponse = requests.post(url=url, json=request_body)\n\n\n\nprint(response.status_code, response.json()) \n\n\n\n# 201 {'title': 'new_blog', 'body': 'new_blog is new blog', 'userId': 1, 'id': 101} Here 201 is the standard code for creating new records on the server. response = requests.post(url=url, json=request_body)\n\n\n\n# can be replaced with \n\n\n\nresponse = requests.post(url, data=request_body)\n• json : It automatically sets Content-Type header to “application/json” and converts provided data into JSON string.\n• data : It allows us to send data in the form of a dictionary, bytes, or file-like object. We should set ‘Content-Type’ explicitly while using data. So the difference b/w both is how Content-Type is being set. Let update our blog post with id 101. import requests\n\n\n\nurl = \"https://jsonplaceholder.typicode.com/posts/1\"\n\n\n\nrequest_body = {\n\n \"id\": 101,\n\n \"title\": 'new_blog_upated',\n\n 'body': 'new_blog is new blog',\n\n 'userId': 1\n\n}\n\n\n\nresponse = requests.put(url=url, json=request_body)\n\nif response.status_code not in [201, 200]:\n\n print(response.text)\n\nprint(response.status_code, response.json())\n\n\n\n# 200 {'id': 1, 'title': 'new_blog_upated', 'body': 'new_blog is new blog', 'userId': 1} posts/1 — It is common practice to give an id of the resource which we are updating in URL but here this 1 represents the id of the user to find out which user’s blog need to be updated. if response.status_code not in [201, 200]:\n\n print(response.text) This code ensures that we only convert the server response to JSON only when we get successful status because there are chances to get Non-JSON serializable data like text if the status is in the 5XX category. One last thing in this section requests.post(*args) -> requests.request(\"post\", *args)\n\nrequest.get(*args) -> requests.request(\"get\", *args)\n\n\n\nand so on for all methods\n\nThese are the alternative way to making request but has more flexibility. Important Note: To consume any API always go through their document to know how to use them. https://jsonplaceholder.typicode.com/guide/ is the one for APIs used in this blog.\n\nUse of headers in HTTP requests. Consider the following scenarios\n• The server needs us to send data in XML.\n• The server needs to authenticate us with a token that we got after successful login or signup.\n• The server also need to ensure that we are trusted so we need to include API Key. Here Headers will help us to include below secure information. Above fabricated sample code show how we can use headers while sending requests. HTTP status codes are a 3-digit number that is returned by the server. These status codes indicate result status of a request. These are grouped into 5 categories based on their first digit.\n• 100 Continue: The server has received the initial part of the request and is willing to proceed with it.\n• 200 OK: Request is a success and the server returns the requested content.\n• 201 Created: New Resource has been created on the server.\n• 204 No Content: The server processed the request successfully but there is no content to return.\n• 301 Moved Permanently: The requested resource has been permanently moved to a new location.\n• 302 Found: The requested resource has been temporarily moved to a different location.\n• 304 Not Modified: The requested resource has not been modified since the last request.\n• 400 Bad Requested: Server cannot process the request either due to wrong syntax, missing required value, or wrong value provided in the request.\n• 401 Unauthorized: The request requires user authentication. The client needs to send a valid credential. Credential can be either a token, password, or api-key.\n• 403 Forbidden: The server understands the request but the client does not have permission to access this.\n• 404 Not Found: The resource that the client tries to reach is not on the server.\n• 500 Internal Server Error: The server encountered an unexpected condition or exception that occurred on the server side.\n• 502 Bad Gateway: The server, acting as gateway or proxy, received an invalid response from the upstream or main server. This status occurs when deployment is not done correctly or deployment is in progress. (Fix me in the comments if you think differently)\n• 503 Service Unavailable: The server is temporarily unavailable, usually due to maintenance or overload.\n\nErrors are possible while trying to reach a server or undesired status codes are also possible like 4XX. So let’s look how we can handle these so our code will work smoothly. import requests\n\n\n\nurl = \"https://jsonplaceholder.typicode.com/posts/\"\n\n\n\nrequest_body = {\n\n \"title\": 'new_blog',\n\n 'body': 'new_blog is new blog',\n\n 'userId': 1\n\n}\n\n\n\ntry:\n\n response = requests.put(url=url, json=request_body)\n\n response.raise_for_status()\n\nexcept requests.exceptions.HTTPError as err:\n\n print(f\"Error = {err}\")\n\nexcept requests.exceptions.RequestException as err:\n\n print(f\"Connection error: {err}\")\n\nelse:\n\n print(response.json())\n\n\n\n# status_code = 404\n\n# Error = 404 Client Error: Not Found for url: https://jsonplaceholder.typicode.com/posts/\n• raise_for_status : It is being called if response indicates an error (e.g., 404 Not Found, 500 Internal Server Error) then it will raise HTTPError.\n• RequestException : This exception handles request-related errors like connection errors or timeouts."
    }
]