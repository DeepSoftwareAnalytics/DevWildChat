[
    {
        "link": "https://elastic.co/guide/en/elasticsearch/reference/current/search-search.html",
        "document": "Returns search hits that match the query defined in the request.\n• If the Elasticsearch security features are enabled, you must have the index privilege for the target data stream, index, or alias. For cross-cluster search, see Configure privileges for cross-cluster search. To search a point in time (PIT) for an alias, you must have the index privilege for the alias’s data streams or indices.\n\nSeveral options for this API can be specified using a query parameter or a request body parameter. If both parameters are specified, only the query parameter is used. (Optional, Boolean) If , the request returns an error if any wildcard expression, index alias, or value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting returns an error if an index starts with but no index starts with . (Optional, Boolean) If , returns partial results if there are shard request timeouts or shard failures. If , returns an error with no partial results. Defaults to . To override the default for this field, set the cluster setting to . (Optional, string) Analyzer to use for the query string. This parameter can only be used when the query string parameter is specified. (Optional, Boolean) If , wildcard and prefix queries are analyzed. Defaults to . This parameter can only be used when the query string parameter is specified. (Optional, integer) The number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large. Defaults to . (Optional, Boolean) If , network round-trips between the coordinating node and the remote clusters are minimized when executing cross-cluster search (CCS) requests. See How cross-cluster search handles network delays. Defaults to . (Optional, string) The default operator for query string query: AND or OR. Defaults to . This parameter can only be used when the query string parameter is specified. (Optional, string) Field to use as default where no field prefix is given in the query string. This parameter can only be used when the query string parameter is specified. (Optional, string) A comma-separated list of fields to return as the docvalue representation of a field for each hit. See Doc value fields. (Optional, string) Type of index that wildcard patterns can match. If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams. Supports comma-separated values, such as . Valid values are: Match any data stream or index, including hidden ones. Match closed, non-hidden indices. Also matches any non-hidden data stream. Data streams cannot be closed. Match hidden data streams and hidden indices. Must be combined with , , or both. (Optional, Boolean) If , returns detailed information about score computation as part of a hit. Defaults to . (Optional, integer) Starting document offset. Needs to be non-negative and defaults to . By default, you cannot page through more than 10,000 hits using the and parameters. To page through more hits, use the parameter. (Optional, Boolean) If , concrete, expanded or aliased indices are ignored when frozen. Defaults to . (Optional, Boolean) If , includes the score contribution from any named queries. This functionality reruns each named query on every hit in a search response. Typically, this adds a small overhead to a request. However, using computationally expensive named queries on a large number of hits may add significant overhead. Defaults to . (Optional, Boolean) If , the request returns an error if it targets a missing or closed index. Defaults to . (Optional, Boolean) If , format-based query failures (such as providing text to a numeric field) in the query string will be ignored. Defaults to . This parameter can only be used when the query string parameter is specified. (Optional, integer) Defines the number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests. Defaults to . (Optional, integer) Defines a threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint. When unspecified, the pre-filter phase is executed if any of these conditions is met:\n• The request targets more than shards.\n• The request targets one or more read-only index.\n• The primary sort of the query targets an indexed field. (Optional, string) Nodes and shards used for the search. By default, Elasticsearch selects from eligible nodes and shards using adaptive replica selection, accounting for allocation awareness. Run the search only on shards on the local node. If possible, run the search on shards on the local node. If not, select shards using the default method. Run the search on only the specified nodes IDs. If suitable shards exist on more than one selected node, use shards on those nodes using the default method. If none of the specified nodes are available, select shards from any available node using the default method. If possible, run the search on the specified nodes IDs. If not, select shards using the default method. Run the search only on the specified shards. You can combine this value with other values. However, the value must come first. For example: . Any string that does not start with . If the cluster state and selected shards do not change, searches using the same value are routed to the same shards in the same order. You can use the parameter to run a query parameter search. Query parameter searches do not support the full Elasticsearch Query DSL but are handy for testing. The parameter overrides the parameter in the request body. If both parameters are specified, documents matching the request body parameter are not returned. (Optional, Boolean) If , the caching of search results is enabled for requests where is . See The shard request cache. Defaults to index level settings. (Optional, Boolean) Indicates whether hits.total should be rendered as an integer or an object in the rest search response. Defaults to . (Optional, string) Custom value used to route operations to a specific shard. (Optional, time value) Period to retain the search context for scrolling. See Scroll search results. By default, this value cannot exceed (24 hours). You can change this limit using the cluster-level setting. (Optional, string) How distributed term frequencies are calculated for relevance scoring. (Default) Distributed term frequencies are calculated locally for each shard running the search. We recommend this option for faster searches with potentially less accurate scoring. Distributed term frequencies are calculated globally, using information gathered from all shards running the search. While this option increases the accuracy of scoring, it adds a round-trip to each shard, which can result in slower searches. (Optional, Boolean) If , returns sequence number and primary term of the last modification of each hit. See Optimistic concurrency control. (Optional, integer) Defines the number of hits to return. Defaults to . By default, you cannot page through more than 10,000 hits using the and parameters. To page through more hits, use the parameter. (Optional) Indicates which source fields are returned for matching documents. These fields are returned in the property of the search response. Defaults to . See source filtering. (Boolean) The document source is not returned. (string) Comma-separated list of source fields to return. Wildcard ( ) patterns are supported. (Optional, string) A comma-separated list of source fields to exclude from the response. You can also use this parameter to exclude fields from the subset specified in query parameter. If the parameter is , this parameter is ignored. (Optional, string) A comma-separated list of source fields to include in the response. If this parameter is specified, only these source fields are returned. You can exclude fields from this subset using the query parameter. If the parameter is , this parameter is ignored. (Optional, string) Specific of the request for logging and statistical purposes. (Optional, string) A comma-separated list of stored fields to return as part of a hit. If no fields are specified, no stored fields are included in the response. See Stored fields. If this field is specified, the parameter defaults to . You can pass to return both source fields and stored fields in the search response. (Optional, string) Specifies which field to use for suggestions. (Optional, string) Specifies the suggest mode. Defaults to . Available options: This parameter can only be used when the and query string parameters are specified. This parameter can only be used when the and query string parameters are specified. (Optional, string) The source text for which the suggestions should be returned. This parameter can only be used when the query string parameter is specified. (Optional, integer) Maximum number of documents to collect for each shard. If a query reaches this limit, Elasticsearch terminates the query early. Elasticsearch collects documents before sorting. Use with caution. Elasticsearch applies this parameter to each shard handling the request. When possible, let Elasticsearch perform early termination automatically. Avoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers. Defaults to , which does not terminate query execution early. (Optional, time units) Specifies the period of time to wait for a response from each shard. If no response is received before the timeout expires, the request fails and returns an error. Defaults to no timeout. (Optional, Boolean) If , calculate and return document scores, even if the scores are not used for sorting. Defaults to . (Optional, integer or Boolean) Number of hits matching the query to count accurately. Defaults to . If , the exact number of hits is returned at the cost of some performance. If , the response does not include the total number of hits matching the query. (Optional, Boolean) If , aggregation and suggester names are prefixed by their respective types in the response. Defaults to . (Optional, Boolean) If , returns document version as part of a hit. Defaults to .\n\n(string) Identifier for the search and its search context. You can use this scroll ID with the scroll API to retrieve the next batch of search results for the request. See Scroll search results. This parameter is only returned if the query parameter is specified in the request. (integer) Milliseconds it took Elasticsearch to execute the request. This value is calculated by measuring the time elapsed between receipt of a request on the coordinating node and the time at which the coordinating node is ready to send the response.\n• Communication time between the coordinating node and data nodes\n• Time the request spends in the thread pool, queued for execution Took time does not include:\n• Time needed to send the request to Elasticsearch\n• Time needed to send the response to a client (Boolean) If , the request timed out before completion; returned results may be partial or empty. (object) Contains a count of shards used for the request. (integer) Number of shards that executed the request successfully. (integer) Number of shards that skipped the request because a lightweight check helped realize that no documents could possibly match on this shard. This typically happens when a search request includes a range filter and the shard only has values that fall outside of that range. (integer) Number of shards that failed to execute the request. Note that shards that are not allocated will be considered neither successful nor failed. Having less than is thus an indication that some of the shards were not allocated. (object) Metadata about the number of matching documents. (string) Indicates whether the number of matching documents in the parameter is accurate or a lower bound. This value is for requests that do not sort by . (string) Name of the index containing the returned document. (string) Unique identifier for the returned document. This ID is only unique within the returned index. (float) Positive 32-bit floating point number used to determine the relevance of the returned document. (object) Original JSON body passed for the document at index time. You can use the parameter to exclude this property from the response or specify which source fields to return. (object) Contains field values for the documents. These fields must be specified in the request using one or more of the following request parameters: This property is returned only if one or more of these parameters are set. (array) Key is the field name. Value is the value for the field."
    },
    {
        "link": "https://elastic.co/guide/en/elasticsearch/reference/current/search.html",
        "document": "Search APIs are used to search and aggregate data stored in Elasticsearch indices and data streams. For an overview and related tutorials, see The search API.\n\nMost search APIs support multi-target syntax, with the exception of the explain API."
    },
    {
        "link": "https://elasticsearch-py.readthedocs.io/en/2.1.0/api.html",
        "document": "All the API calls map the raw REST api as closely as possible, including the distinction between required and optional arguments to the calls. This means that the code makes distinction between positional and keyword arguments; we, however, recommend that people use keyword arguments for all calls for consistency and safety.\n\nSome parameters are added by the client itself and can be used in all API calls. An API call is considered successful (and will return a response) if elasticsearch returns a 2XX response. Otherwise an instance of (or a more specific subclass) will be raised. You can see other exception and error states in Exceptions. If you do not wish an exception to be raised you can always pass in an parameter with either a single status code that should be ignored or a list of them: # ignore 400 cause by IndexAlreadyExistsException when creating an index Global timeout can be set when constructing the client (see ‘s parameter) or on a per-request basis using (float value in seconds) as part of any API call, this value will get passed to the method of the connection class: # only wait for 1 second, regardless of the client's default Some API calls also accept a parameter that is passed to Elasticsearch server. This timeout is internal and doesn’t guarantee that the request will end in the specified time.\n\nElasticsearch low-level client. Provides a straightforward mapping from Python to ES REST endpoints. The instance has attributes , , , and that provide access to instances of , , , and respectively. This is the preferred (and only supported) way to get access to those classes and their methods. You can specify your own connection class which should be used by providing the parameter: # create connection to localhost using the ThriftConnection If you want to turn on Sniffing you have several options (described in ): # create connection that will automatically inspect the cluster to get # the list of active nodes. Start with nodes running on 'esnode1' and # sniff before doing anything # and also every 60 seconds Different hosts can have different parameters, use a dictionary per node to specify those: # connect to localhost directly and another node using SSL on port 443 # and an url_prefix. Note that ``port`` needs to be an int. If using SSL, there are several parameters that control how we deal with certificates (see for detailed description of the options): # make sure we verify SSL certificates (off by default) Alternatively you can use RFC-1738 formatted URLs, as long as they are not in conflict with other options:\n• hosts – list of nodes we should connect to. Node should be a dictionary ({“host”: “localhost”, “port”: 9200}), the entire dictionary will be passed to the class as kwargs, or a string in the format of which will be translated to a dictionary automatically. If no value is given the class defaults will be used.\n• kwargs – any additional arguments will be passed on to the class and, subsequently, to the instances. See the helper function for a more friendly API. http://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html\n• body – The operation definition and data (action-data pairs), separated by newlines\n• index – Default index for items which don’t provide one\n• doc_type – Default document type for items which don’t provide one\n• consistency – Explicit write consistency setting for the operation, valid choices are: ‘one’, ‘quorum’, ‘all’\n• fields – Default comma-separated list of fields to return in the response for updates\n• refresh – Refresh the index after performing the operation Clear the scroll request created by specifying the scroll parameter to search. http://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-scroll.html\n• body – A comma-separated list of scroll IDs to clear if none was specified via the scroll_id parameter Execute a query and get the number of matches for that query. http://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html\n• index – A comma-separated list of indices to restrict the results\n• doc_type – A comma-separated list of types to restrict the results\n• body – A query to restrict the results specified with the Query DSL (optional)\n• allow_no_indices – Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes string or when no indices have been specified)\n• analyze_wildcard – Specify whether wildcard and prefix queries should be analyzed (default: false)\n• analyzer – The analyzer to use for the query string\n• default_operator – The default operator for query string query (AND or OR), default ‘OR’, valid choices are: ‘AND’, ‘OR’\n• df – The field to use as default where no field prefix is given in the query string\n• expand_wildcards – Whether to expand wildcard expression to concrete indices that are open, closed or both., default ‘open’, valid choices are: ‘open’, ‘closed’, ‘none’, ‘all’\n• ignore_unavailable – Whether specified concrete indices should be ignored when unavailable (missing or closed)\n• lenient – Specify whether format-based query failures (such as providing text to a numeric field) should be ignored\n• lowercase_expanded_terms – Specify whether query terms should be lowercased\n• min_score – Include only documents with a specific value in the result\n• preference – Specify the node or shard the operation should be performed on (default: random) The percolator allows to register queries against an index, and then send percolate requests which include a doc, and getting back the queries that match on that doc out of the set of registered queries. http://www.elastic.co/guide/en/elasticsearch/reference/current/search-percolate.html\n• index – The index of the document being count percolated.\n• doc_type – The type of the document being count percolated.\n• id – Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.\n• body – The count percolator request definition using the percolate DSL\n• allow_no_indices – Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes string or when no indices have been specified)\n• expand_wildcards – Whether to expand wildcard expression to concrete indices that are open, closed or both., default ‘open’, valid choices are: ‘open’, ‘closed’, ‘none’, ‘all’\n• ignore_unavailable – Whether specified concrete indices should be ignored when unavailable (missing or closed)\n• percolate_index – The index to count percolate the document into. Defaults to index.\n• percolate_type – The type to count percolate document into. Defaults to type.\n• preference – Specify the node or shard the operation should be performed on (default: random) Adds a typed JSON document in a specific index, making it searchable. Behind the scenes this method calls index(..., op_type=’create’) http://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.html\n• index – The name of the index\n• doc_type – The type of the document\n• consistency – Explicit write consistency setting for the operation, valid choices are: ‘one’, ‘quorum’, ‘all’\n• refresh – Refresh the index after performing the operation Delete a typed JSON document from a specific index based on its id. http://www.elastic.co/guide/en/elasticsearch/reference/current/docs-delete.html\n• index – The name of the index\n• doc_type – The type of the document\n• consistency – Specific write consistency setting for the operation, valid choices are: ‘one’, ‘quorum’, ‘all’\n• refresh – Refresh the index after performing the operation Returns a boolean indicating whether or not given document exists in Elasticsearch. http://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html\n• index – The name of the index\n• doc_type – The type of the document (use to fetch the first document matching the ID across all types)\n• parent – The ID of the parent document\n• preference – Specify the node or shard the operation should be performed on (default: random)\n• realtime – Specify whether to perform the operation in realtime or search mode\n• refresh – Refresh the shard containing the document before performing the operation The explain api computes a score explanation for a query and a specific document. This can give useful feedback whether a document matches or didn’t match a specific query. http://www.elastic.co/guide/en/elasticsearch/reference/current/search-explain.html\n• index – The name of the index\n• doc_type – The type of the document\n• body – The query definition using the Query DSL\n• _source – True or false to return the _source field or not, or a list of fields to return\n• _source_exclude – A list of fields to exclude from the returned _source field\n• _source_include – A list of fields to extract and return from the _source field\n• analyze_wildcard – Specify whether wildcards and prefix queries in the query string query should be analyzed (default: false)\n• analyzer – The analyzer for the query string query\n• default_operator – The default operator for query string query (AND or OR), default ‘OR’, valid choices are: ‘AND’, ‘OR’\n• df – The default field for query string query (default: _all)\n• fields – A comma-separated list of fields to return in the response\n• lenient – Specify whether format-based query failures (such as providing text to a numeric field) should be ignored\n• lowercase_expanded_terms – Specify whether query terms should be lowercased\n• parent – The ID of the parent document\n• preference – Specify the node or shard the operation should be performed on (default: random) The field stats api allows one to find statistical properties of a field without executing a search, but looking up measurements that are natively available in the Lucene index. http://www.elastic.co/guide/en/elasticsearch/reference/current/search-field-stats.html\n• index – A comma-separated list of index names; use or empty string to perform the operation on all indices\n• body – Field json objects containing the name and optionally a range to filter out indices result, that have results outside the defined bounds\n• allow_no_indices – Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes string or when no indices have been specified)\n• expand_wildcards – Whether to expand wildcard expression to concrete indices that are open, closed or both., default ‘open’, valid choices are: ‘open’, ‘closed’, ‘none’, ‘all’\n• fields – A comma-separated list of fields for to get field statistics for (min value, max value, and more)\n• ignore_unavailable – Whether specified concrete indices should be ignored when unavailable (missing or closed)\n• level – Defines if field stats should be returned on a per index level or on a cluster wide level, default ‘cluster’, valid choices are: ‘indices’, ‘cluster’ Get a typed JSON document from the index based on its id. http://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html\n• index – The name of the index\n• doc_type – The type of the document (use to fetch the first document matching the ID across all types)\n• _source – True or false to return the _source field or not, or a list of fields to return\n• _source_exclude – A list of fields to exclude from the returned _source field\n• _source_include – A list of fields to extract and return from the _source field\n• fields – A comma-separated list of fields to return in the response\n• parent – The ID of the parent document\n• preference – Specify the node or shard the operation should be performed on (default: random)\n• realtime – Specify whether to perform the operation in realtime or search mode\n• refresh – Refresh the shard containing the document before performing the operation Get the source of a document by it’s index, type and id. http://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html\n• index – The name of the index\n• doc_type – The type of the document; use to fetch the first document matching the ID across all types\n• _source – True or false to return the _source field or not, or a list of fields to return\n• _source_exclude – A list of fields to exclude from the returned _source field\n• _source_include – A list of fields to extract and return from the _source field\n• parent – The ID of the parent document\n• preference – Specify the node or shard the operation should be performed on (default: random)\n• realtime – Specify whether to perform the operation in realtime or search mode\n• refresh – Refresh the shard containing the document before performing the operation Adds or updates a typed JSON document in a specific index, making it searchable. http://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.html\n• index – The name of the index\n• doc_type – The type of the document\n• consistency – Explicit write consistency setting for the operation, valid choices are: ‘one’, ‘quorum’, ‘all’\n• refresh – Refresh the index after performing the operation Get the basic info from the current cluster. http://www.elastic.co/guide/ Get multiple documents based on an index, type (optional) and ids. http://www.elastic.co/guide/en/elasticsearch/reference/current/docs-multi-get.html\n• body – Document identifiers; can be either (containing full document information) or (when index and type is provided in the URL.\n• index – The name of the index\n• doc_type – The type of the document\n• _source – True or false to return the _source field or not, or a list of fields to return\n• _source_exclude – A list of fields to exclude from the returned _source field\n• _source_include – A list of fields to extract and return from the _source field\n• fields – A comma-separated list of fields to return in the response\n• preference – Specify the node or shard the operation should be performed on (default: random)\n• realtime – Specify whether to perform the operation in realtime or search mode\n• refresh – Refresh the shard containing the document before performing the operation The percolator allows to register queries against an index, and then send percolate requests which include a doc, and getting back the queries that match on that doc out of the set of registered queries. http://www.elastic.co/guide/en/elasticsearch/reference/current/search-percolate.html\n• index – The index of the document being count percolated to use as default\n• doc_type – The type of the document being percolated to use as default.\n• allow_no_indices – Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes string or when no indices have been specified)\n• expand_wildcards – Whether to expand wildcard expression to concrete indices that are open, closed or both., default ‘open’, valid choices are: ‘open’, ‘closed’, ‘none’, ‘all’\n• ignore_unavailable – Whether specified concrete indices should be ignored when unavailable (missing or closed) Execute several search requests within the same API. http://www.elastic.co/guide/en/elasticsearch/reference/current/search-multi-search.html\n• index – A comma-separated list of index names to use as default\n• doc_type – A comma-separated list of document types to use as default Multi termvectors API allows to get multiple termvectors based on an index, type and id. http://www.elastic.co/guide/en/elasticsearch/reference/current/docs-multi-termvectors.html\n• index – The index in which the document resides.\n• doc_type – The type of the document.\n• body – Define ids, documents, parameters or a list of parameters per document here. You must at least provide a list of document ids. See documentation.\n• field_statistics – Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned. Applies to all returned documents unless otherwise specified in body “params” or “docs”., default True\n• fields – A comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body “params” or “docs”.\n• ids – A comma-separated list of documents ids. You must define ids as parameter or set “ids” or “docs” in the request body\n• offsets – Specifies if term offsets should be returned. Applies to all returned documents unless otherwise specified in body “params” or “docs”., default True\n• parent – Parent id of documents. Applies to all returned documents unless otherwise specified in body “params” or “docs”.\n• payloads – Specifies if term payloads should be returned. Applies to all returned documents unless otherwise specified in body “params” or “docs”., default True\n• positions – Specifies if term positions should be returned. Applies to all returned documents unless otherwise specified in body “params” or “docs”., default True\n• preference – Specify the node or shard the operation should be performed on (default: random) .Applies to all returned documents unless otherwise specified in body “params” or “docs”.\n• realtime – Specifies if requests are real-time as opposed to near- real-time (default: true).\n• routing – Specific routing value. Applies to all returned documents unless otherwise specified in body “params” or “docs”.\n• term_statistics – Specifies if total term frequency and document frequency should be returned. Applies to all returned documents unless otherwise specified in body “params” or “docs”., default False The percolator allows to register queries against an index, and then send percolate requests which include a doc, and getting back the queries that match on that doc out of the set of registered queries. http://www.elastic.co/guide/en/elasticsearch/reference/current/search-percolate.html\n• index – The index of the document being percolated.\n• doc_type – The type of the document being percolated.\n• id – Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.\n• body – The percolator request definition using the percolate DSL\n• allow_no_indices – Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes string or when no indices have been specified)\n• expand_wildcards – Whether to expand wildcard expression to concrete indices that are open, closed or both., default ‘open’, valid choices are: ‘open’, ‘closed’, ‘none’, ‘all’\n• ignore_unavailable – Whether specified concrete indices should be ignored when unavailable (missing or closed)\n• percolate_format – Return an array of matching query IDs instead of objects, valid choices are: ‘ids’\n• percolate_index – The index to percolate the document into. Defaults to index.\n• percolate_preference – Which shard to prefer when executing the percolate request.\n• percolate_routing – The routing value to use when percolating the existing document.\n• percolate_type – The type to percolate document into. Defaults to type.\n• preference – Specify the node or shard the operation should be performed on (default: random) Returns True if the cluster is up, False otherwise. http://www.elastic.co/guide/ Create a script in given language with specified ID. http://www.elastic.co/guide/en/elasticsearch/reference/current/modules-scripting.html\n• id – The id of the stored search template\n• body – The search definition template and its params Scroll a search request created by specifying the scroll parameter. http://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-scroll.html\n• body – The scroll ID if not passed by URL or query parameter.\n• scroll – Specify how long a consistent view of the index should be maintained for scrolled search Execute a search query and get back search hits that match the query. http://www.elastic.co/guide/en/elasticsearch/reference/current/search-search.html\n• index – A comma-separated list of index names to search; use or empty string to perform the operation on all indices\n• doc_type – A comma-separated list of document types to search; leave empty to perform the operation on all types\n• body – The search definition using the Query DSL\n• _source – True or false to return the _source field or not, or a list of fields to return\n• _source_exclude – A list of fields to exclude from the returned _source field\n• _source_include – A list of fields to extract and return from the _source field\n• allow_no_indices – Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes string or when no indices have been specified)\n• analyze_wildcard – Specify whether wildcard and prefix queries should be analyzed (default: false)\n• analyzer – The analyzer to use for the query string\n• default_operator – The default operator for query string query (AND or OR), default ‘OR’, valid choices are: ‘AND’, ‘OR’\n• df – The field to use as default where no field prefix is given in the query string\n• expand_wildcards – Whether to expand wildcard expression to concrete indices that are open, closed or both., default ‘open’, valid choices are: ‘open’, ‘closed’, ‘none’, ‘all’\n• explain – Specify whether to return detailed information about score computation as part of a hit\n• fielddata_fields – A comma-separated list of fields to return as the field data representation of a field for each hit\n• fields – A comma-separated list of fields to return as part of a hit\n• ignore_unavailable – Whether specified concrete indices should be ignored when unavailable (missing or closed)\n• lenient – Specify whether format-based query failures (such as providing text to a numeric field) should be ignored\n• lowercase_expanded_terms – Specify whether query terms should be lowercased\n• preference – Specify the node or shard the operation should be performed on (default: random)\n• request_cache – Specify if request cache should be used for this request or not, defaults to index level setting\n• scroll – Specify how long a consistent view of the index should be maintained for scrolled search\n• stats – Specific ‘tag’ of the request for logging and statistical purposes\n• suggest_field – Specify which field to use for suggestions\n• suggest_size – How many suggestions to return in response\n• suggest_text – The source text for which the suggestions should be returned\n• terminate_after – The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.\n• track_scores – Whether to calculate and return scores even if they are not used for sorting\n• version – Specify whether to return document version as part of a hit The exists API allows to easily determine if any matching documents exist for a provided query. http://www.elastic.co/guide/en/elasticsearch/reference/current/search-exists.html\n• index – A comma-separated list of indices to restrict the results\n• doc_type – A comma-separated list of types to restrict the results\n• body – A query to restrict the results specified with the Query DSL (optional)\n• allow_no_indices – Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes string or when no indices have been specified)\n• analyze_wildcard – Specify whether wildcard and prefix queries should be analyzed (default: false)\n• analyzer – The analyzer to use for the query string\n• default_operator – The default operator for query string query (AND or OR), default ‘OR’, valid choices are: ‘AND’, ‘OR’\n• df – The field to use as default where no field prefix is given in the query string\n• expand_wildcards – Whether to expand wildcard expression to concrete indices that are open, closed or both., default ‘open’, valid choices are: ‘open’, ‘closed’, ‘none’, ‘all’\n• ignore_unavailable – Whether specified concrete indices should be ignored when unavailable (missing or closed)\n• lenient – Specify whether format-based query failures (such as providing text to a numeric field) should be ignored\n• lowercase_expanded_terms – Specify whether query terms should be lowercased\n• min_score – Include only documents with a specific value in the result\n• preference – Specify the node or shard the operation should be performed on (default: random) The search shards api returns the indices and shards that a search request would be executed against. This can give useful feedback for working out issues or planning optimizations with routing and shard preferences. http://www.elastic.co/guide/en/elasticsearch/reference/current/search-shards.html\n• index – A comma-separated list of index names to search; use or empty string to perform the operation on all indices\n• doc_type – A comma-separated list of document types to search; leave empty to perform the operation on all types\n• allow_no_indices – Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes string or when no indices have been specified)\n• expand_wildcards – Whether to expand wildcard expression to concrete indices that are open, closed or both., default ‘open’, valid choices are: ‘open’, ‘closed’, ‘none’, ‘all’\n• ignore_unavailable – Whether specified concrete indices should be ignored when unavailable (missing or closed)\n• local – Return local information, do not retrieve the state from master node (default: false)\n• preference – Specify the node or shard the operation should be performed on (default: random) A query that accepts a query template and a map of key/value pairs to fill in template parameters. http://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html\n• index – A comma-separated list of index names to search; use or empty string to perform the operation on all indices\n• doc_type – A comma-separated list of document types to search; leave empty to perform the operation on all types\n• body – The search definition template and its params\n• allow_no_indices – Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes string or when no indices have been specified)\n• expand_wildcards – Whether to expand wildcard expression to concrete indices that are open, closed or both., default ‘open’, valid choices are: ‘open’, ‘closed’, ‘none’, ‘all’\n• ignore_unavailable – Whether specified concrete indices should be ignored when unavailable (missing or closed)\n• preference – Specify the node or shard the operation should be performed on (default: random)\n• scroll – Specify how long a consistent view of the index should be maintained for scrolled search The suggest feature suggests similar looking terms based on a provided text by using a suggester. http://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters.html\n• index – A comma-separated list of index names to restrict the operation; use or empty string to perform the operation on all indices\n• allow_no_indices – Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes string or when no indices have been specified)\n• expand_wildcards – Whether to expand wildcard expression to concrete indices that are open, closed or both., default ‘open’, valid choices are: ‘open’, ‘closed’, ‘none’, ‘all’\n• ignore_unavailable – Whether specified concrete indices should be ignored when unavailable (missing or closed)\n• preference – Specify the node or shard the operation should be performed on (default: random) Returns information and statistics on terms in the fields of a particular document. The document could be stored in the index or artificially provided by the user (Added in 1.4). Note that for documents stored in the index, this is a near realtime API as the term vectors are not available until the next refresh. http://www.elastic.co/guide/en/elasticsearch/reference/current/docs-termvectors.html\n• index – The index in which the document resides.\n• doc_type – The type of the document.\n• id – The id of the document, when not specified a doc param should be supplied.\n• body – Define parameters and or supply a document to get termvectors for. See documentation.\n• dfs – Specifies if distributed frequencies should be returned instead shard frequencies., default False\n• field_statistics – Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned., default True\n• offsets – Specifies if term offsets should be returned., default True\n• payloads – Specifies if term payloads should be returned., default True\n• positions – Specifies if term positions should be returned., default True\n• preference – Specify the node or shard the operation should be performed on (default: random).\n• realtime – Specifies if request is real-time as opposed to near- real-time (default: true).\n• term_statistics – Specifies if total term frequency and document frequency should be returned., default False\n• index – The name of the index\n• doc_type – The type of the document\n• body – The request definition using either or partial\n• consistency – Explicit write consistency setting for the operation, valid choices are: ‘one’, ‘quorum’, ‘all’\n• detect_noop – Specifying as true will cause Elasticsearch to check if there are changes and, if there aren’t, turn the update request into a noop.\n• fields – A comma-separated list of fields to return in the response\n• parent – ID of the parent document. Is is only used for routing and when for the upsert request\n• refresh – Refresh the index after performing the operation\n• retry_on_conflict – Specify how many times should the operation be retried when a conflict occurs (default: 0)\n• script – The URL-encoded script definition (instead of using request body)\n• scripted_upsert – True if the script referenced in script or script_id should be called to perform inserts - defaults to false\n\nPerform the analysis process on a text and return the tokens breakdown of the text. http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-analyze.html\n• index – The name of the index to scope the operation\n• body – The text on which the analysis should be performed\n• analyzer – The name of the analyzer to use\n• char_filters – A comma-separated list of character filters to use for the analysis\n• field – Use the analyzer configured for this field (instead of passing the analyzer name)\n• filters – A comma-separated list of filters to use for the analysis\n• format – Format of the output, default ‘detailed’, valid choices are: ‘detailed’, ‘text’\n• prefer_local – With , specify that a local shard should be used if available, with , use a random shard (default: true)\n• text – The text on which the analysis should be performed (when request body is not used)\n• tokenizer – The name of the tokenizer to use for the analysis Clear either all caches or specific cached associated with one ore more indices. http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-clearcache.html\n• index – A comma-separated list of index name to limit the operation\n• allow_no_indices – Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes string or when no indices have been specified)\n• expand_wildcards – Whether to expand wildcard expression to concrete indices that are open, closed or both., default ‘open’, valid choices are: ‘open’, ‘closed’, ‘none’, ‘all’\n• fields – A comma-separated list of fields to clear when using the parameter (default: all)\n• ignore_unavailable – Whether specified concrete indices should be ignored when unavailable (missing or closed) Close an index to remove it’s overhead from the cluster. Closed index is blocked for read/write operations. http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-open-close.html\n• index – The name of the index\n• allow_no_indices – Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes string or when no indices have been specified)\n• expand_wildcards – Whether to expand wildcard expression to concrete indices that are open, closed or both., default ‘open’, valid choices are: ‘open’, ‘closed’, ‘none’, ‘all’\n• ignore_unavailable – Whether specified concrete indices should be ignored when unavailable (missing or closed)\n• master_timeout – Specify timeout for connection to master\n• index – The name of the index\n• body – The configuration for the index ( and )\n• master_timeout – Specify timeout for connection to master\n• update_all_types – Whether to update the mapping for all fields with the same name across all types or not\n• index – A comma-separated list of indices to delete; use or string to delete all indices\n• master_timeout – Specify timeout for connection to master\n• index – A comma-separated list of index names (supports wildcards); use for all indices\n• name – A comma-separated list of aliases to delete (supports wildcards); use to delete all aliases for the specified indices.\n• master_timeout – Specify timeout for connection to master Delete an index template by its name. http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-templates.html\n• name – The name of the template\n• master_timeout – Specify timeout for connection to master\n• index – A comma-separated list of index names to delete warmers from (supports wildcards); use to perform the operation on all indices.\n• name – A comma-separated list of warmer names to delete (supports wildcards); use to delete all warmers in the specified indices. You must specify a name either in the uri or in the parameters.\n• master_timeout – Specify timeout for connection to master\n• allow_no_indices – Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes string or when no indices have been specified)\n• expand_wildcards – Whether to expand wildcard expression to concrete indices that are open, closed or both., default ‘open’, valid choices are: ‘open’, ‘closed’, ‘none’, ‘all’\n• ignore_unavailable – Whether specified concrete indices should be ignored when unavailable (missing or closed)\n• local – Return local information, do not retrieve the state from master node (default: false)\n• name – A comma-separated list of alias names to return\n• allow_no_indices – Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes string or when no indices have been specified)\n• expand_wildcards – Whether to expand wildcard expression to concrete indices that are open, closed or both., default [‘open’, ‘closed’], valid choices are: ‘open’, ‘closed’, ‘none’, ‘all’\n• ignore_unavailable – Whether specified concrete indices should be ignored when unavailable (missing or closed)\n• local – Return local information, do not retrieve the state from master node (default: false)\n• name – The name of the template\n• local – Return local information, do not retrieve the state from master node (default: false) Check if a type/types exists in an index/indices. http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-types-exists.html\n• index – A comma-separated list of index names; use to check the types across all indices\n• allow_no_indices – Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes string or when no indices have been specified)\n• expand_wildcards – Whether to expand wildcard expression to concrete indices that are open, closed or both., default ‘open’, valid choices are: ‘open’, ‘closed’, ‘none’, ‘all’\n• ignore_unavailable – Whether specified concrete indices should be ignored when unavailable (missing or closed)\n• local – Return local information, do not retrieve the state from master node (default: false) Explicitly flush one or more indices. http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-flush.html\n• index – A comma-separated list of index names; use or empty string for all indices\n• allow_no_indices – Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes string or when no indices have been specified)\n• expand_wildcards – Whether to expand wildcard expression to concrete indices that are open, closed or both., default ‘open’, valid choices are: ‘open’, ‘closed’, ‘none’, ‘all’\n• force – Whether a flush should be forced even if it is not necessarily needed ie. if no changes will be committed to the index. This is useful if transaction log IDs should be incremented even if no uncommitted changes are present. (This setting can be considered as internal)\n• ignore_unavailable – Whether specified concrete indices should be ignored when unavailable (missing or closed)\n• wait_if_ongoing – If set to true the flush operation will block until the flush can be executed if another flush operation is already executing. The default is false and will cause an exception to be thrown on the shard level if another flush operation is already running. Perform a normal flush, then add a generated unique marker (sync_id) to all shards. http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-synced-flush.html\n• index – A comma-separated list of index names; use or empty string for all indices\n• allow_no_indices – Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes string or when no indices have been specified)\n• expand_wildcards – Whether to expand wildcard expression to concrete indices that are open, closed or both., default ‘open’, valid choices are: ‘open’, ‘closed’, ‘none’, ‘all’\n• ignore_unavailable – Whether specified concrete indices should be ignored when unavailable (missing or closed) The get index API allows to retrieve information about one or more indexes. http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-get-index.html\n• allow_no_indices – Ignore if a wildcard expression resolves to no concrete indices (default: false)\n• expand_wildcards – Whether wildcard expressions should get expanded to open or closed indices (default: open), default ‘open’, valid choices are: ‘open’, ‘closed’, ‘none’, ‘all’\n• human – Whether to return version and creation date values in human- readable format., default False\n• local – Return local information, do not retrieve the state from master node (default: false)\n• name – A comma-separated list of alias names to return\n• allow_no_indices – Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes string or when no indices have been specified)\n• expand_wildcards – Whether to expand wildcard expression to concrete indices that are open, closed or both., default ‘open’, valid choices are: ‘open’, ‘closed’, ‘none’, ‘all’\n• ignore_unavailable – Whether specified concrete indices should be ignored when unavailable (missing or closed)\n• local – Return local information, do not retrieve the state from master node (default: false)\n• name – A comma-separated list of alias names to filter\n• local – Return local information, do not retrieve the state from master node (default: false)\n• allow_no_indices – Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes string or when no indices have been specified)\n• expand_wildcards – Whether to expand wildcard expression to concrete indices that are open, closed or both., default ‘open’, valid choices are: ‘open’, ‘closed’, ‘none’, ‘all’\n• ignore_unavailable – Whether specified concrete indices should be ignored when unavailable (missing or closed)\n• include_defaults – Whether the default mapping values should be returned as well\n• local – Return local information, do not retrieve the state from master node (default: false)\n• allow_no_indices – Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes string or when no indices have been specified)\n• expand_wildcards – Whether to expand wildcard expression to concrete indices that are open, closed or both., default ‘open’, valid choices are: ‘open’, ‘closed’, ‘none’, ‘all’\n• ignore_unavailable – Whether specified concrete indices should be ignored when unavailable (missing or closed)\n• local – Return local information, do not retrieve the state from master node (default: false) Retrieve settings for one or more (or all) indices. http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-get-settings.html\n• index – A comma-separated list of index names; use or empty string to perform the operation on all indices\n• name – The name of the settings that should be included\n• allow_no_indices – Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes string or when no indices have been specified)\n• expand_wildcards – Whether to expand wildcard expression to concrete indices that are open, closed or both., default [‘open’, ‘closed’], valid choices are: ‘open’, ‘closed’, ‘none’, ‘all’\n• human – Whether to return version and creation date values in human- readable format., default False\n• ignore_unavailable – Whether specified concrete indices should be ignored when unavailable (missing or closed)\n• local – Return local information, do not retrieve the state from master node (default: false) Retrieve an index template by its name. http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-templates.html\n• name – The name of the template\n• local – Return local information, do not retrieve the state from master node (default: false) Monitor how much of one or more index is upgraded. http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-upgrade.html\n• index – A comma-separated list of index names; use or empty string to perform the operation on all indices\n• allow_no_indices – Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes string or when no indices have been specified)\n• expand_wildcards – Whether to expand wildcard expression to concrete indices that are open, closed or both., default ‘open’, valid choices are: ‘open’, ‘closed’, ‘none’, ‘all’\n• human – Whether to return time and byte values in human-readable format., default False\n• ignore_unavailable – Whether specified concrete indices should be ignored when unavailable (missing or closed)\n• index – A comma-separated list of index names to restrict the operation; use to perform the operation on all indices\n• doc_type – A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types\n• name – The name of the warmer (supports wildcards); leave empty to get all warmers\n• allow_no_indices – Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes string or when no indices have been specified)\n• expand_wildcards – Whether to expand wildcard expression to concrete indices that are open, closed or both., default ‘open’, valid choices are: ‘open’, ‘closed’, ‘none’, ‘all’\n• ignore_unavailable – Whether specified concrete indices should be ignored when unavailable (missing or closed)\n• local – Return local information, do not retrieve the state from master node (default: false) Open a closed index to make it available for search. http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-open-close.html\n• index – The name of the index\n• allow_no_indices – Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes string or when no indices have been specified)\n• expand_wildcards – Whether to expand wildcard expression to concrete indices that are open, closed or both., default ‘closed’, valid choices are: ‘open’, ‘closed’, ‘none’, ‘all’\n• ignore_unavailable – Whether specified concrete indices should be ignored when unavailable (missing or closed)\n• master_timeout – Specify timeout for connection to master Explicitly optimize one or more indices through an API. http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-optimize.html\n• index – A comma-separated list of index names; use or empty string to perform the operation on all indices\n• allow_no_indices – Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes string or when no indices have been specified)\n• expand_wildcards – Whether to expand wildcard expression to concrete indices that are open, closed or both., default ‘open’, valid choices are: ‘open’, ‘closed’, ‘none’, ‘all’\n• flush – Specify whether the index should be flushed after performing the operation (default: true)\n• ignore_unavailable – Whether specified concrete indices should be ignored when unavailable (missing or closed)\n• max_num_segments – The number of segments the index should be merged into (default: dynamic)\n• only_expunge_deletes – Specify whether the operation should only expunge deleted documents\n• wait_for_merge – Specify whether the request should block until the merge process is finished (default: true)\n• index – A comma-separated list of index names the alias should point to (supports wildcards); use to perform the operation on all indices.\n• name – The name of the alias to be created or updated\n• body – The settings for the alias, such as or\n• master_timeout – Specify timeout for connection to master\n• doc_type – The name of the document type\n• index – A comma-separated list of index names the mapping should be added to (supports wildcards); use or omit to add the mapping on all indices.\n• allow_no_indices – Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes string or when no indices have been specified)\n• expand_wildcards – Whether to expand wildcard expression to concrete indices that are open, closed or both., default ‘open’, valid choices are: ‘open’, ‘closed’, ‘none’, ‘all’\n• ignore_unavailable – Whether specified concrete indices should be ignored when unavailable (missing or closed)\n• master_timeout – Specify timeout for connection to master\n• update_all_types – Whether to update the mapping for all fields with the same name across all types or not\n• body – The index settings to be updated\n• index – A comma-separated list of index names; use or empty string to perform the operation on all indices\n• allow_no_indices – Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes string or when no indices have been specified)\n• expand_wildcards – Whether to expand wildcard expression to concrete indices that are open, closed or both., default ‘open’, valid choices are: ‘open’, ‘closed’, ‘none’, ‘all’\n• ignore_unavailable – Whether specified concrete indices should be ignored when unavailable (missing or closed)\n• master_timeout – Specify timeout for connection to master Create an index template that will automatically be applied to new indices created. http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-templates.html\n• name – The name of the template\n• create – Whether the index template should only be added if new or can also replace an existing one, default False\n• master_timeout – Specify timeout for connection to master\n• order – The order for this template when merging multiple matching ones (higher numbers are merged later, overriding the lower numbers) Create an index warmer to run registered search requests to warm up the index before it is available for search. http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-warmers.html\n• name – The name of the warmer\n• body – The search request definition for the warmer (query, filters, facets, sorting, etc)\n• index – A comma-separated list of index names to register the warmer for; use or omit to perform the operation on all indices\n• doc_type – A comma-separated list of document types to register the warmer for; leave empty to perform the operation on all types\n• allow_no_indices – Whether to ignore if a wildcard indices expression resolves into no concrete indices in the search request to warm. (This includes string or when no indices have been specified)\n• expand_wildcards – Whether to expand wildcard expression to concrete indices that are open, closed or both, in the search request to warm., default ‘open’, valid choices are: ‘open’, ‘closed’, ‘none’, ‘all’\n• ignore_unavailable – Whether specified concrete indices should be ignored when unavailable (missing or closed) in the search request to warm\n• master_timeout – Specify timeout for connection to master\n• request_cache – Specify whether the request to be warmed should use the request cache, defaults to index level setting The indices recovery API provides insight into on-going shard recoveries. Recovery status may be reported for specific indices, or cluster-wide. http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-recovery.html\n• index – A comma-separated list of index names; use or empty string to perform the operation on all indices\n• active_only – Display only those recoveries that are currently on- going, default False\n• detailed – Whether to display detailed information about shard recovery, default False\n• human – Whether to return time and byte values in human-readable format., default False Explicitly refresh one or more index, making all operations performed since the last refresh available for search. http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-refresh.html\n• index – A comma-separated list of index names; use or empty string to perform the operation on all indices\n• allow_no_indices – Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes string or when no indices have been specified)\n• expand_wildcards – Whether to expand wildcard expression to concrete indices that are open, closed or both., default ‘open’, valid choices are: ‘open’, ‘closed’, ‘none’, ‘all’\n• force – Force a refresh even if not required, default False\n• ignore_unavailable – Whether specified concrete indices should be ignored when unavailable (missing or closed) Provide low level segments information that a Lucene index (shard level) is built with. http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-segments.html\n• index – A comma-separated list of index names; use or empty string to perform the operation on all indices\n• allow_no_indices – Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes string or when no indices have been specified)\n• expand_wildcards – Whether to expand wildcard expression to concrete indices that are open, closed or both., default ‘open’, valid choices are: ‘open’, ‘closed’, ‘none’, ‘all’\n• human – Whether to return time and byte values in human-readable format., default False\n• ignore_unavailable – Whether specified concrete indices should be ignored when unavailable (missing or closed)\n• index – A comma-separated list of index names; use or empty string to perform the operation on all indices\n• allow_no_indices – Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes string or when no indices have been specified)\n• expand_wildcards – Whether to expand wildcard expression to concrete indices that are open, closed or both., default ‘open’, valid choices are: ‘open’, ‘closed’, ‘none’, ‘all’\n• ignore_unavailable – Whether specified concrete indices should be ignored when unavailable (missing or closed)\n• status – A comma-separated list of statuses used to filter on shards to get store information for, valid choices are: ‘green’, ‘yellow’, ‘red’, ‘all’ Retrieve statistics on different operations happening on an index. http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-stats.html\n• index – A comma-separated list of index names; use or empty string to perform the operation on all indices\n• completion_fields – A comma-separated list of fields for and index metric (supports wildcards)\n• fields – A comma-separated list of fields for and index metric (supports wildcards)\n• human – Whether to return time and byte values in human-readable format., default False\n• level – Return stats aggregated at cluster, index or shard level, default ‘indices’, valid choices are: ‘cluster’, ‘indices’, ‘shards’\n• types – A comma-separated list of document types for the index metric\n• body – The definition of to perform\n• master_timeout – Specify timeout for connection to master Upgrade one or more indices to the latest format through an API. http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-upgrade.html\n• index – A comma-separated list of index names; use or empty string to perform the operation on all indices\n• allow_no_indices – Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes string or when no indices have been specified)\n• expand_wildcards – Whether to expand wildcard expression to concrete indices that are open, closed or both., default ‘open’, valid choices are: ‘open’, ‘closed’, ‘none’, ‘all’\n• ignore_unavailable – Whether specified concrete indices should be ignored when unavailable (missing or closed)\n• only_ancient_segments – If true, only ancient (an older Lucene major release) segments will be upgraded\n• wait_for_completion – Specify whether the request should block until the all segments are upgraded (default: false)\n• index – A comma-separated list of index names to restrict the operation; use or empty string to perform the operation on all indices\n• doc_type – A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types\n• body – The query definition specified with the Query DSL\n• allow_no_indices – Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes string or when no indices have been specified)\n• analyze_wildcard – Specify whether wildcard and prefix queries should be analyzed (default: false)\n• analyzer – The analyzer to use for the query string\n• default_operator – The default operator for query string query (AND or OR), default ‘OR’, valid choices are: ‘AND’, ‘OR’\n• df – The field to use as default where no field prefix is given in the query string\n• expand_wildcards – Whether to expand wildcard expression to concrete indices that are open, closed or both., default ‘open’, valid choices are: ‘open’, ‘closed’, ‘none’, ‘all’\n• ignore_unavailable – Whether specified concrete indices should be ignored when unavailable (missing or closed)\n• lenient – Specify whether format-based query failures (such as providing text to a numeric field) should be ignored\n• lowercase_expanded_terms – Specify whether query terms should be lowercased\n• rewrite – Provide a more detailed explanation showing the actual Lucene query that will be executed.\n• name – A comma-separated list of alias names to return\n• local – Return local information, do not retrieve the state from master node (default: false) Allocation provides a snapshot of how shards have located around the cluster and the state of disk usage. http://www.elastic.co/guide/en/elasticsearch/reference/current/cat-allocation.html\n• node_id – A comma-separated list of node IDs or names to limit the returned information\n• bytes – The unit in which to display byte values, valid choices are: ‘b’, ‘k’, ‘m’, ‘g’\n• local – Return local information, do not retrieve the state from master node (default: false) Count provides quick access to the document count of the entire cluster, or individual indices. http://www.elastic.co/guide/en/elasticsearch/reference/current/cat-count.html\n• index – A comma-separated list of index names to limit the returned information\n• local – Return local information, do not retrieve the state from master node (default: false) Shows information about currently loaded fielddata on a per-node basis. http://www.elastic.co/guide/en/elasticsearch/reference/current/cat-fielddata.html\n• fields – A comma-separated list of fields to return the fielddata size\n• bytes – The unit in which to display byte values, valid choices are: ‘b’, ‘k’, ‘m’, ‘g’\n• local – Return local information, do not retrieve the state from master node (default: false) health is a terse, one-line representation of the same information from API http://www.elastic.co/guide/en/elasticsearch/reference/current/cat-health.html\n• local – Return local information, do not retrieve the state from master node (default: false) A simple help for the cat api. http://www.elastic.co/guide/en/elasticsearch/reference/current/cat.html The indices command provides a cross-section of each index. http://www.elastic.co/guide/en/elasticsearch/reference/current/cat-indices.html\n• index – A comma-separated list of index names to limit the returned information\n• bytes – The unit in which to display byte values, valid choices are: ‘b’, ‘k’, ‘m’, ‘g’\n• local – Return local information, do not retrieve the state from master node (default: false)\n• pri – Set to true to return stats only for primary shards, default False Displays the master’s node ID, bound IP address, and node name. http://www.elastic.co/guide/en/elasticsearch/reference/current/cat-master.html\n• local – Return local information, do not retrieve the state from master node (default: false)\n• local – Return local information, do not retrieve the state from master node (default: false)\n• local – Return local information, do not retrieve the state from master node (default: false) pending_tasks provides the same information as the API in a convenient tabular format. http://www.elastic.co/guide/en/elasticsearch/reference/current/cat-pending-tasks.html\n• local – Return local information, do not retrieve the state from master node (default: false)\n• local – Return local information, do not retrieve the state from master node (default: false)\n• index – A comma-separated list of index names to limit the returned information\n• bytes – The unit in which to display byte values, valid choices are: ‘b’, ‘k’, ‘m’, ‘g’ The segments command is the detailed view of Lucene segments per index. http://www.elastic.co/guide/en/elasticsearch/reference/current/cat-segments.html\n• index – A comma-separated list of index names to limit the returned information The shards command is the detailed view of what nodes contain which shards. http://www.elastic.co/guide/en/elasticsearch/reference/current/cat-shards.html\n• index – A comma-separated list of index names to limit the returned information\n• local – Return local information, do not retrieve the state from master node (default: false)\n• local – Return local information, do not retrieve the state from master node (default: false)\n• wait_for_completion – Should this request wait until the operation has completed before returning, default False\n• verify – Whether to verify the repository after creation\n• local – Return local information, do not retrieve the state from master node (default: false)\n• body – Details of what to restore\n• wait_for_completion – Should this request wait until the operation has completed before returning, default False Return information about all currently running snapshots. By specifying a repository name, it’s possible to limit the results to a particular repository. http://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html Returns a list of nodes where repository was successfully verified or an error message if verification process failed. http://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html"
    },
    {
        "link": "https://stackoverflow.com/questions/20564655/elasticsearch-query-on-a-specific-index",
        "document": "I have already searching this since 2 days now. I use the sense chrome plugin to be able to test my queries but I don't find how to specify on which index he is supposed to search. So my queries search on all the indexes and it isn't easy to use.\n\nI have try the following syntaxes:\n\nEdit I finally have found the answer: just add the index name into the url for the get: localhost:9201/myIndexName"
    },
    {
        "link": "https://elastic.co/guide/en/elasticsearch/reference/current/search-your-data.html",
        "document": "A search consists of one or more queries that are combined and sent to Elasticsearch. Documents that match a search’s queries are returned in the hits, or search results, of the response.\n\nA search may also contain additional information used to better process its queries. For example, a search may be limited to a specific index or only return a specific number of results.\n\nYou can use the search API to search and aggregate data stored in Elasticsearch data streams or indices. The API’s request body parameter accepts queries written in Query DSL.\n\nThe following request searches using a query. This query matches documents with a value of .\n\nThe API response returns the top 10 documents matching the query in the property.\n\nYou can use the following options to customize your searches.\n\nQuery DSL\n\n Query DSL supports a variety of query types you can mix and match to get the results you want. Query types include:\n\nAggregations\n\n You can use search aggregations to get statistics and other analytics for your search results. Aggregations help you answer questions like:\n\nSearch multiple data streams and indices\n\n You can use comma-separated values and grep-like index patterns to search several data streams and indices in the same request. You can even boost search results from specific indices. See Search multiple data streams and indices using a query.\n\nPaginate search results\n\n By default, searches return only the top 10 matching hits. To retrieve more or fewer documents, see Paginate search results.\n\nRetrieve selected fields\n\n The search response’s property includes the full document for each hit. To retrieve only a subset of the or other fields, see Retrieve selected fields.\n\nSort search results\n\n By default, search hits are sorted by , a relevance score that measures how well each document matches the query. To customize the calculation of these scores, use the query. To sort search hits by other field values, see Sort search results.\n\nRun an async search\n\n Elasticsearch searches are designed to run on large volumes of data quickly, often returning results in milliseconds. For this reason, searches are synchronous by default. The search request waits for complete results before returning a response.\n\nHowever, complete results can take longer for searches across large data sets or multiple clusters.\n\nTo avoid long waits, you can run an asynchronous, or async, search instead. An async search lets you retrieve partial results for a long-running search now and get complete results later.\n\nInstead of indexing your data and then searching it, you can define runtime fields that only exist as part of your search query. You specify a section in your search request to define the runtime field, which can optionally include a Painless script.\n\nFor example, the following query defines a runtime field called . The included script calculates the day of the week based on the value of the field, and uses to return the calculated value.\n\nThe query also includes a terms aggregation that operates on .\n\nThe response includes an aggregation based on the runtime field. Under is a with a value of . The query dynamically calculated this value based on the script defined in the runtime field without ever indexing the field.\n\nBy default, search requests don’t time out. The request waits for complete results from each shard before returning a response.\n\nWhile async search is designed for long-running searches, you can also use the parameter to specify a duration you’d like to wait on each shard to complete. Each shard collects hits within the specified time period. If collection isn’t finished when the period ends, Elasticsearch uses only the hits accumulated up to that point. The overall latency of a search request depends on the number of shards needed for the search and the number of concurrent shard requests.\n\nTo set a cluster-wide default timeout for all search requests, configure using the cluster settings API. This global timeout duration is used if no argument is passed in the request. If the global search timeout expires before the search request finishes, the request is cancelled using task cancellation. The setting defaults to (no timeout).\n\nYou can cancel a search request using the task management API. Elasticsearch also automatically cancels a search request when your client’s HTTP connection closes. We recommend you set up your client to close HTTP connections when a search request is aborted or times out.\n\nGenerally the total hit count can’t be computed accurately without visiting all matches, which is costly for queries that match lots of documents. The parameter allows you to control how the total number of hits should be tracked. Given that it is often enough to have a lower bound of the number of hits, such as \"there are at least 10000 hits\", the default is set to . This means that requests will count the total hit accurately up to hits. It is a good trade off to speed up searches if you don’t need the accurate number of hits after a certain threshold.\n\nWhen set to the search response will always track the number of hits that match the query accurately (e.g. will always be equal to when is set to true). Otherwise the returned in the object in the search response determines how the should be interpreted. A value of means that the is a lower bound of the total hits that match the query and a value of indicates that is the accurate count.\n\nIt is also possible to set to an integer. For instance the following query will accurately track the total hit count that match the query up to 100 documents:\n\nThe in the response will indicate if the value returned in is accurate ( ) or a lower bound of the total ( ).\n\nFor instance the following response:\n\n... indicates that the number of hits returned in the is accurate.\n\nIf the total number of hits that match the query is greater than the value set in , the total hits in the response will indicate that the returned value is a lower bound:\n\nIf you don’t need to track the total number of hits at all you can improve query times by setting this option to :\n\nFinally you can force an accurate count by setting to in the request.\n\nIf you only want to know if there are any documents matching a specific query, you can set the to to indicate that we are not interested in the search results. You can also set to to indicate that the query execution can be terminated whenever the first matching document was found (per shard).\n\nThe response will not contain any hits as the was set to . The will be either equal to , indicating that there were no matching documents, or greater than meaning that there were at least as many documents matching the query when it was early terminated. Also if the query was terminated early, the flag will be set to in the response. Some queries are able to retrieve the hits count directly from the index statistics, which is much faster as it does not require executing the query. In those situations, no documents are collected, the returned will be higher than , and will be set to .\n\nThe time in the response contains the milliseconds that this request took for processing, beginning quickly after the node received the query, up until all search related work is done and before the above JSON is returned to the client. This means it includes the time spent waiting in thread pools, executing a distributed search across the whole cluster and gathering all the results."
    },
    {
        "link": "https://elastic.co/guide/en/elasticsearch/reference/current/modules-cluster.html",
        "document": "Shard allocation is the process of assigning shard copies to nodes. This can happen during initial recovery, replica allocation, rebalancing, when nodes are added to or removed from the cluster, or when cluster or index settings that impact allocation are updated.\n\nOne of the main roles of the master is to decide which shards to allocate to which nodes, and when to move shards between nodes in order to rebalance the cluster.\n\nThere are a number of settings available to control the shard allocation process:\n\nBesides these, there are a few other miscellaneous cluster-level settings.\n\nA cluster is balanced when it has an equal number of shards on each node, with all nodes needing equal resources, without having a concentration of shards from any index on any node. Elasticsearch runs an automatic process called rebalancing which moves shards between the nodes in your cluster to improve its balance. Rebalancing obeys all other shard allocation rules such as allocation filtering and forced awareness which may prevent it from completely balancing the cluster. In that case, rebalancing strives to achieve the most balanced cluster possible within the rules you have configured. If you are using data tiers then Elasticsearch automatically applies allocation filtering rules to place each shard within the appropriate tier. These rules mean that the balancer works independently within each tier. You can use the following settings to control the rebalancing of shards across the cluster: (Dynamic) Specify when shard rebalancing is allowed:\n• - Only when all primaries in the cluster are allocated.\n• - Only when all shards (primaries and replicas) in the cluster are allocated. (Dynamic) Enable or disable rebalancing for specific kinds of shards:\n• - (default) Allows shard balancing for all kinds of shards.\n• - Allows shard balancing only for primary shards.\n• - Allows shard balancing only for replica shards.\n• - No shard balancing of any kind are allowed for any indices. Rebalancing is important to ensure the cluster returns to a healthy and fully resilient state after a disruption. If you adjust this setting, remember to set it back to as soon as possible. (Dynamic) Defines the number of concurrent shard rebalances are allowed across the whole cluster. Defaults to . Note that this setting only controls the number of concurrent shard relocations due to imbalances in the cluster. This setting does not limit shard relocations due to allocation filtering or forced awareness. Increasing this setting may cause the cluster to use additional resources moving shards between nodes, so we generally do not recommend adjusting this setting from its default of . Selects the algorithm used for computing the cluster balance. Defaults to which selects the desired balance allocator. This allocator runs a background task which computes the desired balance of shards in the cluster. Once this background task completes, Elasticsearch moves shards to their desired locations. [8.8] Deprecated in 8.8. The allocator type is deprecated and no longer recommended May also be set to to select the legacy balanced allocator. This allocator was the default allocator in versions of Elasticsearch before 8.6.0. It runs in the foreground, preventing the master from doing other work in parallel. It works by selecting a small number of shard movements which immediately improve the balance of the cluster, and when those shard movements complete it runs again and selects another few shards to move. Since this allocator makes its decisions based only on the current state of the cluster, it will sometimes move a shard several times while balancing the cluster.\n\nRebalancing works by computing a weight for each node based on its allocation of shards, and then moving shards between nodes to reduce the weight of the heavier nodes and increase the weight of the lighter ones. The cluster is balanced when there is no possible shard movement that can bring the weight of any node closer to the weight of any other node by more than a configurable threshold. The weight of a node depends on the number of shards it holds and on the total estimated resource usage of those shards expressed in terms of the size of the shard on disk and the number of threads needed to support write traffic to the shard. Elasticsearch estimates the resource usage of shards belonging to data streams when they are created by a rollover. The estimated disk size of the new shard is the mean size of the other shards in the data stream. The estimated write load of the new shard is a weighted average of the actual write loads of recent shards in the data stream. Shards that do not belong to the write index of a data stream have an estimated write load of zero. The following settings control how Elasticsearch combines these values into an overall measure of each node’s weight. (float, Dynamic) The minimum improvement in weight which triggers a rebalancing shard movement. Defaults to . Raising this value will cause Elasticsearch to stop rebalancing shards sooner, leaving the cluster in a more unbalanced state. (float, Dynamic) Defines the weight factor for the total number of shards allocated to each node. Defaults to . Raising this value increases the tendency of Elasticsearch to equalize the total number of shards across nodes ahead of the other balancing variables. (float, Dynamic) Defines the weight factor for the number of shards per index allocated to each node. Defaults to . Raising this value increases the tendency of Elasticsearch to equalize the number of shards of each index across nodes ahead of the other balancing variables. (float, Dynamic) Defines the weight factor for balancing shards according to their predicted disk size in bytes. Defaults to . Raising this value increases the tendency of Elasticsearch to equalize the total disk usage across nodes ahead of the other balancing variables. (float, Dynamic) Defines the weight factor for the write load of each shard, in terms of the estimated number of indexing threads needed by the shard. Defaults to . Raising this value increases the tendency of Elasticsearch to equalize the total write load across nodes ahead of the other balancing variables.\n• If you have a large cluster, it may be unnecessary to keep it in a perfectly balanced state at all times. It is less resource-intensive for the cluster to operate in a somewhat unbalanced state rather than to perform all the shard movements needed to achieve the perfect balance. If so, increase the value of to define the acceptable imbalance between nodes. For instance, if you have an average of 500 shards per node and can accept a difference of 5% (25 typical shards) between nodes, set to .\n• We do not recommend adjusting the values of the heuristic weight factor settings. The default values work well in all reasonable clusters. Although different values may improve the current balance in some ways, it is possible that they will create unexpected problems in the future or prevent it from gracefully handling an unexpected disruption.\n• Regardless of the result of the balancing algorithm, rebalancing might not be allowed due to allocation rules such as forced awareness and allocation filtering. Use the Cluster allocation explain API to explain the current allocation of shards.\n\nThe disk-based shard allocator ensures that all nodes have enough disk space without performing more shard movements than necessary. It allocates shards based on a pair of thresholds known as the low watermark and the high watermark. Its primary goal is to ensure that no node exceeds the high watermark, or at least that any such overage is only temporary. If a node exceeds the high watermark then Elasticsearch will solve this by moving some of its shards onto other nodes in the cluster. It is normal for nodes to temporarily exceed the high watermark from time to time. The allocator also tries to keep nodes clear of the high watermark by forbidding the allocation of more shards to a node that exceeds the low watermark. Importantly, if all of your nodes have exceeded the low watermark then no new shards can be allocated and Elasticsearch will not be able to move any shards between nodes in order to keep the disk usage below the high watermark. You must ensure that your cluster has enough disk space in total and that there are always some nodes below the low watermark. Shard movements triggered by the disk-based shard allocator must also satisfy all other shard allocation rules such as allocation filtering and forced awareness. If these rules are too strict then they can also prevent the shard movements needed to keep the nodes' disk usage under control. If you are using data tiers then Elasticsearch automatically configures allocation filtering rules to place shards within the appropriate tier, which means that the disk-based shard allocator works independently within each tier. If a node is filling up its disk faster than Elasticsearch can move shards elsewhere then there is a risk that the disk will completely fill up. To prevent this, as a last resort, once the disk usage reaches the flood-stage watermark Elasticsearch will block writes to indices with a shard on the affected node. It will also continue to move shards onto the other nodes in the cluster. When disk usage on the affected node drops below the high watermark, Elasticsearch automatically removes the write block. Refer to Fix watermark errors to resolve persistent watermark errors. Max headroom settings apply only when watermark settings are percentages or ratios. A max headroom value is intended to cap the required free disk space before hitting the respective watermark. This is useful for servers with larger disks, where a percentage or ratio watermark could translate to an overly large free disk space requirement. In this case, the max headroom can be used to cap the required free disk space amount. For example, where is 95% and is 100GB, this means that:\n• For a smaller disk, e.g., of 100GB, the flood watermark will hit at 95%, meaning at 5GB of free space, since 5GB is smaller than the 100GB max headroom value.\n• For a larger disk, e.g., of 100TB, the flood watermark will hit at 100GB of free space. That is because the 95% flood watermark alone would require 5TB of free disk space, but is capped by the max headroom setting to 100GB. Max headroom settings have their default values only if their respective watermark settings are not explicitly set. If watermarks are explicitly set, then the max headroom settings do not have their default values, and need to be explicitly set if they are needed. It is normal for the nodes in your cluster to be using very different amounts of disk space. The balance of the cluster depends on a combination of factors which includes the number of shards on each node, the indices to which those shards belong, and the resource needs of each shard in terms of its size on disk and its CPU usage. Elasticsearch must trade off all of these factors against each other, and a cluster which is balanced when looking at the combination of all of these factors may not appear to be balanced if you focus attention on just one of them. You can use the following settings to control disk-based allocation: (Dynamic) Defaults to . Set to to disable the disk allocation decider. Upon disabling, it will also remove any existing index blocks. (Dynamic) Controls the low watermark for disk usage. It defaults to , meaning that Elasticsearch will not allocate shards to nodes that have more than 85% disk used. It can alternatively be set to a ratio value, e.g., . It can also be set to an absolute byte value (like ) to prevent Elasticsearch from allocating shards if less than the specified amount of space is available. This setting has no effect on the primary shards of newly-created indices but will prevent their replicas from being allocated. (Dynamic) Controls the max headroom for the low watermark (in case of a percentage/ratio value). Defaults to 200GB when is not explicitly set. This caps the amount of free space required. (Dynamic) Controls the high watermark. It defaults to , meaning that Elasticsearch will attempt to relocate shards away from a node whose disk usage is above 90%. It can alternatively be set to a ratio value, e.g., . It can also be set to an absolute byte value (similarly to the low watermark) to relocate shards away from a node if it has less than the specified amount of free space. This setting affects the allocation of all shards, whether previously allocated or not. (Dynamic) Controls the max headroom for the high watermark (in case of a percentage/ratio value). Defaults to 150GB when is not explicitly set. This caps the amount of free space required. (Static) In earlier releases, the default behaviour was to disregard disk watermarks for a single data node cluster when making an allocation decision. This is deprecated behavior since 7.14 and has been removed in 8.0. The only valid value for this setting is now . The setting will be removed in a future release. (Dynamic) Controls the flood stage watermark, which defaults to 95%. Elasticsearch enforces a read-only index block ( ) on every index that has one or more shards allocated on the node, and that has at least one disk exceeding the flood stage. This setting is a last resort to prevent nodes from running out of disk space. The index block is automatically released when the disk utilization falls below the high watermark. Similarly to the low and high watermark values, it can alternatively be set to a ratio value, e.g., , or an absolute byte value. (Dynamic) Controls the max headroom for the flood stage watermark (in case of a percentage/ratio value). Defaults to 100GB when is not explicitly set. This caps the amount of free space required. You can’t mix the usage of percentage/ratio values and byte values across the , , and settings. Either all values must be set to percentage/ratio values, or all must be set to byte values. This is required so that Elasticsearch can validate that the settings are internally consistent, ensuring that the low disk threshold is less than the high disk threshold, and the high disk threshold is less than the flood stage threshold. A similar comparison check is done for the max headroom values. (Dynamic) Controls the flood stage watermark for dedicated frozen nodes, which defaults to 95%. (Dynamic) Controls the max headroom for the flood stage watermark (in case of a percentage/ratio value) for dedicated frozen nodes. Defaults to 20GB when is not explicitly set. This caps the amount of free space required on dedicated frozen nodes. (Dynamic) How often Elasticsearch should check on disk usage for each node in the cluster. Defaults to . Percentage values refer to used disk space, while byte values refer to free disk space. This can be confusing, because it flips the meaning of high and low. For example, it makes sense to set the low watermark to 10gb and the high watermark to 5gb, but not the other way around."
    },
    {
        "link": "https://medium.com/trendyol-tech/optimizing-elasticsearch-with-custom-routing-and-handling-routing-value-changes-25e5b0202c0c",
        "document": "In modern systems, managing large datasets efficiently and ensuring fast query performance is a significant challenge. For our system, we leverage Couchbase as the primary database and use Elasticsearch for search functionality. To achieve near real-time indexing of Couchbase data into Elasticsearch, we use go-dcp-elasticsearch, an open-source project developed by Trendyol.\n\nIn this article, we’ll discuss how we improved search performance by implementing custom routing.\n\nCouchbase is a NoSQL database known for its scalability, high availability, and real-time performance. It’s commonly used in systems where low-latency read and write operations are crucial. However, Couchbase is not optimized for complex search queries. This is where Elasticsearch comes in.\n\nElasticsearch is a distributed search engine designed for fast, scalable full-text search and analytics. It allows us to run complex queries over large datasets with low latency. To bring the best of both worlds together, we use go-dcp-elasticsearch, a tool that integrates Couchbase’s DCP (Database Change Protocol) stream with Elasticsearch. This tool listens for changes in Couchbase and indexes documents into Elasticsearch in near real-time.\n\nElasticsearch is a distributed system, which means that it splits data into smaller chunks called shards. These shards are distributed across multiple nodes in the cluster. When performing a search, Elasticsearch queries each shard and aggregates the results. This distributed nature allows Elasticsearch to handle large datasets and scale horizontally.\n\nHowever, querying a large number of shards can be resource-intensive and may lead to performance bottlenecks. This is where routing comes into play.\n\nWhat is Routing in Elasticsearch?\n\nRouting is a mechanism that allows you to control how documents are distributed across shards. By default, Elasticsearch uses the document’s _id to determine the shard on which the document will reside. However, in some cases, you may want to influence this distribution for better performance, especially when querying by specific fields frequently used in searches.\n\nTo better understand the challenges and solutions discussed in this article, it is essential to clarify the domain-specific terminology used in our system. Below is an explanation of the key terms relevant to our system:\n• Listing\n\nA Listing represents a product offered for sale by a seller on our e-commerce platform. Each listing includes various attributes and metadata required for managing and displaying the product to customers.\n• merchantId: The unique identifier for the merchant offering the product.\n• sellerBarcode: A seller-specific barcode used to uniquely identify the product within the seller’s catalog.\n• itemNumber: A globally unique identifier for the listing, used across the platform to reference the product.\n• fulfillmentType: Indicates how the product will be delivered to the customer, such as “market-place”.\n• customValues: A flexible JSON field that stores additional details about the listing. Examples include: origin, hsCode, vatRate.\n• blocks: A field that captures reasons for blocking a listing from being sold. For example, a listing may be blocked due to regulatory non-compliance or policy violations. This field serves as a record of the specific rule infringements.\n\nThe majority of the search queries in our system are based on the itemNumber. For example, when the SPI team queries the listings for a specific product, they typically use itemNumber as one of the main query parameters.\n\nTo improve query performance, we implemented custom routing based on the itemNumber. Custom routing allows us to direct Elasticsearch to search in a specific shard instead of searching through the entire cluster. This approach takes advantage of the fact that many of our search queries are based on itemNumber, meaning we can route queries directly to the relevant shard.\n\nThis provides several key benefits:\n• Reduced Query Scope: When we route a search query based on itemNumber, Elasticsearch doesn’t have to search through all the shards in the cluster. Instead, it only needs to query the shard that contains the data for that itemNumber. This drastically reduces the amount of work Elasticsearch has to do and speeds up the query response time.\n• Improved Search Speed: Instead of performing a global search across all shards, which can be resource-intensive, routing narrows the search to a specific shard. Elasticsearch can immediately target the relevant shard, making the search operation much faster.\n\nFor example, a search query for itemNumber = “item_12345” will be routed directly to the shard that holds the documents for this specific itemNumber, reducing the query latency compared to searching across all shards.\n• Efficient Use of Resources: By targeting only the relevant shard, routing minimizes the computational overhead on the Elasticsearch cluster. The search request is only executed on a subset of the data, avoiding unnecessary processing on unrelated documents.\n• Improved Latency and Throughput: Routing reduces the number of shards that Elasticsearch needs to search through, which improves both the latency (how fast individual queries are answered) and throughput (the system’s ability to handle high query volumes).\n\nIn Elasticsearch, the default routing value for documents is the document’s . This enables efficient operations like and by directly identifying the relevant shard without performing a search. However, when using custom routing during indexing, it becomes necessary to provide the same routing value explicitly in and requests.\n\nDuring indexing: The routing key is hashed and mapped to a specific shard.\n\nDuring deleting: The routing key is hashed and mapped to a specific shard.\n\nThe document is routed based on custom_key.\n\nDuring querying: The same routing key is provided to target the correct shard.\n\nThis ensures that only the shard holding the document is queried.\n\nA key challenge we faced is that the itemNumber for a listing is not immutable — it can change over time. When the itemNumber changes, the document needs to be moved to a different shard, as Elasticsearch routes documents based on their itemNumber.\n\nWhen a listing’s itemNumber changes, it means that the document’s shard will also change. To handle this:\n• The listing must first be deleted from the old shard (where the old itemNumber resided).\n• The listing must then be indexed again with the new itemNumber, ensuring it is placed on the appropriate shard.\n\nThe challenge is how to detect when the itemNumber has changed for a given listing, and how to ensure the changes are reflected in Elasticsearch in an efficient way without introducing excessive overhead.\n\nOne approach to handling this would be to check Elasticsearch during each indexing operation to see if the itemNumber has changed by querying for the existing document. However, given that we perform around 25 million indexing operations per day, querying Elasticsearch on every indexing operation would introduce significant overhead, especially in terms of search load. Additionally, this would increase the latency of the indexing process.\n\nRunning searches before each indexing operation can severely impact Elasticsearch’s performance, as it would require an additional query to find the document and compare the itemNumber. Given the scale of our indexing workload, this extra search burden would put a strain on Elasticsearch, slowing down overall performance.\n\nThe Solution: Delete Document for all shards Before Indexing\n\nInstead of checking if the itemNumber has changed, we send a delete request for the listing (even if the itemNumber hasn’t changed), followed by an index request for the new itemNumber. This ensures that the document is removed from the old shard and indexed correctly to the new shard.\n\nHow the delete operation hits all shards\n\nIn Elasticsearch, a delete operation typically targets a specific shard based on the routing key or document ID. However, in cases where the routing key (e.g., ItemNumber) might have changed and the document’s exact shard location is unknown, we need a strategy to ensure the delete operation hits all shards.\n\nElasticsearch’s routing mechanism is based on a deterministic hash algorithm. This means that for a given number of shards (N), the routing logic always maps a routing key to the same shard.\n\nWhen you index a document into Elasticsearch, the response includes a result field that indicates whether the document was created or updated. To index the same document ID across all shards, you can send indexing requests with incrementally increasing routing keys, starting from 1. If the routing key hits a different shard, the result in the response will be created. Using this approach, you can identify the routing key values that correspond to each shard. These keys can then be used to issue delete requests to all shards.\n\nFor example, for an index with 12 shards, you can use these routing key values:\n\nSince the routing algorithm is deterministic, the generated keys remain valid as long as the number of shards doesn’t change. Cache these keys for repeated use in deletion operations.\n\nTo delete a document from all shards:\n• Send separate delete requests for each routing key in a bulk delete request.\n\nIn Elasticsearch, documents are immutable. Any operation that modifies a document — such as an update — actually creates a new version of the document. The existing document remains unchanged until it is eventually removed during the merge process.\n\nEvery document in Elasticsearch has a _version field that increments with each write operation (index, update, or delete). This versioning mechanism ensures data consistency during concurrent writes and facilitates Elasticsearch’s internal operations.\n\nWhen you issue a delete request, Elasticsearch doesn’t immediately remove the document. Instead, it marks the document as deleted. The following steps occur:\n• Delete Marker Creation: Elasticsearch adds a delete marker for the document in the shard.\n• Visibility Management: During the next refresh cycle (default minimum: 1 second), the delete marker is processed. The document becomes invisible to search queries.\n• Merge Process: During future merge operations, Elasticsearch physically removes documents marked as deleted from the disk, freeing up storage.\n\nExamining the Impact of Consecutive Delete and Index Operations\n\nIn our workflow, when processing updates to listings, we perform delete and index operations in quick succession. This ensures the updated document is correctly routed to the appropriate shard. However, this rapid sequence raises the question:\n\nDoes the delete operation affect the search results when the routing key (e.g., ItemNumber) remains unchanged?\n• Refresh Interval: By default, Elasticsearch periodically refreshes indices every second, but only on indices that have received one search request or more in the last 30 seconds. You can change this default interval using the index.refresh_interval setting. Until this refresh occurs, the delete operation’s effects are not visible to search queries.\n• Versioning Behavior: When we issue an index operation immediately after a delete, Elasticsearch writes the updated document with a new _version value. The newer version of the document becomes visible to search queries after the next refresh.\n\nIf the routing key does not change, the delete operation has no visible impact on search results because:\n• The index operation overwrites the document in the same shard.\n• The search API retrieves the most recent _version of the document after the next refresh cycle.\n\nThus, even though we send a delete request, its effect is neutralized by the subsequent index operation, provided the shard does not change.\n\nTo measure the performance benefits of custom routing, we conducted load tests on a robust Elasticsearch cluster. In our load tests, each search request was designed to query 5 values per request. This structure closely resembles real-world usage patterns in our system, where internal teams often need to retrieve multiple listings in a single query.\n\nThe cluster configuration was as follows:\n• Node Specifications: Each node had 32 CPUs and 64 GB RAM\n• At 2 million queries per minute, the response time reached 45.8 ms, and the system struggled to handle higher loads.\n• By implementing custom routing, the system maintained consistent response times, even at higher throughputs.\n• At 2 million queries per minute, response time dropped from 45.8 ms to just 9.13 ms, demonstrating the efficiency of routing.\n• The cluster sustained up to 6 million queries per minute, with response times remaining under 18 ms, highlighting its scalability and ability to handle high query volumes.\n\nAfter implementing this solution, we have been running it successfully in production for the past 9 months. As part of our approach, we send delete requests to all shards before every indexing operation, even though we are aware that this generates unnecessary network traffic and additional load on Elasticsearch.\n\nDespite this inefficiency, we have not encountered any negative side effects so far. The benefits of this implementation have outweighed the drawbacks, as we have achieved a 5–6x increase in our query capacity. This significant improvement in performance has allowed us to handle high query loads, even during peak traffic periods, with a throughput of up to 6 million requests per minute.\n\nWhile the approach could potentially be optimized further, we prioritized scalability and performance gains over eliminating redundant operations. This trade-off has been essential to meeting our platform’s growing demands and ensuring a seamless experience for the teams relying on our search API.\n\nWe’re building a team of the brightest minds in our industry. Interested in joining us? Visit the pages below to learn more about our open positions."
    },
    {
        "link": "https://elastic.co/guide/en/elasticsearch/reference/current/search-shard-routing.html",
        "document": "To protect against hardware failure and increase search capacity, Elasticsearch can store copies of an index’s data across multiple shards on multiple nodes. When running a search request, Elasticsearch selects a node containing a copy of the index’s data and forwards the search request to that node’s shards. This process is known as search shard routing or routing.\n\nBy default, Elasticsearch uses adaptive replica selection to route search requests. This method selects an eligible node using shard allocation awareness and the following criteria:\n\nAdaptive replica selection is designed to decrease search latency. However, you can disable adaptive replica selection by setting to using the cluster settings API. If disabled, Elasticsearch routes search requests using a round-robin method, which may result in slower searches.\n\nBy default, adaptive replica selection chooses from all eligible nodes and shards. However, you may only want data from a local node or want to route searches to a specific node based on its hardware. Or you may want to send repeated searches to the same shard to take advantage of caching.\n\nTo limit the set of nodes and shards eligible for a search request, use the search API’s query parameter.\n\nFor example, the following request searches with a of . This restricts the search to shards on the local node. If the local node contains no shard copies of the index’s data, the request uses adaptive replica selection to another eligible node as a fallback.\n\nYou can also use the parameter to route searches to specific shards based on a provided string. If the cluster state and selected shards do not change, searches using the same string are routed to the same shards in the same order.\n\nWe recommend using a unique string, such as a user name or web session ID. This string cannot start with a .\n\nThe following request searches with a string of .\n\nWhen you index a document, you can specify an optional routing value, which routes the document to a specific shard.\n\nFor example, the following indexing request routes a document using .\n\nYou can use the same routing value in the search API’s query parameter. This ensures the search runs on the same shard used to index the document.\n\nYou can also provide multiple comma-separated routing values:\n\nBy default, Elasticsearch doesn’t reject search requests based on the number of shards the request hits. However, hitting a large number of shards can significantly increase CPU and memory usage.\n\nYou can use the query parameter to control maximum number of concurrent shards a search request can hit per node. This prevents a single request from overloading a cluster. The parameter defaults to a maximum of .\n\nYou can also use the cluster setting to set a search shard limit and reject requests that hit too many shards. You can configure using the cluster settings API."
    },
    {
        "link": "https://stackoverflow.com/questions/46808084/elasticsearch-routing-only-documents-with-one-routing-key-per-shard",
        "document": "We're currently optimzing the sharding setup of our Elasticsearch index to (surprise) decrease response times. Currently the amount of routing keys is equal to the amount of shards. We're looking for a setup, where all documents in a shard are of one routing key only.\n\nThis is how it is at the moment and how it should look like\n\nIs there any possibility to make sure, that one routing key will be routed only to one shard? Currently we're facing empty shards, which doesn't seems to be an appropriate solution.\n\nWe know that the routing is based on Murmur in version 5.50 (see: Murmur3HashFunction.java). Is there any option to influence this behavior and can someone offer deeper insights, how the routing works internally."
    },
    {
        "link": "https://geeksforgeeks.org/managing-data-distribution-and-shard-allocations",
        "document": "Sharding is a foundational concept in Elasticsearch, essential for managing and distributing data across a cluster of nodes. It is important for enhancing performance, scalability, and reliability in Elasticsearch deployments.\n\nIn this article, We will learn about the Managing data distribution and shard allocations, by understanding the Sharding in Elasticsearch, Data Distribution and Shard Allocation, Shard Allocation Strategies and Shard Allocation Awareness in detail.\n• Elasticsearch sharding plays a fundamental role in distributing and managing data across a cluster of nodes.\n• None Understanding how sharding works is crucial for optimizing performance scalability reliability\n• Sharding is the process of dividing a large dataset into smaller manageable shards . Each shard is an independent self contained index that can be distributed across multiple nodes in a cluster.\n• Elasticsearch multiple shards which are basic units of storage. Each shard is a Lucene index , capable of storing a subset of our data.\n• None When we index a document, Elasticsearch determines which shard to store it in based on a sharding algorithm which is typically using the document's ID\n• None This distribution allows Elasticsearch to scale horizontally by distributing data and queries across nodes.\n• Elasticsearch shard allocation dynamically meaning it can move shards between nodes to balance the cluster or recover from failures.\n\nElasticsearch employs several shard allocation strategies to determine where to place shards within the cluster:\n• Primary Shard Allocation: When an index is created, Elasticsearch assigns primary shards to nodes in the cluster. These primary shards are responsible for indexing and storing the initial data.\n• Replica Shard Allocation : Elasticsearch creates replica shards for each primary shard to provide fault tolerance and high availability. Replica shards are copies of primary shards that are hosted on different nodes in the cluster.\n• Shard Rebalancing : Elasticsearch continuously monitors the distribution of shards across nodes and balances the shard distribution to ensure even load distribution and optimal performance.\n\nWe can use the Elasticsearch REST API to view the shard allocation settings for an index.\n\nIn this example:\n• None The \"allocation\" section specifies the shard allocation settings for the cluster.\n• None The \"enable\" setting is set to \"all\", indicating that shard allocation is enabled for all nodes in the cluster.\n• None Elasticsearch provides the ability to define shard allocation awareness, allowing us to control how shards are distributed across different attributes of the cluster, such as availability zones or data centers.\n• None This ensures that replicas of a shard are distributed across different failure domains to improve fault tolerance.\n\nBest Practices for Managing Data Distribution and Shard Allocations\n• Monitor Shard Distribution: Regularly monitor shard distribution across nodes using tools like Kibana or the _cat/shards\n• Allocate Shards Strategically : Use shard allocation awareness to distribute shards across different failure domains to improve fault tolerance and availability. Allocate primary and replica shards to nodes with sufficient resources to handle indexing and querying workloads.\n• Plan for Growth: Consider future growth and scaling requirements when planning shard allocations and cluster architecture to ensure scalability and performance as the data volume increases.\n• Perform Regular Maintenance : Perform regular maintenance tasks such as shard rebalancing, node upgrades and index optimizations to maintain cluster health and performance.\n\nOverall, understanding the principles of sharding in Elasticsearch is important for optimizing cluster performance and scalability. Understanding how data is distributed, shard allocation strategies and best practices for managing shard distribution are key to maintaining a efficient Elasticsearch deployment. By implementing these strategies, you can ensure that your Elasticsearch cluster operates smoothly, efficiently and reliably even as your data volume and workload grow."
    }
]