[
    {
        "link": "https://developer.android.com/training/data-storage/shared-preferences",
        "document": "If you have a relatively small collection of key-values that you'd like to save, you can use the APIs. A object points to a file containing key-value pairs and provides simple methods to read and write them. Each file is managed by the framework and can be private or shared.\n\nThis page shows you how to use the APIs to store and retrieve simple values.\n\nCaution: is a modern data storage solution that you should use instead of . It builds on Kotlin coroutines and Flow, and overcomes many of the drawbacks of . is a modern data storage solution that you should use instead of. It builds on Kotlin coroutines and Flow, and overcomes many of the drawbacks of Read the DataStore guide for more information.\n\nYou can create a new shared preference file or access an existing one by calling one of these methods:\n• : Use this if you need multiple shared preference files identified by name, which you specify with the first parameter. You can call this from any in your app.\n• : Use this from an if you need to use only one shared preference file for the activity. Because this retrieves a default shared preference file that belongs to the activity, you don't need to supply a name.\n\nFor example, the following code accesses the shared preferences file that's identified by the resource string and opens it using the private mode so the file is accessible by only your app:\n\nWhen naming your shared preference files, you should use a name that's uniquely identifiable to your app. A good way to do this is prefix the file name with your application ID. For example:\n\nAlternatively, if you need just one shared preference file for your activity, you can use the method:\n\nIf you're using the API to save app settings, you should instead use to get the default shared preference file for your entire app. For more information, see the Settings developer guide.\n\nTo write to a shared preferences file, create a by calling on your .\n\nPass the keys and values you want to write with methods such as: and . Then call or to save the changes. For example:\n\nchanges the in-memory object immediately but writes the updates to disk asynchronously. Alternatively, you can use to write the data to disk synchronously. But because is synchronous, you should avoid calling it from your main thread because it could pause your UI rendering.\n\nTo retrieve values from a shared preferences file, call methods such as and , providing the key for the value you want, and optionally a default value to return if the key isn't present. For example:"
    },
    {
        "link": "https://blog.logrocket.com/android-data-storage-guide-kotlin-sharedpreferences",
        "document": "Did you ever wonder how to store some values on your application without losing them after closing the app? Android provides a way to do that if you have a small collection of key values you’d like to save!\n\nIn this article, we’ll take a look at Android’s APIs and then demonstrate how to use in a use case.\n\nJetpack DataStore is a modern solution that uses Kotlin coroutines and Flow to store data asynchronously. In the future, you might consider migrating to Jetpack DataStore from . However, in this article we’ll focus on since it remains useful and is still very popular as of this writing.\n\nis an Android API that allows you to create and access a file containing a key-values collection. A object provides some methods for reading and writing these values on the file. Each file is managed by the framework and can be private to the application or shared.\n\nTo create or access a file, you can call either of the following methods: or .\n\nUse the getSharedPreferences() method if you need to create or access a file identified by name.\n\nHere’s an example of this method:\n\nUse the getDefaultSharedPreferences() method to get the default SharedPreferences file for an entire app. You should be aware that this method requires extra dependency.\n\nThe below example of this method requires an extra dependency to be added to the file at the app module level:\n\nHere’s an example of the method:\n\nThe second parameter of the method is the mode. This parameter relates to permissions for file sharing.\n\nTo share private files with applications that do not share your user ID, you can use with Android versions older than 7.0. Android 7.0+ will throw a security exception if you attempt to use this mode; it has been deprecated since API level 17.\n\nIf you run into this issue, a workaround is to use a FileProvider with the intent set to . For more information, also see the official documentation on sharing files.\n\nTo share private files with any application that shares your user ID, you can use .\n\nTo retrieve values from a file, you can call any of the below methods, providing the key for the value you want and an optional default value to return if the key doesn’t exist:\n• Use this method to check if the preferences file contains a specific preference\n• Use this method to create a new Editor, through which you can make atomic changes to the data in the file\n• Use this method to retrieve all values in the file\n• Use this method to retrieve an value from the file\n• Use this method to retrieve a value from the file\n• Use this method to retrieve a value from the file\n• Use this method to retrieve a value from the file\n• Use this method to retrieve a value from the file\n• Use this method to retrieve a set of values from the file\n\nTo write values in a file, create a by calling on your object. With , you’ll be able to call the following methods:\n• Use this method to insert an value on the file\n• Use this method to insert a value on the file\n• Use this method to insert a value on the file\n• Use this method to insert a value on the file\n• Use this method to insert a value on the file\n• Use this method to insert a set of values on the file\n\nAfter writing changes, be sure to call or to save your changes. According to the official Android documentation, both and change the in-memory object immediately but write updates to the disk differently. writes updates asynchronously, whereas writes updates synchronously and could result in paused UI rendering if called from the main thread.\n\nHere’s an example illustrating some of the above functions to retrieve and write values in a file:\n\nTo detect changes in a file, you can call the following methods:\n• Use this method to register a callback that gets invoked when a change happens in the file\n• Use this method to unregister a callback that gets invoked when a change happens in the file\n\nNow, we’ll take a look at a common scenario in which may be useful. Let’s say you want to display an onboarding page the first time a user opens an app.\n\nTo make this work, you’ll need to have a Boolean value stored in a file indicating whether or not it is the first time a particular user has opened the app.\n\nTo start, open and add the name of our file.\n\nNext, add the following code to the file:\n\nYou’ll also need to add a key that identifies our stored value. Let’s call it .\n\nAdd the following code to the file:\n\nNow, go to your activity and add the following code inside after is called:\n\nIn the above code, we get access to the file by calling .\n\nNext, we try to get the value of our from the file. If the value is nonexistent, we return .\n\nIf we return , this is the first time the user is opening the app. In this case, we show the onboarding screen and change the value of to so the user will not see the onboarding screen again. Then, we call to conclude the changes.\n\nThat should do it!\n\nIn our use case example, we handled an onboarding screen. However, this solution works for anything that you want to be run only once, when the user opens the app for the first time.\n\nSince we’re using Kotlin, we can use its power to reduce the code length a bit with Kotlin extensions.\n\nTo use Kotlin extensions, create a separate file called and then add the following:\n\nThe above code will add an extension function called to the . The function takes a Kotlin lambda function, which is defined by curly braces and is an extension of .\n\nOn this extension function, we are already calling at the end, so there’s no need to repeat that when using this extension to add values in the file.\n\nGo back to the Activity, and replace the following code:\n\nWith the following snippet:\n\nThis shorter code should provide the same result!\n\nIn this article, we investigated and offered solutions for using the Kotlin API. We also demonstrated how to use in an example involving an onboarding screen.\n\nFor more information on this topic, check out the official docs on: SharedPreferences, Jetpack DataStore, and Kotlin extensions.\n\nThank you for reading. I hope this article makes your life easier while working with !"
    },
    {
        "link": "https://stackoverflow.com/questions/56406300/how-to-save-data-that-i-fetched-from-api-using-sharedpreferences-in-kotlin-andr",
        "document": "I have used to make an API call. Now I want to save the data using and to check Previous Promotional Data Method.. Promotional is keyword used by me.\n\nI have created a retrofit instance, declared API services and created a required function in viewmodel class. Now I have created a method in in which will be used to save data. In method, method has been created and in that I will check Previous Promotional Data Method."
    },
    {
        "link": "https://developer.android.com/codelabs/android-preferences-datastore",
        "document": "DataStore is a new and improved data storage solution aimed at replacing SharedPreferences. Built on Kotlin coroutines and Flow, DataStore provides two different implementations: Proto DataStore, that stores typed objects (backed by protocol buffers) and Preferences DataStore, that stores key-value pairs. Data is stored asynchronously, consistently, and transactionally, overcoming some of the drawbacks of SharedPreferences. This codelab focuses on Preferences DataStore. To learn hands-on how to use Proto DataStore, check out this codelab.\n• What DataStore is and why you should use it.\n• How to add DataStore to your project.\n• The differences between Preferences and Proto DataStore and the advantages of each.\n• How to use Preferences DataStore.\n• How to migrate from SharedPreferences to Preferences DataStore. What you will build In this codelab, you're going to start with a sample app that displays a list of tasks that can be filtered by their completed status and can be sorted by priority and deadline. The boolean flag for the Show completed tasks filter is saved in memory. The sort order is persisted to disk using a object. In this codelab, you will learn how to use Preferences DataStore by completing the following tasks:\n• Migrate the sort order from SharedPreferences to DataStore. We recommend working through the Proto DataStore codelab too, so you better understand the difference between the two.\n• Familiarity with the following Architecture Components: LiveData, ViewModel, View Binding and with the architecture suggested in the Guide to app architecture. For an introduction to Architecture Components, check out the Room with a View codelab. For an introduction to Flow, check out the Advanced Coroutines with Kotlin Flow and LiveData codelab.\n\nIn this step, you will download the code for the entire codelab and then run a simple example app. To get you started as quickly as possible, we have prepared a starter project for you to build on. If you have git installed, you can simply run the command below. To check whether git is installed, type in the terminal or command line and verify that it executes correctly. The initial state is in the branch. The solution code is located in the branch. If you do not have git, you can click the following button to download all of the code for this codelab:\n• Unzip the code, and then open the project in Android Studio Arctic Fox.\n• Run the app run configuration on a device or emulator. The app runs and displays the list of tasks:\n\nThe app allows you to see a list of tasks. Each task has the following properties: name, completed status, priority, and deadline. To simplify the code we need to work with, the app allows you to do only two actions:\n• Toggle Show completed tasks visibility - by default the tasks are hidden\n• Sort the tasks by priority, by deadline or by deadline and priority The app follows the architecture recommended in the Guide to app architecture. Here's what you will find in each package:\n• class - responsible for providing the tasks. For simplicity, it returns hardcoded data and exposes it via a to represent a more realistic scenario.\n• class - holds the , defined as an . The current sort order is saved in SharedPreferences as a , based on the enum value name. It exposes synchronous methods to save and get the sort order.\n• Classes related to displaying an with a .\n• The class is responsible for the UI logic. - holds all the elements necessary to build the data that needs to be displayed in the UI: the list of tasks, the and flags, wrapped in a object. Every time one of these values changes, we have to reconstruct a new . To do this, we combine 3 elements:\n• A is retrieved from the .\n• A holding the latest flag which is only kept in memory. To ensure that we're updating the UI correctly, only when the Activity is started, we expose a . We have a couple of problems with our code:\n• We block the UI thread on disk IO when initializing . This can result in UI jank.\n• The flag is only kept in memory, so this means it will be reset every time the user opens the app. Like the , this should be persisted to survive closing the app.\n• We're currently using SharedPreferences to persist data but we keep a in memory, that we modify manually, to be able to be notified of changes. This breaks easily if the value is modified somewhere else in the application.\n• In we expose two methods for updating the sort order: and . Both of these methods rely on the current sort order value but, if one is called before the other has finished, we would end up with the wrong final value. Even more, these methods can result in UI jank and Strict Mode violations as they're called on the UI thread. Let's find out how to use DataStore to help us with these issues.\n\nOften you might find yourself needing to store small or simple data sets. For this, in the past, you might have used SharedPreferences but this API also has a series of drawbacks. Jetpack DataStore library aims at addressing those issues, creating a simple, safer and asynchronous API for storing data. It provides 2 different implementations: ✅ (only for reading changed values, via listener) ✅ (but not safe to call on UI thread) ✅ (work is moved to under the hood) ✅ (work is moved to under the hood) 1 SharedPreferences has a synchronous API that can appear safe to call on the UI thread, but which actually does disk I/O operations. Furthermore, blocks the UI thread on . Pending calls are triggered every time any service starts or stops, and every time an activity starts or stops anywhere in your application. The UI thread is blocked on pending calls scheduled by , often becoming a source of ANRs. While both Preferences and Proto DataStore allow saving data, they do this in different ways:\n• Preference DataStore, like SharedPreferences, accesses data based on keys, without defining a schema upfront.\n• Proto DataStore defines the schema using Protocol buffers. Using Protobufs allows persisting strongly typed data. They are faster, smaller, simpler, and less ambiguous than XML and other similar data formats. While Proto DataStore requires you to learn a new serialization mechanism, we believe that the strongly typed advantage brought by Proto DataStore is worth it. If you have a need for partial updates, referential integrity, or large/complex datasets, you should consider using Room instead of DataStore. DataStore is ideal for small or simple datasets and does not support partial updates or referential integrity.\n\nAlthough both the and flags are user preferences, currently they're represented as two different objects. So one of our goals is to unify these two flags under a class and store it in using DataStore. Right now, the flag is kept in memory, in . Let's start by creating a data class in . For now, it should just have one field: . We'll add the sort order later. To create a DataStore instance we use the delegate, with the as receiver. For simplicity, in this codelab, let's do this in : The delegate ensures that we have a single instance of DataStore with that name in our application. Currently, is implemented as a singleton, because it holds the and avoids having it tied to the lifecycle of the . Because will just work with the data from DataStore and it won't create and hold any new objects, we can already remove the singleton implementation: The should get a instance as a constructor parameter. For now, we can leave the as a parameter as it's needed by SharedPreferences, but we'll remove it later on. In a production application, the DataStore instance should be injected as a singleton in the classes that need it, by using . Read more about dependency injection and Hilt in our docs. Let's update the construction of in and pass in the : Preferences DataStore exposes the data stored in a that will emit every time a preference has changed. We don't want to expose the entire object but rather the object. To do this, we'll have to map the , get the Boolean value we're interested in, based on a key and construct a object. So, the first thing we need to do is define the key - this is a value that we can declare as a member in a private object. Let's expose a , constructed based on , which is then mapped, to retrieve the right preference: val userPreferencesFlow: Flow<UserPreferences> = dataStore.data .map { preferences -> // Get our show completed value, defaulting to false if not set: val showCompleted = preferences[PreferencesKeys.SHOW_COMPLETED]?: false UserPreferences(showCompleted) } As DataStore reads data from a file, are thrown when an error occurs while reading data. We can handle these by using the Flow operator before and emitting in case the exception thrown was an . If a different type of exception was thrown, prefer re-throwing it. val userPreferencesFlow: Flow<UserPreferences> = dataStore.data .catch { exception -> // dataStore.data throws an IOException when an error is encountered when reading data if (exception is IOException) { emit(emptyPreferences()) } else { throw exception } }.map { preferences -> // Get our show completed value, defaulting to false if not set: val showCompleted = preferences[PreferencesKeys.SHOW_COMPLETED]?: false UserPreferences(showCompleted) } To write data, DataStore offers a suspending function, which accepts a block that allows us to transactionally update the state in DataStore. The passed to the transform block will be up-to-date with any previously run edits. All changes to in the block will be applied to disk after completes and before completes. Setting one value in will leave all other preferences unchanged. Note: do not attempt to modify the outside of the transform block. Let's create a suspend function that allows us to update the property of , called , that calls and sets the new value: can throw an if an error was encountered while reading or writing to disk. If any other error happens in the transform block, it will be thrown by . At this point, the app should compile but the functionality we just created in is not used.\n\nThe sort order is saved in SharedPreferences. Let's move it to DataStore. To do this, let's start by updating to also store the sort order: To be able to migrate it to DataStore, we need to update the dataStore builder to pass in a to the list of migrations. DataStore will be able to migrate from to DataStore automatically, for us. Migrations are run before any data access can occur in DataStore. This means that your migration must have succeeded before emits any values and before can update data. Note: keys are only migrated from SharedPreferences once, so you should discontinue using the old SharedPreferences once the code is migrated to DataStore. First, let's update the DataStore creation in : > 're migrating from SharedPreferences, add a migration based on the Then add the to our : private object PreferencesKeys { ... // Note: this has the same name that we used with SharedPreferences. val SORT_ORDER = stringPreferencesKey(\"sort_order\") } All keys will be migrated to our DataStore and deleted from the user preferences SharedPreferences. Now, from we will be able to get and update the based on the key. Let's update the to also retrieve the sort order in the transformation: val userPreferencesFlow: Flow<UserPreferences> = dataStore.data .catch { exception -> if (exception is IOException) { emit(emptyPreferences()) } else { throw exception } }.map { preferences -> // Get the sort order from preferences and convert it to a [SortOrder] object val sortOrder = SortOrder.valueOf( preferences[PreferencesKeys.SORT_ORDER] ?: SortOrder.NONE.name) // Get our show completed value, defaulting to false if not set: val showCompleted = preferences[PreferencesKeys.SHOW_COMPLETED] ?: false UserPreferences(showCompleted, sortOrder) } Currently only exposes a synchronous way to set the sort order flag and it has a concurrency problem. We expose two methods for updating the sort order: and ; both of these methods rely on the current sort order value but, if one is called before the other has finished, we would end up with the wrong final value. As DataStore guarantees that data updates happen transactionally, we won't have this problem anymore. Let's do the following changes:\n• Update and to be functions that use the .\n• In the transform block of , we'll get the from the Preferences parameter, instead of retrieving it from the field.\n• Instead of calling we can directly update the sort order in the preferences. Here's what the implementation looks like. Now you can remove the constructor parameter and all the usages of SharedPreferences."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/android-sharedpreferences-kotlin",
        "document": "In this tutorial, we’ll learn how to implement SharedPreferences in our Android Application using Kotlin.\n\nSharedPreferences is part of the Android API since API level 1. It’s an interface that allows us to store/modify/delete data locally. Generally, it is used to cache user local data such as login forms. The data is stored in the form of a key-value pair. You can create multiple files to hold the SharedPreferences data.\n\nLet’s look at some important methods for SharedPreferences.\n• method is used to retrieve an instance of the . Here is the name of the SharedPreferences file and is the Context passed.\n• The is used to edit values in the .\n• We can call or to save the values in the SharedPreferences file. The saves the values immediately whereas saves the values asynchronously.\n\nWe can set values on our SharedPreference instance using Kotlin in the following way.\n\nThe permitted types on a SharedPreference instance are:\n\nWe can also clear all the values or remove a particular value by calling and methods.\n\nNote: Changes made to the editor after the commit or apply aren’t considered. The above way to save and retrieve values from a SharedPreference is nearly the same as we do in Java. So where’s the magic of Kotlin? That’s what we’ll see next through an example android application.\n\nIn this application, we’ll have a login screen, which allows us to save/clear the form data.\n\nThe code for the layout file is given below.\n\nThe code for the Kotlin class is given below.\n\nThanks to Kotlin Android Extensions, we don’t have to use findViewById for each XML view. In the above code, we are creating a singleton class using the keyword. We are declaring an inline higher-order function named editMe(), which holds the logic for the edit operation. We’ve created separate properties for each of the values. We are using the get and set Kotlin properties to retrieve and set the data in the shared preferences. Kotlin has reduced the code verbosity and it looks much cleaner. Furthermore, we can make it more concise by using another Kotlin higher-order function shown below.\n\nAnd we do the following while setting the values:\n\nThis is as close as Kotlin can get you to the English Language. The output of the above application in action is given below.\n\nYou can download the source code from the following link: AndroidlySharedPreferences"
    },
    {
        "link": "https://medium.com/@zorbeytorunoglu/serialization-and-deserialization-on-kotlin-android-81596ac6da8e",
        "document": "Serialization and deserialization are essential processes in software development, especially for persisting objects, transferring data over networks, and saving application states. In Kotlin, there are several libraries and techniques to handle serialization and deserialization efficiently.\n• Serialization: The process of converting an object into a format that can be easily stored or transmitted (e.g., JSON, XML, binary).\n• Deserialization: The process of converting the serialized format back into an object.\n• Moshi: A modern JSON library for Android and Java from Square.\n\nKotlin Serialization is a Kotlin library developed by JetBrains, providing a native way to serialize and deserialize Kotlin objects. It is fully integrated with Kotlin's language features and provides excellent performance and ease of use.\n\nAdd the necessary dependencies to your :\n\nDefine a data class and annotate it with :\n\nGson is a Java library that can be used to convert Java Objects into their JSON representation and vice versa. It is simple to use and integrates well with Kotlin.\n\nAdd the Gson dependency to your :\n\nMoshi is another JSON library for Android and Java from Square, known for its ease of use and Kotlin support.\n\nAdd the Moshi dependency to your :\n\nJackson is a widely used JSON library for Java, known for its high performance.\n\nAdd the Jackson dependency to your :\n\nProtocol Buffers (Protobuf) is a binary serialization format developed by Google. It is more efficient than JSON for both size and speed but requires a schema definition.\n\nAdd the Protobuf dependency to your :\n\nGenerate the Java classes using the Protobuf plugin, then use them in your Kotlin code:"
    },
    {
        "link": "https://dhiwise.com/post/kotlin-gson-for-effective-json-handling",
        "document": "Passionate about designing and crafting efficient algorithms—because slow code is a crime. Thrives on optimizing performance, tackling complex problems, and transforming logic into elegant solutions. Probably refining an algorithm while sipping tea.\n\nKotlin GSON simplifies working with JSON in Kotlin projects by leveraging the popular Java library GSON.\n\nThis blog dives into the practical aspects of using GSON for JSON serialization and deserialization in Kotlin, covering key concepts like Kotlin data classes, parsing JSON, and converting JSON strings to objects.\n\nGSON, a popular Java library developed by Google, allows efficient conversion between JSON strings and Java objects. It is widely used in Android projects and Kotlin applications because it can handle complex JSON data structures, including nested objects and arrays.\n\nTo start using GSON, you must add it as a dependency in your Kotlin project. For compatibility, ensure you include the latest version of the library.\n\nFor a Gradle-based project, include the following in your file:\n\nIn Kotlin, data classes represent structured data, making them ideal for handling JSON data. To use GSON effectively, define a Kotlin data class that mirrors the structure of the JSON format you're working with.\n\nTo convert JSON into a data class object, use the Gson class. Here’s how to parse JSON in Kotlin:\n\nThis process is commonly referred to as JSON deserialization.\n\nGSON offers flexibility with annotations like to map JSON keys to Kotlin properties.\n\nThis helps when the JSON keys differ from the Kotlin property names.\n\nGiven this JSON with a nested object:\n\nFor JSON with an array:\n\nParse it into a list of data class objects:\n\nTo convert a JSON string back from a data class object, use Gson's toJson method.\n\nThis demonstrates how to handle JSON conversion in Kotlin.\n• Mapping JSON Keys to Kotlin Properties If you need to map JSON keys dynamically, consider using a custom deserializer.\n• Handling Generic Types For scenarios involving generic types, GSON supports type tokens. For example:\n\nKotlin and GSON are widely used in Android apps for handling JSON data from APIs. Incorporating GSON into your Android project involves similar steps, with additional attention to lifecycle management for efficient parsing and serialization.\n\nThis article explored the use of Kotlin GSON for handling JSON in Kotlin projects. From setting up the GSON library to defining Kotlin data classes, parsing JSON strings, and working with nested objects and arrays, it highlighted key methods to simplify JSON handling.\n\nUsing annotations like and leveraging advanced features such as generic types, Kotlin developers can streamline JSON parsing and serialization.\n\nKotlin GSON is a powerful tool for converting data between structured JSON and Kotlin objects, making it indispensable for modern development workflows, especially in Android projects.\n\nShort on time? Speed things up with DhiWise!\n\nTired of manually designing screens, coding on weekends, and technical debt? Let DhiWise handle it for you!\n\nYou can build an e-commerce store, healthcare app, portfolio, blogging website, social media or admin panel right away. Use our library of 40+ pre-built free templates to create your first application using DhiWise."
    },
    {
        "link": "https://stackoverflow.com/questions/76758590/android-kotlin-serialize-string-to-json-string-with-gson",
        "document": "Giving a string, I'd like to format it as json string with Gson.\n\nWhat I expect is from \"email\" to get \"{\"email\" : \"$email\"}\"\n\nI can obviously do\n\nand this is what I'm currently doing, and of course I could also create an \"Email\" class with just one property and use\n\nbut none of them are among my expectations. I'd like to do it with just Gson, but not sure it is really possible.\n\nto no avail. It just returns the same input string, but with double quotes inside, like \"\"email\"\".\n\nThere is no problem at all with the above function (the one I'm currently using), it's just that I'm trying to replace everything related to json serialization with Gson."
    },
    {
        "link": "https://github.com/google/gson",
        "document": "Gson is a Java library that can be used to convert Java Objects into their JSON representation. It can also be used to convert a JSON string to an equivalent Java object. Gson can work with arbitrary Java objects including pre-existing objects that you do not have source-code of.\n\nThere are a few open-source projects that can convert Java objects to JSON. However, most of them require that you place Java annotations in your classes; something that you can not do if you do not have access to the source-code. Most also do not fully support the use of Java Generics. Gson considers both of these as very important design goals.\n\nGson's main focus is on Java. Using it with other JVM languages such as Kotlin or Scala might work fine in many cases, but language-specific features such as Kotlin's non- types or constructors with default arguments are not supported. This can lead to confusing and incorrect behavior.\n\n When using languages other than Java, prefer a JSON library with explicit support for that language.\n• Provide simple and methods to convert Java objects to JSON and vice-versa\n• Allow pre-existing unmodifiable objects to be converted to and from JSON\n• Support arbitrarily complex objects (with deep inheritance hierarchies and extensive use of generic types)\n\nGson jar downloads are available from Maven Central.\n\nDespite supporting older Java versions, Gson also provides a JPMS module descriptor (module name ) for users of Java 9 or newer.\n\nThese are the optional Java Platform Module System (JPMS) JDK modules which Gson depends on. This only applies when running Java 9 or newer.\n• (optional since Gson 2.8.9)\n\n When this module is present, Gson provides default adapters for some SQL date and time classes.\n• , respectively class (optional)\n\n When this module is present, Gson can use the class to create instances of classes without no-args constructor. However, care should be taken when relying on this. is not available in all environments and its usage has some pitfalls, see .\n\nOlder Gson versions may also support lower API levels, however this has not been verified.\n• User guide: This guide contains examples on how to use Gson in your code\n• Troubleshooting guide: Describes how to solve common issues when using Gson\n• Releases and change log: Latest releases and changes in these versions; for older releases see\n• Design document: This document discusses issues we faced while designing Gson. It also includes a comparison of Gson with other Java libraries that can be used for Json conversion\n\nPlease use the 'gson' tag on StackOverflow, GitHub Discussions or the google-gson Google group to discuss Gson or to post questions.\n\nGson uses Maven to build the project:\n\nJDK 11 or newer is required for building, JDK 17 or 21 is recommended. Newer JDKs are currently not supported for building (but are supported when using Gson).\n\nSee the contributing guide.\n\n Please perform a quick search to check if there are already existing issues or pull requests related to your contribution.\n\nKeep in mind that Gson is in maintenance mode. If you want to add a new feature, please first search for existing GitHub issues, or create a new one to discuss the feature and get feedback.\n\nGson is released under the Apache 2.0 license.\n\nThis is not an officially supported Google product."
    },
    {
        "link": "https://stackoverflow.com/questions/62016702/kotlin-using-gson-to-deserialize-local-json-file",
        "document": "I want to deserialize a local json file using Gson to create a recyclerview. However I get an IllegalStateException on below line.\n\nMy json file is saved under an assets folder and believe the program reads the data fine but somehow cannot convert it into my HomeFeed model object."
    },
    {
        "link": "https://kotlinlang.org/docs/shared-mutable-state-and-concurrency.html",
        "document": "Coroutines can be executed parallelly using a multi-threaded dispatcher like the Dispatchers.Default. It presents all the usual parallelism problems. The main problem being synchronization of access to shared mutable state. Some solutions to this problem in the land of coroutines are similar to the solutions in the multi-threaded world, but others are unique.\n\nLet us launch a hundred coroutines all doing the same action a thousand times. We'll also measure their completion time for further comparisons: suspend fun massiveRun(action: suspend () -> Unit) { val n = 100 // number of coroutines to launch val k = 1000 // times an action is repeated by each coroutine val time = measureTimeMillis { coroutineScope { // scope for coroutines repeat(n) { launch { repeat(k) { action() } } } } } println(\"Completed ${n * k} actions in $time ms\") } We start with a very simple action that increments a shared mutable variable using multi-threaded Dispatchers.Default. import kotlinx.coroutines.* import kotlin.system.* suspend fun massiveRun(action: suspend () -> Unit) { val n = 100 // number of coroutines to launch val k = 1000 // times an action is repeated by each coroutine val time = measureTimeMillis { coroutineScope { // scope for coroutines repeat(n) { launch { repeat(k) { action() } } } } } println(\"Completed ${n * k} actions in $time ms\") } //sampleStart var counter = 0 fun main() = runBlocking { withContext(Dispatchers.Default) { massiveRun { counter++ } } println(\"Counter = $counter\") } //sampleEnd You can get the full code here. What does it print at the end? It is highly unlikely to ever print \"Counter = 100000\", because a hundred coroutines increment the concurrently from multiple threads without any synchronization.\n\nVolatiles are of no help There is a common misconception that making a variable solves concurrency problem. Let us try it: import kotlinx.coroutines.* import kotlin.system.* suspend fun massiveRun(action: suspend () -> Unit) { val n = 100 // number of coroutines to launch val k = 1000 // times an action is repeated by each coroutine val time = measureTimeMillis { coroutineScope { // scope for coroutines repeat(n) { launch { repeat(k) { action() } } } } } println(\"Completed ${n * k} actions in $time ms\") } //sampleStart @Volatile // in Kotlin `volatile` is an annotation var counter = 0 fun main() = runBlocking { withContext(Dispatchers.Default) { massiveRun { counter++ } } println(\"Counter = $counter\") } //sampleEnd You can get the full code here. This code works slower, but we still don't always get \"Counter = 100000\" at the end, because volatile variables guarantee linearizable (this is a technical term for \"atomic\") reads and writes to the corresponding variable, but do not provide atomicity of larger actions (increment in our case).\n\nThe general solution that works both for threads and for coroutines is to use a thread-safe (aka synchronized, linearizable, or atomic) data structure that provides all the necessary synchronization for the corresponding operations that needs to be performed on a shared state. In the case of a simple counter we can use class which has atomic operations: import kotlinx.coroutines.* import java.util.concurrent.atomic.* import kotlin.system.* suspend fun massiveRun(action: suspend () -> Unit) { val n = 100 // number of coroutines to launch val k = 1000 // times an action is repeated by each coroutine val time = measureTimeMillis { coroutineScope { // scope for coroutines repeat(n) { launch { repeat(k) { action() } } } } } println(\"Completed ${n * k} actions in $time ms\") } //sampleStart val counter = AtomicInteger() fun main() = runBlocking { withContext(Dispatchers.Default) { massiveRun { counter.incrementAndGet() } } println(\"Counter = $counter\") } //sampleEnd You can get the full code here. This is the fastest solution for this particular problem. It works for plain counters, collections, queues and other standard data structures and basic operations on them. However, it does not easily scale to complex state or to complex operations that do not have ready-to-use thread-safe implementations.\n\nThread confinement is an approach to the problem of shared mutable state where all access to the particular shared state is confined to a single thread. It is typically used in UI applications, where all UI state is confined to the single event-dispatch/application thread. It is easy to apply with coroutines by using a single-threaded context. import kotlinx.coroutines.* import kotlin.system.* suspend fun massiveRun(action: suspend () -> Unit) { val n = 100 // number of coroutines to launch val k = 1000 // times an action is repeated by each coroutine val time = measureTimeMillis { coroutineScope { // scope for coroutines repeat(n) { launch { repeat(k) { action() } } } } } println(\"Completed ${n * k} actions in $time ms\") } //sampleStart val counterContext = newSingleThreadContext(\"CounterContext\") var counter = 0 fun main() = runBlocking { withContext(Dispatchers.Default) { massiveRun { // confine each increment to a single-threaded context withContext(counterContext) { counter++ } } } println(\"Counter = $counter\") } //sampleEnd You can get the full code here. This code works very slowly, because it does fine-grained thread-confinement. Each individual increment switches from multi-threaded Dispatchers.Default context to the single-threaded context using withContext(counterContext) block.\n\nIn practice, thread confinement is performed in large chunks, e.g. big pieces of state-updating business logic are confined to the single thread. The following example does it like that, running each coroutine in the single-threaded context to start with. import kotlinx.coroutines.* import kotlin.system.* suspend fun massiveRun(action: suspend () -> Unit) { val n = 100 // number of coroutines to launch val k = 1000 // times an action is repeated by each coroutine val time = measureTimeMillis { coroutineScope { // scope for coroutines repeat(n) { launch { repeat(k) { action() } } } } } println(\"Completed ${n * k} actions in $time ms\") } //sampleStart val counterContext = newSingleThreadContext(\"CounterContext\") var counter = 0 fun main() = runBlocking { // confine everything to a single-threaded context withContext(counterContext) { massiveRun { counter++ } } println(\"Counter = $counter\") } //sampleEnd You can get the full code here. This now works much faster and produces correct result."
    },
    {
        "link": "https://discuss.kotlinlang.org/t/thread-safe-data-structures-in-kotlin/20083",
        "document": "For things like HashTable, Java docs recommends using ConcurrentHashMap instead.\n\nI thought thread-safe collections had fallen out of favor? At least I remember reading somewhere that you should try not to use them and instead synchronize the usage points.\n\nOf course, if you’re worried about thread-safety of some data than that data is probably the infamous “shared mutable state”. It might be a sign to considering changing the design to avoid shared mutable state if synchronizing the usage points is tedious.\n\nKotlin’s stdlib is small. It’s a major goal of Kotlin not to replace Java, but to integrate and interop with Java code. If there’s a Java library already available, you should use that instead of inventing a completely new wheel. And if I have an existing Java library, I should be able to add Kotlin code along side it without introducing a large stdlib. You’re somewhat expected to use the JVM stdlib (or other common platform specific libraries) in your Kotlin code.\n\nThe Kotlin stdlib has grown over the years but even still the goal is not to include everything–a lot of library additions are done as separate libraries (Kotlinx libraries). Even things such as time keeping, coroutines, and serialization aren’t included in the core stdlib."
    },
    {
        "link": "https://stackoverflow.com/questions/75128798/thread-safe-access-to-the-same-variable-from-different-flows-kotlin",
        "document": "This code is not thread safe.\n\nHowever, it is called from which runs on by default. So your inner blocks will be called sequentially. This means that after all you will get the result which is produced by second block.\n\nTo achieve asynchronous behavior, you want to use . Your code will probably fire concurrent modification exception in that case.\n\nTo synchronize it, you may want to use Java's which blocks the list while one thread is performing operations with it, so the other thread are not able to perform modifications.\n\nAfter all, I am struggling to imagine real life example in which you will actually use that code. You probably don't need asynchronous behavior, you will be fine without using two launch blocks. Or you should rethink your design to avoid need of manual synchronization of two coroutines."
    },
    {
        "link": "https://stackoverflow.com/questions/68009935/safe-to-use-non-thread-safe-mutablemap-in-suspend-function",
        "document": "\n• No, it is not safe to use a single from multiple coroutines.\n• You understand suspending incorrectly. This is not function that is suspended. The coroutine running in the function could suspend. From this perspective suspending functions aren't really different than normal functions - they could be executed by many coroutines at the same time and all of them will work concurrently.\n\nBut... there is nothing wrong with your code for another reason. This mutable map is a local variable, so it is only available to the coroutine/thread that created it. Therefore, it is not accessed concurrently at all. It would be different if the map would be a property of - then it might mean you need to use .\n\nAfter reading all comments I believe I have a better understanding of your (or your friend) concerns, so I can provide a more accurate answer.\n\nYes, after suspending a coroutine it can resume from another thread, so coroutines make possible that some part of a function will be executed by one thread and other part will be executed by another thread. In your example it is possible that and will be invoked from two different threads.\n\nHowever, saying that is not thread-safe doesn't mean, that it has to be always accessed by the same thread. It can be accessed by multiple threads, but not at the same time. One thread need to finish performing changes to the map and only then another thread can perform its modifications.\n\nNow, in your code blocks can work in parallel to each other. They can also work in parallel to the outer scope. But the contents of each of them works sequentially. line can only be executed after fully finishes, so the map is not accessed by multiple threads at the same time.\n\nAs stated earlier, it would be different if the map would be stored e.g. as a property, would modify it and this function would be invoked multiple times in parallel - then each invocation would try to modify it at the same time. It would be also different if async operations would modify directly. As I said, async blocks run in parallel to each other, so they could modify the map at the same time. But since you only return a result from async blocks and then modify the map from a single coroutine (from outer scope), the map is accessed sequentially, not concurrently."
    },
    {
        "link": "https://dhiwise.com/post/kotlin-volatile-vs-synchronized-ensuring-thread-safety",
        "document": "Passionate about building intelligent systems and pushing the boundaries of AI. Always curious, always evolving—turning ideas into reality with precision and speed.\n\nConcurrency in software development allows multiple threads to execute tasks simultaneously, enhancing performance and efficiency. Kotlin, a statically typed language that runs on the Java Virtual Machine (JVM), provides various mechanisms to handle concurrency, ensuring that applications can manage multiple threads safely and effectively. Among these mechanisms, the volatile and synchronized keywords play crucial roles.\n\nUnderstanding how to use \"kotlin volatile vs synchronized\" effectively is essential for Kotlin developers who need to manage thread-safe operations and ensure that all threads see the most recent values of variables.\n\nIn Kotlin, the volatile keyword is a field modifier used primarily to indicate that a variable's value will be modified by different threads. Declaring a variable as volatile ensures that its value is always read from the main memory, and not from a thread's local cache. This is crucial in multi-threaded environments where threads may cache variables locally, leading to situations where a thread might not see the latest value written by another thread.\n\nIn this example, the counter variable is marked with the volatile keyword, ensuring that every thread accessing it sees the most recent value.\n\nThe use of volatile variables is particularly important in scenarios where the state needs to be shared across multiple threads without implementing a full synchronization protocol. This typically includes cases like:\n• Publishing immutable objects that other threads need to see (e.g., configuration data).\n\nThe volatile keyword plays a pivotal role in memory visibility among multiple threads. It provides a lighter-weight alternative to synchronization, which can be more costly in terms of performance and complexity. When a field is declared as volatile, Kotlin guarantees that any write to that variable will happen-before any subsequent read of that variable. This ensures all threads see the same value of the volatile variable and not a value from their local cache.\n• Visibility: As soon as a volatile variable is updated, the new value is immediately made visible to other threads. This is essential when multiple threads are expected to read the same variable, ensuring they all see the latest value.\n• Prevention of Reordering: Compilers often reorder instructions for efficiency. However, with volatile variables, Kotlin ensures that the code's execution order around the volatile read/write operations remains consistent across all threads.\n\nHere's a simple scenario illustrating the effect of volatile on memory visibility:\n\nIn this example, the ready variable is marked as volatile. Even though the first thread is looping until ready becomes true, it will immediately see the change made by the main thread due to the volatile keyword. This prevents a common issue in multithreading where a thread might continue reading an old value and potentially cause a never-ending loop or incorrect behavior.\n\nIn Kotlin, as in Java, the synchronized keyword is used to control access to a method or a block of code by multiple threads. When a method or a block of code is declared with the synchronized keyword, it ensures that only one thread can execute it at a time. This mutual exclusion is crucial when threads share the same resources or data, as it prevents race conditions and ensures thread safety.\n\nIn this example, the increment method is marked with the @Synchronized annotation, ensuring that only one thread can increment the count variable at a time. This is equivalent to synchronizing on the instance of the class containing the method.\n\nHere, the printMessage method includes a synchronized block. This block locks on the current instance (this), ensuring that no two threads can execute the block concurrently.\n\nThe synchronized keyword is essential for achieving thread safety in Kotlin. It prevents multiple threads from interfering with each other and from corrupting shared data.\n\nIn this example, both put and take methods of MessageQueue are synchronized. This ensures that adding to the queue and removing from the queue cannot occur simultaneously, preventing data corruption. Moreover, it uses wait and notify methods for efficient thread communication, allowing threads to wait for conditions to be met, like the queue having items to process.\n\nThe use of synchronized provides a reliable way to lock critical sections of code where variables are updated or checked, which could otherwise lead to inconsistencies if accessed by multiple threads concurrently. By implementing the synchronized keyword in Kotlin, developers can ensure that operations on shared resources are atomic, meaning they are executed as a single, indivisible operation, providing safety and reliability in concurrent applications.\n\nBoth the synchronized methods and blocks form a fundamental part of implementing thread safety in Kotlin, especially when complex operations or multiple resource manipulations need to be protected against concurrent access. This robust synchronization technique ensures that despite multiple threads executing, the integrity and state of shared objects are maintained correctly across the application.\n\nWhen choosing between volatile and synchronized in Kotlin, understanding their impact on performance is crucial. Both keywords aim to solve concurrency problems but do so in different ways that affect performance.\n• The volatile keyword is generally less costly in terms of system resources compared to synchronized because it does not involve locking. Instead, it prevents the caching of variables by threads and ensures visibility of changes across threads by reading and writing directly to and from the main memory.\n• However, volatile is limited to variable operations and is only effective for simple read and write operations. It does not perform well if multiple operations or operations on multiple variables need to be atomic.\n• The synchronized keyword can significantly affect performance because it involves locking. Whenever a synchronized block or method is accessed, a lock must be acquired, which can delay thread execution, especially if the lock is frequently contested by multiple threads.\n• Despite this overhead, synchronized provides a higher degree of thread safety by ensuring that only one thread can execute a block or method at any given time, thus preventing race conditions effectively.\n\nIn this example, incrementVolatile will execute faster than incrementSynchronized under low contention because it does not require locking mechanisms, only ensuring memory visibility. However, as contention increases, the cost of acquiring and releasing locks in incrementSynchronized might become significant, affecting performance.\n\nWhen to use Volatile:\n• Use volatile when you need to ensure that changes to a single variable are immediately visible to other threads. It is suitable for flags or simple status variables.\n• It is ideal for low-contention environments where the overhead of locking is unnecessary and could degrade performance.\n\nWhen to use Synchronized:\n• Use synchronized when working with complex operations or multiple operations that must be executed atomically. This includes modifying multiple variables or performing operations that must see a consistent state of the object.\n• It is crucial when you need to execute a sequence of operations that depend on each other, which volatile cannot guarantee.\n\nIn this Account example, synchronized is necessary to ensure that deposit and withdrawal operations are thread-safe, preventing possible data inconsistencies due to concurrent modifications. Choosing between volatile and synchronized depends largely on the specific requirements of your application regarding thread safety, the complexity of operations, and performance considerations. Volatile is preferred for single variable updates for its lightweight nature, while synchronized is indispensable for ensuring full atomicity and coordination across multiple operations or variables.\n\nBest Practices for Using Volatile and Synchronized\n\nWhen developing concurrent applications in Kotlin, understanding when and how to use volatile and synchronized is fundamental to ensuring your applications are robust, safe, and performant. Here are some best practices to consider:\n• Use volatile when dealing with simple flags or state variables that are accessed by multiple threads. Remember, volatile ensures visibility but not atomicity for compound actions.\n• Employ synchronized for complex interactions involving more than one variable or when operations need to be completed without interference from other threads. This ensures both visibility and atomicity.\n• Minimize locking overhead by keeping the synchronized blocks as short and simple as possible, especially in high-contention environments.\n• Avoid common pitfalls such as locking on mutable objects or introducing unnecessary synchronization that can lead to deadlocks or performance bottlenecks.\n• Test thoroughly in a multi-threaded context to ensure that the synchronization strategy is effective and does not introduce concurrency bugs like race conditions, deadlocks, or livelocks.\n\nIn conclusion, the choice between volatile and synchronized in Kotlin should be guided by the specific needs of your application concerning thread safety and performance. While volatile is excellent for individual variable updates requiring visibility, synchronized is essential for more complex operations or sequences of operations that require full exclusivity.\n\nFor developers aiming to write clean, efficient, and safe concurrent code in Kotlin, mastering these keywords is crucial. By leveraging volatile and synchronized appropriately, you can enhance the reliability and scalability of your Kotlin applications, ensuring that they perform well under various concurrent scenarios.\n\nShort on time? Speed things up with DhiWise!\n\nTired of manually designing screens, coding on weekends, and technical debt? Let DhiWise handle it for you!\n\nYou can build an e-commerce store, healthcare app, portfolio, blogging website, social media or admin panel right away. Use our library of 40+ pre-built free templates to create your first application using DhiWise."
    }
]