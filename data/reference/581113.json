[
    {
        "link": "https://gnu.org/s/bash/manual/bash.html",
        "document": "This text is a brief description of the features that are present in the Bash shell (version 5.2, 19 September 2022). The Bash home page is http://www.gnu.org/software/bash/.\n\nThis is Edition 5.2, last updated 19 September 2022, of , for , Version 5.2.\n\nBash contains features that appear in other popular shells, and some features that only appear in Bash. Some of the shells that Bash has borrowed concepts from are the Bourne Shell ( ), the Korn Shell ( ), and the C-shell ( and its successor, ). The following menu breaks the features up into categories, noting which features were inspired by other shells and which are specific to Bash.\n\nThis manual is meant as a brief introduction to features found in Bash. The Bash manual page should be used as the definitive reference on shell behavior.\n\nNext: Indexes, Previous: Major Differences From The Bourne Shell, Up: Bash Features [Contents][Index] Copyright © 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc. http://fsf.org/ Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.\n• PREAMBLE The purpose of this License is to make a manual, textbook, or other functional and useful document free in the sense of freedom: to assure everyone the effective freedom to copy and redistribute it, with or without modifying it, either commercially or noncommercially. Secondarily, this License preserves for the author and publisher a way to get credit for their work, while not being considered responsible for modifications made by others. This License is a kind of “copyleft”, which means that derivative works of the document must themselves be free in the same sense. It complements the GNU General Public License, which is a copyleft license designed for free software. We have designed this License in order to use it for manuals for free software, because free software needs free documentation: a free program should come with manuals providing the same freedoms that the software does. But this License is not limited to software manuals; it can be used for any textual work, regardless of subject matter or whether it is published as a printed book. We recommend this License principally for works whose purpose is instruction or reference.\n• APPLICABILITY AND DEFINITIONS This License applies to any manual or other work, in any medium, that contains a notice placed by the copyright holder saying it can be distributed under the terms of this License. Such a notice grants a world-wide, royalty-free license, unlimited in duration, to use that work under the conditions stated herein. The “Document”, below, refers to any such manual or work. Any member of the public is a licensee, and is addressed as “you”. You accept the license if you copy, modify or distribute the work in a way requiring permission under copyright law. A “Modified Version” of the Document means any work containing the Document or a portion of it, either copied verbatim, or with modifications and/or translated into another language. A “Secondary Section” is a named appendix or a front-matter section of the Document that deals exclusively with the relationship of the publishers or authors of the Document to the Document’s overall subject (or to related matters) and contains nothing that could fall directly within that overall subject. (Thus, if the Document is in part a textbook of mathematics, a Secondary Section may not explain any mathematics.) The relationship could be a matter of historical connection with the subject or with related matters, or of legal, commercial, philosophical, ethical or political position regarding them. The “Invariant Sections” are certain Secondary Sections whose titles are designated, as being those of Invariant Sections, in the notice that says that the Document is released under this License. If a section does not fit the above definition of Secondary then it is not allowed to be designated as Invariant. The Document may contain zero Invariant Sections. If the Document does not identify any Invariant Sections then there are none. The “Cover Texts” are certain short passages of text that are listed, as Front-Cover Texts or Back-Cover Texts, in the notice that says that the Document is released under this License. A Front-Cover Text may be at most 5 words, and a Back-Cover Text may be at most 25 words. A “Transparent” copy of the Document means a machine-readable copy, represented in a format whose specification is available to the general public, that is suitable for revising the document straightforwardly with generic text editors or (for images composed of pixels) generic paint programs or (for drawings) some widely available drawing editor, and that is suitable for input to text formatters or for automatic translation to a variety of formats suitable for input to text formatters. A copy made in an otherwise Transparent file format whose markup, or absence of markup, has been arranged to thwart or discourage subsequent modification by readers is not Transparent. An image format is not Transparent if used for any substantial amount of text. A copy that is not “Transparent” is called “Opaque”. Examples of suitable formats for Transparent copies include plain ASCII without markup, Texinfo input format, LaTeX input format, or using a publicly available , and standard-conforming simple , PostScript or designed for human modification. Examples of transparent image formats include , and . Opaque formats include proprietary formats that can be read and edited only by proprietary word processors, or for which the and/or processing tools are not generally available, and the machine-generated , PostScript or produced by some word processors for output purposes only. The “Title Page” means, for a printed book, the title page itself, plus such following pages as are needed to hold, legibly, the material this License requires to appear in the title page. For works in formats which do not have any title page as such, “Title Page” means the text near the most prominent appearance of the work’s title, preceding the beginning of the body of the text. The “publisher” means any person or entity that distributes copies of the Document to the public. A section “Entitled XYZ” means a named subunit of the Document whose title either is precisely XYZ or contains XYZ in parentheses following text that translates XYZ in another language. (Here XYZ stands for a specific section name mentioned below, such as “Acknowledgements”, “Dedications”, “Endorsements”, or “History”.) To “Preserve the Title” of such a section when you modify the Document means that it remains a section “Entitled XYZ” according to this definition. The Document may include Warranty Disclaimers next to the notice which states that this License applies to the Document. These Warranty Disclaimers are considered to be included by reference in this License, but only as regards disclaiming warranties: any other implication that these Warranty Disclaimers may have is void and has no effect on the meaning of this License.\n• VERBATIM COPYING You may copy and distribute the Document in any medium, either commercially or noncommercially, provided that this License, the copyright notices, and the license notice saying this License applies to the Document are reproduced in all copies, and that you add no other conditions whatsoever to those of this License. You may not use technical measures to obstruct or control the reading or further copying of the copies you make or distribute. However, you may accept compensation in exchange for copies. If you distribute a large enough number of copies you must also follow the conditions in section 3. You may also lend copies, under the same conditions stated above, and you may publicly display copies.\n• COPYING IN QUANTITY If you publish printed copies (or copies in media that commonly have printed covers) of the Document, numbering more than 100, and the Document’s license notice requires Cover Texts, you must enclose the copies in covers that carry, clearly and legibly, all these Cover Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on the back cover. Both covers must also clearly and legibly identify you as the publisher of these copies. The front cover must present the full title with all words of the title equally prominent and visible. You may add other material on the covers in addition. Copying with changes limited to the covers, as long as they preserve the title of the Document and satisfy these conditions, can be treated as verbatim copying in other respects. If the required texts for either cover are too voluminous to fit legibly, you should put the first ones listed (as many as fit reasonably) on the actual cover, and continue the rest onto adjacent pages. If you publish or distribute Opaque copies of the Document numbering more than 100, you must either include a machine-readable Transparent copy along with each Opaque copy, or state in or with each Opaque copy a computer-network location from which the general network-using public has access to download using public-standard network protocols a complete Transparent copy of the Document, free of added material. If you use the latter option, you must take reasonably prudent steps, when you begin distribution of Opaque copies in quantity, to ensure that this Transparent copy will remain thus accessible at the stated location until at least one year after the last time you distribute an Opaque copy (directly or through your agents or retailers) of that edition to the public. It is requested, but not required, that you contact the authors of the Document well before redistributing any large number of copies, to give them a chance to provide you with an updated version of the Document.\n• MODIFICATIONS You may copy and distribute a Modified Version of the Document under the conditions of sections 2 and 3 above, provided that you release the Modified Version under precisely this License, with the Modified Version filling the role of the Document, thus licensing distribution and modification of the Modified Version to whoever possesses a copy of it. In addition, you must do these things in the Modified Version:\n• Use in the Title Page (and on the covers, if any) a title distinct from that of the Document, and from those of previous versions (which should, if there were any, be listed in the History section of the Document). You may use the same title as a previous version if the original publisher of that version gives permission.\n• List on the Title Page, as authors, one or more persons or entities responsible for authorship of the modifications in the Modified Version, together with at least five of the principal authors of the Document (all of its principal authors, if it has fewer than five), unless they release you from this requirement.\n• State on the Title page the name of the publisher of the Modified Version, as the publisher.\n• Preserve all the copyright notices of the Document.\n• Add an appropriate copyright notice for your modifications adjacent to the other copyright notices.\n• Include, immediately after the copyright notices, a license notice giving the public permission to use the Modified Version under the terms of this License, in the form shown in the Addendum below.\n• Preserve in that license notice the full lists of Invariant Sections and required Cover Texts given in the Document’s license notice.\n• Include an unaltered copy of this License.\n• Preserve the section Entitled “History”, Preserve its Title, and add to it an item stating at least the title, year, new authors, and publisher of the Modified Version as given on the Title Page. If there is no section Entitled “History” in the Document, create one stating the title, year, authors, and publisher of the Document as given on its Title Page, then add an item describing the Modified Version as stated in the previous sentence.\n• Preserve the network location, if any, given in the Document for public access to a Transparent copy of the Document, and likewise the network locations given in the Document for previous versions it was based on. These may be placed in the “History” section. You may omit a network location for a work that was published at least four years before the Document itself, or if the original publisher of the version it refers to gives permission.\n• For any section Entitled “Acknowledgements” or “Dedications”, Preserve the Title of the section, and preserve in the section all the substance and tone of each of the contributor acknowledgements and/or dedications given therein.\n• Preserve all the Invariant Sections of the Document, unaltered in their text and in their titles. Section numbers or the equivalent are not considered part of the section titles.\n• Delete any section Entitled “Endorsements”. Such a section may not be included in the Modified Version.\n• Do not retitle any existing section to be Entitled “Endorsements” or to conflict in title with any Invariant Section. If the Modified Version includes new front-matter sections or appendices that qualify as Secondary Sections and contain no material copied from the Document, you may at your option designate some or all of these sections as invariant. To do this, add their titles to the list of Invariant Sections in the Modified Version’s license notice. These titles must be distinct from any other section titles. You may add a section Entitled “Endorsements”, provided it contains nothing but endorsements of your Modified Version by various parties—for example, statements of peer review or that the text has been approved by an organization as the authoritative definition of a standard. You may add a passage of up to five words as a Front-Cover Text, and a passage of up to 25 words as a Back-Cover Text, to the end of the list of Cover Texts in the Modified Version. Only one passage of Front-Cover Text and one of Back-Cover Text may be added by (or through arrangements made by) any one entity. If the Document already includes a cover text for the same cover, previously added by you or by arrangement made by the same entity you are acting on behalf of, you may not add another; but you may replace the old one, on explicit permission from the previous publisher that added the old one. The author(s) and publisher(s) of the Document do not by this License give permission to use their names for publicity for or to assert or imply endorsement of any Modified Version.\n• COMBINING DOCUMENTS You may combine the Document with other documents released under this License, under the terms defined in section 4 above for modified versions, provided that you include in the combination all of the Invariant Sections of all of the original documents, unmodified, and list them all as Invariant Sections of your combined work in its license notice, and that you preserve all their Warranty Disclaimers. The combined work need only contain one copy of this License, and multiple identical Invariant Sections may be replaced with a single copy. If there are multiple Invariant Sections with the same name but different contents, make the title of each such section unique by adding at the end of it, in parentheses, the name of the original author or publisher of that section if known, or else a unique number. Make the same adjustment to the section titles in the list of Invariant Sections in the license notice of the combined work. In the combination, you must combine any sections Entitled “History” in the various original documents, forming one section Entitled “History”; likewise combine any sections Entitled “Acknowledgements”, and any sections Entitled “Dedications”. You must delete all sections Entitled “Endorsements.”\n• COLLECTIONS OF DOCUMENTS You may make a collection consisting of the Document and other documents released under this License, and replace the individual copies of this License in the various documents with a single copy that is included in the collection, provided that you follow the rules of this License for verbatim copying of each of the documents in all other respects. You may extract a single document from such a collection, and distribute it individually under this License, provided you insert a copy of this License into the extracted document, and follow this License in all other respects regarding verbatim copying of that document.\n• AGGREGATION WITH INDEPENDENT WORKS A compilation of the Document or its derivatives with other separate and independent documents or works, in or on a volume of a storage or distribution medium, is called an “aggregate” if the copyright resulting from the compilation is not used to limit the legal rights of the compilation’s users beyond what the individual works permit. When the Document is included in an aggregate, this License does not apply to the other works in the aggregate which are not themselves derivative works of the Document. If the Cover Text requirement of section 3 is applicable to these copies of the Document, then if the Document is less than one half of the entire aggregate, the Document’s Cover Texts may be placed on covers that bracket the Document within the aggregate, or the electronic equivalent of covers if the Document is in electronic form. Otherwise they must appear on printed covers that bracket the whole aggregate.\n• TRANSLATION Translation is considered a kind of modification, so you may distribute translations of the Document under the terms of section 4. Replacing Invariant Sections with translations requires special permission from their copyright holders, but you may include translations of some or all Invariant Sections in addition to the original versions of these Invariant Sections. You may include a translation of this License, and all the license notices in the Document, and any Warranty Disclaimers, provided that you also include the original English version of this License and the original versions of those notices and disclaimers. In case of a disagreement between the translation and the original version of this License or a notice or disclaimer, the original version will prevail. If a section in the Document is Entitled “Acknowledgements”, “Dedications”, or “History”, the requirement (section 4) to Preserve its Title (section 1) will typically require changing the actual title.\n• TERMINATION You may not copy, modify, sublicense, or distribute the Document except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense, or distribute it is void, and will automatically terminate your rights under this License. However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation. Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice. Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, receipt of a copy of some or all of the same material does not give you any rights to use it.\n• FUTURE REVISIONS OF THIS LICENSE The Free Software Foundation may publish new, revised versions of the GNU Free Documentation License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. See http://www.gnu.org/copyleft/. Each version of the License is given a distinguishing version number. If the Document specifies that a particular numbered version of this License “or any later version” applies to it, you have the option of following the terms and conditions either of that specified version or of any later version that has been published (not as a draft) by the Free Software Foundation. If the Document does not specify a version number of this License, you may choose any version ever published (not as a draft) by the Free Software Foundation. If the Document specifies that a proxy can decide which future versions of this License can be used, that proxy’s public statement of acceptance of a version permanently authorizes you to choose that version for the Document.\n• RELICENSING “Massive Multiauthor Collaboration Site” (or “MMC Site”) means any World Wide Web server that publishes copyrightable works and also provides prominent facilities for anybody to edit those works. A public wiki that anybody can edit is an example of such a server. A “Massive Multiauthor Collaboration” (or “MMC”) contained in the site means any set of copyrightable works thus published on the MMC site. “CC-BY-SA” means the Creative Commons Attribution-Share Alike 3.0 license published by Creative Commons Corporation, a not-for-profit corporation with a principal place of business in San Francisco, California, as well as future copyleft versions of that license published by that same organization. “Incorporate” means to publish or republish a Document, in whole or in part, as part of another Document. An MMC is “eligible for relicensing” if it is licensed under this License, and if all works that were first published under this License somewhere other than this MMC, and subsequently incorporated in whole or in part into the MMC, (1) had no cover texts or invariant sections, and (2) were thus incorporated prior to November 1, 2008. The operator of an MMC Site may republish an MMC contained in the site under CC-BY-SA on the same site at any time before August 1, 2009, provided the MMC is eligible for relicensing. ADDENDUM: How to use this License for your documents To use this License in a document you have written, include a copy of the License in the document and put the following copyright and license notices just after the title page: Copyright (C) . Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of the license is included in the section entitled ``GNU Free Documentation License''. If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts, replace the “with…Texts.” line with this: with the Invariant Sections being , with the Front-Cover Texts being , and with the Back-Cover Texts being . If you have Invariant Sections without Cover Texts, or some other combination of the three, merge those two alternatives to suit the situation. If your document contains nontrivial examples of program code, we recommend releasing these examples in parallel under your choice of free software license, such as the GNU General Public License, to permit their use in free software."
    },
    {
        "link": "https://gnu.org/s/bash/manual/html_node/Bash-Conditional-Expressions.html",
        "document": "Conditional expressions are used by the compound command (see Conditional Constructs) and the and builtin commands (see Bourne Shell Builtins). The and commands determine their behavior based on the number of arguments; see the descriptions of those commands for any other command-specific actions.\n\nExpressions may be unary or binary, and are formed from the following primaries. Unary expressions are often used to examine the status of a file. There are string operators and numeric comparison operators as well. Bash handles several filenames specially when they are used in expressions. If the operating system on which Bash is running provides these special files, Bash will use them; otherwise it will emulate them internally with this behavior: If the argument to one of the primaries is of the form , then file descriptor is checked. If the argument to one of the primaries is one of , , or , file descriptor 0, 1, or 2, respectively, is checked.\n\nWhen used with , the ‘ ’ and ‘ ’ operators sort lexicographically using the current locale. The command uses ASCII ordering.\n\nUnless otherwise specified, primaries that operate on files follow symbolic links and operate on the target of the link, rather than the link itself.\n\nTrue if exists and is a block special file. True if exists and is a character special file. True if exists and is a directory. True if exists and is a regular file. True if exists and its set-group-id bit is set. True if exists and is a symbolic link. True if exists and its \"sticky\" bit is set. True if exists and is a named pipe (FIFO). True if exists and is readable. True if exists and has a size greater than zero. True if file descriptor is open and refers to a terminal. True if exists and its set-user-id bit is set. True if exists and is writable. True if exists and is executable. True if exists and is owned by the effective group id. True if exists and is a symbolic link. True if exists and has been modified since it was last read. True if exists and is owned by the effective user id. True if exists and is a socket. True if and refer to the same device and inode numbers. True if is newer (according to modification date) than , or if exists and does not. True if is older than , or if exists and does not. True if the shell option is enabled. The list of options appears in the description of the option to the builtin (see The Set Builtin). True if the shell variable is set (has been assigned a value). True if the shell variable is set and is a name reference. True if the length of is zero. True if the length of is non-zero. True if the strings are equal. When used with the command, this performs pattern matching as described above (see Conditional Constructs). ‘ ’ should be used with the command for POSIX conformance. True if the strings are not equal. is one of ‘ ’, ‘ ’, ‘ ’, ‘ ’, ‘ ’, or ‘ ’. These arithmetic binary operators return true if is equal to, not equal to, less than, less than or equal to, greater than, or greater than or equal to , respectively. and may be positive or negative integers. When used with the command, and are evaluated as arithmetic expressions (see Shell Arithmetic)."
    },
    {
        "link": "https://freecodecamp.org/news/bash-scripting-tutorial-linux-shell-script-and-command-line-for-beginners",
        "document": "In Linux, process automation relies heavily on shell scripting. This involves creating a file containing a series of commands that can be executed together.\n\nIn this article, we'll start with the basics of bash scripting which includes variables, commands, inputs/ outputs, and debugging. We'll also see examples of each along the way.\n• How to Get Started with Bash Scripting\n• How to Run Bash Commands from the Command Line\n• How to Create and Execute Bash Scripts\n• How to Schedule Scripts using cron\n• How to Debug and Troubleshoot Bash Scripts\n• Resources for learning more about Bash scripting\n\nTo follow along with this tutorial, you should have the following accesses:\n• A running version of Linux with access to the command line.\n\nIf you do not have Linux installed or you are just starting out, you can easily access the Linux command line through Replit. Replit is a browser-based IDE where you can access the bash shell in a few minutes.\n\nYou can also install Linux on top of your Windows system using WSL (Windows Subsystem for Linux). Here is a tutorial for that.\n\nA bash script is a file containing a sequence of commands that are executed by the bash program line by line. It allows you to perform a series of actions, such as navigating to a specific directory, creating a folder, and launching a process using the command line.\n\nBy saving these commands in a script, you can repeat the same sequence of steps multiple times and execute them by running the script.\n\nBash scripting is a powerful and versatile tool for automating system administration tasks, managing system resources, and performing other routine tasks in Unix/Linux systems. Some advantages of shell scripting are:\n• Automation: Shell scripts allow you to automate repetitive tasks and processes, saving time and reducing the risk of errors that can occur with manual execution.\n• Portability: Shell scripts can be run on various platforms and operating systems, including Unix, Linux, macOS, and even Windows through the use of emulators or virtual machines.\n• Flexibility: Shell scripts are highly customizable and can be easily modified to suit specific requirements. They can also be combined with other programming languages or utilities to create more powerful scripts.\n• Accessibility: Shell scripts are easy to write and don't require any special tools or software. They can be edited using any text editor, and most operating systems have a built-in shell interpreter.\n• Integration: Shell scripts can be integrated with other tools and applications, such as databases, web servers, and cloud services, allowing for more complex automation and system management tasks.\n• Debugging: Shell scripts are easy to debug, and most shells have built-in debugging and error-reporting tools that can help identify and fix issues quickly.\n\nThe terms \"shell\" and \"bash\" are used interchangeably. But there is a subtle difference between the two.\n\nThe term \"shell\" refers to a program that provides a command-line interface for interacting with an operating system. Bash (Bourne-Again SHell) is one of the most commonly used Unix/Linux shells and is the default shell in many Linux distributions.\n\nA shell or command-line interface looks like this:\n\nThe shell accepts commands from the user and displays the output\n\nIn the above output, is the shell prompt. When a shell is used interactively, it displays a when it is waiting for a command from the user.\n\nIf the shell is running as root (a user with administrative rights), the prompt is changed to . The superuser shell prompt looks like this:\n\nAlthough Bash is a type of shell, there are other shells available as well, such as Korn shell (ksh), C shell (csh), and Z shell (zsh). Each shell has its own syntax and set of features, but they all share the common purpose of providing a command-line interface for interacting with the operating system.\n\nYou can determine your shell type using the command:\n\nHere is the output for me:\n\nIn summary, while \"shell\" is a broad term that refers to any program that provides a command-line interface, \"Bash\" is a specific type of shell that is widely used in Unix/Linux systems.\n\nNote: In this tutorial, we will be using the \"bash\" shell.\n\nHow to Get Started with Bash Scripting\n\nAs mentioned earlier, the shell prompt looks something like this:\n\nYou can enter any command after the sign and see the output on the terminal.\n\nLet's discuss a few basic bash commands and see their outputs. Make sure to follow along :)\n• : Lists the contents of the current directory.\n• : Prints a string of text, or value of a variable to the terminal.\n\nYou can always refer to a commands manual with the command.\n\nFor example, the manual for looks something like this:\n\nYou can see options for a command in detail using\n\nHow to Create and Execute Bash scripts\n\nBy naming convention, bash scripts end with . However, bash scripts can run perfectly fine without the extension.\n\nBash scripts start with a . Shebang is a combination of and followed by the bash shell path. This is the first line of the script. Shebang tells the shell to execute it via bash shell. Shebang is simply an absolute path to the bash interpreter.\n\nBelow is an example of the shebang statement.\n\nYou can find your bash shell path (which may vary from the above) using the command:\n\nOur first script prompts the user to enter a path. In return, its contents will be listed.\n\nCreate a file named using the command. You can use any editor of your choice.\n\nAdd the following commands in your file and save it:\n\nLet's take a deeper look at the script line by line. I am displaying the same script again, but this time with line numbers.\n• Line #1: The shebang ( ) points toward the bash shell path.\n• Line #2: The command is displaying the current date and time on the terminal. Note that the is in backticks.\n• Line #4: We want the user to enter a valid path.\n• Line #5: The command reads the input and stores it in the variable .\n• line #8: The command takes the variable with the stored path and displays the current files and folders.\n\nTo make the script executable, assign execution rights to your user using this command:\n• modifies the ownership of a file for the current user : .\n• adds the execution rights to the current user. This means that the user who is the owner can now run the script.\n• is the file we wish to run.\n\nYou can run the script using any of the mentioned methods:\n\nLet's see it running in action 🚀\n\nComments start with a in bash scripting. This means that any line that begins with a is a comment and will be ignored by the interpreter.\n\nComments are very helpful in documenting the code, and it is a good practice to add them to help others understand the code.\n\nThese are examples of comments:\n\nVariables let you store data. You can use variables to read, access, and manipulate data throughout your script.\n\nThere are no data types in Bash. In Bash, a variable is capable of storing numeric values, individual characters, or strings of characters.\n\nIn Bash, you can use and set the variable values in the following ways:\n• Assign the value based on the output obtained from a program or command, using command substitution. Note that is required to access an existing variable's value.\n\nTo access the variable value, append to the variable name.\n\nIn Bash scripting, the following are the variable naming conventions:\n• Variable names should start with a letter or an underscore ( ).\n• Variable names can contain letters, numbers, and underscores ( ).\n• Variable names should not contain spaces or special characters.\n• Use descriptive names that reflect the purpose of the variable.\n• Avoid using reserved keywords, such as , , , , and so on as variable names.\n\nHere are some examples of valid variable names in Bash:\n\nAnd here are some examples of invalid variable names:\n\nFollowing these naming conventions helps make Bash scripts more readable and easier to maintain.\n\nIn this section, we'll discuss some methods to provide input to our scripts.\n• Reading the user input and storing it in a variable\n\nWe can read the user input using the command.\n\nThis code reads each line from a file named and prints it to the terminal. We'll study while loops later in this article.\n\nIn a bash script or function, denotes the initial argument passed, denotes the second argument passed, and so forth.\n\nThis script takes a name as a command-line argument and prints a personalized greeting.\n\nWe have supplied as our argument to the script.\n\nHere we'll discuss some methods to receive output from the scripts.\n\nThis prints the text \"Hello, World!\" to the terminal.\n\nThis writes the text \"This is some text.\" to a file named . Note that the operator overwrites a file if it already has some content.\n\nThis appends the text \"More text.\" to the end of the file .\n\nThis lists the files in the current directory and writes the output to a file named . You can redirect output of any command to a file this way.\n\nHere is a list of some of the most commonly used bash commands:\n• : Change the directory to a different location.\n• : List the contents of the current directory.\n• : Concatenate and print the contents of a file.\n• : Change the permissions of a file or directory.\n• : Display the amount of disk space available.\n\nExpressions that produce a boolean result, either true or false, are called conditions. There are several ways to evaluate conditions, including , , , and nested conditionals.\n\nWe can use logical operators such as AND and OR to make comparisons that have more significance.\n\nLet's see an example of a Bash script that uses , , and statements to determine if a user-inputted number is positive, negative, or zero:\n\nThe script first prompts the user to enter a number. Then, it uses an statement to check if the number is greater than 0. If it is, the script outputs that the number is positive. If the number is not greater than 0, the script moves on to the next statement, which is an statement. Here, the script checks if the number is less than 0. If it is, the script outputs that the number is negative. Finally, if the number is neither greater than 0 nor less than 0, the script uses an statement to output that the number is zero.\n\nSeeing it in action 🚀\n\nWhile loops check for a condition and loop until the condition remains . We need to provide a counter statement that increments the counter to control loop execution.\n\nIn the example below, is the counter statement that increments the value of . The loop will run exactly 10 times.\n\nThe loop, just like the loop, allows you to execute statements a specific number of times. Each loop differs in its syntax and usage.\n\nIn the example below, the loop will iterate 5 times.\n\nIn Bash, case statements are used to compare a given value against a list of patterns and execute a block of code based on the first pattern that matches. The syntax for a case statement in Bash is as follows:\n\nHere, \"expression\" is the value that we want to compare, and \"pattern1\", \"pattern2\", \"pattern3\", and so on are the patterns that we want to compare it against.\n\nThe double semicolon \";;\" separates each block of code to execute for each pattern. The asterisk \"*\" represents the default case, which executes if none of the specified patterns match the expression.\n\nLet's see an example.\n\nIn this example, since the value of \"fruit\" is \"apple\", the first pattern matches, and the block of code that echoes \"This is a red fruit.\" is executed. If the value of \"fruit\" were instead \"banana\", the second pattern would match and the block of code that echoes \"This is a yellow fruit.\" would execute, and so on. If the value of \"fruit\" does not match any of the specified patterns, the default case is executed, which echoes \"Unknown fruit.\"\n\nHow to Schedule Scripts using cron\n\nCron is a powerful utility for job scheduling that is available in Unix-like operating systems. By configuring cron, you can set up automated jobs to run on a daily, weekly, monthly, or specific time basis. The automation capabilities provided by cron play a crucial role in Linux system administration.\n\nBelow is the syntax to schedule crons:\n\nHere, the s represent minute(s) hour(s) day(s) month(s) weekday(s), respectively.\n\nBelow are some examples of scheduling cron jobs.\n\nThe utility is used to add and edit the cron jobs.\n\nlists the already scheduled scripts for a particular user.\n\nYou can add and edit the cron through .\n\nYou can read more about corn jobs in my other article here.\n\nHow to Debug and Troubleshoot Bash Scripts\n\nDebugging and troubleshooting are essential skills for any Bash scripter. While Bash scripts can be incredibly powerful, they can also be prone to errors and unexpected behavior. In this section, we will discuss some tips and techniques for debugging and troubleshooting Bash scripts.\n\nOne of the most useful techniques for debugging Bash scripts is to set the option at the beginning of the script. This option enables debugging mode, which causes Bash to print each command that it executes to the terminal, preceded by a sign. This can be incredibly helpful in identifying where errors are occurring in your script.\n\nWhen Bash encounters an error, it sets an exit code that indicates the nature of the error. You can check the exit code of the most recent command using the variable. A value of indicates success, while any other value indicates an error.\n\nAnother useful technique for debugging Bash scripts is to insert statements throughout your code. This can help you identify where errors are occurring and what values are being passed to variables.\n\nIf you want your script to exit immediately when any command in the script fails, you can use the option. This option will cause Bash to exit with an error if any command in the script fails, making it easier to identify and fix errors in your script.\n\nWe can troubleshoot crons using the log files. Logs are maintained for all the scheduled jobs. You can check and verify in logs if a specific job ran as intended or not.\n\nFor Ubuntu/Debian, you can find logs at:\n\nThe location varies for other distributions.\n\nA cron job log file can look like this:\n\nIn this article, we started with how to access the terminal and then ran some basic bash commands. We also studied what a bash shell is. We briefly looked at branching the code using loops and conditionals. Finally, we discussed automating the scripts using cron followed by some troubleshooting techniques.\n\nResources for learning more about Bash scripting\n\nIf you want to dig deeper into the world of bash scripting, I would suggest you have a look at this 6-hour course on Linux at freeCodeCamp.\n\nWhat’s your favorite thing you learned from this tutorial? You can also connect with me on any of these platforms. 📧�\n\nSee you in the next tutorial, happy coding 😁"
    },
    {
        "link": "https://pluralsight.com/resources/blog/cloud/conditions-in-bash-scripting-if-statements",
        "document": "\n• The first difference can be seen in the above example; when comparing strings, the double-bracket syntax features shell globbing. This means that an asterisk (\"*\") will expand to literally anything, just as you probably know from normal command-line usage. Therefore, if $stringvar contains the phrase \"string\" anywhere, the condition will return true. Other forms of shell globbing are allowed, too. If you'd like to match both \"String\" and \"string\", you could use the following syntax: Note that only general shell globbing is allowed. Bash-specific things like {1..4} or {foo,bar} will not work. Also note that the globbing will not work if you quote the right string. In this case you should leave it unquoted.\n• The second difference is that word splitting is prevented. Therefore, you could omit placing quotes around string variables and use a condition like the following without problems: Nevertheless, the quoting string variables remains a good habit, so I recommend just to keep doing it.\n• The third difference consists of not expanding filenames. I will illustrate this difference using two examples, starting with the old single-bracket situation: The above condition will return true if there is one single file in the working directory that has a .sh extension. If there are none, it will return false. If there are several .sh files, bash will throw an error and stop executing the script. This is because *.sh is expanded to the files in the working directory. Using double brackets prevents this: The above condition will return true only if there is a file in the working directory called \"*.sh\", no matter what other .sh files exist. The asterisk is taken literally, because the double-bracket syntax does not expand filenames.\n• The fourth difference is the addition of more generally known combining expressions, or, more specific, the operators \"&&\" and \"||\". Example: The above condition returns true if $num is equal to 3 and $stringvar is equal to \"foo\". The -a and -o known from the single-bracket syntax is supported, too.Note that the and operator has precedence over the or operator, meaning that \"&&\" or \"-a\" will be evaluated before \"||\" or \"-o\".\n• The fifth difference is that the double-bracket syntax allows regex pattern matching using the \"=~\" operator. See the table for more information."
    },
    {
        "link": "https://tldp.org/LDP/abs/html",
        "document": "This tutorial assumes no previous knowledge of scripting or programming, yet progresses rapidly toward an intermediate/advanced level of instruction . . . all the while sneaking in little nuggets of UNIX® wisdom and lore. It serves as a textbook, a manual for self-study, and as a reference and source of knowledge on shell scripting techniques. The exercises and heavily-commented examples invite active reader participation, under the premise that the only way to really learn scripting is to write scripts .\n\nThis book is suitable for classroom use as a general introduction to programming concepts.\n\nThis document is herewith granted to the Public Domain."
    },
    {
        "link": "https://redhat.com/en/blog/arguments-options-bash-scripts",
        "document": "One of the most important tools for most sysadmins is automation. We write and maintain scripts to automate the common and frequent tasks that we must perform.\n\nI have dozens of scripts—short and long—that I've written and modified over the years. Some of my most useful scripts have been to perform regular backups early each morning, install updated software packages with fixes and enhancements, and upgrade from one version of Fedora to the next. I just upgraded all of my personal hosts and servers to Fedora 34 a few days ago using a fairly simple script.\n\nTwo of the most common things I do for all my scripts are creating a help function and a function that displays the GPL3 license statement. I like to include verbose or test modes to assist in problem determination in my scripts. In some scripts, I also pass values such as a user name, the version of Fedora to upgrade to, file names, and more.\n\nThe ability to use positional parameters—otherwise known as arguments—to specify data to be used as values for variables in the scripts is one method for accomplishing this. Another is the use of options and option arguments. This article explores these two methods for getting data into the script and controlling the script's execution path.\n\nBash uses a tool called positional parameters to provide a means of entering data into a Bash program when it is invoked from the command line. There are ten positional parameters that run from $0 through $9, although there are ways to hack around that limit.\n\nStarting with a simple script that displays an entered name on the screen. Create a file called with the following content and make it executable.\n\nI placed this script in my , where personal executable files such as scripts are intended to be stored. Look at your $PATH variable, which contains as one component. If the directory does not exist, you can create it. Or you can just put this file wherever you want and use it from there.\n\nThen run the script with no parameters.\n\nThe output from this script is the name of the script. The $0 parameter is reserved and predefined as the name of the running script and cannot be used for any other purpose. This can be handy inside a script because you don't need to pass the script its own name if it requires it.\n\nSo change the script to use $1 for the positional variable, and run it again:\n\nRun it again, this time using a single parameter:\n\nWhat happens if the parameter is two words?\n\nThat is actually two parameters, but you can remedy that with quotes, as seen here:\n\nThis can be helpful where the input is supposed to be a street address or something with multiple words, like this:\n\nBut there are times when you do need multiple parameters, such as with names or full addresses.\n\n[ You might also like: More stupid Bash tricks: Variables, find, file descriptors, and remote operations ]\n\nChange the program to look like this:\n\nAnd run it using the parameters as shown:\n\nOf course, there are many ways to use the positional parameters once values have been assigned, but this little program makes it easy to see what is happening. It also makes it easy to experiment in a safe way.\n\nTry putting the parameters in a different order to see how that works. These parameters are positional, and that is a key consideration. You must consider how many parameters are needed, how the user remembers them, and what order to place them.\n\nYou need a way to make the order of the parameters irrelevant and still need a way to modify the execution path.\n\nYou can do those two things using command line options.\n\nI find that even simple Bash programs should have some sort of help facility, even if it is fairly rudimentary. Many of the Bash shell programs I write are used infrequently enough that I may forget the exact syntax of the command I need to issue. Some are just so complex that I need to review the options and arguments required even though I use them frequently.\n\nHaving a built-in help function allows you to view those things without resorting to inspecting the code itself. A good and complete help facility is also one part of program documentation.\n\nShell functions are lists of Bash program statements stored in the shell's environment and can be executed like any other command by typing its name at the command line. Shell functions may also be known as procedures or subroutines, depending upon which other programming language you might be using.\n\nFunctions are called in your scripts or from the CLI by using their names, just as you would for any other command. In a CLI program or a script, the commands in the function are executed when called. Then the sequence of program flow returns to the calling entity, and the next series of program statements in that entity is executed.\n\nThe syntax of a function is:\n\nCreate a simple function at the CLI. The function is stored in the shell environment for the shell instance in which it is created. You're going to create a function called hw, which stands for Hello world. Enter the following code at the CLI and press Enter. Then enter hw as you would any other shell command.\n\nOk, so I am a little tired of the standard \"Hello world!\" I usually start with. Now list all of the currently defined functions. There are a lot of them, so I have shown just the new hw function. When called from the command line or within a program, a function performs its programmed task. It then exits, returning control to the calling entity, the command line, or the next Bash program statement in a script after the calling statement.\n\nNow remove that function because you don't need it anymore. You can do that with the command, like this:\n\nCreate a new Bash shell script, , and make it executable. Add the following content, keeping it basic to start:\n\nRun it to verify that it prints \"hello world!\"\n\nI know—I can't help myself, so I went back to \"hello world!\".\n\nAdd the help function shown below to the code of the hello program. Place the help function between the two statements you already have. This help function will display a short description of the program, a syntax diagram, and a short description of each available option. You also add a call to the help function to test it and some comment lines that provide a visual demarcation between the functions and the main portion of the program.\n\nThe program now looks like this.\n\nThe options described in this help function might be typical in the programs I write, although none are yet present in the code. Run the program to test it.\n\nBecause you haven't added any logic to display the help when you want it, the program will always display the help. However, you know that the function is working correctly, so you can add some logic only to show the help when you use a option at the command line invocation of the program.\n\n[ Want to test your sysadmin skills? Take a skills assessment today. ]\n\nThe ability for a Bash script to handle command line options such as to display help gives you some powerful capabilities to direct the program and modify what it does. In the case of your option, you want the program to print the help text to the terminal session and then quit without running the rest of the program. The ability to process options entered at the command line can be added to the Bash script using the command in conjunction with the and commands.\n\nThe command reads any and all options specified at the command line and creates a list of those options. The command loops through the list of options by setting the variable $options for each in the code below. The statement is used to evaluate each option in turn and execute the statements in the corresponding stanza. The statement will continue to assess the list of options until they have all been processed or an exit statement is encountered, which terminates the program.\n\nBe sure to delete the help function call just before the echo \"Hello world!\" statement so that the main body of the program now looks like this.\n\nNotice the double semicolon at the end of the exit statement in the case option for . This is required for each option. Add to this case statement to delineate the end of each option.\n\nTesting is now a little more complex. You need to test your program with several different options—and no options—to see how it responds. First, check to ensure that with no options that it prints \"Hello world!\" as it should.\n\nThat works, so now test the logic that displays the help text.\n\nThat works as expected, so now try some testing to see what happens when you enter some unexpected options.\n\nThe program just ignores the options for which you haven't created specific responses without generating any errors. Although in the last entry with the options, because there is an \"h\" in the list, the program did recognize it and print the help text. Testing has shown that one thing that is missing is the ability to handle incorrect input and terminate the program if any is detected.\n\nYou can add another case stanza to the case statement that will match any option for which there is no explicit match. This general case will match anything you haven't provided a specific match for. The case statement now looks like this.\n\nThis bit of code deserves an explanation about how it works. It seems complex but is fairly easy to understand. The while – done structure defines a loop that executes once for each option in the getopts – option structure. The \":h\" string —which requires the quotes—lists the possible input options that will be evaluated by the case – esac structure. Each option listed must have a corresponding stanza in the case statement. In this case, there are two. One is the h) stanza which calls the Help procedure. After the Help procedure completes, execution returns to the next program statement, exit;; which exits from the program without executing any more code even if some exists. The option processing loop is also terminated, so no additional options would be checked.\n\nNotice the catch-all match of \\? as the last stanza in the case statement. If any options are entered that are not recognized, this stanza prints a short error message and exits from the program.\n\nAny additional specific cases must precede the final catch-all. I like to place the case stanzas in alphabetical order, but there will be circumstances where you want to ensure that a particular case is processed before certain other ones. The case statement is sequence sensitive, so be aware of that when you construct yours.\n\nThe last statement of each stanza in the case construct must end with the double semicolon ( ), which is used to mark the end of each stanza explicitly. This allows those programmers who like to use explicit semicolons for the end of each statement instead of implicit ones to continue to do so for each statement within each case stanza.\n\nTest the program again using the same options as before and see how this works now.\n\nThe Bash script now looks like this.\n\nBe sure to test this version of your program very thoroughly. Use random input and see what happens. You should also try testing valid and invalid options without using the dash ( ) in front.\n\nFirst, add a variable and initialize it. Add the two lines shown in bold in the segment of the program shown below. This initializes the $Name variable to \"world\" as the default.\n\nChange the last line of the program, the command, to this.\n\nAdd the logic to input a name in a moment but first test the program again. The result should be exactly the same as before.\n\n$OPTARG is always the variable name used for each new option argument, no matter how many there are. You must assign the value in $OPTARG to a variable name that will be used in the rest of the program. This new stanza does not have an exit statement. This changes the program flow so that after processing all valid options in the case statement, execution moves on to the next statement after the case construct.\n\nThe completed program looks like this.\n\nBe sure to test the help facility and how the program reacts to invalid input to verify that its ability to process those has not been compromised. If that all works as it should, then you have successfully learned how to use options and option arguments.\n\nIn this article, you've used positional parameters to enter data into the Bash program during invocation from the command line and used options to direct the flow of the program as well as to enter data into the program. You added a help function and the ability to process command line options to display the help selectively. And you added an optional argument that allows entering a name on the command line.\n\nThis little test program is designed to be simple, so you can easily experiment with it yourself to test this input method on your own. As an exercise, revise the program to take a first name and last name. Try entering the options for first and last names in reverse order to see what happens.\n• How to program with Bash: Syntax and tools\n• How to program with Bash: Logical operators and shell expansions\n• How to program with Bash: Loops"
    },
    {
        "link": "https://reddit.com/r/bash/comments/l7a36g/what_is_the_best_practice_for_handling_parameters",
        "document": "I see tons of ways of using GETOPT(s) and leveraging $@ and loops to handle both parameters and flags, but I haven't seen anything approaching a standard or a best practice. I would like to be able to, elegantly, handle parameters and flags with bash scripts similar to the way the 'ls' command handles various mixed parameter/flag options... for example\n\nall do the same thing. The user can use long or short options, and put them in any order and ls will still do what is expected.\n\nI've found some good examples out there, but I have no idea what, if any, are the best practices around parameter/flag handling.\n\nAbsent a definitive answer, what is your preferred method?"
    },
    {
        "link": "https://refine.dev/blog/bash-script-arguments",
        "document": "Arguments in any bash script are inevitable for any scripting task. They make the script flexible and dynamic instead of static and hard coded. Now there are many variations in how arguments can be used effectively in a script, and this is exactly what we will discuss today. Remember, a solid understanding of arguments is crucial to automate your tasks through script arguments. For each point in this article, we will provide an example from a practical perspective as well.\n\nLet's start with understanding how positional parameters work in the bash script.\n\nIn bash scripting, positional parameters are a fundamental concept. They’re the variables that bash scripts use to handle input data. When you run a script, you can pass arguments to it, and these arguments are stored in special variables known as positional parameters. The first argument you pass is stored in , the second in , and so on.\n\nLet’s understand this in detail through an example. Let's say you have a bash script that needs to process three pieces of input data and you want to make use of positional parameters. The below snippet shows how you might use positional parameters to handle this:\n\nWhen you run this script with three arguments, it will echo back the first three arguments you passed to it. For instance, if you run , the script will output:\n\nThis shows how , , and correspond to the first, second, and third arguments you passed to the script. It is a simple yet powerful way to make your scripts more flexible and reusable.\n\nIn bash scripting, there are special parameters that provide additional ways to handle input data. These include , , and .\n\nThe and parameters represent all arguments that were passed to the script. While they might seem identical, their behavior diverges when you try to iterate over them in a script. Let’s illustrate this with an example:\n\nIf you run this script with the arguments ./myscript.sh one two three , you’ll notice that treats all arguments as a single string, while treats each argument as a separate string.\n\nThe parameter is different - it doesn’t represent the arguments themselves, but the number of arguments. This can be useful when your script needs to know how many arguments were passed. Here’s a simple script that uses :\n\nIf you run , the script will output This shows how can be used to count the number of arguments passed to a script.\n\nBash scripts often require input parameters to customize behavior, and is a utility that can be used to parse positional parameters.\n\nIn the script above, is used for displaying help information, and is used for setting a name. The flag is used to set verbose mode. If is provided when the script is run, is set to 1. If is provided, the next argument is assigned to the variable .\n\nHere’s an example of how you might run this script:\n\nIn this example, the flag sets verbose mode, and sets the name to “Example Name”. Any arguments provided after the flags (in this case, “leftover args”) are still available in the script.\n\nBash scripts often need to accept a variable number of arguments. This is where comes into play. It’s a special shell variable that holds all the arguments provided to the script.\n\nIn the script above, we initialize an empty string . We then loop through all arguments provided to the script using and append each argument to .\n\nHere’s an example of how you might run this script:\n\nIn this example, the script concatenates the three arguments , , and into a single string. This demonstrates how a bash script can handle a variable number of arguments.\n\nHere are some best practices for designing bash scripts with arguments:\n• None Use Intuitive Argument Names: Opt for descriptive and intuitive names for arguments. This improves readability and helps maintain the code.\n• None Assign Default Values: Where practical, assign default values to arguments. This ensures that your script behaves predictably even when certain inputs are omitted.\n• None Inline Comments: Use inline comments to explain the purpose and expected values of arguments. This documentation aids future maintainers and users of your script.\n• None Leverage for Option Parsing: allows for more flexible and robust argument parsing, supporting both short and long options.\n• Validate Input Early: Check for the existence and format of required arguments at the start of your script to prevent execution with invalid inputs.\n• Beware of Unquoted Variables: Always quote variables to handle values with spaces correctly.\n• Explicitly Declare Intent: Use to treat unset variables and parameters as an error, preventing scripts from running with unintended states.\n• Add at the beginning of your script.\n\nThe importance of arguments in developing scripts that can adapt to different situations is highlighted by the fact that they are extensively used in bash scripts. We focused on improving script functionality and user interaction by using positional parameters, special variables, and .\n\nNot only do the given examples provide a useful roadmap, but they also inspire developers to try new things and incorporate these ideas into their scripts. Your scripting skills will certainly improve after adopting these best practices and techniques, allowing you to make your automation tasks more efficient and adaptable."
    },
    {
        "link": "https://stackoverflow.com/questions/192249/how-do-i-parse-command-line-arguments-in-bash",
        "document": "What's the accepted way of parsing this such that in each case (or some combination of the two) $v , $f , and $d will all be set to true and $outFile will be equal to /fizz/someOtherFile ?\n\nor this one:\n\nSay, I have a script that gets called with this line:\n\ncat >/tmp/demo-space-separated.sh <<'EOF' #!/bin/bash POSITIONAL_ARGS=() while [[ $# -gt 0 ]]; do case $1 in -e|--extension) EXTENSION=\"$2\" shift # past argument shift # past value ;; -s|--searchpath) SEARCHPATH=\"$2\" shift # past argument shift # past value ;; --default) DEFAULT=YES shift # past argument ;; -*|--*) echo \"Unknown option $1\" exit 1 ;; *) POSITIONAL_ARGS+=(\"$1\") # save positional arg shift # past argument ;; esac done set -- \"${POSITIONAL_ARGS[@]}\" # restore positional parameters echo \"FILE EXTENSION = ${EXTENSION}\" echo \"SEARCH PATH = ${SEARCHPATH}\" echo \"DEFAULT = ${DEFAULT}\" echo \"Number files in SEARCH PATH with EXTENSION:\" $(ls -1 \"${SEARCHPATH}\"/*.\"${EXTENSION}\" | wc -l) if [[ -n $1 ]]; then echo \"Last line of file specified as non-opt/last argument:\" tail -1 \"$1\" fi EOF chmod +x /tmp/demo-space-separated.sh /tmp/demo-space-separated.sh -e conf -s /etc /etc/hosts Output from copy-pasting the block above FILE EXTENSION = conf SEARCH PATH = /etc DEFAULT = Number files in SEARCH PATH with EXTENSION: 14 Last line of file specified as non-opt/last argument: #93.184.216.34 example.com cat >/tmp/demo-equals-separated.sh <<'EOF' #!/bin/bash for i in \"$@\"; do case $i in -e=*|--extension=*) EXTENSION=\"${i#*=}\" shift # past argument=value ;; -s=*|--searchpath=*) SEARCHPATH=\"${i#*=}\" shift # past argument=value ;; --default) DEFAULT=YES shift # past argument with no value ;; -*|--*) echo \"Unknown option $i\" exit 1 ;; *) ;; esac done echo \"FILE EXTENSION = ${EXTENSION}\" echo \"SEARCH PATH = ${SEARCHPATH}\" echo \"DEFAULT = ${DEFAULT}\" echo \"Number files in SEARCH PATH with EXTENSION:\" $(ls -1 \"${SEARCHPATH}\"/*.\"${EXTENSION}\" | wc -l) if [[ -n $1 ]]; then echo \"Last line of file specified as non-opt/last argument:\" tail -1 $1 fi EOF chmod +x /tmp/demo-equals-separated.sh /tmp/demo-equals-separated.sh -e=conf -s=/etc /etc/hosts Output from copy-pasting the block above FILE EXTENSION = conf SEARCH PATH = /etc DEFAULT = Number files in SEARCH PATH with EXTENSION: 14 Last line of file specified as non-opt/last argument: #93.184.216.34 example.com To better understand search for \"Substring Removal\" in this guide. It is functionally equivalent to which calls a needless subprocess or which calls two needless subprocesses.\n• can't handle arguments that are empty strings More recent versions don't have these limitations. For more information, see these docs. Additionally, the POSIX shell and others offer which doen't have these limitations. I've included a simplistic example. cat >/tmp/demo-getopts.sh <<'EOF' #!/bin/sh # A POSIX variable OPTIND=1 # Reset in case getopts has been used previously in the shell. # Initialize our own variables: output_file=\"\" verbose=0 while getopts \"h?vf:\" opt; do case \"$opt\" in h|\\?) show_help exit 0 ;; v) verbose=1 ;; f) output_file=$OPTARG ;; esac done shift $((OPTIND-1)) [ \"${1:-}\" = \"--\" ] && shift echo \"verbose=$verbose, output_file='$output_file', Leftovers: $@\" EOF chmod +x /tmp/demo-getopts.sh /tmp/demo-getopts.sh -vf /etc/hosts foo bar Output from copy-pasting the block above The advantages of are:\n• It's more portable, and will work in other shells like .\n• It can handle multiple single options like in the typical Unix way, automatically. The disadvantage of is that it can only handle short options ( , not ) without additional code. There is a getopts tutorial which explains what all of the syntax and variables mean. In bash, there is also , which might be informative.\n\nI give you The Function that will parse params from the command line.\n• It is a pure Bash solution, no additional utilities.\n• Effortlessly returns you simple to use variables, that you could build further logic on.\n• Amount of dashes before params does not matter ( equals equals ) The script below is a copy-paste working demonstration. See function to understand how to use .\n• Param names will lose dashes so and are equivalent\n• must be used inside bash function (it will not work in the global scope) #!/bin/bash # Universal Bash parameter parsing # Parse equal sign separated params into named local variables # Standalone named parameter value will equal its param name (--force creates variable $force==\"force\") # Parses multi-valued named params into an array (--path=path1 --path=path2 creates ${path[*]} array) # Puts un-named params as-is into ${ARGV[*]} array # Additionally puts all named params as-is into ${ARGN[*]} array # Additionally puts all standalone \"option\" params as-is into ${ARGO[*]} array # @author Oleksii Chekulaiev # @version v1.4.1 (Jul-27-2018) parse_params () { local existing_named local ARGV=() # un-named params local ARGN=() # named params local ARGO=() # options (--params) echo \"local ARGV=(); local ARGN=(); local ARGO=();\" while [[ \"$1\" != \"\" ]]; do # Escape asterisk to prevent bash asterisk expansion, and quotes to prevent string breakage _escaped=${1/\\*/\\'\\\"*\\\"\\'} _escaped=${_escaped//\\'/\\\\\\'} _escaped=${_escaped//\\\"/\\\\\\\"} # If equals delimited named parameter nonspace=\"[^[:space:]]\" if [[ \"$1\" =~ ^${nonspace}${nonspace}*=..* ]]; then # Add to named parameters array echo \"ARGN+=('$_escaped');\" # key is part before first = local _key=$(echo \"$1\" | cut -d = -f 1) # Just add as non-named when key is empty or contains space if [[ \"$_key\" == \"\" || \"$_key\" =~ \" \" ]]; then echo \"ARGV+=('$_escaped');\" shift continue fi # val is everything after key and = (protect from param==value error) local _val=\"${1/$_key=}\" # remove dashes from key name _key=${_key//\\-} # skip when key is empty # search for existing parameter name if (echo \"$existing_named\" | grep \"\\b$_key\\b\" >/dev/null); then # if name already exists then it's a multi-value named parameter # re-declare it as an array if needed if ! (declare -p _key 2> /dev/null | grep -q 'declare \\-a'); then echo \"$_key=(\\\"\\$$_key\\\");\" fi # append new value echo \"$_key+=('$_val');\" else # single-value named parameter echo \"local $_key='$_val';\" existing_named=\" $_key\" fi # If standalone named parameter elif [[ \"$1\" =~ ^\\-${nonspace}+ ]]; then # remove dashes local _key=${1//\\-} # Just add as non-named when key is empty or contains space if [[ \"$_key\" == \"\" || \"$_key\" =~ \" \" ]]; then echo \"ARGV+=('$_escaped');\" shift continue fi # Add to options array echo \"ARGO+=('$_escaped');\" echo \"local $_key=\\\"$_key\\\";\" # non-named parameter else # Escape asterisk to prevent bash asterisk expansion _escaped=${1/\\*/\\'\\\"*\\\"\\'} echo \"ARGV+=('$_escaped');\" fi shift done } #--------------------------- DEMO OF THE USAGE ------------------------------- show_use () { eval $(parse_params \"$@\") # -- echo \"${ARGV[0]}\" # print first unnamed param echo \"${ARGV[1]}\" # print second unnamed param echo \"${ARGN[0]}\" # print first named param echo \"${ARG0[0]}\" # print first option param (--force) echo \"$anyparam\" # print --anyparam value echo \"$k\" # print k=5 value echo \"${multivalue[0]}\" # print first value of multi-value echo \"${multivalue[1]}\" # print second value of multi-value [[ \"$force\" == \"force\" ]] && echo \"\\$force is set so let the force be with you\" } show_use \"param 1\" --anyparam=\"my value\" param2 k=5 --force --multi-value=test1 --multi-value=test2\n\nHere is my solution. It is VERY flexible and unlike others, shouldn't require external packages and handles leftover arguments cleanly. All you have to do is edit the validflags line. It prepends a hyphen and searches all arguments. It then defines the next argument as the flag name e.g. The main code (short version, verbose with examples further down, also a version with erroring out): #!/usr/bin/env bash #shebang.io validflags=\"rate time number\" count=1 for arg in $@ do match=0 argval=$1 for flag in $validflags do sflag=\"-\"$flag if [ \"$argval\" == \"$sflag\" ] then declare $flag=$2 match=1 fi done if [ \"$match\" == \"1\" ] then shift 2 else leftovers=$(echo $leftovers $argval) shift fi count=$(($count+1)) done #Cleanup then restore the leftovers shift $# set -- $leftovers The verbose version with built in echo demos: #!/usr/bin/env bash #shebang.io rate=30 time=30 number=30 echo \"all args $@\" validflags=\"rate time number\" count=1 for arg in $@ do match=0 argval=$1 # argval=$(echo $@ | cut -d ' ' -f$count) for flag in $validflags do sflag=\"-\"$flag if [ \"$argval\" == \"$sflag\" ] then declare $flag=$2 match=1 fi done if [ \"$match\" == \"1\" ] then shift 2 else leftovers=$(echo $leftovers $argval) shift fi count=$(($count+1)) done #Cleanup then restore the leftovers echo \"pre final clear args: $@\" shift $# echo \"post final clear args: $@\" set -- $leftovers echo \"all post set args: $@\" echo arg1: $1 arg2: $2 echo leftovers: $leftovers echo rate $rate time $time number $number Final one, this one errors out if an invalid -argument is passed through. #!/usr/bin/env bash #shebang.io rate=30 time=30 number=30 validflags=\"rate time number\" count=1 for arg in $@ do argval=$1 match=0 if [ \"${argval:0:1}\" == \"-\" ] then for flag in $validflags do sflag=\"-\"$flag if [ \"$argval\" == \"$sflag\" ] then declare $flag=$2 match=1 fi done if [ \"$match\" == \"0\" ] then echo \"Bad argument: $argval\" exit 1 fi shift 2 else leftovers=$(echo $leftovers $argval) shift fi count=$(($count+1)) done #Cleanup then restore the leftovers shift $# set -- $leftovers echo rate $rate time $time number $number echo leftovers: $leftovers Pros: What it does, it handles very well. It preserves unused arguments which a lot of the other solutions here don't. It also allows for variables to be called without being defined by hand in the script. It also allows prepopulation of variables if no corresponding argument is given. (See verbose example). Cons: Can't parse a single complex arg string e.g. -xcvf would process as a single argument. You could somewhat easily write additional code into mine that adds this functionality though.\n\nI wanted to share what I made for parsing options. Some of my needs were not fulfilled by the answers here so I had to come up with this: https://github.com/MihirLuthra/bash_option_parser Let's say we have a command named with usage as follows: takes no args\n\n takes two args i.e. how to cut and why to cut\n\n itself takes at least one argument.\n\n is for suboptions like , etc. (similar to which has suboptions , etc. ) Now if there was any usage error, it can be printed using as follows: retval=$? if [ $retval -ne 0 ]; then # this will manage error messages if # insufficient or extra args are supplied option_parser_error_msg \"$retval\" # This will print the usage print_usage 'fruit' exit 1 fi To check now if some options was passed, if [ -n \"${OPTIONS[-c]}\" ] then echo \"-c was passed\" # args can be accessed in a 2D-array-like format echo \"Arg1 to -c = ${ARGS[-c,0]}\" echo \"Arg2 to -c = ${ARGS[-c,1]}\" fi Suboption parsing can also be done by passing to which makes it start parsing after shifting args to reach args of suboption. It is demonstrated in this example. A detailed description is provided in the readme and examples in the repository."
    },
    {
        "link": "https://baeldung.com/linux/use-command-line-arguments-in-bash-script",
        "document": "We’ve previously examined how to pass command-line arguments to a Bash script. Command-line arguments are a crucial feature in Bash scripting, enabling the script to take input values at runtime, thereby increasing its flexibility and usefulness.\n\nBy using these arguments, we pass data or options to a script when it runs, eliminating the need for hard-coded values inside the script. This approach allows the script to handle different scenarios, making it more dynamic and reusable.\n\nIn this tutorial, we’ll explore the various ways we can use command-line arguments in a Bash script. We’ll start by covering positional parameters and then move on to more advanced techniques like flags, loops, and the shift operator.\n\nBash provides multiple ways to process the arguments passed to a script. Thus, the choice of usage depends on the number of arguments, their order, and how we plan to use them. Let’s break down these approaches step by step.\n\nWhen running a Bash script, the input arguments are stored in special variables:\n• $@: this contains all the input arguments\n• $#: the number of arguments passed to the script\n• $0: the name of the script itself\n\nLet’s further explain with an example:\n\nHere, we can use the various types of special variables. The special parameter $@ represents the arguments arg1, arg2, and arg3, while $# is 3, standing for the number of arguments, and $0 is ./example.sh, the name of the Bash script.\n\nThese variables form the foundation for more advanced techniques in argument processing.\n\nLet’s take a look at the different ways to process the arguments passed to a Bash script inside the script.\n\nArguments passed to a script are processed in the same order in which they’re sent. The indexing of the arguments starts at one, and the first argument can be accessed inside the script using $1.\n\nSimilarly, the second argument can be accessed using $2, and so on. The positional parameters refer to the representation of arguments based on their position in the command line.\n\nAs an example, let’s consider the userReg-positional-parameter.sh script, which prints positional parameter values corresponding to Username, Age, and Full Name in that order:\n\nNow let’s run this script with the three input parameters:\n\nThe result shows that the first positional parameter, $1, is john, while $2 is 25, and $3 is John Smith.\n\nHowever, this approach has its limitations, especially when we don’t know the number of arguments or when their order may vary. For this reason, let’s explore argument validation next.\n\nIt’s important to validate the input to ensure that the correct number of arguments has been provided. In this case, we use $# to check the number of arguments and handle the error gracefully if the expected number of inputs isn’t met.\n\nLet’s copy and edit the previous Bash script, userReg-positional-parameter.sh, to include an argument validation check before the main part of the script is executed. In other words, the validation part of the script prints a message and exits when the number of arguments passed is wrong based on what the script requires. We’ll name the new script userReg-validation-positional-parameter.sh:\n\nThe first section of the script is for validating the number of arguments, while the second section represents the main code. However, the main code doesn’t run if the condition in the validation check isn’t met.\n\nWhen only two arguments are supplied, the code exits and prints the usage syntax for the Bash script.\n\nThis type of validation is a simple, yet essential, step to prevent runtime errors and ensure the script behaves as expected.\n\nUsing flags is a common way of passing input to a script. When passing input to the script, there’s a flag (usually a single letter) starting with a hyphen (–) before each argument.\n\nLet’s take a look at the userReg-flags.sh script, which takes three arguments: username (-u), age (-a), and fullname (-f).\n\nWe’ll modify the userReg-positional-parameter.sh script to use flags instead of relying on positional parameters. The getopts function reads the flags in the input, and the OPTARG variable refers to their corresponding values:\n\nHere, we’re using the getopts function to parse the flags provided as input and the case block to assign the value specified to the corresponding variable.\n\nLet’s run this script with the same input as before, only this time we’ll add flags to the input:\n\nThe output is the same as before, though we have shifted the positions of the username and fullname arguments.\n\nTherefore, we’ve learned that this method removes the reliance on the order of arguments, making the script more flexible.\n\nIn this section, let’s explore more methods for processing the input of a Bash script. Now, we can touch on methods that are a little bit more advanced.\n\nPositional parameters combined with flags produce greater flexibility in terms of usage in a Bash script. For instance, we can have optional parameters handled by flags and mandatory ones handled as positional parameters.\n\nLet’s illustrate this using the Bash script flag-positional-param.sh:\n\nFirst, the script parses the -u, -a, and -f options using getopts. Moreover, these correspond to username, age, and fullname, respectively. After getopts processes the flags, OPTIND points to the next argument, which will become the first positional argument. So, by using shift $((OPTIND – 1)), we skip over the parsed options and their values.\n\nSubsequently, $1, $2, and $3 represent the positional arguments passed after the flags. We assign these to the param1, param2, and param3 variables, respectively.\n\nLet’s run this script with the same input as before, only this time, we’ll add flags and positional parameters to the input:\n\nThis approach allows working with both flags and positional arguments in Bash scripts efficiently.\n\nPositional parameters, while convenient in many cases, can’t be used when the input size is unknown. The use of a loop construct comes in handy in these situations.\n\nThe special parameter $@ is an array-like construct of all the input arguments. Using $@ within a for loop, we can iterate over the input and process all the arguments passed.\n\nLet’s consider the users-loop.sh script, which prints all the usernames that have been passed as input:\n\nIn this example, we’re iterating the user variable over the entire array of input arguments. This iteration starts at the first input argument, john, and runs until the last argument, carol, despite the fact that the number of arguments can’t be known by the script beforehand.\n\nThe shift operator in Bash (syntactically shift n, where n is the number of positions to move) shifts the position of the command-line arguments. The default value for n is one if not specified.\n\nThe shift operator causes the indexing of the input to start from the shifted position. In other words, using this operator on an array-like input shifts the positional parameter $1 to the argument that is n positions to the right of the current value of $1.\n\nConsider an example script that determines whether the input is odd or even:\n\nWe now know that $1 refers to the first argument, which is 13. Using the shift operator with input 1 (shift 1) causes the indexing to start from the second argument. That is, $1 now refers to the second argument (18). Similarly, calling shift 2 will then cause the indexing to start from the fourth argument (35).\n\nLet’s again take a look at the example of the users-loop.sh script. Instead of using the $@ variable and iterating over it, we’ll now use the shift operator in users-shift-operator.sh. The $# variable returns the input size:\n\nLet’s run the script with the same input as before:\n\nIn this example, we’re shifting the positional parameter in each iteration by one until we reach the end of the input. Therefore, $1 refers to the next element in the input each time.\n\nIn this article, we explored various ways to process the arguments passed to a Bash script during runtime. In particular, we discussed positional parameters and flags, in addition to looping over the input arguments and using the shift operator.\n\nBy employing the techniques discussed in this article, we can create robust and dynamic Bash scripts capable of handling user input effectively.\n\nAs always, the examples used in this article are available over on GitHub."
    }
]