[
    {
        "link": "https://freecodecamp.org/news/how-to-render-lists-in-react",
        "document": "When you're working with React, you will often times need to render lists of items. With the method, you can create new results from your current lists or even showcase all the items in your lists.\n\nIn this tutorial, you will learn how to use this method to access array contents in React. We'll also explore how to pass a list of items into multiple React components using React .\n\nThe JavaScript method works by creating a new array that consists of outcomes from calling a function on the items in your array.\n\nBelow is the array you'll be working with. It contains info about applicants to a mentorship workshop. The array is stored in variable.\n\nNow, you need to return JSX that renders every applicant name as presented from the array.\n\nTo get the names of the applicants, you can easily do that with JavaScript's method. Below is how you can map every applicant's name:\n\nUnfortunately, a quick inspection of our current webpage throws this error about keys:\n\nWhy You Need Keys in Lists\n\nWhile the above code works just fine, a key attribute when handling lists in React is key. The key attribute is very important in uniquely identifying each particular item in the array.\n\nReact assigns every item a unique key attribute and so is able to keep track of them despite any changes. This helps in ensuring that you do not end up messing up your code when changes occur in your lists.\n\nWith the key attribute any changes such as re-ordering, adding, or removing items from the array be can tracked. This is a best practice.\n\nHere is a code demo showing the key attribute at work:\n\nAs you can see, a large set of applicants is smoothly mapped and displayed using a few lines of code.\n\nAt the same time, if you were to delete applicants who did not meet some qualifications, the key attribute would help keep track of the remaining applicants using the unique assigned key.\n\nThis is the expected code output:\n\nIn the above examples, you're only dealing with a single variable.\n\nNow, there will be cases in your work where you will have different files and more than one variable in different React components.\n\nThis is where React come in.\n\nWhat are Props in React?\n\nThe word 'props' stands for properties and they are used to pass data from one component to another. Props are useful in passing data and help you write clean and lightweight code.\n\nThe array we're using has a variable named . You have a new component that showcases the applicants' names, number of websites built, and their respective locations.\n\nHow then do you pass the list to this new component?\n\nYou can easily get the applicants data from the object as shown below:\n\nInside the the component, we included as a local variable. With that we don't pollute the global scope. We then returned a with an tag.\n\nNext, we want to pass the data in the array to a new component that showcases further data about each applicant. With the instantiation, the component accesses the array using the props.\n\nAfter that was done, we used to map the applicants' name, number of websites built, and location which was rendered as JSX. And we didn't forget the important key attribute.\n\nHere is the expected code output:\n\nIn this article you have learned how to use the JavaScript method to render a list of items in React. You also learned how to use React to pass the lists data into other components as well."
    },
    {
        "link": "https://stackoverflow.com/questions/38282997/rendering-an-array-map-in-react",
        "document": "Gosha Arinich is right, you should return your element. But, nevertheless, you should get nasty red warning in the browser console in this case\n\nso, you need to add \"key\" to your list:\n\nor drop the and do a beautiful oneliner, using es6 arrow functions:\n\nThe answer above is solving the current problem, but as Sergey mentioned in the comments: using the key depending on the map index is BAD if you want to do some filtering and sorting. In that case use the if already there, or just generate unique ids for it."
    },
    {
        "link": "https://legacy.reactjs.org/docs/lists-and-keys.html",
        "document": "These docs are old and won’t be updated. Go to react.dev for the new React docs. These new documentation pages teach modern React and include live examples:\n\nFirst, let’s review how you transform lists in JavaScript.\n\nGiven the code below, we use the function to take an array of and double their values. We assign the new array returned by to the variable and log it:\n\nThis code logs to the console.\n\nIn React, transforming arrays into lists of elements is nearly identical.\n\nYou can build collections of elements and include them in JSX using curly braces .\n\nBelow, we loop through the array using the JavaScript function. We return a element for each item. Finally, we assign the resulting array of elements to :\n\nThen, we can include the entire array inside a element:\n\nTry it on CodePen\n\nThis code displays a bullet list of numbers between 1 and 5.\n\nUsually you would render lists inside a component.\n\nWe can refactor the previous example into a component that accepts an array of and outputs a list of elements.\n\nWhen you run this code, you’ll be given a warning that a key should be provided for list items. A “key” is a special string attribute you need to include when creating lists of elements. We’ll discuss why it’s important in the next section.\n\nLet’s assign a to our list items inside and fix the missing key issue.\n\nTry it on CodePen\n\nKeys help React identify which items have changed, are added, or are removed. Keys should be given to the elements inside the array to give the elements a stable identity:\n\nThe best way to pick a key is to use a string that uniquely identifies a list item among its siblings. Most often you would use IDs from your data as keys:\n\nWhen you don’t have stable IDs for rendered items, you may use the item index as a key as a last resort:\n\nWe don’t recommend using indexes for keys if the order of items may change. This can negatively impact performance and may cause issues with component state. Check out Robin Pokorny’s article for an in-depth explanation on the negative impacts of using an index as a key. If you choose not to assign an explicit key to list items then React will default to using indexes as keys.\n\nHere is an in-depth explanation about why keys are necessary if you’re interested in learning more.\n\nKeys only make sense in the context of the surrounding array.\n\nFor example, if you extract a component, you should keep the key on the elements in the array rather than on the element in the itself.\n\nTry it on CodePen\n\nA good rule of thumb is that elements inside the call need keys.\n\nKeys Must Only Be Unique Among Siblings\n\nKeys used within arrays should be unique among their siblings. However, they don’t need to be globally unique. We can use the same keys when we produce two different arrays:\n\nTry it on CodePen\n\nKeys serve as a hint to React but they don’t get passed to your components. If you need the same value in your component, pass it explicitly as a prop with a different name:\n\nWith the example above, the component can read , but not .\n\nIn the examples above we declared a separate variable and included it in JSX:\n\nJSX allows embedding any expression in curly braces so we could inline the result:\n\nTry it on CodePen\n\nSometimes this results in clearer code, but this style can also be abused. Like in JavaScript, it is up to you to decide whether it is worth extracting a variable for readability. Keep in mind that if the body is too nested, it might be a good time to extract a component."
    },
    {
        "link": "https://stackoverflow.com/questions/51848718/best-practice-for-mapping-an-array-in-react-app-for-performance-optimization",
        "document": "I have a simple dictionary app I'm making that returns search results. A search is queried on every of the search field using a lokiJS in-memory database for the dictionary, so the results come very quick.\n\nIt is important for me to optimize the rendering of the results, so that the 50 or so filtered search results keep flowing as the user types and the queries happen on each key stroke.\n\nHere's what I've been doing so far: (this works but is it the best/fastest way?)\n\nEach (sync) query of the database returns an array of objects, which I then map with something like this:\n\nThen, once I have the results mapped like that, I add the mapped components to the state, and then the screen gets rendered with the new results.\n\nI made this when I was just learning React and I understand that people consider it really bad practice to store components in the state.\n\nI was wondering what the best practice in terms of performance optimization would be (and code cleanness). Should I store the results array in state then render then map them into components in the render function? Would that cause any performance hits?\n\nAnother answer said that \"A function in the render method will be created each render which is a slight performance hit.\"\n\nAnd why is it so bad to store components in state? Is it just for code clarity? Keeping the state small? I appreciate your help and patience."
    },
    {
        "link": "https://react.dev/learn/rendering-lists",
        "document": "You will often want to display multiple similar components from a collection of data. You can use the JavaScript array methods to manipulate an array of data. On this page, you’ll use and with React to filter and transform your array of data into an array of components.\n• How to render components from an array using JavaScript’s\n• How to render only specific components using JavaScript’s\n• When and why to use React keys Say that you have a list of content. The only difference among those list items is their contents, their data. You will often need to show several instances of the same component using different data when building interfaces: from lists of comments to galleries of profile images. In these situations, you can store that data in JavaScript objects and arrays and use methods like and to render lists of components from them. Here’s a short example of how to generate a list of items from an array:\n• Move the data into an array:\n• Map the members into a new array of JSX nodes, :\n• Return from your component wrapped in a :\n\nWarning: Each child in a list should have a unique “key” prop. You’ll learn how to fix this error later on this page. Before we get to that, let’s add some structure to your data. This data can be structured even more. Let’s say you want a way to only show people whose profession is . You can use JavaScript’s method to return just those people. This method takes an array of items, passes them through a “test” (a function that returns or ), and returns a new array of only those items that passed the test (returned ). You only want the items where is . The “test” function for this looks like . Here’s how to put it together:\n• Create a new array of just “chemist” people, , by calling on the filtering by :\n• Lastly, return the from your component:\n\nArrow functions implicitly return the expression right after , so you didn’t need a statement: However, you must write explicitly if your is followed by a curly brace! Arrow functions containing are said to have a “block body”. They let you write more than a single line of code, but you have to write a statement yourself. If you forget it, nothing gets returned! Notice that all the sandboxes above show an error in the console: Warning: Each child in a list should have a unique “key” prop. You need to give each array item a — a string or a number that uniquely identifies it among other items in that array: Keys tell React which array item each component corresponds to, so that it can match them up later. This becomes important if your array items can move (e.g. due to sorting), get inserted, or get deleted. A well-chosen helps React infer what exactly has happened, and make the correct updates to the DOM tree. Rather than generating keys on the fly, you should include them in your data:\n\nDisplaying several DOM nodes for each list item What do you do when each item needs to render not one, but several DOM nodes? The short Fragment syntax won’t let you pass a key, so you need to either group them into a single , or use the slightly longer and more explicit syntax: Fragments disappear from the DOM, so this will produce a flat list of , , , , and so on. Where to get your Different sources of data provide different sources of keys:\n• Data from a database: If your data is coming from a database, you can use the database keys/IDs, which are unique by nature.\n• Locally generated data: If your data is generated and persisted locally (e.g. notes in a note-taking app), use an incrementing counter, or a package like when creating items.\n• Keys must be unique among siblings. However, it’s okay to use the same keys for JSX nodes in different arrays.\n• Keys must not change or that defeats their purpose! Don’t generate them while rendering. Why does React need keys? Imagine that files on your desktop didn’t have names. Instead, you’d refer to them by their order — the first file, the second file, and so on. You could get used to it, but once you delete a file, it would get confusing. The second file would become the first file, the third file would be the second file, and so on. File names in a folder and JSX keys in an array serve a similar purpose. They let us uniquely identify an item between its siblings. A well-chosen key provides more information than the position within the array. Even if the position changes due to reordering, the lets React identify the item throughout its lifetime. You might be tempted to use an item’s index in the array as its key. In fact, that’s what React will use if you don’t specify a at all. But the order in which you render items will change over time if an item is inserted, deleted, or if the array gets reordered. Index as a key often leads to subtle and confusing bugs. Similarly, do not generate keys on the fly, e.g. with . This will cause keys to never match up between renders, leading to all your components and DOM being recreated every time. Not only is this slow, but it will also lose any user input inside the list items. Instead, use a stable ID based on the data. Note that your components won’t receive as a prop. It’s only used as a hint by React itself. If your component needs an ID, you have to pass it as a separate prop: . On this page you learned:\n• How to move data out of components and into data structures like arrays and objects.\n• How to generate sets of similar components with JavaScript’s .\n• How to create arrays of filtered items with JavaScript’s .\n• Why and how to set on each component in a collection so React can keep track of each of them even if their position or data changes."
    },
    {
        "link": "https://legacy.reactjs.org/docs/lists-and-keys.html",
        "document": "These docs are old and won’t be updated. Go to react.dev for the new React docs. These new documentation pages teach modern React and include live examples:\n\nFirst, let’s review how you transform lists in JavaScript.\n\nGiven the code below, we use the function to take an array of and double their values. We assign the new array returned by to the variable and log it:\n\nThis code logs to the console.\n\nIn React, transforming arrays into lists of elements is nearly identical.\n\nYou can build collections of elements and include them in JSX using curly braces .\n\nBelow, we loop through the array using the JavaScript function. We return a element for each item. Finally, we assign the resulting array of elements to :\n\nThen, we can include the entire array inside a element:\n\nTry it on CodePen\n\nThis code displays a bullet list of numbers between 1 and 5.\n\nUsually you would render lists inside a component.\n\nWe can refactor the previous example into a component that accepts an array of and outputs a list of elements.\n\nWhen you run this code, you’ll be given a warning that a key should be provided for list items. A “key” is a special string attribute you need to include when creating lists of elements. We’ll discuss why it’s important in the next section.\n\nLet’s assign a to our list items inside and fix the missing key issue.\n\nTry it on CodePen\n\nKeys help React identify which items have changed, are added, or are removed. Keys should be given to the elements inside the array to give the elements a stable identity:\n\nThe best way to pick a key is to use a string that uniquely identifies a list item among its siblings. Most often you would use IDs from your data as keys:\n\nWhen you don’t have stable IDs for rendered items, you may use the item index as a key as a last resort:\n\nWe don’t recommend using indexes for keys if the order of items may change. This can negatively impact performance and may cause issues with component state. Check out Robin Pokorny’s article for an in-depth explanation on the negative impacts of using an index as a key. If you choose not to assign an explicit key to list items then React will default to using indexes as keys.\n\nHere is an in-depth explanation about why keys are necessary if you’re interested in learning more.\n\nKeys only make sense in the context of the surrounding array.\n\nFor example, if you extract a component, you should keep the key on the elements in the array rather than on the element in the itself.\n\nTry it on CodePen\n\nA good rule of thumb is that elements inside the call need keys.\n\nKeys Must Only Be Unique Among Siblings\n\nKeys used within arrays should be unique among their siblings. However, they don’t need to be globally unique. We can use the same keys when we produce two different arrays:\n\nTry it on CodePen\n\nKeys serve as a hint to React but they don’t get passed to your components. If you need the same value in your component, pass it explicitly as a prop with a different name:\n\nWith the example above, the component can read , but not .\n\nIn the examples above we declared a separate variable and included it in JSX:\n\nJSX allows embedding any expression in curly braces so we could inline the result:\n\nTry it on CodePen\n\nSometimes this results in clearer code, but this style can also be abused. Like in JavaScript, it is up to you to decide whether it is worth extracting a variable for readability. Keep in mind that if the body is too nested, it might be a good time to extract a component."
    },
    {
        "link": "https://react.dev/learn/rendering-lists",
        "document": "You will often want to display multiple similar components from a collection of data. You can use the JavaScript array methods to manipulate an array of data. On this page, you’ll use and with React to filter and transform your array of data into an array of components.\n• How to render components from an array using JavaScript’s\n• How to render only specific components using JavaScript’s\n• When and why to use React keys Say that you have a list of content. The only difference among those list items is their contents, their data. You will often need to show several instances of the same component using different data when building interfaces: from lists of comments to galleries of profile images. In these situations, you can store that data in JavaScript objects and arrays and use methods like and to render lists of components from them. Here’s a short example of how to generate a list of items from an array:\n• Move the data into an array:\n• Map the members into a new array of JSX nodes, :\n• Return from your component wrapped in a :\n\nWarning: Each child in a list should have a unique “key” prop. You’ll learn how to fix this error later on this page. Before we get to that, let’s add some structure to your data. This data can be structured even more. Let’s say you want a way to only show people whose profession is . You can use JavaScript’s method to return just those people. This method takes an array of items, passes them through a “test” (a function that returns or ), and returns a new array of only those items that passed the test (returned ). You only want the items where is . The “test” function for this looks like . Here’s how to put it together:\n• Create a new array of just “chemist” people, , by calling on the filtering by :\n• Lastly, return the from your component:\n\nArrow functions implicitly return the expression right after , so you didn’t need a statement: However, you must write explicitly if your is followed by a curly brace! Arrow functions containing are said to have a “block body”. They let you write more than a single line of code, but you have to write a statement yourself. If you forget it, nothing gets returned! Notice that all the sandboxes above show an error in the console: Warning: Each child in a list should have a unique “key” prop. You need to give each array item a — a string or a number that uniquely identifies it among other items in that array: Keys tell React which array item each component corresponds to, so that it can match them up later. This becomes important if your array items can move (e.g. due to sorting), get inserted, or get deleted. A well-chosen helps React infer what exactly has happened, and make the correct updates to the DOM tree. Rather than generating keys on the fly, you should include them in your data:\n\nDisplaying several DOM nodes for each list item What do you do when each item needs to render not one, but several DOM nodes? The short Fragment syntax won’t let you pass a key, so you need to either group them into a single , or use the slightly longer and more explicit syntax: Fragments disappear from the DOM, so this will produce a flat list of , , , , and so on. Where to get your Different sources of data provide different sources of keys:\n• Data from a database: If your data is coming from a database, you can use the database keys/IDs, which are unique by nature.\n• Locally generated data: If your data is generated and persisted locally (e.g. notes in a note-taking app), use an incrementing counter, or a package like when creating items.\n• Keys must be unique among siblings. However, it’s okay to use the same keys for JSX nodes in different arrays.\n• Keys must not change or that defeats their purpose! Don’t generate them while rendering. Why does React need keys? Imagine that files on your desktop didn’t have names. Instead, you’d refer to them by their order — the first file, the second file, and so on. You could get used to it, but once you delete a file, it would get confusing. The second file would become the first file, the third file would be the second file, and so on. File names in a folder and JSX keys in an array serve a similar purpose. They let us uniquely identify an item between its siblings. A well-chosen key provides more information than the position within the array. Even if the position changes due to reordering, the lets React identify the item throughout its lifetime. You might be tempted to use an item’s index in the array as its key. In fact, that’s what React will use if you don’t specify a at all. But the order in which you render items will change over time if an item is inserted, deleted, or if the array gets reordered. Index as a key often leads to subtle and confusing bugs. Similarly, do not generate keys on the fly, e.g. with . This will cause keys to never match up between renders, leading to all your components and DOM being recreated every time. Not only is this slow, but it will also lose any user input inside the list items. Instead, use a stable ID based on the data. Note that your components won’t receive as a prop. It’s only used as a hint by React itself. If your component needs an ID, you have to pass it as a separate prop: . On this page you learned:\n• How to move data out of components and into data structures like arrays and objects.\n• How to generate sets of similar components with JavaScript’s .\n• How to create arrays of filtered items with JavaScript’s .\n• Why and how to set on each component in a collection so React can keep track of each of them even if their position or data changes."
    },
    {
        "link": "https://codedamn.com/news/reactjs/why-is-the-key-prop-important-when-rendering-lists",
        "document": "Understanding the efficiency of rendering in React is crucial for anyone seeking optimal performance in their applications. As the UI updates, React ensures that minimal computational resources are utilized, resulting in smooth user experiences. This magic of efficient rendering, however, is closely tied with the correct use of the prop, especially when rendering lists.\n\nTo grasp the significance of the prop, let’s first familiarize ourselves with a few foundational React concepts: JSX, the React element tree, and reconciliation.\n\nJSX, or JavaScript XML, is a syntax extension for JavaScript. It allows developers to write UI structures in a manner similar to HTML but within their JavaScript code. This combination of JavaScript and markup provides a more intuitive and readable way to define component structures. For example:\n\nThe above code isn’t typical HTML or JavaScript. Instead, it’s JSX. During the build process, tools like Babel compile JSX down to standard JavaScript, ensuring browsers can understand and render the content.\n\nMore about JSX can be found in the official React documentation.\n\nWhen you create components in React, you’re effectively constructing a tree of elements, often referred to as the React element tree or Virtual DOM. Each component might contain other components or native HTML elements, forming a hierarchy. This tree representation allows React to manage updates and render efficiently, ensuring only the changed parts of the UI are redrawn.\n\nReconciliation is the process React uses to determine changes in the React element tree (or the Virtual DOM). When a component’s state or props change, React creates a new tree and then compares it with the previous one. Through this comparison, React identifies what changed and subsequently updates only the necessary parts of the real DOM. This diffing mechanism is what makes React apps incredibly responsive and efficient.\n\nWhat is the key prop?\n\nAs we venture further into rendering lists, we’ll see how the prop plays an instrumental role in the process.\n\nIn React, the prop is a special attribute you should assign to elements within arrays to give each element a stable identity. When creating lists, for instance, you might use the function:\n\nUnlike other props in React, the prop isn’t accessible in your component’s object. It’s strictly used by React to track changes within lists or arrays. By giving each item a unique key, React can quickly determine if an item has been added, removed, or changed, making the rendering process efficient.\n\nThe prop isn’t just a requirement—it’s a critical tool in React’s optimization strategy, especially during reconciliation.\n\nFor React to perform efficient updates, it must have a way to identify elements from one render to the next. This identification is achieved through keys. Without a stable identity (like one provided by the prop), React’s reconciliation process becomes less predictable, and unnecessary re-renders may occur.\n\nWhen comparing the new tree with the old one, React relies on these keys to determine:\n• Which items have been removed or added.\n\nBy explicitly defining keys for list items, you ensure that React doesn’t waste time and resources redrawing unchanged items. Instead, it can focus solely on updating, adding, or removing the changed ones.\n\nImplications of Not Using key props in Lists\n\nWhen developing applications with React, particularly those that display lists or arrays of data, the prop becomes vital. Not utilizing this prop correctly can lead to a slew of issues. Let’s delve into these implications.\n\nReact utilizes a diffing algorithm to update the DOM in the most efficient way possible. This involves comparing the current virtual DOM with the new virtual DOM. When elements in a list do not have a unique , React has to work harder to determine which elements have changed. This can lead to suboptimal updates, reducing the overall performance of your application.\n\nThe main purpose of the prop is to ensure that the state is tied to a specific component instance. Without it, React might recycle a component instance and reuse its state in a different place, leading to unexpected behavior. Essentially, you might end up with a component that maintains a state from a previous component.\n\nIn the absence of a or with an improperly assigned key, React might mismatch elements. This can lead to bugs that are tricky to debug because the rendered list appears correct, but the underlying components might be in the wrong order or be associated with incorrect data.\n\nWhile the prop is crucial, it’s not without its pitfalls when misused.\n\nA frequent mistake is using the index of an array as a key. This seems intuitive and straightforward, but it can cause issues when the list changes over time, especially with additions, deletions, or reorderings.\n\nKeys should be consistent between renders. Utilizing dynamic values, like Math.random(), can lead to unexpected behaviors as React won’t be able to track and manage the components efficiently.\n\nKeys should be assigned directly within the map callback to ensure React can identify each element distinctly.\n\nThe prop, when used correctly, can optimize the performance and predictability of your React application.\n\nWhen available, always use a unique identifier from your data as a key. If you’re rendering a list of users, for example, the user’s ID would be ideal.\n\nWhen Using Index Might Be Appropriate\n\nThere are scenarios where using an index as a key is acceptable, like when the list is static and won’t undergo changes in order or content.\n\nMore than Just Lists: Other Scenarios for key prop\n\nThe prop isn’t exclusive to lists. It’s versatile and can play a crucial role in other dynamic UI scenarios.\n\nIn applications where the UI is dynamic and components can mount or unmount based on user actions, the prop ensures consistent and expected behavior.\n\nChanging the prop can force a component to re-mount, resetting its internal state and effects. This is a powerful technique but should be used judiciously.\n\nReact provides mechanisms to warn developers about issues, and there are tools to further assist in this area.\n\nReact’s developer console will often warn you if you neglect to provide a prop where it’s needed, or if there are duplicate keys.\n\nTools like React DevTools for Chrome and Firefox can aid in visualizing component trees and identifying where keys are missing or duplicated.\n\nLearning through examples can be illuminating.\n\nFor platforms like codedamn, where interactive coding challenges and lessons are the norm, utilizing the correct prop ensures that each rendered code block, user interface element, or feedback message retains its proper state and behavior.\n\nOn the flip side, a misconfigured on a platform like codedamn could lead to users experiencing glitches, like a previously solved challenge showing as unsolved or vice versa.\n\nThe prop is an indispensable part of React’s performance optimizations. By understanding its significance, avoiding common pitfalls, and using tools at our disposal, developers can ensure smooth, efficient, and predictable application behavior.\n\nFor a more in-depth exploration of the prop and other related concepts, consider the following resources:\n• Official React Documentation on Lists and Keys"
    },
    {
        "link": "https://developerway.com/posts/react-key-attribute",
        "document": "React “key” attribute is probably one of the most “autopilot” used features in React 😅 Who among us honestly can say that they use it because of “…some valid reasons”, rather than “because eslint rule complained at me”. And I suspect most people when faced with the question “why does React need “key” attribute” will answer something like “errr… we’re supposed to put unique values there so that React can recognise list items, it’s better for performance”. And technically this answer is correct. Sometimes.\n\nBut what exactly does it mean “recognise items”? What will happen if I skip the “key” attribute? Will the app blow up? What if I put a random string there? How unique the value should be? Can I just use array’s index values there? What are the implications of those choices? How exactly do any of them impact performance and why?\n\nFirst of all, before jumping into coding, let’s figure out the theory: what the “key” attribute is and why React needs it.\n\nIn short, if the “key” attribute is present, React uses it as a way to identify an element of the same type among its siblings during re-renders (see the docs: https://reactjs.org/docs/lists-and-keys.html and https://reactjs.org/docs/reconciliation.html#recursing-on-children).In other words, it’s needed only during re-renders and for neighbouring elements of the same type, i.e. flat lists (this is important!).\n\nA simplified algorithm of the process during re-render looks like this:\n• first, React will generate the “before” and “after” “snapshots” of the elements\n• second, it will try to identify those elements that already existed on the page, so that it can re-use them instead of creating them from scratch\n• if the “key” attribute exists, it will assume that items with the same “before” and “after” key are the same\n• if the “key” attribute doesn’t exist, it will just use sibling’s indexes as the default “key”\n• third, it will:\n• get rid of the items that existed in the “before” phase, but don’t exist in the “after” (i.e. unmount them)\n• create from scratch items that haven’t existed in the “before” variant (i.e. mount them)\n• update items that existed “before” and continue to exist “after” (i.e. re-render them)\n\nIt’s much easier to understand when you play with code a little bit, so let’s do that as well.\n\nLet’s implement a list of countries first. We’ll have an component, that renders the country’s info:\n\nand a component that renders the actual list:\n\nNow, I don’t have the “key” attribute on my items at the moment. So what will happen when the component re-renders?\n• React will see that there is no “key” there and fall back to using the array’s indexes as keys\n• our array hasn’t changed, so all items will be identified as “already existed”, and the items will be re-rendered\n\nEssentially, it will be no different than adding to the explicitly\n\nIn short: when component re-renders, every will re-render as well. And if we wrap in , we even can get rid of those unnecessary re-renders and improve the performance of our list component.\n\nNow the fun part: what if, instead of indexes, we add some random strings to the “key” attribute?\n• on every re-render of , React will re-generate the “key” attributes\n• since the “key” attribute is present, React will use it as a way to identify “existing” elements\n• since all “key” attributes will be new, all items “before” will be considered as “removed”, every will be considered as “new”, and React will unmount all items and mount them back again\n\nIn short: when component re-renders, every will be destroyed and re-created from scratch.\n\nAnd re-mounting of components is much, much more expensive, compared to the simple re-render when we talk about performance. Also, all performance improvements from wrapping items in will go away - memoisation won’t work since items are re-created on every re-render.\n\nTake a look at the above examples in the codesandbox. Click on buttons to re-render and pay attention to the console output. Throttle your CPU a little, and the delay when you click the button will be visible even with the naked eye!\n\nIn Chrome developer tools open “Performance” tab, click the “cogwheel” icon on the top right - it will open an additional panel, with “CPU throttling” as one of the options.\n\nWhy “index” as a “key” attribute is not a good idea\n\nBy now it should be obvious, why we need stable “key” attributes, that persist between re-renders. But what about array’s “index”? Even in the official docs, they are not recommended, with the reasoning that they can cause bugs and performance implications. But what exactly is happening that can cause such consequences when we’re using “index” instead of some unique ?\n\nFirst of all, we won't see any of this in the example above. All those bugs and performance implications only happen in “dynamic” lists - lists, where the order or number of the items can change between re-renders. To imitate this, let’s implement sorting functionality for our list:\n\nEvery time I click the button the array’s order is reversed. And I’m going to implement the list in two variants, with as a key:\n\nAnd going to memoise component right away for performance purposes:\n\nHere is the codesandbox with the full implementation. Click on the sorting buttons with throttled CPU, notice how \"index\"-based list is slightly slower, and pay attention to the console output: in the \"index\"-based list every item re-renders on every button click, even though is memoised and technically shouldn’t do that. The \"id\"-based implementation, exactly the same as “key”-based except for the key value, doesn’t have this problem: no items are re-rendered after the button’s click, and the console output is clean.\n\nWhy is this happening? The secret is the “key” value of course:\n• React generates “before” and “after” list of elements and tries to identify items that are “the same”\n• from React’s perspective, the “same” items are the items that have the same keys\n• in “index”-based implementation, the first item in the array will always have , the second one will have , etc, etc - regardless of the sorting of the array\n\nSo, when React does the comparison, when it sees the item with the in both “before” and “after” lists, it thinks that it’s exactly the same item, only with a different props value: value has changed after we reversed the array. And therefore it does what it should do for the same item: triggers its re-render cycle. And since it thinks that the prop value has changed, it will bypass the memo function, and trigger the actual item’s re-render.\n\nThe id-based behaviour is correct and performant: items are recognized accurately, and every item is memoised, so no component is re-rendered.\n\nThis behaviour is going to be especially visible if we introduce some state to the Item component. Let’s, for example, change its background when it’s clicked:\n\nTake a look at the same codesandbox, only this time click on a few countries first, to trigger the background change, and only then click the “sort” button.\n\nThe id-based list behaves exactly as you’d expect. But the index-based list now behaves funny: if I click on the first item in the list, and then click sort - the first item stays selected, regardless of the sorting. And this is the symptom of the behaviour described above: React thinks that the item with (first item in the array) is exactly the same before and after the state change, so it re-uses the same component instance, keeps the state as it was (i.e. set to for this item), and just updates the props values (from the first country to the last country).\n\nAnd exactly the same thing will happen, if instead of sorting we’ll add an item at the start of the array: React will think that the item with (first item) stays the same, and the last item is the new one. So if the first item is selected, in the index-based list the selection will stay at the first item, every item will re-render, and the “mount” even will be triggered for the last item. In the id-based list, only the newly added item will be mounted and rendered, the rest will sit there quietly. Check it out in the codesandbox. Throttle your CPU, and the delay of adding a new item in the index-based list is yet again visible with the naked eye! The id-based list is blazing fast even with the 6x CPU throttle.\n\nWhy “index” as a “key” attribute IS a good idea\n\nAfter the previous sections it’s easy to say “just always use a unique item for “key” attribute”, isn’t it? And for most cases it’s true and if you use all the time nobody will probably notice or mind. But when you have the knowledge, you have superpowers. Now, since we know what exactly is happening when React renders lists, we can cheat and make some lists even faster with instead of .\n\nA typical scenario: paginated list. You have a limited number of items in a list, you click on a button - and you want to show different items of the same type in the same size list. If you go with approach, then every time you change the page you’ll load completely new set of items with completely different ids. Which means React won’t be able to find any “existing” items, unmount the entire list, and mount completely fresh set of items. But! If you go with approach, React will think that all the items on the new “page” already existed, and will just update those items with the fresh data, leaving the actual components mounted. This is going to be visibly faster even on relatively small data sets, if item components are complicated.\n\nTake a look at this example in the codesandbox. Pay attention to the console output - when you switch pages in the “id\"-based list on the right, every item is re-mounted. But in “index\"-based list on the left items are only re-rendered. Much faster! With throttled CPU, even with 50 items very simple list (just a text and an image), the difference between switching pages in the “id\"-based list and “index\"-based list is already visible.\n\nAnd exactly the same situation is going to be with all sorts of dynamic list-like data, where you replace your existing items with the new data set while preserving the list-like appearance: autocomplete components, google-like search pages, paginated tables. Just would need to be mindful about introducing state in those items: they would have to be either stateless, or state should be synced with props.\n\nAll the keys are in the right places!\n\nThat is all for today! Hope you liked the read and have a better understanding now of how React “key” attribute works, how to use it correctly, and even how to bend its rules to your will and cheat your way through the performance game.\n\nA few key takeaways to leave with:\n• never use random value in the “key” attribute: it will cause the item to re-mount on every render. Unless of course, this is your intention\n• there is no harm in using the array’s index as “key” in “static” lists - those whose items number and order stay the same\n• use item unique identifier (“id”) as “key” when the list can be re-sorted or items can be added in random places\n• you can use the array’s index as “key” for dynamic lists with stateless items, where items are replaced with the new ones - paginated lists, search and autocomplete results and the like. This will improve the list’s performance.\n\nHave a great day, and may your list items never re-render unless you explicitly told them so! ✌🏼\n\nAlso, check out the YouTube video that explains content of the article using some pretty animations:"
    },
    {
        "link": "https://stackoverflow.com/questions/77061694/when-rendering-lists-in-react-should-i-always-be-giving-elements-a-key-or-can",
        "document": "React tells us why it's important for lists to have keys when they're being rendered, and this makes sense for actual lists of data.\n\nHowever, for example, we sometimes end up with arrays of components as props.\n\nAssume we have the following component which takes an prop which is an array of components, and we'll assume each component in the array doesn't have a prop:\n\nis only ever going to be a small collection of buttons like / .\n\nas it is will render with warnings since we're rendering a list and its items don't have a .\n\nThere are two things we could do:\n• Give each item in the array a key\n\nBoth options get rid of the warning, but my question is whether spreading arrays here like this is okay in some scenarios or if we should be giving items in an array a ?\n\nI can see arguments both ways, since on one hand we've got a list and should try and use it like a list properly.\n\nOn the other hand, it's not really a list. If wasn't a prop but something defined within and it was just two buttons and then we'd almost certainly render them as two consecutive buttons and not an array of buttons. We're also not going to do list-y things to the array such as sort it or modify it as mentioned in the React docs\n\nI'm interested in what others think about this - are there classes of lists where we can ignore needing a and just spread the array when rendering it?"
    }
]